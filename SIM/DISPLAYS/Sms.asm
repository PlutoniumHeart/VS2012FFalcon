; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DISPLAYS\Sms.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?aim9LastRunTime@@3KA				; aim9LastRunTime
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?aim9LastRunTime@@3KA DD 01H DUP (?)			; aim9LastRunTime
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
_DATA	SEGMENT
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?SetYPR@VuEntity@@QAEXMMM@Z			; VuEntity::SetYPR
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z	; DrawableObject::GetPosition
PUBLIC	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
PUBLIC	??0?$VuBin@VSimWeaponClass@@@@QAE@ABV0@@Z	; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
PUBLIC	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
PUBLIC	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z	; VuBin<SimWeaponClass>::operator=
PUBLIC	??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator!
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
PUBLIC	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
PUBLIC	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset
PUBLIC	?SetHPId@BasicWeaponStation@@QAEXH@Z		; BasicWeaponStation::SetHPId
PUBLIC	??1AList@@QAE@XZ				; AList::~AList
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?GetSType@SimBaseClass@@QBEEXZ			; SimBaseClass::GetSType
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?GetDOFValue@SimMoverClass@@QAEMH@Z		; SimMoverClass::GetDOFValue
PUBLIC	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ	; SimWeaponClass::GetNextOnRail
PUBLIC	?SetRackSlot@SimWeaponClass@@QAEXH@Z		; SimWeaponClass::SetRackSlot
PUBLIC	?GetRackSlot@SimWeaponClass@@QAEHXZ		; SimWeaponClass::GetRackSlot
PUBLIC	?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetDgftSubMode
PUBLIC	?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetMrmSubMode
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?PlayerFCC@FireControlComputer@@QAEHXZ		; FireControlComputer::PlayerFCC
PUBLIC	??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z ; SMSBaseClass::SMSBaseClass
PUBLIC	??1SMSBaseClass@@UAE@XZ				; SMSBaseClass::~SMSBaseClass
PUBLIC	?AddWeaponGraphics@SMSBaseClass@@UAEXXZ		; SMSBaseClass::AddWeaponGraphics
PUBLIC	?FreeWeaponGraphics@SMSBaseClass@@UAEXXZ	; SMSBaseClass::FreeWeaponGraphics
PUBLIC	?GetCurrentWeapon@SMSBaseClass@@UAEPAVSimWeaponClass@@XZ ; SMSBaseClass::GetCurrentWeapon
PUBLIC	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z	; SMSBaseClass::GetGun
PUBLIC	?GetMissile@SMSBaseClass@@QAEPAVMissileClass@@H@Z ; SMSBaseClass::GetMissile
PUBLIC	?GetBomb@SMSBaseClass@@QAEPAVBombClass@@H@Z	; SMSBaseClass::GetBomb
PUBLIC	?GetCurrentWeaponType@SMSBaseClass@@QAE?AW4WeaponType@@XZ ; SMSBaseClass::GetCurrentWeaponType
PUBLIC	?GetCurrentWeaponIndex@SMSBaseClass@@QAEFXZ	; SMSBaseClass::GetCurrentWeaponIndex
PUBLIC	?GetCurrentWeaponRangeFeet@SMSBaseClass@@QAEMXZ	; SMSBaseClass::GetCurrentWeaponRangeFeet
PUBLIC	?LaunchWeapon@SMSBaseClass@@QAEXXZ		; SMSBaseClass::LaunchWeapon
PUBLIC	?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSBaseClass::DetachWeapon
PUBLIC	?StationOK@SMSBaseClass@@QAEHH@Z		; SMSBaseClass::StationOK
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
PUBLIC	?StepMasterArm@SMSBaseClass@@QAEXXZ		; SMSBaseClass::StepMasterArm
PUBLIC	?StepCatIII@SMSBaseClass@@QAEXXZ		; SMSBaseClass::StepCatIII
PUBLIC	?SetFlag@SMSBaseClass@@QAEXH@Z			; SMSBaseClass::SetFlag
PUBLIC	?ClearFlag@SMSBaseClass@@QAEXH@Z		; SMSBaseClass::ClearFlag
PUBLIC	?IsSet@SMSBaseClass@@QAEHH@Z			; SMSBaseClass::IsSet
PUBLIC	?GetWeaponRangeFeet@SMSBaseClass@@QAEMH@Z	; SMSBaseClass::GetWeaponRangeFeet
PUBLIC	?SelectBestWeapon@SMSBaseClass@@QAEXPAEHHHH@Z	; SMSBaseClass::SelectBestWeapon
PUBLIC	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z		; SMSBaseClass::StepMavSubMode
PUBLIC	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ	; SMSBaseClass::GetHARMPowerState
PUBLIC	?GetHARMInitTimer@SMSBaseClass@@QAEMXZ		; SMSBaseClass::GetHARMInitTimer
PUBLIC	??_GSMSBaseClass@@UAEPAXI@Z			; SMSBaseClass::`scalar deleting destructor'
PUBLIC	?ReleaseCurWeapon@SMSClass@@IAEXH@Z		; SMSClass::ReleaseCurWeapon
PUBLIC	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
PUBLIC	?SetupHardpointImage@SMSClass@@IAEXPAVBasicWeaponStation@@H@Z ; SMSClass::SetupHardpointImage
PUBLIC	??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z	; SMSClass::SMSClass
PUBLIC	??1SMSClass@@UAE@XZ				; SMSClass::~SMSClass
PUBLIC	?AddWeaponGraphics@SMSClass@@UAEXXZ		; SMSClass::AddWeaponGraphics
PUBLIC	?FreeWeaponGraphics@SMSClass@@UAEXXZ		; SMSClass::FreeWeaponGraphics
PUBLIC	?GetCurrentWeapon@SMSClass@@UAEPAVSimWeaponClass@@XZ ; SMSClass::GetCurrentWeapon
PUBLIC	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon
PUBLIC	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z	; SMSClass::SetWeaponType
PUBLIC	?IncrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z ; SMSClass::IncrementStores
PUBLIC	?DecrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z ; SMSClass::DecrementStores
PUBLIC	?SelectiveJettison@SMSClass@@QAEXXZ		; SMSClass::SelectiveJettison
PUBLIC	?EmergencyJettison@SMSClass@@QAEXXZ		; SMSClass::EmergencyJettison
PUBLIC	?JettisonWeapon@SMSClass@@QAEXH@Z		; SMSClass::JettisonWeapon
PUBLIC	?RemoveWeapon@SMSClass@@QAEXH@Z			; SMSClass::RemoveWeapon
PUBLIC	?AGJettison@SMSClass@@QAEXXZ			; SMSClass::AGJettison
PUBLIC	?TankJettison@SMSClass@@QAEXXZ			; SMSClass::TankJettison
PUBLIC	?WeaponStep@SMSClass@@QAEHH@Z			; SMSClass::WeaponStep
PUBLIC	?FindWeapon@SMSClass@@QAEHH@Z			; SMSClass::FindWeapon
PUBLIC	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
PUBLIC	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z	; SMSClass::FindWeaponType
PUBLIC	?SetUnlimitedGuns@SMSClass@@QAEXH@Z		; SMSClass::SetUnlimitedGuns
PUBLIC	?UnlimitedAmmo@SMSClass@@QAEHXZ			; SMSClass::UnlimitedAmmo
PUBLIC	?SetUnlimitedAmmo@SMSClass@@QAEXH@Z		; SMSClass::SetUnlimitedAmmo
PUBLIC	?HasTrainable@SMSClass@@QAEHXZ			; SMSClass::HasTrainable
PUBLIC	?HasWeaponClass@SMSClass@@QAEHW4WeaponClass@@@Z	; SMSClass::HasWeaponClass
PUBLIC	?FreeWeapons@SMSClass@@QAEXXZ			; SMSClass::FreeWeapons
PUBLIC	?Exec@SMSClass@@QAEXXZ				; SMSClass::Exec
PUBLIC	?SetPlayerSMS@SMSClass@@QAEXH@Z			; SMSClass::SetPlayerSMS
PUBLIC	?IncrementRippleCount@SMSClass@@QAEXXZ		; SMSClass::IncrementRippleCount
PUBLIC	?DecrementRippleCount@SMSClass@@QAEXXZ		; SMSClass::DecrementRippleCount
PUBLIC	?SetRippleInterval@SMSClass@@QAEXH@Z		; SMSClass::SetRippleInterval
PUBLIC	?IncrementRippleInterval@SMSClass@@QAEXXZ	; SMSClass::IncrementRippleInterval
PUBLIC	?DecrementRippleInterval@SMSClass@@QAEXXZ	; SMSClass::DecrementRippleInterval
PUBLIC	?IncrementBurstHeight@SMSClass@@QAEXXZ		; SMSClass::IncrementBurstHeight
PUBLIC	?DecrementBurstHeight@SMSClass@@QAEXXZ		; SMSClass::DecrementBurstHeight
PUBLIC	?Incrementarmingdelay@SMSClass@@QAEXXZ		; SMSClass::Incrementarmingdelay
PUBLIC	?ResetCurrentWeapon@SMSClass@@QAEXXZ		; SMSClass::ResetCurrentWeapon
PUBLIC	?GetNextWeapon@SMSClass@@QAE?AW4WeaponType@@W4WeaponDomain@@@Z ; SMSClass::GetNextWeapon
PUBLIC	?SelectWeapon@SMSClass@@QAEXW4WeaponType@@W4WeaponDomain@@@Z ; SMSClass::SelectWeapon
PUBLIC	?RemoveStore@SMSClass@@QAEXHH@Z			; SMSClass::RemoveStore
PUBLIC	?AddStore@SMSClass@@QAEXHHH@Z			; SMSClass::AddStore
PUBLIC	?ChooseLimiterMode@SMSClass@@QAEXH@Z		; SMSClass::ChooseLimiterMode
PUBLIC	?RipOffWeapons@SMSClass@@QAEXM@Z		; SMSClass::RipOffWeapons
PUBLIC	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ	; SMSClass::GetCoolState
PUBLIC	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z	; SMSClass::SetCoolState
PUBLIC	?GetCurrentWeaponId@SMSClass@@QAEHXZ		; SMSClass::GetCurrentWeaponId
PUBLIC	?SetCurrentHpByWeaponId@SMSClass@@QAEHH@Z	; SMSClass::SetCurrentHpByWeaponId
PUBLIC	?StepAAWeapon@SMSClass@@QAEXXZ			; SMSClass::StepAAWeapon
PUBLIC	?StepAGWeapon@SMSClass@@QAEXXZ			; SMSClass::StepAGWeapon
PUBLIC	?StepWeaponByID@SMSClass@@QAEXXZ		; SMSClass::StepWeaponByID
PUBLIC	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z		; SMSClass::SetCurrentHardPoint
PUBLIC	?GetAGBRippleCount@SMSClass@@QAEHXZ		; SMSClass::GetAGBRippleCount
PUBLIC	?GetAGBRippleInterval@SMSClass@@QAEHXZ		; SMSClass::GetAGBRippleInterval
PUBLIC	?GetAGBPair@SMSClass@@QAE_NXZ			; SMSClass::GetAGBPair
PUBLIC	?SetAGBRippleCount@SMSClass@@QAEXH@Z		; SMSClass::SetAGBRippleCount
PUBLIC	?SetAGBRippleInterval@SMSClass@@QAEXH@Z		; SMSClass::SetAGBRippleInterval
PUBLIC	?SetAGBBurstAlt@SMSClass@@QAEXH@Z		; SMSClass::SetAGBBurstAlt
PUBLIC	??_GSMSClass@@UAEPAXI@Z				; SMSClass::`scalar deleting destructor'
PUBLIC	?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z ; InitWeaponList
PUBLIC	?SetLaunchRotation@MissileClass@@QAEXMM@Z	; MissileClass::SetLaunchRotation
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	?MaxGs@AirframeClass@@QAEMXZ			; AirframeClass::MaxGs
PUBLIC	?MaxVcas@AirframeClass@@QAEMXZ			; AirframeClass::MaxVcas
PUBLIC	?ExternalFuel@AirframeClass@@QAEMXZ		; AirframeClass::ExternalFuel
PUBLIC	?VehicleIndex@AirframeClass@@QAEHXZ		; AirframeClass::VehicleIndex
PUBLIC	?SetFlag@AirframeClass@@QAEXH@Z			; AirframeClass::SetFlag
PUBLIC	?ClearFlag@AirframeClass@@QAEXH@Z		; AirframeClass::ClearFlag
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?GetRackGroup@AirframeClass@@QAEHH@Z		; AirframeClass::GetRackGroup
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?SetScanDir@RadarDopplerClass@@QAEXM@Z		; RadarDopplerClass::SetScanDir
PUBLIC	?NextACHp@@YAHHH@Z				; NextACHp
PUBLIC	?CompareWith@WeaponStepNode@@EAEHPAVANode@@@Z	; WeaponStepNode::CompareWith
PUBLIC	??0WeaponStepNode@@QAE@XZ			; WeaponStepNode::WeaponStepNode
PUBLIC	??1WeaponStepNode@@QAE@XZ			; WeaponStepNode::~WeaponStepNode
PUBLIC	??_GWeaponStepNode@@QAEPAXI@Z			; WeaponStepNode::`scalar deleting destructor'
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_7SMSBaseClass@@6B@				; SMSBaseClass::`vftable'
PUBLIC	??_7SMSClass@@6B@				; SMSClass::`vftable'
PUBLIC	??_C@_0CF@JFLIKKKJ@Vehicle?5has?5unknown?5weapon?5type?5@ ; `string'
PUBLIC	??_C@_0BM@CGGJMMAL@Jettison?5station?5?$CFd?5at?5?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0M@GPPLIIOD@bug?5bug?5bug?$AA@		; `string'
PUBLIC	??_C@_0EO@GEPHIEMC@JettisonStation?$CI?$CFd?0?$CFd?$CJ?5?3?5rdflags@ ; `string'
PUBLIC	??_7WeaponStepNode@@6B@				; WeaponStepNode::`vftable'
PUBLIC	??_C@_0BB@HKDFJNHB@Comparing?5Hp?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0N@EMOBHKIG@Match?5Hp?5?$CFd?6?$AA@	; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SMSClass@@6B@				; SMSClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSMSClass@@@8				; SMSClass `RTTI Type Descriptor'
PUBLIC	??_R3SMSClass@@8				; SMSClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SMSClass@@8				; SMSClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SMSClass@@8			; SMSClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@SMSBaseClass@@8			; SMSBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSMSBaseClass@@@8			; SMSBaseClass `RTTI Type Descriptor'
PUBLIC	??_R3SMSBaseClass@@8				; SMSBaseClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SMSBaseClass@@8				; SMSBaseClass::`RTTI Base Class Array'
PUBLIC	??_R4SMSBaseClass@@6B@				; SMSBaseClass::`RTTI Complete Object Locator'
PUBLIC	??_R4WeaponStepNode@@6B@			; WeaponStepNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWeaponStepNode@@@8			; WeaponStepNode `RTTI Type Descriptor'
PUBLIC	??_R3WeaponStepNode@@8				; WeaponStepNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2WeaponStepNode@@8				; WeaponStepNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@WeaponStepNode@@8			; WeaponStepNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ANode@@8				; ANode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVANode@@@8				; ANode `RTTI Type Descriptor'
PUBLIC	??_R3ANode@@8					; ANode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ANode@@8					; ANode::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e84816f
PUBLIC	__real@3eb2b8c1
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f1c61a9
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@40a00000
PUBLIC	__real@40b00000
PUBLIC	__real@40c00000
PUBLIC	__real@40d00000
PUBLIC	__real@40e00000
PUBLIC	__real@40f00000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41300000
PUBLIC	__real@41a00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@42200000
PUBLIC	__real@42700000
PUBLIC	__real@42960000
PUBLIC	__real@43160000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@438d8000
PUBLIC	__real@43960000
PUBLIC	__real@43c80000
PUBLIC	__real@43f00000
PUBLIC	__real@43fa0000
PUBLIC	__real@44098000
PUBLIC	__real@44160000
PUBLIC	__real@44480000
PUBLIC	__real@44610000
PUBLIC	__real@447a0000
PUBLIC	__real@44e10000
PUBLIC	__real@453b8000
PUBLIC	__real@454cffae
PUBLIC	__real@45a8c000
PUBLIC	__real@45bb8000
PUBLIC	__real@be32b8c1
PUBLIC	__real@beb2b8c1
PUBLIC	__real@bf000000
PUBLIC	__real@bf060a91
PUBLIC	__real@bf800000
PUBLIC	__real@bf860a91
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_printf:PROC
EXTRN	_fabs:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_stricmp:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetDelta@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetDelta
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::DetachChild
EXTRN	?GetChildOffset@DrawableBSP@@QAEXHPAUTpoint@@@Z:PROC ; DrawableBSP::GetChildOffset
EXTRN	??0BasicWeaponStation@@QAE@XZ:PROC		; BasicWeaponStation::BasicWeaponStation
EXTRN	?SetParentDrawPtr@BasicWeaponStation@@QAEXPAVDrawableBSP@@@Z:PROC ; BasicWeaponStation::SetParentDrawPtr
EXTRN	??0AdvancedWeaponStation@@QAE@XZ:PROC		; AdvancedWeaponStation::AdvancedWeaponStation
EXTRN	?GetWeaponRange@@YAHHH@Z:PROC			; GetWeaponRange
EXTRN	?GetWeaponScore@@YAHHPAEHHH@Z:PROC		; GetWeaponScore
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	??0ANode@@QAE@XZ:PROC				; ANode::ANode
EXTRN	?GetSucc@ANode@@QAEPAXXZ:PROC			; ANode::GetSucc
EXTRN	??1ANode@@QAE@XZ:PROC				; ANode::~ANode
EXTRN	??0AList@@QAE@XZ:PROC				; AList::AList
EXTRN	?RemHead@AList@@QAEPAXXZ:PROC			; AList::RemHead
EXTRN	?GetHead@AList@@QAEPAXXZ:PROC			; AList::GetHead
EXTRN	?AddSorted@AList@@QAEXPAVANode@@@Z:PROC		; AList::AddSorted
EXTRN	?SetTarget@BombClass@@QAEXPAVSimObjectType@@@Z:PROC ; BombClass::SetTarget
EXTRN	?LauGetRoundsRemaining@BombClass@@QAEHXZ:PROC	; BombClass::LauGetRoundsRemaining
EXTRN	?LauGetWeaponId@BombClass@@QAEHXZ:PROC		; BombClass::LauGetWeaponId
EXTRN	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z:PROC ; FireControlComputer::SetMasterMode
EXTRN	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z:PROC ; FireControlComputer::SetSubMode
EXTRN	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ:PROC ; FireControlComputer::GetMainMasterMode
EXTRN	?CanStepToWeaponClass@FireControlComputer@@QAEHW4WeaponClass@@@Z:PROC ; FireControlComputer::CanStepToWeaponClass
EXTRN	?SetAAMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::SetAAMasterModeForCurrentWeapon
EXTRN	?SetAGMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::SetAGMasterModeForCurrentWeapon
EXTRN	?EnterAAMasterMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::EnterAAMasterMode
EXTRN	?EnterAGMasterMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::EnterAGMasterMode
EXTRN	?ReplaceMissile@SMSBaseClass@@QAEXHPAVMissileClass@@@Z:PROC ; SMSBaseClass::ReplaceMissile
EXTRN	?ReplaceBomb@SMSBaseClass@@QAEXHPAVBombClass@@@Z:PROC ; SMSBaseClass::ReplaceBomb
EXTRN	??_ESMSBaseClass@@UAEPAXI@Z:PROC		; SMSBaseClass::`vector deleting destructor'
EXTRN	?RunRockets@SMSClass@@IAEXXZ:PROC		; SMSClass::RunRockets
EXTRN	?DropBomb@SMSClass@@QAEHH@Z:PROC		; SMSClass::DropBomb
EXTRN	??_ESMSClass@@UAEPAXI@Z:PROC			; SMSClass::`vector deleting destructor'
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?SetTarget@MissileClass@@QAEXPAVSimObjectType@@@Z:PROC ; MissileClass::SetTarget
EXTRN	?ClearReferences@MissileClass@@QAEXXZ:PROC	; MissileClass::ClearReferences
EXTRN	?SetLaunchPosition@MissileClass@@QAEXMMM@Z:PROC	; MissileClass::SetLaunchPosition
EXTRN	?InitAMissile@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z:PROC ; InitAMissile
EXTRN	?InitABomb@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z:PROC ; InitABomb
EXTRN	?InitTracers@GunClass@@QAEXXZ:PROC		; GunClass::InitTracers
EXTRN	?CleanupTracers@GunClass@@QAEXXZ:PROC		; GunClass::CleanupTracers
EXTRN	?GetSMSDomain@GunClass@@QAE?AW4WeaponDomain@@XZ:PROC ; GunClass::GetSMSDomain
EXTRN	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z:PROC ; OTWDriverClass::RemoveObject
EXTRN	?AttachObject@OTWDriverClass@@QAEXPAVDrawableBSP@@0H@Z:PROC ; OTWDriverClass::AttachObject
EXTRN	?DetachObject@OTWDriverClass@@QAEXPAVDrawableBSP@@0H@Z:PROC ; OTWDriverClass::DetachObject
EXTRN	?CreateVisualObject@OTWDriverClass@@QAEXPAVSimBaseClass@@M@Z:PROC ; OTWDriverClass::CreateVisualObject
EXTRN	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z:PROC ; OTWDriverClass::AddSfxRequest
EXTRN	??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z:PROC ; SfxClass::SfxClass
EXTRN	??0SmsDrawable@@QAE@PAVSMSClass@@@Z:PROC	; SmsDrawable::SmsDrawable
EXTRN	?UpdateGroundSpot@SmsDrawable@@QAEXXZ:PROC	; SmsDrawable::UpdateGroundSpot
EXTRN	?DropTank@AirframeClass@@QAEXH@Z:PROC		; AirframeClass::DropTank
EXTRN	?AddWeapon@AirframeClass@@QAEXMMM@Z:PROC	; AirframeClass::AddWeapon
EXTRN	?RemoveWeapon@AirframeClass@@QAEXMMM@Z:PROC	; AirframeClass::RemoveWeapon
EXTRN	?InitAGun@@YAPAVSimWeaponClass@@PAVSimBaseClass@@GH@Z:PROC ; InitAGun
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?HasLimiter@LimiterMgrClass@@QAEHHH@Z:PROC	; LimiterMgrClass::HasLimiter
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?JoystickPlayEffect@@YAHHH@Z:PROC		; JoystickPlayEffect
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconTrackMessage::FalconTrackMessage
EXTRN	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z:PROC ; FindLaserPod
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?SimWeaponDataTable@@3PAUSimWeaponDataType@@A:DWORD ; SimWeaponDataTable
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?gLimiterMgr@@3PAVLimiterMgrClass@@A:DWORD	; gLimiterMgr
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?missileDataset@@3PAVMissileDataSetClass@@A:DWORD ; missileDataset
EXTRN	?numMissileDatasets@@3HA:DWORD			; numMissileDatasets
EXTRN	?gRackId_Single_Rack@@3FA:WORD			; gRackId_Single_Rack
EXTRN	?g_bSMSPylonLoadingFix@@3_NA:BYTE		; g_bSMSPylonLoadingFix
EXTRN	?g_bAdvancedGroundChooseWeapon@@3_NA:BYTE	; g_bAdvancedGroundChooseWeapon
EXTRN	?g_fDragDilutionFactor@@3MA:DWORD		; g_fDragDilutionFactor
EXTRN	?g_bUseDefinedGunDomain@@3_NA:BYTE		; g_bUseDefinedGunDomain
EXTRN	?g_bEmergencyJettisonFix@@3_NA:BYTE		; g_bEmergencyJettisonFix
EXTRN	?g_bRealisticMavTime@@3_NA:BYTE			; g_bRealisticMavTime
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?looped@?1??StepWeaponByID@SMSClass@@QAEXXZ@4HA
_BSS	SEGMENT
?looped@?1??StepWeaponByID@SMSClass@@QAEXXZ@4HA DD 01H DUP (?) ; `SMSClass::StepWeaponByID'::`2'::looped
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@bf860a91
CONST	SEGMENT
__real@bf860a91 DD 0bf860a91r			; -1.0472
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf060a91
CONST	SEGMENT
__real@bf060a91 DD 0bf060a91r			; -0.523599
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@beb2b8c1
CONST	SEGMENT
__real@beb2b8c1 DD 0beb2b8c1r			; -0.349066
CONST	ENDS
;	COMDAT __real@be32b8c1
CONST	SEGMENT
__real@be32b8c1 DD 0be32b8c1r			; -0.174533
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@45a8c000
CONST	SEGMENT
__real@45a8c000 DD 045a8c000r			; 5400
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@44e10000
CONST	SEGMENT
__real@44e10000 DD 044e10000r			; 1800
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44610000
CONST	SEGMENT
__real@44610000 DD 044610000r			; 900
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@44098000
CONST	SEGMENT
__real@44098000 DD 044098000r			; 550
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43f00000
CONST	SEGMENT
__real@43f00000 DD 043f00000r			; 480
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@438d8000
CONST	SEGMENT
__real@438d8000 DD 0438d8000r			; 283
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42960000
CONST	SEGMENT
__real@42960000 DD 042960000r			; 75
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40f00000
CONST	SEGMENT
__real@40f00000 DD 040f00000r			; 7.5
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40d00000
CONST	SEGMENT
__real@40d00000 DD 040d00000r			; 6.5
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40b00000
CONST	SEGMENT
__real@40b00000 DD 040b00000r			; 5.5
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f1c61a9
CONST	SEGMENT
__real@3f1c61a9 DD 03f1c61a9r			; 0.610865
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eb2b8c1
CONST	SEGMENT
__real@3eb2b8c1 DD 03eb2b8c1r			; 0.349066
CONST	ENDS
;	COMDAT __real@3e84816f
CONST	SEGMENT
__real@3e84816f DD 03e84816fr			; 0.2588
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2ANode@@8
rdata$r	SEGMENT
??_R2ANode@@8 DD FLAT:??_R1A@?0A@EA@ANode@@8		; ANode::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ANode@@8
rdata$r	SEGMENT
??_R3ANode@@8 DD 00H					; ANode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ANode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVANode@@@8
_DATA	SEGMENT
??_R0?AVANode@@@8 DD FLAT:??_7type_info@@6B@		; ANode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVANode@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ANode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ANode@@8 DD FLAT:??_R0?AVANode@@@8	; ANode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ANode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@WeaponStepNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WeaponStepNode@@8 DD FLAT:??_R0?AVWeaponStepNode@@@8 ; WeaponStepNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WeaponStepNode@@8
rdata$r	ENDS
;	COMDAT ??_R2WeaponStepNode@@8
rdata$r	SEGMENT
??_R2WeaponStepNode@@8 DD FLAT:??_R1A@?0A@EA@WeaponStepNode@@8 ; WeaponStepNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3WeaponStepNode@@8
rdata$r	SEGMENT
??_R3WeaponStepNode@@8 DD 00H				; WeaponStepNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2WeaponStepNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWeaponStepNode@@@8
_DATA	SEGMENT
??_R0?AVWeaponStepNode@@@8 DD FLAT:??_7type_info@@6B@	; WeaponStepNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWeaponStepNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4WeaponStepNode@@6B@
rdata$r	SEGMENT
??_R4WeaponStepNode@@6B@ DD 00H				; WeaponStepNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWeaponStepNode@@@8
	DD	FLAT:??_R3WeaponStepNode@@8
rdata$r	ENDS
;	COMDAT ??_R4SMSBaseClass@@6B@
rdata$r	SEGMENT
??_R4SMSBaseClass@@6B@ DD 00H				; SMSBaseClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSMSBaseClass@@@8
	DD	FLAT:??_R3SMSBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SMSBaseClass@@8
rdata$r	SEGMENT
??_R2SMSBaseClass@@8 DD FLAT:??_R1A@?0A@EA@SMSBaseClass@@8 ; SMSBaseClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SMSBaseClass@@8
rdata$r	SEGMENT
??_R3SMSBaseClass@@8 DD 00H				; SMSBaseClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SMSBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSMSBaseClass@@@8
_DATA	SEGMENT
??_R0?AVSMSBaseClass@@@8 DD FLAT:??_7type_info@@6B@	; SMSBaseClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSMSBaseClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SMSBaseClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SMSBaseClass@@8 DD FLAT:??_R0?AVSMSBaseClass@@@8 ; SMSBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SMSBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SMSClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SMSClass@@8 DD FLAT:??_R0?AVSMSClass@@@8	; SMSClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SMSClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SMSClass@@8
rdata$r	SEGMENT
??_R2SMSClass@@8 DD FLAT:??_R1A@?0A@EA@SMSClass@@8	; SMSClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SMSBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R3SMSClass@@8
rdata$r	SEGMENT
??_R3SMSClass@@8 DD 00H					; SMSClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SMSClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSMSClass@@@8
_DATA	SEGMENT
??_R0?AVSMSClass@@@8 DD FLAT:??_7type_info@@6B@		; SMSClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSMSClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SMSClass@@6B@
rdata$r	SEGMENT
??_R4SMSClass@@6B@ DD 00H				; SMSClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSMSClass@@@8
	DD	FLAT:??_R3SMSClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMOBHKIG@Match?5Hp?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@EMOBHKIG@Match?5Hp?5?$CFd?6?$AA@ DB 'Match Hp %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HKDFJNHB@Comparing?5Hp?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@HKDFJNHB@Comparing?5Hp?5?$CFd?6?$AA@ DB 'Comparing Hp %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_7WeaponStepNode@@6B@
CONST	SEGMENT
??_7WeaponStepNode@@6B@ DD FLAT:??_R4WeaponStepNode@@6B@ ; WeaponStepNode::`vftable'
	DD	FLAT:?CompareWith@WeaponStepNode@@EAEHPAVANode@@@Z
CONST	ENDS
;	COMDAT ??_C@_0EO@GEPHIEMC@JettisonStation?$CI?$CFd?0?$CFd?$CJ?5?3?5rdflags@
CONST	SEGMENT
??_C@_0EO@GEPHIEMC@JettisonStation?$CI?$CFd?0?$CFd?$CJ?5?3?5rdflags@ DB 'J'
	DB	'ettisonStation(%d,%d) : rdflags=%8x  jettpylon=%d  jettrack=%'
	DB	'd jettweapon=%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPPLIIOD@bug?5bug?5bug?$AA@
CONST	SEGMENT
??_C@_0M@GPPLIIOD@bug?5bug?5bug?$AA@ DB 'bug bug bug', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CGGJMMAL@Jettison?5station?5?$CFd?5at?5?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BM@CGGJMMAL@Jettison?5station?5?$CFd?5at?5?$CFld?6?$AA@ DB 'Jettis'
	DB	'on station %d at %ld', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JFLIKKKJ@Vehicle?5has?5unknown?5weapon?5type?5@
CONST	SEGMENT
??_C@_0CF@JFLIKKKJ@Vehicle?5has?5unknown?5weapon?5type?5@ DB 'Vehicle has'
	DB	' unknown weapon type %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_7SMSClass@@6B@
CONST	SEGMENT
??_7SMSClass@@6B@ DD FLAT:??_R4SMSClass@@6B@		; SMSClass::`vftable'
	DD	FLAT:??_ESMSClass@@UAEPAXI@Z
	DD	FLAT:?AddWeaponGraphics@SMSClass@@UAEXXZ
	DD	FLAT:?FreeWeaponGraphics@SMSClass@@UAEXXZ
	DD	FLAT:?GetCurrentWeapon@SMSClass@@UAEPAVSimWeaponClass@@XZ
CONST	ENDS
;	COMDAT ??_7SMSBaseClass@@6B@
CONST	SEGMENT
??_7SMSBaseClass@@6B@ DD FLAT:??_R4SMSBaseClass@@6B@	; SMSBaseClass::`vftable'
	DD	FLAT:??_ESMSBaseClass@@UAEPAXI@Z
	DD	FLAT:?AddWeaponGraphics@SMSBaseClass@@UAEXXZ
	DD	FLAT:?FreeWeaponGraphics@SMSBaseClass@@UAEXXZ
	DD	FLAT:?GetCurrentWeapon@SMSBaseClass@@UAEPAVSimWeaponClass@@XZ
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SetPlayerSMS@SMSClass@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetPlayerSMS@SMSClass@@QAEXH@Z$0
__unwindtable$?EmergencyJettison@SMSClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EmergencyJettison@SMSClass@@QAEXXZ$0
__unwindtable$?SelectiveJettison@SMSClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectiveJettison@SMSClass@@QAEXXZ$0
__unwindtable$?LaunchWeapon@SMSBaseClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LaunchWeapon@SMSBaseClass@@QAEXXZ$0
__unwindtable$?StepWeaponByID@SMSClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StepWeaponByID@SMSClass@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?StepWeaponByID@SMSClass@@QAEXXZ$1
__unwindtable$?RemoveWeapon@SMSClass@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveWeapon@SMSClass@@QAEXH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RemoveWeapon@SMSClass@@QAEXH@Z$1
__unwindtable$??1SMSClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SMSClass@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SMSClass@@UAE@XZ$1
__unwindtable$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z$1
__unwindtable$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z$1
__unwindtable$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z$1
__ehfuncinfo$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?StepWeaponByID@SMSClass@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?StepWeaponByID@SMSClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SetPlayerSMS@SMSClass@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetPlayerSMS@SMSClass@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RemoveWeapon@SMSClass@@QAEXH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RemoveWeapon@SMSClass@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EmergencyJettison@SMSClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EmergencyJettison@SMSClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SelectiveJettison@SMSClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SelectiveJettison@SMSClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1SMSClass@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SMSClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?LaunchWeapon@SMSBaseClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LaunchWeapon@SMSBaseClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$4
__unwindtable$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AList@@QAE@XZ$0
__ehfuncinfo$??1AList@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GWeaponStepNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GWeaponStepNode@@QAEPAXI@Z PROC			; WeaponStepNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1WeaponStepNode@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GWeaponStepNode@@QAEPAXI@Z ENDP			; WeaponStepNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1WeaponStepNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1WeaponStepNode@@QAE@XZ PROC				; WeaponStepNode::~WeaponStepNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	esp, ebp
	pop	ebp
	ret	0
??1WeaponStepNode@@QAE@XZ ENDP				; WeaponStepNode::~WeaponStepNode
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0WeaponStepNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WeaponStepNode@@QAE@XZ PROC				; WeaponStepNode::WeaponStepNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7WeaponStepNode@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WeaponStepNode@@QAE@XZ ENDP				; WeaponStepNode::WeaponStepNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
;	COMDAT ?CompareWith@WeaponStepNode@@EAEHPAVANode@@@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_a$ = 8							; size = 4
?CompareWith@WeaponStepNode@@EAEHPAVANode@@@Z PROC	; WeaponStepNode::CompareWith, COMDAT
; _this$ = ecx

; 3820 : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3821 : 		int i = stricmp(name,((WeaponStepNode *)a)->name);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_stricmp
	add	esp, 8
	mov	DWORD PTR _i$[ebp], eax

; 3822 : 		if(i==0)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@CompareWit

; 3823 : 		{
; 3824 : 			if(weaponCount == 0 && ((WeaponStepNode *)a)->weaponCount)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN2@CompareWit
	mov	edx, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN2@CompareWit

; 3825 : 			{	
; 3826 : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CompareWit

; 3827 : 			}
; 3828 : 			else

	jmp	SHORT $LN3@CompareWit
$LN2@CompareWit:

; 3829 : 			{
; 3830 : 				return -1;

	or	eax, -1
	jmp	SHORT $LN4@CompareWit
$LN3@CompareWit:

; 3831 : 			}
; 3832 : 		}
; 3833 : 		return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN4@CompareWit:

; 3834 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?CompareWith@WeaponStepNode@@EAEHPAVANode@@@Z ENDP	; WeaponStepNode::CompareWith
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_newHp$ = -8						; size = 4
_middleHp$ = -4						; size = 4
_curHp$ = 8						; size = 4
_hpCount$ = 12						; size = 4
?NextACHp@@YAHHH@Z PROC					; NextACHp

; 1953 : {// assumes 0 is gun

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1954 : 	float middleHp;
; 1955 : 	int   newHp;
; 1956 : 	
; 1957 : 	//           |
; 1958 : 	// 0 1 2 3 4 5 6 7 8 9 
; 1959 : 	// 5 9 8 7 6 4 3 2 1 0
; 1960 : 	
; 1961 : 	// 0 1 2 3 4|5 6 7 8
; 1962 : 	// 4 8 7 6 5 3 4 1 0
; 1963 : 	
; 1964 : 	middleHp = (hpCount)/2.0f;

	cvtsi2ss xmm0, DWORD PTR _hpCount$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _middleHp$[ebp], xmm0

; 1965 : 	
; 1966 : 	if(curHp == 0)

	cmp	DWORD PTR _curHp$[ebp], 0
	jne	SHORT $LN5@NextACHp

; 1967 : 	{
; 1968 : 		return((int)middleHp);

	cvttss2si eax, DWORD PTR _middleHp$[ebp]
	jmp	SHORT $LN6@NextACHp
$LN5@NextACHp:

; 1969 : 	}
; 1970 : 
; 1971 : 	if(curHp == middleHp)

	cvtsi2ss xmm0, DWORD PTR _curHp$[ebp]
	ucomiss	xmm0, DWORD PTR _middleHp$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@NextACHp

; 1972 : 	{
; 1973 : 		newHp = (int)(middleHp - 1);

	movss	xmm0, DWORD PTR _middleHp$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	mov	DWORD PTR _newHp$[ebp], eax

; 1974 : 		if(newHp>=0)

	cmp	DWORD PTR _newHp$[ebp], 0
	jl	SHORT $LN3@NextACHp

; 1975 : 			return newHp;

	mov	eax, DWORD PTR _newHp$[ebp]
	jmp	SHORT $LN6@NextACHp
$LN3@NextACHp:

; 1976 : 		
; 1977 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN6@NextACHp
$LN4@NextACHp:

; 1978 : 	}	
; 1979 : 
; 1980 : 	if(curHp < middleHp) // goto opposite Hp

	cvtsi2ss xmm0, DWORD PTR _curHp$[ebp]
	movss	xmm1, DWORD PTR _middleHp$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@NextACHp

; 1981 : 		return(hpCount - curHp);

	mov	eax, DWORD PTR _hpCount$[ebp]
	sub	eax, DWORD PTR _curHp$[ebp]
	jmp	SHORT $LN6@NextACHp
$LN2@NextACHp:

; 1982 : 	
; 1983 : 	if(curHp > middleHp) // goto opposite Hp 

	cvtsi2ss xmm0, DWORD PTR _curHp$[ebp]
	comiss	xmm0, DWORD PTR _middleHp$[ebp]
	jbe	SHORT $LN1@NextACHp

; 1984 : 		return(hpCount - curHp - 1);

	mov	eax, DWORD PTR _hpCount$[ebp]
	sub	eax, DWORD PTR _curHp$[ebp]
	sub	eax, 1
	jmp	SHORT $LN6@NextACHp
$LN1@NextACHp:

; 1985 : 	
; 1986 : 	return(1); // start over

	mov	eax, 1
$LN6@NextACHp:

; 1987 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NextACHp@@YAHHH@Z ENDP					; NextACHp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetScanDir@RadarDopplerClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dir$ = 8						; size = 4
?SetScanDir@RadarDopplerClass@@QAEXM@Z PROC		; RadarDopplerClass::SetScanDir, COMDAT
; _this$ = ecx

; 247  : 	void SetScanDir(float dir)	{scanDir = dir;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [eax+252], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScanDir@RadarDopplerClass@@QAEXM@Z ENDP		; RadarDopplerClass::SetScanDir
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetRackGroup@AirframeClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetRackGroup@AirframeClass@@QAEHH@Z PROC		; AirframeClass::GetRackGroup, COMDAT
; _this$ = ecx

; 1229 : 	int GetRackGroup(int i) { return auxaeroData->hardpointrg[i]; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+476]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRackGroup@AirframeClass@@QAEHH@Z ENDP		; AirframeClass::GetRackGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::ClearFlag, COMDAT
; _this$ = ecx

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::SetFlag, COMDAT
; _this$ = ecx

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?VehicleIndex@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VehicleIndex@AirframeClass@@QAEHXZ PROC		; AirframeClass::VehicleIndex, COMDAT
; _this$ = ecx

; 1200 : 	int	VehicleIndex(void) {return vehicleIndex;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VehicleIndex@AirframeClass@@QAEHXZ ENDP		; AirframeClass::VehicleIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ExternalFuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ExternalFuel@AirframeClass@@QAEMXZ PROC		; AirframeClass::ExternalFuel, COMDAT
; _this$ = ecx

; 1184 : 	float ExternalFuel (void) {return externalFuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?ExternalFuel@AirframeClass@@QAEMXZ ENDP		; AirframeClass::ExternalFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxVcas, COMDAT
; _this$ = ecx

; 1176 : 	float MaxVcas(void) {return maxVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+80]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxGs@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxGs@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxGs, COMDAT
; _this$ = ecx

; 1174 : 	float MaxGs (void) {return maxGs;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxGs@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxGs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?SetLaunchRotation@MissileClass@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_az$ = 8						; size = 4
_el$ = 12						; size = 4
?SetLaunchRotation@MissileClass@@QAEXMM@Z PROC		; MissileClass::SetLaunchRotation, COMDAT
; _this$ = ecx

; 336  : 	void SetLaunchRotation (float az, float el) {initAz = az; initEl = el;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [eax+940], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [ecx+944], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLaunchRotation@MissileClass@@QAEXMM@Z ENDP		; MissileClass::SetLaunchRotation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
_lastPtr$ = -28						; size = 4
_weapPtr$ = -24						; size = 4
_i$ = -20						; size = 4
_rackSize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_parent$ = 12						; size = 4
_weapid$ = 16						; size = 2
_weapClass$ = 20					; size = 4
_num$ = 24						; size = 4
_initFunc$ = 28						; size = 4
_loadOrder$ = 32					; size = 4
?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z PROC ; InitWeaponList

; 3714 : ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 3715 : 	VuBin<SimWeaponClass> weapPtr;

	push	0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3716 : 	VuBin<SimWeaponClass> lastPtr;

	push	0
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3717 : 	int i=0, rackSize=1;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _rackSize$[ebp], 1

; 3718 : 	
; 3719 : 	// Find the real weapon class
; 3720 : 	weapClass = SimWeaponDataTable[Falcon4ClassTable[WeaponDataTable[weapid].Index].vehicleDataIndex].weaponClass;

	movzx	eax, WORD PTR _weapid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	edx, WORD PTR [ecx+eax]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movsx	ecx, WORD PTR [eax+edx+74]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	eax, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _weapClass$[ebp], eax

; 3721 : 	
; 3722 : 	// Determine rack size;
; 3723 : 	if (num) {

	cmp	DWORD PTR _num$[ebp], 0
	je	$LN21@InitWeapon

; 3724 : 		// RV - Biker - This is why AGMs don't load nice on 2 slot rack
; 3725 : 		// MLR 2003-10-16 - make this optional, FF crew has gone mad. :)
; 3726 : 		if(g_bSMSPylonLoadingFix || parent->IsHelicopter()) {

	movzx	ecx, BYTE PTR ?g_bSMSPylonLoadingFix@@3_NA ; g_bSMSPylonLoadingFix
	test	ecx, ecx
	jne	SHORT $LN19@InitWeapon
	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [eax+184]
	call	edx
	test	eax, eax
	je	SHORT $LN20@InitWeapon
$LN19@InitWeapon:

; 3727 : 			rackSize=num; // MLR fixes issue with 2 & 5 slotted A2G racks not being loaded correctly

	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR _rackSize$[ebp], eax

; 3728 : 		}
; 3729 : 		else {

	jmp	SHORT $LN18@InitWeapon
$LN20@InitWeapon:

; 3730 : 			if (num > 6)

	cmp	DWORD PTR _num$[ebp], 6
	jle	SHORT $LN17@InitWeapon

; 3731 : 				rackSize = num;

	mov	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _rackSize$[ebp], ecx
	jmp	SHORT $LN18@InitWeapon
$LN17@InitWeapon:

; 3732 : 			else if (num > 4)

	cmp	DWORD PTR _num$[ebp], 4
	jle	SHORT $LN15@InitWeapon

; 3733 : 				rackSize = 6;

	mov	DWORD PTR _rackSize$[ebp], 6
	jmp	SHORT $LN18@InitWeapon
$LN15@InitWeapon:

; 3734 : 			else if (num == 4)

	cmp	DWORD PTR _num$[ebp], 4
	jne	SHORT $LN13@InitWeapon

; 3735 : 				rackSize = 4;

	mov	DWORD PTR _rackSize$[ebp], 4
	jmp	SHORT $LN18@InitWeapon
$LN13@InitWeapon:

; 3736 : 			else if (num == 2 && weapClass == wcAimWpn)

	cmp	DWORD PTR _num$[ebp], 2
	jne	SHORT $LN11@InitWeapon
	cmp	DWORD PTR _weapClass$[ebp], 0
	jne	SHORT $LN11@InitWeapon

; 3737 : 				rackSize = 2;

	mov	DWORD PTR _rackSize$[ebp], 2
	jmp	SHORT $LN18@InitWeapon
$LN11@InitWeapon:

; 3738 : 			else if (num == 1 && weapClass == wcAimWpn)

	cmp	DWORD PTR _num$[ebp], 1
	jne	SHORT $LN9@InitWeapon
	cmp	DWORD PTR _weapClass$[ebp], 0
	jne	SHORT $LN9@InitWeapon

; 3739 : 				rackSize = 1;

	mov	DWORD PTR _rackSize$[ebp], 1
	jmp	SHORT $LN18@InitWeapon
$LN9@InitWeapon:

; 3740 : 			else if (num > 1)

	cmp	DWORD PTR _num$[ebp], 1
	jle	SHORT $LN7@InitWeapon

; 3741 : 				rackSize = 3;

	mov	DWORD PTR _rackSize$[ebp], 3
	jmp	SHORT $LN18@InitWeapon
$LN7@InitWeapon:

; 3742 : 			else  if (num > 0)

	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $LN18@InitWeapon

; 3743 : 				rackSize = 1;

	mov	DWORD PTR _rackSize$[ebp], 1
$LN18@InitWeapon:

; 3744 : 		}
; 3745 : 		
; 3746 : 		
; 3747 : 		for (i=0; i<num; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@InitWeapon
$LN3@InitWeapon:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@InitWeapon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	SHORT $LN21@InitWeapon

; 3748 : 			// Load from back of rack to front (ie, 2 missiles on a tri-rack will
; 3749 : 			// load into slot 1 and 2, not 0 and 1)
; 3750 : 			weapPtr.reset(initFunc(parent, weapid, rackSize-(i+1)));

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _rackSize$[ebp]
	sub	edx, ecx
	push	edx
	movzx	eax, WORD PTR _weapid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	DWORD PTR _initFunc$[ebp]
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 3751 : 			if (lastPtr){

	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@InitWeapon

; 3752 : 				weapPtr->nextOnRail = lastPtr;

	lea	eax, DWORD PTR _lastPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	add	eax, 672				; 000002a0H
	mov	ecx, eax
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
$LN1@InitWeapon:

; 3753 : 			}
; 3754 : 			lastPtr = weapPtr;

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 3755 : 		}

	jmp	SHORT $LN3@InitWeapon
$LN21@InitWeapon:

; 3756 : 	}
; 3757 : 	
; 3758 : 	return weapPtr;

	lea	edx, DWORD PTR _weapPtr$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@ABV0@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3759 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z$0:
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z$1:
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z$2:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN27@InitWeapon
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
$LN27@InitWeapon:
	ret	0
__ehhandler$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z ENDP ; InitWeaponList
; Function compile flags: /Odtp
;	COMDAT ??_GSMSClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSMSClass@@UAEPAXI@Z PROC				; SMSClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SMSClass@@UAE@XZ			; SMSClass::~SMSClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSMSClass@@UAEPAXI@Z ENDP				; SMSClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBBurstAlt@SMSClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?SetAGBBurstAlt@SMSClass@@QAEXH@Z PROC			; SMSClass::SetAGBBurstAlt, COMDAT
; _this$ = ecx

; 320  : 	void SetAGBBurstAlt(int x)        { agbProfile[curProfile].burstAltitude  = x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx+212], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBBurstAlt@SMSClass@@QAEXH@Z ENDP			; SMSClass::SetAGBBurstAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBRippleInterval@SMSClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?SetAGBRippleInterval@SMSClass@@QAEXH@Z PROC		; SMSClass::SetAGBRippleInterval, COMDAT
; _this$ = ecx

; 318  : 	void SetAGBRippleInterval(int x) { agbProfile[curProfile].rippleInterval = x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx+204], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBRippleInterval@SMSClass@@QAEXH@Z ENDP		; SMSClass::SetAGBRippleInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBRippleCount@SMSClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?SetAGBRippleCount@SMSClass@@QAEXH@Z PROC		; SMSClass::SetAGBRippleCount, COMDAT
; _this$ = ecx

; 317  : 	void SetAGBRippleCount(int x)     { agbProfile[curProfile].rippleCount    = x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx+200], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBRippleCount@SMSClass@@QAEXH@Z ENDP		; SMSClass::SetAGBRippleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBPair@SMSClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBPair@SMSClass@@QAE_NXZ PROC			; SMSClass::GetAGBPair, COMDAT
; _this$ = ecx

; 314  : 	bool GetAGBPair(void)          { return agbProfile[curProfile].releasePair;     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+232]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBPair@SMSClass@@QAE_NXZ ENDP			; SMSClass::GetAGBPair
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBRippleInterval@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBRippleInterval@SMSClass@@QAEHXZ PROC		; SMSClass::GetAGBRippleInterval, COMDAT
; _this$ = ecx

; 307  : 	int GetAGBRippleInterval(void) { return agbProfile[curProfile].rippleInterval;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+204]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBRippleInterval@SMSClass@@QAEHXZ ENDP		; SMSClass::GetAGBRippleInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBRippleCount@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBRippleCount@SMSClass@@QAEHXZ PROC		; SMSClass::GetAGBRippleCount, COMDAT
; _this$ = ecx

; 306  : 	int GetAGBRippleCount(void)    { return agbProfile[curProfile].rippleCount;     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+200]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBRippleCount@SMSClass@@QAEHXZ ENDP		; SMSClass::GetAGBRippleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hpId$ = 8						; size = 4
_findSimilar$ = 12					; size = 4
?SetCurrentHardPoint@SMSClass@@QAEHHH@Z PROC		; SMSClass::SetCurrentHardPoint
; _this$ = ecx

; 4147 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4148 : 
; 4149 : 	SetCurrentWeapon(hpId);

	push	0
	mov	eax, DWORD PTR _hpId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 4150 : 	if(curWeapon)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@SetCurrent

; 4151 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN6@SetCurrent
$LN5@SetCurrent:

; 4152 : 
; 4153 : 	if(hpId < 0)

	cmp	DWORD PTR _hpId$[ebp], 0
	jge	SHORT $LN4@SetCurrent

; 4154 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@SetCurrent
$LN4@SetCurrent:

; 4155 : 
; 4156 : 	if(findSimilar)

	cmp	DWORD PTR _findSimilar$[ebp], 0
	je	SHORT $LN3@SetCurrent

; 4157 : 	{
; 4158 : 		if(SetCurrentHpByWeaponId(hardPoint[hpId]->weaponId))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hpId$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentHpByWeaponId@SMSClass@@QAEHH@Z ; SMSClass::SetCurrentHpByWeaponId
	test	eax, eax
	je	SHORT $LN2@SetCurrent

; 4159 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN6@SetCurrent

; 4160 : 		else

	jmp	SHORT $LN3@SetCurrent
$LN2@SetCurrent:

; 4161 : 		{   // we have to do this because SetCurrentHpByWeaponId() will set the hp to -1
; 4162 : 			SetCurrentWeapon(hpId);

	push	0
	mov	ecx, DWORD PTR _hpId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 4163 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@SetCurrent
$LN3@SetCurrent:

; 4164 : 		}
; 4165 : 	}
; 4166 : 	return FALSE;

	xor	eax, eax
$LN6@SetCurrent:

; 4167 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetCurrentHardPoint@SMSClass@@QAEHHH@Z ENDP		; SMSClass::SetCurrentHardPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_list$ = -112						; size = 24
_found$ = -88						; size = 4
tv276 = -84						; size = 4
$T2 = -80						; size = 4
$T3 = -76						; size = 4
_useEmpty$ = -72					; size = 4
$T4 = -68						; size = 4
tv207 = -64						; size = 4
$T5 = -60						; size = 4
_skip$6 = -56						; size = 4
_l$ = -52						; size = 4
_curWeapNode$ = -48					; size = 4
_playerAC$ = -44					; size = 4
_startHp$ = -40						; size = 4
_weap$7 = -36						; size = 4
_newHp$ = -32						; size = 4
_i$ = -28						; size = 4
_n$ = -24						; size = 4
_this$ = -20						; size = 4
_newWeaponId$ = -16					; size = 2
__$EHRec$ = -12						; size = 12
?StepWeaponByID@SMSClass@@QAEXXZ PROC			; SMSClass::StepWeaponByID
; _this$ = ecx

; 3987 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StepWeaponByID@SMSClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3988 : 	static int looped = 0;
; 3989 : 	int i;
; 3990 : 	int useEmpty = 1;

	mov	DWORD PTR _useEmpty$[ebp], 1

; 3991 : 	short newWeaponId;
; 3992 : 	AList list;

	lea	ecx, DWORD PTR _list$[ebp]
	call	??0AList@@QAE@XZ			; AList::AList
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3993 : 	WeaponStepNode *n;
; 3994 : 	SimWeaponClass *found = NULL;

	mov	DWORD PTR _found$[ebp], 0

; 3995 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3996 : 
; 3997 : 	// 2002-02-08 ADDED BY S.G. 
; 3998 : 	// From SMSClass::WeaponStep, other it will CTD. 
; 3999 : 	// This will fix the CTD but not the original cause which is why curHardpoint is -1.
; 4000 : 	if (curHardpoint < 0  || looped || ! (playerAC && playerAC->FCC) ){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jl	SHORT $LN28@StepWeapon
	cmp	DWORD PTR ?looped@?1??StepWeaponByID@SMSClass@@QAEXXZ@4HA, 0
	jne	SHORT $LN28@StepWeapon
	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN28@StepWeapon
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+936], 0
	jne	SHORT $LN29@StepWeapon
$LN28@StepWeapon:

; 4001 : 		return; // Do nothing if no station is currently selected

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _list$[ebp]
	call	??1AList@@QAE@XZ
	jmp	$LN30@StepWeapon
$LN29@StepWeapon:

; 4002 : 	}
; 4003 : 
; 4004 : 	if(curHardpoint == -1){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], -1
	jne	SHORT $LN26@StepWeapon

; 4005 : 		curHardpoint = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0
$LN26@StepWeapon:

; 4006 : 	}
; 4007 : 
; 4008 : 	// needs to be set because if qty is 0, it is -1
; 4009 : 	curWeaponId = hardPoint[curHardpoint]->weaponId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [edx+8]
	mov	WORD PTR [eax+168], cx

; 4010 : 
; 4011 : 	newWeaponId = curWeaponId;   // MLR 1/20/2004 - just in case there's nothing else to choose from

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+168]
	mov	WORD PTR _newWeaponId$[ebp], ax

; 4012 : 
; 4013 : 	WeaponStepNode *curWeapNode = 0;

	mov	DWORD PTR _curWeapNode$[ebp], 0

; 4014 : 
; 4015 :     for (i=0; i<numHardpoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@StepWeapon
$LN24@StepWeapon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN25@StepWeapon:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN23@StepWeapon

; 4016 : 		if ( playerAC->FCC->CanStepToWeaponClass( hardPoint[i]->GetWeaponData()->weaponClass ) ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+148]
	call	eax
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?CanStepToWeaponClass@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::CanStepToWeaponClass
	test	eax, eax
	je	$LN22@StepWeapon

; 4017 : 			int skip = 0;

	mov	DWORD PTR _skip$6[ebp], 0

; 4018 : 
; 4019 : 			// see if we already have a matching node
; 4020 : 			// if so, tally WeaponCount
; 4021 : 			n = (WeaponStepNode *)list.GetHead();

	lea	ecx, DWORD PTR _list$[ebp]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _n$[ebp], eax
$LN21@StepWeapon:

; 4022 : 			while (n){

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN20@StepWeapon

; 4023 : 				if (n->weaponId == hardPoint[i]->weaponId){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	mov	edx, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [edx+16], ecx
	jne	SHORT $LN19@StepWeapon

; 4024 : 					n->weaponCount += hardPoint[i]->weaponCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+10]
	mov	edx, DWORD PTR _n$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4025 : 					skip = 1;

	mov	DWORD PTR _skip$6[ebp], 1
$LN19@StepWeapon:

; 4026 : 				}
; 4027 : 				n=(WeaponStepNode *)n->GetSucc();

	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _n$[ebp], eax

; 4028 : 			}

	jmp	SHORT $LN21@StepWeapon
$LN20@StepWeapon:

; 4029 : 
; 4030 : 			if (!skip){

	cmp	DWORD PTR _skip$6[ebp], 0
	jne	$LN22@StepWeapon

; 4031 : 				// create a new node
; 4032 : 				n = new WeaponStepNode;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN32@StepWeapon
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0WeaponStepNode@@QAE@XZ
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN33@StepWeapon
$LN32@StepWeapon:
	mov	DWORD PTR tv207[ebp], 0
$LN33@StepWeapon:
	mov	ecx, DWORD PTR tv207[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _n$[ebp], edx

; 4033 : 				n->name			= hardPoint[i]->GetWeaponData()->mnemonic;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	add	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4034 : 				n->weaponId		= hardPoint[i]->weaponId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 4035 : 				n->weaponCount	= hardPoint[i]->weaponCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 4036 : 
; 4037 : 				if(n->weaponId == curWeaponId){  

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+168]
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jne	SHORT $LN17@StepWeapon

; 4038 : 					// this is our current weapon, store for logic later.
; 4039 : 					curWeapNode = n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _curWeapNode$[ebp], edx
$LN17@StepWeapon:

; 4040 : 				}
; 4041 : 				list.AddSorted(n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _list$[ebp]
	call	?AddSorted@AList@@QAEXPAVANode@@@Z	; AList::AddSorted
$LN22@StepWeapon:

; 4042 : 			}
; 4043 : 		}
; 4044 : 	}

	jmp	$LN24@StepWeapon
$LN23@StepWeapon:

; 4045 : 
; 4046 : 	// logic to find the next weaponId
; 4047 : 	n = NULL;

	mov	DWORD PTR _n$[ebp], 0

; 4048 : 	if(curWeapNode){

	cmp	DWORD PTR _curWeapNode$[ebp], 0
	je	SHORT $LN16@StepWeapon

; 4049 : 		n=(WeaponStepNode *)curWeapNode->GetSucc();

	mov	ecx, DWORD PTR _curWeapNode$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _n$[ebp], eax
$LN16@StepWeapon:

; 4050 : 	}
; 4051 : 
; 4052 : 	if(!n){

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN15@StepWeapon

; 4053 : 		n=(WeaponStepNode *)list.GetHead();

	lea	ecx, DWORD PTR _list$[ebp]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _n$[ebp], eax
$LN15@StepWeapon:

; 4054 : 	}
; 4055 : 
; 4056 : 	if(n){

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN12@StepWeapon

; 4057 : 		newWeaponId = n->weaponId;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _newWeaponId$[ebp], dx

; 4058 : 		if(n->weaponCount){

	mov	eax, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN12@StepWeapon

; 4059 : 			useEmpty=0;

	mov	DWORD PTR _useEmpty$[ebp], 0
$LN12@StepWeapon:

; 4060 : 		}
; 4061 : 	}
; 4062 : 
; 4063 : 	// cleanup nodes
; 4064 : 	while (n = (WeaponStepNode *)list.RemHead() ){

	lea	ecx, DWORD PTR _list$[ebp]
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR _n$[ebp], eax
	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN11@StepWeapon

; 4065 : 		delete n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN34@StepWeapon
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GWeaponStepNode@@QAEPAXI@Z
	mov	DWORD PTR tv276[ebp], eax
	jmp	SHORT $LN35@StepWeapon
$LN34@StepWeapon:
	mov	DWORD PTR tv276[ebp], 0
$LN35@StepWeapon:

; 4066 : 	}

	jmp	SHORT $LN12@StepWeapon
$LN11@StepWeapon:

; 4067 : 
; 4068 : 
; 4069 : 	// search for a hardpoint with a matching WeaponId
; 4070 : 	// search inboard to outboard
; 4071 : 	// 0 1 2 3 4 5
; 4072 : 	// 0 1 2 3 4 
; 4073 : 	
; 4074 : 	int startHp = (numHardpoints) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _startHp$[ebp], eax

; 4075 : 	int newHp = startHp;

	mov	ecx, DWORD PTR _startHp$[ebp]
	mov	DWORD PTR _newHp$[ebp], ecx

; 4076 : 
; 4077 : 	looped = 1;

	mov	DWORD PTR ?looped@?1??StepWeaponByID@SMSClass@@QAEXXZ@4HA, 1
$LN10@StepWeapon:

; 4078 : 
; 4079 : 	int l;
; 4080 : 
; 4081 : 	while(startHp>=0){

	cmp	DWORD PTR _startHp$[ebp], 0
	jl	$LN9@StepWeapon

; 4082 : 		newHp = startHp;

	mov	edx, DWORD PTR _startHp$[ebp]
	mov	DWORD PTR _newHp$[ebp], edx

; 4083 : 		for(l=0;l<2;l++){

	mov	DWORD PTR _l$[ebp], 0
	jmp	SHORT $LN8@StepWeapon
$LN7@StepWeapon:
	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$LN8@StepWeapon:
	cmp	DWORD PTR _l$[ebp], 2
	jge	$LN6@StepWeapon

; 4084 : 			MonoPrint("Comparing Hp %d\n",newHp);

	mov	ecx, DWORD PTR _newHp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@HKDFJNHB@Comparing?5Hp?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 8

; 4085 : 			if( newHp < numHardpoints && hardPoint[newHp]->weaponId == newWeaponId){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newHp$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN5@StepWeapon
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _newHp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	movsx	eax, WORD PTR _newWeaponId$[ebp]
	cmp	edx, eax
	jne	$LN5@StepWeapon

; 4086 : 				SimWeaponClass *weap = hardPoint[newHp]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _newHp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weap$7[ebp], eax
$LN4@StepWeapon:

; 4087 : 
; 4088 : 				while(weap && !weap->IsUseable()){

	cmp	DWORD PTR _weap$7[ebp], 0
	je	SHORT $LN3@StepWeapon
	mov	ecx, DWORD PTR _weap$7[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weap$7[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@StepWeapon

; 4089 : 					// MLR 6/3/2004 - Skip unuseable weapons (LAUs)
; 4090 : 					weap=weap->GetNextOnRail();

	mov	ecx, DWORD PTR _weap$7[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weap$7[ebp], eax

; 4091 : 				}

	jmp	SHORT $LN4@StepWeapon
$LN3@StepWeapon:

; 4092 : 
; 4093 : 				if(weap || useEmpty){

	cmp	DWORD PTR _weap$7[ebp], 0
	jne	SHORT $LN1@StepWeapon
	cmp	DWORD PTR _useEmpty$[ebp], 0
	je	SHORT $LN5@StepWeapon
$LN1@StepWeapon:

; 4094 : 					MonoPrint("Match Hp %d\n",newHp);

	mov	ecx, DWORD PTR _newHp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@EMOBHKIG@Match?5Hp?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 8

; 4095 : 					SetCurrentWeapon(newHp, weap);

	mov	edx, DWORD PTR _weap$7[ebp]
	push	edx
	mov	eax, DWORD PTR _newHp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 4096 : 					looped = 0;

	mov	DWORD PTR ?looped@?1??StepWeaponByID@SMSClass@@QAEXXZ@4HA, 0

; 4097 : 					return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _list$[ebp]
	call	??1AList@@QAE@XZ
	jmp	SHORT $LN30@StepWeapon
$LN5@StepWeapon:

; 4098 : 				}
; 4099 : 			}
; 4100 : 			newHp = numHardpoints - newHp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, DWORD PTR _newHp$[ebp]
	mov	DWORD PTR _newHp$[ebp], edx

; 4101 : 		}

	jmp	$LN7@StepWeapon
$LN6@StepWeapon:

; 4102 : 		startHp--;

	mov	eax, DWORD PTR _startHp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _startHp$[ebp], eax

; 4103 : 	}

	jmp	$LN10@StepWeapon
$LN9@StepWeapon:

; 4104 : 
; 4105 : 	SetCurrentWeapon(-1, NULL);

	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 4106 : 	looped = 0;

	mov	DWORD PTR ?looped@?1??StepWeaponByID@SMSClass@@QAEXXZ@4HA, 0

; 4107 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _list$[ebp]
	call	??1AList@@QAE@XZ
$LN30@StepWeapon:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?StepWeaponByID@SMSClass@@QAEXXZ$0:
	lea	ecx, DWORD PTR _list$[ebp]
	jmp	??1AList@@QAE@XZ
__unwindfunclet$?StepWeaponByID@SMSClass@@QAEXXZ$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?StepWeaponByID@SMSClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?StepWeaponByID@SMSClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?StepWeaponByID@SMSClass@@QAEXXZ ENDP			; SMSClass::StepWeaponByID
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv72 = -12						; size = 4
_fcc$ = -8						; size = 4
_playerAC$ = -4						; size = 4
?StepAGWeapon@SMSClass@@QAEXXZ PROC			; SMSClass::StepAGWeapon
; _this$ = ecx

; 3871 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3872 : 	FireControlComputer *fcc;
; 3873 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3874 : 
; 3875 : 	if( playerAC			&&
; 3876 :   		playerAC->FCC	)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN6@StepAGWeap
	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN6@StepAGWeap

; 3877 : 	{
; 3878 : 		fcc=playerAC->FCC;

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	DWORD PTR _fcc$[ebp], edx

; 3879 : 
; 3880 : 		//switch(fcc->GetMasterMode())
; 3881 : 		switch(fcc->GetMainMasterMode())

	mov	ecx, DWORD PTR _fcc$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN2@StepAGWeap
	jmp	SHORT $LN1@StepAGWeap
$LN2@StepAGWeap:

; 3882 : 		{
; 3883 : 		case MM_AG:
; 3884 : 				/* After Jettison, we are still in the AGMM, but the curHardpoint is -1 */
; 3885 : 				/* this really screws things up in SetAGMasterModeForCurrentWeapon()    */
; 3886 : 				StepWeaponByID(); // only step if we are already in an AG or gun mode

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepWeaponByID@SMSClass@@QAEXXZ	; SMSClass::StepWeaponByID

; 3887 : 				fcc->SetAGMasterModeForCurrentWeapon(); // let the FCC figure out the best master/sub mode

	mov	ecx, DWORD PTR _fcc$[ebp]
	call	?SetAGMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ ; FireControlComputer::SetAGMasterModeForCurrentWeapon

; 3888 : 				break;

	jmp	SHORT $LN6@StepAGWeap
$LN1@StepAGWeap:

; 3889 : 			default:
; 3890 : 				fcc->EnterAGMasterMode();

	mov	ecx, DWORD PTR _fcc$[ebp]
	call	?EnterAGMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAGMasterMode
$LN6@StepAGWeap:

; 3891 : 				//fcc->SetMasterMode(FireControlComputer::AGGun); // otherwise, change master mode
; 3892 : 		}
; 3893 : 	}
; 3894 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGWeapon@SMSClass@@QAEXXZ ENDP			; SMSClass::StepAGWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv72 = -12						; size = 4
_fcc$ = -8						; size = 4
_playerAC$ = -4						; size = 4
?StepAAWeapon@SMSClass@@QAEXXZ PROC			; SMSClass::StepAAWeapon
; _this$ = ecx

; 3843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3844 : 	FireControlComputer *fcc;
; 3845 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3846 : 
; 3847 : 	if( playerAC			&&
; 3848 :   		playerAC->FCC	)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN6@StepAAWeap
	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN6@StepAAWeap

; 3849 : 	{
; 3850 : 		fcc=playerAC->FCC;

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	DWORD PTR _fcc$[ebp], edx

; 3851 : 
; 3852 : 		switch(fcc->GetMasterMode())

	mov	ecx, DWORD PTR _fcc$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 10			; 0000000aH
	ja	SHORT $LN1@StepAAWeap
	mov	eax, DWORD PTR tv72[ebp]
	movzx	ecx, BYTE PTR $LN8@StepAAWeap[eax]
	jmp	DWORD PTR $LN9@StepAAWeap[ecx*4]
$LN2@StepAAWeap:

; 3853 : 		{
; 3854 : 			case FireControlComputer::MissileOverride:
; 3855 : 			case FireControlComputer::Dogfight:
; 3856 : 			case FireControlComputer::Missile:
; 3857 : 			case FireControlComputer::AAGun:
; 3858 : 				StepWeaponByID(); // only step if we are already in an AA or gun mode

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepWeaponByID@SMSClass@@QAEXXZ	; SMSClass::StepWeaponByID

; 3859 : 				fcc->SetAAMasterModeForCurrentWeapon(); // let the FCC figure out the best master/sub mode

	mov	ecx, DWORD PTR _fcc$[ebp]
	call	?SetAAMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ ; FireControlComputer::SetAAMasterModeForCurrentWeapon

; 3860 : 				break;

	jmp	SHORT $LN6@StepAAWeap
$LN1@StepAAWeap:

; 3861 : 			default:
; 3862 : 				fcc->EnterAAMasterMode();

	mov	ecx, DWORD PTR _fcc$[ebp]
	call	?EnterAAMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAAMasterMode
$LN6@StepAAWeap:

; 3863 : //				fcc->SetMasterMode(FireControlComputer::Missile); // otherwise, change master mode
; 3864 : 				break;
; 3865 : 		}
; 3866 : 	}
; 3867 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@StepAAWeap:
	DD	$LN2@StepAAWeap
	DD	$LN1@StepAAWeap
$LN8@StepAAWeap:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
?StepAAWeapon@SMSClass@@QAEXXZ ENDP			; SMSClass::StepAAWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_Id$ = 8						; size = 4
?SetCurrentHpByWeaponId@SMSClass@@QAEHH@Z PROC		; SMSClass::SetCurrentHpByWeaponId
; _this$ = ecx

; 4122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4123 : 	int i;
; 4124 :     for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SetCurrent
$LN3@SetCurrent:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SetCurrent:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN2@SetCurrent

; 4125 :     {
; 4126 : 		if( hardPoint[i]->weaponId == Id &&
; 4127 : 			hardPoint[i]->weaponCount > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	cmp	ecx, DWORD PTR _Id$[ebp]
	jne	SHORT $LN1@SetCurrent
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	jle	SHORT $LN1@SetCurrent

; 4128 : 		{
; 4129 : 			SetCurrentWeapon(i);

	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 4130 : 			return(1);

	mov	eax, 1
	jmp	SHORT $LN5@SetCurrent
$LN1@SetCurrent:

; 4131 : 		}
; 4132 : 	}

	jmp	SHORT $LN3@SetCurrent
$LN2@SetCurrent:

; 4133 : 	SetCurrentWeapon(-1);

	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 4134 : 	return(0);

	xor	eax, eax
$LN5@SetCurrent:

; 4135 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCurrentHpByWeaponId@SMSClass@@QAEHH@Z ENDP		; SMSClass::SetCurrentHpByWeaponId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWeaponId@SMSClass@@QAEHXZ PROC		; SMSClass::GetCurrentWeaponId
; _this$ = ecx

; 4138 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4139 : 	if (curHardpoint > -1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], -1
	jle	SHORT $LN1@GetCurrent

; 4140 : 		return hardPoint[curHardpoint]->weaponId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	movsx	eax, WORD PTR [edx+8]
	jmp	SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 4141 : 	return 0;

	xor	eax, eax
$LN2@GetCurrent:

; 4142 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeaponId@SMSClass@@QAEHXZ ENDP		; SMSClass::GetCurrentWeaponId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z PROC	; SMSClass::SetCoolState, COMDAT
; _this$ = ecx

; 271  : 	void SetCoolState (Aim9Mode state) { aim9mode = state; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+180], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ENDP	; SMSClass::SetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ PROC	; SMSClass::GetCoolState, COMDAT
; _this$ = ecx

; 270  : 	Aim9Mode GetCoolState() { return aim9mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ENDP	; SMSClass::GetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv361 = -56						; size = 4
tv356 = -52						; size = 4
tv347 = -48						; size = 4
tv342 = -44						; size = 4
tv326 = -40						; size = 4
tv321 = -36						; size = 4
tv310 = -32						; size = 4
tv247 = -28						; size = 4
_lwing$ = -24						; size = 4
_rwing$ = -20						; size = 4
_count$ = -16						; size = 4
_center$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_noseAngle$ = 8						; size = 4
?RipOffWeapons@SMSClass@@QAEXM@Z PROC			; SMSClass::RipOffWeapons
; _this$ = ecx

; 3400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 3401 : 	//we have only a gun or no weapons
; 3402 : 	if(numHardpoints <= 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jg	SHORT $LN19@RipOffWeap

; 3403 : 		return;

	jmp	$LN20@RipOffWeap
$LN19@RipOffWeap:

; 3404 : 
; 3405 : 	int lwing = 1;

	mov	DWORD PTR _lwing$[ebp], 1

; 3406 : 	int	rwing = numHardpoints - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	DWORD PTR _rwing$[ebp], edx

; 3407 : 	int center = 0;

	mov	DWORD PTR _center$[ebp], 0

; 3408 : 	int count = numHardpoints - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 3409 : 	int i;
; 3410 : 
; 3411 : 	if(count % 2){

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN24@RipOffWeap
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN24@RipOffWeap:
	test	edx, edx
	je	SHORT $LN18@RipOffWeap

; 3412 : 		center = count / 2 + 1;

	mov	eax, DWORD PTR _count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	mov	DWORD PTR _center$[ebp], eax
$LN18@RipOffWeap:

; 3413 : 	}
; 3414 : 
; 3415 : 	if(fabs(noseAngle) < 0.2588F){

	push	ecx
	movss	xmm0, DWORD PTR _noseAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv310[ebp]
	movss	xmm0, DWORD PTR __real@3e84816f
	comiss	xmm0, DWORD PTR tv310[ebp]
	jbe	$LN2@RipOffWeap

; 3416 : 		//remove left wingtip weapon
; 3417 : 		if(ownship->platformAngles.sinphi < -0.5F){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR __real@bf000000
	comiss	xmm0, DWORD PTR [ecx+396]
	jbe	SHORT $LN16@RipOffWeap

; 3418 : 			if(curHardpoint == lwing){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR _lwing$[ebp]
	jne	SHORT $LN15@RipOffWeap

; 3419 : 				ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon
$LN15@RipOffWeap:

; 3420 : 			}
; 3421 : 			JettisonStation(lwing, RippedOff);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _lwing$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
$LN16@RipOffWeap:

; 3422 : 		}
; 3423 : 			
; 3424 : 		//remove left wing stores
; 3425 : 		if(ownship->Roll() > -30.0F * DTR && ownship->Roll() < -10.0F * DTR){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv321[ebp]
	movss	xmm0, DWORD PTR tv321[ebp]
	comiss	xmm0, DWORD PTR __real@bf060a91
	jbe	SHORT $LN11@RipOffWeap
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv326[ebp]
	movss	xmm0, DWORD PTR __real@be32b8c1
	comiss	xmm0, DWORD PTR tv326[ebp]
	jbe	SHORT $LN11@RipOffWeap

; 3426 : 			for(i = lwing + 1; i < count/2 + 1; i++){

	mov	ecx, DWORD PTR _lwing$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN13@RipOffWeap
$LN12@RipOffWeap:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@RipOffWeap:
	mov	eax, DWORD PTR _count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN11@RipOffWeap

; 3427 : 				if(curHardpoint == i){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	ecx, DWORD PTR _i$[ebp]
	jne	SHORT $LN10@RipOffWeap

; 3428 : 					ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon
$LN10@RipOffWeap:

; 3429 : 				}
; 3430 : 				JettisonStation(i, RippedOff);

	push	32					; 00000020H
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation

; 3431 : 			}

	jmp	SHORT $LN12@RipOffWeap
$LN11@RipOffWeap:

; 3432 : 		}
; 3433 : 
; 3434 : 		//remove centerline stores
; 3435 : 		if(center && ownship->Roll() > -20.0F * DTR && ownship->Roll() < 20.0F * DTR){

	cmp	DWORD PTR _center$[ebp], 0
	je	SHORT $LN9@RipOffWeap
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv342[ebp]
	movss	xmm0, DWORD PTR tv342[ebp]
	comiss	xmm0, DWORD PTR __real@beb2b8c1
	jbe	SHORT $LN9@RipOffWeap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv347[ebp]
	movss	xmm0, DWORD PTR __real@3eb2b8c1
	comiss	xmm0, DWORD PTR tv347[ebp]
	jbe	SHORT $LN9@RipOffWeap

; 3436 : 			if(curHardpoint == center){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR _center$[ebp]
	jne	SHORT $LN8@RipOffWeap

; 3437 : 				ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon
$LN8@RipOffWeap:

; 3438 : 			}
; 3439 : 			JettisonStation(center,RippedOff);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
$LN9@RipOffWeap:

; 3440 : 		}
; 3441 : 
; 3442 : 		//remove right wing stores
; 3443 : 		if(ownship->Roll() > 10.0F * DTR && ownship->Roll() < 30.0F *DTR){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv356[ebp]
	movss	xmm0, DWORD PTR tv356[ebp]
	comiss	xmm0, DWORD PTR __real@3e32b8c1
	jbe	SHORT $LN4@RipOffWeap
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv361[ebp]
	movss	xmm0, DWORD PTR __real@3f060a91
	comiss	xmm0, DWORD PTR tv361[ebp]
	jbe	SHORT $LN4@RipOffWeap

; 3444 : 			for(i = count/2 + 1 + (center?1:0); i < rwing; i++){

	cmp	DWORD PTR _center$[ebp], 0
	je	SHORT $LN22@RipOffWeap
	mov	DWORD PTR tv247[ebp], 1
	jmp	SHORT $LN23@RipOffWeap
$LN22@RipOffWeap:
	mov	DWORD PTR tv247[ebp], 0
$LN23@RipOffWeap:
	mov	eax, DWORD PTR _count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv247[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN6@RipOffWeap
$LN5@RipOffWeap:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@RipOffWeap:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _rwing$[ebp]
	jge	SHORT $LN4@RipOffWeap

; 3445 : 				if(curHardpoint == i){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN3@RipOffWeap

; 3446 : 					ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon
$LN3@RipOffWeap:

; 3447 : 				}
; 3448 : 				JettisonStation(i,RippedOff);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation

; 3449 : 			}

	jmp	SHORT $LN5@RipOffWeap
$LN4@RipOffWeap:

; 3450 : 		}
; 3451 : 
; 3452 : 		//remove right wingtip weapon
; 3453 : 		if(rwing && ownship->platformAngles.sinphi > 0.5F){

	cmp	DWORD PTR _rwing$[ebp], 0
	je	SHORT $LN2@RipOffWeap
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR [eax+396]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN2@RipOffWeap

; 3454 : 			if(curHardpoint == rwing){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR _rwing$[ebp]
	jne	SHORT $LN1@RipOffWeap

; 3455 : 				ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon
$LN1@RipOffWeap:

; 3456 : 			}
; 3457 : 			JettisonStation(rwing,RippedOff);

	push	32					; 00000020H
	mov	eax, DWORD PTR _rwing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
$LN2@RipOffWeap:
$LN20@RipOffWeap:

; 3458 : 		}
; 3459 : 	}
; 3460 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RipOffWeapons@SMSClass@@QAEXM@Z ENDP			; SMSClass::RipOffWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_storespeed$ = -16					; size = 4
_gLimit$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_hardpoint$ = 8						; size = 4
?ChooseLimiterMode@SMSClass@@QAEXH@Z PROC		; SMSClass::ChooseLimiterMode
; _this$ = ecx

; 3556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3557 : 	int i;
; 3558 : 	float gLimit;
; 3559 : 	float storespeed;//me123 
; 3560 : 
; 3561 : 	gLimit = 9.0f;//me123

	movss	xmm0, DWORD PTR __real@41100000
	movss	DWORD PTR _gLimit$[ebp], xmm0

; 3562 :  	storespeed = 800.0f;//me123

	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR _storespeed$[ebp], xmm0

; 3563 : 
; 3564 : 	if(ownship->IsAirplane() && ((AircraftClass *)ownship)->af &&
; 3565 : 		!((AircraftClass *)ownship)->af->IsSet(AirframeClass::IsDigital))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN25@ChooseLimi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	cmp	DWORD PTR [ecx+932], 0
	je	$LN25@ChooseLimi
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN25@ChooseLimi

; 3566 : 	{
; 3567 : 		gLimit = ((AircraftClass *)ownship)->af->MaxGs();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	fstp	DWORD PTR _gLimit$[ebp]

; 3568 : 		
; 3569 : 		//MI
; 3570 : 		//if(!g_bEnableCATIIIExtension || ((AircraftClass *)ownship)->af->IsSet(AirframeClass::IsDigital))
; 3571 : 		if(!g_bRealisticAvionics || ((AircraftClass *)ownship)->af->IsSet(AirframeClass::IsDigital))

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN23@ChooseLimi
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN24@ChooseLimi
$LN23@ChooseLimi:

; 3572 : 			((AircraftClass *)ownship)->af->ClearFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN24@ChooseLimi:

; 3573 : 
; 3574 : 		if(gLimiterMgr->HasLimiter(CatIIICommandType, ((AircraftClass *)ownship)->af->VehicleIndex()) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?VehicleIndex@AirframeClass@@QAEHXZ	; AirframeClass::VehicleIndex
	push	eax
	push	5
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?HasLimiter@LimiterMgrClass@@QAEHHH@Z	; LimiterMgrClass::HasLimiter
	test	eax, eax
	je	$LN19@ChooseLimi

; 3575 : 		{
; 3576 : 			for(i = 0; i < numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@ChooseLimi
$LN20@ChooseLimi:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN21@ChooseLimi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN19@ChooseLimi

; 3577 : 			{
; 3578 : 
; 3579 : 				if(hardPoint[i] && hardPoint[i]->weaponPointer &&
; 3580 : 					hardPoint[i]->weaponCount > 0 &&
; 3581 : 					(hardPoint[i]->GetWeaponClass() == wcRocketWpn	||
; 3582 : 					hardPoint[i]->GetWeaponClass() == wcBombWpn		||
; 3583 : 					hardPoint[i]->GetWeaponClass() == wcTank		||
; 3584 : 					hardPoint[i]->GetWeaponClass() == wcAgmWpn		||
; 3585 : 					hardPoint[i]->GetWeaponClass() == wcHARMWpn		||
; 3586 : 					hardPoint[i]->GetWeaponClass() == wcSamWpn		||
; 3587 : 					hardPoint[i]->GetWeaponClass() == wcGbuWpn)				 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	$LN1@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@ChooseLimi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	jle	$LN1@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 1
	je	$LN17@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 2
	je	$LN17@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 5
	je	$LN17@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 6
	je	SHORT $LN17@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 7
	je	SHORT $LN17@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 8
	je	SHORT $LN17@ChooseLimi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 9
	jne	$LN1@ChooseLimi
$LN17@ChooseLimi:

; 3588 : 				{
; 3589 : // OW CATIII Fix 
; 3590 : 					//if(!g_bEnableCATIIIExtension)	MI
; 3591 : 					if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN16@ChooseLimi

; 3592 : 					{
; 3593 : 						if(hardPoint[i]->GetWeaponClass() == wcTank)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN15@ChooseLimi

; 3594 : 						{
; 3595 : 							((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3596 : 							if(gLimit > 7.5F)

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR __real@40f00000
	jbe	SHORT $LN14@ChooseLimi

; 3597 : 								gLimit = 7.5F;

	movss	xmm0, DWORD PTR __real@40f00000
	movss	DWORD PTR _gLimit$[ebp], xmm0
$LN14@ChooseLimi:

; 3598 : 						}
; 3599 : 						else

	jmp	SHORT $LN12@ChooseLimi
$LN15@ChooseLimi:

; 3600 : 						{
; 3601 : 							((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3602 : 							if(gLimit > 6.0F)

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR __real@40c00000
	jbe	SHORT $LN12@ChooseLimi

; 3603 : 								gLimit = 6.0F;

	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR _gLimit$[ebp], xmm0
$LN12@ChooseLimi:

; 3604 : 						}
; 3605 : 					}
; 3606 : 
; 3607 : 					else

	jmp	$LN1@ChooseLimi
$LN16@ChooseLimi:

; 3608 : 					{
; 3609 : 						if(hardPoint[i]->GetWeaponClass() == wcTank )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, 5
	jne	$LN10@ChooseLimi

; 3610 : 						{
; 3611 : 							if (((AircraftClass *)ownship)->af->IsSet(AirframeClass::IsDigital))//me123 don't change cat for player check addet

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN9@ChooseLimi

; 3612 : 							{
; 3613 : 							((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
$LN9@ChooseLimi:

; 3614 : 							}
; 3615 : 							/*if(gLimit > 7.0F)//me123 addet fuel check
; 3616 : 							{
; 3617 : 								storespeed = 600.0f;//me123
; 3618 : 								if (((AircraftClass *)ownship)->af->ExternalFuel() >=1.0f)
; 3619 : 								gLimit = 7.0F;//me123 tanks g limit is 7Gz			
; 3620 : 							}*/
; 3621 : 							//MI me123... we need to check which tank we have here too
; 3622 : 							if (i == numHardpoints /2) // centerline tank

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN8@ChooseLimi

; 3623 : 							{
; 3624 : 								// MD -- 20040531: quick fix for JPO...if there's no fuel on the centerline, don't
; 3625 : 								// set the limiter
; 3626 : 								if (((AircraftClass *)ownship)->af->m_tanks[AirframeClass::TANK_CLINE] > 0.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, 4
	shl	eax, 3
	movss	xmm0, DWORD PTR [edx+eax+1688]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@ChooseLimi

; 3627 : 								{
; 3628 : 						 			if(gLimit > 7.0F)//me123 from 7.5

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR __real@40e00000
	jbe	SHORT $LN6@ChooseLimi

; 3629 : 						 			{
; 3630 : 						 				gLimit = 7.0F;//me123 from 7.5

	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR _gLimit$[ebp], xmm0

; 3631 : 						 				storespeed = 600.0f;//me123

	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR _storespeed$[ebp], xmm0
$LN6@ChooseLimi:

; 3632 : 						 			}
; 3633 : 								}
; 3634 : 							}
; 3635 : 							else // dollys

	jmp	SHORT $LN4@ChooseLimi
$LN8@ChooseLimi:

; 3636 : 							{ 
; 3637 : 					 			if(gLimit > 6.5F) 

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR __real@40d00000
	jbe	SHORT $LN4@ChooseLimi

; 3638 : 					 			{
; 3639 : 					 				gLimit = 6.5F; 

	movss	xmm0, DWORD PTR __real@40d00000
	movss	DWORD PTR _gLimit$[ebp], xmm0

; 3640 : 					 				storespeed = 600.0f;//me123

	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR _storespeed$[ebp], xmm0
$LN4@ChooseLimi:

; 3641 : 					 			}
; 3642 : 							}
; 3643 : 						}
; 3644 : 						else 

	jmp	SHORT $LN1@ChooseLimi
$LN10@ChooseLimi:

; 3645 : 						{
; 3646 : 							if (((AircraftClass *)ownship)->af->IsSet(AirframeClass::IsDigital))//me123 don't change cat for player check addet

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@ChooseLimi

; 3647 : 							{
; 3648 : 								((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
$LN2@ChooseLimi:

; 3649 : 							}
; 3650 : 							if(gLimit > 5.5F)

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR __real@40b00000
	jbe	SHORT $LN1@ChooseLimi

; 3651 : 							{
; 3652 : 								gLimit = 5.5F;//me123 stores in general has 5.5 g limit

	movss	xmm0, DWORD PTR __real@40b00000
	movss	DWORD PTR _gLimit$[ebp], xmm0

; 3653 : 								storespeed = 550.0f;//me123

	movss	xmm0, DWORD PTR __real@44098000
	movss	DWORD PTR _storespeed$[ebp], xmm0
$LN1@ChooseLimi:

; 3654 : 							}
; 3655 : 						}
; 3656 : 					}
; 3657 : 				}
; 3658 : 			}

	jmp	$LN20@ChooseLimi
$LN19@ChooseLimi:

; 3659 : 		}
; 3660 : 		((AircraftClass *)ownship)->af->curMaxGs = gLimit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR _gLimit$[ebp]
	movss	DWORD PTR [ecx+1244], xmm0

; 3661 : 		((AircraftClass *)ownship)->af->curMaxStoreSpeed = storespeed;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR _storespeed$[ebp]
	movss	DWORD PTR [ecx+1612], xmm0
$LN25@ChooseLimi:

; 3662 : 	}
; 3663 : 	
; 3664 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ChooseLimiterMode@SMSClass@@QAEXH@Z ENDP		; SMSClass::ChooseLimiterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_x$ = -16						; size = 4
_z$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
_station$ = 8						; size = 4
_storeId$ = 12						; size = 4
_visible$ = 16						; size = 4
?AddStore@SMSClass@@QAEXHHH@Z PROC			; SMSClass::AddStore
; _this$ = ecx

; 3463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3464 : 	float x,y,z;
; 3465 : 
; 3466 : 	if(ownship->IsAirplane() && !UnlimitedAmmo())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN1@AddStore
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlimitedAmmo@SMSClass@@QAEHXZ		; SMSClass::UnlimitedAmmo
	test	eax, eax
	jne	$LN1@AddStore

; 3467 : 	{
; 3468 : 		ShiAssert(((AircraftClass *)ownship)->af);
; 3469 : 
; 3470 : 		hardPoint[station]->GetPosition(&x,&y,&z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 3471 : 
; 3472 : 		if( ((AircraftClass *)ownship)->IsF16() && (station == 1 || station ==9) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	SHORT $LN22@AddStore
	cmp	DWORD PTR _station$[ebp], 1
	je	SHORT $LN21@AddStore
	cmp	DWORD PTR _station$[ebp], 9
	jne	SHORT $LN22@AddStore
$LN21@AddStore:

; 3473 : 			((AircraftClass *)ownship)->af->AddWeapon(	WeaponDataTable[storeId].Weight, 0.0F, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _storeId$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?AddWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::AddWeapon
	jmp	$LN18@AddStore
$LN22@AddStore:

; 3474 : 		else if(visible)

	cmp	DWORD PTR _visible$[ebp], 0
	je	SHORT $LN19@AddStore

; 3475 : 			((AircraftClass *)ownship)->af->AddWeapon(	WeaponDataTable[storeId].Weight, 
; 3476 : 			WeaponDataTable[storeId].DragIndex,
; 3477 : 			y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _storeId$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	edx, WORD PTR [ecx+eax+50]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _storeId$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?AddWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::AddWeapon

; 3478 : 		else

	jmp	SHORT $LN18@AddStore
$LN19@AddStore:

; 3479 : 			((AircraftClass *)ownship)->af->AddWeapon(	WeaponDataTable[storeId].Weight, 0.0F, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _storeId$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+48]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?AddWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::AddWeapon
$LN18@AddStore:

; 3480 : 
; 3481 : 		if( gLimiterMgr->HasLimiter(CatIIICommandType, ((AircraftClass *)ownship)->af->VehicleIndex()) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?VehicleIndex@AirframeClass@@QAEHXZ	; AirframeClass::VehicleIndex
	push	eax
	push	5
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?HasLimiter@LimiterMgrClass@@QAEHHH@Z	; LimiterMgrClass::HasLimiter
	test	eax, eax
	je	$LN1@AddStore

; 3482 : 		{
; 3483 : 			if(	hardPoint[station]->GetWeaponClass() == wcRocketWpn		||
; 3484 : 				hardPoint[station]->GetWeaponClass() == wcBombWpn		||
; 3485 : 				hardPoint[station]->GetWeaponClass() == wcTank			||
; 3486 : 				hardPoint[station]->GetWeaponClass() == wcAgmWpn		||
; 3487 : 				hardPoint[station]->GetWeaponClass() == wcHARMWpn		||
; 3488 : 				hardPoint[station]->GetWeaponClass() == wcSamWpn		||
; 3489 : 				hardPoint[station]->GetWeaponClass() == wcGbuWpn )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 1
	je	$LN15@AddStore
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 2
	je	$LN15@AddStore
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 5
	je	$LN15@AddStore
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 6
	je	SHORT $LN15@AddStore
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 7
	je	SHORT $LN15@AddStore
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 8
	je	SHORT $LN15@AddStore
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 9
	jne	$LN1@AddStore
$LN15@AddStore:

; 3490 : 			{
; 3491 : 
; 3492 : 				// OW CATIII Fix 
; 3493 : 				//if(!g_bEnableCATIIIExtension)	MI
; 3494 : 				if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN14@AddStore

; 3495 : 				{
; 3496 : 					((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3497 : 					if(hardPoint[station]->GetWeaponClass() == wcTank)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN13@AddStore

; 3498 : 					{
; 3499 : 						if(((AircraftClass *)ownship)->af->curMaxGs > 7.5F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1244]
	comiss	xmm0, DWORD PTR __real@40f00000
	jbe	SHORT $LN12@AddStore

; 3500 : 							((AircraftClass *)ownship)->af->curMaxGs = 7.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@40f00000
	movss	DWORD PTR [edx+1244], xmm0
$LN12@AddStore:

; 3501 : 					}
; 3502 : 					else

	jmp	SHORT $LN10@AddStore
$LN13@AddStore:

; 3503 : 					{
; 3504 : 						if(((AircraftClass *)ownship)->af->curMaxGs > 6.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1244]
	comiss	xmm0, DWORD PTR __real@40c00000
	jbe	SHORT $LN10@AddStore

; 3505 : 							((AircraftClass *)ownship)->af->curMaxGs = 6.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR [edx+1244], xmm0
$LN10@AddStore:

; 3506 : 					}
; 3507 : 				}
; 3508 : 
; 3509 : 				else

	jmp	$LN1@AddStore
$LN14@AddStore:

; 3510 : 				{
; 3511 : 					if (((AircraftClass *)ownship)->af->IsSet(AirframeClass::IsDigital))//me123 let's only set the cat switch for ai

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN8@AddStore

; 3512 : 						((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
$LN8@AddStore:

; 3513 : 
; 3514 : 					if(hardPoint[station]->GetWeaponClass() == wcTank)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _station$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 5
	jne	$LN7@AddStore

; 3515 : 					{
; 3516 : 						// MD -- 20040531: quick fix for JPO...if there's no fuel on the centerline, don't
; 3517 : 						// set the limiter
; 3518 : 						if ((station == numHardpoints /2) &&  (((AircraftClass *)ownship)->af->m_tanks[AirframeClass::TANK_CLINE] > 0.0F))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _station$[ebp], eax
	jne	$LN6@AddStore
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, 4
	shl	edx, 3
	movss	xmm0, DWORD PTR [ecx+edx+1688]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@AddStore

; 3519 : 						//if ((station == 5) &&  (((AircraftClass *)ownship)->af->m_tanks[AirframeClass::TANK_CLINE] > 0.0F))
; 3520 : 						//if (station == 5) // centerline tank
; 3521 : 						//if (station == numHardpoints /2) // centerline tank
; 3522 : 						{
; 3523 : 							if(((AircraftClass *)ownship)->af->curMaxGs > 7.0F)//me123 from 7.5

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1244]
	comiss	xmm0, DWORD PTR __real@40e00000
	jbe	SHORT $LN5@AddStore

; 3524 : 							{
; 3525 : 								((AircraftClass *)ownship)->af->curMaxGs = 7.0F;//me123 from 7.5

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [edx+1244], xmm0

; 3526 : 								((AircraftClass *)ownship)->af->curMaxStoreSpeed = 600.0f;//me123

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR [edx+1612], xmm0

; 3527 : 								((AircraftClass *)ownship)->af->ClearFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN5@AddStore:

; 3528 : 							}
; 3529 : 						}
; 3530 : 						else // dollys

	jmp	SHORT $LN3@AddStore
$LN6@AddStore:

; 3531 : 						{
; 3532 : 							if(((AircraftClass *)ownship)->af->curMaxGs > 6.5F) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1244]
	comiss	xmm0, DWORD PTR __real@40d00000
	jbe	SHORT $LN3@AddStore

; 3533 : 							{
; 3534 : 								((AircraftClass *)ownship)->af->curMaxGs = 6.5F; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@40d00000
	movss	DWORD PTR [ecx+1244], xmm0

; 3535 : 								((AircraftClass *)ownship)->af->curMaxStoreSpeed = 600.0f;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR [ecx+1612], xmm0

; 3536 : 								((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
$LN3@AddStore:

; 3537 : 							}
; 3538 : 						}
; 3539 : 					}
; 3540 : 					else

	jmp	SHORT $LN1@AddStore
$LN7@AddStore:

; 3541 : 					{
; 3542 : 						if(((AircraftClass *)ownship)->af->curMaxGs > 5.5F)//me123 from 6.0

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1244]
	comiss	xmm0, DWORD PTR __real@40b00000
	jbe	SHORT $LN1@AddStore

; 3543 : 						{
; 3544 : 							((AircraftClass *)ownship)->af->curMaxGs = 5.5F;//me123 from 6.0

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@40b00000
	movss	DWORD PTR [eax+1244], xmm0

; 3545 : 							((AircraftClass *)ownship)->af->curMaxStoreSpeed = 550.0f;//me123

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@44098000
	movss	DWORD PTR [eax+1612], xmm0
$LN1@AddStore:

; 3546 : 						}
; 3547 : 					}
; 3548 : 				}
; 3549 : 			}
; 3550 : 		}
; 3551 : 
; 3552 : 	}
; 3553 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddStore@SMSClass@@QAEXHHH@Z ENDP			; SMSClass::AddStore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_x$ = -24						; size = 4
_z$ = -20						; size = 4
_playerAC$ = -16					; size = 4
_vc$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
_station$ = 8						; size = 4
_storeId$ = 12						; size = 4
?RemoveStore@SMSClass@@QAEXHH@Z PROC			; SMSClass::RemoveStore
; _this$ = ecx

; 3667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3668 : 	VehicleClassDataType* vc;
; 3669 : 	float x, y, z;
; 3670 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3671 : 
; 3672 : 	//ShiAssert(hardPoint[station]->weaponCount > 0);
; 3673 :    if (hardPoint[station]->weaponCount >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+10]
	test	ecx, ecx
	jl	$LN1@RemoveStor

; 3674 :    {
; 3675 : 	   if(ownship->IsAirplane() && !UnlimitedAmmo())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN12@RemoveStor
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlimitedAmmo@SMSClass@@QAEHXZ		; SMSClass::UnlimitedAmmo
	test	eax, eax
	jne	$LN12@RemoveStor

; 3676 : 	   {
; 3677 : 		   vc = GetVehicleClassData(ownship->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	edx, ax
	sub	edx, 100				; 00000064H
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 3678 : 		   ShiAssert(((AircraftClass *)ownship)->af );
; 3679 : 		   
; 3680 : 		   hardPoint[station]->GetPosition(&x, &y, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 3681 : 
; 3682 : 		   if( ((AircraftClass *)ownship)->IsF16() && (station == 2 || station == 8) && storeId == gRackId_Single_Rack)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	SHORT $LN11@RemoveStor
	cmp	DWORD PTR _station$[ebp], 2
	je	SHORT $LN10@RemoveStor
	cmp	DWORD PTR _station$[ebp], 8
	jne	SHORT $LN11@RemoveStor
$LN10@RemoveStor:
	movsx	ecx, WORD PTR ?gRackId_Single_Rack@@3FA	; gRackId_Single_Rack
	cmp	DWORD PTR _storeId$[ebp], ecx
	jne	SHORT $LN11@RemoveStor

; 3683 : 			   ((AircraftClass *)ownship)->af->RemoveWeapon( WeaponDataTable[storeId].Weight - 283.0F, WeaponDataTable[storeId].DragIndex - 11.0F, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _storeId$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx+50]
	cvtsi2ss xmm0, ecx
	subss	xmm0, DWORD PTR __real@41300000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _storeId$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+48]
	cvtsi2ss xmm0, ecx
	subss	xmm0, DWORD PTR __real@438d8000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?RemoveWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::RemoveWeapon
	jmp	$LN4@RemoveStor
$LN11@RemoveStor:

; 3684 : 		   else if	( ((AircraftClass *)ownship)->IsF16() && (station == 1 || station ==9) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	SHORT $LN8@RemoveStor
	cmp	DWORD PTR _station$[ebp], 1
	je	SHORT $LN7@RemoveStor
	cmp	DWORD PTR _station$[ebp], 9
	jne	SHORT $LN8@RemoveStor
$LN7@RemoveStor:

; 3685 : 			   ((AircraftClass *)ownship)->af->RemoveWeapon(WeaponDataTable[storeId].Weight, 0.0F, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _storeId$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+48]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?RemoveWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::RemoveWeapon
	jmp	$LN4@RemoveStor
$LN8@RemoveStor:

; 3686 : 		   else if(vc->VisibleFlags & (1 << station))

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+62]
	mov	eax, 1
	mov	ecx, DWORD PTR _station$[ebp]
	shl	eax, cl
	and	edx, eax
	je	SHORT $LN5@RemoveStor

; 3687 : 			   ((AircraftClass *)ownship)->af->RemoveWeapon(	WeaponDataTable[storeId].Weight, 
; 3688 : 															   WeaponDataTable[storeId].DragIndex, 
; 3689 : 															   y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _storeId$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx+50]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _storeId$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?RemoveWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::RemoveWeapon

; 3690 : 		   else

	jmp	SHORT $LN4@RemoveStor
$LN5@RemoveStor:

; 3691 : 			   ((AircraftClass *)ownship)->af->RemoveWeapon(WeaponDataTable[storeId].Weight, 0.0F, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _storeId$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?RemoveWeapon@AirframeClass@@QAEXMMM@Z	; AirframeClass::RemoveWeapon
$LN4@RemoveStor:

; 3692 : 
; 3693 : 		   ChooseLimiterMode(station);

	mov	edx, DWORD PTR _station$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseLimiterMode@SMSClass@@QAEXH@Z	; SMSClass::ChooseLimiterMode
$LN12@RemoveStor:

; 3694 : 	   }
; 3695 : 
; 3696 :       if (ownship == playerAC)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR _playerAC$[ebp]
	jne	SHORT $LN1@RemoveStor

; 3697 :       {
; 3698 :          if (station < numHardpoints / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _station$[ebp], eax
	jge	SHORT $LN2@RemoveStor

; 3699 :             JoystickPlayEffect (JoyLeftDrop, 0);

	push	0
	push	5
	call	?JoystickPlayEffect@@YAHHH@Z		; JoystickPlayEffect
	add	esp, 8

; 3700 :          else

	jmp	SHORT $LN1@RemoveStor
$LN2@RemoveStor:

; 3701 :             JoystickPlayEffect (JoyRightDrop, 0);

	push	0
	push	6
	call	?JoystickPlayEffect@@YAHHH@Z		; JoystickPlayEffect
	add	esp, 8
$LN1@RemoveStor:

; 3702 :       }
; 3703 :    }
; 3704 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveStore@SMSClass@@QAEXHH@Z ENDP			; SMSClass::RemoveStore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_harmPod$ = -20						; size = 4
_playerAC$ = -16					; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
_FCC$ = -4						; size = 4
_newtype$ = 8						; size = 4
_domainDesired$ = 12					; size = 4
?SelectWeapon@SMSClass@@QAEXW4WeaponType@@W4WeaponDomain@@@Z PROC ; SMSClass::SelectWeapon
; _this$ = ecx

; 2651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2652 :     FireControlComputer		*FCC = ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	mov	DWORD PTR _FCC$[ebp], eax

; 2653 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2654 : 	HarmTargetingPod* harmPod = (HarmTargetingPod*) FindSensor (ownship, SensorClass::HTS);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _harmPod$[ebp], eax

; 2655 :     // Tell the FCC about the new weapon selection
; 2656 :     switch (newtype)

	mov	edx, DWORD PTR _newtype$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	cmp	DWORD PTR tv94[ebp], 11			; 0000000bH
	ja	$LN35@SelectWeap
	mov	eax, DWORD PTR tv94[ebp]
	jmp	DWORD PTR $LN37@SelectWeap[eax*4]
$LN32@SelectWeap:

; 2657 :     {
; 2658 :     case wtNone:
; 2659 : 		FCC->SetMasterMode( FireControlComputer::Nav );

	push	4
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2660 : 	break;

	jmp	$LN35@SelectWeap
$LN31@SelectWeap:

; 2661 : 
; 2662 : 	// ASSOCIATOR 3/12/03: Added some checks so that it cycles correctly
; 2663 :     case wtAim9:
; 2664 : 	if( FCC->GetMasterMode() == FireControlComputer::Dogfight ) {	 

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN30@SelectWeap

; 2665 : 		FCC->SetDgftSubMode(FireControlComputer::Aim9);

	push	5
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetDgftSubMode
	jmp	SHORT $LN29@SelectWeap
$LN30@SelectWeap:

; 2666 : 	}	
; 2667 : 	else if( FCC->GetMasterMode() == FireControlComputer::MissileOverride ) {

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN28@SelectWeap

; 2668 : 		FCC->SetMrmSubMode(FireControlComputer::Aim9);	// ASSOCIATOR 04/12/03: for remembering MRM mode missiles		

	push	5
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetMrmSubMode

; 2669 : 	} 
; 2670 : 	else {

	jmp	SHORT $LN29@SelectWeap
$LN28@SelectWeap:

; 2671 : 		FCC->SetMasterMode( FireControlComputer::Missile );

	push	2
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2672 : 		FCC->SetSubMode( FireControlComputer::Aim9 );

	push	5
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2673 : 		FCC->lastAirAirSubMode = FireControlComputer::Aim9;

	mov	ecx, DWORD PTR _FCC$[ebp]
	mov	DWORD PTR [ecx+44], 5
$LN29@SelectWeap:

; 2674 : 	}
; 2675 : 	break;

	jmp	$LN35@SelectWeap
$LN26@SelectWeap:

; 2676 : 	
; 2677 : 	// ASSOCIATOR 3/12/03: Added some checks so that it cycles correctly
; 2678 :     case wtAim120:
; 2679 : 	if( FCC->GetMasterMode() == FireControlComputer::Dogfight ) { 

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN25@SelectWeap

; 2680 : 		FCC->SetDgftSubMode(FireControlComputer::Aim120);

	push	6
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetDgftSubMode
	jmp	SHORT $LN24@SelectWeap
$LN25@SelectWeap:

; 2681 : 	}
; 2682 : 	else if( FCC->GetMasterMode() == FireControlComputer::MissileOverride ) {

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN23@SelectWeap

; 2683 : 		FCC->SetMrmSubMode(FireControlComputer::Aim120);	// ASSOCIATOR 04/12/03: for remembering MRM mode missiles		

	push	6
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetMrmSubMode

; 2684 : 	} 
; 2685 : 	else {

	jmp	SHORT $LN24@SelectWeap
$LN23@SelectWeap:

; 2686 : 		FCC->SetMasterMode( FireControlComputer::Missile );

	push	2
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2687 : 		FCC->SetSubMode( FireControlComputer::Aim120 );

	push	6
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2688 : 		FCC->lastAirAirSubMode = FireControlComputer::Aim120;

	mov	edx, DWORD PTR _FCC$[ebp]
	mov	DWORD PTR [edx+44], 6
$LN24@SelectWeap:

; 2689 : 	}
; 2690 : 	break;

	jmp	$LN35@SelectWeap
$LN21@SelectWeap:

; 2691 : 	
; 2692 :     case wtGuns:
; 2693 : 	{ 
; 2694 : 		// ASSOCIATOR 04/12/03: In DGFT we are already in Gun mode
; 2695 : 		if( playerAC->FCC->GetMasterMode() == FireControlComputer::Dogfight )

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN20@SelectWeap

; 2696 : 			return;

	jmp	$LN35@SelectWeap
$LN20@SelectWeap:

; 2697 : 
; 2698 : 		if (domainDesired == wdAir) {

	cmp	DWORD PTR _domainDesired$[ebp], 1
	jne	SHORT $LN19@SelectWeap

; 2699 : 			FCC->SetMasterMode( FireControlComputer::AAGun );

	push	0
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2700 : 			FCC->SetSubMode( FCC->lastAirAirGunSubMode ); // ASSOCIATOR 3/12/03: changed default EEGS to lastAirAirGunSubMode

	mov	ecx, DWORD PTR _FCC$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2701 : 		} else {

	jmp	SHORT $LN18@SelectWeap
$LN19@SelectWeap:

; 2702 : 			FCC->SetMasterMode( FireControlComputer::AGGun );

	push	1
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2703 : 			FCC->SetSubMode( FireControlComputer::STRAF );

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN18@SelectWeap:

; 2704 : 		}
; 2705 : 	}
; 2706 : 	break;

	jmp	$LN35@SelectWeap
$LN17@SelectWeap:

; 2707 : 	
; 2708 :     case wtAgm88:
; 2709 :     	// RV - I-Hawk - Submode will be set in HARM display classes...
; 2710 : 		FCC->SetMasterMode( FireControlComputer::AirGroundHARM );

	push	7
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2711 : 		break;

	jmp	$LN35@SelectWeap
$LN16@SelectWeap:

; 2712 : 	
; 2713 :     case wtAgm65:
; 2714 : 	FCC->SetMasterMode( FireControlComputer::AirGroundMissile );

	push	6
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2715 : 	//MI done elsewhere
; 2716 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN15@SelectWeap

; 2717 : 	{
; 2718 : 		// M.N. no ATRealisticAV check needed here as in AtRealisticAV mode: g_bRealisticAvionics == TRUE
; 2719 : 		if (PlayerOptions.GetAvionicsType() == ATRealistic)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	jne	SHORT $LN14@SelectWeap

; 2720 : 			FCC->SetSubMode( FireControlComputer::BSGT );

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2721 : 		else

	jmp	SHORT $LN15@SelectWeap
$LN14@SelectWeap:

; 2722 : 			FCC->SetSubMode( FireControlComputer::SLAVE );

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN15@SelectWeap:

; 2723 : 	}
; 2724 : 	break;

	jmp	$LN35@SelectWeap
$LN12@SelectWeap:

; 2725 : 	case wtMk82:
; 2726 :     case wtMk84:
; 2727 : 	if (FCC->GetMasterMode() != FireControlComputer::AirGroundBomb )// || // MLR 4/3/2004 - 

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN11@SelectWeap

; 2728 : 	    //FCC->GetSubMode() == FireControlComputer::STRAF ||
; 2729 : 	    //FCC->GetSubMode() == FireControlComputer::OBSOLETERCKT)
; 2730 : 	{
; 2731 : 	    FCC->SetMasterMode( FireControlComputer::AirGroundBomb );

	push	5
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2732 : 	    FCC->SetSubMode( FireControlComputer::CCRP );//me123 don't go to ccip everytime we select a mk82/84 hmm this might be ai stuff

	push	8
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN11@SelectWeap:

; 2733 : 	}
; 2734 : 	break;

	jmp	$LN35@SelectWeap
$LN10@SelectWeap:

; 2735 : 	
; 2736 :     case wtLAU:
; 2737 : //	FCC->SetMasterMode( FireControlComputer::AirGroundBomb ); // MLR 4/3/2004 - 
; 2738 : //	FCC->SetSubMode( FireControlComputer::OBSOLETERCKT );
; 2739 : 	FCC->SetMasterMode( FireControlComputer::AirGroundRocket ); // MLR 4/3/2004 - 

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2740 : 	break;

	jmp	$LN35@SelectWeap
$LN9@SelectWeap:

; 2741 : 	
; 2742 :     case wtGBU:
; 2743 : 	FCC->SetMasterMode( FireControlComputer::AirGroundLaser );

	push	8
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2744 : 	//MI in realistic we start in slave
; 2745 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN8@SelectWeap

; 2746 : 	{
; 2747 : 		if (PlayerOptions.GetAvionicsType() == ATRealistic)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	jne	SHORT $LN7@SelectWeap

; 2748 : 			FCC->SetSubMode( FireControlComputer::BSGT );

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2749 : 		else

	jmp	SHORT $LN6@SelectWeap
$LN7@SelectWeap:

; 2750 : 			FCC->SetSubMode( FireControlComputer::SLAVE );

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN6@SelectWeap:

; 2751 : 	}
; 2752 : 	else

	jmp	SHORT $LN5@SelectWeap
$LN8@SelectWeap:

; 2753 : 	{
; 2754 : 		// M.N. added full realism mode
; 2755 : 		if (PlayerOptions.GetAvionicsType() != ATRealistic && PlayerOptions.GetAvionicsType() != ATRealisticAV)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	je	SHORT $LN4@SelectWeap
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 3
	je	SHORT $LN4@SelectWeap

; 2756 : 			FCC->SetSubMode( FireControlComputer::BSGT );

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2757 : 		else

	jmp	SHORT $LN5@SelectWeap
$LN4@SelectWeap:

; 2758 : 			FCC->SetSubMode( FireControlComputer::SLAVE );

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN5@SelectWeap:

; 2759 : 	}
; 2760 : 	break;

	jmp	SHORT $LN35@SelectWeap
$LN2@SelectWeap:

; 2761 : 	
; 2762 :     case wtFixed:
; 2763 :         if (hardPoint[curHardpoint]->GetWeaponClass() == wcCamera)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN35@SelectWeap

; 2764 :         {
; 2765 : 	    FCC->SetMasterMode( FireControlComputer::AirGroundCamera );

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN35@SelectWeap:

; 2766 :         }
; 2767 : 	break;
; 2768 :     }
; 2769 :     
; 2770 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN37@SelectWeap:
	DD	$LN21@SelectWeap
	DD	$LN31@SelectWeap
	DD	$LN26@SelectWeap
	DD	$LN17@SelectWeap
	DD	$LN16@SelectWeap
	DD	$LN12@SelectWeap
	DD	$LN12@SelectWeap
	DD	$LN9@SelectWeap
	DD	$LN35@SelectWeap
	DD	$LN10@SelectWeap
	DD	$LN2@SelectWeap
	DD	$LN32@SelectWeap
?SelectWeapon@SMSClass@@QAEXW4WeaponType@@W4WeaponDomain@@@Z ENDP ; SMSClass::SelectWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_FCC$ = -24						; size = 4
_pradar$1 = -20						; size = 4
_newType$ = -16						; size = 4
_i$ = -12						; size = 4
_stationUnderTest$ = -8					; size = 4
_this$ = -4						; size = 4
_domainDesired$ = 8					; size = 4
?GetNextWeapon@SMSClass@@QAE?AW4WeaponType@@W4WeaponDomain@@@Z PROC ; SMSClass::GetNextWeapon
; _this$ = ecx

; 2560 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2561 :     WeaponType				newType = curWeaponType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR _newType$[ebp], ecx

; 2562 :     FireControlComputer		*FCC = ownship->GetFCC();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _FCC$[ebp], eax

; 2563 :     int						i=0;

	mov	DWORD PTR _i$[ebp], 0

; 2564 :     int						stationUnderTest=0;

	mov	DWORD PTR _stationUnderTest$[ebp], 0

; 2565 :     
; 2566 :     // Don't do this if we're in the process of firing a weapon
; 2567 :     if (IsSet(Firing)) {

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SMSBaseClass@@QAEHH@Z		; SMSBaseClass::IsSet
	test	eax, eax
	je	SHORT $LN12@GetNextWea

; 2568 : 	return curWeaponType;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+148]
	jmp	$LN13@GetNextWea
$LN12@GetNextWea:

; 2569 :     }
; 2570 :     
; 2571 :     // Find the next hardpoint with a weapon of the desired type on it
; 2572 :     for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@GetNextWea
$LN10@GetNextWea:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN11@GetNextWea:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN9@GetNextWea

; 2573 :     {
; 2574 : 		stationUnderTest = (i + 1 + curHardpoint) % numHardpoints;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax+1]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+40]
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2575 : 		// Marco edit - non-zero weapon check due to problems with weapon cycling
; 2576 : 		if (hardPoint[stationUnderTest] && (hardPoint[stationUnderTest]->GetWeaponData()->domain & domainDesired) && 
; 2577 : 			(hardPoint[stationUnderTest]->weaponCount != 0 || 
; 2578 : 			hardPoint[stationUnderTest]->GetWeaponType() == wtGuns
; 2579 : 			|| hardPoint[stationUnderTest]->GetWeaponType() == wtAgm88
; 2580 : 			|| hardPoint[stationUnderTest]->GetWeaponType() == wtGBU)) // JB 010726 Allow HTS/LaserPod to be selected even when out of weapons

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN8@GetNextWea
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, DWORD PTR _domainDesired$[ebp]
	je	$LN8@GetNextWea
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	jne	SHORT $LN7@GetNextWea
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	test	eax, eax
	je	SHORT $LN7@GetNextWea
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 3
	je	SHORT $LN7@GetNextWea
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 7
	jne	$LN8@GetNextWea
$LN7@GetNextWea:

; 2581 : 		{
; 2582 : 			newType = hardPoint[stationUnderTest]->GetWeaponType();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	mov	DWORD PTR _newType$[ebp], eax

; 2583 : 	    
; 2584 : 			// Set the current hardpoint so that this weapon is actually used
; 2585 : 			//MI 
; 2586 : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@GetNextWea

; 2587 : 			{
; 2588 : 				if(newType == wtAgm65 && curWeaponType != wtAgm65)

	cmp	DWORD PTR _newType$[ebp], 4
	jne	SHORT $LN5@GetNextWea
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+148], 4
	je	SHORT $LN5@GetNextWea

; 2589 : 					StepMavSubMode(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z	; SMSBaseClass::StepMavSubMode
$LN5@GetNextWea:

; 2590 : 			}
; 2591 : 			ReleaseCurWeapon(stationUnderTest);

	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 2592 : 			SetCurrentWeapon(stationUnderTest, hardPoint[stationUnderTest]->weaponPointer.get());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	push	eax
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2593 : 			break;

	jmp	$LN9@GetNextWea

; 2594 : 		}
; 2595 : 		// ASSOCIATOR 03/12/03: Added this check so that we can now properly cycle AG guns without relying on the 
; 2596 : 		// buggy g_bUseDefinedGunDomain that causes AI to crash
; 2597 : 		else if (hardPoint[stationUnderTest] && (hardPoint[stationUnderTest]->GetWeaponData()->domain | wdBoth) && 

	jmp	$LN3@GetNextWea
$LN8@GetNextWea:

; 2598 : 			(hardPoint[stationUnderTest]->weaponCount != 0 && hardPoint[stationUnderTest]->GetWeaponType() == wtGuns ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN3@GetNextWea
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 3
	je	SHORT $LN3@GetNextWea
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	je	SHORT $LN3@GetNextWea
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@GetNextWea

; 2599 : 		{
; 2600 : 			newType = hardPoint[stationUnderTest]->GetWeaponType();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	mov	DWORD PTR _newType$[ebp], eax

; 2601 : 			break;

	jmp	SHORT $LN9@GetNextWea
$LN3@GetNextWea:

; 2602 : 		}
; 2603 : 	}

	jmp	$LN10@GetNextWea
$LN9@GetNextWea:

; 2604 : 	
; 2605 :     SelectWeapon(newType, domainDesired);

	mov	ecx, DWORD PTR _domainDesired$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectWeapon@SMSClass@@QAEXW4WeaponType@@W4WeaponDomain@@@Z ; SMSClass::SelectWeapon

; 2606 : 	//MI
; 2607 : 	if(g_bRealisticAvionics && domainDesired == wdGround)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@GetNextWea
	cmp	DWORD PTR _domainDesired$[ebp], 2
	jne	SHORT $LN1@GetNextWea

; 2608 : 	{
; 2609 : 		RadarDopplerClass* pradar = (RadarDopplerClass*) FindSensor (ownship, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 2610 : 		if(pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN1@GetNextWea

; 2611 : 			pradar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pradar$1[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir
$LN1@GetNextWea:

; 2612 : 	}
; 2613 :     return (newType);

	mov	eax, DWORD PTR _newType$[ebp]
$LN13@GetNextWea:

; 2614 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNextWeapon@SMSClass@@QAE?AW4WeaponType@@W4WeaponDomain@@@Z ENDP ; SMSClass::GetNextWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv140 = -8						; size = 4
_this$ = -4						; size = 4
?ResetCurrentWeapon@SMSClass@@QAEXXZ PROC		; SMSClass::ResetCurrentWeapon
; _this$ = ecx

; 1864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1865 : 	curHardpoint = lastWpnStation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax+44], edx

; 1866 : 	curWpnNum    = lastWpnNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+136], edx

; 1867 : 	if (curHardpoint >= 0){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jl	$LN4@ResetCurre

; 1868 : 		curWeapon = hardPoint[curHardpoint]->weaponPointer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 1869 : 		// sfr: test
; 1870 : 		if (curWeapon && !curWeapon->IsMissile()){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ResetCurre
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@ResetCurre

; 1871 : 			printf("bug bug bug");

	push	OFFSET ??_C@_0M@GPPLIIOD@bug?5bug?5bug?$AA@
	call	_printf
	add	esp, 4
$LN3@ResetCurre:

; 1872 : 		}
; 1873 : 		curWeaponType  = hardPoint[curHardpoint]->GetWeaponType();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 1874 : 		curWeaponClass = hardPoint[curHardpoint]->GetWeaponClass();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], eax

; 1875 : 		curWeaponId    = hardPoint[curHardpoint]->weaponId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [eax+8]
	mov	WORD PTR [ecx+168], dx

; 1876 : 		curWeaponDomain= hardPoint[curHardpoint]->Domain();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+168]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], eax

; 1877 : 		if (curWeapon && curWeaponClass == wcHARMWpn){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ResetCurre
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 7
	jne	SHORT $LN2@ResetCurre

; 1878 : 			((MissileClass*)curWeapon.get())->display = FindSensor(ownship, SensorClass::HTS);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR [eax+712], esi
$LN2@ResetCurre:

; 1879 : 		}
; 1880 : 	}
; 1881 : 	else {

	jmp	SHORT $LN5@ResetCurre
$LN4@ResetCurre:

; 1882 : 		curWeapon.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 1883 : 		curWeaponType  = wtNone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 11			; 0000000bH

; 1884 : 		curWeaponClass = wcNoWpn;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 11			; 0000000bH

; 1885 : 		curWeaponId    = -1;

	or	edx, -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+168], dx

; 1886 : 		curWeaponDomain= wdNoDomain;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0
$LN5@ResetCurre:

; 1887 : 		// 2001-08-04 ADDED BY S.G. I THINK WE WANT TO SET curHardpoint TO -1 SINCE WE ARE CLEARING IT, RIGHT?
; 1888 : 		//	  curHardpoint = -1;
; 1889 : 		//	  lastWpnStation = -1;
; 1890 : 	}
; 1891 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetCurrentWeapon@SMSClass@@QAEXXZ ENDP		; SMSClass::ResetCurrentWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Incrementarmingdelay@SMSClass@@QAEXXZ PROC		; SMSClass::Incrementarmingdelay
; _this$ = ecx

; 3030 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3031 :    if (armingdelay >= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+172]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN1@Incrementa

; 3032 :    {
; 3033 :       if (armingdelay < 300)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR [ecx+172]
	jbe	SHORT $LN6@Incrementa

; 3034 :          armingdelay += 20;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+172]
	addss	xmm0, DWORD PTR __real@41a00000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+172], xmm0
	jmp	SHORT $LN1@Incrementa
$LN6@Incrementa:

; 3035 :       else if (armingdelay < 500)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43fa0000
	comiss	xmm0, DWORD PTR [ecx+172]
	jbe	SHORT $LN4@Incrementa

; 3036 :          armingdelay += 30;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+172]
	addss	xmm0, DWORD PTR __real@41f00000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+172], xmm0
	jmp	SHORT $LN1@Incrementa
$LN4@Incrementa:

; 3037 :       else if (armingdelay < 1000)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@447a0000
	comiss	xmm0, DWORD PTR [ecx+172]
	jbe	SHORT $LN2@Incrementa

; 3038 :          armingdelay += 40;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+172]
	addss	xmm0, DWORD PTR __real@42200000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+172], xmm0

; 3039 :       else

	jmp	SHORT $LN1@Incrementa
$LN2@Incrementa:

; 3040 :          armingdelay = 75;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42960000
	movss	DWORD PTR [ecx+172], xmm0
$LN1@Incrementa:

; 3041 :    }
; 3042 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Incrementarmingdelay@SMSClass@@QAEXXZ ENDP		; SMSClass::Incrementarmingdelay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecrementBurstHeight@SMSClass@@QAEXXZ PROC		; SMSClass::DecrementBurstHeight
; _this$ = ecx

; 3066 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3067 :    if (curHardpoint >= 0 && hardPoint[curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jl	$LN2@DecrementB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	je	$LN2@DecrementB

; 3068 :    {
; 3069 :       if (burstHeight > 1800)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+76]
	comiss	xmm0, DWORD PTR __real@44e10000
	jbe	SHORT $LN8@DecrementB

; 3070 :          burstHeight -= 400;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	subss	xmm0, DWORD PTR __real@43c80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	jmp	SHORT $LN3@DecrementB
$LN8@DecrementB:

; 3071 :       else if (burstHeight > 900)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+76]
	comiss	xmm0, DWORD PTR __real@44610000
	jbe	SHORT $LN6@DecrementB

; 3072 :          burstHeight -= 300;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	subss	xmm0, DWORD PTR __real@43960000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	jmp	SHORT $LN3@DecrementB
$LN6@DecrementB:

; 3073 :       else if (burstHeight > 300)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+76]
	comiss	xmm0, DWORD PTR __real@43960000
	jbe	SHORT $LN4@DecrementB

; 3074 :          burstHeight -= 200;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	subss	xmm0, DWORD PTR __real@43480000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0

; 3075 :       else

	jmp	SHORT $LN3@DecrementB
$LN4@DecrementB:

; 3076 :          burstHeight = 3000;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@453b8000
	movss	DWORD PTR [edx+76], xmm0
$LN3@DecrementB:

; 3077 : 			// Cobra - limit min BH
; 3078 : 			if (burstHeight < 0)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+76]
	jbe	SHORT $LN2@DecrementB

; 3079 : 				burstHeight = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+76], xmm0
$LN2@DecrementB:

; 3080 :    }
; 3081 :    if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN1@DecrementB

; 3082 :    {
; 3083 : 	   SetAGBBurstAlt((int)burstHeight);

	mov	eax, DWORD PTR _this$[ebp]
	cvttss2si ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBBurstAlt@SMSClass@@QAEXH@Z	; SMSClass::SetAGBBurstAlt
$LN1@DecrementB:

; 3084 :    }
; 3085 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementBurstHeight@SMSClass@@QAEXXZ ENDP		; SMSClass::DecrementBurstHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementBurstHeight@SMSClass@@QAEXXZ PROC		; SMSClass::IncrementBurstHeight
; _this$ = ecx

; 3044 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3045 :    if (curHardpoint >= 0 && hardPoint[curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jl	$LN2@IncrementB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	je	$LN2@IncrementB

; 3046 :    {
; 3047 :       if (burstHeight < 900)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44610000
	comiss	xmm0, DWORD PTR [edx+76]
	jbe	SHORT $LN8@IncrementB

; 3048 :          burstHeight += 200;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	addss	xmm0, DWORD PTR __real@43480000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	jmp	SHORT $LN3@IncrementB
$LN8@IncrementB:

; 3049 :       else if (burstHeight < 1800)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44e10000
	comiss	xmm0, DWORD PTR [edx+76]
	jbe	SHORT $LN6@IncrementB

; 3050 :          burstHeight += 300;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	addss	xmm0, DWORD PTR __real@43960000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	jmp	SHORT $LN3@IncrementB
$LN6@IncrementB:

; 3051 :       else if (burstHeight < 3000)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@453b8000
	comiss	xmm0, DWORD PTR [edx+76]
	jbe	SHORT $LN4@IncrementB

; 3052 :          burstHeight += 400;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	addss	xmm0, DWORD PTR __real@43c80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0

; 3053 :       else

	jmp	SHORT $LN3@IncrementB
$LN4@IncrementB:

; 3054 :          burstHeight = 300;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [edx+76], xmm0
$LN3@IncrementB:

; 3055 : 			// Cobra - limit max BH
; 3056 : 			if (burstHeight > 6000)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	comiss	xmm0, DWORD PTR __real@45bb8000
	jbe	SHORT $LN2@IncrementB

; 3057 : 				burstHeight = 6000;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45bb8000
	movss	DWORD PTR [ecx+76], xmm0
$LN2@IncrementB:

; 3058 :    }
; 3059 :    if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN1@IncrementB

; 3060 :    {
; 3061 : 	   SetAGBBurstAlt((int)burstHeight);

	mov	eax, DWORD PTR _this$[ebp]
	cvttss2si ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBBurstAlt@SMSClass@@QAEXH@Z	; SMSClass::SetAGBBurstAlt
$LN1@IncrementB:

; 3062 :    }
; 3063 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementBurstHeight@SMSClass@@QAEXXZ ENDP		; SMSClass::IncrementBurstHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecrementRippleInterval@SMSClass@@QAEXXZ PROC		; SMSClass::DecrementRippleInterval
; _this$ = ecx

; 2968 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2969 :    if (curWeaponClass == wcBombWpn || (g_bRealisticAvionics && curWeaponClass == wcGbuWpn))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 2
	je	SHORT $LN1@DecrementR
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@DecrementR
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN3@DecrementR
$LN1@DecrementR:

; 2970 :    {
; 2971 :       SetAGBRippleInterval( (GetAGBRippleInterval() - 50) % 200);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleInterval@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleInterval
	sub	eax, 50					; 00000032H
	cdq
	mov	ecx, 200				; 000000c8H
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleInterval@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleInterval
$LN3@DecrementR:

; 2972 :    }
; 2973 : #if 0
; 2974 :    if (curWeaponClass == wcBombWpn)
; 2975 :    {
; 2976 :       rippleInterval -= 50;
; 2977 :       if (rippleInterval < 0)
; 2978 :          rippleInterval = 175;
; 2979 :    }
; 2980 :    //MI
; 2981 :    if(g_bRealisticAvionics)
; 2982 :    {
; 2983 : 	   if(curWeaponClass == wcGbuWpn)
; 2984 : 	   {
; 2985 : 		   rippleInterval -= 50;
; 2986 : 		   if (rippleInterval < 0)
; 2987 : 			   rippleInterval = 175;
; 2988 : 	   }
; 2989 : 
; 2990 :    	   SetAGBRippleInterval(rippleInterval); // MLR 4/3/2004 - 
; 2991 : 
; 2992 : 	   /*
; 2993 : 	   if(Prof1)
; 2994 : 		   Prof1RS = rippleInterval;
; 2995 : 	   else
; 2996 : 		   Prof2RS = rippleInterval;
; 2997 : 		*/
; 2998 :    }
; 2999 : #endif
; 3000 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementRippleInterval@SMSClass@@QAEXXZ ENDP		; SMSClass::DecrementRippleInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementRippleInterval@SMSClass@@QAEXXZ PROC		; SMSClass::IncrementRippleInterval
; _this$ = ecx

; 2934 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2935 :    if (curWeaponClass == wcBombWpn || (g_bRealisticAvionics && curWeaponClass == wcGbuWpn))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 2
	je	SHORT $LN1@IncrementR
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@IncrementR
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN3@IncrementR
$LN1@IncrementR:

; 2936 :    {
; 2937 :       SetAGBRippleInterval( (GetAGBRippleInterval() + 50) % 200);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleInterval@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleInterval
	add	eax, 50					; 00000032H
	cdq
	mov	ecx, 200				; 000000c8H
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleInterval@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleInterval
$LN3@IncrementR:

; 2938 :    }
; 2939 : 
; 2940 : #if 0
; 2941 :    if (curWeaponClass == wcBombWpn)
; 2942 :    {
; 2943 :       //rippleInterval = (rippleInterval + 50) % 200;
; 2944 :       SetAGBRippleInterval( (GetAGBRippleInterval() + 50) % 200);
; 2945 :    }
; 2946 :    //MI
; 2947 :    if(g_bRealisticAvionics)
; 2948 :    {
; 2949 : 	   if(curWeaponClass == wcGbuWpn)
; 2950 : 	   {
; 2951 : 		   //rippleInterval = (rippleInterval + 50) % 200;
; 2952 :            SetAGBRippleInterval( (GetAGBRippleInterval() + 50) % 200);
; 2953 : 
; 2954 : 	   }
; 2955 : 
; 2956 : 	   SetAGBRippleInterval(rippleInterval); // MLR 4/3/2004 - 
; 2957 : /*
; 2958 : 	   if(Prof1)
; 2959 : 		   Prof1RS = rippleInterval;
; 2960 : 	   else
; 2961 : 		   Prof2RS = rippleInterval;
; 2962 : 		   */
; 2963 :    }
; 2964 : #endif
; 2965 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementRippleInterval@SMSClass@@QAEXXZ ENDP		; SMSClass::IncrementRippleInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rippledistance$ = 8					; size = 4
?SetRippleInterval@SMSClass@@QAEXH@Z PROC		; SMSClass::SetRippleInterval
; _this$ = ecx

; 3003 : { // MLR 4/3/2004 - 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3004 :    if (curWeaponClass == wcBombWpn || (g_bRealisticAvionics && curWeaponClass == wcGbuWpn))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 2
	je	SHORT $LN3@SetRippleI
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@SetRippleI
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN5@SetRippleI
$LN3@SetRippleI:

; 3005 :    {
; 3006 : 	   if(rippledistance > 999)

	cmp	DWORD PTR _rippledistance$[ebp], 999	; 000003e7H
	jle	SHORT $LN2@SetRippleI

; 3007 : 		   rippledistance = 999;

	mov	DWORD PTR _rippledistance$[ebp], 999	; 000003e7H
$LN2@SetRippleI:

; 3008 : 	   if(rippledistance < 10)

	cmp	DWORD PTR _rippledistance$[ebp], 10	; 0000000aH
	jge	SHORT $LN1@SetRippleI

; 3009 : 		   rippledistance = 10;

	mov	DWORD PTR _rippledistance$[ebp], 10	; 0000000aH
$LN1@SetRippleI:

; 3010 :       SetAGBRippleInterval( rippledistance );

	mov	eax, DWORD PTR _rippledistance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleInterval@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleInterval
$LN5@SetRippleI:

; 3011 :    }
; 3012 : 
; 3013 : #if 0
; 3014 : 	if (curWeaponClass == wcBombWpn)
; 3015 : 	{
; 3016 : 		rippleInterval = rippledistance;
; 3017 : 	}
; 3018 : 	if (rippleInterval > 175)
; 3019 : 	{
; 3020 : 		rippleInterval = 175;
; 3021 : 	}
; 3022 : 	if (rippleInterval < 0)
; 3023 : 	{
; 3024 : 		rippleInterval = 0;
; 3025 : 	}
; 3026 : #endif
; 3027 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRippleInterval@SMSClass@@QAEXH@Z ENDP		; SMSClass::SetRippleInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecrementRippleCount@SMSClass@@QAEXXZ PROC		; SMSClass::DecrementRippleCount
; _this$ = ecx

; 2887 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2888 :    if (curWeaponClass == wcBombWpn || (g_bRealisticAvionics && curWeaponClass == wcGbuWpn))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 2
	je	SHORT $LN3@DecrementR
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@DecrementR
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN5@DecrementR
$LN3@DecrementR:

; 2889 :    {
; 2890 : 	   if (ownship->GetSType() == STYPE_AIR_BOMBER)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetSType@SimBaseClass@@QBEEXZ		; SimBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 4
	jne	SHORT $LN2@DecrementR

; 2891 : 			SetAGBRippleCount( (GetAGBRippleCount() - 1) % MAX_RIPPLE_COUNT_BOMBER );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	sub	eax, 1
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleCount@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleCount

; 2892 : 	   else

	jmp	SHORT $LN5@DecrementR
$LN2@DecrementR:

; 2893 : 			SetAGBRippleCount( (GetAGBRippleCount() - 1) % MAX_RIPPLE_COUNT_BOMBER );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	sub	eax, 1
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleCount@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleCount
$LN5@DecrementR:

; 2894 :    }
; 2895 : #if 0
; 2896 : 
; 2897 :    if (curWeaponClass == wcBombWpn)
; 2898 :    {
; 2899 :       rippleCount --;
; 2900 :       if (rippleCount < 0)
; 2901 : 		  // 2000-08-31 ADDED BY S.G. SO BOMBER HAVE A HIGHER RIPPLE COUNT AVAILABLE
; 2902 : 	   if (ownship->GetSType() == STYPE_AIR_BOMBER)
; 2903 :          rippleCount = MAX_RIPPLE_COUNT_BOMBER - 1;
; 2904 : 	   else
; 2905 : // END OF ADDED SECTION
; 2906 :          rippleCount = MAX_RIPPLE_COUNT - 1;
; 2907 :    }
; 2908 :    //MI
; 2909 :    if(g_bRealisticAvionics)
; 2910 :    {
; 2911 : 	   if(curWeaponClass == wcGbuWpn)
; 2912 : 	   {
; 2913 : 		   rippleCount --;
; 2914 : 		  if (rippleCount < 0)
; 2915 : 			  // 2000-08-31 ADDED BY S.G. SO BOMBER HAVE A HIGHER RIPPLE COUNT AVAILABLE
; 2916 : 		   if (ownship->GetSType() == STYPE_AIR_BOMBER)
; 2917 : 			 rippleCount = MAX_RIPPLE_COUNT_BOMBER - 1;
; 2918 : 		   else
; 2919 : 	// END OF ADDED SECTION
; 2920 : 			 rippleCount = MAX_RIPPLE_COUNT - 1;
; 2921 : 	   }
; 2922 :    	   SetAGBRippleCount(rippleCount); // MLR 4/3/2004 - 
; 2923 : 	   /*
; 2924 : 	   if(Prof1)
; 2925 : 		   Prof1RP = rippleCount;
; 2926 : 	   else
; 2927 : 		   Prof2RP = rippleCount;
; 2928 : 		   */
; 2929 :    }
; 2930 : #endif
; 2931 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementRippleCount@SMSClass@@QAEXXZ ENDP		; SMSClass::DecrementRippleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementRippleCount@SMSClass@@QAEXXZ PROC		; SMSClass::IncrementRippleCount
; _this$ = ecx

; 2840 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2841 :    if (curWeaponClass == wcBombWpn || (g_bRealisticAvionics && curWeaponClass == wcGbuWpn))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 2
	je	SHORT $LN3@IncrementR
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@IncrementR
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN5@IncrementR
$LN3@IncrementR:

; 2842 :    {
; 2843 : 	   if (ownship->GetSType() == STYPE_AIR_BOMBER)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetSType@SimBaseClass@@QBEEXZ		; SimBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 4
	jne	SHORT $LN2@IncrementR

; 2844 : 			SetAGBRippleCount( (GetAGBRippleCount() + 1) % MAX_RIPPLE_COUNT_BOMBER );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleCount@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleCount

; 2845 : 	   else

	jmp	SHORT $LN5@IncrementR
$LN2@IncrementR:

; 2846 : 			SetAGBRippleCount( (GetAGBRippleCount() + 1) % MAX_RIPPLE_COUNT_BOMBER );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAGBRippleCount@SMSClass@@QAEXH@Z	; SMSClass::SetAGBRippleCount
$LN5@IncrementR:

; 2847 :    }
; 2848 : 
; 2849 : 
; 2850 : #if 0
; 2851 : 	if (curWeaponClass == wcBombWpn)
; 2852 :    {
; 2853 : 	   // 2000-08-31 ADDED BY S.G. SO BOMBER HAVE A HIGHER RIPPLE COUNT AVAILABLE
; 2854 : 	   if (ownship->GetSType() == STYPE_AIR_BOMBER)
; 2855 : 			//rippleCount = (rippleCount + 1) % MAX_RIPPLE_COUNT_BOMBER; // MLR 4/3/2004 - 
; 2856 : 			SetAGBRippleCount( (GetAGBRippleCount() + 1) % MAX_RIPPLE_COUNT_BOMBER );
; 2857 : 	   else
; 2858 : // END OF ADDED SECTION
; 2859 : 			//rippleCount = (rippleCount + 1) % MAX_RIPPLE_COUNT; // MLR 4/3/2004 - 
; 2860 : 			SetAGBRippleCount( (GetAGBRippleCount() + 1) % MAX_RIPPLE_COUNT_BOMBER );
; 2861 :    }
; 2862 :    //MI
; 2863 :    if(g_bRealisticAvionics)
; 2864 :    {
; 2865 : 	   if(curWeaponClass == wcGbuWpn)
; 2866 : 	   {
; 2867 : 		   // 2000-08-31 ADDED BY S.G. SO BOMBER HAVE A HIGHER RIPPLE COUNT AVAILABLE
; 2868 : 		   if (ownship->GetSType() == STYPE_AIR_BOMBER)
; 2869 : 			   rippleCount = (rippleCount + 1) % MAX_RIPPLE_COUNT_BOMBER;
; 2870 : 		   else
; 2871 : 			   // END OF ADDED SECTION
; 2872 : 			   rippleCount = (rippleCount + 1) % MAX_RIPPLE_COUNT;
; 2873 : 	   }
; 2874 : 
; 2875 : 	   
; 2876 : 	   SetAGBRippleCount(rippleCount); // MLR 4/3/2004 - 
; 2877 : 	   /*if(Prof1)
; 2878 : 		   Prof1RP = rippleCount;
; 2879 : 	   else
; 2880 : 		   Prof2RP = rippleCount;
; 2881 : 		   */
; 2882 :    }
; 2883 : #endif
; 2884 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementRippleCount@SMSClass@@QAEXXZ ENDP		; SMSClass::IncrementRippleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv88 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
tv76 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flag$ = 8						; size = 4
?SetPlayerSMS@SMSClass@@QAEXH@Z PROC			; SMSClass::SetPlayerSMS
; _this$ = ecx

; 1634 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetPlayerSMS@SMSClass@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1635 :    if (flag && !drawable){

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN3@SetPlayerS
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+160], 0
	jne	SHORT $LN3@SetPlayerS

; 1636 :       drawable = new SmsDrawable (this);

	push	312					; 00000138H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@SetPlayerS
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0SmsDrawable@@QAE@PAVSMSClass@@@Z	; SmsDrawable::SmsDrawable
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN7@SetPlayerS
$LN6@SetPlayerS:
	mov	DWORD PTR tv76[ebp], 0
$LN7@SetPlayerS:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+160], ecx
	jmp	SHORT $LN4@SetPlayerS
$LN3@SetPlayerS:

; 1637 :    }
; 1638 : 
; 1639 :    else if (!flag){

	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $LN4@SetPlayerS

; 1640 :       delete drawable;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@SetPlayerS
	push	1
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN9@SetPlayerS
$LN8@SetPlayerS:
	mov	DWORD PTR tv88[ebp], 0
$LN9@SetPlayerS:

; 1641 :       drawable = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0
$LN4@SetPlayerS:

; 1642 :    }
; 1643 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetPlayerSMS@SMSClass@@QAEXH@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetPlayerSMS@SMSClass@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetPlayerSMS@SMSClass@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetPlayerSMS@SMSClass@@QAEXH@Z ENDP			; SMSClass::SetPlayerSMS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv602 = -60						; size = 4
tv594 = -56						; size = 4
tv562 = -52						; size = 4
tv684 = -48						; size = 4
tv688 = -44						; size = 4
tv557 = -40						; size = 4
tv690 = -36						; size = 4
tv552 = -32						; size = 4
tv547 = -28						; size = 4
tv686 = -24						; size = 4
tv542 = -20						; size = 4
_gun$ = -16						; size = 4
tv80 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?Exec@SMSClass@@QAEXXZ PROC				; SMSClass::Exec
; _this$ = ecx

; 1478 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : int i;
; 1480 : GunClass* gun;
; 1481 : 
; 1482 : 	RunRockets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunRockets@SMSClass@@IAEXXZ		; SMSClass::RunRockets

; 1483 : 
; 1484 :    // 2002-01-27 ADDED BY S.G. Reset curRippleCount if the current weapon is NOT a bomb...
; 1485 :    if (curRippleCount && curWeapon && !curWeapon->IsBomb()) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN38@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN38@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv80[ebp], eax
	mov	edx, DWORD PTR tv80[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv80[ebp]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	test	eax, eax
	jne	SHORT $LN38@Exec

; 1486 : 	   curRippleCount =0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 1487 : 	   nextDrop = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 0
$LN38@Exec:

; 1488 :    }
; 1489 :    // END OF ADDED SECTION
; 1490 : 
; 1491 :    // Do ripple stuff here
; 1492 :    if (curRippleCount && SimLibElapsedTime > nextDrop)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	$LN33@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	ecx, DWORD PTR [eax+80]
	jbe	$LN33@Exec

; 1493 :    {
; 1494 : 		 if (GetAGBPair() && numCurrentWpn <= 1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN36@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 1
	jg	SHORT $LN36@Exec

; 1495 : 			curRippleCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 1

; 1496 : 		 else

	jmp	SHORT $LN35@Exec
$LN36@Exec:

; 1497 : 			DropBomb();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropBomb@SMSClass@@QAEHH@Z		; SMSClass::DropBomb
$LN35@Exec:

; 1498 : 
; 1499 :       curRippleCount--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 1500 : 
; 1501 :       if (curRippleCount)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	$LN34@Exec

; 1502 : // 2001-04-27 MODIFIED BY S.G. SO THE RIPPLE DISTANCE IS INCREASED WITH ALTITUDE (SINCE BOMBS SLOWS DOWN)
; 1503 : //         nextDrop = SimLibElapsedTime + FloatToInt32((rippleInterval)/(float)sqrt(ownship->XDelta()*ownship->XDelta() + ownship->YDelta()*ownship->YDelta()) * SEC_TO_MSEC + (float)sqrt(ownship->ZPos() * -4.0f));
; 1504 : // JB 011017 Use old nextDrop ripple code instead of altitude dependant code.  I don't see why bombs slowing down would have an effect on ripple distance
; 1505 : // If anything is effected it would cause bombs to fall short which is not happening.  
; 1506 : // Besides this really screws up the code that decides when to start the ripple, and all the bombs don't fall off properly.
; 1507 :        //nextDrop = SimLibElapsedTime + FloatToInt32((rippleInterval)/
; 1508 :        nextDrop = SimLibElapsedTime + FloatToInt32((GetAGBRippleInterval())/
; 1509 : 				(float)sqrt(ownship->XDelta()*ownship->XDelta() + ownship->YDelta()*ownship->YDelta()) * SEC_TO_MSEC);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAGBRippleInterval@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleInterval
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv684[ebp], xmm0
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv542[ebp]
	movss	xmm0, DWORD PTR tv542[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv686[ebp], xmm0
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv547[ebp]
	movss	xmm0, DWORD PTR tv686[ebp]
	mulss	xmm0, DWORD PTR tv547[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv688[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv552[ebp]
	movss	xmm0, DWORD PTR tv552[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv690[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv557[ebp]
	movss	xmm0, DWORD PTR tv690[ebp]
	mulss	xmm0, DWORD PTR tv557[ebp]
	movss	xmm1, DWORD PTR tv688[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv562[ebp]
	movss	xmm0, DWORD PTR tv684[ebp]
	divss	xmm0, DWORD PTR tv562[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 1510 :       else

	jmp	SHORT $LN33@Exec
$LN34@Exec:

; 1511 :       {
; 1512 :          nextDrop = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 1513 : 
; 1514 :          // Make sure we can fire in the future
; 1515 :          ClearFlag (Firing);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@SMSBaseClass@@QAEXH@Z	; SMSBaseClass::ClearFlag
$LN33@Exec:

; 1516 :       }
; 1517 : 
; 1518 :    }
; 1519 :    //MI Mav cooling
; 1520 :    if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN29@Exec

; 1521 :    {
; 1522 : 		if(Powered && MavCoolTimer >= -1.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	je	SHORT $LN31@Exec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	comiss	xmm0, DWORD PTR __real@bf800000
	jb	SHORT $LN31@Exec

; 1523 : 			MavCoolTimer -= SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+20], xmm0
	jmp	SHORT $LN29@Exec
$LN31@Exec:

; 1524 : 		else if(!Powered && MavCoolTimer <= 5.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	jne	SHORT $LN29@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR [edx+20]
	jb	SHORT $LN29@Exec

; 1525 : 			MavCoolTimer += SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	addss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+20], xmm0
$LN29@Exec:

; 1526 :    }
; 1527 : 
; 1528 :    if (g_bRealisticAvionics)//Cobra for the JDAM

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN25@Exec

; 1529 :    {
; 1530 :        if (JDAMPowered && JDAMInitTimer >= -1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN27@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	comiss	xmm0, DWORD PTR __real@bf800000
	jb	SHORT $LN27@Exec

; 1531 : 	   JDAMInitTimer -= SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
	jmp	SHORT $LN25@Exec
$LN27@Exec:

; 1532 : 	   else if (!JDAMPowered && JDAMInitTimer < 10.0f)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+28]
	test	eax, eax
	jne	SHORT $LN25@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR [ecx+32]
	jbe	SHORT $LN25@Exec

; 1533 : 	   JDAMInitTimer = 10.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [edx+32], xmm0
$LN25@Exec:

; 1534 :    }
; 1535 : 
; 1536 :    // RV - I-Hawk - For HARM initial power-up
; 1537 :    if ( g_bRealisticAvionics )

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN21@Exec

; 1538 :    {
; 1539 :        if ( GetHARMPowerState() && GetHARMInitTimer() >= -1.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ; SMSBaseClass::GetHARMPowerState
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHARMInitTimer@SMSBaseClass@@QAEMXZ	; SMSBaseClass::GetHARMInitTimer
	fstp	DWORD PTR tv594[ebp]
	movss	xmm0, DWORD PTR tv594[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jb	SHORT $LN23@Exec

; 1540 : 	   {
; 1541 :            HARMInitTimer -= SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+64], xmm0
	jmp	SHORT $LN21@Exec
$LN23@Exec:

; 1542 : 	   }
; 1543 : 	   else if ( !GetHARMPowerState() && GetHARMInitTimer() < 5.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ; SMSBaseClass::GetHARMPowerState
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHARMInitTimer@SMSBaseClass@@QAEMXZ	; SMSBaseClass::GetHARMInitTimer
	fstp	DWORD PTR tv602[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR tv602[ebp]
	jbe	SHORT $LN21@Exec

; 1544 : 	   {
; 1545 :            HARMInitTimer = 2.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [edx+64], xmm0
$LN21@Exec:

; 1546 : 	   }
; 1547 :    }
; 1548 : 
; 1549 :    // Marco Edit - Check overall cooling amount left
; 1550 : 	if(GetCoolState() == COOLING)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	cmp	eax, 1
	jne	SHORT $LN19@Exec

; 1551 : 	{ // JPO aim9 is cooling down
; 1552 : 		aim9cooltime -= SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+184]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+184], xmm0

; 1553 :        if(aim9cooltime <= 0.0F) 

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+184]
	jb	SHORT $LN19@Exec

; 1554 : 	   {
; 1555 : 		   SetCoolState(COOL);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState

; 1556 : 		   aim9cooltime = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+184], xmm0
$LN19@Exec:

; 1557 :        }
; 1558 :    }
; 1559 :    if(GetCoolState() == COOL || GetCoolState() == COOLING)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	cmp	eax, 2
	je	SHORT $LN17@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	cmp	eax, 1
	jne	SHORT $LN16@Exec
$LN17@Exec:

; 1560 :    {
; 1561 : 	   aim9coolingtimeleft -= SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+188], xmm0

; 1562 : 	   aim9warmtime -= SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+192]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+192], xmm0

; 1563 : 	   if(aim9warmtime <= 0.0F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+192]
	jb	SHORT $LN16@Exec

; 1564 : 		   aim9warmtime = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+192], xmm0
$LN16@Exec:

; 1565 :    }
; 1566 : 
; 1567 :    // Marco Edit - Warming up back to normal
; 1568 :    if(GetCoolState() == WARMING)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	cmp	eax, 3
	jne	$LN13@Exec

; 1569 :    {
; 1570 : 	   aim9warmtime += SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+192]
	addss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+192], xmm0

; 1571 : 	   aim9cooltime += SimLibMajorFrameTime;	//reset our cooling timer.

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+184]
	addss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+184], xmm0

; 1572 : 
; 1573 : 	   if(aim9cooltime > 3.0F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+184]
	comiss	xmm0, DWORD PTR __real@40400000
	jbe	SHORT $LN14@Exec

; 1574 : 		   aim9cooltime = 3.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [eax+184], xmm0
$LN14@Exec:

; 1575 : 
; 1576 : 	   if(aim9warmtime >= 60.0F) 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+192]
	comiss	xmm0, DWORD PTR __real@42700000
	jb	SHORT $LN13@Exec

; 1577 : 	   {
; 1578 : 		   SetCoolState(WARM);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState

; 1579 : 		   aim9cooltime = 3.0F;	//reset our cooling timer.

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [edx+184], xmm0
$LN13@Exec:

; 1580 : 	   }
; 1581 :    }
; 1582 : 
; 1583 :    	// We're out of coolant! We start to warm up....
; 1584 : 	if(aim9coolingtimeleft <= 0 && GetCoolState() != WARM)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+188]
	jb	SHORT $LN12@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	test	eax, eax
	je	SHORT $LN12@Exec

; 1585 : 		SetCoolState(WARMING);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState
$LN12@Exec:

; 1586 : 
; 1587 : 	// Okay, we've warmed up enough....
; 1588 : 	// can you say dead weight???
; 1589 : 	/*else if(aim9coolingtimeleft == 0 && SimLibElapsedTime > aim9warmtime)
; 1590 : 	{
; 1591 : 		SetCoolState(WARM);
; 1592 : 		aim9warmtime = 0;
; 1593 : 		aim9cooltime = 0;
; 1594 : 	}*/
; 1595 : 
; 1596 :    if (drawable)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+160], 0
	je	SHORT $LN10@Exec

; 1597 :    {
; 1598 :       drawable->UpdateGroundSpot();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?UpdateGroundSpot@SmsDrawable@@QAEXXZ	; SmsDrawable::UpdateGroundSpot

; 1599 :       if (ownship && // JB 010710 CTD?
; 1600 : 				!ownship->OnGround())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN10@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN10@Exec

; 1601 :       {
; 1602 :          drawable->frameCount += FloatToInt32(SimLibMajorFrameTime * SEC_TO_MSEC * 0.1F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+160]
	movss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	mov	DWORD PTR [ecx+28], eax
$LN10@Exec:

; 1603 :       }
; 1604 :    }
; 1605 : 
; 1606 :    // Count how many of these we have
; 1607 :    if (curHardpoint >= 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jl	$LN9@Exec

; 1608 :    {
; 1609 :       numCurrentWpn = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 1610 :       if (curWeaponClass == wcGunWpn)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+156], 3
	jne	SHORT $LN8@Exec

; 1611 :       {
; 1612 :          gun = GetGun(curHardpoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ; SMSBaseClass::GetGun
	mov	DWORD PTR _gun$[ebp], eax

; 1613 :          if (gun)

	cmp	DWORD PTR _gun$[ebp], 0
	je	SHORT $LN7@Exec

; 1614 :             numCurrentWpn = gun->numRoundsRemaining / 10;

	mov	ecx, DWORD PTR _gun$[ebp]
	mov	eax, DWORD PTR [ecx+808]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax
$LN7@Exec:

; 1615 :       }
; 1616 :       else

	jmp	SHORT $LN3@Exec
$LN8@Exec:

; 1617 :       {
; 1618 :          for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@Exec
$LN4@Exec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@Exec:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN3@Exec

; 1619 :          {
; 1620 :             if (hardPoint[i] && hardPoint[i]->weaponId == curWeaponId)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN2@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+168]
	cmp	ecx, eax
	jne	SHORT $LN2@Exec

; 1621 :             {
; 1622 :                numCurrentWpn += hardPoint[i]->weaponCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], edx
$LN2@Exec:

; 1623 :             }
; 1624 :          }

	jmp	SHORT $LN4@Exec
$LN3@Exec:

; 1625 :       }
; 1626 :    }
; 1627 :    else

	jmp	SHORT $LN1@Exec
$LN9@Exec:

; 1628 :    {
; 1629 :       numCurrentWpn = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], -1
$LN1@Exec:

; 1630 :    }
; 1631 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Exec@SMSClass@@QAEXXZ ENDP				; SMSClass::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?FreeWeapons@SMSClass@@QAEXXZ PROC			; SMSClass::FreeWeapons
; _this$ = ecx

; 1646 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1647 : 	int i;
; 1648 : 
; 1649 : 	// KCK: The actual deletion of this stuff is done in the base class destructor
; 1650 : 	ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1651 : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FreeWeapon
$LN3@FreeWeapon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FreeWeapon:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN5@FreeWeapon

; 1652 : 		if (hardPoint[i])

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN1@FreeWeapon

; 1653 : 			hardPoint[i]->SetGun(NULL);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+180]
	call	edx
$LN1@FreeWeapon:

; 1654 : 	}

	jmp	SHORT $LN3@FreeWeapon
$LN5@FreeWeapon:
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeWeapons@SMSClass@@QAEXXZ ENDP			; SMSClass::FreeWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv146 = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_classDesired$ = 8					; size = 4
?HasWeaponClass@SMSClass@@QAEHW4WeaponClass@@@Z PROC	; SMSClass::HasWeaponClass
; _this$ = ecx

; 2326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2327 : int i;
; 2328 : 
; 2329 : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HasWeaponC
$LN3@HasWeaponC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HasWeaponC:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN2@HasWeaponC

; 2330 : 	{
; 2331 : 		if (hardPoint[i] && hardPoint[i]->GetWeaponClass() == classDesired && hardPoint[i]->weaponPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN1@HasWeaponC
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, DWORD PTR _classDesired$[ebp]
	jne	SHORT $LN1@HasWeaponC
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@HasWeaponC

; 2332 :       {
; 2333 : 			break;

	jmp	SHORT $LN2@HasWeaponC
$LN1@HasWeaponC:

; 2334 : 		}
; 2335 : 	}

	jmp	SHORT $LN3@HasWeaponC
$LN2@HasWeaponC:

; 2336 : 
; 2337 :    return (i<numHardpoints ? TRUE : FALSE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN7@HasWeaponC
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN8@HasWeaponC
$LN7@HasWeaponC:
	mov	DWORD PTR tv146[ebp], 0
$LN8@HasWeaponC:
	mov	eax, DWORD PTR tv146[ebp]

; 2338 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasWeaponClass@SMSClass@@QAEHW4WeaponClass@@@Z ENDP	; SMSClass::HasWeaponClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_retval$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?HasTrainable@SMSClass@@QAEHXZ PROC			; SMSClass::HasTrainable
; _this$ = ecx

; 2773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2774 : int i;
; 2775 : int retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0

; 2776 : 
; 2777 :    for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HasTrainab
$LN3@HasTrainab:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HasTrainab:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN2@HasTrainab

; 2778 :    {
; 2779 :       if (hardPoint[i] && hardPoint[i]->GetWeaponData()->flags & SMSClass::Trainable)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN1@HasTrainab
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	eax, DWORD PTR [eax]
	and	eax, 1024				; 00000400H
	je	SHORT $LN1@HasTrainab

; 2780 :       {
; 2781 :          retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 2782 :          break;

	jmp	SHORT $LN2@HasTrainab
$LN1@HasTrainab:

; 2783 :       }
; 2784 :    }

	jmp	SHORT $LN3@HasTrainab
$LN2@HasTrainab:

; 2785 : 
; 2786 :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 2787 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasTrainable@SMSClass@@QAEHXZ ENDP			; SMSClass::HasTrainable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetUnlimitedAmmo@SMSClass@@QAEXH@Z PROC		; SMSClass::SetUnlimitedAmmo
; _this$ = ecx

; 2803 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2804 :    if (newFlag)

	cmp	DWORD PTR _newFlag$[ebp], 0
	je	SHORT $LN2@SetUnlimit

; 2805 :       flags |= UnlimitedAmmoFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 2806 :    else

	jmp	SHORT $LN1@SetUnlimit
$LN2@SetUnlimit:

; 2807 :       flags &= ~UnlimitedAmmoFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN1@SetUnlimit:

; 2808 :    SetUnlimitedGuns (newFlag);

	mov	eax, DWORD PTR _newFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnlimitedGuns@SMSClass@@QAEXH@Z	; SMSClass::SetUnlimitedGuns

; 2809 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnlimitedAmmo@SMSClass@@QAEXH@Z ENDP		; SMSClass::SetUnlimitedAmmo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?UnlimitedAmmo@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnlimitedAmmo@SMSClass@@QAEHXZ PROC			; SMSClass::UnlimitedAmmo, COMDAT
; _this$ = ecx

; 233  : 	int UnlimitedAmmo (void) {return flags & UnlimitedAmmoFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	and	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlimitedAmmo@SMSClass@@QAEHXZ ENDP			; SMSClass::UnlimitedAmmo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetUnlimitedGuns@SMSClass@@QAEXH@Z PROC		; SMSClass::SetUnlimitedGuns
; _this$ = ecx

; 2790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2791 : int i;
; 2792 : 
; 2793 :    for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SetUnlimit
$LN3@SetUnlimit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SetUnlimit:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN5@SetUnlimit

; 2794 :    {
; 2795 :       if (hardPoint[i] && hardPoint[i]->GetGun())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN1@SetUnlimit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+176]
	call	edx
	test	eax, eax
	je	SHORT $LN1@SetUnlimit

; 2796 :       {
; 2797 :          hardPoint[i]->GetGun()->unlimitedAmmo = flag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+176]
	call	edx
	mov	ecx, DWORD PTR _flag$[ebp]
	mov	DWORD PTR [eax+820], ecx
$LN1@SetUnlimit:

; 2798 :       }
; 2799 :    }

	jmp	SHORT $LN3@SetUnlimit
$LN5@SetUnlimit:

; 2800 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnlimitedGuns@SMSClass@@QAEXH@Z ENDP		; SMSClass::SetUnlimitedGuns
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_newHp$ = -12						; size = 4
_weap$1 = -8						; size = 4
_this$ = -4						; size = 4
_weaponDesired$ = 8					; size = 4
?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z PROC	; SMSClass::FindWeaponType
; _this$ = ecx

; 2417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2418 : 	int newHp = 0;

	mov	DWORD PTR _newHp$[ebp], 0

; 2419 : 
; 2420 : 	if(!hardPoint)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN7@FindWeapon

; 2421 : 		return 0;

	xor	eax, eax
	jmp	$LN9@FindWeapon
$LN7@FindWeapon:

; 2422 : 
; 2423 : 	do
; 2424 : 	{
; 2425 : 		if (hardPoint[newHp]->GetWeaponType() == weaponDesired)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _newHp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _newHp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, DWORD PTR _weaponDesired$[ebp]
	jne	SHORT $LN4@FindWeapon

; 2426 : 		{
; 2427 : 			SimWeaponClass *weap;
; 2428 : 			weap = hardPoint[newHp]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _newHp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weap$1[ebp], eax
$LN3@FindWeapon:

; 2429 : 
; 2430 : 			// find a useable weapon
; 2431 : 			while(weap && !weap->IsUseable()) 

	cmp	DWORD PTR _weap$1[ebp], 0
	je	SHORT $LN2@FindWeapon
	mov	ecx, DWORD PTR _weap$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weap$1[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@FindWeapon

; 2432 : 			{
; 2433 : 				weap = weap->GetNextOnRail();

	mov	ecx, DWORD PTR _weap$1[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weap$1[ebp], eax

; 2434 : 			}

	jmp	SHORT $LN3@FindWeapon
$LN2@FindWeapon:

; 2435 : 			
; 2436 : 			if(weap)

	cmp	DWORD PTR _weap$1[ebp], 0
	je	SHORT $LN4@FindWeapon

; 2437 : 			{
; 2438 : 				ReleaseCurWeapon (curHardpoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 2439 : 				SetCurrentWeapon(newHp, weap);

	mov	eax, DWORD PTR _weap$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _newHp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2440 : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN9@FindWeapon
$LN4@FindWeapon:

; 2441 : 			}
; 2442 : 		}
; 2443 : 		newHp = NextACHp(newHp, this->numHardpoints);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _newHp$[ebp]
	push	ecx
	call	?NextACHp@@YAHHH@Z			; NextACHp
	add	esp, 8
	mov	DWORD PTR _newHp$[ebp], eax

; 2444 : 	} while(newHp != 0);

	cmp	DWORD PTR _newHp$[ebp], 0
	jne	$LN7@FindWeapon

; 2445 : 
; 2446 : 	ReleaseCurWeapon (curHardpoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 2447 : 
; 2448 : 	return 0;

	xor	eax, eax
$LN9@FindWeapon:

; 2449 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ENDP	; SMSClass::FindWeaponType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_retval$ = -32						; size = 4
_foundStation$ = -28					; size = 4
_notNeedStation$ = -24					; size = 4
_i$ = -20						; size = 4
_found$ = -16						; size = 4
_stationUnderTest$ = -12				; size = 4
_weapPtr$ = -8						; size = 4
_this$ = -4						; size = 4
_weaponDesired$ = 8					; size = 4
_needWeapon$ = 12					; size = 4
?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z PROC	; SMSClass::FindWeaponClass
; _this$ = ecx

; 2344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2345 : 	int i, retval;
; 2346 : 	int stationUnderTest;
; 2347 : 	SimWeaponClass *weapPtr,*found=NULL;

	mov	DWORD PTR _found$[ebp], 0

; 2348 : 	int notNeedStation = -1;

	mov	DWORD PTR _notNeedStation$[ebp], -1

; 2349 : 	int foundStation = -1;

	mov	DWORD PTR _foundStation$[ebp], -1

; 2350 : 	
; 2351 : 	// Release the current weapon;
; 2352 : 	if (curHardpoint >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jl	SHORT $LN16@FindWeapon

; 2353 : 	{
; 2354 : 		ReleaseCurWeapon (curHardpoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 2355 : 		
; 2356 : 		// Do we have the right thing on the current station?
; 2357 : 		weapPtr = hardPoint[curHardpoint]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapPtr$[ebp], eax

; 2358 : 		if (hardPoint[curHardpoint]->GetWeaponClass() == weaponDesired && weapPtr && weapPtr->IsUseable())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, DWORD PTR _weaponDesired$[ebp]
	jne	SHORT $LN16@FindWeapon
	cmp	DWORD PTR _weapPtr$[ebp], 0
	je	SHORT $LN16@FindWeapon
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	je	SHORT $LN16@FindWeapon

; 2359 : 		{
; 2360 : 			foundStation = curHardpoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _foundStation$[ebp], edx

; 2361 : 			found = weapPtr;

	mov	eax, DWORD PTR _weapPtr$[ebp]
	mov	DWORD PTR _found$[ebp], eax
$LN16@FindWeapon:

; 2362 : 		}
; 2363 : 	}
; 2364 : 	
; 2365 : 	// Try and get the first weapon on any other hardpoint
; 2366 : 	if (!found)

	cmp	DWORD PTR _found$[ebp], 0
	jne	$LN14@FindWeapon

; 2367 : 	{
; 2368 : 		for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@FindWeapon
$LN12@FindWeapon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@FindWeapon:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN14@FindWeapon

; 2369 : 		{
; 2370 : 			stationUnderTest = (i + 1 + curHardpoint) % numHardpoints;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+40]
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2371 : 			if (hardPoint[stationUnderTest] && hardPoint[stationUnderTest]->GetWeaponClass() == weaponDesired)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN10@FindWeapon
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, DWORD PTR _weaponDesired$[ebp]
	jne	SHORT $LN10@FindWeapon

; 2372 : 			{
; 2373 : 				if (!found)

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN9@FindWeapon

; 2374 : 				{
; 2375 : 					weapPtr = hardPoint[stationUnderTest]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapPtr$[ebp], eax
$LN8@FindWeapon:

; 2376 : 					while(weapPtr && !weapPtr->IsUseable()) // skip unusable stores

	cmp	DWORD PTR _weapPtr$[ebp], 0
	je	SHORT $LN7@FindWeapon
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	jne	SHORT $LN7@FindWeapon

; 2377 : 					{
; 2378 : 						weapPtr = weapPtr->GetNextOnRail();

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapPtr$[ebp], eax

; 2379 : 					}

	jmp	SHORT $LN8@FindWeapon
$LN7@FindWeapon:

; 2380 : 
; 2381 : 					found		 = weapPtr;

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	DWORD PTR _found$[ebp], ecx

; 2382 : 					foundStation = stationUnderTest;

	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	DWORD PTR _foundStation$[ebp], edx
	jmp	SHORT $LN10@FindWeapon
$LN9@FindWeapon:

; 2383 : 				}
; 2384 : 				else if (notNeedStation < 0)

	cmp	DWORD PTR _notNeedStation$[ebp], 0
	jge	SHORT $LN10@FindWeapon

; 2385 : 				{
; 2386 : 					notNeedStation = stationUnderTest;

	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	DWORD PTR _notNeedStation$[ebp], eax
$LN10@FindWeapon:

; 2387 : 				}
; 2388 : 			}
; 2389 : 		}

	jmp	$LN12@FindWeapon
$LN14@FindWeapon:

; 2390 : 	}
; 2391 : 	
; 2392 : 	// Report status
; 2393 : 	if (found)

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN4@FindWeapon

; 2394 : 	{
; 2395 : 		// Found one
; 2396 : 		SetCurrentWeapon(foundStation, found);

	mov	ecx, DWORD PTR _found$[ebp]
	push	ecx
	mov	edx, DWORD PTR _foundStation$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2397 : 		retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
	jmp	SHORT $LN3@FindWeapon
$LN4@FindWeapon:

; 2398 : 	}
; 2399 : 	else if (!needWeapon && notNeedStation != -1)

	cmp	DWORD PTR _needWeapon$[ebp], 0
	jne	SHORT $LN2@FindWeapon
	cmp	DWORD PTR _notNeedStation$[ebp], -1
	je	SHORT $LN2@FindWeapon

; 2400 : 	{
; 2401 : 		// Found where one was, and thats good enough
; 2402 : 		SetCurrentWeapon(notNeedStation, NULL);

	push	0
	mov	eax, DWORD PTR _notNeedStation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2403 : 		retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 2404 : 	}
; 2405 : 	else

	jmp	SHORT $LN3@FindWeapon
$LN2@FindWeapon:

; 2406 : 	{
; 2407 : 		// Never had one.
; 2408 : 		SetCurrentWeapon(-1, NULL);

	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2409 : 		retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
$LN3@FindWeapon:

; 2410 : 	}
; 2411 : 	
; 2412 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 2413 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ENDP	; SMSClass::FindWeaponClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv245 = -24						; size = 4
_weapPtr$ = -20						; size = 4
_i$ = -16						; size = 4
_found$ = -12						; size = 4
_stationUnderTest$ = -8					; size = 4
_this$ = -4						; size = 4
_indexDesired$ = 8					; size = 4
?FindWeapon@SMSClass@@QAEHH@Z PROC			; SMSClass::FindWeapon
; _this$ = ecx

; 2279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2280 : 	int i=0;

	mov	DWORD PTR _i$[ebp], 0

; 2281 : 	int stationUnderTest=0;

	mov	DWORD PTR _stationUnderTest$[ebp], 0

; 2282 : 	SimWeaponClass *weapPtr=NULL,*found=NULL;

	mov	DWORD PTR _weapPtr$[ebp], 0
	mov	DWORD PTR _found$[ebp], 0

; 2283 : 
; 2284 : 	if (curHardpoint >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jl	$LN11@FindWeapon

; 2285 : 		{
; 2286 : 		ReleaseCurWeapon (curHardpoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 2287 : 		if (hardPoint[curHardpoint]->weaponPointer && hardPoint[curHardpoint]->weaponPointer->Type() == indexDesired)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@FindWeapon
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	cmp	eax, DWORD PTR _indexDesired$[ebp]
	jne	SHORT $LN11@FindWeapon

; 2288 : 			{
; 2289 : 			// Try and get the next weapon on current hardpoint
; 2290 : 			weapPtr = hardPoint[curHardpoint]->weaponPointer->GetNextOnRail();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapPtr$[ebp], eax

; 2291 : 			if (weapPtr)

	cmp	DWORD PTR _weapPtr$[ebp], 0
	je	SHORT $LN11@FindWeapon

; 2292 : 				{
; 2293 : 				stationUnderTest = curHardpoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _stationUnderTest$[ebp], eax

; 2294 : 				found = weapPtr;

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	DWORD PTR _found$[ebp], ecx
$LN11@FindWeapon:

; 2295 : 				}
; 2296 : 			}
; 2297 : 		}
; 2298 : 
; 2299 : 	// Try and get the first weapon on any other hardpoint
; 2300 : 	if (!found)

	cmp	DWORD PTR _found$[ebp], 0
	jne	$LN8@FindWeapon

; 2301 : 	{
; 2302 : 		for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@FindWeapon
$LN6@FindWeapon:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@FindWeapon:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN8@FindWeapon

; 2303 : 		{
; 2304 : 			stationUnderTest = (i + 1 + curHardpoint) % numHardpoints;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax+1]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+40]
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2305 : 			if (hardPoint[stationUnderTest] && hardPoint[stationUnderTest]->weaponPointer && 
; 2306 : 				hardPoint[stationUnderTest]->weaponPointer->Type() == indexDesired &&
; 2307 : 				hardPoint[stationUnderTest]->weaponPointer->IsUseable()) // MLR 3/6/2004 - IsUseable()

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN4@FindWeapon
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@FindWeapon
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	cmp	eax, DWORD PTR _indexDesired$[ebp]
	jne	SHORT $LN4@FindWeapon
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv245[ebp], eax
	mov	ecx, DWORD PTR tv245[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv245[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	je	SHORT $LN4@FindWeapon

; 2308 : 			{
; 2309 : 				found = hardPoint[stationUnderTest]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _found$[ebp], eax

; 2310 : 				break;

	jmp	SHORT $LN8@FindWeapon
$LN4@FindWeapon:

; 2311 : 			}
; 2312 : 		}

	jmp	$LN6@FindWeapon
$LN8@FindWeapon:

; 2313 : 	}
; 2314 : 
; 2315 : 	if (found)

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN3@FindWeapon

; 2316 : 		SetCurrentWeapon(stationUnderTest, found);

	mov	ecx, DWORD PTR _found$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2317 : 	else

	jmp	SHORT $LN2@FindWeapon
$LN3@FindWeapon:

; 2318 : 		SetCurrentWeapon(-1, NULL);

	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon
$LN2@FindWeapon:

; 2319 : 
; 2320 : 	if (found)

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN1@FindWeapon

; 2321 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN12@FindWeapon
$LN1@FindWeapon:

; 2322 : 	return 0;

	xor	eax, eax
$LN12@FindWeapon:

; 2323 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindWeapon@SMSClass@@QAEHH@Z ENDP			; SMSClass::FindWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_typeDesired$ = -64					; size = 4
tv670 = -60						; size = 4
tv646 = -56						; size = 4
tv544 = -52						; size = 4
tv480 = -48						; size = 4
tv405 = -44						; size = 4
_classDesired$ = -40					; size = 4
_idDesired$ = -36					; size = 4
_initialHp$1 = -32					; size = 4
_weapPtr$ = -28						; size = 4
_nextHp$2 = -24						; size = 4
_weap$3 = -20						; size = 4
_found$ = -16						; size = 4
_i$ = -12						; size = 4
_stationUnderTest$ = -8					; size = 4
_this$ = -4						; size = 4
_symFlag$ = 8						; size = 4
?WeaponStep@SMSClass@@QAEHH@Z PROC			; SMSClass::WeaponStep
; _this$ = ecx

; 1991 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1992 : 	int i, idDesired;
; 1993 : 	int stationUnderTest;
; 1994 : 	WeaponClass classDesired;
; 1995 : 	WeaponType typeDesired;
; 1996 : 	SimWeaponClass *weapPtr,*found=NULL;

	mov	DWORD PTR _found$[ebp], 0

; 1997 : 
; 1998 : 	if(ownship->IsAirplane()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN47@WeaponStep

; 1999 : 		if(curHardpoint>0){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jle	$LN46@WeaponStep

; 2000 : 			int initialHp = curHardpoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _initialHp$1[ebp], edx

; 2001 : 			int nextHp    = NextACHp( initialHp, numHardpoints );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _initialHp$1[ebp]
	push	edx
	call	?NextACHp@@YAHHH@Z			; NextACHp
	add	esp, 8
	mov	DWORD PTR _nextHp$2[ebp], eax
$LN45@WeaponStep:

; 2002 : 			while(1){

	mov	eax, 1
	test	eax, eax
	je	$LN46@WeaponStep

; 2003 : 				if(hardPoint[nextHp]->weaponId == hardPoint[initialHp]->weaponId){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _nextHp$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _initialHp$1[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [ecx+8]
	cmp	edx, eax
	jne	SHORT $LN43@WeaponStep

; 2004 : 					SimWeaponClass *weap = hardPoint[nextHp]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _nextHp$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weap$3[ebp], eax
$LN42@WeaponStep:

; 2005 : 					// skip unuseable weapons
; 2006 : 					while(weap && !weap->IsUseable()){

	cmp	DWORD PTR _weap$3[ebp], 0
	je	SHORT $LN41@WeaponStep
	mov	ecx, DWORD PTR _weap$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weap$3[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	jne	SHORT $LN41@WeaponStep

; 2007 : 						weap = weap->GetNextOnRail();

	mov	ecx, DWORD PTR _weap$3[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weap$3[ebp], eax

; 2008 : 					}

	jmp	SHORT $LN42@WeaponStep
$LN41@WeaponStep:

; 2009 : 					if(weap){

	cmp	DWORD PTR _weap$3[ebp], 0
	je	SHORT $LN43@WeaponStep

; 2010 : 						SetCurrentWeapon(nextHp, weap);

	mov	ecx, DWORD PTR _weap$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _nextHp$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2011 : 						return 1;

	mov	eax, 1
	jmp	$LN48@WeaponStep
$LN43@WeaponStep:

; 2012 : 					}
; 2013 : 				}
; 2014 : 				if(nextHp == initialHp){

	mov	eax, DWORD PTR _nextHp$2[ebp]
	cmp	eax, DWORD PTR _initialHp$1[ebp]
	jne	SHORT $LN39@WeaponStep

; 2015 : 					// we searched all Hps, and didn't find a match.
; 2016 : 					SetCurrentWeapon(nextHp);

	push	0
	mov	ecx, DWORD PTR _nextHp$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2017 : 					return 0;

	xor	eax, eax
	jmp	$LN48@WeaponStep
$LN39@WeaponStep:

; 2018 : 				}
; 2019 : 				nextHp = NextACHp( nextHp, numHardpoints );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _nextHp$2[ebp]
	push	ecx
	call	?NextACHp@@YAHHH@Z			; NextACHp
	add	esp, 8
	mov	DWORD PTR _nextHp$2[ebp], eax

; 2020 : 			}

	jmp	$LN45@WeaponStep
$LN46@WeaponStep:

; 2021 : 		}
; 2022 : 		return 0;

	xor	eax, eax
	jmp	$LN48@WeaponStep
$LN47@WeaponStep:

; 2023 : 	}
; 2024 : 
; 2025 : 	// old code follows
; 2026 : 	
; 2027 : 	if (curHardpoint < 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jge	SHORT $LN38@WeaponStep

; 2028 : 		// Do nothing if no station is currently selected
; 2029 : 		return 0;

	xor	eax, eax
	jmp	$LN48@WeaponStep
$LN38@WeaponStep:

; 2030 : 	}
; 2031 : 
; 2032 : 	// Symetric or same?
; 2033 : 	if (!symFlag){

	cmp	DWORD PTR _symFlag$[ebp], 0
	jne	SHORT $LN37@WeaponStep

; 2034 : 		stationUnderTest = curHardpoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _stationUnderTest$[ebp], ecx

; 2035 : 		i = curWpnNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR _i$[ebp], eax

; 2036 : 	}
; 2037 : 	else{

	jmp	SHORT $LN36@WeaponStep
$LN37@WeaponStep:

; 2038 :       stationUnderTest = numHardpoints - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2039 :       i = -1;

	mov	DWORD PTR _i$[ebp], -1
$LN36@WeaponStep:

; 2040 : 	}
; 2041 : 
; 2042 : 	// Otherwise, start with next weapon on this hardpoint
; 2043 : 	ReleaseCurWeapon (curHardpoint);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 2044 : 
; 2045 : 	// KCK: Why are we returning here? I guess we can't step to our next gun for
; 2046 : 	// multiple gun vehicles...
; 2047 : 	if (!hardPoint[curHardpoint] || hardPoint[curHardpoint]->GetWeaponClass() == wcGunWpn){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN34@WeaponStep
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 3
	jne	SHORT $LN35@WeaponStep
$LN34@WeaponStep:

; 2048 : 		return 0;

	xor	eax, eax
	jmp	$LN48@WeaponStep
$LN35@WeaponStep:

; 2049 : 	}
; 2050 : 
; 2051 : 	classDesired = hardPoint[curHardpoint]->GetWeaponClass();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	mov	DWORD PTR _classDesired$[ebp], eax

; 2052 : 	typeDesired = hardPoint[curHardpoint]->GetWeaponType();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	mov	DWORD PTR _typeDesired$[ebp], eax

; 2053 : 	idDesired = hardPoint[curHardpoint]->weaponId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	movsx	eax, WORD PTR [edx+8]
	mov	DWORD PTR _idDesired$[ebp], eax

; 2054 : 
; 2055 : 	// First try and find next weapon on the current hardpoint
; 2056 : 	if (i >= 0){

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN33@WeaponStep

; 2057 : 		weapPtr = hardPoint[curHardpoint]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapPtr$[ebp], eax
$LN32@WeaponStep:

; 2058 : 		while (weapPtr){

	cmp	DWORD PTR _weapPtr$[ebp], 0
	je	SHORT $LN33@WeaponStep

; 2059 : 			if (weapPtr->GetRackSlot() > i && weapPtr->IsUseable()){

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?GetRackSlot@SimWeaponClass@@QAEHXZ	; SimWeaponClass::GetRackSlot
	cmp	eax, DWORD PTR _i$[ebp]
	jle	SHORT $LN30@WeaponStep
	mov	edx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	test	eax, eax
	je	SHORT $LN30@WeaponStep

; 2060 : 				// MLR 3/6/2004 - added IsUseable (for rockets at this point)
; 2061 : 				found = weapPtr;

	mov	eax, DWORD PTR _weapPtr$[ebp]
	mov	DWORD PTR _found$[ebp], eax

; 2062 : 				break;

	jmp	SHORT $LN33@WeaponStep
$LN30@WeaponStep:

; 2063 : 			}
; 2064 : 			weapPtr = weapPtr->GetNextOnRail();

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapPtr$[ebp], eax

; 2065 : 		}

	jmp	SHORT $LN32@WeaponStep
$LN33@WeaponStep:

; 2066 : 	}
; 2067 : 
; 2068 : 	// Next look for anything w/ the same weapon Id
; 2069 : 	if (!found){

	cmp	DWORD PTR _found$[ebp], 0
	jne	$LN29@WeaponStep

; 2070 :       if (!symFlag){

	cmp	DWORD PTR _symFlag$[ebp], 0
	jne	$LN28@WeaponStep

; 2071 : 		   for (i=0; i<numHardpoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN27@WeaponStep
$LN26@WeaponStep:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN27@WeaponStep:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN25@WeaponStep

; 2072 : 			   stationUnderTest = (i + 1 + curHardpoint) % numHardpoints;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+40]
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2073 : 			   if (hardPoint[stationUnderTest] && hardPoint[stationUnderTest]->weaponId == idDesired){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN24@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	cmp	eax, DWORD PTR _idDesired$[ebp]
	jne	SHORT $LN24@WeaponStep

; 2074 : 				   if (hardPoint[stationUnderTest]->weaponPointer && hardPoint[stationUnderTest]->weaponPointer->IsUseable()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv405[ebp], eax
	mov	edx, DWORD PTR tv405[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv405[ebp]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	test	eax, eax
	je	SHORT $LN24@WeaponStep

; 2075 : 					   // MLR 3/6/2004 - added IsUseable (for rockets at this point)
; 2076 : 					   found = hardPoint[stationUnderTest]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _found$[ebp], eax

; 2077 : 					   break;

	jmp	SHORT $LN25@WeaponStep
$LN24@WeaponStep:

; 2078 : 				   }
; 2079 : 			   }
; 2080 : 		   }

	jmp	$LN26@WeaponStep
$LN25@WeaponStep:

; 2081 :       }
; 2082 :       else{

	jmp	$LN29@WeaponStep
$LN28@WeaponStep:

; 2083 :          if (curHardpoint > numHardpoints / 2){

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], eax
	jle	$LN21@WeaponStep

; 2084 : 		      for (i=0; i<numHardpoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@WeaponStep
$LN19@WeaponStep:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN20@WeaponStep:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN18@WeaponStep

; 2085 : 			      stationUnderTest = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2086 : 			      if (hardPoint[stationUnderTest] && hardPoint[stationUnderTest]->weaponId == idDesired){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN17@WeaponStep
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	cmp	ecx, DWORD PTR _idDesired$[ebp]
	jne	SHORT $LN17@WeaponStep

; 2087 : 				      if (hardPoint[stationUnderTest]->weaponPointer && hardPoint[stationUnderTest]->weaponPointer->IsUseable()){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@WeaponStep
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv480[ebp], eax
	mov	eax, DWORD PTR tv480[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv480[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	je	SHORT $LN17@WeaponStep

; 2088 : 						  // MLR 3/6/2004 - added IsUseable (for rockets at this point)
; 2089 : 						  found = hardPoint[stationUnderTest]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _found$[ebp], eax

; 2090 : 					      break;

	jmp	SHORT $LN18@WeaponStep
$LN17@WeaponStep:

; 2091 : 				      }
; 2092 : 			      }
; 2093 : 		      }

	jmp	$LN19@WeaponStep
$LN18@WeaponStep:

; 2094 :          }
; 2095 :          else {

	jmp	$LN29@WeaponStep
$LN21@WeaponStep:

; 2096 : 		      for (i=numHardpoints-1; i>=0; i--)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN14@WeaponStep
$LN13@WeaponStep:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@WeaponStep:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$LN29@WeaponStep

; 2097 : 		      {
; 2098 : 			      stationUnderTest = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _stationUnderTest$[ebp], ecx

; 2099 : 			      if (hardPoint[stationUnderTest] && hardPoint[stationUnderTest]->weaponId == idDesired)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN11@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	cmp	eax, DWORD PTR _idDesired$[ebp]
	jne	SHORT $LN11@WeaponStep

; 2100 : 			      {
; 2101 : 				      if (hardPoint[stationUnderTest]->weaponPointer && hardPoint[stationUnderTest]->weaponPointer->IsUseable())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv544[ebp], eax
	mov	edx, DWORD PTR tv544[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv544[ebp]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	test	eax, eax
	je	SHORT $LN11@WeaponStep

; 2102 : 				      {
; 2103 : 					      found = hardPoint[stationUnderTest]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _found$[ebp], eax

; 2104 : 					      break;

	jmp	SHORT $LN29@WeaponStep
$LN11@WeaponStep:

; 2105 : 				      }
; 2106 : 			      }
; 2107 : 		      }

	jmp	$LN13@WeaponStep
$LN29@WeaponStep:

; 2108 :          }
; 2109 :       }
; 2110 : 	}
; 2111 : 
; 2112 : 	// Next try and find first weapon of the same class on any other hardpoint
; 2113 : 	if (!found && classDesired != wcGbuWpn){

	cmp	DWORD PTR _found$[ebp], 0
	jne	$LN9@WeaponStep
	cmp	DWORD PTR _classDesired$[ebp], 9
	je	$LN9@WeaponStep

; 2114 : 		for (i=0; i<numHardpoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@WeaponStep
$LN7@WeaponStep:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@WeaponStep:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	$LN9@WeaponStep

; 2115 : 			stationUnderTest = (i + 1 + curHardpoint) % numHardpoints;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+40]
	mov	DWORD PTR _stationUnderTest$[ebp], edx

; 2116 : 			if (hardPoint[stationUnderTest] && hardPoint[stationUnderTest]->GetWeaponClass() == classDesired){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN5@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, DWORD PTR _classDesired$[ebp]
	jne	$LN5@WeaponStep

; 2117 : 				if (hardPoint[stationUnderTest]->GetWeaponType() == typeDesired && 
; 2118 : 					hardPoint[stationUnderTest]->weaponPointer &&
; 2119 : 					hardPoint[stationUnderTest]->weaponPointer->IsUseable())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, DWORD PTR _typeDesired$[ebp]
	jne	SHORT $LN5@WeaponStep
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv646[ebp], eax
	mov	edx, DWORD PTR tv646[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv646[ebp]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	test	eax, eax
	je	SHORT $LN5@WeaponStep

; 2120 : 				{
; 2121 : 					// MLR 3/6/2004 - added IsUseable (for rockets at this point)
; 2122 : 					found = hardPoint[stationUnderTest]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationUnderTest$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _found$[ebp], eax

; 2123 : 					break;

	jmp	SHORT $LN9@WeaponStep
$LN5@WeaponStep:

; 2124 : 				}
; 2125 : 			}
; 2126 : 		}

	jmp	$LN7@WeaponStep
$LN9@WeaponStep:

; 2127 : 	}
; 2128 : 
; 2129 : 	if (found || classDesired == wcHARMWpn){

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN2@WeaponStep
	cmp	DWORD PTR _classDesired$[ebp], 7
	jne	SHORT $LN3@WeaponStep
$LN2@WeaponStep:

; 2130 : 		// JB 010726 Stick with the HARM
; 2131 : 		SetCurrentWeapon(stationUnderTest, found);

	mov	eax, DWORD PTR _found$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stationUnderTest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon

; 2132 : 	}
; 2133 : 	else{

	jmp	SHORT $LN1@WeaponStep
$LN3@WeaponStep:

; 2134 : 		SetCurrentWeapon(-1, NULL);

	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSClass::SetCurrentWeapon
$LN1@WeaponStep:

; 2135 : 	}
; 2136 : 
; 2137 : 	return found ? 1 : 0;

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN50@WeaponStep
	mov	DWORD PTR tv670[ebp], 1
	jmp	SHORT $LN51@WeaponStep
$LN50@WeaponStep:
	mov	DWORD PTR tv670[ebp], 0
$LN51@WeaponStep:
	mov	eax, DWORD PTR tv670[ebp]
$LN48@WeaponStep:

; 2138 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?WeaponStep@SMSClass@@QAEHH@Z ENDP			; SMSClass::WeaponStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv195 = -16						; size = 4
_jettSuccess$ = -12					; size = 4
_curStation$ = -8					; size = 4
_this$ = -4						; size = 4
?TankJettison@SMSClass@@QAEXXZ PROC			; SMSClass::TankJettison
; _this$ = ecx

; 1843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1844 : 	int curStation;
; 1845 : 	int jettSuccess = 0;

	mov	DWORD PTR _jettSuccess$[ebp], 0

; 1846 : 
; 1847 : 	if (!(flags & TankJettisonFlag) && ownship->IsAirplane() && ((AircraftClass*)ownship)->af->ExternalFuel() < 0.1f) { // We're an airplane and our external fuel is almost zero (to trap floating point precision error), then jettison the tanks

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 2048				; 00000800H
	jne	$LN1@TankJettis
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN1@TankJettis
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?ExternalFuel@AirframeClass@@QAEMXZ	; AirframeClass::ExternalFuel
	fstp	DWORD PTR tv195[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR tv195[ebp]
	jbe	SHORT $LN1@TankJettis

; 1848 : 		for (curStation = numHardpoints-1; curStation>0; curStation--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	DWORD PTR _curStation$[ebp], ecx
	jmp	SHORT $LN5@TankJettis
$LN4@TankJettis:
	mov	edx, DWORD PTR _curStation$[ebp]
	sub	edx, 1
	mov	DWORD PTR _curStation$[ebp], edx
$LN5@TankJettis:
	cmp	DWORD PTR _curStation$[ebp], 0
	jle	SHORT $LN3@TankJettis

; 1849 : 		{
; 1850 : 			if(hardPoint[curStation] && hardPoint[curStation]->GetWeaponClass() == wcTank)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN2@TankJettis
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN2@TankJettis

; 1851 : 			{
; 1852 : //				MonoPrint ("Jettison station %d at %ld\n", curStation, SimLibElapsedTime);
; 1853 : 				jettSuccess = JettisonStation (curStation, SelectiveRack); // MLR 3/2/2004 - 

	push	12					; 0000000cH
	mov	eax, DWORD PTR _curStation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax
$LN2@TankJettis:

; 1854 : 			}
; 1855 : 		}

	jmp	SHORT $LN4@TankJettis
$LN3@TankJettis:

; 1856 : 
; 1857 : 		// Set a permanent flag indicating that we've done the deed
; 1858 : 		if (jettSuccess)

	cmp	DWORD PTR _jettSuccess$[ebp], 0
	je	SHORT $LN1@TankJettis

; 1859 : 			flags |= TankJettisonFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	or	edx, 2048				; 00000800H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], edx
$LN1@TankJettis:

; 1860 : 	}	
; 1861 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TankJettison@SMSClass@@QAEXXZ ENDP			; SMSClass::TankJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_jettSuccess$ = -12					; size = 4
_curStation$ = -8					; size = 4
_this$ = -4						; size = 4
?AGJettison@SMSClass@@QAEXXZ PROC			; SMSClass::AGJettison
; _this$ = ecx

; 1817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1818 : 	int curStation;
; 1819 : 	int jettSuccess = 0;

	mov	DWORD PTR _jettSuccess$[ebp], 0

; 1820 : 
; 1821 : 
; 1822 : 	for (curStation = numHardpoints-1; curStation>0; curStation--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	DWORD PTR _curStation$[ebp], ecx
	jmp	SHORT $LN6@AGJettison
$LN5@AGJettison:
	mov	edx, DWORD PTR _curStation$[ebp]
	sub	edx, 1
	mov	DWORD PTR _curStation$[ebp], edx
$LN6@AGJettison:
	cmp	DWORD PTR _curStation$[ebp], 0
	jle	$LN4@AGJettison

; 1823 : 	{
; 1824 : 		// FRB - SEAD a/c need to keep their Harms
; 1825 : 		if (hardPoint[curStation]->GetWeaponClass() == wcHARMWpn)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 7
	jne	SHORT $LN3@AGJettison

; 1826 : 			continue;

	jmp	SHORT $LN5@AGJettison
$LN3@AGJettison:

; 1827 : 		// MLR-NOTE GetRack??? should prevent A-10 from Jetting??? 
; 1828 : 		if(hardPoint[curStation] && hardPoint[curStation]->GetRack() && (hardPoint[curStation]->Domain() & wdGround))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN2@AGJettison
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	test	eax, eax
	je	SHORT $LN2@AGJettison
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+168]
	call	edx
	and	eax, 2
	je	SHORT $LN2@AGJettison

; 1829 : 		{
; 1830 : //			MonoPrint ("Jettison station %d at %ld\n", curStation, SimLibElapsedTime);
; 1831 : 			ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1832 : 			jettSuccess = JettisonStation (curStation, SelectiveRack); // MLR 3/2/2004 - 

	push	12					; 0000000cH
	mov	eax, DWORD PTR _curStation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax
$LN2@AGJettison:

; 1833 : 		}
; 1834 : 	}

	jmp	$LN5@AGJettison
$LN4@AGJettison:

; 1835 : 
; 1836 : 	// Set a permanent flag indicating that we've done the deed
; 1837 : 	if (jettSuccess)

	cmp	DWORD PTR _jettSuccess$[ebp], 0
	je	SHORT $LN7@AGJettison

; 1838 : 		flags |= EmergencyJettisonFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], edx
$LN7@AGJettison:

; 1839 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AGJettison@SMSClass@@QAEXXZ ENDP			; SMSClass::AGJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_b$2 = -48						; size = 4
$T3 = -44						; size = 4
tv234 = -40						; size = 4
tv65 = -36						; size = 4
tv182 = -32						; size = 4
_m$4 = -28						; size = 4
tv161 = -24						; size = 4
_this$ = -20						; size = 4
_weapPtr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hp$ = 8						; size = 4
?RemoveWeapon@SMSClass@@QAEXH@Z PROC			; SMSClass::RemoveWeapon
; _this$ = ecx

; 302  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveWeapon@SMSClass@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 303  : 	VuBin<SimWeaponClass> weapPtr;

	push	0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 304  : 
; 305  : 	if (
; 306  : 		(hardPoint) &&
; 307  : 		(hp > -1) &&
; 308  : 		(hardPoint[hp]->weaponPointer) &&
; 309  : 		(hardPoint[hp]->weaponCount > 0)
; 310  : 	){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN6@RemoveWeap
	cmp	DWORD PTR _hp$[ebp], -1
	jle	$LN6@RemoveWeap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@RemoveWeap
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	jle	$LN6@RemoveWeap

; 311  : 		weapPtr = hardPoint[hp]->DetachFirstWeapon(); // removes BSP too!

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+92]
	call	eax
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv234[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv234[ebp]
	push	edx
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>

; 312  : 		if ( !weapPtr ){ return; }

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator!
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@RemoveWeap
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	jmp	$LN7@RemoveWeap
$LN5@RemoveWeap:

; 313  : 
; 314  : 		if (weapPtr->IsMissile()){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv161[ebp], eax
	mov	ecx, DWORD PTR tv161[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv161[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	SHORT $LN4@RemoveWeap

; 315  : 			MissileClass *m = static_cast<MissileClass*>(weapPtr.get());

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _m$4[ebp], eax

; 316  : 			m->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _m$4[ebp]
	call	?SetTarget@MissileClass@@QAEXPAVSimObjectType@@@Z ; MissileClass::SetTarget

; 317  : 			m->ClearReferences();

	mov	ecx, DWORD PTR _m$4[ebp]
	call	?ClearReferences@MissileClass@@QAEXXZ	; MissileClass::ClearReferences
	jmp	SHORT $LN3@RemoveWeap
$LN4@RemoveWeap:

; 318  : 		}
; 319  : 		else if (weapPtr->IsBomb()){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv182[ebp], eax
	mov	ecx, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv182[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	je	SHORT $LN3@RemoveWeap

; 320  : 			BombClass *b = static_cast<BombClass*>(weapPtr.get());

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _b$2[ebp], eax

; 321  : 			b->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _b$2[ebp]
	call	?SetTarget@BombClass@@QAEXPAVSimObjectType@@@Z ; BombClass::SetTarget
$LN3@RemoveWeap:

; 322  : 		}
; 323  : 		RemoveStore(hp, hardPoint[hp]->weaponId);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 324  : 		if (weapPtr->drawPointer){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN6@RemoveWeap

; 325  : 			OTWDriver.RemoveObject(weapPtr->drawPointer, TRUE);

	push	1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 326  : 			weapPtr->drawPointer = NULL;

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR [eax+332], 0
$LN6@RemoveWeap:

; 327  : 		}
; 328  : 	}
; 329  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
$LN7@RemoveWeap:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RemoveWeapon@SMSClass@@QAEXH@Z$0:
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?RemoveWeapon@SMSClass@@QAEXH@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$?RemoveWeapon@SMSClass@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveWeapon@SMSClass@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveWeapon@SMSClass@@QAEXH@Z ENDP			; SMSClass::RemoveWeapon
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hp$ = 8						; size = 4
?JettisonWeapon@SMSClass@@QAEXH@Z PROC			; SMSClass::JettisonWeapon
; _this$ = ecx

; 1720 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1721 : 	ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1722 : 	JettisonStation (hp, SelectiveRack); // MLR 3/2/2004 - 

	push	12					; 0000000cH
	mov	eax, DWORD PTR _hp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation

; 1723 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?JettisonWeapon@SMSClass@@QAEXH@Z ENDP			; SMSClass::JettisonWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 8
$T3 = -52						; size = 8
$T4 = -44						; size = 4
tv521 = -40						; size = 4
$T5 = -36						; size = 4
tv504 = -32						; size = 4
_jettSuccess$ = -28					; size = 4
_trackMsg$6 = -24					; size = 4
_curStation$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?EmergencyJettison@SMSClass@@QAEXXZ PROC		; SMSClass::EmergencyJettison
; _this$ = ecx

; 1726 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EmergencyJettison@SMSClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1727 : 	int curStation;
; 1728 : 	int jettSuccess = 0;

	mov	DWORD PTR _jettSuccess$[ebp], 0

; 1729 : 	//me123 make sure we don't keep doing this...a mp messages is tranmitted every time.
; 1730 : 	if (flags & EmergencyJettisonFlag) return;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 16					; 00000010H
	je	SHORT $LN22@EmergencyJ
	jmp	$LN23@EmergencyJ
$LN22@EmergencyJ:

; 1731 : 	//MI
; 1732 : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN21@EmergencyJ

; 1733 : 	{
; 1734 : 		if (ownship->OnGround())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN20@EmergencyJ

; 1735 : 			return;

	jmp	$LN23@EmergencyJ
$LN20@EmergencyJ:

; 1736 : 	}
; 1737 : 	else

	jmp	SHORT $LN19@EmergencyJ
$LN21@EmergencyJ:

; 1738 : 	{
; 1739 : 		if(ownship->OnGround() && !GndJett)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN19@EmergencyJ
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	test	ecx, ecx
	jne	SHORT $LN19@EmergencyJ

; 1740 : 			return;

	jmp	$LN23@EmergencyJ
$LN19@EmergencyJ:

; 1741 : 	}
; 1742 : 
; 1743 : 	for (curStation = numHardpoints-1; curStation>0; curStation--)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	DWORD PTR _curStation$[ebp], eax
	jmp	SHORT $LN17@EmergencyJ
$LN16@EmergencyJ:
	mov	ecx, DWORD PTR _curStation$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _curStation$[ebp], ecx
$LN17@EmergencyJ:
	cmp	DWORD PTR _curStation$[ebp], 0
	jle	$LN15@EmergencyJ

; 1744 : 	{
; 1745 : // OW Jettison fix
; 1746 : /*
; 1747 : 		if( !(((AircraftClass *)ownship)->IsF16() &&
; 1748 :          (curStation == 1 || curStation == 9 || hardPoint[curStation]->GetWeaponClass() == wcECM)) &&
; 1749 :          hardPoint[curStation]->GetRack())
; 1750 : */
; 1751 : // 2002-04-21 MN this fixes release of AA weapons for F-16's, but other aircraft drop all the stuff -> crap
; 1752 : // new code by Pogo - just check not to drop station 1 and 9 and no AA and ECM for F-16's, no AA and ECM for all
; 1753 : 		
; 1754 : 		if (!g_bEmergencyJettisonFix)

	movzx	edx, BYTE PTR ?g_bEmergencyJettisonFix@@3_NA ; g_bEmergencyJettisonFix
	test	edx, edx
	jne	$LN14@EmergencyJ

; 1755 : 		{		if(hardPoint[curStation] && (!(((AircraftClass *)ownship)->IsF16() &&
; 1756 : 	         (curStation == 1 || curStation == 9 || hardPoint[curStation]->GetWeaponClass() == wcECM || hardPoint[curStation]->GetWeaponClass() == wcAimWpn || hardPoint[curStation]->GetWeaponClass() == wcHARMWpn)) &&
; 1757 : 		     (hardPoint[curStation]->GetRack() || curStation == 5 && hardPoint[curStation]->GetWeaponClass() == wcTank)))//me123 in the line above addet a check so we don't emergency jettison a-a missiles

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	$LN13@EmergencyJ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	$LN12@EmergencyJ
	cmp	DWORD PTR _curStation$[ebp], 1
	je	$LN13@EmergencyJ
	cmp	DWORD PTR _curStation$[ebp], 9
	je	$LN13@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 4
	je	$LN13@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	test	eax, eax
	je	$LN13@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 7
	je	$LN13@EmergencyJ
$LN12@EmergencyJ:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+116]
	call	eax
	test	eax, eax
	jne	SHORT $LN11@EmergencyJ
	cmp	DWORD PTR _curStation$[ebp], 5
	jne	SHORT $LN13@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN13@EmergencyJ
$LN11@EmergencyJ:

; 1758 : 
; 1759 : 			{
; 1760 : 				MonoPrint ("Jettison station %d at %ld\n", curStation, SimLibElapsedTime);

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	ecx
	mov	edx, DWORD PTR _curStation$[ebp]
	push	edx
	push	OFFSET ??_C@_0BM@CGGJMMAL@Jettison?5station?5?$CFd?5at?5?$CFld?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 1761 : 				ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1762 : 				jettSuccess = JettisonStation (curStation, Emergency); // MLR 3/2/2004 - 

	push	2
	mov	eax, DWORD PTR _curStation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax
$LN13@EmergencyJ:

; 1763 : 			}
; 1764 : 		}
; 1765 : 		else

	jmp	$LN10@EmergencyJ
$LN14@EmergencyJ:

; 1766 : 		{
; 1767 : 
; 1768 : 			 if(!(hardPoint[curStation]->GetRackDataFlags() & RDF_BMSDEFINITION))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+104]
	call	eax
	and	eax, 1
	jne	$LN9@EmergencyJ

; 1769 : 			 {
; 1770 : 				 if(((AircraftClass *)ownship)->IsF16() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	$LN8@EmergencyJ

; 1771 : 				 {
; 1772 : 					 if(!(curStation == 1 || curStation == 9 || hardPoint[curStation]->GetWeaponClass() == wcECM || hardPoint[curStation]->GetWeaponClass() == wcAimWpn || hardPoint[curStation]->GetWeaponClass() == wcHARMWpn) &&
; 1773 : 						 (hardPoint[curStation]->GetRack() || curStation == 5 && hardPoint[curStation]->GetWeaponClass() == wcTank))

	cmp	DWORD PTR _curStation$[ebp], 1
	je	$LN7@EmergencyJ
	cmp	DWORD PTR _curStation$[ebp], 9
	je	$LN7@EmergencyJ
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, 4
	je	$LN7@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	test	eax, eax
	je	$LN7@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 7
	je	SHORT $LN7@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+116]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@EmergencyJ
	cmp	DWORD PTR _curStation$[ebp], 5
	jne	SHORT $LN7@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN7@EmergencyJ
$LN6@EmergencyJ:

; 1774 : 					 {
; 1775 : 						 ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1776 : 						 jettSuccess = JettisonStation (curStation, Emergency); // MLR 3/2/2004 - 

	push	2
	mov	ecx, DWORD PTR _curStation$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax
$LN7@EmergencyJ:

; 1777 : 					 }
; 1778 : 				 }
; 1779 : 				 else

	jmp	$LN5@EmergencyJ
$LN8@EmergencyJ:

; 1780 : 				 {
; 1781 : 					 if (hardPoint[curStation] && !(hardPoint[curStation]->GetWeaponClass() == wcECM || 
; 1782 : 						 hardPoint[curStation]->GetWeaponClass() == wcAimWpn || hardPoint[curStation]->GetWeaponClass() == wcHARMWpn))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN5@EmergencyJ
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _curStation$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, 4
	je	SHORT $LN5@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	test	eax, eax
	je	SHORT $LN5@EmergencyJ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 7
	je	SHORT $LN5@EmergencyJ

; 1783 : 					 {
; 1784 : 						 ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1785 : 						 jettSuccess = JettisonStation (curStation, Emergency); // MLR 3/2/2004 - 

	push	2
	mov	ecx, DWORD PTR _curStation$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax
$LN5@EmergencyJ:

; 1786 : 					 }
; 1787 : 		
; 1788 : 				 }
; 1789 : 			 }
; 1790 : 			 else

	jmp	SHORT $LN10@EmergencyJ
$LN9@EmergencyJ:

; 1791 : 			 {
; 1792 : 				 ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1793 : 				 jettSuccess = JettisonStation (curStation, Emergency); // MLR 3/2/2004 - 

	push	2
	mov	edx, DWORD PTR _curStation$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax
$LN10@EmergencyJ:

; 1794 : 			 }
; 1795 : 		}
; 1796 : 	}

	jmp	$LN16@EmergencyJ
$LN15@EmergencyJ:

; 1797 : 
; 1798 : 	if (ownship->IsLocal ())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@EmergencyJ

; 1799 : 	{
; 1800 : 		// Create and fill in the message structure
; 1801 : 		FalconTrackMessage* trackMsg = new FalconTrackMessage (1,ownship->Id (), FalconLocalGame);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN27@EmergencyJ
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN25@EmergencyJ
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv504[ebp], eax
	jmp	SHORT $LN26@EmergencyJ
$LN25@EmergencyJ:
	mov	DWORD PTR tv504[ebp], 0
$LN26@EmergencyJ:
	push	1
	mov	eax, DWORD PTR tv504[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTrackMessage::FalconTrackMessage
	mov	DWORD PTR tv521[ebp], eax
	jmp	SHORT $LN28@EmergencyJ
$LN27@EmergencyJ:
	mov	DWORD PTR tv521[ebp], 0
$LN28@EmergencyJ:
	mov	eax, DWORD PTR tv521[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _trackMsg$6[ebp], ecx

; 1802 : 		trackMsg->dataBlock.trackType = Track_JettisonAll;

	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -65536				; ffff0000H
	or	eax, 8
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1803 : 		trackMsg->dataBlock.hardpoint = 0;

	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1804 : 		trackMsg->dataBlock.id = ownship->Id ();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], edx

; 1805 : 
; 1806 : 		// Send our track list
; 1807 : 		FalconSendMessage (trackMsg, TRUE);

	push	1
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN2@EmergencyJ:

; 1808 : 	}
; 1809 : 
; 1810 : 	// Set a permanent flag indicating that we've done the deed
; 1811 : 	if (jettSuccess)

	cmp	DWORD PTR _jettSuccess$[ebp], 0
	je	SHORT $LN23@EmergencyJ

; 1812 : 		flags |= EmergencyJettisonFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN23@EmergencyJ:

; 1813 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EmergencyJettison@SMSClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EmergencyJettison@SMSClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EmergencyJettison@SMSClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EmergencyJettison@SMSClass@@QAEXXZ ENDP		; SMSClass::EmergencyJettison
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 8
$T3 = -52						; size = 8
$T4 = -44						; size = 4
tv192 = -40						; size = 4
$T5 = -36						; size = 4
tv175 = -32						; size = 4
_jettSuccess$ = -28					; size = 4
_trackMsg$6 = -24					; size = 4
_curStation$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SelectiveJettison@SMSClass@@QAEXXZ PROC		; SMSClass::SelectiveJettison
; _this$ = ecx

; 1681 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SelectiveJettison@SMSClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1682 : 	int curStation;
; 1683 : 	int jettSuccess = 0;

	mov	DWORD PTR _jettSuccess$[ebp], 0

; 1684 : 
; 1685 : 	if (drawable) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+160], 0
	je	$LN8@SelectiveJ

; 1686 : 		for (curStation = numHardpoints-1; curStation>0; curStation--) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	DWORD PTR _curStation$[ebp], edx
	jmp	SHORT $LN6@SelectiveJ
$LN5@SelectiveJ:
	mov	eax, DWORD PTR _curStation$[ebp]
	sub	eax, 1
	mov	DWORD PTR _curStation$[ebp], eax
$LN6@SelectiveJ:
	cmp	DWORD PTR _curStation$[ebp], 0
	jle	$LN8@SelectiveJ

; 1687 : 			//if(drawable->hardPointSelected & (1 << curStation) && MasterArm() != Safe)
; 1688 : 			if(drawable->sjSelected[curStation]!=JettisonNone && MasterArm() != Safe) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR _curStation$[ebp]
	cmp	DWORD PTR [edx+eax*4+36], 0
	je	$LN3@SelectiveJ
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	je	$LN3@SelectiveJ

; 1689 :    				MonoPrint ("Jettison station %d at %ld\n", curStation, SimLibElapsedTime);

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	ecx
	mov	edx, DWORD PTR _curStation$[ebp]
	push	edx
	push	OFFSET ??_C@_0BM@CGGJMMAL@Jettison?5station?5?$CFd?5at?5?$CFld?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 1690 : 				ReleaseCurWeapon (-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseCurWeapon@SMSClass@@IAEXH@Z	; SMSClass::ReleaseCurWeapon

; 1691 : 				jettSuccess = JettisonStation (curStation, drawable->sjSelected[curStation]); // MLR 3/2/2004 - 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	edx, DWORD PTR _curStation$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+36]
	push	eax
	mov	ecx, DWORD PTR _curStation$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ; SMSClass::JettisonStation
	mov	DWORD PTR _jettSuccess$[ebp], eax

; 1692 : 				if (jettSuccess)

	cmp	DWORD PTR _jettSuccess$[ebp], 0
	je	SHORT $LN2@SelectiveJ

; 1693 : 					drawable->hardPointSelected -= (1 << curStation);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	edx, 1
	mov	ecx, DWORD PTR _curStation$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR [eax+32]
	sub	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR [edx+32], eax
$LN2@SelectiveJ:

; 1694 : 
; 1695 : 				if (ownship->IsLocal () && jettSuccess) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@SelectiveJ
	cmp	DWORD PTR _jettSuccess$[ebp], 0
	je	$LN3@SelectiveJ

; 1696 : 					// Create and fill in the message structure
; 1697 : 					FalconTrackMessage* trackMsg = new FalconTrackMessage (1,ownship->Id (), FalconLocalGame);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN12@SelectiveJ
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@SelectiveJ
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN11@SelectiveJ
$LN10@SelectiveJ:
	mov	DWORD PTR tv175[ebp], 0
$LN11@SelectiveJ:
	push	1
	mov	eax, DWORD PTR tv175[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTrackMessage::FalconTrackMessage
	mov	DWORD PTR tv192[ebp], eax
	jmp	SHORT $LN13@SelectiveJ
$LN12@SelectiveJ:
	mov	DWORD PTR tv192[ebp], 0
$LN13@SelectiveJ:
	mov	eax, DWORD PTR tv192[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _trackMsg$6[ebp], ecx

; 1698 : 					trackMsg->dataBlock.trackType = Track_JettisonWeapon;

	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -65536				; ffff0000H
	or	eax, 9
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1699 : 					trackMsg->dataBlock.hardpoint = (ushort)curStation;

	movzx	edx, WORD PTR _curStation$[ebp]
	and	edx, 65535				; 0000ffffH
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 65535				; 0000ffffH
	or	ecx, edx
	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [edx+48], ecx

; 1700 : 					trackMsg->dataBlock.id = ownship->Id ();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [ecx+52], edx
	mov	DWORD PTR [ecx+56], eax

; 1701 : 
; 1702 : 					// Send our track list
; 1703 : 					FalconSendMessage (trackMsg, TRUE);

	push	1
	mov	edx, DWORD PTR _trackMsg$6[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN3@SelectiveJ:

; 1704 : 				}
; 1705 : 			}
; 1706 : 		}

	jmp	$LN5@SelectiveJ
$LN8@SelectiveJ:

; 1707 : 	}
; 1708 : 
; 1709 : /*   // Can't jettison the gun
; 1710 : 	if (curHardpoint > 0)
; 1711 : 	{
; 1712 : //		MonoPrint ("Jettison station %d\n", curStation);
; 1713 : 		ReleaseCurWeapon (-1);
; 1714 : 		JettisonStation (curHardpoint);
; 1715 : 	}
; 1716 :    */
; 1717 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SelectiveJettison@SMSClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SelectiveJettison@SMSClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SelectiveJettison@SMSClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectiveJettison@SMSClass@@QAEXXZ ENDP		; SMSClass::SelectiveJettison
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wClass$ = 8						; size = 4
_count$ = 12						; size = 4
?DecrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z PROC	; SMSClass::DecrementStores
; _this$ = ecx

; 1671 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1672 :    ShiAssert (wClass <= wcNoWpn && wClass >= 0);
; 1673 :    numOnBoard[wClass] -= count;

	mov	eax, DWORD PTR _wClass$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+88]
	sub	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _wClass$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+88], edx

; 1674 :    ShiAssert(numOnBoard[wClass] >= 0);
; 1675 :    if(numOnBoard[wClass] < 0)

	mov	edx, DWORD PTR _wClass$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+88], 0
	jge	SHORT $LN2@DecrementS

; 1676 : 	   numOnBoard[wClass] = 0;

	mov	ecx, DWORD PTR _wClass$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+88], 0
$LN2@DecrementS:

; 1677 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DecrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z ENDP	; SMSClass::DecrementStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wClass$ = 8						; size = 4
_count$ = 12						; size = 4
?IncrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z PROC	; SMSClass::IncrementStores
; _this$ = ecx

; 1662 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1663 :    ShiAssert (wClass <= wcNoWpn && wClass >= 0);
; 1664 :    numOnBoard[wClass] += count;

	mov	eax, DWORD PTR _wClass$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+88]
	add	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _wClass$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+88], edx

; 1665 :    ShiAssert(numOnBoard[wClass] >= 0);
; 1666 :    if(numOnBoard[wClass] < 0)

	mov	edx, DWORD PTR _wClass$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+88], 0
	jge	SHORT $LN2@IncrementS

; 1667 : 	   numOnBoard[wClass] = 0;

	mov	ecx, DWORD PTR _wClass$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+88], 0
$LN2@IncrementS:

; 1668 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IncrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z ENDP	; SMSClass::IncrementStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newType$ = 8						; size = 4
?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z PROC	; SMSClass::SetWeaponType
; _this$ = ecx

; 1657 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1658 :    curWeaponType = newType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newType$[ebp]
	mov	DWORD PTR [eax+148], ecx

; 1659 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ENDP	; SMSClass::SetWeaponType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_station$ = 8						; size = 4
_weapon$ = 12						; size = 4
?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z PROC ; SMSClass::SetCurrentWeapon
; _this$ = ecx

; 1895 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1896 : 	lastWpnStation = curHardpoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+140], edx

; 1897 : 	lastWpnNum     = curWpnNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+144], edx

; 1898 : 
; 1899 : 	if (station >= 0){

	cmp	DWORD PTR _station$[ebp], 0
	jl	$LN9@SetCurrent

; 1900 : 		if(!weapon){ // MLR 2/1/2004 - 

	cmp	DWORD PTR _weapon$[ebp], 0
	jne	SHORT $LN8@SetCurrent

; 1901 : 			weapon=hardPoint[station]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapon$[ebp], eax
$LN7@SetCurrent:

; 1902 : 			while(weapon && !weapon->IsUseable()){ // MLR 6/4/2004 - 

	cmp	DWORD PTR _weapon$[ebp], 0
	je	SHORT $LN8@SetCurrent
	mov	eax, DWORD PTR _weapon$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _weapon$[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@SetCurrent

; 1903 : 				weapon=weapon->GetNextOnRail();

	mov	ecx, DWORD PTR _weapon$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapon$[ebp], eax

; 1904 : 			}

	jmp	SHORT $LN7@SetCurrent
$LN8@SetCurrent:

; 1905 : 		}
; 1906 : 		curHardpoint   = station;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _station$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 1907 : 		
; 1908 : 		// COBRA - RED - A NEW CORRECTION, RESET WEAPON PARAMETERS IF NO WEAPON...!!!! 
; 1909 : 		if (weapon){

	cmp	DWORD PTR _weapon$[ebp], 0
	je	$LN5@SetCurrent

; 1910 : 			// sfr: test
; 1911 : 			if (weapon && !weapon->IsWeapon()){

	cmp	DWORD PTR _weapon$[ebp], 0
	je	SHORT $LN4@SetCurrent
	mov	eax, DWORD PTR _weapon$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _weapon$[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@SetCurrent

; 1912 : 				printf("bug bug bug");

	push	OFFSET ??_C@_0M@GPPLIIOD@bug?5bug?5bug?$AA@
	call	_printf
	add	esp, 4
$LN4@SetCurrent:

; 1913 : 			}
; 1914 : 			curWpnNum   = weapon->GetRackSlot();

	mov	ecx, DWORD PTR _weapon$[ebp]
	call	?GetRackSlot@SimWeaponClass@@QAEHXZ	; SimWeaponClass::GetRackSlot
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 1915 : 			curWeapon.reset(weapon);

	mov	edx, DWORD PTR _weapon$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 1916 : 			curWeaponType  = hardPoint[station]->GetWeaponType();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+156]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 1917 : 			curWeaponClass = hardPoint[station]->GetWeaponClass();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _station$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], eax

; 1918 : 			curWeaponId    = hardPoint[station]->weaponId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [edx+8]
	mov	WORD PTR [eax+168], cx

; 1919 : 			curWeaponDomain= hardPoint[station]->Domain();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _station$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+168]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], eax

; 1920 : 		}
; 1921 : 		else{

	jmp	SHORT $LN3@SetCurrent
$LN5@SetCurrent:

; 1922 : 			curWpnNum   = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], -1

; 1923 : 			curWeapon.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 1924 : 			curWeaponType  = wtNone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 11			; 0000000bH

; 1925 : 			curWeaponClass = wcNoWpn;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 11			; 0000000bH

; 1926 : 			curWeaponId    = -1;

	or	edx, -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+168], dx

; 1927 : 			curWeaponDomain= wdNoDomain;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0
$LN3@SetCurrent:

; 1928 : 		}
; 1929 : 
; 1930 : 		if (curWeapon && (curWeaponClass == wcHARMWpn)){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@SetCurrent
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 7
	jne	SHORT $LN2@SetCurrent

; 1931 : 			((MissileClass*)curWeapon.get())->display = FindSensor(ownship, SensorClass::HTS);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR [eax+712], esi
$LN2@SetCurrent:

; 1932 : 		}
; 1933 : 	}
; 1934 : 	else {

	jmp	SHORT $LN1@SetCurrent
$LN9@SetCurrent:

; 1935 : 		curWeapon.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 1936 : 		curWeaponType  = wtNone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 11			; 0000000bH

; 1937 : 		curWeaponClass = wcNoWpn;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 11			; 0000000bH

; 1938 : 		curWeaponId    = -1;

	or	edx, -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+168], dx

; 1939 : 		curWeaponDomain= wdNoDomain;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0
$LN1@SetCurrent:

; 1940 : 	}
; 1941 : 	//MI since this get's called AFTER the ChooseLimiterMode() function above when launching AG
; 1942 : 	//missiles, we're not checking with the correct loadout. So let's just check here again.
; 1943 : 	//This fixes the bug with AG missiles and OverG when we only have the rack left
; 1944 : 	ChooseLimiterMode(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseLimiterMode@SMSClass@@QAEXH@Z	; SMSClass::ChooseLimiterMode

; 1945 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetCurrentWeapon@SMSClass@@QAEXHPAVSimWeaponClass@@@Z ENDP ; SMSClass::SetCurrentWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCurrentWeapon@SMSClass@@UAEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWeapon@SMSClass@@UAEPAVSimWeaponClass@@XZ PROC ; SMSClass::GetCurrentWeapon, COMDAT
; _this$ = ecx

; 211  : 	virtual SimWeaponClass* GetCurrentWeapon (void) {return curWeapon.get();};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeapon@SMSClass@@UAEPAVSimWeaponClass@@XZ ENDP ; SMSClass::GetCurrentWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_rackslotid$1 = -32					; size = 4
_parentBSP$ = -28					; size = 4
_drawPtr$ = -24						; size = 4
_rackBSP$ = -20						; size = 4
_pylonBSP$ = -16					; size = 4
_weapPtr$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?FreeWeaponGraphics@SMSClass@@UAEXXZ PROC		; SMSClass::FreeWeaponGraphics
; _this$ = ecx

; 1378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1379 : 	int i;
; 1380 : 	DrawableBSP	*drawPtr   = (DrawableBSP*) ownship->drawPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR _drawPtr$[ebp], edx

; 1381 : 	DrawableBSP *rackBSP   = NULL, 

	mov	DWORD PTR _rackBSP$[ebp], 0

; 1382 : 				*pylonBSP  = NULL;

	mov	DWORD PTR _pylonBSP$[ebp], 0

; 1383 : 	DrawableBSP *parentBSP = drawPtr; // parent of the weapon

	mov	eax, DWORD PTR _drawPtr$[ebp]
	mov	DWORD PTR _parentBSP$[ebp], eax

; 1384 : 	SimWeaponClass *weapPtr;
; 1385 : 	
; 1386 : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@FreeWeapon
$LN13@FreeWeapon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN14@FreeWeapon:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN15@FreeWeapon

; 1387 : 	{
; 1388 : 		if (hardPoint[i])

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	$LN11@FreeWeapon

; 1389 : 		{
; 1390 : 			// Detach all weapons from the rack and remove drawables
; 1391 : 			weapPtr = hardPoint[i]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapPtr$[ebp], eax
$LN10@FreeWeapon:

; 1392 : 			while (weapPtr)

	cmp	DWORD PTR _weapPtr$[ebp], 0
	je	$LN9@FreeWeapon

; 1393 : 			{
; 1394 : 				if ( weapPtr->IsMissile() )

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	SHORT $LN8@FreeWeapon

; 1395 : 				{
; 1396 : 					((MissileClass *)weapPtr)->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?SetTarget@MissileClass@@QAEXPAVSimObjectType@@@Z ; MissileClass::SetTarget

; 1397 : 					((MissileClass *)weapPtr)->ClearReferences();

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?ClearReferences@MissileClass@@QAEXXZ	; MissileClass::ClearReferences

; 1398 : 				}
; 1399 : 				else 

	jmp	SHORT $LN7@FreeWeapon
$LN8@FreeWeapon:

; 1400 : 					if ( weapPtr->IsBomb() )

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	je	SHORT $LN7@FreeWeapon

; 1401 : 						((BombClass *)weapPtr)->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?SetTarget@BombClass@@QAEXPAVSimObjectType@@@Z ; BombClass::SetTarget
$LN7@FreeWeapon:

; 1402 : 				
; 1403 : 				RemoveStore(i, hardPoint[i]->weaponId);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 1404 : 
; 1405 : 				if (weapPtr->drawPointer)

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN5@FreeWeapon

; 1406 : 				{
; 1407 : 					hardPoint[i]->DetachWeaponBSP(weapPtr);

	mov	edx, DWORD PTR _weapPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+88]
	call	edx

; 1408 : 					//OTWDriver.DetachObject(parentBSP, (DrawableBSP*)(weapPtr->drawPointer), weapPtr->GetRackSlot());
; 1409 : 					OTWDriver.RemoveObject(weapPtr->drawPointer, TRUE);	// MLR is this needed?

	push	1
	mov	eax, DWORD PTR _weapPtr$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 1410 : 					weapPtr->drawPointer = NULL;

	mov	edx, DWORD PTR _weapPtr$[ebp]
	mov	DWORD PTR [edx+332], 0
$LN5@FreeWeapon:

; 1411 : 				}
; 1412 : 				weapPtr = weapPtr->GetNextOnRail();

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapPtr$[ebp], eax

; 1413 : 			}

	jmp	$LN10@FreeWeapon
$LN9@FreeWeapon:

; 1414 : 			
; 1415 : 			// MLR 1/11/2004 - Free the pods, if any
; 1416 : 			/*
; 1417 : 			weapPtr = hardPoint[i]->podPointer;
; 1418 : 			while (weapPtr)
; 1419 : 			{
; 1420 : 				if ( weapPtr->IsMissile() ) // this code could be trimmed out
; 1421 : 				{
; 1422 : 					((MissileClass *)weapPtr)->SetTarget( NULL );
; 1423 : 					((MissileClass *)weapPtr)->ClearReferences();
; 1424 : 				}
; 1425 : 				else if ( weapPtr->IsBomb() )
; 1426 : 					((BombClass *)weapPtr)->SetTarget( NULL );
; 1427 : 				
; 1428 : 				RemoveStore(i, hardPoint[i]->weaponId);
; 1429 : 				if (weapPtr->drawPointer)
; 1430 : 				{
; 1431 : 					hardPoint[i]->DetachWeaponBSP(weapPtr);
; 1432 : 					//OTWDriver.DetachObject(parentBSP, (DrawableBSP*)(weapPtr->drawPointer), weapPtr->GetRackSlot());
; 1433 : 					OTWDriver.RemoveObject(weapPtr->drawPointer, TRUE);	// MLR is this needed?
; 1434 : 					weapPtr->drawPointer = NULL;
; 1435 : 				}
; 1436 : 				weapPtr = weapPtr->GetNextOnRail();
; 1437 : 			}
; 1438 : 			*/
; 1439 : 
; 1440 : 			// remove the pylon & rack
; 1441 : 
; 1442 : 			// 1st determine what the rack is attached to
; 1443 : 			parentBSP		= drawPtr;

	mov	eax, DWORD PTR _drawPtr$[ebp]
	mov	DWORD PTR _parentBSP$[ebp], eax

; 1444 : 			int rackslotid	= i-1;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _rackslotid$1[ebp], ecx

; 1445 : 
; 1446 : 			if(pylonBSP)

	cmp	DWORD PTR _pylonBSP$[ebp], 0
	je	SHORT $LN4@FreeWeapon

; 1447 : 			{ 
; 1448 : 				// set these up for the rack
; 1449 : 				parentBSP  = pylonBSP;

	mov	edx, DWORD PTR _pylonBSP$[ebp]
	mov	DWORD PTR _parentBSP$[ebp], edx

; 1450 : 				rackslotid = 0;

	mov	DWORD PTR _rackslotid$1[ebp], 0
$LN4@FreeWeapon:

; 1451 : 			}
; 1452 : 
; 1453 : 			rackBSP = hardPoint[i]->DetachRackBSP();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+68]
	call	edx
	mov	DWORD PTR _rackBSP$[ebp], eax

; 1454 : 			if(rackBSP)

	cmp	DWORD PTR _rackBSP$[ebp], 0
	je	SHORT $LN3@FreeWeapon

; 1455 : 			{
; 1456 : 				//OTWDriver.DetachObject(parentBSP, rackBSP, rackslotid);
; 1457 : 				RemoveStore(i, hardPoint[i]->GetRackId());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+132]
	call	edx
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 1458 : 				OTWDriver.RemoveObject(rackBSP, TRUE); // deletes object too

	push	1
	mov	ecx, DWORD PTR _rackBSP$[ebp]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject
$LN3@FreeWeapon:

; 1459 : 				//hardPoint[i]->SetRack(NULL);
; 1460 : 			}
; 1461 : 
; 1462 : 			pylonBSP = hardPoint[i]->DetachPylonBSP();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	DWORD PTR _pylonBSP$[ebp], eax

; 1463 : 			if(pylonBSP)

	cmp	DWORD PTR _pylonBSP$[ebp], 0
	je	SHORT $LN2@FreeWeapon

; 1464 : 			{
; 1465 : 				//OTWDriver.DetachObject(drawPtr, pylonBSP, i-1);
; 1466 : 				RemoveStore(i, hardPoint[i]->GetPylonId());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+140]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 1467 : 				OTWDriver.RemoveObject(pylonBSP, TRUE); // deletes object too

	push	1
	mov	edx, DWORD PTR _pylonBSP$[ebp]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject
$LN2@FreeWeapon:

; 1468 : 				//hardPoint[i]->SetPylon(NULL);
; 1469 : 			}
; 1470 : 
; 1471 : 			if (GetGun(i))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ; SMSBaseClass::GetGun
	test	eax, eax
	je	SHORT $LN11@FreeWeapon

; 1472 : 				GetGun(i)->CleanupTracers();

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ; SMSBaseClass::GetGun
	mov	ecx, eax
	call	?CleanupTracers@GunClass@@QAEXXZ	; GunClass::CleanupTracers
$LN11@FreeWeapon:

; 1473 : 		}
; 1474 : 	}

	jmp	$LN13@FreeWeapon
$LN15@FreeWeapon:

; 1475 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeWeaponGraphics@SMSClass@@UAEXXZ ENDP		; SMSClass::FreeWeaponGraphics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_zOff$ = -80						; size = 4
_xOff$ = -76						; size = 4
_yOff$ = -72						; size = 4
_wid$1 = -68						; size = 4
_rackFlag$ = -64					; size = 4
_rnds$2 = -60						; size = 4
_drawPtr$ = -56						; size = 4
tv211 = -52						; size = 4
_first$3 = -48						; size = 4
_vc$ = -44						; size = 4
_lau$4 = -40						; size = 4
_l$5 = -36						; size = 4
_visFlag$ = -32						; size = 4
_weapPtr$ = -28						; size = 4
_this$ = -24						; size = 4
_i$ = -20						; size = 4
_simView$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?AddWeaponGraphics@SMSClass@@UAEXXZ PROC		; SMSClass::AddWeaponGraphics
; _this$ = ecx

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1048 : 	int i;
; 1049 : 	Tpoint simView;
; 1050 : 	float xOff, yOff, zOff;
; 1051 : 	VehicleClassDataType* vc;
; 1052 : 	int rackFlag, visFlag;
; 1053 : 	SimWeaponClass *weapPtr;
; 1054 : 	DrawableBSP	*drawPtr = (DrawableBSP*) ownship->drawPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR _drawPtr$[ebp], edx

; 1055 : 	
; 1056 : 	if (!hardPoint)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN22@AddWeaponG

; 1057 : 		return;

	jmp	$LN23@AddWeaponG
$LN22@AddWeaponG:

; 1058 : 	
; 1059 : 	vc = GetVehicleClassData(ownship->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	edx, ax
	sub	edx, 100				; 00000064H
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 1060 : 	rackFlag=vc->RackFlags;

	mov	eax, DWORD PTR _vc$[ebp]
	movzx	ecx, WORD PTR [eax+60]
	mov	DWORD PTR _rackFlag$[ebp], ecx

; 1061 : 	visFlag=vc->VisibleFlags;

	mov	edx, DWORD PTR _vc$[ebp]
	movzx	eax, WORD PTR [edx+62]
	mov	DWORD PTR _visFlag$[ebp], eax

; 1062 : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@AddWeaponG
$LN20@AddWeaponG:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN21@AddWeaponG:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN19@AddWeaponG

; 1063 : 	{
; 1064 : 		if (hardPoint[i] && hardPoint[i]->weaponPointer)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	$LN8@AddWeaponG
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@AddWeaponG

; 1065 : 		{
; 1066 : 			hardPoint[i]->SetSMS(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+48]
	call	edx

; 1067 : 			hardPoint[i]->SetHPId(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	call	?SetHPId@BasicWeaponStation@@QAEXH@Z	; BasicWeaponStation::SetHPId

; 1068 : 			hardPoint[i]->SetParentDrawPtr(drawPtr);

	mov	ecx, DWORD PTR _drawPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	call	?SetParentDrawPtr@BasicWeaponStation@@QAEXPAVDrawableBSP@@@Z ; BasicWeaponStation::SetParentDrawPtr

; 1069 : 
; 1070 : 			if (hardPoint[i]->weaponPointer->IsGun()/* && i==0*/){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv211[ebp], eax
	mov	edx, DWORD PTR tv211[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv211[ebp]
	mov	edx, DWORD PTR [eax+168]
	call	edx
	test	eax, eax
	je	SHORT $LN17@AddWeaponG

; 1071 : 				// MLR 1/28/2004 - added i==0
; 1072 : 				((GunClass*)hardPoint[i]->weaponPointer.get())->InitTracers();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	ecx, eax
	call	?InitTracers@GunClass@@QAEXXZ		; GunClass::InitTracers

; 1073 : 			}
; 1074 : 			else 

	jmp	$LN8@AddWeaponG
$LN17@AddWeaponG:

; 1075 : 			{
; 1076 : 				if (i>0)

	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN8@AddWeaponG

; 1077 : 				{
; 1078 : 					if (visFlag & (1 << i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _visFlag$[ebp]
	je	SHORT $LN14@AddWeaponG

; 1079 : 					{
; 1080 : 						drawPtr->GetChildOffset(i-1, &simView);

	lea	ecx, DWORD PTR _simView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _drawPtr$[ebp]
	call	?GetChildOffset@DrawableBSP@@QAEXHPAUTpoint@@@Z ; DrawableBSP::GetChildOffset

; 1081 : 					}
; 1082 : 					else

	jmp	SHORT $LN13@AddWeaponG
$LN14@AddWeaponG:

; 1083 : 					{
; 1084 : 						simView.x = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _simView$[ebp], xmm0

; 1085 : 						simView.y = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _simView$[ebp+4], xmm0

; 1086 : 						simView.z = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _simView$[ebp+8], xmm0
$LN13@AddWeaponG:

; 1087 : 					}
; 1088 : 
; 1089 : 
; 1090 : 					hardPoint[i]->SetPosition(simView.x, simView.y, simView.z);

	push	ecx
	movss	xmm0, DWORD PTR _simView$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _simView$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _simView$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1091 : 
; 1092 : 	
; 1093 : 					if (rackFlag & (1 << i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _rackFlag$[ebp]
	je	$LN10@AddWeaponG

; 1094 : 					{
; 1095 : 						// create the pylon
; 1096 : 						if(hardPoint[i]->GetPylonId())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+140]
	call	eax
	test	eax, eax
	je	SHORT $LN11@AddWeaponG

; 1097 : 						{
; 1098 : 							hardPoint[i]->AttachPylonBSP();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+52]
	call	eax

; 1099 : 							AddStore(i, hardPoint[i]->GetPylonId(), (visFlag & (1 << i)));

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _visFlag$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+140]
	call	edx
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStore@SMSClass@@QAEXHHH@Z		; SMSClass::AddStore
$LN11@AddWeaponG:

; 1100 : 						}
; 1101 : 
; 1102 : 						// create the rack
; 1103 : 						if(hardPoint[i]->GetRackId())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+132]
	call	eax
	test	eax, eax
	je	SHORT $LN10@AddWeaponG

; 1104 : 						{
; 1105 : 							hardPoint[i]->AttachRackBSP();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+64]
	call	eax

; 1106 : 							AddStore(i, hardPoint[i]->GetRackId(), (visFlag & (1 << i)));

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _visFlag$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+132]
	call	edx
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStore@SMSClass@@QAEXHHH@Z		; SMSClass::AddStore
$LN10@AddWeaponG:

; 1107 : 						}
; 1108 : 					}
; 1109 : 					
; 1110 : 					// Use the rack offset in addition to our location offset
; 1111 : 					hardPoint[i]->GetPosition(&xOff, &yOff, &zOff);

	lea	ecx, DWORD PTR _zOff$[ebp]
	push	ecx
	lea	edx, DWORD PTR _yOff$[ebp]
	push	edx
	lea	eax, DWORD PTR _xOff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+16]
	call	eax

; 1112 : 
; 1113 : 
; 1114 : 					/*
; 1115 : 					int ispod=0;
; 1116 : 					if(hardPoint[i]->podPointer)
; 1117 : 					{
; 1118 : 						ispod=1;
; 1119 : 						// since we're dealing with pods, we just need to add the 
; 1120 : 						// weapon weight/drag whatever via AddStore()
; 1121 : 						weapPtr = hardPoint[i]->weaponPointer;
; 1122 : 						while(weapPtr)
; 1123 : 						{
; 1124 : 							AddStore(i, hardPoint[i]->weaponId, (visFlag & (1 << i)));
; 1125 : 							weapPtr=weapPtr->GetNextOnRail();
; 1126 : 						}
; 1127 : 
; 1128 : 						weapPtr = hardPoint[i]->podPointer;
; 1129 : 
; 1130 : 					}
; 1131 : 					else */
; 1132 : 						weapPtr = hardPoint[i]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapPtr$[ebp], eax

; 1133 : 
; 1134 : 					int first=1;

	mov	DWORD PTR _first$3[ebp], 1
$LN9@AddWeaponG:

; 1135 : 					while (weapPtr)

	cmp	DWORD PTR _weapPtr$[ebp], 0
	je	$LN8@AddWeaponG

; 1136 : 					{
; 1137 : 						if( visFlag & (1 << i) &&
; 1138 : 						    ( first || hardPoint[i]->GetRack() ) )

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _visFlag$[ebp]
	je	SHORT $LN7@AddWeaponG
	cmp	DWORD PTR _first$3[ebp], 0
	jne	SHORT $LN6@AddWeaponG
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	test	eax, eax
	je	SHORT $LN7@AddWeaponG
$LN6@AddWeaponG:

; 1139 : 
; 1140 : 						{
; 1141 : 							hardPoint[i]->AttachWeaponBSP(weapPtr);

	mov	eax, DWORD PTR _weapPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+80]
	call	eax
$LN7@AddWeaponG:

; 1142 : 						}
; 1143 : 
; 1144 : 						AddStore(i, hardPoint[i]->weaponId,(visFlag & (1 << i)));

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _visFlag$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStore@SMSClass@@QAEXHHH@Z		; SMSClass::AddStore

; 1145 : 
; 1146 : 						// MLR 3/15/2004 - Add Launchers munition
; 1147 : 						if(weapPtr->IsLauncher())

	mov	eax, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
	test	eax, eax
	je	SHORT $LN2@AddWeaponG

; 1148 : 						{
; 1149 : 							BombClass *lau = (BombClass *)weapPtr;

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	DWORD PTR _lau$4[ebp], ecx

; 1150 : 							int wid  = lau->LauGetWeaponId();

	mov	ecx, DWORD PTR _lau$4[ebp]
	call	?LauGetWeaponId@BombClass@@QAEHXZ	; BombClass::LauGetWeaponId
	mov	DWORD PTR _wid$1[ebp], eax

; 1151 : 							int rnds = lau->LauGetRoundsRemaining();

	mov	ecx, DWORD PTR _lau$4[ebp]
	call	?LauGetRoundsRemaining@BombClass@@QAEHXZ ; BombClass::LauGetRoundsRemaining
	mov	DWORD PTR _rnds$2[ebp], eax

; 1152 : 							int l;
; 1153 : 
; 1154 : 							for(l = 0; l < rnds; l++)

	mov	DWORD PTR _l$5[ebp], 0
	jmp	SHORT $LN4@AddWeaponG
$LN3@AddWeaponG:
	mov	edx, DWORD PTR _l$5[ebp]
	add	edx, 1
	mov	DWORD PTR _l$5[ebp], edx
$LN4@AddWeaponG:
	mov	eax, DWORD PTR _l$5[ebp]
	cmp	eax, DWORD PTR _rnds$2[ebp]
	jge	SHORT $LN2@AddWeaponG

; 1155 : 							{
; 1156 : 								AddStore(i, wid, 0); // rockets are not "visible" - no extra drag

	push	0
	mov	ecx, DWORD PTR _wid$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStore@SMSClass@@QAEXHHH@Z		; SMSClass::AddStore

; 1157 : 							}

	jmp	SHORT $LN3@AddWeaponG
$LN2@AddWeaponG:

; 1158 : 						}
; 1159 : 						
; 1160 : 						if (weapPtr->IsGun() ) // init  gun pod // MLR 1/28/2004 - 

	mov	eax, DWORD PTR _weapPtr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+168]
	call	eax
	test	eax, eax
	je	SHORT $LN1@AddWeaponG

; 1161 : 						{
; 1162 : 							((GunClass*)weapPtr)->InitTracers();

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?InitTracers@GunClass@@QAEXXZ		; GunClass::InitTracers
$LN1@AddWeaponG:

; 1163 : 							//((GunClass*)weapPtr)->SetPosition(simView.x, simView.y, simView.z,0,0);
; 1164 : 						}
; 1165 : 
; 1166 : 						first=0;

	mov	DWORD PTR _first$3[ebp], 0

; 1167 : 						weapPtr = weapPtr->GetNextOnRail();

	mov	ecx, DWORD PTR _weapPtr$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapPtr$[ebp], eax

; 1168 : 					}

	jmp	$LN9@AddWeaponG
$LN8@AddWeaponG:

; 1169 : 				}
; 1170 : 			}
; 1171 : 		}
; 1172 : 	}

	jmp	$LN20@AddWeaponG
$LN19@AddWeaponG:
$LN23@AddWeaponG:

; 1173 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AddWeaponGraphics@SMSClass@@UAEXXZ ENDP		; SMSClass::AddWeaponGraphics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv88 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SMSClass@@UAE@XZ PROC				; SMSClass::~SMSClass
; _this$ = ecx

; 952  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SMSClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SMSClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 953  :    FreeWeapons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeWeapons@SMSClass@@QAEXXZ		; SMSClass::FreeWeapons

; 954  : 
; 955  :    delete drawable;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@SMSClass
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN4@SMSClass
$LN3@SMSClass:
	mov	DWORD PTR tv88[ebp], 0
$LN4@SMSClass:

; 956  :    drawable = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 957  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SMSBaseClass@@UAE@XZ			; SMSBaseClass::~SMSBaseClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1SMSClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SMSBaseClass@@UAE@XZ			; SMSBaseClass::~SMSBaseClass
__unwindfunclet$??1SMSClass@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$??1SMSClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SMSClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SMSClass@@UAE@XZ ENDP				; SMSClass::~SMSClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_visFlag$ = -72						; size = 4
_rackFlag$ = -68					; size = 4
_dataIndex$ = -64					; size = 4
_lo$2 = -60						; size = 4
tv685 = -56						; size = 4
tv503 = -52						; size = 4
_vc$ = -48						; size = 4
_wc$ = -44						; size = 4
_weapPtr$3 = -40					; size = 4
_l$4 = -36						; size = 4
_gun$ = -32						; size = 4
_classPtr$ = -28					; size = 4
_wpnDefinition$ = -24					; size = 4
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newOwnship$ = 8					; size = 4
_weapId$ = 12						; size = 4
_weapCnt$ = 16						; size = 4
??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z PROC	; SMSClass::SMSClass
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _weapCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _weapId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newOwnship$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z ; SMSBaseClass::SMSBaseClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SMSClass@@6B@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 711  : 	int i;
; 712  : 	Falcon4EntityClassType* classPtr;
; 713  : 	SimWeaponDataType* wpnDefinition;
; 714  : 	int dataIndex;
; 715  : 	VehicleClassDataType* vc;
; 716  : 	WeaponClassDataType* wc;
; 717  : 	int rackFlag, visFlag;
; 718  : 	GunClass* gun;
; 719  : 	
; 720  : 	flash     = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+68], 0

; 721  : 	curHardpoint = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], -1

; 722  : 	curWpnNum = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], -1

; 723  : 	curWeaponId = -1;

	or	ecx, -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+168], cx

; 724  : 	//curWeapon = NULL;
; 725  : 	curWeaponType = wtNone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 11			; 0000000bH

; 726  : 	curWeaponClass = wcNoWpn;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 11			; 0000000bH

; 727  : 	curWeaponDomain = wdNoDomain;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 0

; 728  : 	flags = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 729  : 	//rippleCount = 0;
; 730  : 	//rippleInterval = 25;
; 731  : 	//rippleInterval = 125; // JB 010701
; 732  : 	curRippleCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 733  : 	//pair = FALSE;
; 734  : 	nextDrop = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 735  : 	// default burst height to optimum height...default for AI
; 736  : 	burstHeight  = 1000.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR [eax+76], xmm0

; 737  : 	armingdelay = 480; //me123 status ok. addet

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43f00000
	movss	DWORD PTR [ecx+172], xmm0

; 738  :         aim120id = 0; // JPO added.

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+176], 0

; 739  : 	aim9mode = WARM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+180], 0

; 740  : 	aim9cooltime = 3.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [ecx+184], xmm0

; 741  : 	aim9warmtime = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+192], xmm0

; 742  : 	aim9coolingtimeleft = 1.5 * 60 * 60;//1.5 * 60.0 * 60.0 * CLOCKS_PER_SEC;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45a8c000
	movss	DWORD PTR [eax+188], xmm0

; 743  : 	// Test - 10 seconds of coolant
; 744  : 	// aim9coolingtimeleft = 10.0F;// * CLOCKS_PER_SEC;
; 745  : 	aim9LastRunTime = 0;

	mov	DWORD PTR ?aim9LastRunTime@@3KA, 0	; aim9LastRunTime

; 746  : 	drawable = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 747  : 
; 748  : 	//MI
; 749  : 	//angle = 23;
; 750  : 
; 751  : 	curProfile = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], 0

; 752  : 
; 753  : 	agbProfile[0].rippleCount     = 0;

	mov	eax, 40					; 00000028H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+200], 0

; 754  : 	agbProfile[0].rippleInterval  = 175;

	mov	edx, 40					; 00000028H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+204], 175		; 000000afH

; 755  : 	agbProfile[0].fuzeNoseTail    = 0;

	mov	ecx, 40					; 00000028H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+208], 0

; 756  : 	agbProfile[0].burstAltitude   = 1000;

	mov	eax, 40					; 00000028H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+212], 1000		; 000003e8H

; 757  : 	agbProfile[0].releaseAngle    = 23;

	mov	edx, 40					; 00000028H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+216], 23		; 00000017H

; 758  : 	agbProfile[0].C1ArmDelay1     = 400;

	mov	ecx, 40					; 00000028H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [edx+ecx+220], xmm0

; 759  : 	agbProfile[0].C1ArmDelay2     = 600;

	mov	eax, 40					; 00000028H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR [ecx+eax+224], xmm0

; 760  : 	agbProfile[0].C2ArmDelay      = 150;

	mov	edx, 40					; 00000028H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR [eax+edx+228], xmm0

; 761  : 	agbProfile[0].releasePair     = FALSE;

	mov	ecx, 40					; 00000028H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+232], 0

; 762  : 	agbProfile[0].subMode		  = FireControlComputer::CCRP;

	mov	eax, 40					; 00000028H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+236], 8

; 763  : 
; 764  : 	agbProfile[1].rippleCount     = 3;

	mov	edx, 40					; 00000028H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+200], 3

; 765  : 	agbProfile[1].rippleInterval  = 25;

	mov	ecx, 40					; 00000028H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+204], 25		; 00000019H

; 766  : 	agbProfile[1].fuzeNoseTail    = 1;

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+208], 1

; 767  : 	agbProfile[1].burstAltitude   = 500;

	mov	edx, 40					; 00000028H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+212], 500		; 000001f4H

; 768  : 	agbProfile[1].releaseAngle    = 23;

	mov	ecx, 40					; 00000028H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+216], 23		; 00000017H

; 769  : 	agbProfile[1].C1ArmDelay1     = 400;

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [ecx+eax+220], xmm0

; 770  : 	agbProfile[1].C1ArmDelay2     = 600;

	mov	edx, 40					; 00000028H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR [eax+edx+224], xmm0

; 771  : 	agbProfile[1].C2ArmDelay      = 150;

	mov	ecx, 40					; 00000028H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR [edx+ecx+228], xmm0

; 772  : 	agbProfile[1].releasePair     = FALSE;

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+232], 0

; 773  : 	agbProfile[1].subMode		  = FireControlComputer::CCIP;

	mov	edx, 40					; 00000028H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+236], 7

; 774  : 
; 775  : 	runRockets = 0; // MLR 6/3/2004 - 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 776  : 
; 777  : 	/*Prof1RP = 0;
; 778  : 	Prof2RP = 3;
; 779  : 	Prof1RS = 175;
; 780  : 	Prof2RS = 25;
; 781  : 	Prof1Pair = FALSE;
; 782  : 	Prof2Pair = FALSE;
; 783  : 	Prof1NSTL = 0;
; 784  : 	Prof2NSTL = 1;
; 785  : 	C1AD1 = 600;
; 786  : 	C1AD2 = 150;
; 787  : 	C2AD = 400;
; 788  : 	C2BA = 500;
; 789  : 	Prof1SubMode = FireControlComputer::CCRP;
; 790  : 	Prof2SubMode = FireControlComputer::CCIP;
; 791  : 	Prof1Pair = FALSE;
; 792  : 	Prof2Pair = TRUE;
; 793  : 	Prof1 = FALSE; */
; 794  : 
; 795  : 	//MI
; 796  : 	BHOT = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 1

; 797  : 	GndJett = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], 0

; 798  : 	FEDS = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+14], 0

; 799  : 	DrawFEDS = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+15], 0

; 800  : 	Powered = FALSE;	//for Mav's

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 0

; 801  : 	if (g_bRealisticMavTime) MavCoolTimer = 180.0F; else MavCoolTimer = 5.0F;	//5 seconds cooling time (a guess) // JPG 06 Dec 03 - changed to 3 mins for mav. gyro spool up

	movzx	ecx, BYTE PTR ?g_bRealisticMavTime@@3_NA ; g_bRealisticMavTime
	test	ecx, ecx
	je	SHORT $LN28@SMSClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR [edx+20], xmm0
	jmp	SHORT $LN27@SMSClass
$LN28@SMSClass:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [eax+20], xmm0
$LN27@SMSClass:

; 802  : 	MavSubMode = PRE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 803  : 
; 804  : 	ShiAssert(weapCnt);
; 805  : 	
; 806  : 	for (i=0; i<=wtNone; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN26@SMSClass
$LN25@SMSClass:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN26@SMSClass:
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jg	SHORT $LN24@SMSClass

; 807  : 		numOnBoard[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+88], 0
	jmp	SHORT $LN25@SMSClass
$LN24@SMSClass:

; 808  : 	
; 809  : 	// Set up advanced hardpoint data
; 810  : 	vc = GetVehicleClassData(newOwnship->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _newOwnship$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	edx, ax
	sub	edx, 100				; 00000064H
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 811  : 	rackFlag = vc->RackFlags;

	mov	eax, DWORD PTR _vc$[ebp]
	movzx	ecx, WORD PTR [eax+60]
	mov	DWORD PTR _rackFlag$[ebp], ecx

; 812  : 	visFlag = vc->VisibleFlags;

	mov	edx, DWORD PTR _vc$[ebp]
	movzx	eax, WORD PTR [edx+62]
	mov	DWORD PTR _visFlag$[ebp], eax

; 813  : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN23@SMSClass
$LN22@SMSClass:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN23@SMSClass:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN21@SMSClass

; 814  : 	{
; 815  : 		if (hardPoint[i] && hardPoint[i]->weaponId && hardPoint[i]->weaponPointer)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	$LN5@SMSClass
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	test	edx, edx
	je	$LN5@SMSClass
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN5@SMSClass

; 816  : 		{
; 817  : 			wc = &WeaponDataTable[hardPoint[i]->weaponId];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	DWORD PTR _wc$[ebp], edx

; 818  : 			classPtr = &(Falcon4ClassTable[wc->Index]);

	mov	eax, DWORD PTR _wc$[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], ecx

; 819  : 			dataIndex = classPtr->vehicleDataIndex;

	mov	edx, DWORD PTR _classPtr$[ebp]
	movsx	eax, WORD PTR [edx+74]
	mov	DWORD PTR _dataIndex$[ebp], eax

; 820  : // 2002-03-21 MN catch data errors
; 821  : 			ShiAssert(wc);
; 822  : 			ShiAssert(classPtr);
; 823  : 
; 824  : 			
; 825  : 			//LRKLUDGE
; 826  : 			if ((classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_RECON &&
; 827  : 				classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_CAMERA))

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 7
	jne	SHORT $LN19@SMSClass
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 1
	jne	SHORT $LN19@SMSClass

; 828  : 			{
; 829  : 				dataIndex = Rpod_DEF;

	mov	DWORD PTR _dataIndex$[ebp], 57		; 00000039H
$LN19@SMSClass:

; 830  : 			}
; 831  : 			
; 832  : 			//			wpnDefinition = (SimWpnDefinition*)moverDefinitionData[dataIndex];
; 833  : 			wpnDefinition = &SimWeaponDataTable[classPtr->vehicleDataIndex];

	mov	ecx, DWORD PTR _classPtr$[ebp]
	movsx	edx, WORD PTR [ecx+74]
	imul	edx, 52					; 00000034H
	add	edx, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	DWORD PTR _wpnDefinition$[ebp], edx

; 834  : 			hardPoint[i]->SetWeaponClass((WeaponClass)wpnDefinition->weaponClass);

	mov	eax, DWORD PTR _wpnDefinition$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+172]
	call	eax

; 835  : 			hardPoint[i]->SetWeaponType((WeaponType)wpnDefinition->weaponType);

	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 836  : 			hardPoint[i]->GetWeaponData()->domain = (WeaponDomain)wpnDefinition->domain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx

; 837  : 			// edg kludge, look for durandal and set its drag to value
; 838  : 			// the weapon def files (at least for bombs) all seem to point
; 839  : 			// to the same thing -- mkxxx
; 840  : 			hardPoint[i]->GetWeaponData()->cd = wpnDefinition->cd;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 841  : 			if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BOMB )

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 2
	jne	$LN14@SMSClass

; 842  : 			{ 
; 843  : 				if ( classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_BOMB &&
; 844  : 					classPtr->vuClassData.classInfo_[VU_SPTYPE] == SPTYPE_DURANDAL)

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 1
	jne	SHORT $LN17@SMSClass
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 7
	jne	SHORT $LN17@SMSClass

; 845  : 				{
; 846  : 					hardPoint[i]->GetWeaponData()->cd = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+4], xmm0
	jmp	$LN14@SMSClass
$LN17@SMSClass:

; 847  : 				}
; 848  : 				// JB 010707 Why?? This makes the drag insignificant.  Make it configurable
; 849  : 				else if ( hardPoint[i]->GetWeaponData()->cd < 1.0f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN15@SMSClass

; 850  : 				{
; 851  : 					//hardPoint[i]->GetWeaponData()->cd *= 0.01f;
; 852  : 					hardPoint[i]->GetWeaponData()->cd *= 0.2f * g_fDragDilutionFactor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	add	eax, 4
	mov	DWORD PTR tv503[ebp], eax
	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR ?g_fDragDilutionFactor@@3MA
	mov	eax, DWORD PTR tv503[ebp]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv503[ebp]
	movss	DWORD PTR [ecx], xmm0

; 853  : 				}
; 854  : 				else

	jmp	SHORT $LN14@SMSClass
$LN15@SMSClass:

; 855  : 				{
; 856  : 					// if it's not a durandal and it's got a value >= 1
; 857  : 					// make it a a drag of 0.9 so that the bombclass doesn't
; 858  : 					// think it's a durandal. did I hear kludge?
; 859  : 					hardPoint[i]->GetWeaponData()->cd = 0.9f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [eax+4], xmm0
$LN14@SMSClass:

; 860  : 				}
; 861  : 			}
; 862  : 			
; 863  : 			//LRKLUDGE problem w/ AA7R's
; 864  : 			if ((classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_MISSILE &&
; 865  : 				classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_MISSILE_AIR_AIR &&
; 866  : 				classPtr->vuClassData.classInfo_[VU_SPTYPE] == SPTYPE_AA7R))

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 6
	jne	SHORT $LN13@SMSClass
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 1
	jne	SHORT $LN13@SMSClass
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN13@SMSClass

; 867  : 			{
; 868  : 				hardPoint[i]->SetWeaponType(wtAim120);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+160]
	call	eax
$LN13@SMSClass:

; 869  : 			}
; 870  : 			
; 871  : 			hardPoint[i]->GetWeaponData()->area = wpnDefinition->area;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+148]
	call	eax
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 872  : 			hardPoint[i]->GetWeaponData()->weight = wpnDefinition->weight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 873  : 			hardPoint[i]->GetWeaponData()->xEjection = wpnDefinition->xEjection;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 874  : 			hardPoint[i]->GetWeaponData()->yEjection = wpnDefinition->yEjection;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 875  : 			hardPoint[i]->GetWeaponData()->zEjection = wpnDefinition->zEjection;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 876  : 			hardPoint[i]->GetWeaponData()->flags = wpnDefinition->flags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 877  : 			
; 878  : 			// Set CBU flag appropriatly
; 879  : 			if (wc->Flags & WEAP_CLUSTER)

	mov	eax, DWORD PTR _wc$[ebp]
	movzx	ecx, WORD PTR [eax+10]
	and	ecx, 16					; 00000010H
	je	SHORT $LN12@SMSClass

; 880  : 				hardPoint[i]->GetWeaponData()->flags |= HasBurstHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR tv685[ebp], eax
	mov	ecx, DWORD PTR tv685[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 4
	mov	eax, DWORD PTR tv685[ebp]
	mov	DWORD PTR [eax], edx
$LN12@SMSClass:

; 881  : 			
; 882  : 			strcpy (hardPoint[i]->GetWeaponData()->mnemonic, wpnDefinition->mnemonic);

	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	add	eax, 28					; 0000001cH
	push	eax
	call	_strcpy
	add	esp, 8

; 883  : 			IncrementStores(hardPoint[i]->GetWeaponClass(), hardPoint[i]->weaponCount);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementStores@SMSClass@@QAEXW4WeaponClass@@H@Z ; SMSClass::IncrementStores

; 884  : 			gun = GetGun(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ; SMSBaseClass::GetGun
	mov	DWORD PTR _gun$[ebp], eax

; 885  : 			if (gun)

	cmp	DWORD PTR _gun$[ebp], 0
	je	$LN10@SMSClass

; 886  : 			{
; 887  : 				// Special stuff for guns
; 888  : 				SetFlag( GunOnBoard );

	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SMSBaseClass@@QAEXH@Z		; SMSBaseClass::SetFlag

; 889  : 				hardPoint[i]->SetGun(gun);

	mov	ecx, DWORD PTR _gun$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+180]
	call	eax

; 890  : 				hardPoint[i]->GetWeaponData()->xEjection = gun->initBulletVelocity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+148]
	call	eax
	mov	ecx, DWORD PTR _gun$[ebp]
	mov	edx, DWORD PTR [ecx+792]
	mov	DWORD PTR [eax+16], edx

; 891  : 				if (!g_bUseDefinedGunDomain) // 2002-04-17 ADDED BY S.G. Why fudge the weapon domain of guns instead of relying on what's in the data file?

	movzx	eax, BYTE PTR ?g_bUseDefinedGunDomain@@3_NA ; g_bUseDefinedGunDomain
	test	eax, eax
	jne	SHORT $LN10@SMSClass

; 892  : 					hardPoint[i]->GetWeaponData()->domain = gun->GetSMSDomain();

	mov	ecx, DWORD PTR _gun$[ebp]
	call	?GetSMSDomain@GunClass@@QAE?AW4WeaponDomain@@XZ ; GunClass::GetSMSDomain
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edi+148]
	call	eax
	mov	DWORD PTR [eax+40], esi
$LN10@SMSClass:

; 893  : 			} 
; 894  : 			
; 895  : 			// Setup rack data
; 896  : 			//if (rackFlag & (1 << i))
; 897  : 			{
; 898  : // 2002-03-24 MN Helicopter also create a SMS class, but don't have auxaerodata, so add a check for Airplane
; 899  : 				if ( ownship->IsAirplane() && ((AircraftClass*)ownship)->af && wc) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN9@SMSClass
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	DWORD PTR [edx+932], 0
	je	$LN9@SMSClass
	cmp	DWORD PTR _wc$[ebp], 0
	je	$LN9@SMSClass

; 900  : 				{ 
; 901  : 					hardPoint[i]->SetHPId(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	call	?SetHPId@BasicWeaponStation@@QAEXH@Z	; BasicWeaponStation::SetHPId

; 902  : 					hardPoint[i]->DetermineRackData(((AircraftClass*)ownship)->af->GetRackGroup(i), hardPoint[i]->weaponId, weapCnt[i] );

	mov	ecx, DWORD PTR _weapCnt$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetRackGroup@AirframeClass@@QAEHH@Z	; AirframeClass::GetRackGroup
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 903  : 
; 904  : 					// MLR 3/20/2004 - use loadorder rackdata 
; 905  : 					int *lo;
; 906  : 					if(lo=hardPoint[i]->GetLoadOrder())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+192]
	call	eax
	mov	DWORD PTR _lo$2[ebp], eax
	cmp	DWORD PTR _lo$2[ebp], 0
	je	SHORT $LN6@SMSClass

; 907  : 					{
; 908  : 						int l=0;

	mov	DWORD PTR _l$4[ebp], 0

; 909  : 						SimWeaponClass *weapPtr = hardPoint[i]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapPtr$3[ebp], eax
$LN7@SMSClass:

; 910  : 						while(weapPtr && l < hardPoint[i]->NumPoints())

	cmp	DWORD PTR _weapPtr$3[ebp], 0
	je	SHORT $LN6@SMSClass
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+44]
	call	eax
	cmp	DWORD PTR _l$4[ebp], eax
	jge	SHORT $LN6@SMSClass

; 911  : 						{
; 912  : 							weapPtr->SetRackSlot(lo[l]);

	mov	ecx, DWORD PTR _l$4[ebp]
	mov	edx, DWORD PTR _lo$2[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _weapPtr$3[ebp]
	call	?SetRackSlot@SimWeaponClass@@QAEXH@Z	; SimWeaponClass::SetRackSlot

; 913  : 							l++;

	mov	ecx, DWORD PTR _l$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$4[ebp], ecx

; 914  : 							weapPtr=weapPtr->GetNextOnRail();

	mov	ecx, DWORD PTR _weapPtr$3[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapPtr$3[ebp], eax

; 915  : 						}

	jmp	SHORT $LN7@SMSClass
$LN6@SMSClass:

; 916  : 					}
; 917  : 				}
; 918  : 				else 

	jmp	SHORT $LN5@SMSClass
$LN9@SMSClass:

; 919  : 				{
; 920  : 					SetupHardpointImage(hardPoint[i], weapCnt[i]);

	mov	edx, DWORD PTR _weapCnt$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupHardpointImage@SMSClass@@IAEXPAVBasicWeaponStation@@H@Z ; SMSClass::SetupHardpointImage
$LN5@SMSClass:

; 921  : 				}
; 922  : 			}
; 923  : 		}
; 924  : 	}

	jmp	$LN22@SMSClass
$LN21@SMSClass:

; 925  : 
; 926  : 	// Check for HARM, LGB, ECM
; 927  : 	if (numOnBoard[wcHARMWpn] > 0)

	mov	edx, 4
	imul	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+88], 0
	jle	SHORT $LN4@SMSClass

; 928  : 	{
; 929  : 		SetFlag (HTSOnBoard);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SMSBaseClass@@QAEXH@Z		; SMSBaseClass::SetFlag
$LN4@SMSClass:

; 930  : 	}
; 931  : 	
; 932  : 	if (numOnBoard[wcGbuWpn] > 0)

	mov	ecx, 4
	imul	ecx, 9
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+88], 0
	jle	SHORT $LN3@SMSClass

; 933  : 	{
; 934  : 		SetFlag (LGBOnBoard);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SMSBaseClass@@QAEXH@Z		; SMSBaseClass::SetFlag
$LN3@SMSClass:

; 935  : 	}
; 936  : 	
; 937  : // 2000-11-17 MODIFIED BY S.G. SO INTERNAL ECMS ARE ACCOUNTING FOR
; 938  : //	if (numOnBoard[wcECM] > 0)
; 939  : 	if (numOnBoard[wcECM] > 0 || vc->Flags & VEH_HAS_JAMMER)

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+88], 0
	jg	SHORT $LN1@SMSClass
	mov	edx, DWORD PTR _vc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 65536				; 00010000H
	je	SHORT $LN2@SMSClass
$LN1@SMSClass:

; 940  : 	{
; 941  : 		SetFlag (SPJamOnBoard);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SMSBaseClass@@QAEXH@Z		; SMSBaseClass::SetFlag
$LN2@SMSClass:

; 942  : 	}
; 943  : 	JDAMPowered = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+28], 0

; 944  : 	JDAMInitTimer = 10.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [edx+32], xmm0

; 945  : 	JDAMtargeting = SMSBaseClass::PB; // 0 = PB, 1 = TOO

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 946  : 
; 947  : 	HARMPowered = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+60], 0

; 948  : 	HARMInitTimer = 2.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [edx+64], xmm0

; 949  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SMSBaseClass@@UAE@XZ			; SMSBaseClass::~SMSBaseClass
__unwindfunclet$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z ENDP	; SMSClass::SMSClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv134 = -8						; size = 4
tv65 = -4						; size = 4
_hp$ = 8						; size = 4
_count$ = 12						; size = 4
?SetupHardpointImage@SMSClass@@IAEXPAVBasicWeaponStation@@H@Z PROC ; SMSClass::SetupHardpointImage
; _this$ = ecx

; 963  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 	ShiAssert(hp);
; 965  : 	if (!hp)

	cmp	DWORD PTR _hp$[ebp], 0
	jne	SHORT $LN9@SetupHardp

; 966  : 		return;

	jmp	$LN10@SetupHardp
$LN9@SetupHardp:

; 967  : 
; 968  : 	// RV - Biker - Hardcode chopper racks for now
; 969  : 
; 970  : 	// Find the proper rack id && max points
; 971  : 	//if (hp->GetWeaponClass() == wcRocketWpn)
; 972  : 	//{
; 973  : 	//	// The rack id should have already been set up in SMSBaseClass
; 974  : 	//	hp->SetupPoints(1);
; 975  : 	//}
; 976  : 	//else if (count == 1)
; 977  : 	//{
; 978  : 	//	if(hp->GetWeaponClass() == wcAimWpn)
; 979  : 	//	{
; 980  : 	//		hp->SetupPoints(1);
; 981  : 	//		hp->SetRackId(gRackId_Single_AA_Rack);
; 982  : 	//	}
; 983  : 	//	else
; 984  : 	//	{
; 985  : 	//		hp->SetupPoints(1);
; 986  : 	//		hp->SetRackId(gRackId_Single_Rack);
; 987  : 	//	}
; 988  : 	//}
; 989  : 	//else if (count <= 2 && hp->GetWeaponClass() == wcAimWpn)
; 990  : 	//{
; 991  : 	//	hp->SetupPoints(2);
; 992  : 	//	hp->SetRackId(gRackId_Two_Rack);
; 993  : 	//}
; 994  : 	//else if (count <= 3)
; 995  : 	//{
; 996  : 	//	if(hp->GetWeaponClass() == wcAgmWpn)
; 997  : 	//	{
; 998  : 	//		hp->SetupPoints(3);
; 999  : 	//		hp->SetRackId(gRackId_Mav_Rack);
; 1000 : 	//	}
; 1001 : 	//	else
; 1002 : 	//	{
; 1003 : 	//		hp->SetupPoints(3);
; 1004 : 	//		hp->SetRackId(gRackId_Triple_Rack);
; 1005 : 	//	}
; 1006 : 	//}
; 1007 : 	//else if (count <= 4)
; 1008 : 	//{
; 1009 : 	//	hp->SetupPoints(4);
; 1010 : 	//	hp->SetRackId(gRackId_Quad_Rack);
; 1011 : 	//}
; 1012 : 	//else
; 1013 : 	//{
; 1014 : 	//	hp->SetupPoints(6);
; 1015 : 	//	hp->SetRackId(gRackId_Six_Rack);
; 1016 : 	//}
; 1017 : 
; 1018 : 	// RV - Biker - Without data adjustment this will cause CTD
; 1019 : 	switch(count) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 4
	ja	$LN1@SetupHardp
	mov	ecx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN14@SetupHardp[ecx*4]
$LN6@SetupHardp:

; 1020 : 		case 0:
; 1021 : 			break;

	jmp	$LN10@SetupHardp
$LN5@SetupHardp:

; 1022 : 		case 1:
; 1023 : 			hp->SetupPoints(1);

	push	1
	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx

; 1024 : 			hp->SetRackId(747);

	push	747					; 000002ebH
	mov	eax, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax

; 1025 : 			break;

	jmp	$LN10@SetupHardp
$LN4@SetupHardp:

; 1026 : 		case 2:
; 1027 : 			hp->SetupPoints(2);

	push	2
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax

; 1028 : 			hp->SetRackId(746);

	push	746					; 000002eaH
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax

; 1029 : 			break;

	jmp	$LN10@SetupHardp
$LN3@SetupHardp:

; 1030 : 		case 3:
; 1031 : 			hp->SetupPoints(3);

	push	3
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax

; 1032 : 			hp->SetRackId(745);

	push	745					; 000002e9H
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax

; 1033 : 			break;

	jmp	SHORT $LN10@SetupHardp
$LN2@SetupHardp:

; 1034 : 		case 4:
; 1035 : 			hp->SetupPoints(4);

	push	4
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax

; 1036 : 			hp->SetRackId(745);

	push	745					; 000002e9H
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax

; 1037 : 			break;

	jmp	SHORT $LN10@SetupHardp
$LN1@SetupHardp:

; 1038 : 		default:
; 1039 : 			hp->SetupPoints(min(count, 4));

	cmp	DWORD PTR _count$[ebp], 4
	jge	SHORT $LN12@SetupHardp
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	jmp	SHORT $LN13@SetupHardp
$LN12@SetupHardp:
	mov	DWORD PTR tv134[ebp], 4
$LN13@SetupHardp:
	mov	edx, DWORD PTR tv134[ebp]
	push	edx
	mov	eax, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax

; 1040 : 			hp->SetRackId(745);

	push	745					; 000002e9H
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
$LN10@SetupHardp:

; 1041 : 			break;
; 1042 : 	}
; 1043 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN14@SetupHardp:
	DD	$LN6@SetupHardp
	DD	$LN5@SetupHardp
	DD	$LN4@SetupHardp
	DD	$LN3@SetupHardp
	DD	$LN2@SetupHardp
?SetupHardpointImage@SMSClass@@IAEXPAVBasicWeaponStation@@H@Z ENDP ; SMSClass::SetupHardpointImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv969 = -196						; size = 4
tv1194 = -192						; size = 4
$T2 = -188						; size = 4
tv975 = -184						; size = 4
$T3 = -180						; size = 4
$T4 = -176						; size = 4
$T5 = -172						; size = 4
tv994 = -168						; size = 4
$T6 = -164						; size = 4
tv987 = -160						; size = 4
$T7 = -156						; size = 4
tv980 = -152						; size = 4
$T8 = -148						; size = 4
$T9 = -144						; size = 4
$T10 = -140						; size = 4
$T11 = -136						; size = 4
tv326 = -132						; size = 4
tv447 = -128						; size = 4
_jettweapon$12 = -124					; size = 4
tv556 = -120						; size = 4
tv861 = -116						; size = 4
tv334 = -112						; size = 4
$T13 = -108						; size = 4
_center$14 = -104					; size = 4
tv318 = -100						; size = 4
$T15 = -96						; size = 4
$T16 = -92						; size = 4
tv620 = -88						; size = 4
tv729 = -84						; size = 4
_jettrack$17 = -80					; size = 4
_jettpylon$18 = -76					; size = 4
_rack$19 = -72						; size = 4
_pylon$20 = -68						; size = 4
_bsp$21 = -64						; size = 4
_weapptr$22 = -60					; size = 4
_rdflags$23 = -56					; size = 4
_tempPtr$ = -52						; size = 4
_weapPtr$ = -48						; size = 4
_this$ = -44						; size = 4
_pos$24 = -40						; size = 12
_vec$25 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_stationNum$ = 8					; size = 4
_mode$ = 12						; size = 4
?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z PROC	; SMSClass::JettisonStation
; _this$ = ecx

; 3089 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3090 : 	VuBin<SimWeaponClass> tempPtr, weapPtr;

	push	0
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3091 : 	
; 3092 : 	// only works for valid stations with positive G's on a local machine
; 3093 : 	if (stationNum < 1) // MLR 3/2/2004 - changed from 0 - which is the gun

	cmp	DWORD PTR _stationNum$[ebp], 1
	jge	SHORT $LN30@JettisonSt

; 3094 : 	{
; 3095 : 		return 0;

	mov	DWORD PTR $T9[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN31@JettisonSt
$LN30@JettisonSt:

; 3096 : 	}
; 3097 : 
; 3098 : 	//MI
; 3099 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN29@JettisonSt

; 3100 : 	{
; 3101 : 		if ((ownship->IsLocal ()) && (((AircraftClass*)ownship)->af->nzcgb <= 0.0F))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@JettisonSt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+1192]
	jb	SHORT $LN28@JettisonSt

; 3102 : 		{
; 3103 : 			return 0;

	mov	DWORD PTR $T2[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN31@JettisonSt
$LN28@JettisonSt:

; 3104 : 		}
; 3105 : 	}
; 3106 : 	else

	jmp	$LN20@JettisonSt
$LN29@JettisonSt:

; 3107 : 	{
; 3108 : 		if(ownship->IsLocal() && !ownship->OnGround()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@JettisonSt
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN20@JettisonSt

; 3109 : 			// RV - Biker - Only allow jettison when in plane flight
; 3110 : 			if (mode != RippedOff) {

	cmp	DWORD PTR _mode$[ebp], 32		; 00000020H
	je	$LN20@JettisonSt

; 3111 : 				if (fabs(ownship->Roll()) > 35.0f*DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv969[ebp]
	movss	xmm0, DWORD PTR tv969[ebp]
	comiss	xmm0, DWORD PTR __real@3f1c61a9
	jbe	SHORT $LN24@JettisonSt

; 3112 : 					return 0;

	mov	DWORD PTR $T11[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T11[ebp]
	jmp	$LN31@JettisonSt
$LN24@JettisonSt:

; 3113 : 				
; 3114 : 				if (((AircraftClass*)ownship)->Pitch() > 45.0f*DTR || ((AircraftClass*)ownship)->Pitch() < -60.0f*DTR)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv975[ebp]
	movss	xmm0, DWORD PTR tv975[ebp]
	comiss	xmm0, DWORD PTR __real@3f490fd9
	ja	SHORT $LN22@JettisonSt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv980[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	comiss	xmm0, DWORD PTR tv980[ebp]
	jbe	SHORT $LN23@JettisonSt
$LN22@JettisonSt:

; 3115 : 					return 0;

	mov	DWORD PTR $T4[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN31@JettisonSt
$LN23@JettisonSt:

; 3116 : 				
; 3117 : 				if (((AircraftClass*)ownship)->af->MaxVcas()/1.5f > ((AircraftClass*)ownship)->GetVt())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv987[ebp]
	movss	xmm0, DWORD PTR tv987[ebp]
	divss	xmm0, DWORD PTR __real@3fc00000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	movss	DWORD PTR tv1194[ebp], xmm0
	call	edx
	fstp	DWORD PTR tv994[ebp]
	movss	xmm0, DWORD PTR tv1194[ebp]
	comiss	xmm0, DWORD PTR tv994[ebp]
	jbe	SHORT $LN21@JettisonSt

; 3118 : 					return 0;

	mov	DWORD PTR $T10[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T10[ebp]
	jmp	$LN31@JettisonSt
$LN21@JettisonSt:

; 3119 : 
; 3120 : 				if(((AircraftClass*)ownship)->af->nzcgb < 0.5F || ((AircraftClass*)ownship)->af->nzcgb > 5.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [edx+1192]
	ja	SHORT $LN19@JettisonSt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1192]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	SHORT $LN20@JettisonSt
$LN19@JettisonSt:

; 3121 : 					return 0;

	mov	DWORD PTR $T8[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN31@JettisonSt
$LN20@JettisonSt:

; 3122 : 			}
; 3123 : 		}
; 3124 : 	}
; 3125 : 	
; 3126 : 	if (hardPoint[stationNum]->weaponPointer || hardPoint[stationNum]->GetRack())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@JettisonSt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+116]
	call	eax
	test	eax, eax
	je	$LN1@JettisonSt
$LN17@JettisonSt:

; 3127 : 	{
; 3128 : 		SimWeaponClass *weapptr;
; 3129 : 		Tpoint pos ,vec;
; 3130 : 		int rdflags = hardPoint[stationNum]->GetRackDataFlags();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+104]
	call	eax
	mov	DWORD PTR _rdflags$23[ebp], eax

; 3131 : 
; 3132 : 		int jettpylon = ( (rdflags & RDF_EMERGENCY_JETT_PYLON) && (mode == Emergency) ) ||
; 3133 : 			            ( (rdflags & RDF_SELECTIVE_JETT_PYLON) && (mode == SelectivePylon) );

	mov	ecx, DWORD PTR _rdflags$23[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN33@JettisonSt
	cmp	DWORD PTR _mode$[ebp], 2
	je	SHORT $LN35@JettisonSt
$LN33@JettisonSt:
	mov	edx, DWORD PTR _rdflags$23[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN34@JettisonSt
	cmp	DWORD PTR _mode$[ebp], 28		; 0000001cH
	je	SHORT $LN35@JettisonSt
$LN34@JettisonSt:
	mov	DWORD PTR tv318[ebp], 0
	jmp	SHORT $LN36@JettisonSt
$LN35@JettisonSt:
	mov	DWORD PTR tv318[ebp], 1
$LN36@JettisonSt:
	mov	eax, DWORD PTR tv318[ebp]
	mov	DWORD PTR _jettpylon$18[ebp], eax

; 3134 : 
; 3135 : 		int jettrack  = jettpylon ||
; 3136 : 						( (rdflags & RDF_EMERGENCY_JETT_RACK) && (mode == Emergency) ) ||
; 3137 : 			            ( (rdflags & RDF_SELECTIVE_JETT_RACK) && (mode == SelectiveRack) );

	cmp	DWORD PTR _jettpylon$18[ebp], 0
	jne	SHORT $LN38@JettisonSt
	mov	ecx, DWORD PTR _rdflags$23[ebp]
	and	ecx, 8
	je	SHORT $LN37@JettisonSt
	cmp	DWORD PTR _mode$[ebp], 2
	je	SHORT $LN38@JettisonSt
$LN37@JettisonSt:
	mov	edx, DWORD PTR _rdflags$23[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN39@JettisonSt
	cmp	DWORD PTR _mode$[ebp], 12		; 0000000cH
	je	SHORT $LN38@JettisonSt
$LN39@JettisonSt:
	mov	DWORD PTR tv326[ebp], 0
	jmp	SHORT $LN40@JettisonSt
$LN38@JettisonSt:
	mov	DWORD PTR tv326[ebp], 1
$LN40@JettisonSt:
	mov	eax, DWORD PTR tv326[ebp]
	mov	DWORD PTR _jettrack$17[ebp], eax

; 3138 : 
; 3139 : 		int jettweapon = jettrack ||
; 3140 : 						( (rdflags & RDF_EMERGENCY_JETT_WEAPON) && (mode == Emergency) ) ||
; 3141 : 			            ( (rdflags & RDF_SELECTIVE_JETT_WEAPON) && (mode == SelectiveWeapon) );

	cmp	DWORD PTR _jettrack$17[ebp], 0
	jne	SHORT $LN42@JettisonSt
	mov	ecx, DWORD PTR _rdflags$23[ebp]
	and	ecx, 2
	je	SHORT $LN41@JettisonSt
	cmp	DWORD PTR _mode$[ebp], 2
	je	SHORT $LN42@JettisonSt
$LN41@JettisonSt:
	mov	edx, DWORD PTR _rdflags$23[ebp]
	and	edx, 4
	je	SHORT $LN43@JettisonSt
	cmp	DWORD PTR _mode$[ebp], 4
	je	SHORT $LN42@JettisonSt
$LN43@JettisonSt:
	mov	DWORD PTR tv334[ebp], 0
	jmp	SHORT $LN44@JettisonSt
$LN42@JettisonSt:
	mov	DWORD PTR tv334[ebp], 1
$LN44@JettisonSt:
	mov	eax, DWORD PTR tv334[ebp]
	mov	DWORD PTR _jettweapon$12[ebp], eax

; 3142 : 
; 3143 : 		MonoPrint("JettisonStation(%d,%d) : rdflags=%8x  jettpylon=%d  jettrack=%d jettweapon=%d",
; 3144 : 			stationNum, mode, rdflags, jettpylon, jettrack, jettweapon);

	mov	ecx, DWORD PTR _jettweapon$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _jettrack$17[ebp]
	push	edx
	mov	eax, DWORD PTR _jettpylon$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _rdflags$23[ebp]
	push	ecx
	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	mov	eax, DWORD PTR _stationNum$[ebp]
	push	eax
	push	OFFSET ??_C@_0EO@GEPHIEMC@JettisonStation?$CI?$CFd?0?$CFd?$CJ?5?3?5rdflags@
	call	_MonoPrint
	add	esp, 28					; 0000001cH

; 3145 : 
; 3146 : 
; 3147 : 
; 3148 : 		
; 3149 : 	    if( jettweapon )

	cmp	DWORD PTR _jettweapon$12[ebp], 0
	je	$LN16@JettisonSt

; 3150 : 		{
; 3151 : 			weapptr=hardPoint[stationNum]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weapptr$22[ebp], eax
$LN15@JettisonSt:

; 3152 : 			while(weapptr)

	cmp	DWORD PTR _weapptr$22[ebp], 0
	je	$LN14@JettisonSt

; 3153 : 			{
; 3154 : 				//RemoveStore(stationNum, hardPoint[stationNum]->weaponId);
; 3155 : 				// remove the BSP
; 3156 : 				DrawableBSP *bsp;
; 3157 : 				bsp=(DrawableBSP *)weapptr->drawPointer;

	mov	ecx, DWORD PTR _weapptr$22[ebp]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR _bsp$21[ebp], edx

; 3158 : 
; 3159 : 				hardPoint[stationNum]->DetachWeaponBSP(weapptr);

	mov	eax, DWORD PTR _weapptr$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+88]
	call	eax

; 3160 : 
; 3161 : 				
; 3162 : 
; 3163 : 				weapptr->drawPointer=NULL;

	mov	ecx, DWORD PTR _weapptr$22[ebp]
	mov	DWORD PTR [ecx+332], 0

; 3164 : 				if(bsp)

	cmp	DWORD PTR _bsp$21[ebp], 0
	je	$LN13@JettisonSt

; 3165 : 				{
; 3166 : 					bsp->GetPosition( &pos );

	lea	edx, DWORD PTR _pos$24[ebp]
	push	edx
	mov	ecx, DWORD PTR _bsp$21[ebp]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 3167 : 
; 3168 : 					/*
; 3169 : 					pos.x = ownship->XPos() + ownship->dmx[0][0]*lpos.x + ownship->dmx[1][0]*lpos.y + ownship->dmx[2][0]*lpos.z;
; 3170 : 					pos.y = ownship->YPos() + ownship->dmx[0][1]*lpos.x + ownship->dmx[1][1]*lpos.y + ownship->dmx[2][1]*lpos.z;
; 3171 : 					pos.z = ownship->ZPos() + ownship->dmx[0][2]*lpos.x + ownship->dmx[1][2]*lpos.y + ownship->dmx[2][2]*lpos.z;
; 3172 : 					*/
; 3173 : 
; 3174 : 					vec.x = ownship->XDelta();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR _vec$25[ebp]

; 3175 : 					vec.y = ownship->YDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR _vec$25[ebp+4]

; 3176 : 					vec.z = ownship->ZDelta();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR _vec$25[ebp+8]

; 3177 : 					
; 3178 : 					// Create and add the "SFX" container
; 3179 : 					bsp->SetLabel ("", 0xff00ff00);

	push	-16711936				; ff00ff00H
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _bsp$21[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _bsp$21[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 3180 : 					OTWDriver.AddSfxRequest( new SfxClass (
; 3181 : 						SFX_MOVING_BSP,				// type
; 3182 : 						&pos,						// world pos
; 3183 : 						&vec,						// vector
; 3184 : 						bsp,						// BSP
; 3185 : 						30.0f,						// time to live
; 3186 : 						1.0f ) );					// scale

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN45@JettisonSt
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _bsp$21[ebp]
	push	ecx
	lea	edx, DWORD PTR _vec$25[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$24[ebp]
	push	eax
	push	33					; 00000021H
	mov	ecx, DWORD PTR $T15[ebp]
	call	??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z ; SfxClass::SfxClass
	mov	DWORD PTR tv447[ebp], eax
	jmp	SHORT $LN46@JettisonSt
$LN45@JettisonSt:
	mov	DWORD PTR tv447[ebp], 0
$LN46@JettisonSt:
	mov	ecx, DWORD PTR tv447[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest
$LN13@JettisonSt:

; 3187 : 				}
; 3188 : 				weapptr=weapptr->GetNextOnRail();

	mov	ecx, DWORD PTR _weapptr$22[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weapptr$22[ebp], eax

; 3189 : 			}

	jmp	$LN15@JettisonSt
$LN14@JettisonSt:

; 3190 : 
; 3191 : 			// If it's  fuel tank and it has anything in it, remove it
; 3192 : 			if (hardPoint[stationNum]->GetWeaponClass() == wcTank && ownship->IsAirplane())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN8@JettisonSt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	SHORT $LN8@JettisonSt

; 3193 : 			{
; 3194 : 				//			float lostFuel = ((AircraftClass*)ownship)->af->ExternalFuel() / numOnBoard[hardPoint[stationNum]->GetWeaponClass()];
; 3195 : 				// JPO redo with ne fuel stuff
; 3196 : 				int center = (numHardpoints - 1) / 2 + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	mov	DWORD PTR _center$14[ebp], eax

; 3197 : 				if (stationNum < center)

	mov	ecx, DWORD PTR _stationNum$[ebp]
	cmp	ecx, DWORD PTR _center$14[ebp]
	jge	SHORT $LN11@JettisonSt

; 3198 : 					((AircraftClass*)ownship)->af->DropTank(AirframeClass::TANK_LEXT); // XXX DROP

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?DropTank@AirframeClass@@QAEXH@Z	; AirframeClass::DropTank
	jmp	SHORT $LN8@JettisonSt
$LN11@JettisonSt:

; 3199 : 				else if (stationNum > center)

	mov	ecx, DWORD PTR _stationNum$[ebp]
	cmp	ecx, DWORD PTR _center$14[ebp]
	jle	SHORT $LN9@JettisonSt

; 3200 : 					((AircraftClass*)ownship)->af->DropTank(AirframeClass::TANK_REXT); // XXX DROP

	push	6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?DropTank@AirframeClass@@QAEXH@Z	; AirframeClass::DropTank
	jmp	SHORT $LN8@JettisonSt
$LN9@JettisonSt:

; 3201 : 				else ((AircraftClass*)ownship)->af->DropTank(AirframeClass::TANK_CLINE); // XXX DROP

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?DropTank@AirframeClass@@QAEXH@Z	; AirframeClass::DropTank
$LN8@JettisonSt:

; 3202 : 				
; 3203 : 				//			((AircraftClass*)ownship)->af->AddExternalFuel (-lostFuel);
; 3204 : 			}
; 3205 : 			
; 3206 : 			// Iterate all the weapons on this station and clean them up
; 3207 : 			weapPtr = hardPoint[stationNum]->weaponPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
$LN7@JettisonSt:

; 3208 : 			while (weapPtr)

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@JettisonSt

; 3209 : 			{
; 3210 : 				if(FalconLocalGame->GetGameType() != game_InstantAction){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN47@JettisonSt
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv556[ebp], eax
	jmp	SHORT $LN48@JettisonSt
$LN47@JettisonSt:
	mov	DWORD PTR tv556[ebp], 0
$LN48@JettisonSt:
	mov	ecx, DWORD PTR tv556[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	je	SHORT $LN5@JettisonSt

; 3211 : 					tempPtr.reset(weapPtr->GetNextOnRail());

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	push	eax
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset
$LN5@JettisonSt:

; 3212 : 				}
; 3213 : 				RemoveStore(stationNum, hardPoint[stationNum]->weaponId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _stationNum$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 3214 : 				weapPtr = tempPtr;

	lea	eax, DWORD PTR _tempPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 3215 : 			}

	jmp	$LN7@JettisonSt
$LN6@JettisonSt:

; 3216 : 			hardPoint[stationNum]->weaponPointer.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 3217 : 			numOnBoard[hardPoint[stationNum]->GetWeaponClass()] -= hardPoint[stationNum]->weaponCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+88]
	mov	DWORD PTR tv620[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+10]
	mov	edx, DWORD PTR tv620[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR tv620[ebp]
	mov	DWORD PTR [ecx], eax

; 3218 : 			hardPoint[stationNum]->weaponCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	xor	eax, eax
	mov	WORD PTR [edx+10], ax
$LN16@JettisonSt:

; 3219 : 
; 3220 : 		}
; 3221 : 
; 3222 : 		if( jettrack )

	cmp	DWORD PTR _jettrack$17[ebp], 0
	je	$LN3@JettisonSt

; 3223 : 		{
; 3224 : 			DrawableBSP *rack = hardPoint[stationNum]->DetachRackBSP();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _stationNum$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+68]
	call	eax
	mov	DWORD PTR _rack$19[ebp], eax

; 3225 : 			if(rack)

	cmp	DWORD PTR _rack$19[ebp], 0
	je	$LN3@JettisonSt

; 3226 : 			{
; 3227 : 				rack->GetPosition( &pos );

	lea	ecx, DWORD PTR _pos$24[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rack$19[ebp]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 3228 : 
; 3229 : 				RemoveStore(stationNum, hardPoint[stationNum]->GetRackId());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _stationNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 3230 : 
; 3231 : 				vec.x = ownship->XDelta();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR _vec$25[ebp]

; 3232 : 				vec.y = ownship->YDelta();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR _vec$25[ebp+4]

; 3233 : 				vec.z = ownship->ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR _vec$25[ebp+8]

; 3234 : 				
; 3235 : 				// Create and add the "SFX" container
; 3236 : 				rack->SetLabel ("", 0xff00ff00);

	push	-16711936				; ff00ff00H
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _rack$19[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _rack$19[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3237 : 				OTWDriver.AddSfxRequest( new SfxClass (
; 3238 : 					SFX_MOVING_BSP,				// type
; 3239 : 					&pos,						// world pos
; 3240 : 					&vec,						// vector
; 3241 : 					rack,		// BSP
; 3242 : 					30.0f,						// time to live
; 3243 : 					1.0f ) );					// scale

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN49@JettisonSt
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _rack$19[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$25[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$24[ebp]
	push	edx
	push	33					; 00000021H
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z ; SfxClass::SfxClass
	mov	DWORD PTR tv729[ebp], eax
	jmp	SHORT $LN50@JettisonSt
$LN49@JettisonSt:
	mov	DWORD PTR tv729[ebp], 0
$LN50@JettisonSt:
	mov	eax, DWORD PTR tv729[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest
$LN3@JettisonSt:

; 3244 : 			}
; 3245 : 		}
; 3246 : 
; 3247 : 		if( jettpylon )

	cmp	DWORD PTR _jettpylon$18[ebp], 0
	je	$LN1@JettisonSt

; 3248 : 		{
; 3249 : 			DrawableBSP *pylon = hardPoint[stationNum]->DetachPylonBSP();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	DWORD PTR _pylon$20[ebp], eax

; 3250 : 			if(pylon)

	cmp	DWORD PTR _pylon$20[ebp], 0
	je	$LN1@JettisonSt

; 3251 : 			{
; 3252 : 				pylon->GetPosition( &pos );

	lea	ecx, DWORD PTR _pos$24[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pylon$20[ebp]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 3253 : 
; 3254 : 				RemoveStore(stationNum, hardPoint[stationNum]->GetPylonId());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+140]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _stationNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveStore@SMSClass@@QAEXHH@Z		; SMSClass::RemoveStore

; 3255 : 
; 3256 : 				vec.x = ownship->XDelta();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR _vec$25[ebp]

; 3257 : 				vec.y = ownship->YDelta();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR _vec$25[ebp+4]

; 3258 : 				vec.z = ownship->ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR _vec$25[ebp+8]

; 3259 : 				
; 3260 : 				// Create and add the "SFX" container
; 3261 : 				pylon->SetLabel ("", 0xff00ff00);

	push	-16711936				; ff00ff00H
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _pylon$20[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pylon$20[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3262 : 				OTWDriver.AddSfxRequest( new SfxClass (
; 3263 : 					SFX_MOVING_BSP,				// type
; 3264 : 					&pos,						// world pos
; 3265 : 					&vec,						// vector
; 3266 : 					pylon,		// BSP
; 3267 : 					30.0f,						// time to live
; 3268 : 					1.0f ) );					// scale

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN51@JettisonSt
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pylon$20[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$25[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$24[ebp]
	push	edx
	push	33					; 00000021H
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z ; SfxClass::SfxClass
	mov	DWORD PTR tv861[ebp], eax
	jmp	SHORT $LN52@JettisonSt
$LN51@JettisonSt:
	mov	DWORD PTR tv861[ebp], 0
$LN52@JettisonSt:
	mov	eax, DWORD PTR tv861[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest
$LN1@JettisonSt:

; 3269 : 			}
; 3270 : 		}
; 3271 : 
; 3272 : 		//if(ownship && !rippedOff)  // MLR 3/2/2004 - never used ???
; 3273 : 		//	ownship->SoundPos.Sfx( SFX_JETTISON, 0, 1, 0, pos.x, pos.y, pos.z);
; 3274 : 
; 3275 : 
; 3276 : 
; 3277 : 
; 3278 : 
; 3279 : #if 0
; 3280 : 		if (hardPoint[stationNum]->GetRack())
; 3281 : 		{
; 3282 : 			droppedThing = hardPoint[stationNum]->GetRack();
; 3283 : 			weapPtr = hardPoint[stationNum]->weaponPointer;
; 3284 : 			RemoveStore(stationNum, hardPoint[stationNum]->GetRackId());
; 3285 : 			hardPoint[stationNum]->SetRack(NULL);
; 3286 : 		}
; 3287 : 		else
; 3288 : 		{
; 3289 : 			droppedThing = (DrawableBSP *)hardPoint[stationNum]->weaponPointer->drawPointer;
; 3290 : 			hardPoint[stationNum]->weaponPointer->drawPointer = NULL;
; 3291 : 			weapPtr = NULL;
; 3292 : 			RemoveStore(stationNum, hardPoint[stationNum]->weaponId);
; 3293 : 		}
; 3294 : 		
; 3295 : 		if (droppedThing)
; 3296 : 		{
; 3297 : 			Tpoint pos, vec;
; 3298 : 			
; 3299 : 			// Detach the thing from the parent object
; 3300 : 			OTWDriver.DetachObject((DrawableBSP*)(ownship->drawPointer), (DrawableBSP*)droppedThing, stationNum - 1);
; 3301 : 			
; 3302 : 			// Get initial location and velocity for the "SFX" container
; 3303 : 			droppedThing->GetPosition( &pos );
; 3304 : 			vec.x = ownship->XDelta();
; 3305 : 			vec.y = ownship->YDelta();
; 3306 : 			vec.z = ownship->ZDelta();
; 3307 : 			
; 3308 : 			// Create and add the "SFX" container
; 3309 : 			droppedThing->SetLabel ("", 0xff00ff00);
; 3310 : 			OTWDriver.AddSfxRequest( new SfxClass (
; 3311 : 				SFX_MOVING_BSP,				// type
; 3312 : 				&pos,						// world pos
; 3313 : 				&vec,						// vector
; 3314 : 				droppedThing,				// BSP
; 3315 : 				30.0f,						// time to live
; 3316 : 				1.0f ) );					// scale
; 3317 : 			
; 3318 : 			// Play the jettison sound unless the thing is being ripped off, in which case it takes care of itself
; 3319 : 			if(!rippedOff)
; 3320 : 				if(ownship) ownship->SoundPos.Sfx( SFX_JETTISON, 0, 1, 0, pos.x, pos.y, pos.z);
; 3321 : 			
; 3322 : 			// If this was a rack, we will drop all its children seperatly to ensure proper cleanup.
; 3323 : 			// SCR:  It would be nice if this could be handled by a sub-class of SfxClass.
; 3324 : 			while (weapPtr) {
; 3325 : 				
; 3326 : 				// Get the child drawable (if any)
; 3327 : 				DrawableBSP	*child = (DrawableBSP*)weapPtr->drawPointer;
; 3328 : 				if (child) {
; 3329 : 					
; 3330 : 					// Detach the child from the parent rack
; 3331 : 					OTWDriver.DetachObject( droppedThing, child, weapPtr->GetRackSlot() );
; 3332 : 					weapPtr->drawPointer = NULL;
; 3333 : 					
; 3334 : 					// Get initial location for the "SFX" container
; 3335 : 					child->GetPosition( &pos );
; 3336 : 					
; 3337 : 					// Create and add the "SFX" container
; 3338 : 					droppedThing->SetLabel ("", 0xff00ff00);
; 3339 : 					OTWDriver.AddSfxRequest( new SfxClass (
; 3340 : 						SFX_MOVING_BSP,				// type
; 3341 : 						&pos,						// world pos
; 3342 : 						&vec,						// vector
; 3343 : 						child,						// BSP
; 3344 : 						30.0f,						// time to live
; 3345 : 						1.0f ) );					// scale
; 3346 : 				}
; 3347 : 				
; 3348 : 				// Get the next weapon
; 3349 : 				weapPtr = weapPtr->GetNextOnRail();
; 3350 : 			}
; 3351 : 		}
; 3352 : #endif
; 3353 : 	/*	
; 3354 : 		// If it's  fuel tank and it has anything in it, remove it
; 3355 : 		if (hardPoint[stationNum]->GetWeaponClass() == wcTank && ownship->IsAirplane())
; 3356 : 		{
; 3357 : //			float lostFuel = ((AircraftClass*)ownship)->af->ExternalFuel() / numOnBoard[hardPoint[stationNum]->GetWeaponClass()];
; 3358 : 		  // JPO redo with ne fuel stuff
; 3359 : 		    int center = (numHardpoints - 1) / 2 + 1;
; 3360 : 			if (stationNum < center)
; 3361 : 			    ((AircraftClass*)ownship)->af->DropTank(AirframeClass::TANK_LEXT); // XXX DROP
; 3362 : 			else if (stationNum > center)
; 3363 : 			    ((AircraftClass*)ownship)->af->DropTank(AirframeClass::TANK_REXT); // XXX DROP
; 3364 : 			else ((AircraftClass*)ownship)->af->DropTank(AirframeClass::TANK_CLINE); // XXX DROP
; 3365 : 
; 3366 : //			((AircraftClass*)ownship)->af->AddExternalFuel (-lostFuel);
; 3367 : 		}
; 3368 : 		
; 3369 : 		// Iterate all the weapons on this station and clean them up
; 3370 : 		weapPtr = hardPoint[stationNum]->weaponPointer;
; 3371 : 		tempPtr = NULL;
; 3372 : 		while (weapPtr)
; 3373 : 		{
; 3374 : 			ShiAssert( weapPtr->drawPointer == NULL );
; 3375 : 			if(FalconLocalGame->GetGameType() != game_InstantAction)
; 3376 : 				tempPtr = weapPtr->GetNextOnRail();
; 3377 : 			RemoveStore(stationNum, hardPoint[stationNum]->weaponId);
; 3378 : 			// 2002-02-08 ADDED BY S.G. Before we delete it, we must check if the drawable->thePrevMissile is pointing to it but NOT referenced so we can clear it as well otherwise it will CTD in UpdateGroundSpot
; 3379 : 			if (drawable && drawable->thePrevMissile && drawable->thePrevMissile == weapPtr && !drawable->thePrevMissileIsRef)
; 3380 : 				drawable->thePrevMissile = NULL; // Clear it as well
; 3381 : 			delete weapPtr;
; 3382 : 			//			vuAntiDB->Remove(weapPtr);
; 3383 : 			weapPtr = tempPtr;
; 3384 : 		}
; 3385 : 		hardPoint[stationNum]->weaponPointer = NULL;
; 3386 : 		numOnBoard[hardPoint[stationNum]->GetWeaponClass()] -= hardPoint[stationNum]->weaponCount;
; 3387 : 		hardPoint[stationNum]->weaponCount = 0;
; 3388 : 		*/
; 3389 : 	}
; 3390 : 	
; 3391 : 
; 3392 : 
; 3393 : 	{
; 3394 : 		ChooseLimiterMode(1); // (me1234 lets check airframe_g-limit after stores jettison)

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseLimiterMode@SMSClass@@QAEXH@Z	; SMSClass::ChooseLimiterMode

; 3395 : 	}
; 3396 : 	return 1;

	mov	DWORD PTR $T3[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	eax, DWORD PTR $T3[ebp]
$LN31@JettisonSt:

; 3397 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$0:
	lea	ecx, DWORD PTR _tempPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$1:
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$2:
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$3:
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z$4:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-192]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?JettisonStation@SMSClass@@IAEHHW4JettisonMode@@@Z ENDP	; SMSClass::JettisonStation
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_theMissile$ = -16					; size = 4
tv70 = -12						; size = 4
_laserPod$1 = -8					; size = 4
_this$ = -4						; size = 4
_newStation$ = 8					; size = 4
?ReleaseCurWeapon@SMSClass@@IAEXH@Z PROC		; SMSClass::ReleaseCurWeapon
; _this$ = ecx

; 2522 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2523 : 	MissileClass* theMissile;
; 2524 : 
; 2525 : 	if (curWeapon)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN8@ReleaseCur

; 2526 : 	{
; 2527 : 		switch (curWeaponType)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR tv70[ebp], edx
	cmp	DWORD PTR tv70[ebp], 3
	jl	SHORT $LN8@ReleaseCur
	cmp	DWORD PTR tv70[ebp], 4
	jle	SHORT $LN5@ReleaseCur
	cmp	DWORD PTR tv70[ebp], 7
	je	SHORT $LN3@ReleaseCur
	jmp	SHORT $LN8@ReleaseCur
$LN5@ReleaseCur:

; 2528 : 		{
; 2529 : 			case wtAgm65:
; 2530 : 			case wtAgm88:
; 2531 : 				theMissile = (MissileClass*)curWeapon.get();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _theMissile$[ebp], eax

; 2532 : 				if (theMissile->display){

	mov	eax, DWORD PTR _theMissile$[ebp]
	cmp	DWORD PTR [eax+712], 0
	je	SHORT $LN3@ReleaseCur

; 2533 : 					theMissile->display->DisplayExit();

	mov	ecx, DWORD PTR _theMissile$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	mov	eax, DWORD PTR _theMissile$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+712]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN3@ReleaseCur:

; 2534 : 				}
; 2535 : 			case wtGBU:
; 2536 : 			{
; 2537 : 				// MN blind shot from JPO - does this fix the LGB crash/hardlock ?
; 2538 : 				// MN commented back in - I think not performing the DisplayExit will result in memory leaks,
; 2539 : 				// as each missile seems to have its own display initialised
; 2540 : 				SensorClass* laserPod = FindLaserPod (ownship);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 2541 : 				if (laserPod){

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	SHORT $LN8@ReleaseCur

; 2542 : 					if (laserPod->GetDisplay()){

	mov	eax, DWORD PTR _laserPod$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _laserPod$1[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	test	eax, eax
	je	SHORT $LN8@ReleaseCur

; 2543 : 						laserPod->DisplayExit();

	mov	ecx, DWORD PTR _laserPod$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _laserPod$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN8@ReleaseCur:

; 2544 : 					}
; 2545 : 				}
; 2546 : 			}
; 2547 : 			break;
; 2548 : 		}
; 2549 : 	}
; 2550 : 	curHardpoint = newStation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newStation$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 2551 : 	curWpnNum = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], -1

; 2552 : 	curWeapon.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 2553 : 	curWeaponType = wtNone;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 11			; 0000000bH

; 2554 : 	curWeaponClass = wcNoWpn;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 11			; 0000000bH

; 2555 : 	curWeaponId   = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+168], ax

; 2556 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ReleaseCurWeapon@SMSClass@@IAEXH@Z ENDP		; SMSClass::ReleaseCurWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSMSBaseClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSMSBaseClass@@UAEPAXI@Z PROC			; SMSBaseClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SMSBaseClass@@UAE@XZ			; SMSBaseClass::~SMSBaseClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSMSBaseClass@@UAEPAXI@Z ENDP			; SMSBaseClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetHARMInitTimer@SMSBaseClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHARMInitTimer@SMSBaseClass@@QAEMXZ PROC		; SMSBaseClass::GetHARMInitTimer, COMDAT
; _this$ = ecx

; 126  : 	float GetHARMInitTimer(void) { return HARMInitTimer; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHARMInitTimer@SMSBaseClass@@QAEMXZ ENDP		; SMSBaseClass::GetHARMInitTimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetHARMPowerState@SMSBaseClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHARMPowerState@SMSBaseClass@@QAE_NXZ PROC		; SMSBaseClass::GetHARMPowerState, COMDAT
; _this$ = ecx

; 125  : 	bool GetHARMPowerState(void) { return HARMPowered; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ENDP		; SMSBaseClass::GetHARMPowerState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_playerAC$ = -16					; size = 4
_FCC$ = -12						; size = 4
_this$ = -8						; size = 4
_theRadar$ = -4						; size = 4
_init$ = 8						; size = 1
?StepMavSubMode@SMSBaseClass@@QAEX_N@Z PROC		; SMSBaseClass::StepMavSubMode
; _this$ = ecx

; 3765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3766 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3767 : 	RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 3768 : 	FireControlComputer	*FCC = ownship->GetFCC();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _FCC$[ebp], eax

; 3769 : 	if(!theRadar || !FCC)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN8@StepMavSub
	cmp	DWORD PTR _FCC$[ebp], 0
	jne	SHORT $LN9@StepMavSub
$LN8@StepMavSub:

; 3770 : 		return;

	jmp	$LN10@StepMavSub
$LN9@StepMavSub:

; 3771 : 
; 3772 : 	if(!FCC->PlayerFCC())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?PlayerFCC@FireControlComputer@@QAEHXZ	; FireControlComputer::PlayerFCC
	test	eax, eax
	jne	SHORT $LN7@StepMavSub

; 3773 : 		return; // MLR just in case

	jmp	$LN10@StepMavSub
$LN7@StepMavSub:

; 3774 : 
; 3775 : 	if(!g_bRealisticAvionics) // MLR 7/17/2004 - //Cobra 10/31/04 TJL

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN6@StepMavSub

; 3776 : 	{
; 3777 : 		MavSubMode = SMSBaseClass::PRE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 3778 : 		FCC->SetSubMode(FireControlComputer::SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 3779 : 		return; 

	jmp	$LN10@StepMavSub
$LN6@StepMavSub:

; 3780 : 	}
; 3781 : 
; 3782 : 	if(init)

	movzx	eax, BYTE PTR _init$[ebp]
	test	eax, eax
	je	SHORT $LN5@StepMavSub

; 3783 : 	{
; 3784 : 		MavSubMode = SMSBaseClass::PRE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 3785 : 		theRadar->SelectGM();

	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx

; 3786 : 		theRadar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir

; 3787 : 		FCC->SetSubMode(FireControlComputer::SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 3788 : 		return;

	jmp	$LN10@StepMavSub
$LN5@StepMavSub:

; 3789 : 	}
; 3790 : 	if(MavSubMode == SMSBaseClass::PRE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN4@StepMavSub

; 3791 : 	{
; 3792 : 		MavSubMode = SMSBaseClass::VIS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 1

; 3793 : 		theRadar->SelectAGR();

	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+244]
	call	edx

; 3794 : 		theRadar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir

; 3795 : 		FCC->SetSubMode(FireControlComputer::BSGT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
	jmp	SHORT $LN1@StepMavSub
$LN4@StepMavSub:

; 3796 : 	}
; 3797 : 	else if(MavSubMode == SMSBaseClass::VIS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN2@StepMavSub

; 3798 : 	{
; 3799 : 		MavSubMode = SMSBaseClass::BORE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 2

; 3800 : 		theRadar->SelectGM();

	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx

; 3801 : 		theRadar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir

; 3802 : 		FCC->SetSubMode(FireControlComputer::BSGT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 3803 : 	}
; 3804 : 	else

	jmp	SHORT $LN1@StepMavSub
$LN2@StepMavSub:

; 3805 : 	{
; 3806 : 		MavSubMode = SMSBaseClass::PRE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 3807 : 		theRadar->SelectGM();

	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax

; 3808 : 		theRadar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir

; 3809 : 		FCC->SetSubMode(FireControlComputer::SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN1@StepMavSub:
$LN10@StepMavSub:

; 3810 : 	}
; 3811 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StepMavSubMode@SMSBaseClass@@QAEX_N@Z ENDP		; SMSBaseClass::StepMavSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_bw$ = -80						; size = 4
_maxAlt$1 = -76						; size = 4
_minRange$2 = -72					; size = 4
_bhp$ = -68						; size = 4
_bs$ = -64						; size = 4
tv304 = -60						; size = 4
tv299 = -56						; size = 4
tv294 = -52						; size = 4
_wpnDefinition$3 = -48					; size = 4
tv193 = -44						; size = 4
tv185 = -40						; size = 4
tv159 = -36						; size = 4
tv128 = -32						; size = 4
_minAlt$4 = -28						; size = 4
_auxData$5 = -24					; size = 4
_classInfoPtr$6 = -20					; size = 4
_str$ = -16						; size = 4
_wrange$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_dam$ = 8						; size = 4
_mt$ = 12						; size = 4
_range_km$ = 16						; size = 4
_guns_only$ = 20					; size = 4
_alt_feet$ = 24						; size = 4
?SelectBestWeapon@SMSBaseClass@@QAEXPAEHHHH@Z PROC	; SMSBaseClass::SelectBestWeapon
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 	int	i,str;
; 487  : 	int bhp = -1;

	mov	DWORD PTR _bhp$[ebp], -1

; 488  : 	int bw = 0,bs = 0;

	mov	DWORD PTR _bw$[ebp], 0
	mov	DWORD PTR _bs$[ebp], 0

; 489  : 	int wrange;
; 490  : 	for (i=0; i<numHardpoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN33@SelectBest
$LN32@SelectBest:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN33@SelectBest:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	$LN31@SelectBest

; 491  : 		if (hardPoint[i] && hardPoint[i]->weaponId && hardPoint[i]->weaponCount){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	$LN1@SelectBest
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	test	ecx, ecx
	je	$LN1@SelectBest
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	je	$LN1@SelectBest

; 492  : 			if (range_km >= 0 && !((Unit)(ownship->GetCampaignObject()))->CanShootWeapon(hardPoint[i]->weaponId)){

	cmp	DWORD PTR _range_km$[ebp], 0
	jl	SHORT $LN29@SelectBest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv128[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR [edx+464]
	call	eax
	test	eax, eax
	jne	SHORT $LN29@SelectBest

; 493  : 				str = 0;

	mov	DWORD PTR _str$[ebp], 0
	jmp	$LN2@SelectBest
$LN29@SelectBest:

; 494  : 			} //JPO check 
; 495  : 			else if(guns_only && hardPoint[i]->weaponPointer && !hardPoint[i]->weaponPointer->IsGun()){

	cmp	DWORD PTR _guns_only$[ebp], 0
	je	SHORT $LN27@SelectBest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN27@SelectBest
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv159[ebp], eax
	mov	edx, DWORD PTR tv159[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv159[ebp]
	mov	edx, DWORD PTR [eax+168]
	call	edx
	test	eax, eax
	jne	SHORT $LN27@SelectBest

; 496  : 				str = 0;

	mov	DWORD PTR _str$[ebp], 0
	jmp	$LN2@SelectBest
$LN27@SelectBest:

; 497  : 			}
; 498  : 			else if(range_km >= 0){

	cmp	DWORD PTR _range_km$[ebp], 0
	jl	$LN25@SelectBest

; 499  : 				wrange = GetWeaponRange (hardPoint[i]->weaponId, mt );

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	push	edx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	mov	DWORD PTR _wrange$[ebp], eax

; 500  : 				if ( wrange > 2 ){

	cmp	DWORD PTR _wrange$[ebp], 2
	jle	$LN4@SelectBest

; 501  : 					// 2000-10-12 MODIFIED BY S.G. DIVIDER OF 11 INSTEAD IF IT'S A GUN. 
; 502  : 					// THAT WAY, RANGE * LowAirModifier MIGHT STILL SELECT THIS WEAPON IF THE RANGE IS 15 NM.
; 503  : 					//if ( range_km < min(wrange/4, 2) || range_km > wrange )
; 504  : 					//	continue;
; 505  : 					if (hardPoint[i]->weaponPointer->IsGun()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv185[ebp], eax
	mov	eax, DWORD PTR tv185[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv185[ebp]
	mov	eax, DWORD PTR [edx+168]
	call	eax
	test	eax, eax
	je	SHORT $LN23@SelectBest

; 506  : 						if ( range_km < min(wrange/11, 2) || range_km > wrange )

	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	cmp	eax, 2
	jge	SHORT $LN36@SelectBest
	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	mov	ecx, 11					; 0000000bH
	idiv	ecx
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN37@SelectBest
$LN36@SelectBest:
	mov	DWORD PTR tv193[ebp], 2
$LN37@SelectBest:
	mov	edx, DWORD PTR _range_km$[ebp]
	cmp	edx, DWORD PTR tv193[ebp]
	jl	SHORT $LN21@SelectBest
	mov	eax, DWORD PTR _range_km$[ebp]
	cmp	eax, DWORD PTR _wrange$[ebp]
	jle	SHORT $LN22@SelectBest
$LN21@SelectBest:

; 507  : 							continue;

	jmp	$LN32@SelectBest
$LN22@SelectBest:

; 508  : 					}
; 509  : 					// 2002-03-09 MODIFIED BY S.G. 
; 510  : 					// New weapon selection code based on the target min/max alt and range. 
; 511  : 					// If g_bAdvancedGroundChooseWeapon is false or alt_feet is -1, use the original code
; 512  : 					// else if ( range_km < min(wrange/4, 2) || range_km > wrange )
; 513  : 					//	continue;
; 514  : 					else {

	jmp	$LN4@SelectBest
$LN23@SelectBest:

; 515  : 						// If we're shooting at an air thingy and this weapon is a ... 
; 516  : 						// STYPE_MISSILE_SURF_AIR, we might be restricted to a min/max engagement range/altitude 
; 517  : 						// if we asked for it
; 518  : 						if (g_bAdvancedGroundChooseWeapon && alt_feet >= 0 && (mt == LowAir || mt == Air)) {

	movzx	ecx, BYTE PTR ?g_bAdvancedGroundChooseWeapon@@3_NA ; g_bAdvancedGroundChooseWeapon
	test	ecx, ecx
	je	$LN19@SelectBest
	cmp	DWORD PTR _alt_feet$[ebp], 0
	jl	$LN19@SelectBest
	cmp	DWORD PTR _mt$[ebp], 4
	je	SHORT $LN18@SelectBest
	cmp	DWORD PTR _mt$[ebp], 5
	jne	$LN19@SelectBest
$LN18@SelectBest:

; 519  : 							// If we're outside the weapon's range, no point going further,
; 520  : 							// no matter what the weapon is...
; 521  : 							if (range_km > wrange){

	mov	edx, DWORD PTR _range_km$[ebp]
	cmp	edx, DWORD PTR _wrange$[ebp]
	jle	SHORT $LN17@SelectBest

; 522  : 								continue;

	jmp	$LN32@SelectBest
$LN17@SelectBest:

; 523  : 							}
; 524  : 
; 525  : 							// If it's a SAM...
; 526  : 							VU_BYTE *classInfoPtr = Falcon4ClassTable[WeaponDataTable[
; 527  : 								hardPoint[i]->weaponId].Index
; 528  : 							].vuClassData.classInfo_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _classInfoPtr$6[ebp], edx

; 529  : 							if (
; 530  : 								classInfoPtr[VU_DOMAIN] == DOMAIN_AIR && 
; 531  : 								classInfoPtr[VU_CLASS] == CLASS_VEHICLE && 
; 532  : 								classInfoPtr[VU_TYPE] == TYPE_MISSILE && 
; 533  : 								classInfoPtr[VU_STYPE] == STYPE_MISSILE_SURF_AIR
; 534  : 							){

	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _classInfoPtr$6[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 2
	jne	$LN16@SelectBest
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _classInfoPtr$6[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 7
	jne	$LN16@SelectBest
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classInfoPtr$6[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 6
	jne	$LN16@SelectBest
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _classInfoPtr$6[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 5
	jne	$LN16@SelectBest

; 535  : 								MissileAuxData *auxData = NULL;

	mov	DWORD PTR _auxData$5[ebp], 0

; 536  : 								SimWeaponDataType* wpnDefinition = &SimWeaponDataTable[
; 537  : 									Falcon4ClassTable[WeaponDataTable[hardPoint[i]->weaponId].Index].vehicleDataIndex
; 538  : 								];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movsx	edx, WORD PTR [ecx+eax+74]
	imul	edx, 52					; 00000034H
	add	edx, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	DWORD PTR _wpnDefinition$3[ebp], edx

; 539  : 
; 540  : 								if (wpnDefinition->dataIdx < numMissileDatasets){

	mov	eax, DWORD PTR _wpnDefinition$3[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	ecx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	jge	SHORT $LN15@SelectBest

; 541  : 									auxData = missileDataset[wpnDefinition->dataIdx].auxData;

	mov	edx, DWORD PTR _wpnDefinition$3[ebp]
	mov	eax, DWORD PTR [edx+48]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR ?missileDataset@@3PAVMissileDataSetClass@@A ; missileDataset
	mov	edx, DWORD PTR [ecx+eax+96]
	mov	DWORD PTR _auxData$5[ebp], edx
$LN15@SelectBest:

; 542  : 								}
; 543  : 
; 544  : 								if (auxData) {

	cmp	DWORD PTR _auxData$5[ebp], 0
	je	$LN14@SelectBest

; 545  : 									float minAlt = auxData->MinEngagementAlt;

	mov	eax, DWORD PTR _auxData$5[ebp]
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR _minAlt$4[ebp], xmm0

; 546  : 									float minRange = auxData->MinEngagementRange;

	mov	ecx, DWORD PTR _auxData$5[ebp]
	movss	xmm0, DWORD PTR [ecx+24]
	movss	DWORD PTR _minRange$2[ebp], xmm0

; 547  : 									float maxAlt = (float)WeaponDataTable[hardPoint[i]->weaponId].MaxAlt * 1000.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	edx, BYTE PTR [ecx+eax+58]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _maxAlt$1[ebp], xmm0

; 548  : 									// If our range is less than the min range, 
; 549  : 									// don't consider this weapon (used range squared to save a FPU costly sqrt)
; 550  : 									if (range_km * KM_TO_FT < minRange)

	cvtsi2ss xmm0, DWORD PTR _range_km$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	xmm1, DWORD PTR _minRange$2[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN13@SelectBest

; 551  : 										continue;

	jmp	$LN32@SelectBest
$LN13@SelectBest:

; 552  : 
; 553  : 									// If we haven't entered the MinEngagementAlt yet, 
; 554  : 									// use the one in the Falcon4.WCD file
; 555  : 									if (minAlt < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _minAlt$4[ebp]
	jbe	SHORT $LN12@SelectBest

; 556  : 										minAlt = (float)(WeaponDataTable[hardPoint[i]->weaponId].Name[18]) * 32.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	edx, 1
	imul	edx, 18					; 00000012H
	movsx	eax, BYTE PTR [ecx+edx+12]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR _minAlt$4[ebp], xmm0
$LN12@SelectBest:

; 557  : 
; 558  : 									// If less than min altitude or more than max altitude 
; 559  : 									// (in this case alt_feet is POSITIVE if we're below the target), 
; 560  : 									// don't consider this weapon
; 561  : 									if (alt_feet < minAlt || alt_feet > maxAlt)

	cvtsi2ss xmm0, DWORD PTR _alt_feet$[ebp]
	movss	xmm1, DWORD PTR _minAlt$4[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN10@SelectBest
	cvtsi2ss xmm0, DWORD PTR _alt_feet$[ebp]
	comiss	xmm0, DWORD PTR _maxAlt$1[ebp]
	jbe	SHORT $LN11@SelectBest
$LN10@SelectBest:

; 562  : 										continue;

	jmp	$LN32@SelectBest
$LN11@SelectBest:

; 563  : 								}

	jmp	SHORT $LN8@SelectBest
$LN14@SelectBest:

; 564  : 								// No auxiliary data, default to orinal min range test...
; 565  : 								else if (range_km < min(wrange/4, 2)){

	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	eax, 2
	jge	SHORT $LN38@SelectBest
	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv294[ebp], eax
	jmp	SHORT $LN39@SelectBest
$LN38@SelectBest:
	mov	DWORD PTR tv294[ebp], 2
$LN39@SelectBest:
	mov	ecx, DWORD PTR _range_km$[ebp]
	cmp	ecx, DWORD PTR tv294[ebp]
	jge	SHORT $LN8@SelectBest

; 566  : 									continue;

	jmp	$LN32@SelectBest
$LN8@SelectBest:

; 567  : 								}
; 568  : 							}

	jmp	SHORT $LN6@SelectBest
$LN16@SelectBest:

; 569  : 							// Not a SAM but was within wrange, check if too close
; 570  : 							else if (range_km < min(wrange/4, 2)){

	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	eax, 2
	jge	SHORT $LN40@SelectBest
	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv299[ebp], eax
	jmp	SHORT $LN41@SelectBest
$LN40@SelectBest:
	mov	DWORD PTR tv299[ebp], 2
$LN41@SelectBest:
	mov	edx, DWORD PTR _range_km$[ebp]
	cmp	edx, DWORD PTR tv299[ebp]
	jge	SHORT $LN6@SelectBest

; 571  : 								continue;

	jmp	$LN32@SelectBest
$LN6@SelectBest:

; 572  : 							}
; 573  : 						}

	jmp	SHORT $LN4@SelectBest
$LN19@SelectBest:

; 574  : 						// Original line if we don't want advanced weapon 
; 575  : 						// selection or our target isn't in the air or alt_feet wasn't passed (ie, is -1)
; 576  : 						else if ( range_km < min(wrange/4, 2) || range_km > wrange ){

	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	eax, 2
	jge	SHORT $LN42@SelectBest
	mov	eax, DWORD PTR _wrange$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv304[ebp], eax
	jmp	SHORT $LN43@SelectBest
$LN42@SelectBest:
	mov	DWORD PTR tv304[ebp], 2
$LN43@SelectBest:
	mov	eax, DWORD PTR _range_km$[ebp]
	cmp	eax, DWORD PTR tv304[ebp]
	jl	SHORT $LN3@SelectBest
	mov	ecx, DWORD PTR _range_km$[ebp]
	cmp	ecx, DWORD PTR _wrange$[ebp]
	jle	SHORT $LN4@SelectBest
$LN3@SelectBest:

; 577  : 							continue;

	jmp	$LN32@SelectBest
$LN4@SelectBest:

; 578  : 						}
; 579  : 					}
; 580  : 					// END OF MODIFIED SECTION 2002-03-09
; 581  : 					// END OF MODIFIED SECTION
; 582  : 				}
; 583  : 
; 584  : 				str = GetWeaponScore (hardPoint[i]->weaponId, dam, mt, range_km, wrange);

	mov	edx, DWORD PTR _wrange$[ebp]
	push	edx
	mov	eax, DWORD PTR _range_km$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dam$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	push	ecx
	call	?GetWeaponScore@@YAHHPAEHHH@Z		; GetWeaponScore
	add	esp, 20					; 00000014H
	mov	DWORD PTR _str$[ebp], eax

; 585  : 			}
; 586  : 			else {

	jmp	SHORT $LN2@SelectBest
$LN25@SelectBest:

; 587  : 				//GetWeaponScore (hardPoint[i]->weaponId, dam, mt, 1);
; 588  : 				str = WeaponDataTable[hardPoint[i]->weaponId].HitChance[mt]; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	ecx, DWORD PTR _mt$[ebp]
	movzx	edx, BYTE PTR [eax+ecx+32]
	mov	DWORD PTR _str$[ebp], edx
$LN2@SelectBest:

; 589  : 			}
; 590  : 
; 591  : 			if (str > bs){

	mov	eax, DWORD PTR _str$[ebp]
	cmp	eax, DWORD PTR _bs$[ebp]
	jle	SHORT $LN1@SelectBest

; 592  : 				bw = hardPoint[i]->weaponId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	mov	DWORD PTR _bw$[ebp], edx

; 593  : 				bs = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _bs$[ebp], eax

; 594  : 				bhp = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bhp$[ebp], ecx
$LN1@SelectBest:

; 595  : 			}
; 596  : 		}
; 597  : 	}

	jmp	$LN32@SelectBest
$LN31@SelectBest:

; 598  : 	curHardpoint = bhp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bhp$[ebp]
	mov	DWORD PTR [edx+44], eax

; 599  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SelectBestWeapon@SMSBaseClass@@QAEXPAEHHHH@Z ENDP	; SMSBaseClass::SelectBestWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_hardpoint$ = 8						; size = 4
?GetWeaponRangeFeet@SMSBaseClass@@QAEMH@Z PROC		; SMSBaseClass::GetWeaponRangeFeet
; _this$ = ecx

; 478  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 479  : 	ShiAssert (hardpoint >= 0 && hardpoint < numHardpoints);
; 480  : 	return WeaponDataTable[hardPoint[hardpoint]->weaponId].Range * KM_TO_FT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hardpoint$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx+8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR tv82[ebp], xmm0
	fld	DWORD PTR tv82[ebp]

; 481  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetWeaponRangeFeet@SMSBaseClass@@QAEMH@Z ENDP		; SMSBaseClass::GetWeaponRangeFeet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?IsSet@SMSBaseClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@SMSBaseClass@@QAEHH@Z PROC			; SMSBaseClass::IsSet, COMDAT
; _this$ = ecx

; 102  : 	int  IsSet (int newFlag) { return flags & newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	and	eax, DWORD PTR _newFlag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@SMSBaseClass@@QAEHH@Z ENDP			; SMSBaseClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?ClearFlag@SMSBaseClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@SMSBaseClass@@QAEXH@Z PROC			; SMSBaseClass::ClearFlag, COMDAT
; _this$ = ecx

; 101  : 	void ClearFlag (int newFlag) { flags &= ~newFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@SMSBaseClass@@QAEXH@Z ENDP			; SMSBaseClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetFlag@SMSBaseClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@SMSBaseClass@@QAEXH@Z PROC			; SMSBaseClass::SetFlag, COMDAT
; _this$ = ecx

; 100  : 	void SetFlag (int newFlag) { flags |= newFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@SMSBaseClass@@QAEXH@Z ENDP			; SMSBaseClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepCatIII@SMSBaseClass@@QAEXXZ PROC			; SMSBaseClass::StepCatIII
; _this$ = ecx

; 446  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 447  : 	//if(g_bEnableCATIIIExtension)	MI
; 448  : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN4@StepCatIII

; 449  : 	{
; 450  : 		if( ((AircraftClass *)ownship)->af->IsSet(AirframeClass::CATLimiterIII) )

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@StepCatIII

; 451  : 			((AircraftClass *)ownship)->af->ClearFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 452  : 		else

	jmp	SHORT $LN4@StepCatIII
$LN2@StepCatIII:

; 453  : 			((AircraftClass *)ownship)->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
$LN4@StepCatIII:

; 454  : 	}
; 455  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepCatIII@SMSBaseClass@@QAEXXZ ENDP			; SMSBaseClass::StepCatIII
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?StepMasterArm@SMSBaseClass@@QAEXXZ PROC		; SMSBaseClass::StepMasterArm
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	switch (masterArm){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN3@StepMaster
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN2@StepMaster
	jmp	SHORT $LN1@StepMaster
$LN3@StepMaster:

; 433  : 		case Safe:
; 434  : 			SetMasterArm (Sim);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 435  : 		break;

	jmp	SHORT $LN6@StepMaster
$LN2@StepMaster:

; 436  : 		case Arm:
; 437  : 			SetMasterArm (Safe);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 438  : 		break;

	jmp	SHORT $LN6@StepMaster
$LN1@StepMaster:

; 439  : 		default:
; 440  : 			SetMasterArm (Arm);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
$LN6@StepMaster:

; 441  : 	}
; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepMasterArm@SMSBaseClass@@QAEXXZ ENDP		; SMSBaseClass::StepMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newState$ = 8						; size = 4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z PROC ; SMSBaseClass::SetMasterArm, COMDAT
; _this$ = ecx

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newState$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ENDP ; SMSBaseClass::SetMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_mFaults$ = -16						; size = 4
_broken$ = -12						; size = 4
_retval$ = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?StationOK@SMSBaseClass@@QAEHH@Z PROC			; SMSBaseClass::StationOK
; _this$ = ecx

; 678  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 679  : int retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 680  : FackClass* mFaults;
; 681  : int broken;
; 682  : 
; 683  :    if (ownship->IsAirplane() && ((AircraftClass*)ownship)->mFaults)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	SHORT $LN5@StationOK
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	cmp	DWORD PTR [ecx+928], 0
	je	SHORT $LN5@StationOK

; 684  :    {
; 685  :       mFaults = ((AircraftClass*)ownship)->mFaults;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+928]
	mov	DWORD PTR _mFaults$[ebp], ecx

; 686  :       broken = mFaults->GetFault(FaultClass::sms_fault);

	push	26					; 0000001aH
	mov	ecx, DWORD PTR _mFaults$[ebp]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	mov	DWORD PTR _broken$[ebp], eax

; 687  :       if (broken & FaultClass::bus & FaultClass::fail)

	mov	edx, DWORD PTR _broken$[ebp]
	and	edx, 1
	and	edx, 2
	je	SHORT $LN4@StationOK

; 688  :       {
; 689  :          retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
	jmp	SHORT $LN5@StationOK
$LN4@StationOK:

; 690  :       }
; 691  :       else if (n >= 1)

	cmp	DWORD PTR _n$[ebp], 1
	jl	SHORT $LN5@StationOK

; 692  :       {
; 693  : 		  if (broken & (FaultClass::sta1 << (n - 1)) & FaultClass::fail)

	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	eax, 2097152				; 00200000H
	shl	eax, cl
	and	eax, DWORD PTR _broken$[ebp]
	and	eax, 2
	je	SHORT $LN5@StationOK

; 694  :          {
; 695  :             retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
$LN5@StationOK:

; 696  :          }
; 697  :       }
; 698  :    }
; 699  :         
; 700  :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StationOK@SMSBaseClass@@QAEHH@Z ENDP			; SMSBaseClass::StationOK
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_lastPtr$ = -20						; size = 4
_weapPtr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hardpoint$ = 8						; size = 4
_theWeapon$ = 12					; size = 4
?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z PROC ; SMSBaseClass::DetachWeapon
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	VuBin<SimWeaponClass> weapPtr = hardPoint[hardpoint]->weaponPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hardpoint$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@ABV0@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 459  : 	VuBin<SimWeaponClass> lastPtr;

	push	0
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
$LN5@DetachWeap:

; 460  : 
; 461  : 	while (weapPtr){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@DetachWeap

; 462  : 		if (weapPtr.get() == theWeapon){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	cmp	eax, DWORD PTR _theWeapon$[ebp]
	jne	SHORT $LN3@DetachWeap

; 463  : 			if (lastPtr){

	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@DetachWeap

; 464  : 				lastPtr->nextOnRail = theWeapon->nextOnRail;

	mov	eax, DWORD PTR _theWeapon$[ebp]
	add	eax, 672				; 000002a0H
	push	eax
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	add	eax, 672				; 000002a0H
	mov	ecx, eax
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 465  : 			}
; 466  : 			else {

	jmp	SHORT $LN1@DetachWeap
$LN2@DetachWeap:

; 467  : 				hardPoint[hardpoint]->weaponPointer = theWeapon->nextOnRail;

	mov	ecx, DWORD PTR _theWeapon$[ebp]
	add	ecx, 672				; 000002a0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
$LN1@DetachWeap:

; 468  : 			}
; 469  : 			theWeapon->nextOnRail.reset();

	push	0
	mov	ecx, DWORD PTR _theWeapon$[ebp]
	add	ecx, 672				; 000002a0H
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 470  : 			return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	jmp	SHORT $LN6@DetachWeap
$LN3@DetachWeap:

; 471  : 		}
; 472  : 		lastPtr = weapPtr;

	lea	edx, DWORD PTR _weapPtr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 473  : 		weapPtr = weapPtr->nextOnRail;

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	add	eax, 672				; 000002a0H
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 474  : 	}

	jmp	$LN5@DetachWeap
$LN4@DetachWeap:

; 475  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
$LN6@DetachWeap:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z$0:
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z$1:
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z ENDP ; SMSBaseClass::DetachWeapon
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_vc$ = -72						; size = 4
_visFlag$ = -68						; size = 4
_tmpTargetPtr$ = -64					; size = 4
tv91 = -60						; size = 4
tv232 = -56						; size = 4
tv440 = -52						; size = 4
tv418 = -48						; size = 4
_theMissile$2 = -44					; size = 4
_slotId$ = -40						; size = 4
_theWeapon$ = -36					; size = 4
_this$ = -32						; size = 4
_simLoc$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LaunchWeapon@SMSBaseClass@@QAEXXZ PROC			; SMSBaseClass::LaunchWeapon
; _this$ = ecx

; 334  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LaunchWeapon@SMSBaseClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 335  : 	VuBin<SimWeaponClass> theWeapon;

	push	0
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 336  : 	//SimWeaponClass *theWeapon;
; 337  : 	Tpoint			simLoc;
; 338  : 	//float			dx,dy,dz,xydist,yaw,pitch;
; 339  : 	SimObjectType	*tmpTargetPtr = ownship->targetPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+656]
	mov	DWORD PTR _tmpTargetPtr$[ebp], edx

; 340  : 	int				visFlag;
; 341  : 	VehicleClassDataType* vc;
; 342  : 	int slotId;
; 343  : 
; 344  : 	if (!ownship->drawPointer || !tmpTargetPtr){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN12@LaunchWeap
	cmp	DWORD PTR _tmpTargetPtr$[ebp], 0
	jne	SHORT $LN13@LaunchWeap
$LN12@LaunchWeap:

; 345  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	jmp	$LN14@LaunchWeap
$LN13@LaunchWeap:

; 346  : 	}
; 347  : 
; 348  : 	// edg: there was a problem.  Some ground vehicles do NOT have guns
; 349  : 	// at all.  All this code assumes a gun in Slot 0 and therefore subtracts
; 350  : 	// 1 from curhardpoint to get the right slot.  Don't do this if there
; 351  : 	// are no guns on board.
; 352  : 	if (IsSet(GunOnBoard)){

	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SMSBaseClass@@QAEHH@Z		; SMSBaseClass::IsSet
	test	eax, eax
	je	SHORT $LN11@LaunchWeap

; 353  : 		slotId = max(0,curHardpoint - 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	sub	eax, 1
	jns	SHORT $LN16@LaunchWeap
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN17@LaunchWeap
$LN16@LaunchWeap:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	sub	edx, 1
	mov	DWORD PTR tv91[ebp], edx
$LN17@LaunchWeap:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR _slotId$[ebp], eax

; 354  : 	}
; 355  : 	else {

	jmp	SHORT $LN10@LaunchWeap
$LN11@LaunchWeap:

; 356  : 		slotId = curHardpoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _slotId$[ebp], edx
$LN10@LaunchWeap:

; 357  : 	}
; 358  : 
; 359  : 	vc = GetVehicleClassData(ownship->Type() - VU_LAST_ENTITY_TYPE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	ecx, ax
	sub	ecx, 100				; 00000064H
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 360  : 	visFlag = vc->VisibleFlags;

	mov	edx, DWORD PTR _vc$[ebp]
	movzx	eax, WORD PTR [edx+62]
	mov	DWORD PTR _visFlag$[ebp], eax

; 361  : 	if (
; 362  : 		(hardPoint && curHardpoint > -1) && 
; 363  : 		(hardPoint[curHardpoint]->weaponPointer) && 
; 364  : 		(hardPoint[curHardpoint]->weaponCount > 0)
; 365  : 	){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN1@LaunchWeap
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], -1
	jle	$LN1@LaunchWeap
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@LaunchWeap
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	movsx	ecx, WORD PTR [eax+10]
	test	ecx, ecx
	jle	$LN1@LaunchWeap

; 366  : 		theWeapon = hardPoint[curHardpoint]->weaponPointer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 367  : 		hardPoint[curHardpoint]->weaponCount--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ax, WORD PTR [edx+10]
	sub	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	WORD PTR [edx+10], ax

; 368  : 		DetachWeapon(curHardpoint, theWeapon.get());

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetachWeapon@SMSBaseClass@@QAEXHPAVSimWeaponClass@@@Z ; SMSBaseClass::DetachWeapon

; 369  : 		//DetachWeapon(curHardpoint, theWeapon);
; 370  : 
; 371  : 		// Detach visual from parent
; 372  : 		if (theWeapon->drawPointer){

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN8@LaunchWeap

; 373  : 			// KCK: Call detach directly, so we can use it's updated position/orientation
; 374  : 			((DrawableBSP*)ownship->drawPointer)->DetachChild((DrawableBSP*)theWeapon->drawPointer, slotId);

	mov	edx, DWORD PTR _slotId$[ebp]
	push	edx
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	eax, DWORD PTR [eax+332]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+332]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild
$LN8@LaunchWeap:

; 375  : 		}
; 376  : 
; 377  : 		if (theWeapon->IsMissile() && ownship->drawPointer){

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv232[ebp], eax
	mov	eax, DWORD PTR tv232[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv232[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	$LN7@LaunchWeap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	DWORD PTR [edx+332], 0
	je	$LN7@LaunchWeap

; 378  : 			if (visFlag & (1 << curHardpoint)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+44]
	shl	edx, cl
	and	edx, DWORD PTR _visFlag$[ebp]
	je	SHORT $LN6@LaunchWeap

; 379  : 				((DrawableBSP*)ownship->drawPointer)->GetChildOffset(slotId, &simLoc);

	lea	eax, DWORD PTR _simLoc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _slotId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+332]
	call	?GetChildOffset@DrawableBSP@@QAEXHPAUTpoint@@@Z ; DrawableBSP::GetChildOffset

; 380  : 			}
; 381  : 			else {

	jmp	SHORT $LN5@LaunchWeap
$LN6@LaunchWeap:

; 382  : 				simLoc.x = simLoc.y = simLoc.z = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _simLoc$[ebp+8], xmm0
	movss	xmm0, DWORD PTR _simLoc$[ebp+8]
	movss	DWORD PTR _simLoc$[ebp+4], xmm0
	movss	xmm0, DWORD PTR _simLoc$[ebp+4]
	movss	DWORD PTR _simLoc$[ebp], xmm0
$LN5@LaunchWeap:

; 383  : 			}
; 384  : 
; 385  : 			// The weapon's position/orientation are being set relative to the parent's postion and orientation
; 386  : 			MissileClass *theMissile = static_cast<MissileClass*>(theWeapon.get());

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _theMissile$2[ebp], eax

; 387  : 			theMissile->SetLaunchPosition (simLoc.x, simLoc.y, simLoc.z);

	push	ecx
	movss	xmm0, DWORD PTR _simLoc$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _simLoc$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _simLoc$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theMissile$2[ebp]
	call	?SetLaunchPosition@MissileClass@@QAEXMMM@Z ; MissileClass::SetLaunchPosition

; 388  : 			theMissile->SetLaunchRotation (ownship->GetDOFValue(0), ownship->GetDOFValue(1));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _theMissile$2[ebp]
	call	?SetLaunchRotation@MissileClass@@QAEXMM@Z ; MissileClass::SetLaunchRotation

; 389  : 
; 390  : 			//((MissileClass*)theWeapon.get())->SetLaunchPosition (simLoc.x, simLoc.y, simLoc.z);
; 391  : 			//((MissileClass*)theWeapon.get())->SetLaunchRotation (ownship->GetDOFValue(0), ownship->GetDOFValue(1));
; 392  : 		}
; 393  : 		else {

	jmp	SHORT $LN4@LaunchWeap
$LN7@LaunchWeap:

; 394  : 			// Just use parent object's position/orientation
; 395  : 			// KCK: These take world coodinates, but I can't really think of a non-missile ground weapon
; 396  : 			// which launches... 
; 397  : 			theWeapon->SetPosition(ownship->XPos(),ownship->YPos(),ownship->ZPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 398  : 			theWeapon->SetYPR(ownship->Yaw(),ownship->Pitch(),0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR
$LN4@LaunchWeap:

; 399  : 		}
; 400  : 		theWeapon->SetDelta(ownship->XDelta(), ownship->YDelta(), ownship->ZDelta());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 401  : 
; 402  : 		// If we're direct mounted weapons and have more weapons on this hardpoint, but no weapon pointers, 
; 403  : 		// replace the weapon with an identical copy
; 404  : 		if (
; 405  : 			!hardPoint[curHardpoint]->GetRackOrPylon() && // MLR 2/20/2004 - added OrPylon
; 406  : 			hardPoint[curHardpoint]->weaponCount && 
; 407  : 			!hardPoint[curHardpoint]->weaponPointer
; 408  : 		){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	test	eax, eax
	jne	$LN1@LaunchWeap
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	movsx	edx, WORD PTR [ecx+10]
	test	edx, edx
	je	$LN1@LaunchWeap
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator!
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@LaunchWeap

; 409  : 			if (theWeapon->IsMissile()){

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv418[ebp], eax
	mov	edx, DWORD PTR tv418[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv418[ebp]
	mov	edx, DWORD PTR [eax+156]
	call	edx
	test	eax, eax
	je	SHORT $LN2@LaunchWeap

; 410  : 				//ReplaceMissile(curHardpoint, (MissileClass*)theWeapon.get());
; 411  : 				ReplaceMissile(curHardpoint, (MissileClass*)theWeapon.get());

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReplaceMissile@SMSBaseClass@@QAEXHPAVMissileClass@@@Z ; SMSBaseClass::ReplaceMissile
$LN2@LaunchWeap:

; 412  : 			}
; 413  : 			if (theWeapon->IsBomb()){

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv440[ebp], eax
	mov	edx, DWORD PTR tv440[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv440[ebp]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	test	eax, eax
	je	SHORT $LN1@LaunchWeap

; 414  : 				//ReplaceBomb(curHardpoint, (BombClass*)theWeapon.get());
; 415  : 				ReplaceBomb(curHardpoint, (BombClass*)theWeapon.get());

	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReplaceBomb@SMSBaseClass@@QAEXHPAVBombClass@@@Z ; SMSBaseClass::ReplaceBomb
$LN1@LaunchWeap:

; 416  : 			}
; 417  : 		}
; 418  : 		// If next weapon is a visible weapon, attach it to the hardpoint (note: some delay to this would be cool)
; 419  : 		/*
; 420  : 		if (hardPoint[curHardpoint]->weaponPointer && visFlag & (1 << curHardpoint)){
; 421  : 			OTWDriver.CreateVisualObject(hardPoint[curHardpoint]->weaponPointer);
; 422  : 			OTWDriver.AttachObject(
; 423  : 				ownship->drawPointer, (DrawableBSP*)hardPoint[curHardpoint]->weaponPointer->drawPointer, curHardpoint
; 424  : 			);
; 425  : 		}
; 426  : 		*/
; 427  : 	}
; 428  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
$LN14@LaunchWeap:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LaunchWeapon@SMSBaseClass@@QAEXXZ$0:
	lea	ecx, DWORD PTR _theWeapon$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$?LaunchWeapon@SMSBaseClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LaunchWeapon@SMSBaseClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LaunchWeapon@SMSBaseClass@@QAEXXZ ENDP			; SMSBaseClass::LaunchWeapon
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?GetCurrentWeaponRangeFeet@SMSBaseClass@@QAEMXZ PROC	; SMSBaseClass::GetCurrentWeaponRangeFeet
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 	if (curHardpoint > -1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], -1
	jle	SHORT $LN1@GetCurrent

; 297  : 		return WeaponDataTable[hardPoint[curHardpoint]->weaponId].Range * KM_TO_FT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	movsx	eax, WORD PTR [edx+8]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	edx, WORD PTR [ecx+eax+8]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR tv88[ebp], xmm0
	fld	DWORD PTR tv88[ebp]
	jmp	SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 298  : 	return 0.0F;

	fldz
$LN2@GetCurrent:

; 299  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeaponRangeFeet@SMSBaseClass@@QAEMXZ ENDP	; SMSBaseClass::GetCurrentWeaponRangeFeet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWeaponIndex@SMSBaseClass@@QAEFXZ PROC	; SMSBaseClass::GetCurrentWeaponIndex
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	if (curHardpoint > -1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], -1
	jle	SHORT $LN1@GetCurrent

; 289  : 		return WeaponDataTable[hardPoint[curHardpoint]->weaponId].Index;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	movsx	eax, WORD PTR [edx+8]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	ax, WORD PTR [ecx+eax]
	jmp	SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 290  : 	return 0;

	xor	eax, eax
$LN2@GetCurrent:

; 291  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeaponIndex@SMSBaseClass@@QAEFXZ ENDP	; SMSBaseClass::GetCurrentWeaponIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWeaponType@SMSBaseClass@@QAE?AW4WeaponType@@XZ PROC ; SMSBaseClass::GetCurrentWeaponType
; _this$ = ecx

; 4111 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4112 : 	if(curHardpoint<0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jge	SHORT $LN1@GetCurrent

; 4113 : 	{
; 4114 : 		return wtNone;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 4115 : 	}
; 4116 : 
; 4117 : 	return hardPoint[curHardpoint]->GetWeaponType();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+156]
	call	eax
$LN2@GetCurrent:

; 4118 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeaponType@SMSBaseClass@@QAE?AW4WeaponType@@XZ ENDP ; SMSBaseClass::GetCurrentWeaponType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv85 = -8						; size = 4
_this$ = -4						; size = 4
_hardpoint$ = 8						; size = 4
?GetBomb@SMSBaseClass@@QAEPAVBombClass@@H@Z PROC	; SMSBaseClass::GetBomb
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 271  : 	if (hardPoint && hardPoint[hardpoint]->weaponPointer && hardPoint[hardpoint]->weaponPointer->IsBomb())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@GetBomb
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GetBomb
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv85[ebp], eax
	mov	edx, DWORD PTR tv85[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR [eax+164]
	call	edx
	test	eax, eax
	je	SHORT $LN1@GetBomb

; 272  : 		return (BombClass*) hardPoint[hardpoint]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	jmp	SHORT $LN2@GetBomb
$LN1@GetBomb:

; 273  : 	return NULL;

	xor	eax, eax
$LN2@GetBomb:

; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBomb@SMSBaseClass@@QAEPAVBombClass@@H@Z ENDP	; SMSBaseClass::GetBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv85 = -8						; size = 4
_this$ = -4						; size = 4
_hardpoint$ = 8						; size = 4
?GetMissile@SMSBaseClass@@QAEPAVMissileClass@@H@Z PROC	; SMSBaseClass::GetMissile
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	if (hardPoint && hardPoint[hardpoint]->weaponPointer && hardPoint[hardpoint]->weaponPointer->IsMissile())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@GetMissile
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GetMissile
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv85[ebp], eax
	mov	edx, DWORD PTR tv85[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR [eax+156]
	call	edx
	test	eax, eax
	je	SHORT $LN1@GetMissile

; 265  : 		return (MissileClass*) hardPoint[hardpoint]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hardpoint$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	jmp	SHORT $LN2@GetMissile
$LN1@GetMissile:

; 266  : 	return NULL;

	xor	eax, eax
$LN2@GetMissile:

; 267  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetMissile@SMSBaseClass@@QAEPAVMissileClass@@H@Z ENDP	; SMSBaseClass::GetMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
tv86 = -8						; size = 4
_this$ = -4						; size = 4
_station$ = 8						; size = 4
?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z PROC		; SMSBaseClass::GetGun
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 	if (hardPoint && station >= 0 && hardPoint[station]->weaponPointer && hardPoint[station]->weaponPointer->IsGun())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@GetGun
	cmp	DWORD PTR _station$[ebp], 0
	jl	SHORT $LN1@GetGun
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _station$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GetGun
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _station$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv86[ebp], eax
	mov	edx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [eax+168]
	call	edx
	test	eax, eax
	je	SHORT $LN1@GetGun

; 258  : 		return (GunClass*) hardPoint[station]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _station$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	jmp	SHORT $LN2@GetGun
$LN1@GetGun:

; 259  : 	return NULL;

	xor	eax, eax
$LN2@GetGun:

; 260  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ENDP		; SMSBaseClass::GetGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWeapon@SMSBaseClass@@UAEPAVSimWeaponClass@@XZ PROC ; SMSBaseClass::GetCurrentWeapon
; _this$ = ecx

; 277  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	if (hardPoint && curHardpoint > -1){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@GetCurrent
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], -1
	jle	SHORT $LN2@GetCurrent

; 279  : 		return hardPoint[curHardpoint]->weaponPointer.get();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	jmp	SHORT $LN3@GetCurrent

; 280  : 	}
; 281  : 	else{

	jmp	SHORT $LN3@GetCurrent
$LN2@GetCurrent:

; 282  : 		return NULL;

	xor	eax, eax
$LN3@GetCurrent:

; 283  : 	}
; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeapon@SMSBaseClass@@UAEPAVSimWeaponClass@@XZ ENDP ; SMSBaseClass::GetCurrentWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_drawPtr$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 4
_weaponPtr$ = -4					; size = 4
?FreeWeaponGraphics@SMSBaseClass@@UAEXXZ PROC		; SMSBaseClass::FreeWeaponGraphics
; _this$ = ecx

; 636  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	int i;
; 638  : 	SimWeaponClass	*weaponPtr;
; 639  : 	DrawableBSP		*drawPtr = (DrawableBSP*) ownship->drawPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR _drawPtr$[ebp], edx

; 640  : 
; 641  : 	if (!hardPoint || !drawPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN13@FreeWeapon
	cmp	DWORD PTR _drawPtr$[ebp], 0
	jne	SHORT $LN14@FreeWeapon
$LN13@FreeWeapon:

; 642  : 		return;

	jmp	$LN15@FreeWeapon
$LN14@FreeWeapon:

; 643  : 
; 644  : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@FreeWeapon
$LN11@FreeWeapon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN12@FreeWeapon:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$LN15@FreeWeapon

; 645  : 	{
; 646  : 		weaponPtr = NULL;

	mov	DWORD PTR _weaponPtr$[ebp], 0

; 647  : 		if (hardPoint[i]){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN8@FreeWeapon

; 648  : 			weaponPtr = hardPoint[i]->weaponPointer.get();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _weaponPtr$[ebp], eax
$LN8@FreeWeapon:

; 649  : 		}
; 650  : 
; 651  : 		while (weaponPtr)

	cmp	DWORD PTR _weaponPtr$[ebp], 0
	je	$LN7@FreeWeapon

; 652  : 		{
; 653  : 
; 654  : 			if ( weaponPtr->IsMissile() )

	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	SHORT $LN6@FreeWeapon

; 655  : 			{
; 656  : 				((MissileClass *)weaponPtr)->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	call	?SetTarget@MissileClass@@QAEXPAVSimObjectType@@@Z ; MissileClass::SetTarget

; 657  : 				((MissileClass *)weaponPtr)->ClearReferences();

	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	call	?ClearReferences@MissileClass@@QAEXXZ	; MissileClass::ClearReferences
	jmp	SHORT $LN5@FreeWeapon
$LN6@FreeWeapon:

; 658  : 			}
; 659  : 			else if ( weaponPtr->IsBomb() )

	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	je	SHORT $LN5@FreeWeapon

; 660  : 				((BombClass *)weaponPtr)->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	call	?SetTarget@BombClass@@QAEXPAVSimObjectType@@@Z ; BombClass::SetTarget
$LN5@FreeWeapon:

; 661  : 
; 662  : 			if (weaponPtr->drawPointer)

	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN3@FreeWeapon

; 663  : 			{
; 664  : 				// Detach anything with a draw pointer from the vehicle's drawpointer
; 665  : 				OTWDriver.DetachObject(drawPtr,	(DrawableBSP*)(weaponPtr->drawPointer), i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _weaponPtr$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _drawPtr$[ebp]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?DetachObject@OTWDriverClass@@QAEXPAVDrawableBSP@@0H@Z ; OTWDriverClass::DetachObject

; 666  : 				OTWDriver.RemoveObject(weaponPtr->drawPointer, TRUE);

	push	1
	mov	eax, DWORD PTR _weaponPtr$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 667  : 				weaponPtr->drawPointer = NULL;

	mov	edx, DWORD PTR _weaponPtr$[ebp]
	mov	DWORD PTR [edx+332], 0
	jmp	SHORT $LN2@FreeWeapon
$LN3@FreeWeapon:

; 668  : 			}
; 669  : 			else if (GetGun(i))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ; SMSBaseClass::GetGun
	test	eax, eax
	je	SHORT $LN2@FreeWeapon

; 670  : 				GetGun(i)->CleanupTracers();

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGun@SMSBaseClass@@QAEPAVGunClass@@H@Z ; SMSBaseClass::GetGun
	mov	ecx, eax
	call	?CleanupTracers@GunClass@@QAEXXZ	; GunClass::CleanupTracers
$LN2@FreeWeapon:

; 671  : 			weaponPtr = weaponPtr->GetNextOnRail();

	mov	ecx, DWORD PTR _weaponPtr$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	mov	DWORD PTR _weaponPtr$[ebp], eax

; 672  : 		}

	jmp	$LN8@FreeWeapon
$LN7@FreeWeapon:

; 673  : 	}

	jmp	$LN11@FreeWeapon
$LN15@FreeWeapon:

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FreeWeaponGraphics@SMSBaseClass@@UAEXXZ ENDP		; SMSBaseClass::FreeWeaponGraphics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
_visFlag$ = -24						; size = 4
_vc$ = -20						; size = 4
tv183 = -16						; size = 4
_drawPtr$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?AddWeaponGraphics@SMSBaseClass@@UAEXXZ PROC		; SMSBaseClass::AddWeaponGraphics
; _this$ = ecx

; 605  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 	int				i, visFlag;
; 607  : 	DrawableBSP		*drawPtr = (DrawableBSP*) ownship->drawPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR _drawPtr$[ebp], edx

; 608  : 	VehicleClassDataType* vc;
; 609  : 	
; 610  : 	if (!hardPoint || !drawPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@AddWeaponG
	cmp	DWORD PTR _drawPtr$[ebp], 0
	jne	SHORT $LN9@AddWeaponG
$LN8@AddWeaponG:

; 611  : 		return;

	jmp	$LN10@AddWeaponG
$LN9@AddWeaponG:

; 612  : 
; 613  : 	vc = GetVehicleClassData(ownship->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	edx, ax
	sub	edx, 100				; 00000064H
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 614  : 	visFlag = vc->VisibleFlags;

	mov	eax, DWORD PTR _vc$[ebp]
	movzx	ecx, WORD PTR [eax+62]
	mov	DWORD PTR _visFlag$[ebp], ecx

; 615  : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@AddWeaponG
$LN6@AddWeaponG:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@AddWeaponG:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN5@AddWeaponG

; 616  : 	{
; 617  : 		if (hardPoint[i] && hardPoint[i]->weaponPointer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN1@AddWeaponG
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	$LN1@AddWeaponG

; 618  : 		{
; 619  : 			if (visFlag & (1 << i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _visFlag$[ebp]
	je	SHORT $LN3@AddWeaponG

; 620  : 			{
; 621  : 				// This is a visible weapon, however, only the first one should get a drawPointer
; 622  : 				OTWDriver.CreateVisualObject(hardPoint[i]->weaponPointer.get());

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?CreateVisualObject@OTWDriverClass@@QAEXPAVSimBaseClass@@M@Z ; OTWDriverClass::CreateVisualObject

; 623  : 				OTWDriver.AttachObject(drawPtr, (DrawableBSP*)hardPoint[i]->weaponPointer->drawPointer, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	edx, DWORD PTR [eax+332]
	push	edx
	mov	eax, DWORD PTR _drawPtr$[ebp]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AttachObject@OTWDriverClass@@QAEXPAVDrawableBSP@@0H@Z ; OTWDriverClass::AttachObject
	jmp	SHORT $LN1@AddWeaponG
$LN3@AddWeaponG:

; 624  : 			}
; 625  : 			else if (hardPoint[i]->weaponPointer->IsGun())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv183[ebp], eax
	mov	ecx, DWORD PTR tv183[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv183[ebp]
	mov	eax, DWORD PTR [edx+168]
	call	eax
	test	eax, eax
	je	SHORT $LN1@AddWeaponG

; 626  : 			{
; 627  : 				// Just init gun's tracers. We don't draw the gun
; 628  : 				((GunClass*)hardPoint[i]->weaponPointer.get())->InitTracers();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	ecx, eax
	call	?InitTracers@GunClass@@QAEXXZ		; GunClass::InitTracers
$LN1@AddWeaponG:

; 629  : 			}
; 630  : 			// Otherwise, this is a non-visible weapon - it'll init it's draw pointer on launch
; 631  : 		}
; 632  : 	}

	jmp	$LN6@AddWeaponG
$LN5@AddWeaponG:
$LN10@AddWeaponG:

; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddWeaponGraphics@SMSBaseClass@@UAEXXZ ENDP		; SMSBaseClass::AddWeaponGraphics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv141 = -24						; size = 4
$T2 = -20						; size = 4
_tmpwpn$ = -16						; size = 4
$T3 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??1SMSBaseClass@@UAE@XZ PROC				; SMSBaseClass::~SMSBaseClass
; _this$ = ecx

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SMSBaseClass@@6B@

; 224  : 	int i;
; 225  : 	SimWeaponClass *tmpwpn;
; 226  : 
; 227  : 	if (hardPoint)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN8@SMSBaseCla

; 228  : 	{
; 229  : 		// Clear out unfired weapons
; 230  : 		for (i=0; i<numHardpoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SMSBaseCla
$LN5@SMSBaseCla:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@SMSBaseCla:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN4@SMSBaseCla
$LN3@SMSBaseCla:

; 231  : 			// edg bug fix hack (try): for some reason we're crashing
; 232  : 			// in here on ground unit cleanup.  I'm not sure what's
; 233  : 			// causing this, but I have seen the hardpoint weaponCount
; 234  : 			// be 0 and weaponPointer non-NULL.  Ths hack is to make
; 235  : 			// sure if weaponCount is 0 weaponPointer is NULL.
; 236  : 			// if ( hardPoint[i]->weaponCount == 0 )
; 237  : 			//	hardPoint[i]->weaponPointer = NULL;
; 238  : 			while (hardPoint[i] && hardPoint[i]->weaponPointer){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN2@SMSBaseCla
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@SMSBaseCla

; 239  : 				tmpwpn = hardPoint[i]->weaponPointer.get();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR _tmpwpn$[ebp], eax

; 240  : 				hardPoint[i]->weaponPointer.reset(tmpwpn->GetNextOnRail());

	mov	ecx, DWORD PTR _tmpwpn$[ebp]
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 241  : 				//delete tmpwpn;
; 242  : 				//vuAntiDB->Remove(tmpwpn);
; 243  : 			}

	jmp	SHORT $LN3@SMSBaseCla
$LN2@SMSBaseCla:

; 244  : 			if (hardPoint[i]){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN1@SMSBaseCla

; 245  : 				delete hardPoint[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN10@SMSBaseCla
	push	1
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN1@SMSBaseCla
$LN10@SMSBaseCla:
	mov	DWORD PTR tv141[ebp], 0
$LN1@SMSBaseCla:

; 246  : 			}
; 247  : 			hardPoint[i] = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 248  : 		}

	jmp	$LN5@SMSBaseCla
$LN4@SMSBaseCla:

; 249  : 		// sfr: [] since its a vector
; 250  : 		delete []hardPoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 251  : 		hardPoint = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN8@SMSBaseCla:

; 252  : 	}
; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1SMSBaseClass@@UAE@XZ ENDP				; SMSBaseClass::~SMSBaseClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\sms.cpp
_TEXT	SEGMENT
$T2 = -116						; size = 4
tv531 = -112						; size = 4
tv538 = -108						; size = 4
$T3 = -104						; size = 4
tv529 = -100						; size = 4
tv537 = -96						; size = 4
$T4 = -92						; size = 4
tv527 = -88						; size = 4
tv536 = -84						; size = 4
$T5 = -80						; size = 4
$T6 = -76						; size = 4
_vc$ = -72						; size = 4
$T7 = -68						; size = 4
_createCount$ = -64					; size = 4
tv291 = -60						; size = 4
_rackFlag$ = -56					; size = 4
tv280 = -52						; size = 4
tv265 = -48						; size = 4
tv199 = -44						; size = 4
$T8 = -40						; size = 4
tv188 = -36						; size = 4
$T9 = -32						; size = 4
_wd$ = -28						; size = 4
_classPtr$ = -24					; size = 4
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newOwnship$ = 8					; size = 4
_weapId$ = 12						; size = 4
_weapCnt$ = 16						; size = 4
_advanced$ = 20						; size = 4
??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z PROC	; SMSBaseClass::SMSBaseClass
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SMSBaseClass@@6B@

; 94   : 	int						i;//,j;
; 95   : 	WeaponClassDataType		*wd;
; 96   : 	Falcon4EntityClassType	*classPtr;
; 97   : 	//
; 98   : 	VehicleClassDataType	*vc;
; 99   : 	int						rackFlag = 0, createCount;

	mov	DWORD PTR _rackFlag$[ebp], 0

; 100  : 
; 101  : 	flags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 102  : 	numCurrentWpn = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 103  : 	//MI change for default state
; 104  : 	if(!g_bRealisticAvionics){ masterArm = Arm; }

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN32@SMSBaseCla
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 2
	jmp	SHORT $LN31@SMSBaseCla
$LN32@SMSBaseCla:

; 105  : 	else { masterArm = Safe; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN31@SMSBaseCla:

; 106  : 	ownship = newOwnship;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newOwnship$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 107  : 
; 108  : 	if (ownship->IsAirplane() && ((AircraftClass*)ownship)->IsF16()) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	SHORT $LN30@SMSBaseCla
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	SHORT $LN30@SMSBaseCla

; 109  : 		numHardpoints = 10;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 10			; 0000000aH

; 110  : 	}
; 111  : 	else {

	jmp	SHORT $LN29@SMSBaseCla
$LN30@SMSBaseCla:

; 112  : 		for (numHardpoints=HARDPOINT_MAX-1; numHardpoints>=0; numHardpoints--){

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 15			; 0000000fH
	jmp	SHORT $LN28@SMSBaseCla
$LN27@SMSBaseCla:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx
$LN28@SMSBaseCla:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jl	SHORT $LN26@SMSBaseCla

; 113  : 			if (weapId[numHardpoints] != 0){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _weapId$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN25@SMSBaseCla

; 114  : 				break;

	jmp	SHORT $LN26@SMSBaseCla
$LN25@SMSBaseCla:

; 115  : 			}
; 116  : 		}

	jmp	SHORT $LN27@SMSBaseCla
$LN26@SMSBaseCla:

; 117  : 		if (numHardpoints >= 0){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jl	SHORT $LN24@SMSBaseCla

; 118  : 			numHardpoints ++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx

; 119  : 		}
; 120  : 		else {

	jmp	SHORT $LN29@SMSBaseCla
$LN24@SMSBaseCla:

; 121  : 			numHardpoints = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0
$LN29@SMSBaseCla:

; 122  : 		}
; 123  : 	}
; 124  : 
; 125  : 	curHardpoint = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], -1

; 126  : 	if (numHardpoints){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN22@SMSBaseCla

; 127  : 		hardPoint = new BasicWeaponStation*[numHardpoints];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [eax+4], ecx

; 128  : 	}
; 129  : 	else {

	jmp	SHORT $LN21@SMSBaseCla
$LN22@SMSBaseCla:

; 130  : 		hardPoint = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN21@SMSBaseCla:

; 131  : 	}
; 132  : //
; 133  : 	vc = GetVehicleClassData(newOwnship->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _newOwnship$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	sub	eax, 100				; 00000064H
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 134  : 	rackFlag=vc->RackFlags;

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+60]
	mov	DWORD PTR _rackFlag$[ebp], edx

; 135  : //
; 136  : 	for (i=0; i<numHardpoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@SMSBaseCla
$LN19@SMSBaseCla:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@SMSBaseCla:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	$LN33@SMSBaseCla

; 137  : 	{
; 138  : 		if (advanced){

	cmp	DWORD PTR _advanced$[ebp], 0
	je	SHORT $LN17@SMSBaseCla

; 139  : 			hardPoint[i] = new AdvancedWeaponStation;

	push	152					; 00000098H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN35@SMSBaseCla
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0AdvancedWeaponStation@@QAE@XZ	; AdvancedWeaponStation::AdvancedWeaponStation
	mov	DWORD PTR tv188[ebp], eax
	jmp	SHORT $LN36@SMSBaseCla
$LN35@SMSBaseCla:
	mov	DWORD PTR tv188[ebp], 0
$LN36@SMSBaseCla:
	mov	eax, DWORD PTR tv188[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 140  : 		}
; 141  : 		else{

	jmp	SHORT $LN16@SMSBaseCla
$LN17@SMSBaseCla:

; 142  : 			hardPoint[i] = new BasicWeaponStation;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN37@SMSBaseCla
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0BasicWeaponStation@@QAE@XZ		; BasicWeaponStation::BasicWeaponStation
	mov	DWORD PTR tv199[ebp], eax
	jmp	SHORT $LN38@SMSBaseCla
$LN37@SMSBaseCla:
	mov	DWORD PTR tv199[ebp], 0
$LN38@SMSBaseCla:
	mov	edx, DWORD PTR tv199[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN16@SMSBaseCla:

; 143  : 		}
; 144  : 		hardPoint[i]->weaponPointer.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 145  : 		hardPoint[i]->weaponId = (unsigned short)(weapId[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _weapId$[ebp]
	mov	dx, WORD PTR [eax+edx*2]
	mov	WORD PTR [ecx+8], dx

; 146  : 		hardPoint[i]->weaponCount = (unsigned short)(weapCnt[i]);

	mov	eax, DWORD PTR _weapCnt$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	cx, BYTE PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	WORD PTR [eax+10], cx

; 147  : 
; 148  : 		if (hardPoint[i]->weaponId && hardPoint[i]->weaponCount)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	test	edx, edx
	je	$LN15@SMSBaseCla
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+10]
	test	ecx, ecx
	je	$LN15@SMSBaseCla

; 149  : 		{
; 150  : 			wd = &WeaponDataTable[hardPoint[i]->weaponId];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+8]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	DWORD PTR _wd$[ebp], eax

; 151  : 			ShiAssert (wd);
; 152  : 			if (wd->Flags & WEAP_ONETENTH)

	mov	ecx, DWORD PTR _wd$[ebp]
	movzx	edx, WORD PTR [ecx+10]
	and	edx, 32768				; 00008000H
	je	SHORT $LN14@SMSBaseCla

; 153  : 				hardPoint[i]->weaponCount *= 10;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+10]
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	WORD PTR [eax+10], cx
$LN14@SMSBaseCla:

; 154  : 
; 155  : 			// sfr: in DF and IA we dont respect these hardpoint limitations
; 156  : 			// fixes DF bug where you select 8 missiles and after second youre out of ammo
; 157  : 			createCount = (
; 158  : 				(FalconLocalGame->gameType == game_Dogfight) || 
; 159  : 				(FalconLocalGame->gameType == game_InstantAction) || 
; 160  : 				(rackFlag & (1 << i))
; 161  : 			) ? hardPoint[i]->weaponCount : 1;

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN39@SMSBaseCla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv265[ebp], eax
	jmp	SHORT $LN40@SMSBaseCla
$LN39@SMSBaseCla:
	mov	DWORD PTR tv265[ebp], 0
$LN40@SMSBaseCla:
	mov	edx, DWORD PTR tv265[ebp]
	cmp	DWORD PTR [edx+352], 2
	je	SHORT $LN43@SMSBaseCla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@SMSBaseCla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv280[ebp], eax
	jmp	SHORT $LN42@SMSBaseCla
$LN41@SMSBaseCla:
	mov	DWORD PTR tv280[ebp], 0
$LN42@SMSBaseCla:
	mov	ecx, DWORD PTR tv280[ebp]
	cmp	DWORD PTR [ecx+352], 1
	je	SHORT $LN43@SMSBaseCla
	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _rackFlag$[ebp]
	jne	SHORT $LN43@SMSBaseCla
	mov	DWORD PTR tv291[ebp], 1
	jmp	SHORT $LN44@SMSBaseCla
$LN43@SMSBaseCla:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+10]
	mov	DWORD PTR tv291[ebp], ecx
$LN44@SMSBaseCla:
	mov	edx, DWORD PTR tv291[ebp]
	mov	DWORD PTR _createCount$[ebp], edx

; 162  : 			classPtr = &Falcon4ClassTable[wd->Index];

	mov	eax, DWORD PTR _wd$[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], ecx

; 163  : 			if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_GUN &&
; 164  : 				classPtr->vuClassData.classInfo_[VU_CLASS] == CLASS_WEAPON)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 3
	jne	SHORT $LN13@SMSBaseCla
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 8
	jne	SHORT $LN13@SMSBaseCla

; 165  : 			{
; 166  : 				// This is a gun, initialize some extra data
; 167  : 				hardPoint[i]->weaponPointer.reset(InitAGun(newOwnship, hardPoint[i]->weaponId, weapCnt[i]));

	mov	edx, DWORD PTR _weapCnt$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _newOwnship$[ebp]
	push	eax
	call	?InitAGun@@YAPAVSimWeaponClass@@PAVSimBaseClass@@GH@Z ; InitAGun
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 168  : 				SetFlag( GunOnBoard );

	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SMSBaseClass@@QAEXH@Z		; SMSBaseClass::SetFlag

; 169  : 			}
; 170  : 			else if (

	jmp	$LN15@SMSBaseCla
$LN13@SMSBaseCla:

; 171  : 				classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_MISSILE || 
; 172  : 				classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_ROCKET
; 173  : 			){

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 6
	je	SHORT $LN10@SMSBaseCla
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 8
	jne	$LN11@SMSBaseCla
$LN10@SMSBaseCla:

; 174  : 				// This is a Missile, create one for each shot (linked list)
; 175  : 				hardPoint[i]->weaponPointer = InitWeaponList(
; 176  : 					newOwnship, hardPoint[i]->weaponId, 
; 177  : 					hardPoint[i]->GetWeaponClass(), createCount, InitAMissile
; 178  : 				);

	push	0
	push	OFFSET ?InitAMissile@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z ; InitAMissile
	mov	ecx, DWORD PTR _createCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _newOwnship$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z ; InitWeaponList
	add	esp, 28					; 0000001cH
	mov	DWORD PTR tv536[ebp], eax
	mov	edx, DWORD PTR tv536[ebp]
	mov	DWORD PTR tv527[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv527[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>

; 179  : 			}
; 180  : 			else if (

	jmp	$LN15@SMSBaseCla
$LN11@SMSBaseCla:

; 181  : 				classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BOMB ||
; 182  : 				(
; 183  : 					classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_ELECTRONICS && 
; 184  : 					classPtr->vuClassData.classInfo_[VU_CLASS] == CLASS_VEHICLE
; 185  : 				) ||
; 186  : 				(
; 187  : 					classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_FUEL_TANK && 
; 188  : 					classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_FUEL_TANK
; 189  : 				) ||
; 190  : 				(
; 191  : 					classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_RECON && 
; 192  : 					classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_CAMERA
; 193  : 				)
; 194  : 			){

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 2
	je	$LN7@SMSBaseCla
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 3
	jne	SHORT $LN6@SMSBaseCla
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 7
	je	SHORT $LN7@SMSBaseCla
$LN6@SMSBaseCla:
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 4
	jne	SHORT $LN5@SMSBaseCla
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 1
	je	SHORT $LN7@SMSBaseCla
$LN5@SMSBaseCla:
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 7
	jne	$LN8@SMSBaseCla
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 1
	jne	$LN8@SMSBaseCla
$LN7@SMSBaseCla:

; 195  : 				// This is a Bomb or other dropable object, create one for each shot (linked list)
; 196  : 				hardPoint[i]->weaponPointer = InitWeaponList(
; 197  : 					newOwnship, hardPoint[i]->weaponId, hardPoint[i]->GetWeaponClass(), createCount, InitABomb
; 198  : 				);

	push	0
	push	OFFSET ?InitABomb@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z ; InitABomb
	mov	ecx, DWORD PTR _createCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _newOwnship$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z ; InitWeaponList
	add	esp, 28					; 0000001cH
	mov	DWORD PTR tv537[ebp], eax
	mov	edx, DWORD PTR tv537[ebp]
	mov	DWORD PTR tv529[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR tv529[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>

; 199  : 			}
; 200  : 	 		// MLR 3/5/2004 - launchers are "special" bombs
; 201  : 			else if (

	jmp	$LN15@SMSBaseCla
$LN8@SMSBaseCla:

; 202  : 				classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_LAUNCHER && 
; 203  : 				classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_ROCKET
; 204  : 			){

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 5
	jne	$LN3@SMSBaseCla
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 2
	jne	$LN3@SMSBaseCla

; 205  : 				if(hardPoint[i]->weaponCount == 19) // MLR 1/20/2004 - Kludge for IA

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	cmp	edx, 19					; 00000013H
	jne	SHORT $LN2@SMSBaseCla

; 206  : 				{
; 207  : 					hardPoint[i]->weaponCount=1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, 1
	mov	WORD PTR [eax+10], cx
$LN2@SMSBaseCla:

; 208  : 				}
; 209  : 				// This is a Bomb or other dropable object, create one for each shot (linked list)
; 210  : 				hardPoint[i]->weaponPointer = InitWeaponList(
; 211  : 					newOwnship, hardPoint[i]->weaponId, 
; 212  : 					hardPoint[i]->GetWeaponClass(), hardPoint[i]->weaponCount, InitABomb
; 213  : 				);

	push	0
	push	OFFSET ?InitABomb@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z ; InitABomb
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _newOwnship$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?InitWeaponList@@YA?AV?$VuBin@VSimWeaponClass@@@@PAVFalconEntity@@GHHP6APAVSimWeaponClass@@0GH@ZPAH@Z ; InitWeaponList
	add	esp, 28					; 0000001cH
	mov	DWORD PTR tv538[ebp], eax
	mov	edx, DWORD PTR tv538[ebp]
	mov	DWORD PTR tv531[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv531[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>

; 214  : 			}
; 215  : 			else {

	jmp	SHORT $LN15@SMSBaseCla
$LN3@SMSBaseCla:

; 216  : 				MonoPrint("Vehicle has unknown weapon type %d.\n",wd->Index);

	mov	ecx, DWORD PTR _wd$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CF@JFLIKKKJ@Vehicle?5has?5unknown?5weapon?5type?5@
	call	_MonoPrint
	add	esp, 8
$LN15@SMSBaseCla:

; 217  : 			}
; 218  : 		}
; 219  : 	}

	jmp	$LN19@SMSBaseCla
$LN33@SMSBaseCla:

; 220  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$1:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SMSBaseClass@@QAE@PAVSimVehicleClass@@PAFPAEH@Z ENDP	; SMSBaseClass::SMSBaseClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?PlayerFCC@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PlayerFCC@FireControlComputer@@QAEHXZ PROC		; FireControlComputer::PlayerFCC, COMDAT
; _this$ = ecx

; 286  : 	int PlayerFCC (void) {return playerFCC;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayerFCC@FireControlComputer@@QAEHXZ ENDP		; FireControlComputer::PlayerFCC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msm$ = 8						; size = 4
?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z PROC ; FireControlComputer::SetMrmSubMode, COMDAT
; _this$ = ecx

; 273  : 	void SetMrmSubMode (FCCSubMode msm) { mrmSubMode = msm;}; // ASSOCIATOR 04/12/03: for remembering MRM mode missiles

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _msm$[ebp]
	mov	DWORD PTR [eax+156], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ENDP ; FireControlComputer::SetMrmSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dsm$ = 8						; size = 4
?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z PROC ; FireControlComputer::SetDgftSubMode, COMDAT
; _this$ = ecx

; 272  : 	void SetDgftSubMode (FCCSubMode dsm) {dgftSubMode = dsm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dsm$[ebp]
	mov	DWORD PTR [eax+152], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ENDP ; FireControlComputer::SetDgftSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?GetRackSlot@SimWeaponClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRackSlot@SimWeaponClass@@QAEHXZ PROC		; SimWeaponClass::GetRackSlot, COMDAT
; _this$ = ecx

; 43   : 	int GetRackSlot (void) { return rackSlot; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+676]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRackSlot@SimWeaponClass@@QAEHXZ ENDP		; SimWeaponClass::GetRackSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?SetRackSlot@SimWeaponClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_slot$ = 8						; size = 4
?SetRackSlot@SimWeaponClass@@QAEXH@Z PROC		; SimWeaponClass::SetRackSlot, COMDAT
; _this$ = ecx

; 42   : 	void SetRackSlot (int slot) { rackSlot = slot; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _slot$[ebp]
	mov	DWORD PTR [eax+676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRackSlot@SimWeaponClass@@QAEXH@Z ENDP		; SimWeaponClass::SetRackSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ PROC		; SimWeaponClass::GetNextOnRail, COMDAT
; _this$ = ecx

; 41   : 	SimWeaponClass* GetNextOnRail(void) { return nextOnRail.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 672				; 000002a0H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ENDP		; SimWeaponClass::GetNextOnRail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?GetDOFValue@SimMoverClass@@QAEMH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_dof$ = 8						; size = 4
?GetDOFValue@SimMoverClass@@QAEMH@Z PROC		; SimMoverClass::GetDOFValue, COMDAT
; _this$ = ecx

; 132  : 	float GetDOFValue (int dof) { ShiAssert(dof < numDofs); return dof < numDofs ? DOFData[dof] : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dof$[ebp]
	cmp	ecx, DWORD PTR [eax+600]
	jge	SHORT $LN3@GetDOFValu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+612]
	mov	ecx, DWORD PTR _dof$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN4@GetDOFValu
$LN3@GetDOFValu:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv69[ebp], xmm0
$LN4@GetDOFValu:
	fld	DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDOFValue@SimMoverClass@@QAEMH@Z ENDP		; SimMoverClass::GetDOFValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetSType@SimBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@SimBaseClass@@QBEEXZ PROC			; SimBaseClass::GetSType, COMDAT
; _this$ = ecx

; 162  : 	uchar GetSType() const					{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@SimBaseClass@@QBEEXZ ENDP			; SimBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AList@@QAE@XZ PROC					; AList::~AList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AList@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AList@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__ehhandler$??1AList@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AList@@QAE@XZ ENDP					; AList::~AList
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hardpnt.h
;	COMDAT ?SetHPId@BasicWeaponStation@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?SetHPId@BasicWeaponStation@@QAEXH@Z PROC		; BasicWeaponStation::SetHPId, COMDAT
; _this$ = ecx

; 63   : 		void SetHPId(int id)  {hpId = id;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHPId@BasicWeaponStation@@QAEXH@Z ENDP		; BasicWeaponStation::SetHPId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newe$ = 8						; size = 4
?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z PROC ; VuBin<SimWeaponClass>::reset, COMDAT
; _this$ = ecx

; 60   : 	void reset(E *newe = NULL){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if (newe == e){ return; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newe$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@reset
	jmp	SHORT $LN2@reset
$LN1@reset:

; 62   : 		VuReferenceEntity(newe); // ref new pointer

	mov	edx, DWORD PTR _newe$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 63   : 		VuDeReferenceEntity(e);  // unref old pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 64   : 		e = newe;                // get new pointer

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@reset:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ENDP ; VuBin<SimWeaponClass>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator!, COMDAT
; _this$ = ecx

; 37   : 	bool operator!() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 		return e == NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 39   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z PROC	; VuBin<SimWeaponClass>::operator=, COMDAT
; _this$ = ecx

; 24   : 	const VuBin &operator=(const VuBin &rhs){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 		reset(rhs.e);

	mov	eax, DWORD PTR _rhs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 26   : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 27   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ENDP	; VuBin<SimWeaponClass>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??1?$VuBin@VSimWeaponClass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$VuBin@VSimWeaponClass@@@@QAE@XZ PROC		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 19   : 	~VuBin(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 		VuDeReferenceEntity((VuEntity *)e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 21   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$VuBin@VSimWeaponClass@@@@QAE@XZ ENDP		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VSimWeaponClass@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0?$VuBin@VSimWeaponClass@@@@QAE@ABV0@@Z PROC		; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 15   : 	VuBin(const VuBin &rhs) : e(rhs.e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 16   : 		VuReferenceEntity(e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 17   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VSimWeaponClass@@@@QAE@ABV0@@Z ENDP		; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z PROC ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 11   : 	explicit VuBin(E *e = NULL) : e(e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], ecx

; 12   : 		VuReferenceEntity(e);

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ENDP ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z PROC	; DrawableObject::GetPosition, COMDAT
; _this$ = ecx

; 28   : 	void GetPosition(Tpoint* pos){ *pos = position; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ENDP	; DrawableObject::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPR@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?SetYPR@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPR, COMDAT
; _this$ = ecx

; 113  : 	void SetYPR(SM_SCALAR yaw, SM_SCALAR pitch, SM_SCALAR roll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 115  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPR@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
