; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DISPLAYS\navhud.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
CONST	SEGMENT
_TrigWidth DD	03d23d70ar			; 0.04
_TrigHeight DD	03d99999ar			; 0.075
_L_2	DD	03f317218r			; 0.693147
_Lenght	DD	03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?DrawAirspeed@HudClass@@AAEXXZ			; HudClass::DrawAirspeed
PUBLIC	?DrawAltitude@HudClass@@AAEXXZ			; HudClass::DrawAltitude
PUBLIC	?DrawHeading@HudClass@@AAEXXZ			; HudClass::DrawHeading
PUBLIC	?DrawILS@HudClass@@AAEXXZ			; HudClass::DrawILS
PUBLIC	?DrawNav@HudClass@@AAEXXZ			; HudClass::DrawNav
PUBLIC	?DrawWaypoint@HudClass@@AAEXXZ			; HudClass::DrawWaypoint
PUBLIC	?TimeToSteerpoint@HudClass@@AAEXXZ		; HudClass::TimeToSteerpoint
PUBLIC	?RangeToSteerpoint@HudClass@@AAEXXZ		; HudClass::RangeToSteerpoint
PUBLIC	?DrawTadpole@HudClass@@AAEXXZ			; HudClass::DrawTadpole
PUBLIC	?DrawRollCue@HudClass@@AAEXXZ			; HudClass::DrawRollCue
PUBLIC	?RadToHudUnitsX@HudClass@@AAEMM@Z		; HudClass::RadToHudUnitsX
PUBLIC	?RadToHudUnitsY@HudClass@@AAEMM@Z		; HudClass::RadToHudUnitsY
PUBLIC	?FindRollAngle@HudClass@@QAEHM@Z		; HudClass::FindRollAngle
PUBLIC	?FindPitchAngle@HudClass@@QAEHM@Z		; HudClass::FindPitchAngle
PUBLIC	?CheckMSLFloor@HudClass@@QAEXXZ			; HudClass::CheckMSLFloor
PUBLIC	?DrawOA@HudClass@@QAEXXZ			; HudClass::DrawOA
PUBLIC	?DrawVIP@HudClass@@QAEXXZ			; HudClass::DrawVIP
PUBLIC	?DrawVRP@HudClass@@QAEXXZ			; HudClass::DrawVRP
PUBLIC	?DrawRALT@HudClass@@QAEXXZ			; HudClass::DrawRALT
PUBLIC	?DrawRALTBox@HudClass@@QAEXXZ			; HudClass::DrawRALTBox
PUBLIC	?DrawALString@HudClass@@QAEXXZ			; HudClass::DrawALString
PUBLIC	?DrawCMDSTRG@HudClass@@QAEXXZ			; HudClass::DrawCMDSTRG
PUBLIC	?DrawBankIndicator@HudClass@@QAEXXZ		; HudClass::DrawBankIndicator
PUBLIC	?DrawAirSpeedCarret@HudClass@@QAEXM@Z		; HudClass::DrawAirSpeedCarret
PUBLIC	?DrawAltCarret@HudClass@@QAEXM@Z		; HudClass::DrawAltCarret
PUBLIC	?DrawCruiseIndexes@HudClass@@QAEXXZ		; HudClass::DrawCruiseIndexes
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?SavedWaypoint@FireControlComputer@@QAEPAVWayPointClass@@XZ ; FireControlComputer::SavedWaypoint
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?IsAGMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsAGMasterMode
PUBLIC	?IsAAMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsAAMasterMode
PUBLIC	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
PUBLIC	?GetStptMode@FireControlComputer@@QAE?AW4FCCStptMode@1@XZ ; FireControlComputer::GetStptMode
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?GetINSLatDrift@AircraftClass@@QAEMXZ		; AircraftClass::GetINSLatDrift
PUBLIC	?GetINSLongDrift@AircraftClass@@QAEMXZ		; AircraftClass::GetINSLongDrift
PUBLIC	?GetINSAltOffset@AircraftClass@@QAEMXZ		; AircraftClass::GetINSAltOffset
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	?RaltReady@AircraftClass@@QAEHXZ		; AircraftClass::RaltReady
PUBLIC	?GetTypeAC@AirframeClass@@QAEHXZ		; AirframeClass::GetTypeAC
PUBLIC	?GetDragIndex@AirframeClass@@QAEMXZ		; AirframeClass::GetDragIndex
PUBLIC	?GetAltitudeSnd@AirframeClass@@QAEHXZ		; AirframeClass::GetAltitudeSnd
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ	; VirtualDisplay::ZeroRotationAboutOrigin
PUBLIC	?GetCMDSTR@ICPClass@@QAEHXZ			; ICPClass::GetCMDSTR
PUBLIC	?GetCruiseIndex@ICPClass@@QAEHXZ		; ICPClass::GetCruiseIndex
PUBLIC	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_01GAPBHFFA@T?$AA@				; `string'
PUBLIC	??_C@_01BBODEMC@G?$AA@				; `string'
PUBLIC	??_C@_03GLKEJMAA@?$CF4d?$AA@			; `string'
PUBLIC	??_C@_05JHCHPGNF@?5?$CF03d?$AA@			; `string'
PUBLIC	??_C@_04GHNNFJCK@?$CF?40f?$AA@			; `string'
PUBLIC	??_C@_07HDNLKEPD@?$CF02d?0?$CFd?$AA@		; `string'
PUBLIC	??_C@_06LDAHLMHO@?$CFd?$CF02d?$AA@		; `string'
PUBLIC	??_C@_07KFONKJBG@AL?5?$CF?40f?$AA@		; `string'
PUBLIC	??_C@_01DGKLNCNG@R?$AA@				; `string'
PUBLIC	??_C@_08MHFJHILJ@?$CF2d?0?$CF03d?$AA@		; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_09HIHJIMAB@?9?$CF2d?0?$CF03d?$AA@		; `string'
PUBLIC	??_C@_04OHGLKFFN@?$CF03d?$AA@			; `string'
PUBLIC	??_C@_04OGKJMPGK@?$CF02d?$AA@			; `string'
PUBLIC	??_C@_03NDEAONJP@?5?5?5?$AA@			; `string'
PUBLIC	??_C@_03GOOLIKIF@?$CF3d?$AA@			; `string'
PUBLIC	??_C@_03NEHPGBBG@010?$AA@			; `string'
PUBLIC	??_C@_02OCIIMEMP@01?$AA@			; `string'
PUBLIC	??_C@_09JFBOEAOE@?$CF03d?3?$CF02d?$AA@		; `string'
PUBLIC	??_C@_0N@JIJJHBFE@?5?5?5?$CF02d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_0N@FDANDMFD@?5?5?9?$CF02d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_0L@JMLBFLDA@?9?$CF02d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_05CJNIOAFN@XX?3XX?$AA@			; `string'
PUBLIC	??_C@_04JFGEPOPP@?$DO?$CFs?$DM?$AA@		; `string'
PUBLIC	??_C@_04NNJCMPBN@?$DM?$CFs?$DO?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0M@GJIKDFJJ@?$CF03?40f?$DO?$CF02d?$AA@	; `string'
PUBLIC	??_C@_06FGAEIJIJ@B?$CF3?41f?$AA@		; `string'
PUBLIC	??_C@_06KCELKNJK@F?$CF3?41f?$AA@		; `string'
PUBLIC	??_C@_07IDGFKELM@B0?$CF2?41f?$AA@		; `string'
PUBLIC	??_C@_07HCPKKEG@F0?$CF2?41f?$AA@		; `string'
PUBLIC	??_C@_08FJPPKIMH@B00?$CF1?41f?$AA@		; `string'
PUBLIC	??_C@_08EBDPJML@F00?$CF1?41f?$AA@		; `string'
PUBLIC	??_C@_08GDCGIJAL@B?50?$CF2?40f?$AA@		; `string'
PUBLIC	??_C@_08DOMKNIAH@F?50?$CF2?40f?$AA@		; `string'
PUBLIC	??_C@_07OPLBMDCI@F?5?$CF4?41f?$AA@		; `string'
PUBLIC	??_C@_08GFFHNBPG@F?5?$CF03?40f?$AA@		; `string'
PUBLIC	??_C@_02PJGLPOMM@AR?$AA@			; `string'
PUBLIC	??_C@_02CNCKMBBD@AL?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@392c987a
PUBLIC	__real@3a83126f
PUBLIC	__real@3b449ba6
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c449ba6
PUBLIC	__real@3c83126f
PUBLIC	__real@3c8efa34
PUBLIC	__real@3c9374bc
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3ccccccd
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3d75c28f
PUBLIC	__real@3d99999a
PUBLIC	__real@3db851ec
PUBLIC	__real@3dcccccd
PUBLIC	__real@3df5c28f
PUBLIC	__real@3e051eb8
PUBLIC	__real@3e19999a
PUBLIC	__real@3e23d70a
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e3851ec
PUBLIC	__real@3e400000
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e6147ae
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3ea3d70a
PUBLIC	__real@3eb2b8c1
PUBLIC	__real@3ec28f5c
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ed70a3d
PUBLIC	__real@3ee66666
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f19999a
PUBLIC	__real@3f1ae148
PUBLIC	__real@3f266666
PUBLIC	__real@3f3d70a4
PUBLIC	__real@3f400000
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3f8ccccd
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3feccccd
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40700000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41300000
PUBLIC	__real@41700000
PUBLIC	__real@41a00000
PUBLIC	__real@41c00000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42340000
PUBLIC	__real@42480000
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@42840000
PUBLIC	__real@42c80000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@43b40000
PUBLIC	__real@43fa0000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@44bb8000
PUBLIC	__real@453b8000
PUBLIC	__real@45610000
PUBLIC	__real@459c4000
PUBLIC	__real@45bde1b0
PUBLIC	__real@461c3c00
PUBLIC	__real@461c4000
PUBLIC	__real@466a6000
PUBLIC	__real@46c35000
PUBLIC	__real@47435000
PUBLIC	__real@47a8c000
PUBLIC	__real@48127c00
PUBLIC	__real@bccccccd
PUBLIC	__real@bd75c28f
PUBLIC	__real@bdb851ec
PUBLIC	__real@bdf5c28f
PUBLIC	__real@be19999a
PUBLIC	__real@be23d70a
PUBLIC	__real@be2e147b
PUBLIC	__real@be3851ec
PUBLIC	__real@be6147ae
PUBLIC	__real@be800000
PUBLIC	__real@bec7ae14
PUBLIC	__real@bedc28f6
PUBLIC	__real@bf000000
PUBLIC	__real@bf400000
PUBLIC	__real@bf490fd9
PUBLIC	__real@bf51eb85
PUBLIC	__real@bf547ae1
PUBLIC	__real@bf59999a
PUBLIC	__real@bf5eb852
PUBLIC	__real@bf6147ae
PUBLIC	__real@bf666666
PUBLIC	__real@bf6b851f
PUBLIC	__real@bf6e147b
PUBLIC	__real@bf733333
PUBLIC	__real@bf7851ec
PUBLIC	__real@bf800000
PUBLIC	__real@bfc90fd9
PUBLIC	__real@c0000000
PUBLIC	__real@c0400000
PUBLIC	__real@c0700000
PUBLIC	__real@c0a00000
PUBLIC	__real@c0c00000
PUBLIC	__real@c1c80000
PUBLIC	__real@c1f00000
PUBLIC	__real@c2700000
PUBLIC	__real@c3340000
PUBLIC	__real@c4960000
PUBLIC	__real@c4bb8000
PUBLIC	__real@c97423fe
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_sprintf:PROC
EXTRN	_abs:PROC
EXTRN	_fabs:PROC
EXTRN	_atoi:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?DrawTDBox@HudClass@@AAEXXZ:PROC		; HudClass::DrawTDBox
EXTRN	?DrawWindowString@HudClass@@AAEXHPADH@Z:PROC	; HudClass::DrawWindowString
EXTRN	?RadToHudUnits@HudClass@@AAEMM@Z:PROC		; HudClass::RadToHudUnits
EXTRN	?GetDriftCOSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDriftCOSwitch
EXTRN	?GetDEDSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDEDSwitch
EXTRN	_F4SoundFXSetDist:PROC
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ:PROC ; FireControlComputer::GetMainMasterMode
EXTRN	?GetWayPointNo@SimVehicleClass@@QAEPAVWayPointClass@@H@Z:PROC ; SimVehicleClass::GetWayPointNo
EXTRN	?GetOptimumAltitude@AirframeClass@@QAEMXZ:PROC	; AirframeClass::GetOptimumAltitude
EXTRN	?GetOptKias@AirframeClass@@QAEMH@Z:PROC		; AirframeClass::GetOptKias
EXTRN	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ:PROC ; OTWDriverClass::GetOTWDisplayMode
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z:PROC ; OTWDriverClass::GetApproxGroundLevel
EXTRN	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z:PROC ; VirtualDisplay::AdjustOriginInViewport
EXTRN	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z:PROC ; VirtualDisplay::AdjustRotationAboutOrigin
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z:PROC ; NavigationSystem::GetILSAttribute
EXTRN	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ:PROC ; NavigationSystem::GetInstrumentMode
EXTRN	?GetILSData@NavigationSystem@@QAEXPAM000@Z:PROC	; NavigationSystem::GetILSData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?hudWinX@@3PAMA:BYTE				; hudWinX
EXTRN	?hudWinY@@3PAMA:BYTE				; hudWinY
EXTRN	?hudWinWidth@@3PAMA:BYTE			; hudWinWidth
EXTRN	?hudWinHeight@@3PAMA:BYTE			; hudWinHeight
EXTRN	?hudNumbers@@3PAPADA:BYTE			; hudNumbers
EXTRN	?flash@HudClass@@0HA:DWORD			; HudClass::flash
EXTRN	?Warnflash@HudClass@@0HA:DWORD			; HudClass::Warnflash
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?cockpitFlightData@@3VFlightData@@A:BYTE	; cockpitFlightData
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
EXTRN	?g_bFallingHeadingTape@@3_NA:BYTE		; g_bFallingHeadingTape
EXTRN	?g_bINS@@3_NA:BYTE				; g_bINS
EXTRN	?g_bHUDFix@@3_NA:BYTE				; g_bHUDFix
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?HEADING_BOTTOM@?1??DrawHeading@HudClass@@AAEXXZ@4MA
_BSS	SEGMENT
?HEADING_BOTTOM@?1??DrawHeading@HudClass@@AAEXXZ@4MA DD 01H DUP (?) ; `HudClass::DrawHeading'::`2'::HEADING_BOTTOM
_BSS	ENDS
;	COMDAT ?HEADING_BOTTOM@?6??DrawWaypoint@HudClass@@AAEXXZ@4MA
_BSS	SEGMENT
?HEADING_BOTTOM@?6??DrawWaypoint@HudClass@@AAEXXZ@4MA DD 01H DUP (?) ; `HudClass::DrawWaypoint'::`7'::HEADING_BOTTOM
_BSS	ENDS
;	COMDAT ?basey@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
_BSS	SEGMENT
?basey@?1??DrawRollCue@HudClass@@AAEXXZ@4MB DD 01H DUP (?) ; `HudClass::DrawRollCue'::`2'::basey
_BSS	ENDS
;	COMDAT ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA
_BSS	SEGMENT
?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA DD 01H DUP (?) ; `HudClass::DrawRollCue'::`2'::$S1
_BSS	ENDS
;	COMDAT ?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB
_BSS	SEGMENT
?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB DD 04H DUP (?) ; `HudClass::DrawRollCue'::`2'::angles
_BSS	ENDS
;	COMDAT ?x1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA
_BSS	SEGMENT
?x1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA DD 04H DUP (?) ; `HudClass::DrawRollCue'::`2'::x1points
_BSS	ENDS
;	COMDAT ?x2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA
_BSS	SEGMENT
?x2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA DD 04H DUP (?) ; `HudClass::DrawRollCue'::`2'::x2points
_BSS	ENDS
;	COMDAT ?y1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA
_BSS	SEGMENT
?y1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA DD 04H DUP (?) ; `HudClass::DrawRollCue'::`2'::y1points
_BSS	ENDS
;	COMDAT ?y2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA
_BSS	SEGMENT
?y2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA DD 04H DUP (?) ; `HudClass::DrawRollCue'::`2'::y2points
_BSS	ENDS
;	COMDAT ?x1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA
_BSS	SEGMENT
?x1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA DD 09H DUP (?) ; `HudClass::DrawBankIndicator'::`2'::x1points
_BSS	ENDS
;	COMDAT ?x2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA
_BSS	SEGMENT
?x2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA DD 09H DUP (?) ; `HudClass::DrawBankIndicator'::`2'::x2points
_BSS	ENDS
;	COMDAT ?y1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA
_BSS	SEGMENT
?y1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA DD 09H DUP (?) ; `HudClass::DrawBankIndicator'::`2'::y1points
_BSS	ENDS
;	COMDAT ?y2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA
_BSS	SEGMENT
?y2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA DD 09H DUP (?) ; `HudClass::DrawBankIndicator'::`2'::y2points
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c97423fe
CONST	SEGMENT
__real@c97423fe DD 0c97423fer			; -1e+006
CONST	ENDS
;	COMDAT __real@c4bb8000
CONST	SEGMENT
__real@c4bb8000 DD 0c4bb8000r			; -1500
CONST	ENDS
;	COMDAT __real@c4960000
CONST	SEGMENT
__real@c4960000 DD 0c4960000r			; -1200
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c2700000
CONST	SEGMENT
__real@c2700000 DD 0c2700000r			; -60
CONST	ENDS
;	COMDAT __real@c1f00000
CONST	SEGMENT
__real@c1f00000 DD 0c1f00000r			; -30
CONST	ENDS
;	COMDAT __real@c1c80000
CONST	SEGMENT
__real@c1c80000 DD 0c1c80000r			; -25
CONST	ENDS
;	COMDAT __real@c0c00000
CONST	SEGMENT
__real@c0c00000 DD 0c0c00000r			; -6
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@c0700000
CONST	SEGMENT
__real@c0700000 DD 0c0700000r			; -3.75
CONST	ENDS
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bfc90fd9
CONST	SEGMENT
__real@bfc90fd9 DD 0bfc90fd9r			; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf7851ec
CONST	SEGMENT
__real@bf7851ec DD 0bf7851ecr			; -0.97
CONST	ENDS
;	COMDAT __real@bf733333
CONST	SEGMENT
__real@bf733333 DD 0bf733333r			; -0.95
CONST	ENDS
;	COMDAT __real@bf6e147b
CONST	SEGMENT
__real@bf6e147b DD 0bf6e147br			; -0.93
CONST	ENDS
;	COMDAT __real@bf6b851f
CONST	SEGMENT
__real@bf6b851f DD 0bf6b851fr			; -0.92
CONST	ENDS
;	COMDAT __real@bf666666
CONST	SEGMENT
__real@bf666666 DD 0bf666666r			; -0.9
CONST	ENDS
;	COMDAT __real@bf6147ae
CONST	SEGMENT
__real@bf6147ae DD 0bf6147aer			; -0.88
CONST	ENDS
;	COMDAT __real@bf5eb852
CONST	SEGMENT
__real@bf5eb852 DD 0bf5eb852r			; -0.87
CONST	ENDS
;	COMDAT __real@bf59999a
CONST	SEGMENT
__real@bf59999a DD 0bf59999ar			; -0.85
CONST	ENDS
;	COMDAT __real@bf547ae1
CONST	SEGMENT
__real@bf547ae1 DD 0bf547ae1r			; -0.83
CONST	ENDS
;	COMDAT __real@bf51eb85
CONST	SEGMENT
__real@bf51eb85 DD 0bf51eb85r			; -0.82
CONST	ENDS
;	COMDAT __real@bf490fd9
CONST	SEGMENT
__real@bf490fd9 DD 0bf490fd9r			; -0.785398
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@bedc28f6
CONST	SEGMENT
__real@bedc28f6 DD 0bedc28f6r			; -0.43
CONST	ENDS
;	COMDAT __real@bec7ae14
CONST	SEGMENT
__real@bec7ae14 DD 0bec7ae14r			; -0.39
CONST	ENDS
;	COMDAT __real@be800000
CONST	SEGMENT
__real@be800000 DD 0be800000r			; -0.25
CONST	ENDS
;	COMDAT __real@be6147ae
CONST	SEGMENT
__real@be6147ae DD 0be6147aer			; -0.22
CONST	ENDS
;	COMDAT __real@be3851ec
CONST	SEGMENT
__real@be3851ec DD 0be3851ecr			; -0.18
CONST	ENDS
;	COMDAT __real@be2e147b
CONST	SEGMENT
__real@be2e147b DD 0be2e147br			; -0.17
CONST	ENDS
;	COMDAT __real@be23d70a
CONST	SEGMENT
__real@be23d70a DD 0be23d70ar			; -0.16
CONST	ENDS
;	COMDAT __real@be19999a
CONST	SEGMENT
__real@be19999a DD 0be19999ar			; -0.15
CONST	ENDS
;	COMDAT __real@bdf5c28f
CONST	SEGMENT
__real@bdf5c28f DD 0bdf5c28fr			; -0.12
CONST	ENDS
;	COMDAT __real@bdb851ec
CONST	SEGMENT
__real@bdb851ec DD 0bdb851ecr			; -0.09
CONST	ENDS
;	COMDAT __real@bd75c28f
CONST	SEGMENT
__real@bd75c28f DD 0bd75c28fr			; -0.06
CONST	ENDS
;	COMDAT __real@bccccccd
CONST	SEGMENT
__real@bccccccd DD 0bccccccdr			; -0.025
CONST	ENDS
;	COMDAT __real@48127c00
CONST	SEGMENT
__real@48127c00 DD 048127c00r			; 150000
CONST	ENDS
;	COMDAT __real@47a8c000
CONST	SEGMENT
__real@47a8c000 DD 047a8c000r			; 86400
CONST	ENDS
;	COMDAT __real@47435000
CONST	SEGMENT
__real@47435000 DD 047435000r			; 50000
CONST	ENDS
;	COMDAT __real@46c35000
CONST	SEGMENT
__real@46c35000 DD 046c35000r			; 25000
CONST	ENDS
;	COMDAT __real@466a6000
CONST	SEGMENT
__real@466a6000 DD 0466a6000r			; 15000
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
CONST	ENDS
;	COMDAT __real@45610000
CONST	SEGMENT
__real@45610000 DD 045610000r			; 3600
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@44bb8000
CONST	SEGMENT
__real@44bb8000 DD 044bb8000r			; 1500
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42840000
CONST	SEGMENT
__real@42840000 DD 042840000r			; 66
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40700000
CONST	SEGMENT
__real@40700000 DD 040700000r			; 3.75
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3feccccd
CONST	SEGMENT
__real@3feccccd DD 03feccccdr			; 1.85
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f3d70a4
CONST	SEGMENT
__real@3f3d70a4 DD 03f3d70a4r			; 0.74
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f1ae148
CONST	SEGMENT
__real@3f1ae148 DD 03f1ae148r			; 0.605
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3ed70a3d
CONST	SEGMENT
__real@3ed70a3d DD 03ed70a3dr			; 0.42
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3ec28f5c
CONST	SEGMENT
__real@3ec28f5c DD 03ec28f5cr			; 0.38
CONST	ENDS
;	COMDAT __real@3eb2b8c1
CONST	SEGMENT
__real@3eb2b8c1 DD 03eb2b8c1r			; 0.349066
CONST	ENDS
;	COMDAT __real@3ea3d70a
CONST	SEGMENT
__real@3ea3d70a DD 03ea3d70ar			; 0.32
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e6147ae
CONST	SEGMENT
__real@3e6147ae DD 03e6147aer			; 0.22
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e400000
CONST	SEGMENT
__real@3e400000 DD 03e400000r			; 0.1875
CONST	ENDS
;	COMDAT __real@3e3851ec
CONST	SEGMENT
__real@3e3851ec DD 03e3851ecr			; 0.18
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@3e23d70a
CONST	SEGMENT
__real@3e23d70a DD 03e23d70ar			; 0.16
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e051eb8
CONST	SEGMENT
__real@3e051eb8 DD 03e051eb8r			; 0.13
CONST	ENDS
;	COMDAT __real@3df5c28f
CONST	SEGMENT
__real@3df5c28f DD 03df5c28fr			; 0.12
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db851ec
CONST	SEGMENT
__real@3db851ec DD 03db851ecr			; 0.09
CONST	ENDS
;	COMDAT __real@3d99999a
CONST	SEGMENT
__real@3d99999a DD 03d99999ar			; 0.075
CONST	ENDS
;	COMDAT __real@3d75c28f
CONST	SEGMENT
__real@3d75c28f DD 03d75c28fr			; 0.06
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3ccccccd
CONST	SEGMENT
__real@3ccccccd DD 03ccccccdr			; 0.025
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c9374bc
CONST	SEGMENT
__real@3c9374bc DD 03c9374bcr			; 0.018
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c83126f
CONST	SEGMENT
__real@3c83126f DD 03c83126fr			; 0.016
CONST	ENDS
;	COMDAT __real@3c449ba6
CONST	SEGMENT
__real@3c449ba6 DD 03c449ba6r			; 0.012
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b449ba6
CONST	SEGMENT
__real@3b449ba6 DD 03b449ba6r			; 0.003
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ?oedist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA
_DATA	SEGMENT
?oedist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA DD 03e051eb8r ; 0.13 ; `HudClass::DrawBankIndicator'::`2'::oedist
_DATA	ENDS
;	COMDAT ?sdist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA
_DATA	SEGMENT
?sdist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA DD 03de147aer ; 0.11 ; `HudClass::DrawBankIndicator'::`2'::sdist
_DATA	ENDS
;	COMDAT ?angles@?1??DrawBankIndicator@HudClass@@QAEXXZ@4QBMB
CONST	SEGMENT
?angles@?1??DrawBankIndicator@HudClass@@QAEXXZ@4QBMB DD 03f860a91r ; 1.0472 ; `HudClass::DrawBankIndicator'::`2'::angles
	DD	03f060a91r			; 0.523599
	DD	03eb2b8c1r			; 0.349066
	DD	03e32b8c1r			; 0.174533
	DD	000000000r			; 0
	DD	0be32b8c1r			; -0.174533
	DD	0beb2b8c1r			; -0.349066
	DD	0bf060a91r			; -0.523599
	DD	0bf860a91r			; -1.0472
CONST	ENDS
;	COMDAT ??_C@_02CNCKMBBD@AL?$AA@
CONST	SEGMENT
??_C@_02CNCKMBBD@AL?$AA@ DB 'AL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJGLPOMM@AR?$AA@
CONST	SEGMENT
??_C@_02PJGLPOMM@AR?$AA@ DB 'AR', 00H			; `string'
CONST	ENDS
;	COMDAT ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
CONST	SEGMENT
?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB DD 03ecccccdr ; 0.4 ; `HudClass::DrawRollCue'::`2'::oedist
CONST	ENDS
;	COMDAT ?sdist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
CONST	SEGMENT
?sdist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB DD 03eb33333r ; 0.35 ; `HudClass::DrawRollCue'::`2'::sdist
CONST	ENDS
;	COMDAT ?MAXROLL@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
CONST	SEGMENT
?MAXROLL@?1??DrawRollCue@HudClass@@AAEXXZ@4MB DD 03f490fd9r ; 0.785398 ; `HudClass::DrawRollCue'::`2'::MAXROLL
CONST	ENDS
;	COMDAT ??_C@_08GFFHNBPG@F?5?$CF03?40f?$AA@
CONST	SEGMENT
??_C@_08GFFHNBPG@F?5?$CF03?40f?$AA@ DB 'F %03.0f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OPLBMDCI@F?5?$CF4?41f?$AA@
CONST	SEGMENT
??_C@_07OPLBMDCI@F?5?$CF4?41f?$AA@ DB 'F %4.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DOMKNIAH@F?50?$CF2?40f?$AA@
CONST	SEGMENT
??_C@_08DOMKNIAH@F?50?$CF2?40f?$AA@ DB 'F 0%2.0f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDCGIJAL@B?50?$CF2?40f?$AA@
CONST	SEGMENT
??_C@_08GDCGIJAL@B?50?$CF2?40f?$AA@ DB 'B 0%2.0f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBDPJML@F00?$CF1?41f?$AA@
CONST	SEGMENT
??_C@_08EBDPJML@F00?$CF1?41f?$AA@ DB 'F00%1.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJPPKIMH@B00?$CF1?41f?$AA@
CONST	SEGMENT
??_C@_08FJPPKIMH@B00?$CF1?41f?$AA@ DB 'B00%1.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCPKKEG@F0?$CF2?41f?$AA@
CONST	SEGMENT
??_C@_07HCPKKEG@F0?$CF2?41f?$AA@ DB 'F0%2.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDGFKELM@B0?$CF2?41f?$AA@
CONST	SEGMENT
??_C@_07IDGFKELM@B0?$CF2?41f?$AA@ DB 'B0%2.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCELKNJK@F?$CF3?41f?$AA@
CONST	SEGMENT
??_C@_06KCELKNJK@F?$CF3?41f?$AA@ DB 'F%3.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FGAEIJIJ@B?$CF3?41f?$AA@
CONST	SEGMENT
??_C@_06FGAEIJIJ@B?$CF3?41f?$AA@ DB 'B%3.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GJIKDFJJ@?$CF03?40f?$DO?$CF02d?$AA@
CONST	SEGMENT
??_C@_0M@GJIKDFJJ@?$CF03?40f?$DO?$CF02d?$AA@ DB '%03.0f>%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NNJCMPBN@?$DM?$CFs?$DO?$AA@
CONST	SEGMENT
??_C@_04NNJCMPBN@?$DM?$CFs?$DO?$AA@ DB '<%s>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFGEPOPP@?$DO?$CFs?$DM?$AA@
CONST	SEGMENT
??_C@_04JFGEPOPP@?$DO?$CFs?$DM?$AA@ DB '>%s<', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CJNIOAFN@XX?3XX?$AA@
CONST	SEGMENT
??_C@_05CJNIOAFN@XX?3XX?$AA@ DB 'XX:XX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JMLBFLDA@?9?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0L@JMLBFLDA@?9?$CF02d?3?$CF02d?$AA@ DB '-%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDANDMFD@?5?5?9?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@FDANDMFD@?5?5?9?$CF02d?3?$CF02d?$AA@ DB '  -%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIJJHBFE@?5?5?5?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@JIJJHBFE@?5?5?5?$CF02d?3?$CF02d?$AA@ DB '   %02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFBOEAOE@?$CF03d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_09JFBOEAOE@?$CF03d?3?$CF02d?$AA@ DB '%03d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OCIIMEMP@01?$AA@
CONST	SEGMENT
??_C@_02OCIIMEMP@01?$AA@ DB '01', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NEHPGBBG@010?$AA@
CONST	SEGMENT
??_C@_03NEHPGBBG@010?$AA@ DB '010', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOOLIKIF@?$CF3d?$AA@
CONST	SEGMENT
??_C@_03GOOLIKIF@?$CF3d?$AA@ DB '%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDEAONJP@?5?5?5?$AA@
CONST	SEGMENT
??_C@_03NDEAONJP@?5?5?5?$AA@ DB '   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OGKJMPGK@?$CF02d?$AA@
CONST	SEGMENT
??_C@_04OGKJMPGK@?$CF02d?$AA@ DB '%02d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHGLKFFN@?$CF03d?$AA@
CONST	SEGMENT
??_C@_04OHGLKFFN@?$CF03d?$AA@ DB '%03d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIHJIMAB@?9?$CF2d?0?$CF03d?$AA@
CONST	SEGMENT
??_C@_09HIHJIMAB@?9?$CF2d?0?$CF03d?$AA@ DB '-%2d,%03d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHFJHILJ@?$CF2d?0?$CF03d?$AA@
CONST	SEGMENT
??_C@_08MHFJHILJ@?$CF2d?0?$CF03d?$AA@ DB '%2d,%03d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01DGKLNCNG@R?$AA@
CONST	SEGMENT
??_C@_01DGKLNCNG@R?$AA@ DB 'R', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFONKJBG@AL?5?$CF?40f?$AA@
CONST	SEGMENT
??_C@_07KFONKJBG@AL?5?$CF?40f?$AA@ DB 'AL %.0f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LDAHLMHO@?$CFd?$CF02d?$AA@
CONST	SEGMENT
??_C@_06LDAHLMHO@?$CFd?$CF02d?$AA@ DB '%d%02d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDNLKEPD@?$CF02d?0?$CFd?$AA@
CONST	SEGMENT
??_C@_07HDNLKEPD@?$CF02d?0?$CFd?$AA@ DB '%02d,%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHNNFJCK@?$CF?40f?$AA@
CONST	SEGMENT
??_C@_04GHNNFJCK@?$CF?40f?$AA@ DB '%.0f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JHCHPGNF@?5?$CF03d?$AA@
CONST	SEGMENT
??_C@_05JHCHPGNF@?5?$CF03d?$AA@ DB ' %03d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GLKEJMAA@?$CF4d?$AA@
CONST	SEGMENT
??_C@_03GLKEJMAA@?$CF4d?$AA@ DB '%4d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BBODEMC@G?$AA@
CONST	SEGMENT
??_C@_01BBODEMC@G?$AA@ DB 'G', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T?$AA@
CONST	SEGMENT
??_C@_01GAPBHFFA@T?$AA@ DB 'T', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\harmpod.h
;	COMDAT ?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ PROC	; HarmTargetingPod::GetSubMode, COMDAT
; _this$ = ecx

; 83   : 	Submode			GetSubMode ( void ) { return submode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+168]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ENDP	; HarmTargetingPod::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?GetCruiseIndex@ICPClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCruiseIndex@ICPClass@@QAEHXZ PROC			; ICPClass::GetCruiseIndex, COMDAT
; _this$ = ecx

; 359  : 	int GetCruiseIndex(void)	{return CruiseMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCruiseIndex@ICPClass@@QAEHXZ ENDP			; ICPClass::GetCruiseIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?GetCMDSTR@ICPClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCMDSTR@ICPClass@@QAEHXZ PROC			; ICPClass::GetCMDSTR, COMDAT
; _this$ = ecx

; 243  : 	BOOL GetCMDSTR(void)	{return CMDSTRG;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1501]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCMDSTR@ICPClass@@QAEHXZ ENDP			; ICPClass::GetCMDSTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::ZeroRotationAboutOrigin, COMDAT
; _this$ = ecx

; 144  :     void ZeroRotationAboutOrigin( void ) { dmatrix.rotation01 = dmatrix.rotation10 = 0.0f, dmatrix.rotation00 = dmatrix.rotation11 = 1.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+84], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+80], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+88], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+76], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::ZeroRotationAboutOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetAltitudeSnd@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAltitudeSnd@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetAltitudeSnd, COMDAT
; _this$ = ecx

; 1231 : 	int GetAltitudeSnd() { return auxaeroData->sndBBAltitude; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+2416]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAltitudeSnd@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetAltitudeSnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetDragIndex@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDragIndex@AirframeClass@@QAEMXZ PROC		; AirframeClass::GetDragIndex, COMDAT
; _this$ = ecx

; 1211 : 	float GetDragIndex(void) {return dragIndex;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDragIndex@AirframeClass@@QAEMXZ ENDP		; AirframeClass::GetDragIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetTypeAC@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTypeAC@AirframeClass@@QAEHXZ PROC			; AirframeClass::GetTypeAC, COMDAT
; _this$ = ecx

; 809  : 	int GetTypeAC() {return auxaeroData->typeAC;};//TJL 02/28/04

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+3880]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTypeAC@AirframeClass@@QAEHXZ ENDP			; AirframeClass::GetTypeAC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?RaltReady@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?RaltReady@AircraftClass@@QAEHXZ PROC			; AircraftClass::RaltReady, COMDAT
; _this$ = ecx

; 416  : 	int RaltReady() { return (RALTCoolTime < 0.0F && RALTStatus == RON) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+1008]
	jbe	SHORT $LN3@RaltReady
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1004], 2
	jne	SHORT $LN3@RaltReady
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@RaltReady
$LN3@RaltReady:
	mov	DWORD PTR tv68[ebp], 0
$LN4@RaltReady:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RaltReady@AircraftClass@@QAEHXZ ENDP			; AircraftClass::RaltReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetINSAltOffset@AircraftClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetINSAltOffset@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetINSAltOffset, COMDAT
; _this$ = ecx

; 223  : 	float GetINSAltOffset(void)	{return INSAltOffset;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+812]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetINSAltOffset@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetINSAltOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetINSLongDrift@AircraftClass@@QAEMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?GetINSLongDrift@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetINSLongDrift, COMDAT
; _this$ = ecx

; 222  : 	float GetINSLongDrift(void)	{return (INSLongDrift + INSLongOffset);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+792]
	addss	xmm0, DWORD PTR [ecx+808]
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetINSLongDrift@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetINSLongDrift
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetINSLatDrift@AircraftClass@@QAEMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?GetINSLatDrift@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetINSLatDrift, COMDAT
; _this$ = ecx

; 221  : 	float GetINSLatDrift(void)	{return (INSLatDrift + INSLatOffset);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+788]
	addss	xmm0, DWORD PTR [ecx+804]
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetINSLatDrift@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetINSLatDrift
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetStptMode@FireControlComputer@@QAE?AW4FCCStptMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetStptMode@FireControlComputer@@QAE?AW4FCCStptMode@1@XZ PROC ; FireControlComputer::GetStptMode, COMDAT
; _this$ = ecx

; 295  : 	FCCStptMode GetStptMode(void) {return mStptMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+124]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStptMode@FireControlComputer@@QAE?AW4FCCStptMode@1@XZ ENDP ; FireControlComputer::GetStptMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ PROC ; FireControlComputer::GetSubMode, COMDAT
; _this$ = ecx

; 281  : 	FCCSubMode GetSubMode (void) {return (subMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ENDP ; FireControlComputer::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsAAMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsAAMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsAAMasterMode, COMDAT
; _this$ = ecx

; 279  : 	int IsAAMasterMode() { return GetMainMasterMode() == MM_AA; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 1
	jne	SHORT $LN3@IsAAMaster
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAAMaster
$LN3@IsAAMaster:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAAMaster:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAAMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsAAMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsAGMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsAGMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsAGMasterMode, COMDAT
; _this$ = ecx

; 278  : 	int IsAGMasterMode() { return GetMainMasterMode() == MM_AG; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	test	eax, eax
	jne	SHORT $LN3@IsAGMaster
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAGMaster
$LN3@IsAGMaster:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAGMaster:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAGMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsAGMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SavedWaypoint@FireControlComputer@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SavedWaypoint@FireControlComputer@@QAEPAVWayPointClass@@XZ PROC ; FireControlComputer::SavedWaypoint, COMDAT
; _this$ = ecx

; 212  : 	WayPointClass* SavedWaypoint() { return mpSavedWaypoint; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?SavedWaypoint@FireControlComputer@@QAEPAVWayPointClass@@XZ ENDP ; FireControlComputer::SavedWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv783 = -228						; size = 4
tv797 = -224						; size = 4
tv770 = -220						; size = 4
tv567 = -216						; size = 4
tv748 = -212						; size = 4
_decentpoint$1 = -208					; size = 4
tv735 = -204						; size = 4
_zCurr$2 = -200						; size = 4
tv709 = -196						; size = 4
tv618 = -192						; size = 4
tv696 = -188						; size = 4
tv590 = -184						; size = 4
tv680 = -180						; size = 4
tv562 = -176						; size = 4
tv801 = -172						; size = 4
tv637 = -168						; size = 4
tv675 = -164						; size = 4
tv632 = -160						; size = 4
tv671 = -156						; size = 4
tv605 = -152						; size = 4
tv666 = -148						; size = 4
_distanceToSta$3 = -144					; size = 4
tv661 = -140						; size = 4
tv580 = -136						; size = 4
tv799 = -132						; size = 4
_yCurr$4 = -128						; size = 4
tv656 = -124						; size = 4
tv527 = -120						; size = 4
tv651 = -116						; size = 4
tv540 = -112						; size = 4
tv642 = -108						; size = 4
_xCurr$5 = -104						; size = 4
tv443 = -100						; size = 4
tv161 = -96						; size = 4
tv442 = -92						; size = 4
_deltaY$6 = -88						; size = 4
tv429 = -84						; size = 4
tv82 = -80						; size = 4
tv403 = -76						; size = 4
_wp$7 = -72						; size = 4
tv402 = -68						; size = 4
tv90 = -64						; size = 4
tv389 = -60						; size = 4
tv72 = -56						; size = 4
tv361 = -52						; size = 4
_deltaX$8 = -48						; size = 4
tv360 = -44						; size = 4
tv162 = -40						; size = 4
tv347 = -36						; size = 4
tv148 = -32						; size = 4
tv264 = -28						; size = 4
tv89 = -24						; size = 4
tv263 = -20						; size = 4
tv250 = -16						; size = 4
tv226 = -12						; size = 4
_this$ = -8						; size = 4
_playerAC$ = -4						; size = 4
?DrawCruiseIndexes@HudClass@@QAEXXZ PROC		; HudClass::DrawCruiseIndexes
; _this$ = ecx

; 2698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	DWORD PTR _this$[ebp], ecx

; 2699 : 	if(!OTWDriver.pCockpitManager || !OTWDriver.pCockpitManager->mpIcp){

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN20@DrawCruise
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [eax+688], 0
	jne	SHORT $LN21@DrawCruise
$LN20@DrawCruise:

; 2700 : 		return;

	jmp	$LN22@DrawCruise
$LN21@DrawCruise:

; 2701 : 	}
; 2702 : 
; 2703 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2704 : 	switch(OTWDriver.pCockpitManager->mpIcp->GetCruiseIndex())

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?GetCruiseIndex@ICPClass@@QAEHXZ	; ICPClass::GetCruiseIndex
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 3
	ja	$LN1@DrawCruise
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN62@DrawCruise[edx*4]
$LN17@DrawCruise:

; 2705 : 	{
; 2706 : 		case 0:	//Cruise TOS
; 2707 : 			//Speed
; 2708 : 			DrawAirSpeedCarret(waypointSpeed);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4928]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirSpeedCarret@HudClass@@QAEXM@Z	; HudClass::DrawAirSpeedCarret

; 2709 : 			sprintf(SpeedText, "%.0f", max( min(waypointSpeed, 9999.0F), 0.0F));

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR [ecx+4928]
	jbe	SHORT $LN24@DrawCruise
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4928]
	movss	DWORD PTR tv82[ebp], xmm0
	jmp	SHORT $LN25@DrawCruise
$LN24@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv82[ebp], xmm0
$LN25@DrawCruise:
	movss	xmm0, DWORD PTR tv82[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN28@DrawCruise
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR [eax+4928]
	jbe	SHORT $LN26@DrawCruise
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4928]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN27@DrawCruise
$LN26@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv89[ebp], xmm0
$LN27@DrawCruise:
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN29@DrawCruise
$LN28@DrawCruise:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv90[ebp], xmm0
$LN29@DrawCruise:
	cvtss2sd xmm0, DWORD PTR tv90[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5107				; 000013f3H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2710 : 			break;

	jmp	$LN18@DrawCruise
$LN16@DrawCruise:

; 2711 : 		case 1:	//Cruise RNG
; 2712 : 			//Speed
; 2713 : 			if(playerAC &&  playerAC->af)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN15@DrawCruise
	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	$LN15@DrawCruise

; 2714 : 			{
; 2715 : 				DrawAirSpeedCarret(playerAC->af->GetOptKias(2));

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirSpeedCarret@HudClass@@QAEXM@Z	; HudClass::DrawAirSpeedCarret

; 2716 : 				sprintf(SpeedText, "%.0f", max(min(playerAC->af->GetOptKias(2), 9999.0F), 0.0F));

	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv527[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv527[ebp]
	jbe	SHORT $LN30@DrawCruise
	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv148[ebp]
	jmp	SHORT $LN31@DrawCruise
$LN30@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv148[ebp], xmm0
$LN31@DrawCruise:
	movss	xmm0, DWORD PTR tv148[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN34@DrawCruise
	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv540[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv540[ebp]
	jbe	SHORT $LN32@DrawCruise
	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv161[ebp]
	jmp	SHORT $LN33@DrawCruise
$LN32@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv161[ebp], xmm0
$LN33@DrawCruise:
	movss	xmm0, DWORD PTR tv161[ebp]
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN35@DrawCruise
$LN34@DrawCruise:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv162[ebp], xmm0
$LN35@DrawCruise:
	cvtss2sd xmm0, DWORD PTR tv162[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5107				; 000013f3H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN15@DrawCruise:

; 2717 : 			}
; 2718 : 			break;

	jmp	$LN18@DrawCruise
$LN14@DrawCruise:

; 2719 : 		case 2:	//Cruise Home
; 2720 : 			//opt speed and alt with climb profile and such
; 2721 : 			if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp && playerAC)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	$LN4@DrawCruise
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	$LN4@DrawCruise
	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN4@DrawCruise

; 2722 : 			{
; 2723 : 				float xCurr, yCurr, zCurr = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _zCurr$2[ebp], xmm0

; 2724 : 				WayPointClass *wp = playerAC->GetWayPointNo(
; 2725 : 						OTWDriver.pCockpitManager->mpIcp->HomeWP);

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR [eax+440]
	push	ecx
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetWayPointNo@SimVehicleClass@@QAEPAVWayPointClass@@H@Z ; SimVehicleClass::GetWayPointNo
	mov	DWORD PTR _wp$7[ebp], eax

; 2726 : 				if(wp)

	cmp	DWORD PTR _wp$7[ebp], 0
	je	$LN4@DrawCruise

; 2727 : 				{		
; 2728 : 					wp->GetLocation(&xCurr, &yCurr,&zCurr);

	lea	edx, DWORD PTR _zCurr$2[ebp]
	push	edx
	lea	eax, DWORD PTR _yCurr$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _xCurr$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wp$7[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 2729 : 					float deltaX			= xCurr - playerAC->XPos();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv562[ebp]
	movss	xmm0, DWORD PTR _xCurr$5[ebp]
	subss	xmm0, DWORD PTR tv562[ebp]
	movss	DWORD PTR _deltaX$8[ebp], xmm0

; 2730 : 					float deltaY			= yCurr - playerAC->YPos();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv567[ebp]
	movss	xmm0, DWORD PTR _yCurr$4[ebp]
	subss	xmm0, DWORD PTR tv567[ebp]
	movss	DWORD PTR _deltaY$6[ebp], xmm0

; 2731 : 					float distanceToSta	= (float)sqrt(deltaX * deltaX + deltaY * deltaY);

	movss	xmm0, DWORD PTR _deltaX$8[ebp]
	mulss	xmm0, DWORD PTR _deltaX$8[ebp]
	movss	xmm1, DWORD PTR _deltaY$6[ebp]
	mulss	xmm1, DWORD PTR _deltaY$6[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _distanceToSta$3[ebp]

; 2732 : 
; 2733 : 					if (playerAC->af)

	mov	edx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [edx+932], 0
	je	$LN4@DrawCruise

; 2734 : 					{
; 2735 : 						// we are within glide distance let's go max rng and decent
; 2736 : 						float decentpoint = ((5000.0f - playerAC->ZPos()*0.8f)/1000.0f)/
; 2737 : 							(max(100.0f,(float)playerAC->af->GetDragIndex())/100.0f);

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetDragIndex@AirframeClass@@QAEMXZ	; AirframeClass::GetDragIndex
	fstp	DWORD PTR tv580[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR tv580[ebp]
	jbe	SHORT $LN36@DrawCruise
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv226[ebp], xmm0
	jmp	SHORT $LN37@DrawCruise
$LN36@DrawCruise:
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetDragIndex@AirframeClass@@QAEMXZ	; AirframeClass::GetDragIndex
	fstp	DWORD PTR tv226[ebp]
$LN37@DrawCruise:
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv590[ebp]
	movss	xmm0, DWORD PTR tv590[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR __real@459c4000
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR __real@447a0000
	movss	xmm0, DWORD PTR tv226[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	divss	xmm1, xmm0
	movss	DWORD PTR _decentpoint$1[ebp], xmm1

; 2738 : 						if (decentpoint > distanceToSta*FT_TO_NM)

	movss	xmm0, DWORD PTR _distanceToSta$3[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	xmm1, DWORD PTR _decentpoint$1[ebp]
	comiss	xmm1, xmm0
	jbe	$LN10@DrawCruise

; 2739 : 						{
; 2740 : 							DrawAirSpeedCarret(playerAC->af->GetOptKias(2));

	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirSpeedCarret@HudClass@@QAEXM@Z	; HudClass::DrawAirSpeedCarret

; 2741 : 							sprintf(SpeedText, "%.0f", max(min(playerAC->af->GetOptKias(2), 9999.0F), 0.0F));

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv605[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv605[ebp]
	jbe	SHORT $LN38@DrawCruise
	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv250[ebp]
	jmp	SHORT $LN39@DrawCruise
$LN38@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv250[ebp], xmm0
$LN39@DrawCruise:
	movss	xmm0, DWORD PTR tv250[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@DrawCruise
	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv618[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv618[ebp]
	jbe	SHORT $LN40@DrawCruise
	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv263[ebp]
	jmp	SHORT $LN41@DrawCruise
$LN40@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv263[ebp], xmm0
$LN41@DrawCruise:
	movss	xmm0, DWORD PTR tv263[ebp]
	movss	DWORD PTR tv264[ebp], xmm0
	jmp	SHORT $LN43@DrawCruise
$LN42@DrawCruise:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv264[ebp], xmm0
$LN43@DrawCruise:
	cvtss2sd xmm0, DWORD PTR tv264[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5107				; 000013f3H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2742 : 						}
; 2743 : 						// we are at optimum cruice let's cruice range here
; 2744 : 						else if (fabs(-playerAC->ZPos() - playerAC->af->GetOptimumAltitude()) < 200.0f  &&

	jmp	$LN4@DrawCruise
$LN10@DrawCruise:

; 2745 : 								fabs(playerAC->ZDelta())< 50.0f ||
; 2746 : 								fabs(-playerAC->ZPos() - playerAC->af->GetOptimumAltitude()) < 1000.0f  &&
; 2747 : 								playerAC->ZDelta()> 0.0f ||
; 2748 : 								-playerAC->ZPos() > playerAC->af->GetOptimumAltitude())

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv632[ebp]
	movss	xmm0, DWORD PTR tv632[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	movss	DWORD PTR tv797[ebp], xmm0
	call	?GetOptimumAltitude@AirframeClass@@QAEMXZ ; AirframeClass::GetOptimumAltitude
	fstp	DWORD PTR tv637[ebp]
	movss	xmm0, DWORD PTR tv797[ebp]
	subss	xmm0, DWORD PTR tv637[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv642[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR tv642[ebp]
	jbe	SHORT $LN6@DrawCruise
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv651[ebp]
	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR tv651[ebp]
	ja	$LN7@DrawCruise
$LN6@DrawCruise:
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv656[ebp]
	movss	xmm0, DWORD PTR tv656[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	DWORD PTR tv799[ebp], xmm0
	call	?GetOptimumAltitude@AirframeClass@@QAEMXZ ; AirframeClass::GetOptimumAltitude
	fstp	DWORD PTR tv661[ebp]
	movss	xmm0, DWORD PTR tv799[ebp]
	subss	xmm0, DWORD PTR tv661[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv666[ebp]
	movss	xmm0, DWORD PTR __real@447a0000
	comiss	xmm0, DWORD PTR tv666[ebp]
	jbe	SHORT $LN5@DrawCruise
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR tv671[ebp]
	movss	xmm0, DWORD PTR tv671[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN7@DrawCruise
$LN5@DrawCruise:
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv675[ebp]
	movss	xmm0, DWORD PTR tv675[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	movss	DWORD PTR tv801[ebp], xmm0
	call	?GetOptimumAltitude@AirframeClass@@QAEMXZ ; AirframeClass::GetOptimumAltitude
	fstp	DWORD PTR tv680[ebp]
	movss	xmm0, DWORD PTR tv801[ebp]
	comiss	xmm0, DWORD PTR tv680[ebp]
	jbe	$LN8@DrawCruise
$LN7@DrawCruise:

; 2749 : 						{
; 2750 : 							DrawAirSpeedCarret(playerAC->af->GetOptKias(2));

	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirSpeedCarret@HudClass@@QAEXM@Z	; HudClass::DrawAirSpeedCarret

; 2751 : 							DrawAltCarret(playerAC->af->GetOptimumAltitude());

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptimumAltitude@AirframeClass@@QAEMXZ ; AirframeClass::GetOptimumAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAltCarret@HudClass@@QAEXM@Z	; HudClass::DrawAltCarret

; 2752 : 							sprintf(SpeedText, "%.0f", max(min(playerAC->af->GetOptKias(2), 9999.0F), 0.0F));

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv696[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv696[ebp]
	jbe	SHORT $LN44@DrawCruise
	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv347[ebp]
	jmp	SHORT $LN45@DrawCruise
$LN44@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv347[ebp], xmm0
$LN45@DrawCruise:
	movss	xmm0, DWORD PTR tv347[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN48@DrawCruise
	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv709[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv709[ebp]
	jbe	SHORT $LN46@DrawCruise
	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv360[ebp]
	jmp	SHORT $LN47@DrawCruise
$LN46@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv360[ebp], xmm0
$LN47@DrawCruise:
	movss	xmm0, DWORD PTR tv360[ebp]
	movss	DWORD PTR tv361[ebp], xmm0
	jmp	SHORT $LN49@DrawCruise
$LN48@DrawCruise:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv361[ebp], xmm0
$LN49@DrawCruise:
	cvtss2sd xmm0, DWORD PTR tv361[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5107				; 000013f3H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2753 : 						}
; 2754 : 						// we are in the climp towards best cruice altitude
; 2755 : 						else

	jmp	$LN4@DrawCruise
$LN8@DrawCruise:

; 2756 : 						{
; 2757 : 							DrawAirSpeedCarret(playerAC->af->GetOptKias(0));

	push	0
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirSpeedCarret@HudClass@@QAEXM@Z	; HudClass::DrawAirSpeedCarret

; 2758 : 							DrawAltCarret(playerAC->af->GetOptimumAltitude());

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptimumAltitude@AirframeClass@@QAEMXZ ; AirframeClass::GetOptimumAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAltCarret@HudClass@@QAEXM@Z	; HudClass::DrawAltCarret

; 2759 : 							sprintf(SpeedText, "%.0f", max(min(playerAC->af->GetOptKias(0), 9999.0F), 0.0F));

	push	0
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv735[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv735[ebp]
	jbe	SHORT $LN50@DrawCruise
	push	0
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv389[ebp]
	jmp	SHORT $LN51@DrawCruise
$LN50@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv389[ebp], xmm0
$LN51@DrawCruise:
	movss	xmm0, DWORD PTR tv389[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN54@DrawCruise
	push	0
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv748[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv748[ebp]
	jbe	SHORT $LN52@DrawCruise
	push	0
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv402[ebp]
	jmp	SHORT $LN53@DrawCruise
$LN52@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv402[ebp], xmm0
$LN53@DrawCruise:
	movss	xmm0, DWORD PTR tv402[ebp]
	movss	DWORD PTR tv403[ebp], xmm0
	jmp	SHORT $LN55@DrawCruise
$LN54@DrawCruise:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv403[ebp], xmm0
$LN55@DrawCruise:
	cvtss2sd xmm0, DWORD PTR tv403[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5107				; 000013f3H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN4@DrawCruise:

; 2760 : 						}
; 2761 : 					}
; 2762 : 				}
; 2763 : 			}	
; 2764 : 			//opt speed and alt with climb profile and such
; 2765 : 			break;

	jmp	$LN18@DrawCruise
$LN3@DrawCruise:

; 2766 : 		case 3:	//Cruise Edr
; 2767 : 			//Speed
; 2768 : 			if(playerAC &&  playerAC->af)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN2@DrawCruise
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	je	$LN2@DrawCruise

; 2769 : 			{
; 2770 : 				DrawAirSpeedCarret(playerAC->af->GetOptKias(1));

	push	1
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirSpeedCarret@HudClass@@QAEXM@Z	; HudClass::DrawAirSpeedCarret

; 2771 : 				sprintf(SpeedText, "%.0f", max(min(playerAC->af->GetOptKias(1), 9999.0F), 0.0F));

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv770[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv770[ebp]
	jbe	SHORT $LN56@DrawCruise
	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv429[ebp]
	jmp	SHORT $LN57@DrawCruise
$LN56@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv429[ebp], xmm0
$LN57@DrawCruise:
	movss	xmm0, DWORD PTR tv429[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN60@DrawCruise
	push	1
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv783[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR tv783[ebp]
	jbe	SHORT $LN58@DrawCruise
	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetOptKias@AirframeClass@@QAEMH@Z	; AirframeClass::GetOptKias
	fstp	DWORD PTR tv442[ebp]
	jmp	SHORT $LN59@DrawCruise
$LN58@DrawCruise:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv442[ebp], xmm0
$LN59@DrawCruise:
	movss	xmm0, DWORD PTR tv442[ebp]
	movss	DWORD PTR tv443[ebp], xmm0
	jmp	SHORT $LN61@DrawCruise
$LN60@DrawCruise:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv443[ebp], xmm0
$LN61@DrawCruise:
	cvtss2sd xmm0, DWORD PTR tv443[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5107				; 000013f3H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN2@DrawCruise:

; 2772 : 			}
; 2773 : 			break;

	jmp	SHORT $LN18@DrawCruise
$LN1@DrawCruise:

; 2774 : 		default:
; 2775 : 			sprintf(SpeedText, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5107				; 000013f3H
	push	edx
	call	_sprintf
	add	esp, 8
$LN18@DrawCruise:
$LN22@DrawCruise:

; 2776 : 			break;
; 2777 : 	}
; 2778 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@DrawCruise:
	DD	$LN17@DrawCruise
	DD	$LN16@DrawCruise
	DD	$LN14@DrawCruise
	DD	$LN3@DrawCruise
?DrawCruiseIndexes@HudClass@@QAEXXZ ENDP		; HudClass::DrawCruiseIndexes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_x2$ = -56						; size = 4
tv249 = -52						; size = 4
tv182 = -48						; size = 4
tv178 = -44						; size = 4
tv158 = -40						; size = 4
_playerAC$ = -36					; size = 4
_leftEdge$ = -32					; size = 4
_bigTickLen$ = -28					; size = 4
_tickInc$ = -24						; size = 4
_delta$ = -20						; size = 4
_x1$ = -16						; size = 4
_this$ = -12						; size = 4
_smallTickLen$ = -8					; size = 4
_y1$ = -4						; size = 4
_Alt$ = 8						; size = 4
?DrawAltCarret@HudClass@@QAEXM@Z PROC			; HudClass::DrawAltCarret
; _this$ = ecx

; 2666 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2667 : 	if(FCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN2@DrawAltCar

; 2668 : 		return;

	jmp	$LN3@DrawAltCar
$LN2@DrawAltCar:

; 2669 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2670 : 	float leftEdge = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _leftEdge$[ebp], xmm0

; 2671 : 	float bigTickLen=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 2672 : 	float smallTickLen=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 2673 : 	float tickInc=0.0F, delta=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tickInc$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delta$[ebp], xmm0

; 2674 : 	float x1=0.0F, x2=0.0F, y1=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y1$[ebp], xmm0

; 2675 : 
; 2676 : 	leftEdge = hudWinX[ALTITUDE_WINDOW] - (hudWinWidth[ALTITUDE_WINDOW] * 0.5F);

	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	mov	edx, 4
	imul	edx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR ?hudWinX@@3PAMA[ecx]
	subss	xmm1, xmm0
	movss	DWORD PTR _leftEdge$[ebp], xmm1

; 2677 : 
; 2678 : 	bigTickLen = hudWinWidth[ALTITUDE_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 2679 : 	smallTickLen = bigTickLen * 0.5F;

	movss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 2680 : 	tickInc = hudWinHeight[ALTITUDE_WINDOW] / (float)(NUM_VERTICAL_TICKS - 1);

	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 2681 : 	tickInc *= 0.75F;

	movss	xmm0, DWORD PTR _tickInc$[ebp]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 2682 : 
; 2683 : 	y1 = hudWinY[ALTITUDE_WINDOW] + hudWinHeight[ALTITUDE_WINDOW] * 0.5F;

	mov	edx, 4
	imul	edx, 39					; 00000027H
	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2684 : 	x1 = leftEdge * 0.95F;

	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR _x1$[ebp], xmm0

; 2685 : 	if(playerAC && playerAC->curWaypoint)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN1@DrawAltCar
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+728], 0
	je	$LN1@DrawAltCar

; 2686 : 	{
; 2687 : 		delta = Alt - -ownship->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv249[ebp]
	movss	xmm0, DWORD PTR tv249[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _Alt$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _delta$[ebp], xmm1

; 2688 : 		delta *= 0.01F;

	movss	xmm0, DWORD PTR _delta$[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _delta$[ebp], xmm0

; 2689 : 		y1 += delta * tickInc;

	movss	xmm0, DWORD PTR _delta$[ebp]
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	addss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2690 : 		y1 = max ( min ( y1, hudWinY[ALTITUDE_WINDOW] + hudWinHeight[ALTITUDE_WINDOW] - smallTickLen),
; 2691 : 				hudWinY[ALTITUDE_WINDOW]);

	mov	eax, 4
	imul	eax, 39					; 00000027H
	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN5@DrawAltCar
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN6@DrawAltCar
$LN5@DrawAltCar:
	mov	edx, 4
	imul	edx, 39					; 00000027H
	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR tv158[ebp], xmm0
$LN6@DrawAltCar:
	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR tv158[ebp]
	comiss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	jbe	SHORT $LN9@DrawAltCar
	mov	edx, 4
	imul	edx, 39					; 00000027H
	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN7@DrawAltCar
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv178[ebp], xmm0
	jmp	SHORT $LN8@DrawAltCar
$LN7@DrawAltCar:
	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	mov	edx, 4
	imul	edx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR tv178[ebp], xmm0
$LN8@DrawAltCar:
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR tv182[ebp], xmm0
	jmp	SHORT $LN10@DrawAltCar
$LN9@DrawAltCar:
	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR tv182[ebp], xmm0
$LN10@DrawAltCar:
	movss	xmm0, DWORD PTR tv182[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2692 : 		display->Line (x1 + bigTickLen, y1, x1, y1 + (smallTickLen * 0.5F));

	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2693 : 		display->Line (x1 + bigTickLen, y1, x1, y1 - (smallTickLen * 0.5F));

	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN1@DrawAltCar:
$LN3@DrawAltCar:

; 2694 : 	}
; 2695 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawAltCarret@HudClass@@QAEXM@Z ENDP			; HudClass::DrawAltCarret
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_x2$ = -56						; size = 4
tv361 = -52						; size = 4
tv357 = -48						; size = 4
tv337 = -44						; size = 4
_tickInc$ = -40						; size = 4
_rightEdge$ = -36					; size = 4
_delta$1 = -32						; size = 4
_delta$2 = -28						; size = 4
_bigTickLen$ = -24					; size = 4
_delta$ = -20						; size = 4
_x1$ = -16						; size = 4
_smallTickLen$ = -12					; size = 4
_y1$ = -8						; size = 4
_this$ = -4						; size = 4
_Speed$ = 8						; size = 4
?DrawAirSpeedCarret@HudClass@@QAEXM@Z PROC		; HudClass::DrawAirSpeedCarret
; _this$ = ecx

; 2580 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2581 : 	if(FCC->GetMasterMode() == FireControlComputer::Dogfight){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN14@DrawAirSpe

; 2582 : 		return;

	jmp	$LN15@DrawAirSpe
$LN14@DrawAirSpe:

; 2583 : 	}
; 2584 : 
; 2585 : 	//TJL 07/31/04 F14 - F18 Airspeed Carret //Cobra 11/04/04 TJL
; 2586 : 	//Cobra fixed non-F16, non-HUD specific airspeed carret issue
; 2587 : 	if (ownship->af->GetTypeAC() == 6 || ownship->af->GetTypeAC() == 7 || ownship->af->GetTypeAC() == 8 ||
; 2588 : 			ownship->af->GetTypeAC() == 9 || ownship->af->GetTypeAC() == 10)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 6
	je	SHORT $LN12@DrawAirSpe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 7
	je	SHORT $LN12@DrawAirSpe
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 8
	je	SHORT $LN12@DrawAirSpe
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 9
	je	SHORT $LN12@DrawAirSpe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 10					; 0000000aH
	jne	$LN13@DrawAirSpe
$LN12@DrawAirSpe:

; 2589 : 	{
; 2590 : 		float delta = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delta$2[ebp], xmm0

; 2591 : 		delta = Speed - (cockpitFlightData.kias);

	movss	xmm0, DWORD PTR _Speed$[ebp]
	subss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR _delta$2[ebp], xmm0

; 2592 : 		display->Line (-0.90F, 0.1F, -0.90F, 0.02F);//Vertical Line

	push	ecx
	movss	xmm0, DWORD PTR __real@3ca3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2593 : 		if (delta > 5.0f)

	movss	xmm0, DWORD PTR _delta$2[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	$LN11@DrawAirSpe

; 2594 : 		{
; 2595 : 			//Arrow Left
; 2596 : 			display->Line (-0.95F, 0.1F, -0.97F, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2597 : 			display->Line (-0.95F, 0.1F, -0.93F, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	jmp	$LN8@DrawAirSpe
$LN11@DrawAirSpe:

; 2598 : 		}
; 2599 : 		else if (delta < -5.0f)

	movss	xmm0, DWORD PTR __real@c0a00000
	comiss	xmm0, DWORD PTR _delta$2[ebp]
	jbe	$LN9@DrawAirSpe

; 2600 : 		{
; 2601 : 			//Arrow Right
; 2602 : 			display->Line (-0.85F, 0.1F, -0.87F, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf5eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf59999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2603 : 			display->Line (-0.85F, 0.1F, -0.83F, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf547ae1
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf59999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2604 : 		}
; 2605 : 		else

	jmp	$LN8@DrawAirSpe
$LN9@DrawAirSpe:

; 2606 : 		{	
; 2607 : 			//Arrow Center
; 2608 : 			display->Line (-0.90F, 0.1F, -0.92F, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6b851f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2609 : 			display->Line (-0.90F, 0.1F, -0.88F, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN8@DrawAirSpe:

; 2610 : 		}
; 2611 : 		return;

	jmp	$LN15@DrawAirSpe
	jmp	$LN6@DrawAirSpe
$LN13@DrawAirSpe:

; 2612 : 	}
; 2613 : 	//F15s
; 2614 : 	else if (ownship->af->GetTypeAC() == 3 || ownship->af->GetTypeAC() == 4 || ownship->af->GetTypeAC() == 5)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 3
	je	SHORT $LN5@DrawAirSpe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 4
	je	SHORT $LN5@DrawAirSpe
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 5
	jne	$LN6@DrawAirSpe
$LN5@DrawAirSpe:

; 2615 : 	{
; 2616 : 		float delta = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delta$1[ebp], xmm0

; 2617 : 		delta = Speed - (cockpitFlightData.kias);

	movss	xmm0, DWORD PTR _Speed$[ebp]
	subss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR _delta$1[ebp], xmm0

; 2618 : 		display->Line (-0.90F, 0.25F, -0.90F, 0.32F);//Vertical Line

	push	ecx
	movss	xmm0, DWORD PTR __real@3ea3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2619 : 		if (delta > 5.0f)

	movss	xmm0, DWORD PTR _delta$1[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	$LN4@DrawAirSpe

; 2620 : 		{
; 2621 : 			//Arrow Left
; 2622 : 			display->Line (-0.95F, 0.25F, -0.97F, 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2623 : 			display->Line (-0.95F, 0.25F, -0.93F, 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	jmp	$LN1@DrawAirSpe
$LN4@DrawAirSpe:

; 2624 : 		}
; 2625 : 		else if (delta < -5.0f)

	movss	xmm0, DWORD PTR __real@c0a00000
	comiss	xmm0, DWORD PTR _delta$1[ebp]
	jbe	$LN2@DrawAirSpe

; 2626 : 		{
; 2627 : 			//Arrow Right
; 2628 : 			display->Line (-0.85F, 0.25F, -0.87F, 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf5eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf59999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2629 : 			display->Line (-0.85F, 0.25F, -0.83F, 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf547ae1
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf59999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2630 : 		}
; 2631 : 		else

	jmp	$LN1@DrawAirSpe
$LN2@DrawAirSpe:

; 2632 : 		{	
; 2633 : 			//Arrow Center
; 2634 : 			display->Line (-0.90F, 0.25F, -0.92F, 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6b851f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2635 : 			display->Line (-0.90F, 0.25F, -0.88F, 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN1@DrawAirSpe:

; 2636 : 		}
; 2637 : 		return;

	jmp	$LN15@DrawAirSpe
$LN6@DrawAirSpe:

; 2638 : 	}
; 2639 : 
; 2640 : 	float rightEdge=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rightEdge$[ebp], xmm0

; 2641 : 	float bigTickLen=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 2642 : 	float smallTickLen=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 2643 : 	float tickInc=0.0F, delta=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tickInc$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delta$[ebp], xmm0

; 2644 : 	float x1=0.0F, x2=0.0F, y1=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y1$[ebp], xmm0

; 2645 : 
; 2646 : 	rightEdge = hudWinX[AIRSPEED_WINDOW] + hudWinWidth[AIRSPEED_WINDOW];

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinX@@3PAMA[ecx]
	addss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	movss	DWORD PTR _rightEdge$[ebp], xmm0

; 2647 : 
; 2648 : 	bigTickLen = hudWinWidth[AIRSPEED_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 2649 : 	smallTickLen = bigTickLen * 0.5F;

	movss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 2650 : 	tickInc = hudWinHeight[AIRSPEED_WINDOW] / (float)(NUM_VERTICAL_TICKS - 1);

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 2651 : 
; 2652 : 	y1 = hudWinY[AIRSPEED_WINDOW] + hudWinHeight[AIRSPEED_WINDOW] * 0.5F;

	mov	edx, 4
	imul	edx, 38					; 00000026H
	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2653 : 	x1 = rightEdge;

	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 2654 : 
; 2655 : 	delta = Speed - (cockpitFlightData.kias);

	movss	xmm0, DWORD PTR _Speed$[ebp]
	subss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR _delta$[ebp], xmm0

; 2656 : 	delta *= 0.1F;

	movss	xmm0, DWORD PTR _delta$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _delta$[ebp], xmm0

; 2657 : 	y1 += delta * tickInc;

	movss	xmm0, DWORD PTR _delta$[ebp]
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	addss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2658 : 	y1 = max ( min ( y1, hudWinY[AIRSPEED_WINDOW] + hudWinHeight[AIRSPEED_WINDOW] - smallTickLen),
; 2659 : 			hudWinY[AIRSPEED_WINDOW]);

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN17@DrawAirSpe
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv337[ebp], xmm0
	jmp	SHORT $LN18@DrawAirSpe
$LN17@DrawAirSpe:
	mov	eax, 4
	imul	eax, 38					; 00000026H
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR tv337[ebp], xmm0
$LN18@DrawAirSpe:
	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR tv337[ebp]
	comiss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	jbe	SHORT $LN21@DrawAirSpe
	mov	eax, 4
	imul	eax, 38					; 00000026H
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN19@DrawAirSpe
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv357[ebp], xmm0
	jmp	SHORT $LN20@DrawAirSpe
$LN19@DrawAirSpe:
	mov	edx, 4
	imul	edx, 38					; 00000026H
	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR tv357[ebp], xmm0
$LN20@DrawAirSpe:
	movss	xmm0, DWORD PTR tv357[ebp]
	movss	DWORD PTR tv361[ebp], xmm0
	jmp	SHORT $LN22@DrawAirSpe
$LN21@DrawAirSpe:
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	movss	DWORD PTR tv361[ebp], xmm0
$LN22@DrawAirSpe:
	movss	xmm0, DWORD PTR tv361[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2660 : 
; 2661 : 	display->Line (x1, y1, x1 + bigTickLen, y1 + (smallTickLen * 0.5F));

	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2662 : 	display->Line (x1, y1, x1 + bigTickLen, y1 - (smallTickLen * 0.5F));

	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN15@DrawAirSpe:

; 2663 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawAirSpeedCarret@HudClass@@QAEXM@Z ENDP		; HudClass::DrawAirSpeedCarret
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_trig$ = -28						; size = 8
_dx$ = -20						; size = 4
_dy$ = -16						; size = 4
_i$1 = -12						; size = 4
_this$ = -8						; size = 4
_i$2 = -4						; size = 4
?DrawBankIndicator@HudClass@@QAEXXZ PROC		; HudClass::DrawBankIndicator
; _this$ = ecx

; 2539 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2540 : 	//get where our FPM is located
; 2541 : 	float dx = betaHudUnits;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4860]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2542 : 	float dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2543 : 		hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 2544 : 		alphaHudUnits;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+4856]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2545 : 
; 2546 : 	static const float angles[] = { 60 * DTR, 30 * DTR, 20 * DTR, 10 * DTR, 0 * DTR, -10 * DTR, -20 * DTR, -30 * DTR, -60 * DTR };
; 2547 : 	static const int nangles = sizeof(angles)/sizeof(angles[0]);
; 2548 : 	static float x1points[nangles], x2points[nangles], y1points[nangles], y2points[nangles];
; 2549 : 	static float sdist = 0.11f, oedist = 0.13f;
; 2550 : 	mlTrig trig;
; 2551 : 
; 2552 : 	display->AdjustOriginInViewport(dx, dy); 

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2553 : 	if(CalcBank)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+5093]
	test	eax, eax
	je	$LN10@DrawBankIn

; 2554 : 	{
; 2555 : 		for (int i = 0; i  < nangles; i++) 

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN9@DrawBankIn
$LN8@DrawBankIn:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN9@DrawBankIn:
	cmp	DWORD PTR _i$2[ebp], 9
	jge	$LN7@DrawBankIn

; 2556 : 		{
; 2557 : 			if (i ==0 || i == 1 || i == 4 || i == 7 || i == 8) 

	cmp	DWORD PTR _i$2[ebp], 0
	je	SHORT $LN5@DrawBankIn
	cmp	DWORD PTR _i$2[ebp], 1
	je	SHORT $LN5@DrawBankIn
	cmp	DWORD PTR _i$2[ebp], 4
	je	SHORT $LN5@DrawBankIn
	cmp	DWORD PTR _i$2[ebp], 7
	je	SHORT $LN5@DrawBankIn
	cmp	DWORD PTR _i$2[ebp], 8
	jne	SHORT $LN6@DrawBankIn
$LN5@DrawBankIn:

; 2558 : 				oedist = 0.16f;

	movss	xmm0, DWORD PTR __real@3e23d70a
	movss	DWORD PTR ?oedist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA, xmm0

; 2559 : 			else

	jmp	SHORT $LN4@DrawBankIn
$LN6@DrawBankIn:

; 2560 : 				oedist = 0.13f;

	movss	xmm0, DWORD PTR __real@3e051eb8
	movss	DWORD PTR ?oedist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA, xmm0
$LN4@DrawBankIn:

; 2561 : 
; 2562 : 			mlSinCos( &trig, angles[i]);

	mov	edx, DWORD PTR _i$2[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?angles@?1??DrawBankIndicator@HudClass@@QAEXXZ@4QBMB[edx*4]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2563 : 			x1points[i] = sdist*trig.sin;

	movss	xmm0, DWORD PTR ?sdist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA
	mulss	xmm0, DWORD PTR _trig$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR ?x1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[ecx*4], xmm0

; 2564 : 			y1points[i] = sdist*trig.cos;

	movss	xmm0, DWORD PTR ?sdist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	mov	edx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR ?y1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[edx*4], xmm0

; 2565 : 			x2points[i] = oedist*trig.sin;

	movss	xmm0, DWORD PTR ?oedist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA
	mulss	xmm0, DWORD PTR _trig$[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	movss	DWORD PTR ?x2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[eax*4], xmm0

; 2566 : 			y2points[i] = oedist*trig.cos;

	movss	xmm0, DWORD PTR ?oedist@?1??DrawBankIndicator@HudClass@@QAEXXZ@4MA
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	mov	ecx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR ?y2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[ecx*4], xmm0

; 2567 : 		}

	jmp	$LN8@DrawBankIn
$LN7@DrawBankIn:

; 2568 : 		CalcBank = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5093], 0
$LN10@DrawBankIn:

; 2569 : 	}
; 2570 : 	display->AdjustRotationAboutOrigin(-cockpitFlightData.roll);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2571 : 	for(int i = 0; i < nangles; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@DrawBankIn
$LN2@DrawBankIn:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN3@DrawBankIn:
	cmp	DWORD PTR _i$1[ebp], 9
	jge	$LN1@DrawBankIn

; 2572 : 	{
; 2573 : 		display->Line(x1points[i], y1points[i], x2points[i], y2points[i]);

	mov	edx, DWORD PTR _i$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?x2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[eax*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[ecx*4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?x1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2574 : 		display->Line(-x1points[i], y1points[i], -x2points[i], y2points[i]);

	mov	eax, DWORD PTR _i$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[eax*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$1[ebp]
	movss	xmm0, DWORD PTR ?x2points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[ecx*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$1[ebp]
	movss	xmm0, DWORD PTR ?x1points@?1??DrawBankIndicator@HudClass@@QAEXXZ@4PAMA[eax*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2575 : 	}

	jmp	$LN2@DrawBankIn
$LN1@DrawBankIn:

; 2576 : 	display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 2577 : 	display->AdjustOriginInViewport(-dx, -dy);

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2578 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawBankIndicator@HudClass@@QAEXXZ ENDP		; HudClass::DrawBankIndicator
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_headingDiff$ = -148					; size = 4
_GlideSlopeAngle$ = -144				; size = 4
_hDeviationGain$ = -140					; size = 4
_vDeviationGain$ = -136					; size = 4
_hor_Offset$ = -132					; size = 4
tv201 = -128						; size = 4
_Descent$ = -124					; size = 4
_len$ = -120						; size = 4
tv223 = -116						; size = 4
_circlesize$ = -112					; size = 4
tv249 = -108						; size = 4
_linesize$ = -104					; size = 4
_dx$ = -100						; size = 4
tv255 = -96						; size = 4
_dy$ = -92						; size = 4
tv233 = -88						; size = 4
_x$ = -84						; size = 4
_DistToSta$ = -80					; size = 4
_y$ = -76						; size = 4
_ratio$ = -72						; size = 4
tv217 = -68						; size = 4
_trig$ = -64						; size = 8
_curHeading$ = -56					; size = 4
_Intercept$ = -52					; size = 4
_tmpSmooth$1 = -48					; size = 4
_y1$ = -44						; size = 4
_GlideSlopeDev$ = -40					; size = 4
_x1$ = -36						; size = 4
_RWYHeading$ = -32					; size = 4
_Bearing$ = -28						; size = 4
_Bearing2$ = -24					; size = 4
_CorrectionLimit$ = -20					; size = 4
_Bearing1$ = -16					; size = 4
_this$ = -12						; size = 4
_LocalizerDev$ = -8					; size = 4
_Slope$ = -4						; size = 4
?DrawCMDSTRG@HudClass@@QAEXXZ PROC			; HudClass::DrawCMDSTRG
; _this$ = ecx

; 2419 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	DWORD PTR _this$[ebp], ecx

; 2420 : 	//get where our FPM is located
; 2421 : 	float dx = betaHudUnits;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4860]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2422 : 	float dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2423 : 		hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 2424 : 		alphaHudUnits;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+4856]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2425 : 
; 2426 : 	float LocalizerDev = 0.0F, RWYHeading = 0.0F, GlideSlopeDev = 0.0F, DistToSta = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _LocalizerDev$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RWYHeading$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _GlideSlopeDev$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _DistToSta$[ebp], xmm0

; 2427 : 	float x1 = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x1$[ebp], xmm0

; 2428 : 	float y1 = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y1$[ebp], xmm0

; 2429 : 	float Intercept = 0.0F, Slope = 0.0F, Descent = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Intercept$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Slope$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Descent$[ebp], xmm0

; 2430 : 	float Bearing = 0.0F, Bearing1 = 0.0F, Bearing2 = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Bearing$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Bearing1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Bearing2$[ebp], xmm0

; 2431 : 
; 2432 : 	if(gNavigationSys)

	cmp	DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A, 0 ; gNavigationSys
	je	SHORT $LN25@DrawCMDSTR

; 2433 : 		gNavigationSys->GetILSData(&LocalizerDev, &RWYHeading, &GlideSlopeDev, &DistToSta);

	lea	ecx, DWORD PTR _DistToSta$[ebp]
	push	ecx
	lea	edx, DWORD PTR _GlideSlopeDev$[ebp]
	push	edx
	lea	eax, DWORD PTR _RWYHeading$[ebp]
	push	eax
	lea	ecx, DWORD PTR _LocalizerDev$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSData@NavigationSystem@@QAEXPAM000@Z ; NavigationSystem::GetILSData
$LN25@DrawCMDSTR:

; 2434 : 
; 2435 : 	// MD -- 20040605: no signals from the ILS system is you are beyond ~25nm.
; 2436 : 	// or approximately (25 * 6000) feet
; 2437 : 	if (DistToSta > 150000.0F)

	movss	xmm0, DWORD PTR _DistToSta$[ebp]
	comiss	xmm0, DWORD PTR __real@48127c00
	jbe	SHORT $LN24@DrawCMDSTR

; 2438 : 		return;

	jmp	$LN26@DrawCMDSTR
$LN24@DrawCMDSTR:

; 2439 : 
; 2440 : 	LocalizerDev *= RTD;

	movss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _LocalizerDev$[ebp], xmm0

; 2441 : 	GlideSlopeDev *= RTD;

	movss	xmm0, DWORD PTR _GlideSlopeDev$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _GlideSlopeDev$[ebp], xmm0

; 2442 : 
; 2443 : 	//up to 5 we're on a correction
; 2444 : 	float CorrectionLimit = 5.0F;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _CorrectionLimit$[ebp], xmm0

; 2445 : 
; 2446 : 	//set correction sensitivity
; 2447 : 	float hDeviationGain = 45.0F / CorrectionLimit; // this way there is no jump  when switching from intercept

	movss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	movss	DWORD PTR _hDeviationGain$[ebp], xmm0

; 2448 : 	float vDeviationGain = 3.0F; // must be greater than 1, how soon you want to align with ILS

	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _vDeviationGain$[ebp], xmm0

; 2449 : 	float GlideSlopeAngle = -3.0F;

	movss	xmm0, DWORD PTR __real@c0400000
	movss	DWORD PTR _GlideSlopeAngle$[ebp], xmm0

; 2450 : 
; 2451 : 	mlTrig trig;
; 2452 : 	mlSinCos (&trig, cockpitFlightData.roll);

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2453 : 
; 2454 : 	//Calculate our current heading from FPM position;
; 2455 : 	float hor_Offset = cockpitFlightData.beta * trig.cos + cockpitFlightData.alpha * trig.sin
; 2456 : 		+ RTD * cockpitFlightData.windOffset * trig.cos;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+28
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	xmm1, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+24
	mulss	xmm1, DWORD PTR _trig$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@42652ee1
	mulss	xmm1, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+64
	mulss	xmm1, DWORD PTR _trig$[ebp+4]
	addss	xmm0, xmm1
	movss	DWORD PTR _hor_Offset$[ebp], xmm0

; 2457 : 	float curHeading = cockpitFlightData.yaw * RTD + hor_Offset;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	mulss	xmm0, DWORD PTR __real@42652ee1
	addss	xmm0, DWORD PTR _hor_Offset$[ebp]
	movss	DWORD PTR _curHeading$[ebp], xmm0

; 2458 : 
; 2459 : 	//Calcualte correction phase Bearing1
; 2460 : 	Bearing1 = RWYHeading - curHeading + (LocalizerDev * hDeviationGain);

	movss	xmm0, DWORD PTR _RWYHeading$[ebp]
	subss	xmm0, DWORD PTR _curHeading$[ebp]
	movss	xmm1, DWORD PTR _LocalizerDev$[ebp]
	mulss	xmm1, DWORD PTR _hDeviationGain$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _Bearing1$[ebp], xmm0
$LN23@DrawCMDSTR:

; 2461 : 	while ((Bearing1 < -180) || (Bearing1 > 180)) 

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _Bearing1$[ebp]
	ja	SHORT $LN21@DrawCMDSTR
	movss	xmm0, DWORD PTR _Bearing1$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN22@DrawCMDSTR
$LN21@DrawCMDSTR:

; 2462 : 	{
; 2463 : 		if(Bearing1 > 180)

	movss	xmm0, DWORD PTR _Bearing1$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN20@DrawCMDSTR

; 2464 : 			Bearing1 -= 360;

	movss	xmm0, DWORD PTR _Bearing1$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _Bearing1$[ebp], xmm0
	jmp	SHORT $LN18@DrawCMDSTR
$LN20@DrawCMDSTR:

; 2465 : 		else if(Bearing1 < -180)

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _Bearing1$[ebp]
	jbe	SHORT $LN18@DrawCMDSTR

; 2466 : 			Bearing1 += 360;

	movss	xmm0, DWORD PTR _Bearing1$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _Bearing1$[ebp], xmm0
$LN18@DrawCMDSTR:

; 2467 : 	}

	jmp	SHORT $LN23@DrawCMDSTR
$LN22@DrawCMDSTR:

; 2468 : 
; 2469 : 	//Calculate correction phase descent Slope
; 2470 : 	Descent = cockpitFlightData.gamma * RTD;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+32
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _Descent$[ebp], xmm0

; 2471 : 	Slope = (GlideSlopeAngle - Descent) + GlideSlopeDev * vDeviationGain;

	movss	xmm0, DWORD PTR _GlideSlopeAngle$[ebp]
	subss	xmm0, DWORD PTR _Descent$[ebp]
	movss	xmm1, DWORD PTR _GlideSlopeDev$[ebp]
	mulss	xmm1, DWORD PTR _vDeviationGain$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _Slope$[ebp], xmm0
$LN17@DrawCMDSTR:

; 2472 : 	while ((Slope < -180) || (Slope > 180)) 

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _Slope$[ebp]
	ja	SHORT $LN15@DrawCMDSTR
	movss	xmm0, DWORD PTR _Slope$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN16@DrawCMDSTR
$LN15@DrawCMDSTR:

; 2473 : 	{
; 2474 : 		if(Slope > 180)

	movss	xmm0, DWORD PTR _Slope$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN14@DrawCMDSTR

; 2475 : 			Slope -= 360;

	movss	xmm0, DWORD PTR _Slope$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _Slope$[ebp], xmm0
	jmp	SHORT $LN12@DrawCMDSTR
$LN14@DrawCMDSTR:

; 2476 : 		else if(Slope < -180)

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _Slope$[ebp]
	jbe	SHORT $LN12@DrawCMDSTR

; 2477 : 			Slope += 360;

	movss	xmm0, DWORD PTR _Slope$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _Slope$[ebp], xmm0
$LN12@DrawCMDSTR:

; 2478 : 	}

	jmp	SHORT $LN17@DrawCMDSTR
$LN16@DrawCMDSTR:

; 2479 : 
; 2480 : 
; 2481 : 	//Calculate 45 intercept Bearing2
; 2482 : 	float headingDiff = RWYHeading - curHeading;

	movss	xmm0, DWORD PTR _RWYHeading$[ebp]
	subss	xmm0, DWORD PTR _curHeading$[ebp]
	movss	DWORD PTR _headingDiff$[ebp], xmm0

; 2483 : 	//left or right turn?
; 2484 : 	if(LocalizerDev < 0)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	jbe	SHORT $LN11@DrawCMDSTR

; 2485 : 		Intercept = RWYHeading - 45;    //right of RWY

	movss	xmm0, DWORD PTR _RWYHeading$[ebp]
	subss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR _Intercept$[ebp], xmm0

; 2486 : 	else

	jmp	SHORT $LN10@DrawCMDSTR
$LN11@DrawCMDSTR:

; 2487 : 		Intercept = RWYHeading + 45;    //left or RWY

	movss	xmm0, DWORD PTR _RWYHeading$[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR _Intercept$[ebp], xmm0
$LN10@DrawCMDSTR:

; 2488 : 
; 2489 : 	Bearing2 = Intercept - curHeading;

	movss	xmm0, DWORD PTR _Intercept$[ebp]
	subss	xmm0, DWORD PTR _curHeading$[ebp]
	movss	DWORD PTR _Bearing2$[ebp], xmm0

; 2490 : 	if(Bearing2 > 180)

	movss	xmm0, DWORD PTR _Bearing2$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN9@DrawCMDSTR

; 2491 : 		Bearing2 -= 360;

	movss	xmm0, DWORD PTR _Bearing2$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _Bearing2$[ebp], xmm0
	jmp	SHORT $LN7@DrawCMDSTR
$LN9@DrawCMDSTR:

; 2492 : 	else if(Bearing2 < -180)

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _Bearing2$[ebp]
	jbe	SHORT $LN7@DrawCMDSTR

; 2493 : 		Bearing2 += 360;

	movss	xmm0, DWORD PTR _Bearing2$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _Bearing2$[ebp], xmm0
$LN7@DrawCMDSTR:

; 2494 : 
; 2495 : 	//When to apply which bearing and slope...
; 2496 : 	if(LocalizerDev < CorrectionLimit && LocalizerDev > -CorrectionLimit)

	movss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	comiss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	jbe	$LN6@DrawCMDSTR
	movss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _LocalizerDev$[ebp]
	comiss	xmm1, xmm0
	jbe	$LN6@DrawCMDSTR

; 2497 : 	{
; 2498 : 		Bearing = Bearing1;

	movss	xmm0, DWORD PTR _Bearing1$[ebp]
	movss	DWORD PTR _Bearing$[ebp], xmm0

; 2499 : 
; 2500 : 		//Smooth slope movement
; 2501 : 		float tmpSmooth = 0.9F;

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR _tmpSmooth$1[ebp], xmm0

; 2502 : 		if ((LocalizerDev > tmpSmooth * CorrectionLimit) || (LocalizerDev < -tmpSmooth * CorrectionLimit))

	movss	xmm0, DWORD PTR _tmpSmooth$1[ebp]
	mulss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	movss	xmm1, DWORD PTR _LocalizerDev$[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN4@DrawCMDSTR
	movss	xmm0, DWORD PTR _tmpSmooth$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	comiss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	jbe	SHORT $LN2@DrawCMDSTR
$LN4@DrawCMDSTR:

; 2503 : 		{
; 2504 : 			if (LocalizerDev > 0)

	movss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@DrawCMDSTR

; 2505 : 				Slope = Slope * ((CorrectionLimit - LocalizerDev) / ((1-tmpSmooth) * CorrectionLimit));

	movss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	subss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _tmpSmooth$1[ebp]
	mulss	xmm1, DWORD PTR _CorrectionLimit$[ebp]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _Slope$[ebp]
	movss	DWORD PTR _Slope$[ebp], xmm0

; 2506 : 			else

	jmp	SHORT $LN2@DrawCMDSTR
$LN3@DrawCMDSTR:

; 2507 : 				Slope = Slope * ((CorrectionLimit + LocalizerDev) / ((1-tmpSmooth) * CorrectionLimit));

	movss	xmm0, DWORD PTR _CorrectionLimit$[ebp]
	addss	xmm0, DWORD PTR _LocalizerDev$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _tmpSmooth$1[ebp]
	mulss	xmm1, DWORD PTR _CorrectionLimit$[ebp]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _Slope$[ebp]
	movss	DWORD PTR _Slope$[ebp], xmm0
$LN2@DrawCMDSTR:

; 2508 : 		}
; 2509 : 	}
; 2510 : 	else

	jmp	SHORT $LN1@DrawCMDSTR
$LN6@DrawCMDSTR:

; 2511 : 	{
; 2512 : 		Bearing = Bearing2;

	movss	xmm0, DWORD PTR _Bearing2$[ebp]
	movss	DWORD PTR _Bearing$[ebp], xmm0

; 2513 : 		Slope = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Slope$[ebp], xmm0
$LN1@DrawCMDSTR:

; 2514 : 	}
; 2515 : 	Bearing *= DTR;

	movss	xmm0, DWORD PTR _Bearing$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _Bearing$[ebp], xmm0

; 2516 : 	Slope *= DTR;

	movss	xmm0, DWORD PTR _Slope$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _Slope$[ebp], xmm0

; 2517 : 
; 2518 : 	display->AdjustOriginInViewport (dx, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2519 : 	display->AdjustRotationAboutOrigin(-cockpitFlightData.roll);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2520 : 	x1 = max(min(Bearing, hudWinWidth[PITCH_LADDER_WINDOW] * 0.75F),-hudWinWidth[PITCH_LADDER_WINDOW] * 0.75F);

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f400000
	comiss	xmm0, DWORD PTR _Bearing$[ebp]
	jbe	SHORT $LN28@DrawCMDSTR
	movss	xmm0, DWORD PTR _Bearing$[ebp]
	movss	DWORD PTR tv201[ebp], xmm0
	jmp	SHORT $LN29@DrawCMDSTR
$LN28@DrawCMDSTR:
	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv201[ebp], xmm0
$LN29@DrawCMDSTR:
	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	xmm1, DWORD PTR tv201[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@DrawCMDSTR
	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f400000
	comiss	xmm0, DWORD PTR _Bearing$[ebp]
	jbe	SHORT $LN30@DrawCMDSTR
	movss	xmm0, DWORD PTR _Bearing$[ebp]
	movss	DWORD PTR tv217[ebp], xmm0
	jmp	SHORT $LN31@DrawCMDSTR
$LN30@DrawCMDSTR:
	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv217[ebp], xmm0
$LN31@DrawCMDSTR:
	movss	xmm0, DWORD PTR tv217[ebp]
	movss	DWORD PTR tv223[ebp], xmm0
	jmp	SHORT $LN33@DrawCMDSTR
$LN32@DrawCMDSTR:
	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv223[ebp], xmm0
$LN33@DrawCMDSTR:
	movss	xmm0, DWORD PTR tv223[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 2521 : 	y1 = max(min(Slope, hudWinWidth[PITCH_LADDER_WINDOW] * 0.75F), -hudWinWidth[PITCH_LADDER_WINDOW] * 0.75F);

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f400000
	comiss	xmm0, DWORD PTR _Slope$[ebp]
	jbe	SHORT $LN34@DrawCMDSTR
	movss	xmm0, DWORD PTR _Slope$[ebp]
	movss	DWORD PTR tv233[ebp], xmm0
	jmp	SHORT $LN35@DrawCMDSTR
$LN34@DrawCMDSTR:
	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv233[ebp], xmm0
$LN35@DrawCMDSTR:
	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	xmm1, DWORD PTR tv233[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN38@DrawCMDSTR
	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f400000
	comiss	xmm0, DWORD PTR _Slope$[ebp]
	jbe	SHORT $LN36@DrawCMDSTR
	movss	xmm0, DWORD PTR _Slope$[ebp]
	movss	DWORD PTR tv249[ebp], xmm0
	jmp	SHORT $LN37@DrawCMDSTR
$LN36@DrawCMDSTR:
	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv249[ebp], xmm0
$LN37@DrawCMDSTR:
	movss	xmm0, DWORD PTR tv249[ebp]
	movss	DWORD PTR tv255[ebp], xmm0
	jmp	SHORT $LN39@DrawCMDSTR
$LN38@DrawCMDSTR:
	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv255[ebp], xmm0
$LN39@DrawCMDSTR:
	movss	xmm0, DWORD PTR tv255[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2522 : 
; 2523 : 	float circlesize = 0.003F;

	movss	xmm0, DWORD PTR __real@3b449ba6
	movss	DWORD PTR _circlesize$[ebp], xmm0

; 2524 : 	float linesize = 0.016F;

	movss	xmm0, DWORD PTR __real@3c83126f
	movss	DWORD PTR _linesize$[ebp], xmm0

; 2525 : 	//float circlesize = 0.006F;
; 2526 : 	//float linesize = 0.012F;
; 2527 : 	float ratio = circlesize / linesize;

	movss	xmm0, DWORD PTR _circlesize$[ebp]
	divss	xmm0, DWORD PTR _linesize$[ebp]
	movss	DWORD PTR _ratio$[ebp], xmm0

; 2528 : 	display->Circle (x1, y1, RadToHudUnits(circlesize));

	push	ecx
	movss	xmm0, DWORD PTR _circlesize$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 2529 : 	float len = RadToHudUnits(linesize);

	push	ecx
	movss	xmm0, DWORD PTR _linesize$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR _len$[ebp]

; 2530 : 	mlSinCos (&trig, cockpitFlightData.roll);

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2531 : 	float y = len * trig.cos;

	movss	xmm0, DWORD PTR _len$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _y$[ebp], xmm0

; 2532 : 	float x = len * trig.sin;

	movss	xmm0, DWORD PTR _len$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 2533 : 	display->Line (x1 + x, y1 + y, x1 + x * ratio, y1 + y * ratio);

	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	addss	xmm0, DWORD PTR _y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	addss	xmm0, DWORD PTR _x1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2534 : 	display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 2535 : 	display->AdjustOriginInViewport (-dx, -dy);

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN26@DrawCMDSTR:

; 2536 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawCMDSTRG@HudClass@@QAEXXZ ENDP			; HudClass::DrawCMDSTRG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawALString@HudClass@@QAEXXZ PROC			; HudClass::DrawALString
; _this$ = ecx

; 2391 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2392 : 	if(FCC->GetMasterMode() == FireControlComputer::Dogfight || FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN6@DrawALStri
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN7@DrawALStri
$LN6@DrawALStri:

; 2393 : 		return;

	jmp	$LN8@DrawALStri
$LN7@DrawALStri:

; 2394 : 
; 2395 : 	//here in any case, according to the list member
; 2396 : 	if(OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModeHud)

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 1
	jne	SHORT $LN5@DrawALStri

; 2397 : 		display->TextLeft(0.550F,YALText,"AL");

	push	0
	push	OFFSET ??_C@_02CNCKMBBD@AL?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5084]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2398 : 	else

	jmp	SHORT $LN4@DrawALStri
$LN5@DrawALStri:

; 2399 : 		display->TextLeft(0.45F,YALText,"AL");

	push	0
	push	OFFSET ??_C@_02CNCKMBBD@AL?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5084]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN4@DrawALStri:

; 2400 : 
; 2401 : 	if(((AircraftClass*)ownship)->af->platform->RALTStatus == AircraftClass::RaltStatus::ROFF)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	cmp	DWORD PTR [ecx+1004], 0
	jne	SHORT $LN3@DrawALStri

; 2402 : 		return;

	jmp	$LN8@DrawALStri
$LN3@DrawALStri:

; 2403 : 
; 2404 : 	if(OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModeHud)

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 1
	jne	SHORT $LN2@DrawALStri

; 2405 : 	{ 
; 2406 : 		//display->TextLeft(0.550F,YALText,"AL");
; 2407 : 		sprintf(tmpStr, "%.0f", lowAltWarning);

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+4960]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2408 : 		display->TextRight(0.74F,YALText,tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5084]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 2409 : 	}
; 2410 : 	else

	jmp	SHORT $LN1@DrawALStri
$LN2@DrawALStri:

; 2411 : 	{
; 2412 : 		//display->TextLeft(0.40F,YALText,"AL");
; 2413 : 		sprintf(tmpStr, "%.0f", lowAltWarning);

	mov	eax, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4960]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2414 : 		display->TextRight(0.74F,YALText,tmpStr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5084]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax
$LN1@DrawALStri:
$LN8@DrawALStri:

; 2415 : 	}
; 2416 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawALString@HudClass@@QAEXXZ ENDP			; HudClass::DrawALString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawRALTBox@HudClass@@QAEXXZ PROC			; HudClass::DrawRALTBox
; _this$ = ecx

; 2329 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2330 : 	if(FCC->GetMasterMode() == FireControlComputer::Dogfight || FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN17@DrawRALTBo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN18@DrawRALTBo
$LN17@DrawRALTBo:

; 2331 : 		return;

	jmp	$LN19@DrawRALTBo
$LN18@DrawRALTBo:

; 2332 : 
; 2333 : 	if(OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModeHud)

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 1
	jne	$LN16@DrawRALTBo

; 2334 : 	{
; 2335 : 		//window flashes if RALT fault
; 2336 : 		if(ownship && ownship->mFaults && ownship->mFaults->GetFault(FaultClass::ralt_fault))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	$LN15@DrawRALTBo
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx+928], 0
	je	$LN15@DrawRALTBo
	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	$LN15@DrawRALTBo

; 2337 : 		{
; 2338 : 			if(Warnflash)

	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	$LN14@DrawRALTBo

; 2339 : 			{
; 2340 : 				display->Line(0.605F,-0.16F,0.74F,-0.16F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2341 : 				display->Line(0.74F,-0.16F,0.74F,-0.22F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2342 : 				display->Line(0.74F,-0.22F,0.605F,-0.22F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2343 : 				display->Line(0.605F,-0.22F,0.605F,-0.16F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN14@DrawRALTBo:

; 2344 : 			}
; 2345 : 		}
; 2346 : 		else

	jmp	$LN13@DrawRALTBo
$LN15@DrawRALTBo:

; 2347 : 		{
; 2348 : 			display->Line(0.605F,-0.16F,0.74F,-0.16F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2349 : 			display->Line(0.74F,-0.16F,0.74F,-0.22F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2350 : 			display->Line(0.74F,-0.22F,0.605F,-0.22F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2351 : 			display->Line(0.605F,-0.22F,0.605F,-0.16F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f1ae148
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN13@DrawRALTBo:

; 2352 : 		}
; 2353 : 
; 2354 : 		if(((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN9@DrawRALTBo

; 2355 : 		{
; 2356 : 			if(radarSwitch == RADAR_AUTO)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4880], 2
	jne	SHORT $LN11@DrawRALTBo

; 2357 : 				display->TextLeft(0.550F,YRALTText,"AR");

	push	0
	push	OFFSET ??_C@_02PJGLPOMM@AR?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5088]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+56]
	call	edx
	jmp	SHORT $LN9@DrawRALTBo
$LN11@DrawRALTBo:

; 2358 : 			else if(radarSwitch == BARO)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4880], 1
	jne	SHORT $LN9@DrawRALTBo

; 2359 : 				display->TextLeft(0.550F,YRALTText,"R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+5088]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN9@DrawRALTBo:

; 2360 : 		}
; 2361 : 	} 
; 2362 : 	else

	jmp	$LN1@DrawRALTBo
$LN16@DrawRALTBo:

; 2363 : 	{
; 2364 : 		if(ownship && ownship->mFaults && ownship->mFaults->GetFault(FaultClass::ralt_fault))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	$LN7@DrawRALTBo
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	DWORD PTR [eax+928], 0
	je	$LN7@DrawRALTBo
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	$LN7@DrawRALTBo

; 2365 : 		{
; 2366 : 			if(Warnflash)

	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	$LN6@DrawRALTBo

; 2367 : 			{
; 2368 : 				display->Line(0.50F,-0.17F,0.75F,-0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2369 : 				display->Line(0.75F,-0.17F,0.75F,-0.25F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2370 : 				display->Line(0.75F,-0.25F,0.50F,-0.25F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2371 : 				display->Line(0.50F,-0.25F,0.50F,-0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN6@DrawRALTBo:

; 2372 : 			}
; 2373 : 		}
; 2374 : 		else

	jmp	$LN5@DrawRALTBo
$LN7@DrawRALTBo:

; 2375 : 		{
; 2376 : 			display->Line(0.50F,-0.17F,0.75F,-0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2377 : 			display->Line(0.75F,-0.17F,0.75F,-0.25F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2378 : 			display->Line(0.75F,-0.25F,0.50F,-0.25F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2379 : 			display->Line(0.50F,-0.25F,0.50F,-0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN5@DrawRALTBo:

; 2380 : 		}
; 2381 : 		if(((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN1@DrawRALTBo

; 2382 : 		{ 
; 2383 : 			if(radarSwitch == RADAR_AUTO)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4880], 2
	jne	SHORT $LN3@DrawRALTBo

; 2384 : 				display->TextLeft(0.42F,YRALTText,"AR");

	push	0
	push	OFFSET ??_C@_02PJGLPOMM@AR?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+5088]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ed70a3d
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	jmp	SHORT $LN1@DrawRALTBo
$LN3@DrawRALTBo:

; 2385 : 			else if(radarSwitch == BARO)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4880], 1
	jne	SHORT $LN1@DrawRALTBo

; 2386 : 				display->TextLeft(0.45F,YRALTText,"R");	

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5088]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+56]
	call	edx
$LN1@DrawRALTBo:
$LN19@DrawRALTBo:

; 2387 : 		}
; 2388 : 	}	   
; 2389 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawRALTBox@HudClass@@QAEXXZ ENDP			; HudClass::DrawRALTBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawRALT@HudClass@@QAEXXZ PROC				; HudClass::DrawRALT
; _this$ = ecx

; 2273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2274 : 	if(!ownship)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN17@DrawRALT

; 2275 : 		return;

	jmp	$LN18@DrawRALT
$LN17@DrawRALT:

; 2276 : 
; 2277 : 	if(FCC->GetMasterMode() == FireControlComputer::Dogfight || FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN15@DrawRALT
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN16@DrawRALT
$LN15@DrawRALT:

; 2278 : 		return;

	jmp	$LN18@DrawRALT
$LN16@DrawRALT:

; 2279 : 
; 2280 : 	//NO RALT if RF Switch in SILENT
; 2281 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2282 : 	if(playerAC && playerAC->RFState == 2)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN14@DrawRALT
	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+1520], 2
	jne	SHORT $LN14@DrawRALT

; 2283 : 		return;

	jmp	$LN18@DrawRALT
$LN14@DrawRALT:

; 2284 : 
; 2285 : 	if(-hat < lowAltWarning && (FindRollAngle(-hat) && FindPitchAngle(-hat)) &&
; 2286 : 			((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4960]
	comiss	xmm1, xmm0
	jbe	$LN13@DrawRALT
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	$LN13@DrawRALT
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	$LN13@DrawRALT
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN13@DrawRALT

; 2287 : 	{
; 2288 : 		if(!((AircraftClass*)ownship)->OnGround())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN12@DrawRALT

; 2289 : 		{
; 2290 : 			if(((AircraftClass*)ownship)->af->platform->RALTStatus == AircraftClass::RaltStatus::ROFF ||
; 2291 : 					((AircraftClass*)ownship)->af->platform->RALTStatus == AircraftClass::RaltStatus::RSTANDBY)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	cmp	DWORD PTR [ecx+1004], 0
	je	SHORT $LN10@DrawRALT
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+1088]
	cmp	DWORD PTR [edx+1004], 1
	jne	SHORT $LN11@DrawRALT
$LN10@DrawRALT:

; 2292 : 				DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
	jmp	SHORT $LN8@DrawRALT
$LN11@DrawRALT:

; 2293 : 			else if(Warnflash)

	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	SHORT $LN8@DrawRALT

; 2294 : 				DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN8@DrawRALT:

; 2295 : 		}

	jmp	SHORT $LN6@DrawRALT
$LN12@DrawRALT:

; 2296 : 		else if(((AircraftClass*)ownship)->OnGround())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN6@DrawRALT

; 2297 : 		{
; 2298 : 			//if(((AircraftClass*)ownship)->af->platform->RALTStatus != AircraftClass::RaltStatus::ROFF)
; 2299 : 			DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN6@DrawRALT:

; 2300 : 		}
; 2301 : 		if(((AircraftClass*)ownship)->af->gearPos < 0.8F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [edx+1552]
	jbe	SHORT $LN5@DrawRALT

; 2302 : 			F4SoundFXSetDist(ownship->af->GetAltitudeSnd(), FALSE, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetAltitudeSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetAltitudeSnd
	push	eax
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN5@DrawRALT:

; 2303 : 	}
; 2304 : 	else

	jmp	SHORT $LN4@DrawRALT
$LN13@DrawRALT:

; 2305 : 	{
; 2306 : 		//if(((AircraftClass*)ownship)->af->platform->RALTStatus != AircraftClass::RaltStatus::ROFF)
; 2307 : 		DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN4@DrawRALT:

; 2308 : 	}
; 2309 : 	if(((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN2@DrawRALT

; 2310 : 	{ 
; 2311 : 		if(FindRollAngle(-hat) && FindPitchAngle(-hat))

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	$LN2@DrawRALT
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	$LN2@DrawRALT

; 2312 : 		{
; 2313 : 			//Cobra
; 2314 : 			if ((unsigned long)hudRAltDelayTimer < SimLibElapsedTime)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5160]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN1@DrawRALT

; 2315 : 			{
; 2316 : 				raltHud=hat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5080]
	mov	DWORD PTR [eax+5176], edx

; 2317 : 				hudRAltDelayTimer = SimLibElapsedTime + 250;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 250				; 000000faH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5160], eax
$LN1@DrawRALT:

; 2318 : 			}
; 2319 : 
; 2320 : 			//only show 10's of feet
; 2321 : 			hat = ((static_cast<int>(raltHud) + 5) / 10) * 10.0f;

	mov	edx, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [edx+5176]
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+5080], xmm0

; 2322 : 			sprintf (tmpStr, "%.0f", -hat);  //JPG "%.0f"

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2323 : 			display->TextRight(0.74F, YRALTText, tmpStr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5088]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax
$LN2@DrawRALT:
$LN18@DrawRALT:

; 2324 : 		}
; 2325 : 	}
; 2326 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawRALT@HudClass@@QAEXXZ ENDP				; HudClass::DrawRALT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv228 = -20						; size = 4
tv85 = -16						; size = 4
_xPos$ = -12						; size = 4
_yPos$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawVRP@HudClass@@QAEXXZ PROC				; HudClass::DrawVRP
; _this$ = ecx

; 2227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2228 : 	//MI INS stuff
; 2229 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN9@DrawVRP
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN9@DrawVRP

; 2230 : 	{
; 2231 : 		if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN9@DrawVRP
	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN9@DrawVRP

; 2232 : 			return;

	jmp	$LN11@DrawVRP
$LN9@DrawVRP:

; 2233 : 	}
; 2234 : 	float xPos,yPos;
; 2235 : 	if (!VRPValid || (FCC->GetMasterMode() == FireControlComputer::Dogfight))//me123 status test.)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5064]
	test	edx, edx
	je	SHORT $LN7@DrawVRP
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN8@DrawVRP
$LN7@DrawVRP:

; 2236 : 		return;

	jmp	$LN11@DrawVRP

; 2237 : 	else

	jmp	$LN4@DrawVRP
$LN8@DrawVRP:

; 2238 : 	{
; 2239 : 		// Draw the waypoint on the ground
; 2240 : 		switch (FCC->GetMasterMode())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv85[ebp], eax
	mov	edx, DWORD PTR tv85[ebp]
	sub	edx, 4
	mov	DWORD PTR tv85[ebp], edx
	cmp	DWORD PTR tv85[ebp], 9
	ja	$LN1@DrawVRP
	mov	eax, DWORD PTR tv85[ebp]
	movzx	ecx, BYTE PTR $LN13@DrawVRP[eax]
	jmp	DWORD PTR $LN14@DrawVRP[ecx*4]
$LN3@DrawVRP:

; 2241 : 		{
; 2242 : 			case FireControlComputer::Nav:
; 2243 : 			case FireControlComputer::AirGroundBomb:
; 2244 : 			case FireControlComputer::AirGroundRocket: // MLR 4/3/2004 - 
; 2245 : 			case FireControlComputer::AirGroundLaser:
; 2246 : 			case FireControlComputer::AirGroundMissile:
; 2247 : 			case FireControlComputer::AirGroundHARM:
; 2248 : 			case FireControlComputer::AirGroundCamera:
; 2249 : 				if (fabs(VRPAz) < (90.0F * DTR))

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5056]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv228[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv228[ebp]
	jbe	$LN2@DrawVRP

; 2250 : 				{
; 2251 : 					xPos = RadToHudUnitsX(VRPAz);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5056]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 2252 : 					yPos = RadToHudUnitsY(VRPElev);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+5060]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 2253 : 					display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2254 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2255 : 
; 2256 : 					display->Line(xPos - Lenght, yPos, xPos, yPos + Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2257 : 					display->Line(xPos, yPos + Lenght, xPos + Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2258 : 					display->Line(xPos + Lenght, yPos, xPos, yPos - Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2259 : 					display->Line(xPos, yPos - Lenght, xPos - Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2260 : 
; 2261 : 					// display->Circle(xPos - Diam/2, yPos, Diam);  // JPG 17 Dec 03 - A circle is for the PUP, not this crap
; 2262 : 
; 2263 : 					display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2264 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN2@DrawVRP:
$LN1@DrawVRP:
$LN4@DrawVRP:
$LN11@DrawVRP:

; 2265 : 				}
; 2266 : 				break;
; 2267 : 			default:
; 2268 : 				break;
; 2269 : 		}
; 2270 : 	}
; 2271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@DrawVRP:
	DD	$LN3@DrawVRP
	DD	$LN1@DrawVRP
$LN13@DrawVRP:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
?DrawVRP@HudClass@@QAEXXZ ENDP				; HudClass::DrawVRP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv226 = -20						; size = 4
tv85 = -16						; size = 4
_xPos$ = -12						; size = 4
_yPos$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawVIP@HudClass@@QAEXXZ PROC				; HudClass::DrawVIP
; _this$ = ecx

; 2185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2186 : 	//MI INS stuff
; 2187 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN9@DrawVIP
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN9@DrawVIP

; 2188 : 	{
; 2189 : 		if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN9@DrawVIP
	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN9@DrawVIP

; 2190 : 			return;

	jmp	$LN11@DrawVIP
$LN9@DrawVIP:

; 2191 : 	}
; 2192 : 	float xPos,yPos;
; 2193 : 	if (!VIPValid || (FCC->GetMasterMode() == FireControlComputer::Dogfight))//me123 status test.)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5052]
	test	edx, edx
	je	SHORT $LN7@DrawVIP
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN8@DrawVIP
$LN7@DrawVIP:

; 2194 : 		return;

	jmp	$LN11@DrawVIP

; 2195 : 	else

	jmp	$LN4@DrawVIP
$LN8@DrawVIP:

; 2196 : 	{
; 2197 : 		// Draw the waypoint on the ground
; 2198 : 		switch (FCC->GetMasterMode())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv85[ebp], eax
	cmp	DWORD PTR tv85[ebp], 4
	jl	$LN1@DrawVIP
	cmp	DWORD PTR tv85[ebp], 8
	jle	SHORT $LN3@DrawVIP
	cmp	DWORD PTR tv85[ebp], 11			; 0000000bH
	je	SHORT $LN3@DrawVIP
	jmp	$LN1@DrawVIP
$LN3@DrawVIP:

; 2199 : 		{
; 2200 : 			case FireControlComputer::Nav:
; 2201 : 			case FireControlComputer::AirGroundBomb:
; 2202 : 			case FireControlComputer::AirGroundLaser:
; 2203 : 			case FireControlComputer::AirGroundMissile:
; 2204 : 			case FireControlComputer::AirGroundHARM:
; 2205 : 			case FireControlComputer::AirGroundCamera:
; 2206 : 				if (fabs(VIPAz) < (90.0F * DTR))

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5044]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv226[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv226[ebp]
	jbe	$LN2@DrawVIP

; 2207 : 				{
; 2208 : 					xPos = RadToHudUnitsX(VIPAz);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5044]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 2209 : 					yPos = RadToHudUnitsY(VIPElev);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+5048]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 2210 : 					display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2211 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2212 : 					display->Line(xPos - Lenght, yPos, xPos, yPos + Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2213 : 					display->Line(xPos, yPos + Lenght, xPos + Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2214 : 					display->Line(xPos + Lenght, yPos, xPos, yPos - Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2215 : 					display->Line(xPos, yPos - Lenght, xPos - Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2216 : 					// display->Circle(xPos - Diam/2, yPos, Diam);  // JPG 17 Dec 03 No no no, not a circle, draw a diamond
; 2217 : 					display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2218 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN2@DrawVIP:
$LN1@DrawVIP:
$LN4@DrawVIP:
$LN11@DrawVIP:

; 2219 : 				}
; 2220 : 				break;
; 2221 : 			default:
; 2222 : 				break;
; 2223 : 		}
; 2224 : 	}
; 2225 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawVIP@HudClass@@QAEXXZ ENDP				; HudClass::DrawVIP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv422 = -28						; size = 4
tv337 = -24						; size = 4
tv221 = -20						; size = 4
tv88 = -16						; size = 4
_xPos$ = -12						; size = 4
_yPos$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawOA@HudClass@@QAEXXZ PROC				; HudClass::DrawOA
; _this$ = ecx

; 2111 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2112 : 	//MI INS stuff
; 2113 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN18@DrawOA
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN18@DrawOA

; 2114 : 	{
; 2115 : 		if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN18@DrawOA
	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN18@DrawOA

; 2116 : 			return;

	jmp	$LN20@DrawOA
$LN18@DrawOA:

; 2117 : 	}
; 2118 : 	float xPos,yPos;
; 2119 : 	if ((!OA1Valid && !OA2Valid) || (FCC->GetMasterMode() == FireControlComputer::Dogfight))//me123 status test.)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5040]
	test	edx, edx
	jne	SHORT $LN15@DrawOA
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+5041]
	test	ecx, ecx
	je	SHORT $LN16@DrawOA
$LN15@DrawOA:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN17@DrawOA
$LN16@DrawOA:

; 2120 : 		return;

	jmp	$LN20@DrawOA

; 2121 : 	else

	jmp	$LN12@DrawOA
$LN17@DrawOA:

; 2122 : 	{
; 2123 : 		// Draw the waypoint on the ground
; 2124 : 		switch (FCC->GetMasterMode())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv88[ebp], eax
	mov	ecx, DWORD PTR tv88[ebp]
	sub	ecx, 4
	mov	DWORD PTR tv88[ebp], ecx
	cmp	DWORD PTR tv88[ebp], 9
	ja	$LN9@DrawOA
	mov	edx, DWORD PTR tv88[ebp]
	movzx	eax, BYTE PTR $LN22@DrawOA[edx]
	jmp	DWORD PTR $LN24@DrawOA[eax*4]
$LN11@DrawOA:

; 2125 : 		{
; 2126 : 			case FireControlComputer::Nav:
; 2127 : 			case FireControlComputer::AirGroundBomb:
; 2128 : 			case FireControlComputer::AirGroundRocket: // MLR 4/3/2004 - 
; 2129 : 			case FireControlComputer::AirGroundLaser:
; 2130 : 			case FireControlComputer::AirGroundMissile:
; 2131 : 			case FireControlComputer::AirGroundHARM:
; 2132 : 			case FireControlComputer::AirGroundCamera:
; 2133 : 				if (fabs(OA1Az) < (90.0F * DTR))

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+5024]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv337[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv337[ebp]
	jbe	$LN10@DrawOA

; 2134 : 				{
; 2135 : 					xPos = RadToHudUnitsX(OA1Az);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5024]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 2136 : 					yPos = RadToHudUnitsY(OA1Elev);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5028]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 2137 : 					display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2138 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2139 : 					display->Line(xPos - TrigWidth/2, yPos - TrigHeight/2, xPos + TrigWidth/2, yPos - TrigHeight/2);

	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _xPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2140 : 					display->Line(xPos + TrigWidth/2, yPos - TrigHeight/2, xPos, yPos + TrigHeight/2);

	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2141 : 					display->Line(xPos, yPos + TrigHeight/2, xPos - TrigWidth/2, yPos - TrigHeight/2);

	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _xPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2142 : 					display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2143 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN10@DrawOA:
$LN9@DrawOA:
$LN12@DrawOA:

; 2144 : 				}
; 2145 : 				break;
; 2146 : 			default:
; 2147 : 				break;
; 2148 : 		}
; 2149 : 	}
; 2150 : 	if(!OA2Valid || (FCC->GetMasterMode() == FireControlComputer::Dogfight))//me123 status test.)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5041]
	test	edx, edx
	je	SHORT $LN7@DrawOA
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN8@DrawOA
$LN7@DrawOA:

; 2151 : 		return;

	jmp	$LN20@DrawOA

; 2152 : 	else

	jmp	$LN4@DrawOA
$LN8@DrawOA:

; 2153 : 	{
; 2154 : 		// Draw the waypoint on the ground
; 2155 : 		switch (FCC->GetMasterMode())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv221[ebp], eax
	mov	edx, DWORD PTR tv221[ebp]
	sub	edx, 4
	mov	DWORD PTR tv221[ebp], edx
	cmp	DWORD PTR tv221[ebp], 9
	ja	$LN1@DrawOA
	mov	eax, DWORD PTR tv221[ebp]
	movzx	ecx, BYTE PTR $LN23@DrawOA[eax]
	jmp	DWORD PTR $LN25@DrawOA[ecx*4]
$LN3@DrawOA:

; 2156 : 		{
; 2157 : 			case FireControlComputer::Nav:
; 2158 : 			case FireControlComputer::AirGroundBomb:
; 2159 : 			case FireControlComputer::AirGroundRocket: // MLR 4/3/2004 - 
; 2160 : 			case FireControlComputer::AirGroundLaser:
; 2161 : 			case FireControlComputer::AirGroundMissile:
; 2162 : 			case FireControlComputer::AirGroundHARM:
; 2163 : 			case FireControlComputer::AirGroundCamera:
; 2164 : 				if (fabs(OA2Az) < (90.0F * DTR))

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+5032]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv422[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv422[ebp]
	jbe	$LN2@DrawOA

; 2165 : 				{
; 2166 : 					xPos = RadToHudUnitsX(OA2Az);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+5032]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 2167 : 					yPos = RadToHudUnitsY(OA2Elev);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+5036]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 2168 : 					display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2169 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2170 : 					display->Line(xPos - TrigWidth/2, yPos - TrigHeight/2, xPos + TrigWidth/2, yPos - TrigHeight/2);

	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _xPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2171 : 					display->Line(xPos + TrigWidth/2, yPos - TrigHeight/2, xPos, yPos + TrigHeight/2);

	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2172 : 					display->Line(xPos, yPos + TrigHeight/2, xPos - TrigWidth/2, yPos - TrigHeight/2);

	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _yPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigWidth
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _xPos$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _TrigHeight
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2173 : 					display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2174 : 								hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN2@DrawOA:
$LN1@DrawOA:
$LN4@DrawOA:
$LN20@DrawOA:

; 2175 : 				}
; 2176 : 				break;
; 2177 : 				break;
; 2178 : 			default:
; 2179 : 				break;
; 2180 : 		}
; 2181 : 	}
; 2182 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN24@DrawOA:
	DD	$LN11@DrawOA
	DD	$LN9@DrawOA
$LN22@DrawOA:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	npad	2
$LN25@DrawOA:
	DD	$LN3@DrawOA
	DD	$LN1@DrawOA
$LN23@DrawOA:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
?DrawOA@HudClass@@QAEXXZ ENDP				; HudClass::DrawOA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?CheckMSLFloor@HudClass@@QAEXXZ PROC			; HudClass::CheckMSLFloor
; _this$ = ecx

; 2088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2089 : 	//No Message if gear down
; 2090 : 	if(((AircraftClass*)ownship)->af->gearPos > 0.5F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN7@CheckMSLFl

; 2091 : 		return;

	jmp	$LN8@CheckMSLFl
$LN7@CheckMSLFl:

; 2092 : 	//Above our setting and descending
; 2093 : 	if(-cockpitFlightData.z <= MSLFloor + 20.0F &&
; 2094 : 			-cockpitFlightData.zDot < 0)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+5008]
	addss	xmm1, DWORD PTR __real@41a00000
	comiss	xmm1, xmm0
	jb	$LN5@CheckMSLFl
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@CheckMSLFl

; 2095 : 	{
; 2096 : 		if(WasAboveMSLFloor)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5004]
	test	edx, edx
	je	SHORT $LN5@CheckMSLFl

; 2097 : 		{
; 2098 : 			for(int i = 0; i < 2; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@CheckMSLFl
$LN3@CheckMSLFl:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@CheckMSLFl:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN2@CheckMSLFl

; 2099 : 				F4SoundFXSetDist( ownship->af->GetAltitudeSnd(), FALSE, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetAltitudeSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetAltitudeSnd
	push	eax
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@CheckMSLFl
$LN2@CheckMSLFl:

; 2100 : 
; 2101 : 			WasAboveMSLFloor = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5004], 0
$LN5@CheckMSLFl:

; 2102 : 		}
; 2103 : 	}
; 2104 : 
; 2105 : 	if(-cockpitFlightData.z > (MSLFloor + 20.0F) && !WasAboveMSLFloor)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+5008]
	addss	xmm1, DWORD PTR __real@41a00000
	comiss	xmm0, xmm1
	jbe	SHORT $LN1@CheckMSLFl
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+5004]
	test	eax, eax
	jne	SHORT $LN1@CheckMSLFl

; 2106 : 		WasAboveMSLFloor = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5004], 1
$LN1@CheckMSLFl:
$LN8@CheckMSLFl:

; 2107 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckMSLFloor@HudClass@@QAEXXZ ENDP			; HudClass::CheckMSLFloor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_Pitch$1 = -40						; size = 4
_factor$2 = -36						; size = 4
_Pitch$3 = -32						; size = 4
_factor$4 = -28						; size = 4
_Pitch$5 = -24						; size = 4
_factor$6 = -20						; size = 4
_Angle$7 = -16						; size = 4
_Angle$8 = -12						; size = 4
_Angle$9 = -8						; size = 4
_this$ = -4						; size = 4
_Alt$ = 8						; size = 4
?FindPitchAngle@HudClass@@QAEHM@Z PROC			; HudClass::FindPitchAngle
; _this$ = ecx

; 1953 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1954 : 	if(!ownship)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN21@FindPitchA

; 1955 : 		return FALSE;

	xor	eax, eax
	jmp	$LN22@FindPitchA
$LN21@FindPitchA:

; 1956 : 
; 1957 : 	if(Alt <= 5000)

	movss	xmm0, DWORD PTR __real@459c4000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	SHORT $LN20@FindPitchA

; 1958 : 	{
; 1959 : 		//Below 5000ft we always have 30
; 1960 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN17@FindPitchA

; 1961 : 		{
; 1962 : 			if((cockpitFlightData.pitch * RTD) <= 30 &&
; 1963 : 					cockpitFlightData.pitch * RTD >= -30)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR __real@41f00000
	comiss	xmm1, xmm0
	jb	SHORT $LN18@FindPitchA
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	comiss	xmm0, DWORD PTR __real@c1f00000
	jb	SHORT $LN18@FindPitchA

; 1964 : 			{
; 1965 : 				return TRUE;

	mov	eax, 1
	jmp	$LN22@FindPitchA

; 1966 : 			}
; 1967 : 			else

	jmp	SHORT $LN17@FindPitchA
$LN18@FindPitchA:

; 1968 : 				return FALSE;

	xor	eax, eax
	jmp	$LN22@FindPitchA
$LN17@FindPitchA:

; 1969 : 		}
; 1970 : 	}

	jmp	$LN1@FindPitchA
$LN20@FindPitchA:

; 1971 : 	else if(Alt > 5000 && Alt <= 10000)

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@459c4000
	jbe	$LN15@FindPitchA
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN15@FindPitchA

; 1972 : 	{
; 1973 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN12@FindPitchA

; 1974 : 		{
; 1975 : 			float factor = 5000 / 5; //5 less bank in 5000ft

	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _factor$6[ebp], xmm0

; 1976 : 			float Pitch = (Alt - 5000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@459c4000
	divss	xmm0, DWORD PTR _factor$6[ebp]
	movss	DWORD PTR _Pitch$5[ebp], xmm0

; 1977 : 			float Angle = 30 - Pitch;

	movss	xmm0, DWORD PTR __real@41f00000
	subss	xmm0, DWORD PTR _Pitch$5[ebp]
	movss	DWORD PTR _Angle$9[ebp], xmm0

; 1978 : 			if(cockpitFlightData.pitch * RTD <= Angle &&
; 1979 : 					cockpitFlightData.pitch * RTD >= -Angle)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$9[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN13@FindPitchA
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$9[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN13@FindPitchA

; 1980 : 			{
; 1981 : 				return TRUE;

	mov	eax, 1
	jmp	$LN22@FindPitchA

; 1982 : 			}
; 1983 : 			else

	jmp	SHORT $LN12@FindPitchA
$LN13@FindPitchA:

; 1984 : 				return FALSE;

	xor	eax, eax
	jmp	$LN22@FindPitchA
$LN12@FindPitchA:

; 1985 : 		}
; 1986 : 	}

	jmp	$LN1@FindPitchA
$LN15@FindPitchA:

; 1987 : 	else if(Alt > 10000 && Alt <= 25000)

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@461c4000
	jbe	$LN10@FindPitchA
	movss	xmm0, DWORD PTR __real@46c35000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN10@FindPitchA

; 1988 : 	{
; 1989 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN7@FindPitchA

; 1990 : 		{
; 1991 : 			float factor = 15000 / 10; //10 less bank in 15000ft

	movss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _factor$4[ebp], xmm0

; 1992 : 			float Pitch = (Alt - 15000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@466a6000
	divss	xmm0, DWORD PTR _factor$4[ebp]
	movss	DWORD PTR _Pitch$3[ebp], xmm0

; 1993 : 			float Angle = 25 - Pitch;

	movss	xmm0, DWORD PTR __real@41c80000
	subss	xmm0, DWORD PTR _Pitch$3[ebp]
	movss	DWORD PTR _Angle$8[ebp], xmm0

; 1994 : 			if(cockpitFlightData.pitch * RTD <= Angle &&
; 1995 : 					cockpitFlightData.pitch * RTD >= -Angle)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$8[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN8@FindPitchA
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$8[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN8@FindPitchA

; 1996 : 			{
; 1997 : 				return TRUE;

	mov	eax, 1
	jmp	$LN22@FindPitchA

; 1998 : 			}
; 1999 : 			else

	jmp	SHORT $LN7@FindPitchA
$LN8@FindPitchA:

; 2000 : 				return FALSE;

	xor	eax, eax
	jmp	$LN22@FindPitchA
$LN7@FindPitchA:

; 2001 : 		}
; 2002 : 	}

	jmp	$LN1@FindPitchA
$LN10@FindPitchA:

; 2003 : 	else if(Alt > 25000 && Alt <= 50000)

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@46c35000
	jbe	$LN5@FindPitchA
	movss	xmm0, DWORD PTR __real@47435000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN5@FindPitchA

; 2004 : 	{
; 2005 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN2@FindPitchA

; 2006 : 		{
; 2007 : 			float factor = 25000 / 5; //5 less bank in 25000ft

	movss	xmm0, DWORD PTR __real@459c4000
	movss	DWORD PTR _factor$2[ebp], xmm0

; 2008 : 			float Pitch = (Alt - 25000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@46c35000
	divss	xmm0, DWORD PTR _factor$2[ebp]
	movss	DWORD PTR _Pitch$1[ebp], xmm0

; 2009 : 			float Angle = 15 - Pitch;

	movss	xmm0, DWORD PTR __real@41700000
	subss	xmm0, DWORD PTR _Pitch$1[ebp]
	movss	DWORD PTR _Angle$7[ebp], xmm0

; 2010 : 			if(cockpitFlightData.pitch * RTD <= Angle &&
; 2011 : 					cockpitFlightData.pitch * RTD >= -Angle)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$7[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@FindPitchA
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$7[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN3@FindPitchA

; 2012 : 			{
; 2013 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $LN22@FindPitchA

; 2014 : 			}
; 2015 : 			else

	jmp	SHORT $LN2@FindPitchA
$LN3@FindPitchA:

; 2016 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN22@FindPitchA
$LN2@FindPitchA:

; 2017 : 		}
; 2018 : 	}
; 2019 : 	else

	jmp	SHORT $LN1@FindPitchA
$LN5@FindPitchA:

; 2020 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN22@FindPitchA
$LN1@FindPitchA:

; 2021 : 
; 2022 : 	return FALSE;

	xor	eax, eax
$LN22@FindPitchA:

; 2023 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindPitchAngle@HudClass@@QAEHM@Z ENDP			; HudClass::FindPitchAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_Roll$1 = -52						; size = 4
_factor$2 = -48						; size = 4
_Roll$3 = -44						; size = 4
_factor$4 = -40						; size = 4
_Roll$5 = -36						; size = 4
_factor$6 = -32						; size = 4
_Roll$7 = -28						; size = 4
_factor$8 = -24						; size = 4
_Angle$9 = -20						; size = 4
_Angle$10 = -16						; size = 4
_Angle$11 = -12						; size = 4
_Angle$12 = -8						; size = 4
_this$ = -4						; size = 4
_Alt$ = 8						; size = 4
?FindRollAngle@HudClass@@QAEHM@Z PROC			; HudClass::FindRollAngle
; _this$ = ecx

; 1866 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1867 : 	if (!ownship){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN26@FindRollAn

; 1868 : 		// JB 010528
; 1869 : 		return FALSE; // JB 010528

	xor	eax, eax
	jmp	$LN27@FindRollAn
$LN26@FindRollAn:

; 1870 : 	}
; 1871 : 
; 1872 : 	/*Roll is from 0 to 180 and -180 to 0 clockwise
; 1873 : 	  Alt is hight above terrain*/
; 1874 : 	if (Alt <= 3000){

	movss	xmm0, DWORD PTR __real@453b8000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	SHORT $LN25@FindRollAn

; 1875 : 		//Below 3000ft we always have 60
; 1876 : 		if (((AircraftClass*)ownship)->af->platform->IsPlayer()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN22@FindRollAn

; 1877 : 			if((cockpitFlightData.roll * RTD) <= 60 && cockpitFlightData.roll * RTD >= -60){

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR __real@42700000
	comiss	xmm1, xmm0
	jb	SHORT $LN23@FindRollAn
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	comiss	xmm0, DWORD PTR __real@c2700000
	jb	SHORT $LN23@FindRollAn

; 1878 : 				return TRUE;

	mov	eax, 1
	jmp	$LN27@FindRollAn

; 1879 : 			}
; 1880 : 			else {

	jmp	SHORT $LN22@FindRollAn
$LN23@FindRollAn:

; 1881 : 				return FALSE;

	xor	eax, eax
	jmp	$LN27@FindRollAn
$LN22@FindRollAn:

; 1882 : 			}
; 1883 : 		}
; 1884 : 	}

	jmp	$LN1@FindRollAn
$LN25@FindRollAn:

; 1885 : 	else if(Alt > 3000 && Alt <= 5000){

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN20@FindRollAn
	movss	xmm0, DWORD PTR __real@459c4000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN20@FindRollAn

; 1886 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN17@FindRollAn

; 1887 : 			float factor = 2000 / 30; //30 less bank in 2000ft

	movss	xmm0, DWORD PTR __real@42840000
	movss	DWORD PTR _factor$8[ebp], xmm0

; 1888 : 			float Roll = (Alt - 3000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@453b8000
	divss	xmm0, DWORD PTR _factor$8[ebp]
	movss	DWORD PTR _Roll$7[ebp], xmm0

; 1889 : 			float Angle = 60 - Roll;

	movss	xmm0, DWORD PTR __real@42700000
	subss	xmm0, DWORD PTR _Roll$7[ebp]
	movss	DWORD PTR _Angle$12[ebp], xmm0

; 1890 : 			if (cockpitFlightData.roll * RTD <= Angle && cockpitFlightData.roll * RTD >= -Angle){

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$12[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN18@FindRollAn
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$12[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN18@FindRollAn

; 1891 : 				return TRUE;

	mov	eax, 1
	jmp	$LN27@FindRollAn

; 1892 : 			}
; 1893 : 			else {

	jmp	SHORT $LN17@FindRollAn
$LN18@FindRollAn:

; 1894 : 				return FALSE;

	xor	eax, eax
	jmp	$LN27@FindRollAn
$LN17@FindRollAn:

; 1895 : 			}
; 1896 : 		}
; 1897 : 	}

	jmp	$LN1@FindRollAn
$LN20@FindRollAn:

; 1898 : 	else if(Alt > 5000 && Alt <= 10000)

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@459c4000
	jbe	$LN15@FindRollAn
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN15@FindRollAn

; 1899 : 	{
; 1900 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN12@FindRollAn

; 1901 : 		{
; 1902 : 			float factor = 5000 / 5; //5 less bank in 5000ft

	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _factor$6[ebp], xmm0

; 1903 : 			float Roll = (Alt - 5000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@459c4000
	divss	xmm0, DWORD PTR _factor$6[ebp]
	movss	DWORD PTR _Roll$5[ebp], xmm0

; 1904 : 			float Angle = 30 - Roll;

	movss	xmm0, DWORD PTR __real@41f00000
	subss	xmm0, DWORD PTR _Roll$5[ebp]
	movss	DWORD PTR _Angle$11[ebp], xmm0

; 1905 : 			if(cockpitFlightData.roll * RTD <= Angle &&
; 1906 : 					cockpitFlightData.roll * RTD >= -Angle)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$11[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN13@FindRollAn
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$11[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN13@FindRollAn

; 1907 : 			{
; 1908 : 				return TRUE;

	mov	eax, 1
	jmp	$LN27@FindRollAn

; 1909 : 			}
; 1910 : 			else

	jmp	SHORT $LN12@FindRollAn
$LN13@FindRollAn:

; 1911 : 				return FALSE;

	xor	eax, eax
	jmp	$LN27@FindRollAn
$LN12@FindRollAn:

; 1912 : 		}
; 1913 : 	}

	jmp	$LN1@FindRollAn
$LN15@FindRollAn:

; 1914 : 	else if(Alt > 10000 && Alt <= 25000)

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@461c4000
	jbe	$LN10@FindRollAn
	movss	xmm0, DWORD PTR __real@46c35000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN10@FindRollAn

; 1915 : 	{
; 1916 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN7@FindRollAn

; 1917 : 		{
; 1918 : 			float factor = 15000 / 10; //10 less bank in 15000ft

	movss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _factor$4[ebp], xmm0

; 1919 : 			float Roll = (Alt - 15000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@466a6000
	divss	xmm0, DWORD PTR _factor$4[ebp]
	movss	DWORD PTR _Roll$3[ebp], xmm0

; 1920 : 			float Angle = 25 - Roll;

	movss	xmm0, DWORD PTR __real@41c80000
	subss	xmm0, DWORD PTR _Roll$3[ebp]
	movss	DWORD PTR _Angle$10[ebp], xmm0

; 1921 : 			if(cockpitFlightData.roll * RTD <= Angle &&
; 1922 : 					cockpitFlightData.roll * RTD >= -Angle)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$10[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN8@FindRollAn
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$10[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN8@FindRollAn

; 1923 : 			{
; 1924 : 				return TRUE;

	mov	eax, 1
	jmp	$LN27@FindRollAn

; 1925 : 			}
; 1926 : 			else

	jmp	SHORT $LN7@FindRollAn
$LN8@FindRollAn:

; 1927 : 				return FALSE;

	xor	eax, eax
	jmp	$LN27@FindRollAn
$LN7@FindRollAn:

; 1928 : 		}
; 1929 : 	}

	jmp	$LN1@FindRollAn
$LN10@FindRollAn:

; 1930 : 	else if(Alt > 25000 && Alt <= 50000)

	movss	xmm0, DWORD PTR _Alt$[ebp]
	comiss	xmm0, DWORD PTR __real@46c35000
	jbe	$LN5@FindRollAn
	movss	xmm0, DWORD PTR __real@47435000
	comiss	xmm0, DWORD PTR _Alt$[ebp]
	jb	$LN5@FindRollAn

; 1931 : 	{
; 1932 : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN2@FindRollAn

; 1933 : 		{
; 1934 : 			float factor = 25000 / 5; //5 less bank in 25000ft

	movss	xmm0, DWORD PTR __real@459c4000
	movss	DWORD PTR _factor$2[ebp], xmm0

; 1935 : 			float Roll = (Alt - 25000) / factor;

	movss	xmm0, DWORD PTR _Alt$[ebp]
	subss	xmm0, DWORD PTR __real@46c35000
	divss	xmm0, DWORD PTR _factor$2[ebp]
	movss	DWORD PTR _Roll$1[ebp], xmm0

; 1936 : 			float Angle = 15 - Roll;

	movss	xmm0, DWORD PTR __real@41700000
	subss	xmm0, DWORD PTR _Roll$1[ebp]
	movss	DWORD PTR _Angle$9[ebp], xmm0

; 1937 : 			if(cockpitFlightData.roll * RTD <= Angle &&
; 1938 : 					cockpitFlightData.roll * RTD >= -Angle)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$9[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@FindRollAn
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _Angle$9[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, xmm1
	jb	SHORT $LN3@FindRollAn

; 1939 : 			{
; 1940 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $LN27@FindRollAn

; 1941 : 			}
; 1942 : 			else

	jmp	SHORT $LN2@FindRollAn
$LN3@FindRollAn:

; 1943 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN27@FindRollAn
$LN2@FindRollAn:

; 1944 : 		}
; 1945 : 	}
; 1946 : 	else

	jmp	SHORT $LN1@FindRollAn
$LN5@FindRollAn:

; 1947 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN27@FindRollAn
$LN1@FindRollAn:

; 1948 : 
; 1949 : 	return FALSE;

	xor	eax, eax
$LN27@FindRollAn:

; 1950 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindRollAngle@HudClass@@QAEHM@Z ENDP			; HudClass::FindRollAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?RadToHudUnitsY@HudClass@@AAEMM@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_mr$ = 8						; size = 4
?RadToHudUnitsY@HudClass@@AAEMM@Z PROC			; HudClass::RadToHudUnitsY, COMDAT
; _this$ = ecx

; 220  : 	float	RadToHudUnitsY (float mr)	{ return RadToHudUnits(mr) * mVScale; };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _mr$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR tv75[ebp]
	movss	xmm0, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+5184]
	movss	DWORD PTR tv78[ebp], xmm0
	fld	DWORD PTR tv78[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?RadToHudUnitsY@HudClass@@AAEMM@Z ENDP			; HudClass::RadToHudUnitsY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?RadToHudUnitsX@HudClass@@AAEMM@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_mr$ = 8						; size = 4
?RadToHudUnitsX@HudClass@@AAEMM@Z PROC			; HudClass::RadToHudUnitsX, COMDAT
; _this$ = ecx

; 219  : 	float	RadToHudUnitsX (float mr)	{ return RadToHudUnits(mr) * mHScale; };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _mr$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR tv75[ebp]
	movss	xmm0, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+5188]
	movss	DWORD PTR tv78[ebp], xmm0
	fld	DWORD PTR tv78[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?RadToHudUnitsX@HudClass@@AAEMM@Z ENDP			; HudClass::RadToHudUnitsX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_trig$1 = -28						; size = 8
_roll$ = -20						; size = 4
_edist$2 = -16						; size = 4
_i$3 = -12						; size = 4
_i$4 = -8						; size = 4
_this$ = -4						; size = 4
?DrawRollCue@HudClass@@AAEXXZ PROC			; HudClass::DrawRollCue
; _this$ = ecx

; 2026 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2027 : 	static const float basey = hudWinY[HEADING_WINDOW_LO] +
; 2028 : 		hudWinHeight[HEADING_WINDOW_LO] * 0.5F - 0.075f;

	mov	eax, DWORD PTR ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA
	and	eax, 1
	jne	SHORT $LN13@DrawRollCu
	mov	ecx, DWORD PTR ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA, ecx
	mov	edx, 4
	imul	edx, 41					; 00000029H
	mov	eax, 4
	imul	eax, 41					; 00000029H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	subss	xmm0, DWORD PTR __real@3d99999a
	movss	DWORD PTR ?basey@?1??DrawRollCue@HudClass@@AAEXXZ@4MB, xmm0
$LN13@DrawRollCu:

; 2029 : 	//static bool initonce = false;
; 2030 : 	static const float MAXROLL = 45 * DTR;
; 2031 : 	static const float angles[] = { MAXROLL, 30 *DTR, 20 * DTR, 10 * DTR};

	mov	ecx, DWORD PTR ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA
	and	ecx, 2
	jne	SHORT $LN12@DrawRollCu
	mov	edx, DWORD PTR ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA
	or	edx, 2
	mov	DWORD PTR ?$S1@?1??DrawRollCue@HudClass@@AAEXXZ@4IA, edx
	movss	xmm0, DWORD PTR ?MAXROLL@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	movss	DWORD PTR ?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB, xmm0
	movss	xmm0, DWORD PTR __real@3f060a91
	movss	DWORD PTR ?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB+4, xmm0
	movss	xmm0, DWORD PTR __real@3eb2b8c1
	movss	DWORD PTR ?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB+8, xmm0
	movss	xmm0, DWORD PTR __real@3e32b8c1
	movss	DWORD PTR ?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB+12, xmm0
$LN12@DrawRollCu:

; 2032 : 	static const int nangles = sizeof(angles)/sizeof(angles[0]);
; 2033 : 	static float x1points[nangles], x2points[nangles], y1points[nangles], y2points[nangles];
; 2034 : 	static const float sdist = 0.35f, oedist = 0.40f;
; 2035 : 
; 2036 : 	//if (initonce == false) { // JPO precalculate drawing points
; 2037 : 	if(CalcRoll){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+5092]
	test	ecx, ecx
	je	$LN11@DrawRollCu

; 2038 : 		float edist = oedist;

	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	movss	DWORD PTR _edist$2[ebp], xmm0

; 2039 : 		mlTrig trig;
; 2040 : 		for (int i = 0; i  < nangles; i++) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN10@DrawRollCu
$LN9@DrawRollCu:
	mov	edx, DWORD PTR _i$3[ebp]
	add	edx, 1
	mov	DWORD PTR _i$3[ebp], edx
$LN10@DrawRollCu:
	cmp	DWORD PTR _i$3[ebp], 4
	jge	$LN8@DrawRollCu

; 2041 : 			if (i > 1) edist = 0.38f;

	cmp	DWORD PTR _i$3[ebp], 1
	jle	SHORT $LN7@DrawRollCu
	movss	xmm0, DWORD PTR __real@3ec28f5c
	movss	DWORD PTR _edist$2[ebp], xmm0
$LN7@DrawRollCu:

; 2042 : 			mlSinCos( &trig, angles[i]);

	mov	eax, DWORD PTR _i$3[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?angles@?1??DrawRollCue@HudClass@@AAEXXZ@4QBMB[eax*4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$1[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2043 : 			x1points[i] = sdist*trig.sin;

	movss	xmm0, DWORD PTR ?sdist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	mulss	xmm0, DWORD PTR _trig$1[ebp]
	mov	edx, DWORD PTR _i$3[ebp]
	movss	DWORD PTR ?x1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[edx*4], xmm0

; 2044 : 			y1points[i] = -sdist*trig.cos;

	movss	xmm0, DWORD PTR ?sdist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _trig$1[ebp+4]
	mov	eax, DWORD PTR _i$3[ebp]
	movss	DWORD PTR ?y1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[eax*4], xmm0

; 2045 : 			x2points[i] = edist*trig.sin;

	movss	xmm0, DWORD PTR _edist$2[ebp]
	mulss	xmm0, DWORD PTR _trig$1[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	movss	DWORD PTR ?x2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[ecx*4], xmm0

; 2046 : 			y2points[i] = -edist*trig.cos;

	movss	xmm0, DWORD PTR _edist$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _trig$1[ebp+4]
	mov	edx, DWORD PTR _i$3[ebp]
	movss	DWORD PTR ?y2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[edx*4], xmm0

; 2047 : 		}

	jmp	$LN9@DrawRollCu
$LN8@DrawRollCu:

; 2048 : 		//initonce = true;
; 2049 : 		CalcRoll = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5092], 0
$LN11@DrawRollCu:

; 2050 : 	}
; 2051 : 
; 2052 : 	display->AdjustOriginInViewport( 0,  basey);

	push	ecx
	movss	xmm0, DWORD PTR ?basey@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2053 : 
; 2054 : 	for (int i = 0; i  < nangles; i++) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN6@DrawRollCu
$LN5@DrawRollCu:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN6@DrawRollCu:
	cmp	DWORD PTR _i$4[ebp], 4
	jge	$LN4@DrawRollCu

; 2055 : 		display->Line(x1points[i], y1points[i], x2points[i], y2points[i]);

	mov	eax, DWORD PTR _i$4[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[eax*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?x2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[ecx*4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$4[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[edx*4]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$4[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?x1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[eax*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2056 : 		display->Line(-x1points[i], y1points[i], -x2points[i], y2points[i]);

	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[ecx*4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$4[ebp]
	movss	xmm0, DWORD PTR ?x2points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[edx*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$4[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?y1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[eax*4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$4[ebp]
	movss	xmm0, DWORD PTR ?x1points@?1??DrawRollCue@HudClass@@AAEXXZ@4PAMA[ecx*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2057 : #if 0
; 2058 : 		mlSinCos( &trig, angles[i]);
; 2059 : 		display->Line ( sdist*trig.sin, -sdist*trig.cos,  edist*trig.sin, -edist*trig.cos);
; 2060 : 		display->Line (-sdist*trig.sin, -sdist*trig.cos, -edist*trig.sin, -edist*trig.cos);
; 2061 : 		if (i > 1) edist = 0.38f;
; 2062 : #endif
; 2063 : 	}

	jmp	$LN5@DrawRollCu
$LN4@DrawRollCu:

; 2064 : 	display->Line(0, -sdist, 0, -oedist); // final cue line

	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?sdist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2065 : 	float roll = -cockpitFlightData.roll;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _roll$[ebp], xmm0

; 2066 : 	// Only draw the roll if within limits.
; 2067 : 	if (roll <= MAXROLL && roll >= -MAXROLL) {

	movss	xmm0, DWORD PTR ?MAXROLL@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	comiss	xmm0, DWORD PTR _roll$[ebp]
	jb	$LN3@DrawRollCu
	movss	xmm0, DWORD PTR ?MAXROLL@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _roll$[ebp]
	comiss	xmm1, xmm0
	jb	$LN3@DrawRollCu

; 2068 : 		display->AdjustRotationAboutOrigin(roll); // do the roll offset

	push	ecx
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2069 : 		// draw empty triange there.
; 2070 : 		//MI INS stuff
; 2071 : 		if(g_bRealisticAvionics && g_bINS)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN1@DrawRollCu
	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN1@DrawRollCu

; 2072 : 		{
; 2073 : 			if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN1@DrawRollCu
	push	1024					; 00000400H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawRollCu

; 2074 : 			{
; 2075 : 				display->ZeroRotationAboutOrigin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 2076 : 				display->AdjustOriginInViewport( 0,  -basey);

	movss	xmm0, DWORD PTR ?basey@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2077 : 				return;

	jmp	$LN14@DrawRollCu
$LN1@DrawRollCu:

; 2078 : 			}
; 2079 : 		}
; 2080 : 		display->Line(0, -oedist, -0.025f, -oedist-0.05f);

	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bccccccd
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2081 : 		display->Line(-0.025f, -oedist-0.05f, 0.025f, -oedist-0.05f);

	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ccccccd
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bccccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2082 : 		display->Line(0.025f, -oedist-0.05f, 0, -oedist);

	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?oedist@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ccccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2083 : 		display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin
$LN3@DrawRollCu:

; 2084 : 	}
; 2085 : 	display->AdjustOriginInViewport( 0,  -basey);

	movss	xmm0, DWORD PTR ?basey@?1??DrawRollCue@HudClass@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN14@DrawRollCu:

; 2086 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawRollCue@HudClass@@AAEXXZ ENDP			; HudClass::DrawRollCue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_trig$ = -48						; size = 8
_dx$ = -40						; size = 4
_dy$ = -36						; size = 4
tv153 = -32						; size = 4
tv152 = -28						; size = 4
tv143 = -24						; size = 4
_len$ = -20						; size = 4
_x$ = -16						; size = 4
_y$ = -12						; size = 4
_x1$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawTadpole@HudClass@@AAEXXZ PROC			; HudClass::DrawTadpole
; _this$ = ecx

; 1199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1200 : 	float dx, dy;
; 1201 : 	float x, x1, y;
; 1202 : 	float len;
; 1203 : 	mlTrig trig;
; 1204 : 
; 1205 : 	//MI INS stuff
; 1206 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN9@DrawTadpol
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN9@DrawTadpol

; 1207 : 	{
; 1208 : 		if(ownship && ownship->INSState(AircraftClass::INS_PowerOff) ||
; 1209 : 				!ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN7@DrawTadpol
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN8@DrawTadpol
$LN7@DrawTadpol:
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN9@DrawTadpol
$LN8@DrawTadpol:

; 1210 : 			return;

	jmp	$LN11@DrawTadpol
$LN9@DrawTadpol:

; 1211 : 	}
; 1212 : 
; 1213 : 	if (!waypointValid || (FCC->GetMasterMode() == FireControlComputer::Dogfight))//me123 status test.

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4952]
	test	eax, eax
	je	SHORT $LN5@DrawTadpol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN6@DrawTadpol
$LN5@DrawTadpol:

; 1214 : 	{
; 1215 : 		return;

	jmp	$LN11@DrawTadpol
$LN6@DrawTadpol:

; 1216 : 	}
; 1217 : 
; 1218 : 	dx = betaHudUnits;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4860]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1219 : 	dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1220 : 		hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 1221 : 		alphaHudUnits;

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+4856]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1222 : 
; 1223 : 	display->AdjustOriginInViewport (dx, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1224 : 	display->AdjustRotationAboutOrigin(-cockpitFlightData.roll);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1225 : 	x1 = max (min (waypointBearing / (10.0F * DTR), 1.0F), -1.0F) * hudWinWidth[PITCH_LADDER_WINDOW] * 0.75F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4940]
	divss	xmm0, DWORD PTR __real@3e32b8c1
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN13@DrawTadpol
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4940]
	divss	xmm0, DWORD PTR __real@3e32b8c1
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN14@DrawTadpol
$LN13@DrawTadpol:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv143[ebp], xmm0
$LN14@DrawTadpol:
	movss	xmm0, DWORD PTR tv143[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN17@DrawTadpol
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4940]
	divss	xmm0, DWORD PTR __real@3e32b8c1
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN15@DrawTadpol
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4940]
	divss	xmm0, DWORD PTR __real@3e32b8c1
	movss	DWORD PTR tv152[ebp], xmm0
	jmp	SHORT $LN16@DrawTadpol
$LN15@DrawTadpol:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv152[ebp], xmm0
$LN16@DrawTadpol:
	movss	xmm0, DWORD PTR tv152[ebp]
	movss	DWORD PTR tv153[ebp], xmm0
	jmp	SHORT $LN18@DrawTadpol
$LN17@DrawTadpol:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv153[ebp], xmm0
$LN18@DrawTadpol:
	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR tv153[ebp]
	mulss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _x1$[ebp], xmm0

; 1226 : 
; 1227 : 	display->Circle (x1, 0.0F, RadToHudUnits(0.003F));

	push	ecx
	movss	xmm0, DWORD PTR __real@3b449ba6
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1228 : 	//MI
; 1229 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@DrawTadpol

; 1230 : 		len = RadToHudUnits(0.012F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3c449ba6
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR _len$[ebp]

; 1231 : 	else

	jmp	SHORT $LN3@DrawTadpol
$LN4@DrawTadpol:

; 1232 : 		len = RadToHudUnits(0.016F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3c83126f
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR _len$[ebp]
$LN3@DrawTadpol:

; 1233 : 
; 1234 : 	mlSinCos (&trig, waypointBearing + cockpitFlightData.roll);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4940]
	addss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1235 : 	y = len * trig.cos;

	movss	xmm0, DWORD PTR _len$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _y$[ebp], xmm0

; 1236 : 	x = len * trig.sin;

	movss	xmm0, DWORD PTR _len$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 1237 : 
; 1238 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN2@DrawTadpol

; 1239 : 		display->Line (x1 + x, y, x1 + x * 0.25F, y * 0.25F);

	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	addss	xmm0, DWORD PTR _x1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1240 : 	else

	jmp	SHORT $LN1@DrawTadpol
$LN2@DrawTadpol:

; 1241 : 		display->Line (x1 + x, y, x1 + x * 0.1875F, y * 0.1875F);

	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR __real@3e400000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR __real@3e400000
	addss	xmm0, DWORD PTR _x1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN1@DrawTadpol:

; 1242 : 
; 1243 : 	display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 1244 : 
; 1245 : 	display->AdjustOriginInViewport (-dx, -dy);

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN11@DrawTadpol:

; 1246 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawTadpole@HudClass@@AAEXXZ ENDP			; HudClass::DrawTadpole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv436 = -164						; size = 4
tv446 = -160						; size = 4
tv431 = -156						; size = 4
tv608 = -152						; size = 4
_xPos$ = -148						; size = 4
tv459 = -144						; size = 4
_yPos$ = -140						; size = 4
_wpZ$1 = -136						; size = 4
tv473 = -132						; size = 4
tv441 = -128						; size = 4
tv463 = -124						; size = 4
tv455 = -120						; size = 4
tv322 = -116						; size = 4
tv309 = -112						; size = 4
tv339 = -108						; size = 4
tv323 = -104						; size = 4
tv353 = -100						; size = 4
tv352 = -96						; size = 4
_dz$2 = -92						; size = 4
_dx$3 = -88						; size = 4
_dy$4 = -84						; size = 4
_wpX$5 = -80						; size = 4
_wpY$6 = -76						; size = 4
_harmPod$7 = -72					; size = 4
_playerAC$ = -68					; size = 4
_displayRange$ = -61					; size = 1
_range$ = -60						; size = 4
_this$ = -56						; size = 4
_tmpStr$ = -52						; size = 24
_str$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?RangeToSteerpoint@HudClass@@AAEXXZ PROC		; HudClass::RangeToSteerpoint
; _this$ = ecx

; 1731 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1732 : 	//MI INS stuff
; 1733 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN36@RangeToSte
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN36@RangeToSte

; 1734 : 	{
; 1735 : 		if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN36@RangeToSte
	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN36@RangeToSte

; 1736 : 			return;

	jmp	$LN38@RangeToSte
$LN36@RangeToSte:

; 1737 : 	}
; 1738 : 	char tmpStr[24];
; 1739 : 	char str[24];
; 1740 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1741 : 
; 1742 : 	// MD -- 20040220: adding override for GM SP ground stabilization
; 1743 : 	if ((FCC->GetStptMode() == FireControlComputer::FCCGMPseudoPoint) && playerAC)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetStptMode@FireControlComputer@@QAE?AW4FCCStptMode@1@XZ ; FireControlComputer::GetStptMode
	cmp	eax, 3
	jne	$LN35@RangeToSte
	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN35@RangeToSte

; 1744 : 	{
; 1745 : 		float wpX=0.0f, wpY=0.0f, wpZ=0.0f, dx=0.0f, dy=0.0f, dz=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wpX$5[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wpY$6[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wpZ$1[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$3[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$4[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dz$2[ebp], xmm0

; 1746 : 		FCC->SavedWaypoint()->GetLocation (&wpX, &wpY, &wpZ);

	lea	edx, DWORD PTR _wpZ$1[ebp]
	push	edx
	lea	eax, DWORD PTR _wpY$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _wpX$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?SavedWaypoint@FireControlComputer@@QAEPAVWayPointClass@@XZ ; FireControlComputer::SavedWaypoint
	mov	ecx, eax
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1747 : 		// add in INS Drift
; 1748 : 		if(g_bINS && g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN33@RangeToSte
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN33@RangeToSte

; 1749 : 		{
; 1750 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN33@RangeToSte

; 1751 : 			{
; 1752 : 				wpX += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv431[ebp]
	movss	xmm0, DWORD PTR tv431[ebp]
	addss	xmm0, DWORD PTR _wpX$5[ebp]
	movss	DWORD PTR _wpX$5[ebp], xmm0

; 1753 : 				wpY += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv436[ebp]
	movss	xmm0, DWORD PTR tv436[ebp]
	addss	xmm0, DWORD PTR _wpY$6[ebp]
	movss	DWORD PTR _wpY$6[ebp], xmm0
$LN33@RangeToSte:

; 1754 : 			}
; 1755 : 		}
; 1756 : 
; 1757 : 		dx = wpX - playerAC->XPos();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv441[ebp]
	movss	xmm0, DWORD PTR _wpX$5[ebp]
	subss	xmm0, DWORD PTR tv441[ebp]
	movss	DWORD PTR _dx$3[ebp], xmm0

; 1758 : 		dy = wpY - playerAC->YPos();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv446[ebp]
	movss	xmm0, DWORD PTR _wpY$6[ebp]
	subss	xmm0, DWORD PTR tv446[ebp]
	movss	DWORD PTR _dy$4[ebp], xmm0

; 1759 : 		dz = OTWDriver.GetApproxGroundLevel(wpX, wpY) - playerAC->ZPos();

	push	ecx
	movss	xmm0, DWORD PTR _wpY$6[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wpX$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR tv455[ebp]
	movss	xmm0, DWORD PTR tv455[ebp]
	mov	ecx, DWORD PTR _playerAC$[ebp]
	movss	DWORD PTR tv608[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv459[ebp]
	movss	xmm0, DWORD PTR tv608[ebp]
	subss	xmm0, DWORD PTR tv459[ebp]
	movss	DWORD PTR _dz$2[ebp], xmm0

; 1760 : 		// add in INS Offset
; 1761 : 		if(g_bINS && g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	SHORT $LN31@RangeToSte
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN31@RangeToSte

; 1762 : 		{
; 1763 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN31@RangeToSte

; 1764 : 				dz -= playerAC->GetINSAltOffset();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSAltOffset@AircraftClass@@QAEMXZ	; AircraftClass::GetINSAltOffset
	fstp	DWORD PTR tv463[ebp]
	movss	xmm0, DWORD PTR _dz$2[ebp]
	subss	xmm0, DWORD PTR tv463[ebp]
	movss	DWORD PTR _dz$2[ebp], xmm0
$LN31@RangeToSte:

; 1765 : 		}
; 1766 : 
; 1767 : 		sprintf (tmpStr, "%03.0f>%02d", ((float)sqrt(dx*dx + dy*dy)) * FT_TO_NM, waypointNum + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4948]
	add	edx, 1
	push	edx
	movss	xmm0, DWORD PTR _dx$3[ebp]
	mulss	xmm0, DWORD PTR _dx$3[ebp]
	movss	xmm1, DWORD PTR _dy$4[ebp]
	mulss	xmm1, DWORD PTR _dy$4[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv473[ebp]
	movss	xmm0, DWORD PTR tv473[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@GJIKDFJJ@?$CF03?40f?$DO?$CF02d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 1768 : 	}
; 1769 : 	else

	jmp	SHORT $LN30@RangeToSte
$LN35@RangeToSte:

; 1770 : 		// Range and Number
; 1771 : 		//MI      JPG 1 Feb 04  - Why would you do this??  ugh
; 1772 : 		// if(!g_bRealisticAvionics)
; 1773 : 		//	sprintf (tmpStr, "%03.0f > %02d", waypointRange * FT_TO_NM, waypointNum + 1);
; 1774 : 		// else
; 1775 : 		sprintf (tmpStr, "%03.0f>%02d", waypointRange * FT_TO_NM, waypointNum + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4948]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4944]
	mulss	xmm0, DWORD PTR __real@392c987a
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@GJIKDFJJ@?$CF03?40f?$DO?$CF02d?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
$LN30@RangeToSte:

; 1776 : 
; 1777 : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 1778 : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN29@RangeToSte

; 1779 : 		DrawWindowString (14, tmpStr);

	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 1780 : 	else

	jmp	SHORT $LN28@RangeToSte
$LN29@RangeToSte:

; 1781 : 		display->TextLeft(0.45F, -0.50F, tmpStr);  //JPG .52F

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN28@RangeToSte:

; 1782 : 
; 1783 : 	//MI Slant range
; 1784 : 	float xPos = 0.45F;   //JPG .40F

	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1785 : 	float yPos = -0.39F;

	movss	xmm0, DWORD PTR __real@bec7ae14
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1786 : 	float range = SlantRange * FT_TO_NM;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5132]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _range$[ebp], xmm0

; 1787 : 
; 1788 : 	// RV - I-Hawk - Do not display target range if in HARM HAS mode
; 1789 : 	bool displayRange = true;

	mov	BYTE PTR _displayRange$[ebp], 1

; 1790 : 	if ( FCC->GetSubMode() == FireControlComputer::HARM )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 23					; 00000017H
	jne	SHORT $LN26@RangeToSte

; 1791 : 	{
; 1792 : 		HarmTargetingPod* harmPod = (HarmTargetingPod*)FindSensor(ownship, SensorClass::HTS);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _harmPod$7[ebp], eax

; 1793 : 		if ( harmPod && harmPod->GetSubMode() == HarmTargetingPod::HAS ||
; 1794 : 			 harmPod && harmPod->GetSubMode() == HarmTargetingPod::Handoff ||
; 1795 : 			 harmPod && harmPod->GetSubMode() == HarmTargetingPod::FilterMode )

	cmp	DWORD PTR _harmPod$7[ebp], 0
	je	SHORT $LN24@RangeToSte
	mov	ecx, DWORD PTR _harmPod$7[ebp]
	call	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
	cmp	eax, 1
	je	SHORT $LN25@RangeToSte
$LN24@RangeToSte:
	cmp	DWORD PTR _harmPod$7[ebp], 0
	je	SHORT $LN23@RangeToSte
	mov	ecx, DWORD PTR _harmPod$7[ebp]
	call	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
	cmp	eax, 2
	je	SHORT $LN25@RangeToSte
$LN23@RangeToSte:
	cmp	DWORD PTR _harmPod$7[ebp], 0
	je	SHORT $LN26@RangeToSte
	mov	ecx, DWORD PTR _harmPod$7[ebp]
	call	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
	cmp	eax, 4
	jne	SHORT $LN26@RangeToSte
$LN25@RangeToSte:

; 1796 : 		{
; 1797 : 			displayRange = false;

	mov	BYTE PTR _displayRange$[ebp], 0
$LN26@RangeToSte:

; 1798 : 		}
; 1799 : 	}
; 1800 : 
; 1801 : 	if (targetPtr) 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN22@RangeToSte

; 1802 : 		range = targetData->range * FT_TO_NM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _range$[ebp], xmm0
$LN22@RangeToSte:

; 1803 : 
; 1804 : 	if ( displayRange == true )

	movzx	edx, BYTE PTR _displayRange$[ebp]
	cmp	edx, 1
	jne	$LN7@RangeToSte

; 1805 : 	{
; 1806 : 		if(range >= 100)

	movss	xmm0, DWORD PTR _range$[ebp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jb	SHORT $LN20@RangeToSte

; 1807 : 		{
; 1808 : 			if(!targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN19@RangeToSte

; 1809 : 			{
; 1810 : 				sprintf(str, "B%3.1f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06FGAEIJIJ@B?$CF3?41f?$AA@
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1811 : 			}
; 1812 : 			else

	jmp	SHORT $LN18@RangeToSte
$LN19@RangeToSte:

; 1813 : 				sprintf(str, "F%3.1f", range);		

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06KCELKNJK@F?$CF3?41f?$AA@
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN18@RangeToSte:
	jmp	$LN7@RangeToSte
$LN20@RangeToSte:

; 1814 : 		}
; 1815 : 		else if(range < 100 && range >= 10)

	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _range$[ebp]
	jbe	SHORT $LN16@RangeToSte
	movss	xmm0, DWORD PTR _range$[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jb	SHORT $LN16@RangeToSte

; 1816 : 		{
; 1817 : 			if (!targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN15@RangeToSte

; 1818 : 			{
; 1819 : 				sprintf(str, "B0%2.1f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07IDGFKELM@B0?$CF2?41f?$AA@
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1820 : 			}
; 1821 : 			else

	jmp	SHORT $LN14@RangeToSte
$LN15@RangeToSte:

; 1822 : 				sprintf(str, "F0%2.1f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07HCPKKEG@F0?$CF2?41f?$AA@
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN14@RangeToSte:
	jmp	$LN7@RangeToSte
$LN16@RangeToSte:

; 1823 : 		}
; 1824 : 		else if(range < 10 && range >= 1)

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _range$[ebp]
	jbe	SHORT $LN12@RangeToSte
	movss	xmm0, DWORD PTR _range$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN12@RangeToSte

; 1825 : 		{
; 1826 : 			if(!targetPtr) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN11@RangeToSte

; 1827 : 			{
; 1828 : 				sprintf(str, "B00%1.1f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08FJPPKIMH@B00?$CF1?41f?$AA@
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1829 : 			}
; 1830 : 			else

	jmp	SHORT $LN10@RangeToSte
$LN11@RangeToSte:

; 1831 : 				sprintf(str, "F00%1.1f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08EBDPJML@F00?$CF1?41f?$AA@
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN10@RangeToSte:

; 1832 : 		}
; 1833 : 		else

	jmp	SHORT $LN7@RangeToSte
$LN12@RangeToSte:

; 1834 : 		{
; 1835 : 			range *= NM_TO_FT;

	movss	xmm0, DWORD PTR _range$[ebp]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	movss	DWORD PTR _range$[ebp], xmm0

; 1836 : 			range /= 100;

	movss	xmm0, DWORD PTR _range$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _range$[ebp], xmm0

; 1837 : 			if(!targetPtr) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN8@RangeToSte

; 1838 : 				sprintf(str, "B 0%2.0f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08GDCGIJAL@B?50?$CF2?40f?$AA@
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1839 : 			else

	jmp	SHORT $LN7@RangeToSte
$LN8@RangeToSte:

; 1840 : 				sprintf(str, "F 0%2.0f", range);

	cvtss2sd xmm0, DWORD PTR _range$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08DOMKNIAH@F?50?$CF2?40f?$AA@
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN7@RangeToSte:

; 1841 : 		}
; 1842 : 	}
; 1843 : 
; 1844 : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 1845 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN6@RangeToSte

; 1846 : 	{
; 1847 : 		if (targetPtr)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN5@RangeToSte

; 1848 : 		{
; 1849 : 			if (targetPtr->localData->range > 1.0F * NM_TO_FT)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR __real@45bde1b0
	jbe	$LN4@RangeToSte

; 1850 : 				sprintf (tmpStr, "F %4.1f", max ( min (100.0F, targetPtr->localData->range * FT_TO_NM), 0.0F));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR __real@392c987a
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN40@RangeToSte
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv309[ebp], xmm0
	jmp	SHORT $LN41@RangeToSte
$LN40@RangeToSte:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR tv309[ebp], xmm0
$LN41@RangeToSte:
	movss	xmm0, DWORD PTR tv309[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN44@RangeToSte
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR __real@392c987a
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN42@RangeToSte
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv322[ebp], xmm0
	jmp	SHORT $LN43@RangeToSte
$LN42@RangeToSte:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR tv322[ebp], xmm0
$LN43@RangeToSte:
	movss	xmm0, DWORD PTR tv322[ebp]
	movss	DWORD PTR tv323[ebp], xmm0
	jmp	SHORT $LN45@RangeToSte
$LN44@RangeToSte:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv323[ebp], xmm0
$LN45@RangeToSte:
	cvtss2sd xmm0, DWORD PTR tv323[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07OPLBMDCI@F?5?$CF4?41f?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1851 : 			else

	jmp	$LN3@RangeToSte
$LN4@RangeToSte:

; 1852 : 				sprintf (tmpStr, "F %03.0f", max ( min (10000.0F, targetPtr->localData->range * 0.01F), 0.0F));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR __real@461c4000
	jbe	SHORT $LN46@RangeToSte
	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR tv339[ebp], xmm0
	jmp	SHORT $LN47@RangeToSte
$LN46@RangeToSte:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv339[ebp], xmm0
$LN47@RangeToSte:
	movss	xmm0, DWORD PTR tv339[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN50@RangeToSte
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR __real@461c4000
	jbe	SHORT $LN48@RangeToSte
	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR tv352[ebp], xmm0
	jmp	SHORT $LN49@RangeToSte
$LN48@RangeToSte:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv352[ebp], xmm0
$LN49@RangeToSte:
	movss	xmm0, DWORD PTR tv352[ebp]
	movss	DWORD PTR tv353[ebp], xmm0
	jmp	SHORT $LN51@RangeToSte
$LN50@RangeToSte:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv353[ebp], xmm0
$LN51@RangeToSte:
	cvtss2sd xmm0, DWORD PTR tv353[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08GFFHNBPG@F?5?$CF03?40f?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN3@RangeToSte:

; 1853 : 			ShiAssert(strlen(tmpStr) < sizeof(tmpStr));
; 1854 : 			DrawWindowString (10, tmpStr);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN5@RangeToSte:

; 1855 : 		}
; 1856 : 	}

	jmp	SHORT $LN1@RangeToSte
$LN6@RangeToSte:

; 1857 : 	else if ( displayRange )

	movzx	edx, BYTE PTR _displayRange$[ebp]
	test	edx, edx
	je	SHORT $LN1@RangeToSte

; 1858 : 	{
; 1859 : 		display->TextLeft(xPos, yPos + 0.03F, str);

	push	0
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN1@RangeToSte:
$LN38@RangeToSte:

; 1860 : 
; 1861 : 	}
; 1862 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?RangeToSteerpoint@HudClass@@AAEXXZ ENDP		; HudClass::RangeToSteerpoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv89 = -84						; size = 4
tv94 = -80						; size = 4
tv182 = -76						; size = 4
_sec$ = -72						; size = 4
_minute$ = -68						; size = 4
_hr$ = -64						; size = 4
_this$ = -60						; size = 4
_ttg$ = -56						; size = 4
_tmpStr1$ = -52						; size = 24
_tmpStr$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?TimeToSteerpoint@HudClass@@AAEXXZ PROC			; HudClass::TimeToSteerpoint
; _this$ = ecx

; 1652 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1653 : 	//MI INS stuff
; 1654 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN20@TimeToStee
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN20@TimeToStee

; 1655 : 	{
; 1656 : 		if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN20@TimeToStee
	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN20@TimeToStee

; 1657 : 			return;

	jmp	$LN22@TimeToStee
$LN20@TimeToStee:

; 1658 : 	}
; 1659 : 	char tmpStr[24];
; 1660 : 	char tmpStr1[24];
; 1661 : 	int hr, minute, sec;
; 1662 : 	float ttg;
; 1663 : 
; 1664 : 	// Time to waypoint
; 1665 : 	if (waypointArrival > 0.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4936]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN19@TimeToStee

; 1666 : 	{
; 1667 : 		ttg = waypointArrival;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4936]
	movss	DWORD PTR _ttg$[ebp], xmm0

; 1668 : 		// burn any days in the number
; 1669 : 		hr = FloatToInt32(ttg / (3600.0F * 24.0F));

	movss	xmm0, DWORD PTR _ttg$[ebp]
	divss	xmm0, DWORD PTR __real@47a8c000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 1670 : 		ttg -= hr * 3600.0F * 24.0F;

	cvtsi2ss xmm0, DWORD PTR _hr$[ebp]
	mulss	xmm0, DWORD PTR __real@45610000
	mulss	xmm0, DWORD PTR __real@41c00000
	movss	xmm1, DWORD PTR _ttg$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _ttg$[ebp], xmm1

; 1671 : 		hr  = FloatToInt32(ttg / 3600.0F);

	movss	xmm0, DWORD PTR _ttg$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 1672 : 		hr  = max (hr, 0);

	cmp	DWORD PTR _hr$[ebp], 0
	jle	SHORT $LN24@TimeToStee
	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN25@TimeToStee
$LN24@TimeToStee:
	mov	DWORD PTR tv89[ebp], 0
$LN25@TimeToStee:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR _hr$[ebp], ecx

; 1673 : 		ttg -= hr * 3600.0F;

	cvtsi2ss xmm0, DWORD PTR _hr$[ebp]
	mulss	xmm0, DWORD PTR __real@45610000
	movss	xmm1, DWORD PTR _ttg$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _ttg$[ebp], xmm1

; 1674 : 		ttg = max (ttg, 0.0F);

	movss	xmm0, DWORD PTR _ttg$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN26@TimeToStee
	movss	xmm0, DWORD PTR _ttg$[ebp]
	movss	DWORD PTR tv94[ebp], xmm0
	jmp	SHORT $LN27@TimeToStee
$LN26@TimeToStee:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv94[ebp], xmm0
$LN27@TimeToStee:
	movss	xmm0, DWORD PTR tv94[ebp]
	movss	DWORD PTR _ttg$[ebp], xmm0

; 1675 : 		minute = FloatToInt32(ttg / 60.0F);

	movss	xmm0, DWORD PTR _ttg$[ebp]
	divss	xmm0, DWORD PTR __real@42700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _minute$[ebp], eax

; 1676 : 		ttg -= minute * 60.0F;

	cvtsi2ss xmm0, DWORD PTR _minute$[ebp]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	xmm1, DWORD PTR _ttg$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _ttg$[ebp], xmm1

; 1677 : 		sec = FloatToInt32(ttg);

	push	ecx
	movss	xmm0, DWORD PTR _ttg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _sec$[ebp], eax

; 1678 : 		if (hr != 0)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN18@TimeToStee

; 1679 : 			sprintf (tmpStr, "%03d:%02d", abs(minute), sec);  //JPG 5 Feb 04

	mov	edx, DWORD PTR _sec$[ebp]
	push	edx
	mov	eax, DWORD PTR _minute$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_09JFBOEAOE@?$CF03d?3?$CF02d?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	$LN11@TimeToStee
$LN18@TimeToStee:

; 1680 : 		else if (sec >= 0)

	cmp	DWORD PTR _sec$[ebp], 0
	jl	SHORT $LN16@TimeToStee

; 1681 : 		{
; 1682 : 			if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN15@TimeToStee

; 1683 : 				sprintf (tmpStr, "   %02d:%02d", abs(minute), sec);

	mov	eax, DWORD PTR _sec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minute$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0N@JIJJHBFE@?5?5?5?$CF02d?3?$CF02d?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1684 : 			else

	jmp	SHORT $LN14@TimeToStee
$LN15@TimeToStee:

; 1685 : 				sprintf (tmpStr, "%03d:%02d", abs(minute), sec);  //JPG "%02d:%02d"

	mov	eax, DWORD PTR _sec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minute$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_09JFBOEAOE@?$CF03d?3?$CF02d?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN14@TimeToStee:

; 1686 : 		}
; 1687 : 		else

	jmp	SHORT $LN11@TimeToStee
$LN16@TimeToStee:

; 1688 : 		{
; 1689 : 			if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN12@TimeToStee

; 1690 : 				sprintf (tmpStr, "  -%02d:%02d", abs(minute), abs(sec));

	mov	ecx, DWORD PTR _sec$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _minute$[ebp]
	push	edx
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0N@FDANDMFD@?5?5?9?$CF02d?3?$CF02d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1691 : 			else

	jmp	SHORT $LN11@TimeToStee
$LN12@TimeToStee:

; 1692 : 				sprintf (tmpStr, "-%02d:%02d", abs(minute), abs(sec));

	mov	ecx, DWORD PTR _sec$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _minute$[ebp]
	push	edx
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0L@JMLBFLDA@?9?$CF02d?3?$CF02d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN11@TimeToStee:

; 1693 : 		}
; 1694 : 	}
; 1695 : 	else

	jmp	SHORT $LN10@TimeToStee
$LN19@TimeToStee:

; 1696 : 	{
; 1697 : 		strcpy (tmpStr, "XX:XX");

	push	OFFSET ??_C@_05CJNIOAFN@XX?3XX?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN10@TimeToStee:

; 1698 : 	}
; 1699 : 
; 1700 : 	//MI
; 1701 : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN9@TimeToStee

; 1702 : 	{
; 1703 : 		switch (FCC->GetSubMode())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR tv182[ebp], 18		; 00000012H
	je	SHORT $LN6@TimeToStee
	cmp	DWORD PTR tv182[ebp], 20		; 00000014H
	je	SHORT $LN5@TimeToStee
	jmp	SHORT $LN4@TimeToStee
$LN6@TimeToStee:

; 1704 : 		{
; 1705 : 			case FireControlComputer::TimeToGo:         
; 1706 : 				sprintf (tmpStr1, ">%s<", tmpStr);

	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	OFFSET ??_C@_04JFGEPOPP@?$DO?$CFs?$DM?$AA@
	lea	edx, DWORD PTR _tmpStr1$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1707 : 				break;

	jmp	SHORT $LN7@TimeToStee
$LN5@TimeToStee:

; 1708 : 
; 1709 : 			case FireControlComputer::ETA:
; 1710 : 				sprintf (tmpStr1, "<%s>", tmpStr);

	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	OFFSET ??_C@_04NNJCMPBN@?$DM?$CFs?$DO?$AA@
	lea	ecx, DWORD PTR _tmpStr1$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1711 : 				break;

	jmp	SHORT $LN7@TimeToStee
$LN4@TimeToStee:

; 1712 : 
; 1713 : 			default:
; 1714 : 				strcpy (tmpStr1, tmpStr);

	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _tmpStr1$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN7@TimeToStee:

; 1715 : 				break;
; 1716 : 		}
; 1717 : 	}
; 1718 : 	else									// JPG

	jmp	SHORT $LN3@TimeToStee
$LN9@TimeToStee:

; 1719 : 	{
; 1720 : 
; 1721 : 		sprintf(tmpStr1, "%s", tmpStr);

	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	edx, DWORD PTR _tmpStr1$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN3@TimeToStee:

; 1722 : 	}
; 1723 : 	ShiAssert (strlen(tmpStr1) < sizeof(tmpStr1));
; 1724 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN2@TimeToStee

; 1725 : 		DrawWindowString (13, tmpStr1);

	push	0
	lea	ecx, DWORD PTR _tmpStr1$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 1726 : 	else

	jmp	SHORT $LN1@TimeToStee
$LN2@TimeToStee:

; 1727 : 		display->TextLeft(0.45F, -0.43F, tmpStr1 );  // JPG .40F & .44F

	push	0
	lea	edx, DWORD PTR _tmpStr1$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@bedc28f6
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+56]
	call	edx
$LN1@TimeToStee:
$LN22@TimeToStee:

; 1728 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?TimeToSteerpoint@HudClass@@AAEXXZ ENDP			; HudClass::TimeToSteerpoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_boresightOffset$1 = -80				; size = 4
tv926 = -76						; size = 4
_tickInc$ = -72						; size = 4
_vertConstraintTop$2 = -68				; size = 4
tv135 = -64						; size = 4
tv134 = -60						; size = 4
tv131 = -56						; size = 4
_playerAC$ = -52					; size = 4
_vertConstraintBottom$3 = -48				; size = 4
tv373 = -44						; size = 4
_horizConstraint$4 = -40				; size = 4
_dy$ = -36						; size = 4
_crossSize$5 = -32					; size = 4
_tickLen$ = -28						; size = 4
_headingTop$ = -24					; size = 4
_headingError$ = -20					; size = 4
_xPos$ = -16						; size = 4
_yPos$ = -12						; size = 4
_this$ = -8						; size = 4
_stptConstrained$6 = -1					; size = 1
?DrawWaypoint@HudClass@@AAEXXZ PROC			; HudClass::DrawWaypoint
; _this$ = ecx

; 1349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 1350 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1351 : 	//MI INS stuff
; 1352 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN57@DrawWaypoi
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN57@DrawWaypoi

; 1353 : 	{
; 1354 : 		if(ownship && !ownship->INSState(AircraftClass::INS_HUD_STUFF))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN57@DrawWaypoi
	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN57@DrawWaypoi

; 1355 : 			return;

	jmp	$LN59@DrawWaypoi
$LN57@DrawWaypoi:

; 1356 : 	}
; 1357 : 	float headingTop;
; 1358 : 	float tickInc, tickLen;
; 1359 : 	float headingError;
; 1360 : 	float xPos, yPos;
; 1361 : 
; 1362 : 	float dy;
; 1363 : 	static float HEADING_BOTTOM;
; 1364 : 
; 1365 : 	if(g_bFallingHeadingTape)

	movzx	ecx, BYTE PTR ?g_bFallingHeadingTape@@3_NA ; g_bFallingHeadingTape
	test	ecx, ecx
	je	SHORT $LN56@DrawWaypoi

; 1366 : 		HEADING_BOTTOM = -2.0F;

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR ?HEADING_BOTTOM@?6??DrawWaypoint@HudClass@@AAEXXZ@4MA, xmm0

; 1367 : 	else

	jmp	SHORT $LN55@DrawWaypoi
$LN56@DrawWaypoi:

; 1368 : 		HEADING_BOTTOM = -0.82F;

	movss	xmm0, DWORD PTR __real@bf51eb85
	movss	DWORD PTR ?HEADING_BOTTOM@?6??DrawWaypoint@HudClass@@AAEXXZ@4MA, xmm0
$LN55@DrawWaypoi:

; 1369 : 
; 1370 : 	if (!waypointValid || ownship == NULL || (FCC->GetMasterMode() == FireControlComputer::Dogfight))//me123 status test.)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4952]
	test	eax, eax
	je	SHORT $LN53@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN53@DrawWaypoi
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN54@DrawWaypoi
$LN53@DrawWaypoi:

; 1371 : 	{
; 1372 : 		return;

	jmp	$LN59@DrawWaypoi
$LN54@DrawWaypoi:

; 1373 : 	}
; 1374 : 
; 1375 : 	tickInc = hudWinWidth[HEADING_WINDOW_HI] / (NUM_HORIZONTAL_TICKS + 1);

	mov	eax, 4
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	divss	xmm0, DWORD PTR __real@41300000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 1376 : 	tickLen = hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _tickLen$[ebp], xmm0

; 1377 : 	headingError = waypointBearing * RTD;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4940]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _headingError$[ebp], xmm0

; 1378 : 	if (headingError > 180.0F)

	movss	xmm0, DWORD PTR _headingError$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN52@DrawWaypoi

; 1379 : 		headingError -= 360.0F;

	movss	xmm0, DWORD PTR _headingError$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _headingError$[ebp], xmm0
$LN52@DrawWaypoi:

; 1380 : 	headingError = max ( min (headingError, 25.0F), -25.0F);

	movss	xmm0, DWORD PTR __real@41c80000
	comiss	xmm0, DWORD PTR _headingError$[ebp]
	jbe	SHORT $LN61@DrawWaypoi
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN62@DrawWaypoi
$LN61@DrawWaypoi:
	movss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR tv131[ebp], xmm0
$LN62@DrawWaypoi:
	movss	xmm0, DWORD PTR tv131[ebp]
	comiss	xmm0, DWORD PTR __real@c1c80000
	jbe	SHORT $LN65@DrawWaypoi
	movss	xmm0, DWORD PTR __real@41c80000
	comiss	xmm0, DWORD PTR _headingError$[ebp]
	jbe	SHORT $LN63@DrawWaypoi
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN64@DrawWaypoi
$LN63@DrawWaypoi:
	movss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR tv134[ebp], xmm0
$LN64@DrawWaypoi:
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN66@DrawWaypoi
$LN65@DrawWaypoi:
	movss	xmm0, DWORD PTR __real@c1c80000
	movss	DWORD PTR tv135[ebp], xmm0
$LN66@DrawWaypoi:
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR _headingError$[ebp], xmm0

; 1381 : 	headingError /= 5.0F;

	movss	xmm0, DWORD PTR _headingError$[ebp]
	divss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _headingError$[ebp], xmm0

; 1382 : 	headingError *= tickInc;

	movss	xmm0, DWORD PTR _headingError$[ebp]
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _headingError$[ebp], xmm0

; 1383 : 
; 1384 : 	if (headingPos == Off)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4964], 2
	jne	SHORT $LN51@DrawWaypoi

; 1385 : 	{
; 1386 : 		return;

	jmp	$LN59@DrawWaypoi
	jmp	$LN34@DrawWaypoi
$LN51@DrawWaypoi:

; 1387 : 	}
; 1388 : 	else if (headingPos == High || ((AircraftClass*)ownship)->af->gearPos > 0.5F)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4964], 0
	je	SHORT $LN48@DrawWaypoi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN49@DrawWaypoi
$LN48@DrawWaypoi:

; 1389 : 	{
; 1390 : 		//MI
; 1391 : 		if(!g_bRealisticAvionics || ((AircraftClass*)ownship)->OnGround() ||
; 1392 : 				(g_bRealisticAvionics && g_bINS && ownship && ownship->INSState(AircraftClass::INS_PowerOff) ||
; 1393 : 				 !ownship->INSState(AircraftClass::INS_HUD_STUFF)))

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN45@DrawWaypoi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN45@DrawWaypoi
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN44@DrawWaypoi
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN44@DrawWaypoi
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN44@DrawWaypoi
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN45@DrawWaypoi
$LN44@DrawWaypoi:
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN47@DrawWaypoi
$LN45@DrawWaypoi:

; 1394 : 		{
; 1395 : 
; 1396 : 			headingTop = hudWinY[HEADING_WINDOW_HI] +
; 1397 : 				hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	edx, 4
	imul	edx, 40					; 00000028H
	mov	eax, 4
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _headingTop$[ebp], xmm0

; 1398 : 		}
; 1399 : 		else

	jmp	SHORT $LN43@DrawWaypoi
$LN47@DrawWaypoi:

; 1400 : 			headingTop = (hudWinY[HEADING_WINDOW_LO] - 0.2F) +	//use this to make it always follow FPM	
; 1401 : 				hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	ecx, 4
	imul	ecx, 41					; 00000029H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	subss	xmm0, DWORD PTR __real@3e4ccccd
	mov	edx, 4
	imul	edx, 40					; 00000028H
	movss	xmm1, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN43@DrawWaypoi:

; 1402 : 
; 1403 : 		// MI
; 1404 : 		if (g_bRealisticAvionics && GetDriftCOSwitch() == DRIFT_CO_OFF)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN39@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	test	eax, eax
	jne	$LN39@DrawWaypoi

; 1405 : 		{
; 1406 : 			if(((AircraftClass*)ownship)->af->gearPos > 0.5F && !((AircraftClass*)ownship->OnGround()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN41@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN41@DrawWaypoi

; 1407 : 			{
; 1408 : 				dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1409 : 					hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 1410 : 					alphaHudUnits + 0.4F;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+4856]
	addss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR _dy$[ebp], xmm0

; 1411 : 
; 1412 : 				if (dy > headingTop)

	movss	xmm0, DWORD PTR _dy$[ebp]
	comiss	xmm0, DWORD PTR _headingTop$[ebp]
	jbe	SHORT $LN40@DrawWaypoi

; 1413 : 					headingTop = dy;

	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN40@DrawWaypoi:

; 1414 : 			}
; 1415 : 			else

	jmp	SHORT $LN39@DrawWaypoi
$LN41@DrawWaypoi:

; 1416 : 			{
; 1417 : 				headingTop = hudWinY[HEADING_WINDOW_HI] +
; 1418 : 					hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	mov	edx, 4
	imul	edx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN39@DrawWaypoi:

; 1419 : 			}
; 1420 : 		}
; 1421 : 		if(GetDriftCOSwitch() != DRIFT_CO_OFF)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	test	eax, eax
	je	SHORT $LN38@DrawWaypoi

; 1422 : 		{
; 1423 : 			headingTop = hudWinY[HEADING_WINDOW_HI] +
; 1424 : 				hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	eax, 4
	imul	eax, 40					; 00000028H
	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN38@DrawWaypoi:

; 1425 : 		}
; 1426 : 	}
; 1427 : 	else

	jmp	$LN34@DrawWaypoi
$LN49@DrawWaypoi:

; 1428 : 	{
; 1429 : 		headingTop = hudWinY[HEADING_WINDOW_LO] +
; 1430 : 			hudWinHeight[HEADING_WINDOW_LO] * 0.5F;

	mov	edx, 4
	imul	edx, 41					; 00000029H
	mov	eax, 4
	imul	eax, 41					; 00000029H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _headingTop$[ebp], xmm0

; 1431 : 		// Marco edit - Scroll heading tape downwards with FPM
; 1432 : 		// if it's down the bottom
; 1433 : 		if (g_bRealisticAvionics && GetDriftCOSwitch() == DRIFT_CO_OFF)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN34@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	test	eax, eax
	jne	SHORT $LN34@DrawWaypoi

; 1434 : 		{
; 1435 : 			dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1436 : 				hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 1437 : 				alphaHudUnits - 0.12f;

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	mov	ecx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [ecx+4856]
	subss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR _dy$[ebp], xmm0

; 1438 : 
; 1439 : 			if(dy < HEADING_BOTTOM)	//don't fall off of the HUD. This can be seen in some of the vids

	movss	xmm0, DWORD PTR ?HEADING_BOTTOM@?6??DrawWaypoint@HudClass@@AAEXXZ@4MA
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN35@DrawWaypoi

; 1440 : 				dy = HEADING_BOTTOM;	//not sure if the position is right, but I think you should always see it

	movss	xmm0, DWORD PTR ?HEADING_BOTTOM@?6??DrawWaypoint@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR _dy$[ebp], xmm0
$LN35@DrawWaypoi:

; 1441 : 			//so let's keep it above the projector thingie
; 1442 : 
; 1443 : 			if (dy < headingTop)

	movss	xmm0, DWORD PTR _headingTop$[ebp]
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN34@DrawWaypoi

; 1444 : 				headingTop = dy;

	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN34@DrawWaypoi:

; 1445 : 		}
; 1446 : 	}
; 1447 : 	//MI
; 1448 : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	$LN33@DrawWaypoi

; 1449 : 	{
; 1450 : 		display->Line (headingError, headingTop + tickLen * 0.1F,
; 1451 : 				headingError + 0.1F * tickLen, headingTop + tickLen * 0.65F);

	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f266666
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _tickLen$[ebp]
	addss	xmm0, DWORD PTR _headingError$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1452 : 		display->Line (headingError, headingTop + tickLen * 0.1F,
; 1453 : 				headingError - 0.1F * tickLen, headingTop + tickLen * 0.65F);

	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f266666
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _tickLen$[ebp]
	movss	xmm1, DWORD PTR _headingError$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1454 : 		display->Line (headingError, headingTop + tickLen * 1.1F,
; 1455 : 				headingError + 0.1F * tickLen, headingTop + tickLen * 0.65F);

	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f266666
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _tickLen$[ebp]
	addss	xmm0, DWORD PTR _headingError$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1456 : 		display->Line (headingError, headingTop + tickLen * 1.1F,
; 1457 : 				headingError - 0.1F * tickLen, headingTop + tickLen * 0.65F);

	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f266666
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _tickLen$[ebp]
	movss	xmm1, DWORD PTR _headingError$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1458 : 	}
; 1459 : 	else

	jmp	$LN31@DrawWaypoi
$LN33@DrawWaypoi:

; 1460 : 	{
; 1461 : 		//in ILS, we get a "V" as our cue
; 1462 : 		if(FCC && FCC->GetMasterMode() == FireControlComputer::ILS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	$LN31@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 3
	jne	$LN31@DrawWaypoi

; 1463 : 		{
; 1464 : 			display->Line(headingError, headingTop + tickLen * 0.1F,
; 1465 : 					headingError + 0.3F * tickLen, headingTop + tickLen * 0.8F);

	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR _tickLen$[ebp]
	addss	xmm0, DWORD PTR _headingError$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1466 : 			display->Line(headingError, headingTop + tickLen * 0.1F,
; 1467 : 					headingError - 0.3F * tickLen, headingTop + tickLen * 0.8F);

	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR _tickLen$[ebp]
	movss	xmm1, DWORD PTR _headingError$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _tickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR _headingTop$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _headingError$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN31@DrawWaypoi:

; 1468 : 		}
; 1469 : 		else
; 1470 : 		{
; 1471 : 			//Here we get a inverted arrow  // JPG 17 Dec 03 NOT HERE IN REAL JET YOU DOPE!!
; 1472 : 			//   display->Line(headingError, headingTop + tickLen * 0.1F,
; 1473 : 			//	    headingError + 0.3F * tickLen, headingTop + tickLen * 0.8F);
; 1474 : 			//   display->Line(headingError + 0.25F * tickLen, headingTop + tickLen * 0.8F,
; 1475 : 			//	   headingError - 0.3F * tickLen, headingTop + tickLen * 0.8F);
; 1476 : 			//   display->Line(headingError, headingTop + tickLen * 0.1F,
; 1477 : 			//	    headingError - 0.3F * tickLen, headingTop + tickLen * 0.8F);
; 1478 : 		}
; 1479 : 	}
; 1480 : 
; 1481 : 	// Draw the waypoint on the ground
; 1482 : 	switch (FCC->GetMasterMode())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv373[ebp], eax
	mov	edx, DWORD PTR tv373[ebp]
	sub	edx, 4
	mov	DWORD PTR tv373[ebp], edx
	cmp	DWORD PTR tv373[ebp], 9
	ja	$LN1@DrawWaypoi
	mov	eax, DWORD PTR tv373[ebp]
	movzx	ecx, BYTE PTR $LN67@DrawWaypoi[eax]
	jmp	DWORD PTR $LN68@DrawWaypoi[ecx*4]
$LN27@DrawWaypoi:

; 1483 : 	{
; 1484 : 		case FireControlComputer::Nav:
; 1485 : 		case FireControlComputer::AirGroundBomb:
; 1486 : 		case FireControlComputer::AirGroundRocket: // MLR 4/3/2004 - 
; 1487 : 		case FireControlComputer::AirGroundLaser:
; 1488 : 		case FireControlComputer::AirGroundMissile:
; 1489 : 		case FireControlComputer::AirGroundHARM:
; 1490 : 		case FireControlComputer::AirGroundCamera:
; 1491 : 			//Normally we only consider drawing the waypoint if it's less than 90deg 
; 1492 : 			//in either direction off the nose. However, the HUD fix for constraining 
; 1493 : 			//the waypoint to the HUD's edge requires us to always draw it. Smeghead, 16-Oct-2003
; 1494 : 			if ((g_bHUDFix == true) || (fabs(waypointAz) < (90.0F * DTR)) )

	movzx	edx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	edx, 1
	je	SHORT $LN25@DrawWaypoi
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4920]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv926[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv926[ebp]
	jbe	$LN26@DrawWaypoi
$LN25@DrawWaypoi:

; 1495 : 			{
; 1496 : 				if((g_bHUDFix == true) && (g_bRealisticAvionics))

	movzx	ecx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	ecx, 1
	jne	$LN24@DrawWaypoi
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN24@DrawWaypoi

; 1497 : 				{
; 1498 : 					//If the waypoint is behind us, then really bad things tend to happen when the
; 1499 : 					//waypoint is drawn. Stuff like the waypoint crawling up the HUD when we pitch up
; 1500 : 					//(think about it) and so forth. Clamp the position of the drawn waypoint to 
; 1501 : 					//+/- 45 deg off the nose to keep things nice and smooth. Easier to do than 
; 1502 : 					//pissing around with a bunch of trig to figure out what to do.
; 1503 : 					if (waypointAz > (45.0F * DTR))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4920]
	comiss	xmm0, DWORD PTR __real@3f490fd9
	jbe	SHORT $LN23@DrawWaypoi

; 1504 : 					{
; 1505 : 						yPos = RadToHudUnitsY(45.0F * DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f490fd9
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]
	jmp	SHORT $LN20@DrawWaypoi
$LN23@DrawWaypoi:

; 1506 : 					}
; 1507 : 					else if (waypointAz < (-45.0F * DTR))

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf490fd9
	comiss	xmm0, DWORD PTR [ecx+4920]
	jbe	SHORT $LN21@DrawWaypoi

; 1508 : 					{
; 1509 : 						yPos = RadToHudUnitsY(-45.0F * DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf490fd9
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 1510 : 					}
; 1511 : 					else

	jmp	SHORT $LN20@DrawWaypoi
$LN21@DrawWaypoi:

; 1512 : 					{
; 1513 : 						yPos = RadToHudUnitsY(waypointEl);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4924]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]
$LN20@DrawWaypoi:

; 1514 : 					}
; 1515 : 				}
; 1516 : 				else

	jmp	SHORT $LN19@DrawWaypoi
$LN24@DrawWaypoi:

; 1517 : 				{
; 1518 : 					yPos = RadToHudUnitsY(waypointEl);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4924]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]
$LN19@DrawWaypoi:

; 1519 : 				}
; 1520 : 				xPos = RadToHudUnitsX(waypointAz);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4920]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 1521 : 
; 1522 : 				display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1523 : 							hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1524 : 				//MI draw our WP symbol centered on the WP, not edge-on
; 1525 : #if 0
; 1526 : 				display->Line (xPos, yPos + 0.04F, xPos + 0.04F, yPos);
; 1527 : 				display->Line (xPos, yPos - 0.04F, xPos + 0.04F, yPos);
; 1528 : 				display->Line (xPos, yPos + 0.04F, xPos - 0.04F, yPos);
; 1529 : 				display->Line (xPos, yPos - 0.04F, xPos - 0.04F, yPos);
; 1530 : #else
; 1531 : 				if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN18@DrawWaypoi

; 1532 : 				{
; 1533 : 					//No symbology if in AA MasterMode
; 1534 : 					if(FCC->IsAAMasterMode())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?IsAAMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAAMasterMode
	test	eax, eax
	je	SHORT $LN17@DrawWaypoi

; 1535 : 					{
; 1536 : 						display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1537 : 									hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1538 : 						return;

	jmp	$LN59@DrawWaypoi
$LN17@DrawWaypoi:

; 1539 : 					}
; 1540 : 
; 1541 : 					//HUD_Fixes.pdf #4 - restrain Steerpoint/target box within bounds of 
; 1542 : 					//HUD. Smeg, 16-Oct-2003.
; 1543 : 					if(g_bHUDFix == true)

	movzx	ecx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	ecx, 1
	jne	$LN5@DrawWaypoi

; 1544 : 					{
; 1545 : 						float boresightOffset = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1546 : 							hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F;

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _boresightOffset$1[ebp], xmm0

; 1547 : 						float horizConstraint = 1.00F - Lenght;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _Lenght
	movss	DWORD PTR _horizConstraint$4[ebp], xmm0

; 1548 : 						float vertConstraintBottom = -horizConstraint - boresightOffset;

	movss	xmm0, DWORD PTR _horizConstraint$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _boresightOffset$1[ebp]
	movss	DWORD PTR _vertConstraintBottom$3[ebp], xmm0

; 1549 : 						float vertConstraintTop = vertConstraintBottom + 1.85F; //HUD is 2 units tall, minus slight fudge.

	movss	xmm0, DWORD PTR _vertConstraintBottom$3[ebp]
	addss	xmm0, DWORD PTR __real@3feccccd
	movss	DWORD PTR _vertConstraintTop$2[ebp], xmm0

; 1550 : 						bool  stptConstrained = false;

	mov	BYTE PTR _stptConstrained$6[ebp], 0

; 1551 : 
; 1552 : 						//NOTE: If Stpt is almost directly behind us, then it's constrained to the HUD, 
; 1553 : 						//but it seems to be drawn the wrong way up - as you raise the nose, the stpt on 
; 1554 : 						//the hud rises, which makes bugger all sense. This really needs to be looked at...
; 1555 : 						if((xPos <= -horizConstraint) || (waypointAz < (-90.0F * DTR)) ) //Left edge

	movss	xmm0, DWORD PTR _horizConstraint$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _xPos$[ebp]
	jae	SHORT $LN14@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfc90fd9
	comiss	xmm0, DWORD PTR [ecx+4920]
	jbe	SHORT $LN15@DrawWaypoi
$LN14@DrawWaypoi:

; 1556 : 						{
; 1557 : 							xPos = -horizConstraint;

	movss	xmm0, DWORD PTR _horizConstraint$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1558 : 							stptConstrained = true;

	mov	BYTE PTR _stptConstrained$6[ebp], 1
	jmp	SHORT $LN12@DrawWaypoi
$LN15@DrawWaypoi:

; 1559 : 						}
; 1560 : 						else if ((xPos > horizConstraint) || (waypointAz > (90.0F * DTR))) //Right

	movss	xmm0, DWORD PTR _xPos$[ebp]
	comiss	xmm0, DWORD PTR _horizConstraint$4[ebp]
	ja	SHORT $LN11@DrawWaypoi
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4920]
	comiss	xmm0, DWORD PTR __real@3fc90fd9
	jbe	SHORT $LN12@DrawWaypoi
$LN11@DrawWaypoi:

; 1561 : 						{
; 1562 : 							xPos = horizConstraint;

	movss	xmm0, DWORD PTR _horizConstraint$4[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1563 : 							stptConstrained = true;

	mov	BYTE PTR _stptConstrained$6[ebp], 1
$LN12@DrawWaypoi:

; 1564 : 						}
; 1565 : 						if ((yPos <= vertConstraintBottom) || (waypointEl < (-90.0F * DTR))) //Bottom

	movss	xmm0, DWORD PTR _vertConstraintBottom$3[ebp]
	comiss	xmm0, DWORD PTR _yPos$[ebp]
	jae	SHORT $LN9@DrawWaypoi
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfc90fd9
	comiss	xmm0, DWORD PTR [eax+4924]
	jbe	SHORT $LN10@DrawWaypoi
$LN9@DrawWaypoi:

; 1566 : 						{
; 1567 : 							yPos = vertConstraintBottom;

	movss	xmm0, DWORD PTR _vertConstraintBottom$3[ebp]
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1568 : 							stptConstrained = true;

	mov	BYTE PTR _stptConstrained$6[ebp], 1
	jmp	SHORT $LN7@DrawWaypoi
$LN10@DrawWaypoi:

; 1569 : 						}
; 1570 : 						else if ((yPos > vertConstraintTop) || (waypointEl > (90.0F * DTR))) //Top

	movss	xmm0, DWORD PTR _yPos$[ebp]
	comiss	xmm0, DWORD PTR _vertConstraintTop$2[ebp]
	ja	SHORT $LN6@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4924]
	comiss	xmm0, DWORD PTR __real@3fc90fd9
	jbe	SHORT $LN7@DrawWaypoi
$LN6@DrawWaypoi:

; 1571 : 						{
; 1572 : 							yPos = vertConstraintTop;

	movss	xmm0, DWORD PTR _vertConstraintTop$2[ebp]
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1573 : 							stptConstrained = true;

	mov	BYTE PTR _stptConstrained$6[ebp], 1
$LN7@DrawWaypoi:

; 1574 : 						}
; 1575 : 
; 1576 : 						//If Stpt was constrained to HUD, then draw a cross on top of it 
; 1577 : 						//to warn that it's unreliable.
; 1578 : 						if(stptConstrained == true)

	movzx	edx, BYTE PTR _stptConstrained$6[ebp]
	cmp	edx, 1
	jne	$LN5@DrawWaypoi

; 1579 : 						{
; 1580 : 							float crossSize = Lenght; 

	movss	xmm0, DWORD PTR _Lenght
	movss	DWORD PTR _crossSize$5[ebp], xmm0

; 1581 : 							display->Line (-crossSize + xPos, -crossSize + yPos,
; 1582 : 									crossSize + xPos, crossSize + yPos);

	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1583 : 							display->Line (-crossSize + xPos, crossSize + yPos, 
; 1584 : 									crossSize + xPos, -crossSize + yPos);

	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	addss	xmm0, DWORD PTR _yPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _xPos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN5@DrawWaypoi:

; 1585 : 						}
; 1586 : 					} //End of HUD fix.
; 1587 : 
; 1588 : 					if(playerAC && playerAC->curWaypoint &&
; 1589 : 							playerAC->curWaypoint->GetWPFlags() & WPF_TARGET &&
; 1590 : 							FCC && FCC->IsAGMasterMode() &&
; 1591 : 							FCC->GetSubMode() != FireControlComputer::CCIP)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN4@DrawWaypoi
	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+728], 0
	je	$LN4@DrawWaypoi
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	$LN4@DrawWaypoi
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	$LN4@DrawWaypoi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	je	$LN4@DrawWaypoi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 7
	je	$LN4@DrawWaypoi

; 1592 : 					{
; 1593 : 						//This is our target, so the WP is a square, but not in CCIP, and only in AG 
; 1594 : 						//mode.
; 1595 : 						display->Line(xPos - Lenght, yPos - (Lenght), xPos - (Lenght), yPos + (Lenght));

	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1596 : 						display->Line(xPos - Lenght, yPos + (Lenght), xPos + (Lenght), yPos + (Lenght));

	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1597 : 						display->Line(xPos + Lenght, yPos + (Lenght), xPos + (Lenght), yPos - (Lenght));

	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1598 : 						display->Line(xPos + Lenght, yPos - (Lenght), xPos - (Lenght), yPos - (Lenght));

	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1599 : 						display->Point(xPos, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 1600 : 					}
; 1601 : 					else

	jmp	$LN3@DrawWaypoi
$LN4@DrawWaypoi:

; 1602 : 					{
; 1603 : 						display->Line(xPos - Lenght, yPos, xPos, yPos + Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1604 : 						display->Line(xPos, yPos + Lenght, xPos + Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1605 : 						display->Line(xPos + Lenght, yPos, xPos, yPos - Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1606 : 						display->Line(xPos, yPos - Lenght, xPos - Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawWaypoi:

; 1607 : 					}
; 1608 : 
; 1609 : 				}
; 1610 : 				else

	jmp	$LN2@DrawWaypoi
$LN18@DrawWaypoi:

; 1611 : 				{
; 1612 : 					display->Line(xPos - Lenght, yPos, xPos, yPos + Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1613 : 					display->Line(xPos, yPos + Lenght, xPos + Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1614 : 					display->Line(xPos + Lenght, yPos, xPos, yPos - Lenght);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	addss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1615 : 					display->Line(xPos, yPos - Lenght, xPos - Lenght, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR _Lenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN2@DrawWaypoi:

; 1616 : 				}
; 1617 : #endif
; 1618 : 				display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1619 : 							hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN26@DrawWaypoi:
$LN1@DrawWaypoi:
$LN59@DrawWaypoi:

; 1620 : 			}
; 1621 : 			break;
; 1622 : 
; 1623 : 		default:
; 1624 : 			break;
; 1625 : 	}
; 1626 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN68@DrawWaypoi:
	DD	$LN27@DrawWaypoi
	DD	$LN1@DrawWaypoi
$LN67@DrawWaypoi:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
?DrawWaypoint@HudClass@@AAEXXZ ENDP			; HudClass::DrawWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawNav@HudClass@@AAEXXZ PROC				; HudClass::DrawNav
; _this$ = ecx

; 1629 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1630 : 	//char tmpStr[24];
; 1631 : 
; 1632 : 	DrawTDBox();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTDBox@HudClass@@AAEXXZ		; HudClass::DrawTDBox

; 1633 : 
; 1634 : 	/*  now drawn in rangetostearpoint me123 if (targetPtr)
; 1635 : 	    {
; 1636 : 	    if (targetPtr->localData->range > 1.0F * NM_TO_FT)
; 1637 : 	    sprintf (tmpStr, "F %4.1f", max ( min (100.0F, targetPtr->localData->range * FT_TO_NM), 0.0F));
; 1638 : 	    else
; 1639 : 	    sprintf (tmpStr, "F %03.0f", max ( min (10000.0F, targetPtr->localData->range * 0.01F), 0.0F));
; 1640 : 	    ShiAssert(strlen(tmpStr) < sizeof(tmpStr));
; 1641 : 	    DrawWindowString (10, tmpStr);
; 1642 : 	    }*/
; 1643 : 
; 1644 : 	if (waypointValid)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4952]
	test	ecx, ecx
	je	SHORT $LN2@DrawNav

; 1645 : 	{
; 1646 : 		TimeToSteerpoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TimeToSteerpoint@HudClass@@AAEXXZ	; HudClass::TimeToSteerpoint

; 1647 : 		RangeToSteerpoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RangeToSteerpoint@HudClass@@AAEXXZ	; HudClass::RangeToSteerpoint
$LN2@DrawNav:

; 1648 : 	}
; 1649 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawNav@HudClass@@AAEXXZ ENDP				; HudClass::DrawNav
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_xOffset$ = -52						; size = 4
_yOffset$ = -48						; size = 4
_vValid$ = -44						; size = 4
_hValid$ = -40						; size = 4
tv128 = -36						; size = 4
tv95 = -32						; size = 4
tv92 = -28						; size = 4
tv89 = -24						; size = 4
tv88 = -20						; size = 4
tv85 = -16						; size = 4
_vDev$ = -12						; size = 4
_hDev$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawILS@HudClass@@AAEXXZ PROC				; HudClass::DrawILS
; _this$ = ecx

; 1249 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1250 : 	float hDev = 0.0F;   // glide path deviation.  Positive is glide path on right side

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _hDev$[ebp], xmm0

; 1251 : 	float vDev = 0.0F;   // glide slope deviation.  Positive is glide slope above.

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vDev$[ebp], xmm0

; 1252 : 	int hValid, vValid;
; 1253 : 	float xOffset, yOffset;
; 1254 : 
; 1255 : 	//ATARIBABY ILS needles HUD fix
; 1256 : 	// ILS needles on hud not get properly updated because it query pCockpitManager->mHiddenFlag 
; 1257 : 	// and this seems not get updated in 3d pit view
; 1258 : 	// if (gNavigationSys && !OTWDriver.pCockpitManager->mHiddenFlag)
; 1259 : 	if (gNavigationSys && (gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_TACAN ||
; 1260 : 				gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_NAV) &&
; 1261 : 			gNavigationSys->GetILSAttribute(NavigationSystem::GP_DEV, &hDev))

	cmp	DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A, 0 ; gNavigationSys
	je	$LN11@DrawILS
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 2
	je	SHORT $LN10@DrawILS
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 1
	jne	SHORT $LN11@DrawILS
$LN10@DrawILS:
	lea	eax, DWORD PTR _hDev$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z ; NavigationSystem::GetILSAttribute
	test	eax, eax
	je	SHORT $LN11@DrawILS

; 1262 : 	{
; 1263 : 		gNavigationSys->GetILSAttribute(NavigationSystem::GP_DEV, &hDev);

	lea	ecx, DWORD PTR _hDev$[ebp]
	push	ecx
	push	4
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z ; NavigationSystem::GetILSAttribute

; 1264 : 		gNavigationSys->GetILSAttribute(NavigationSystem::GS_DEV, &vDev);

	lea	edx, DWORD PTR _vDev$[ebp]
	push	edx
	push	5
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z ; NavigationSystem::GetILSAttribute

; 1265 : 		hDev *= RTD;

	movss	xmm0, DWORD PTR _hDev$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _hDev$[ebp], xmm0

; 1266 : 		vDev *= RTD;

	movss	xmm0, DWORD PTR _vDev$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _vDev$[ebp], xmm0

; 1267 : 		hValid = TRUE;

	mov	DWORD PTR _hValid$[ebp], 1

; 1268 : 		vValid = TRUE;

	mov	DWORD PTR _vValid$[ebp], 1

; 1269 : 	}
; 1270 : 	else

	jmp	SHORT $LN9@DrawILS
$LN11@DrawILS:

; 1271 : 	{
; 1272 : 		hValid = FALSE;

	mov	DWORD PTR _hValid$[ebp], 0

; 1273 : 		vValid = FALSE;

	mov	DWORD PTR _vValid$[ebp], 0
$LN9@DrawILS:

; 1274 : 	}
; 1275 : 
; 1276 : 	hDev = min ( max (hDev, -3.75F), 3.75F) / 3.75F;

	movss	xmm0, DWORD PTR _hDev$[ebp]
	comiss	xmm0, DWORD PTR __real@c0700000
	jbe	SHORT $LN14@DrawILS
	movss	xmm0, DWORD PTR _hDev$[ebp]
	movss	DWORD PTR tv85[ebp], xmm0
	jmp	SHORT $LN15@DrawILS
$LN14@DrawILS:
	movss	xmm0, DWORD PTR __real@c0700000
	movss	DWORD PTR tv85[ebp], xmm0
$LN15@DrawILS:
	movss	xmm0, DWORD PTR __real@40700000
	comiss	xmm0, DWORD PTR tv85[ebp]
	jbe	SHORT $LN18@DrawILS
	movss	xmm0, DWORD PTR _hDev$[ebp]
	comiss	xmm0, DWORD PTR __real@c0700000
	jbe	SHORT $LN16@DrawILS
	movss	xmm0, DWORD PTR _hDev$[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN17@DrawILS
$LN16@DrawILS:
	movss	xmm0, DWORD PTR __real@c0700000
	movss	DWORD PTR tv88[ebp], xmm0
$LN17@DrawILS:
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN19@DrawILS
$LN18@DrawILS:
	movss	xmm0, DWORD PTR __real@40700000
	movss	DWORD PTR tv89[ebp], xmm0
$LN19@DrawILS:
	movss	xmm0, DWORD PTR tv89[ebp]
	divss	xmm0, DWORD PTR __real@40700000
	movss	DWORD PTR _hDev$[ebp], xmm0

; 1277 : 	vDev = min ( max (vDev, -0.75F), 0.75F) / 0.75F;

	movss	xmm0, DWORD PTR _vDev$[ebp]
	comiss	xmm0, DWORD PTR __real@bf400000
	jbe	SHORT $LN20@DrawILS
	movss	xmm0, DWORD PTR _vDev$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN21@DrawILS
$LN20@DrawILS:
	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR tv92[ebp], xmm0
$LN21@DrawILS:
	movss	xmm0, DWORD PTR __real@3f400000
	comiss	xmm0, DWORD PTR tv92[ebp]
	jbe	SHORT $LN24@DrawILS
	movss	xmm0, DWORD PTR _vDev$[ebp]
	comiss	xmm0, DWORD PTR __real@bf400000
	jbe	SHORT $LN22@DrawILS
	movss	xmm0, DWORD PTR _vDev$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN23@DrawILS
$LN22@DrawILS:
	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR tv95[ebp], xmm0
$LN23@DrawILS:
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN25@DrawILS
$LN24@DrawILS:
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv128[ebp], xmm0
$LN25@DrawILS:
	movss	xmm0, DWORD PTR tv128[ebp]
	divss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _vDev$[ebp], xmm0

; 1278 : 
; 1279 : 	// Draw symbology centered about FPM
; 1280 : 	xOffset = betaHudUnits;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4860]
	movss	DWORD PTR _xOffset$[ebp], xmm0

; 1281 : 	yOffset = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1282 : 		hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 1283 : 		alphaHudUnits;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+4856]
	movss	DWORD PTR _yOffset$[ebp], xmm0

; 1284 : 	display->AdjustOriginInViewport( xOffset,  yOffset);

	push	ecx
	movss	xmm0, DWORD PTR _yOffset$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xOffset$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1285 : 
; 1286 : 	// Horizontal Dev
; 1287 : 	if(hValid)

	cmp	DWORD PTR _hValid$[ebp], 0
	je	SHORT $LN8@DrawILS

; 1288 : 	{
; 1289 : 		display->Line (0.18F * hDev, 0.18F, 0.18F * hDev, -0.18F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1290 : 	}
; 1291 : 	else

	jmp	$LN7@DrawILS
$LN8@DrawILS:

; 1292 : 	{
; 1293 : 		display->Line (0.18F * hDev, 0.15F, 0.18F * hDev,  0.09F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1294 : 		display->Line (0.18F * hDev,-0.15F, 0.18F * hDev, -0.09F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN7@DrawILS:

; 1295 : 	}
; 1296 : 	//MI
; 1297 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN6@DrawILS

; 1298 : 	{
; 1299 : 		display->Line (0.18F * hDev - 0.03F, 0.18F, 0.18F * hDev + 0.03F, 0.18F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1300 : 		display->Line (0.18F * hDev - 0.03F, 0.12F, 0.18F * hDev + 0.03F, 0.12F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1301 : 		display->Line (0.18F * hDev - 0.03F, 0.06F, 0.18F * hDev + 0.03F, 0.06F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d75c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d75c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1302 : 		display->Line (0.18F * hDev - 0.03F, 0.00F, 0.18F * hDev + 0.03F, 0.00F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1303 : 		display->Line (0.18F * hDev - 0.03F,-0.18F, 0.18F * hDev + 0.03F,-0.18F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1304 : 		display->Line (0.18F * hDev - 0.03F,-0.12F, 0.18F * hDev + 0.03F,-0.12F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1305 : 		display->Line (0.18F * hDev - 0.03F,-0.06F, 0.18F * hDev + 0.03F,-0.06F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bd75c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd75c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1306 : 	}
; 1307 : 	else

	jmp	$LN5@DrawILS
$LN6@DrawILS:

; 1308 : 	{
; 1309 : 		//lines are 2 left and right, not like above
; 1310 : 		display->Line (0.18F * hDev - 0.018F, 0.18F, 0.18F * hDev + 0.018F, 0.18F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1311 : 		display->Line (0.18F * hDev - 0.018F, 0.09F, 0.18F * hDev + 0.018F, 0.09F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1312 : 		display->Line (0.18F * hDev - 0.018F,-0.18F, 0.18F * hDev + 0.018F,-0.18F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1313 : 		display->Line (0.18F * hDev - 0.018F,-0.09F, 0.18F * hDev + 0.018F,-0.09F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _hDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN5@DrawILS:

; 1314 : 	}
; 1315 : 
; 1316 : 	// Vertical Dev
; 1317 : 	if(vValid)

	cmp	DWORD PTR _vValid$[ebp], 0
	je	SHORT $LN4@DrawILS

; 1318 : 	{
; 1319 : 		display->Line (0.18F, 0.18F * vDev, -0.18F, 0.18F * vDev);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1320 : 	}
; 1321 : 	else

	jmp	$LN3@DrawILS
$LN4@DrawILS:

; 1322 : 	{
; 1323 : 		display->Line ( 0.15F, 0.18F * vDev,  0.09F, 0.18F * vDev);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1324 : 		display->Line (-0.15F, 0.18F * vDev, -0.09F, 0.18F * vDev);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawILS:

; 1325 : 	}
; 1326 : 	//MI
; 1327 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN2@DrawILS

; 1328 : 	{
; 1329 : 		display->Line ( 0.18F, 0.18F * vDev - 0.03F, 0.18F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1330 : 		display->Line ( 0.12F, 0.18F * vDev - 0.03F, 0.12F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1331 : 		display->Line ( 0.06F, 0.18F * vDev - 0.03F, 0.06F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d75c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d75c28f
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1332 : 		display->Line ( 0.00F, 0.18F * vDev - 0.03F, 0.00F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1333 : 		display->Line (-0.18F, 0.18F * vDev - 0.03F,-0.18F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1334 : 		display->Line (-0.12F, 0.18F * vDev - 0.03F,-0.12F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1335 : 		display->Line (-0.06F, 0.18F * vDev - 0.03F,-0.06F, 0.18F * vDev + 0.03F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd75c28f
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd75c28f
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1336 : 	}
; 1337 : 	else

	jmp	$LN1@DrawILS
$LN2@DrawILS:

; 1338 : 	{
; 1339 : 		//lines are 2 left and right, not like above
; 1340 : 		display->Line ( 0.18F, 0.18F * vDev - 0.018F, 0.18F, 0.18F * vDev + 0.018F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e3851ec
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1341 : 		display->Line ( 0.09F, 0.18F * vDev - 0.018F, 0.09F, 0.18F * vDev + 0.018F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1342 : 		display->Line (-0.18F, 0.18F * vDev - 0.018F,-0.18F, 0.18F * vDev + 0.018F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be3851ec
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1343 : 		display->Line (-0.09F, 0.18F * vDev - 0.018F,-0.09F, 0.18F * vDev + 0.018F);

	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	addss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e3851ec
	mulss	xmm0, DWORD PTR _vDev$[ebp]
	subss	xmm0, DWORD PTR __real@3c9374bc
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN1@DrawILS:

; 1344 : 	}
; 1345 : 	display->AdjustOriginInViewport(-xOffset, -yOffset);

	movss	xmm0, DWORD PTR _yOffset$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xOffset$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1346 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawILS@HudClass@@AAEXXZ ENDP				; HudClass::DrawILS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_playerAC$ = -88					; size = 4
tv1095 = -84						; size = 4
tv1197 = -80						; size = 4
_textWidth$ = -76					; size = 4
_bigTickLen$ = -72					; size = 4
_smallTickLen$ = -68					; size = 4
_val$ = -64						; size = 4
_tmpVal$1 = -60						; size = 4
_dy$ = -56						; size = 4
_i$ = -52						; size = 4
_tickInc$ = -48						; size = 4
_headingTop$ = -44					; size = 4
_a$ = -40						; size = 4
_this$ = -36						; size = 4
_vert$ = -32						; size = 16
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?DrawHeading@HudClass@@AAEXXZ PROC			; HudClass::DrawHeading
; _this$ = ecx

; 835  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 836  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 837  : 	char tmpStr[12]={0};

	mov	BYTE PTR _tmpStr$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _tmpStr$[ebp+1], eax
	mov	DWORD PTR _tmpStr$[ebp+5], eax
	mov	WORD PTR _tmpStr$[ebp+9], ax
	mov	BYTE PTR _tmpStr$[ebp+11], al

; 838  : 	float vert[2][2]={0.0F};

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vert$[ebp], xmm0
	xor	ecx, ecx
	mov	DWORD PTR _vert$[ebp+4], ecx
	mov	DWORD PTR _vert$[ebp+8], ecx
	mov	DWORD PTR _vert$[ebp+12], ecx

; 839  : 	int i=0, a=0, val=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _a$[ebp], 0
	mov	DWORD PTR _val$[ebp], 0

; 840  : 	float headingTop=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _headingTop$[ebp], xmm0

; 841  : 	float bigTickLen=0.0F, smallTickLen=0.0F, tickInc=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 842  : 	float textWidth=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _textWidth$[ebp], xmm0

; 843  : 
; 844  : 	float dy;
; 845  : 	static float HEADING_BOTTOM;
; 846  : 
; 847  : 	if(g_bFallingHeadingTape)

	movzx	edx, BYTE PTR ?g_bFallingHeadingTape@@3_NA ; g_bFallingHeadingTape
	test	edx, edx
	je	SHORT $LN95@DrawHeadin

; 848  : 		HEADING_BOTTOM = -2.0F;

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR ?HEADING_BOTTOM@?1??DrawHeading@HudClass@@AAEXXZ@4MA, xmm0

; 849  : 	else

	jmp	SHORT $LN94@DrawHeadin
$LN95@DrawHeadin:

; 850  : 		HEADING_BOTTOM = -0.82F;

	movss	xmm0, DWORD PTR __real@bf51eb85
	movss	DWORD PTR ?HEADING_BOTTOM@?1??DrawHeading@HudClass@@AAEXXZ@4MA, xmm0
$LN94@DrawHeadin:

; 851  : 
; 852  : 	if (headingPos == Off || (FCC->GetMasterMode() ==FireControlComputer::Dogfight))//me123 status test.)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4964], 2
	je	SHORT $LN92@DrawHeadin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN93@DrawHeadin
$LN92@DrawHeadin:

; 853  : 	{
; 854  : 		return;

	jmp	$LN96@DrawHeadin
	jmp	$LN73@DrawHeadin
$LN93@DrawHeadin:

; 855  : 	}
; 856  : 	else if (headingPos == High || ((AircraftClass*)ownship)->af->gearPos > 0.5F)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4964], 0
	je	SHORT $LN89@DrawHeadin
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN90@DrawHeadin
$LN89@DrawHeadin:

; 857  : 	{
; 858  : 		//MI
; 859  : 		if(!g_bRealisticAvionics || ((AircraftClass*)ownship)->OnGround() ||
; 860  : 				(g_bRealisticAvionics && g_bINS && ownship && ownship->INSState(AircraftClass::INS_PowerOff) ||
; 861  : 				 !ownship->INSState(AircraftClass::INS_HUD_STUFF)))

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN86@DrawHeadin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN86@DrawHeadin
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN85@DrawHeadin
	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	SHORT $LN85@DrawHeadin
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN85@DrawHeadin
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN86@DrawHeadin
$LN85@DrawHeadin:
	push	1024					; 00000400H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN88@DrawHeadin
$LN86@DrawHeadin:

; 862  : 		{
; 863  : 
; 864  : 			headingTop = hudWinY[HEADING_WINDOW_HI] +
; 865  : 				hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	eax, 4
	imul	eax, 40					; 00000028H
	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR _headingTop$[ebp], xmm0

; 866  : 		}
; 867  : 		else

	jmp	SHORT $LN84@DrawHeadin
$LN88@DrawHeadin:

; 868  : 			headingTop = (hudWinY[HEADING_WINDOW_LO] - 0.2F) +	//use this to make it always follow FPM	
; 869  : 				hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	edx, 4
	imul	edx, 41					; 00000029H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	subss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, 4
	imul	eax, 40					; 00000028H
	movss	xmm1, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN84@DrawHeadin:

; 870  : 
; 871  : 		// MI
; 872  : 		if (g_bRealisticAvionics && GetDriftCOSwitch() == DRIFT_CO_OFF)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN80@DrawHeadin
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	test	eax, eax
	jne	$LN80@DrawHeadin

; 873  : 		{
; 874  : 			if(((AircraftClass*)ownship)->af->gearPos > 0.5F && !((AircraftClass*)ownship->OnGround()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN82@DrawHeadin
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN82@DrawHeadin

; 875  : 			{
; 876  : 				dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 877  : 					hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 878  : 					alphaHudUnits + 0.4F;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+4856]
	addss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR _dy$[ebp], xmm0

; 879  : 
; 880  : 				if (dy > headingTop)

	movss	xmm0, DWORD PTR _dy$[ebp]
	comiss	xmm0, DWORD PTR _headingTop$[ebp]
	jbe	SHORT $LN81@DrawHeadin

; 881  : 					headingTop = dy;

	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN81@DrawHeadin:

; 882  : 			}
; 883  : 			else

	jmp	SHORT $LN80@DrawHeadin
$LN82@DrawHeadin:

; 884  : 			{
; 885  : 				headingTop = hudWinY[HEADING_WINDOW_HI] +
; 886  : 					hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	mov	edx, 4
	imul	edx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN80@DrawHeadin:

; 887  : 			}
; 888  : 		}
; 889  : 		if(GetDriftCOSwitch() != DRIFT_CO_OFF)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	test	eax, eax
	je	SHORT $LN79@DrawHeadin

; 890  : 		{
; 891  : 			headingTop = hudWinY[HEADING_WINDOW_HI] +
; 892  : 				hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	eax, 4
	imul	eax, 40					; 00000028H
	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN79@DrawHeadin:

; 893  : 		}
; 894  : 	}

	jmp	$LN73@DrawHeadin
$LN90@DrawHeadin:

; 895  : 	else if (headingPos == Low)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4964], 1
	jne	$LN73@DrawHeadin

; 896  : 	{
; 897  : 		headingTop = hudWinY[HEADING_WINDOW_LO] +
; 898  : 			hudWinHeight[HEADING_WINDOW_LO] * 0.5F;

	mov	eax, 4
	imul	eax, 41					; 00000029H
	mov	ecx, 4
	imul	ecx, 41					; 00000029H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR _headingTop$[ebp], xmm0

; 899  : 		// Marco edit - Scroll heading tape downwards with FPM
; 900  : 		// if it's down the bottom
; 901  : 		if(g_bRealisticAvionics && GetDriftCOSwitch() == DRIFT_CO_OFF)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN74@DrawHeadin
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	test	eax, eax
	jne	SHORT $LN74@DrawHeadin

; 902  : 		{
; 903  : 			dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 904  : 				hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 905  : 				alphaHudUnits - 0.12f;

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+4856]
	subss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR _dy$[ebp], xmm0

; 906  : 
; 907  : 			if(dy < HEADING_BOTTOM)	//don't fall off of the HUD. This can be seen in some of the vids

	movss	xmm0, DWORD PTR ?HEADING_BOTTOM@?1??DrawHeading@HudClass@@AAEXXZ@4MA
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN75@DrawHeadin

; 908  : 				dy = HEADING_BOTTOM;	//not sure if the position is right, but I think you should always see it

	movss	xmm0, DWORD PTR ?HEADING_BOTTOM@?1??DrawHeading@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR _dy$[ebp], xmm0
$LN75@DrawHeadin:

; 909  : 			//so let's keep it above the projector thingie
; 910  : 			if (dy < headingTop)	

	movss	xmm0, DWORD PTR _headingTop$[ebp]
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN74@DrawHeadin

; 911  : 				headingTop = dy;

	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN74@DrawHeadin:

; 912  : 
; 913  : 		}
; 914  : 		//MI INS stuff
; 915  : 		if(g_bRealisticAvionics && g_bINS && ownship && ownship->INSState(AircraftClass::INS_PowerOff) ||
; 916  : 				!ownship->INSState(AircraftClass::INS_HUD_STUFF))

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN71@DrawHeadin
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN71@DrawHeadin
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN71@DrawHeadin
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN72@DrawHeadin
$LN71@DrawHeadin:
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN73@DrawHeadin
$LN72@DrawHeadin:

; 917  : 		{
; 918  : 			headingTop = hudWinY[HEADING_WINDOW_LO] +
; 919  : 				hudWinHeight[HEADING_WINDOW_LO] * 0.5F;

	mov	edx, 4
	imul	edx, 41					; 00000029H
	mov	eax, 4
	imul	eax, 41					; 00000029H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _headingTop$[ebp], xmm0
$LN73@DrawHeadin:

; 920  : 		}
; 921  : 	}
; 922  : 	tickInc = hudWinWidth[HEADING_WINDOW_HI] / (NUM_HORIZONTAL_TICKS + 1);

	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	divss	xmm0, DWORD PTR __real@41300000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 923  : 
; 924  : 	/*   // Marco edit - Scroll heading tape downwards with FPM
; 925  : 	     if (g_bRealisticAvionics && dy < headingTop && ((AircraftClass*)ownship)->af->gearPos <= 0.5F)
; 926  : 	     {
; 927  : 	     headingTop = dy ;
; 928  : 	     }*/
; 929  : 
; 930  : 	//MI make the spaces wider
; 931  : 	if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN70@DrawHeadin

; 932  : 		tickInc *= 2.0F;

	movss	xmm0, DWORD PTR _tickInc$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _tickInc$[ebp], xmm0
$LN70@DrawHeadin:

; 933  : 	bigTickLen = hudWinHeight[HEADING_WINDOW_HI] * 0.5F;

	mov	eax, 4
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 934  : 	smallTickLen = hudWinHeight[HEADING_WINDOW_HI] * 0.25F;

	mov	ecx, 4
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 935  : 
; 936  : 	display->Line (0.0F, headingTop + smallTickLen,
; 937  : 			0.0F, headingTop + bigTickLen + smallTickLen);

	movss	xmm0, DWORD PTR _headingTop$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _headingTop$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 938  : 	a = FloatToInt32(cockpitFlightData.yaw * 10.0F * RTD);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 939  : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN69@DrawHeadin

; 940  : 		vert[0][0] = -(a%50) * tickInc * 0.02F - 4 * tickInc;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	neg	edx
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR __real@40800000
	mulss	xmm1, DWORD PTR _tickInc$[ebp]
	subss	xmm0, xmm1
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 941  : 	else

	jmp	SHORT $LN68@DrawHeadin
$LN69@DrawHeadin:

; 942  : 		vert[0][0] = -(a%50) * tickInc * 0.02F - 2 * tickInc;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	neg	edx
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _tickInc$[ebp]
	subss	xmm0, xmm1
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
$LN68@DrawHeadin:

; 943  : 	vert[0][1] = headingTop;

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _headingTop$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 944  : 
; 945  : 	// OW: Sylvains Three-Digit heading patch
; 946  : #if 1
; 947  : 	// ADDED BY S.G. SO 3 DIGIT ARE DISPLAYED FOR THE HEADING WHEN IN 'SS_OFF' MODE
; 948  : 	if (scalesSwitch == SS_OFF || scalesSwitch == VAH) {	//MI changed VV_VAH to VAH

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 3
	je	SHORT $LN66@DrawHeadin
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4864], 1
	jne	SHORT $LN67@DrawHeadin
$LN66@DrawHeadin:

; 949  : 		// a is multiplied by ten above, we don't need that here
; 950  : 		//MI 16/2/02 give us a 180 heading
; 951  : 		//MI better heading code
; 952  : #if 0
; 953  : 		int tmpVal = 0;
; 954  : 		if(a > 1795 || a < -1795)
; 955  : 			tmpVal = 180;
; 956  : 		else
; 957  : 			tmpVal = (int)(a / 10);
; 958  : 		//int tmpVal = (((int)a + 5) / 10) * 10;
; 959  : 		// Heading 'tape' is NOT negative, convert to positive
; 960  : 		if (tmpVal < 0)
; 961  : 			tmpVal += 360;
; 962  : 
; 963  : 		// Needed for the 'tick marks'
; 964  : 		a = a/50;
; 965  : 
; 966  : 		sprintf (tmpStr, "%03d", tmpVal);
; 967  : #else
; 968  : 		int tmpVal = a;

	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _tmpVal$1[ebp], ecx

; 969  : 		if (tmpVal >= 0)

	cmp	DWORD PTR _tmpVal$1[ebp], 0
	jl	SHORT $LN65@DrawHeadin

; 970  : 			tmpVal = (int)((a+5) / 10);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _tmpVal$1[ebp], eax

; 971  : 		else

	jmp	SHORT $LN64@DrawHeadin
$LN65@DrawHeadin:

; 972  : 			tmpVal = (int)((a-5) / 10);

	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _tmpVal$1[ebp], eax
$LN64@DrawHeadin:

; 973  : 		// Heading 'tape' is NOT negative, convert to positive
; 974  : 		if (tmpVal < 0)

	cmp	DWORD PTR _tmpVal$1[ebp], 0
	jge	SHORT $LN63@DrawHeadin

; 975  : 			tmpVal += 360;

	mov	edx, DWORD PTR _tmpVal$1[ebp]
	add	edx, 360				; 00000168H
	mov	DWORD PTR _tmpVal$1[ebp], edx
$LN63@DrawHeadin:

; 976  : 
; 977  : 		// Needed for the 'tick marks'
; 978  : 		a = a/50;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	DWORD PTR _a$[ebp], eax

; 979  : 
; 980  : 		sprintf (tmpStr, "%03d", tmpVal);

	mov	edx, DWORD PTR _tmpVal$1[ebp]
	push	edx
	push	OFFSET ??_C@_04OHGLKFFN@?$CF03d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 981  : #endif
; 982  : 	}
; 983  : 	else {

	jmp	SHORT $LN58@DrawHeadin
$LN67@DrawHeadin:

; 984  : 		// END OF ADDED SECTION - NEXT SECTION INDENTED SINCE IT'S NOW PART OF AN ELSE CLAUSE
; 985  : 		if (a % 100 > 50)

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, 50					; 00000032H
	jle	SHORT $LN61@DrawHeadin

; 986  : 			val = a / 50 + 2;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	add	eax, 2
	mov	DWORD PTR _val$[ebp], eax

; 987  : 		else

	jmp	SHORT $LN60@DrawHeadin
$LN61@DrawHeadin:

; 988  : 			val = a / 50;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	DWORD PTR _val$[ebp], eax
$LN60@DrawHeadin:

; 989  : 		a = a/50;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	DWORD PTR _a$[ebp], eax

; 990  : 
; 991  : 		if (val <= 0)

	cmp	DWORD PTR _val$[ebp], 0
	jg	SHORT $LN59@DrawHeadin

; 992  : 			sprintf (tmpStr, "%02d", (val + 72) >> 1);    

	mov	edx, DWORD PTR _val$[ebp]
	add	edx, 72					; 00000048H
	sar	edx, 1
	push	edx
	push	OFFSET ??_C@_04OGKJMPGK@?$CF02d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 993  : 		else

	jmp	SHORT $LN58@DrawHeadin
$LN59@DrawHeadin:

; 994  : 			sprintf (tmpStr, "%02d", val >> 1);

	mov	ecx, DWORD PTR _val$[ebp]
	sar	ecx, 1
	push	ecx
	push	OFFSET ??_C@_04OGKJMPGK@?$CF02d?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN58@DrawHeadin:

; 995  : 		// CLOSING BRACE ADDED BY S.G.
; 996  : 	}
; 997  : #else
; 998  : 	if (a % 100 > 50)
; 999  : 		val = a / 50 + 2;
; 1000 : 	else
; 1001 : 		val = a / 50;
; 1002 : 	a = a/50;
; 1003 : 
; 1004 : 	if (val <= 0)
; 1005 : 		sprintf (tmpStr, "%02d", (val + 72) >> 1);    
; 1006 : 	else
; 1007 : 		sprintf (tmpStr, "%02d", val >> 1);    
; 1008 : #endif
; 1009 : 
; 1010 : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 1011 : 	a -= 4;

	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, 4
	mov	DWORD PTR _a$[ebp], eax

; 1012 : 
; 1013 : 	//MI
; 1014 : 	if(g_bINS && g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	$LN57@DrawHeadin
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN57@DrawHeadin

; 1015 : 	{
; 1016 : 		if(!ownship->INSState(AircraftClass::INS_HUD_STUFF))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN56@DrawHeadin

; 1017 : 			sprintf(tmpStr,"   ");

	push	OFFSET ??_C@_03NDEAONJP@?5?5?5?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN56@DrawHeadin:

; 1018 : 
; 1019 : 		display->TextCenter (0.0F, vert[0][1] - 0.075F, tmpStr, 1 );

	push	1
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+72]
	call	edx

; 1020 : 	}
; 1021 : 	else

	jmp	SHORT $LN55@DrawHeadin
$LN57@DrawHeadin:

; 1022 : 		display->TextCenter (0.0F, vert[0][1] - 0.075F, tmpStr, 1 );

	push	1
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN55@DrawHeadin:

; 1023 : 
; 1024 : 	textWidth = display->TextWidth (tmpStr);

	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+84]
	call	eax
	fstp	DWORD PTR _textWidth$[ebp]

; 1025 : 
; 1026 : 	if (scalesSwitch == VAH || scalesSwitch == VV_VAH || scalesSwitch == H )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4864], 1
	je	SHORT $LN53@DrawHeadin
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 0
	je	SHORT $LN53@DrawHeadin
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4864], 2
	jne	$LN35@DrawHeadin
$LN53@DrawHeadin:

; 1027 : 	{
; 1028 : 		//MI
; 1029 : 		if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN52@DrawHeadin

; 1030 : 		{
; 1031 : 			for (i=0; i<NUM_HORIZONTAL_TICKS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN51@DrawHeadin
$LN50@DrawHeadin:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN51@DrawHeadin:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	$LN49@DrawHeadin

; 1032 : 			{ 
; 1033 : 				vert[1][0] = vert[0][0];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 8
	shl	eax, 0
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	imul	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1034 : 
; 1035 : 				if (a & 1)

	mov	edx, DWORD PTR _a$[ebp]
	and	edx, 1
	je	SHORT $LN48@DrawHeadin

; 1036 : 					vert[1][1] = vert[0][1] - smallTickLen;

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1037 : 				else

	jmp	$LN41@DrawHeadin
$LN48@DrawHeadin:

; 1038 : 				{
; 1039 : 					vert[1][1] = vert[0][1] - bigTickLen;

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1040 : 					if (a <= 0)

	cmp	DWORD PTR _a$[ebp], 0
	jg	SHORT $LN46@DrawHeadin

; 1041 : 						sprintf (tmpStr, "%02d", (a + 72) >> 1);    

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 72					; 00000048H
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_04OGKJMPGK@?$CF02d?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1042 : 					else

	jmp	SHORT $LN45@DrawHeadin
$LN46@DrawHeadin:

; 1043 : 						sprintf (tmpStr, "%02d", a >> 1);    

	mov	edx, DWORD PTR _a$[ebp]
	sar	edx, 1
	push	edx
	push	OFFSET ??_C@_04OGKJMPGK@?$CF02d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN45@DrawHeadin:

; 1044 : 					ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 1045 : 
; 1046 : 					// don't draw text in virtual display -- too crowded
; 1047 : 					if (fabs (vert[1][0]) > 1.5F * textWidth)

	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1095[ebp]
	movss	xmm0, DWORD PTR tv1095[ebp]
	movss	xmm1, DWORD PTR __real@3fc00000
	mulss	xmm1, DWORD PTR _textWidth$[ebp]
	comiss	xmm0, xmm1
	jbe	$LN41@DrawHeadin

; 1048 : 					{
; 1049 : 						if (display->type == VirtualDisplay::DISPLAY_GENERAL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN43@DrawHeadin

; 1050 : 						{
; 1051 : 							display->TextCenter (vert[1][0], vert[0][1] - 0.075F, tmpStr );

	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 1052 : 						}
; 1053 : 						else

	jmp	$LN41@DrawHeadin
$LN43@DrawHeadin:

; 1054 : 						{ 
; 1055 : 							if
; 1056 : 								(
; 1057 : 								 ((a < 0) && (((-a) % 6) < 2)) ||
; 1058 : 								 ((a >= 0) && ((a % 6) < 2))
; 1059 : 								)

	cmp	DWORD PTR _a$[ebp], 0
	jge	SHORT $LN39@DrawHeadin
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	edx, 2
	jl	SHORT $LN40@DrawHeadin
$LN39@DrawHeadin:
	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN41@DrawHeadin
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	edx, 2
	jge	SHORT $LN41@DrawHeadin
$LN40@DrawHeadin:

; 1060 : 								{
; 1061 : 									display->TextCenter (vert[1][0], vert[0][1] - 0.075F, tmpStr );

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+72]
	call	edx
$LN41@DrawHeadin:

; 1062 : 								}
; 1063 : 						}
; 1064 : 					}
; 1065 : 				} 
; 1066 : 				display->Line (vert[0][0], vert[0][1], vert[1][0], vert[1][1]);

	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1067 : 
; 1068 : 				a ++ ;

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 1
	mov	DWORD PTR _a$[ebp], eax

; 1069 : 				vert[0][0] += tickInc;

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	movss	DWORD PTR [eax+ecx], xmm0

; 1070 : 			} 

	jmp	$LN50@DrawHeadin
$LN49@DrawHeadin:

; 1071 : 		}
; 1072 : 		else

	jmp	$LN35@DrawHeadin
$LN52@DrawHeadin:

; 1073 : 		{
; 1074 : 			for (i=0; i<NUM_HORIZONTAL_TICKS/2; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN37@DrawHeadin
$LN36@DrawHeadin:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN37@DrawHeadin:
	cmp	DWORD PTR _i$[ebp], 5
	jge	$LN35@DrawHeadin

; 1075 : 			{ 
; 1076 : 				vert[1][0] = vert[0][0];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 8
	shl	edx, 0
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	imul	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1077 : 
; 1078 : 				if (a & 1)

	mov	ecx, DWORD PTR _a$[ebp]
	and	ecx, 1
	je	SHORT $LN34@DrawHeadin

; 1079 : 					vert[1][1] = vert[0][1] - smallTickLen;

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1080 : 				else

	jmp	$LN13@DrawHeadin
$LN34@DrawHeadin:

; 1081 : 				{
; 1082 : 					vert[1][1] = vert[0][1] - bigTickLen;

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1083 : 					if (scalesSwitch == VV_VAH) 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 0
	jne	SHORT $LN32@DrawHeadin

; 1084 : 					{
; 1085 : 						if (a <= 0)

	cmp	DWORD PTR _a$[ebp], 0
	jg	SHORT $LN31@DrawHeadin

; 1086 : 						{
; 1087 : 							sprintf (tmpStr, "%3d", ((a + 74) * 10) >> 1);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 74					; 0000004aH
	imul	eax, 10					; 0000000aH
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_03GOOLIKIF@?$CF3d?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1088 : 							if(atoi(tmpStr) == 370)	//MI HACK to prevent "37" beeing written

	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	cmp	eax, 370				; 00000172H
	jne	SHORT $LN30@DrawHeadin

; 1089 : 								sprintf(tmpStr,"010");

	push	OFFSET ??_C@_03NEHPGBBG@010?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN30@DrawHeadin:

; 1090 : 						}
; 1091 : 						else

	jmp	SHORT $LN29@DrawHeadin
$LN31@DrawHeadin:

; 1092 : 							sprintf (tmpStr, "%3d", ((a + 2) * 10) >> 1);

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 2
	imul	ecx, 10					; 0000000aH
	sar	ecx, 1
	push	ecx
	push	OFFSET ??_C@_03GOOLIKIF@?$CF3d?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN29@DrawHeadin:

; 1093 : 					}
; 1094 : 					else 

	jmp	SHORT $LN25@DrawHeadin
$LN32@DrawHeadin:

; 1095 : 					{
; 1096 : 						if (a <= 0)

	cmp	DWORD PTR _a$[ebp], 0
	jg	SHORT $LN27@DrawHeadin

; 1097 : 						{
; 1098 : 							sprintf (tmpStr, "%02d", (a + 74) >> 1);

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 74					; 0000004aH
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_04OGKJMPGK@?$CF02d?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1099 : 							if(atoi(tmpStr) == 37)	//MI HACK to prevent "37" beeing written

	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN26@DrawHeadin

; 1100 : 								sprintf(tmpStr,"01");

	push	OFFSET ??_C@_02OCIIMEMP@01?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN26@DrawHeadin:

; 1101 : 						}
; 1102 : 						else

	jmp	SHORT $LN25@DrawHeadin
$LN27@DrawHeadin:

; 1103 : 							sprintf (tmpStr, "%02d", (a + 2) >> 1);

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 2
	sar	ecx, 1
	push	ecx
	push	OFFSET ??_C@_04OGKJMPGK@?$CF02d?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN25@DrawHeadin:

; 1104 : 					}
; 1105 : 
; 1106 : 					ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 1107 : 
; 1108 : 					if (fabs (vert[1][0]) > 1.5F * textWidth)

	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1197[ebp]
	movss	xmm0, DWORD PTR tv1197[ebp]
	movss	xmm1, DWORD PTR __real@3fc00000
	mulss	xmm1, DWORD PTR _textWidth$[ebp]
	comiss	xmm0, xmm1
	jbe	$LN13@DrawHeadin

; 1109 : 					{
; 1110 : 						// don't draw text in virtual display -- too crowded
; 1111 : 						if (display->type == VirtualDisplay::DISPLAY_GENERAL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+4], 0
	jne	$LN23@DrawHeadin

; 1112 : 						{
; 1113 : 							if(g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	SHORT $LN22@DrawHeadin

; 1114 : 							{
; 1115 : 								if(ownship->INSState(AircraftClass::INS_HUD_STUFF))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN21@DrawHeadin

; 1116 : 								{
; 1117 : 									display->TextCenter (vert[1][0], vert[0][1] - 0.075F, tmpStr );

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN21@DrawHeadin:

; 1118 : 								}
; 1119 : 							}
; 1120 : 							else

	jmp	SHORT $LN20@DrawHeadin
$LN22@DrawHeadin:

; 1121 : 								display->TextCenter (vert[1][0], vert[0][1] - 0.075F, tmpStr );

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN20@DrawHeadin:

; 1122 : 						}
; 1123 : 						else

	jmp	$LN13@DrawHeadin
$LN23@DrawHeadin:

; 1124 : 						{
; 1125 : 							if
; 1126 : 								(
; 1127 : 								 ((a < 0) && (((-a) % 6) < 2)) ||
; 1128 : 								 ((a >= 0) && ((a % 6) < 2))
; 1129 : 								)

	cmp	DWORD PTR _a$[ebp], 0
	jge	SHORT $LN16@DrawHeadin
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	edx, 2
	jl	SHORT $LN17@DrawHeadin
$LN16@DrawHeadin:
	cmp	DWORD PTR _a$[ebp], 0
	jl	$LN13@DrawHeadin
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	cmp	edx, 2
	jge	$LN13@DrawHeadin
$LN17@DrawHeadin:

; 1130 : 								{
; 1131 : 									if(g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	SHORT $LN15@DrawHeadin

; 1132 : 									{
; 1133 : 										if(ownship->INSState(AircraftClass::INS_HUD_STUFF))

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN14@DrawHeadin

; 1134 : 										{
; 1135 : 											display->TextCenter (vert[1][0], vert[0][1] - 0.075F, tmpStr );

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN14@DrawHeadin:

; 1136 : 										}
; 1137 : 									}
; 1138 : 									else

	jmp	SHORT $LN13@DrawHeadin
$LN15@DrawHeadin:

; 1139 : 										display->TextCenter (vert[1][0], vert[0][1] - 0.075F, tmpStr );

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN13@DrawHeadin:

; 1140 : 								}
; 1141 : 						}
; 1142 : 					}
; 1143 : 				} 
; 1144 : 				display->Line (vert[0][0], vert[0][1], vert[1][0], vert[1][1]);

	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1145 : 
; 1146 : 				a ++ ;

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 1
	mov	DWORD PTR _a$[ebp], ecx

; 1147 : 				vert[0][0] += tickInc;

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	movss	DWORD PTR [ecx+edx], xmm0

; 1148 : 			}

	jmp	$LN36@DrawHeadin
$LN35@DrawHeadin:

; 1149 : 		}
; 1150 : 	}
; 1151 : 
; 1152 : 	DrawWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWaypoint@HudClass@@AAEXXZ		; HudClass::DrawWaypoint

; 1153 : 	//MI
; 1154 : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN12@DrawHeadin

; 1155 : 		DrawTadpole();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTadpole@HudClass@@AAEXXZ		; HudClass::DrawTadpole

; 1156 : 	else

	jmp	SHORT $LN9@DrawHeadin
$LN12@DrawHeadin:

; 1157 : 	{
; 1158 : 		if(FCC && FCC->GetMasterMode() == FireControlComputer::ILS &&
; 1159 : 				OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp->GetCMDSTR())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN10@DrawHeadin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 3
	jne	SHORT $LN10@DrawHeadin
	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN10@DrawHeadin
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?GetCMDSTR@ICPClass@@QAEHXZ		; ICPClass::GetCMDSTR
	test	eax, eax
	je	SHORT $LN10@DrawHeadin

; 1160 : 			DrawCMDSTRG();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCMDSTRG@HudClass@@QAEXXZ		; HudClass::DrawCMDSTRG

; 1161 : 		else

	jmp	SHORT $LN9@DrawHeadin
$LN10@DrawHeadin:

; 1162 : 			DrawTadpole();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTadpole@HudClass@@AAEXXZ		; HudClass::DrawTadpole
$LN9@DrawHeadin:

; 1163 : 	}
; 1164 : 	//MI
; 1165 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN8@DrawHeadin

; 1166 : 		DrawRollCue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRollCue@HudClass@@AAEXXZ		; HudClass::DrawRollCue

; 1167 : 	else

	jmp	$LN2@DrawHeadin
$LN8@DrawHeadin:

; 1168 : 	{
; 1169 : 		//MI appears to be based on mode and geardown/switch, not only switch
; 1170 : #if 0
; 1171 : 		if(fpmSwitch != FPM_OFF && scalesSwitch == VV_VAH)
; 1172 : 			DrawBankIndicator();
; 1173 : 		else if(fpmSwitch != FPM_OFF && scalesSwitch == VAH)
; 1174 : 			DrawRollCue();
; 1175 : #else
; 1176 : 		if(FCC && FCC->IsAGMasterMode() || (playerAC->af->gearPos > 0.5F &&
; 1177 : 					fpmSwitch != FPM_OFF && scalesSwitch == VV_VAH))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN4@DrawHeadin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	jne	SHORT $LN5@DrawHeadin
$LN4@DrawHeadin:
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN6@DrawHeadin
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4868], 2
	je	SHORT $LN6@DrawHeadin
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4864], 0
	jne	SHORT $LN6@DrawHeadin
$LN5@DrawHeadin:

; 1178 : 			DrawBankIndicator();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawBankIndicator@HudClass@@QAEXXZ	; HudClass::DrawBankIndicator

; 1179 : 		//not there in Dogfight
; 1180 : 		else

	jmp	SHORT $LN2@DrawHeadin
$LN6@DrawHeadin:

; 1181 : 		{
; 1182 : 			if(FCC && FCC->GetMasterMode() != FireControlComputer::Dogfight &&
; 1183 : 					GetDEDSwitch() == DED_OFF)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN2@DrawHeadin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN2@DrawHeadin
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDEDSwitch@HudClass@@QAEHXZ		; HudClass::GetDEDSwitch
	cmp	eax, 1
	jne	SHORT $LN2@DrawHeadin

; 1184 : 				DrawRollCue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRollCue@HudClass@@AAEXXZ		; HudClass::DrawRollCue
$LN2@DrawHeadin:

; 1185 : 		}
; 1186 : #endif
; 1187 : 	}
; 1188 : 	//MI
; 1189 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawHeadin

; 1190 : 	{
; 1191 : 		DrawOA();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawOA@HudClass@@QAEXXZ		; HudClass::DrawOA

; 1192 : 		DrawVIP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawVIP@HudClass@@QAEXXZ		; HudClass::DrawVIP

; 1193 : 		DrawVRP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawVRP@HudClass@@QAEXXZ		; HudClass::DrawVRP
$LN1@DrawHeadin:
$LN96@DrawHeadin:

; 1194 : 	}
; 1195 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawHeading@HudClass@@AAEXXZ ENDP			; HudClass::DrawHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
tv1313 = -116						; size = 4
tv1417 = -112						; size = 4
tv958 = -108						; size = 4
tv970 = -104						; size = 4
tv967 = -100						; size = 4
_lowAlt$ = -96						; size = 4
_labelInterval$ = -92					; size = 4
_tickInterval$ = -88					; size = 4
_boxY$ = -84						; size = 4
_formatStr$ = -80					; size = 4
_winCenter$ = -76					; size = 4
_labelMod$ = -72					; size = 4
_y2$ = -68						; size = 4
_bigTickLen$ = -64					; size = 4
_i$ = -60						; size = 4
_x2$ = -56						; size = 4
_leftEdge$ = -52					; size = 4
_a$ = -48						; size = 4
_smallTickLen$ = -44					; size = 4
_tickInc$ = -40						; size = 4
_x1$ = -36						; size = 4
_theAlt$ = -32						; size = 4
_y1$ = -28						; size = 4
_this$ = -24						; size = 4
_highFormat$ = -20					; size = 8
_lowFormat$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
?DrawAltitude@HudClass@@AAEXXZ PROC			; HudClass::DrawAltitude
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	float leftEdge;
; 275  : 	float bigTickLen;
; 276  : 	float smallTickLen;
; 277  : 	float tickInc;
; 278  : 	float x1, x2, y1, y2;
; 279  : 	float winCenter, boxY;
; 280  : 	int i, a, lowAlt;
; 281  : 	float theAlt;
; 282  : 	//MI moved to the Class
; 283  : 	//char tmpStr[12];
; 284  : 	//float hat;
; 285  : 	int tickInterval, labelMod, labelInterval;
; 286  : 	char* formatStr;
; 287  : 	char highFormat[] = "%02d,%d";

	mov	eax, DWORD PTR ??_C@_07HDNLKEPD@?$CF02d?0?$CFd?$AA@
	mov	DWORD PTR _highFormat$[ebp], eax
	mov	ecx, DWORD PTR ??_C@_07HDNLKEPD@?$CF02d?0?$CFd?$AA@+4
	mov	DWORD PTR _highFormat$[ebp+4], ecx

; 288  : 	char lowFormat[] = "%d%02d";

	mov	edx, DWORD PTR ??_C@_06LDAHLMHO@?$CFd?$CF02d?$AA@
	mov	DWORD PTR _lowFormat$[ebp], edx
	mov	ax, WORD PTR ??_C@_06LDAHLMHO@?$CFd?$CF02d?$AA@+4
	mov	WORD PTR _lowFormat$[ebp+4], ax
	mov	cl, BYTE PTR ??_C@_06LDAHLMHO@?$CFd?$CF02d?$AA@+6
	mov	BYTE PTR _lowFormat$[ebp+6], cl

; 289  : 
; 290  : 
; 291  : 	if(ownship == NULL) {	// vwf: to avoid crash after ownship gets destroyed.

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN126@DrawAltitu

; 292  : 		return;

	jmp	$LN127@DrawAltitu
$LN126@DrawAltitu:

; 293  : 	}
; 294  : 
; 295  : 	// Height Above Terrain
; 296  : 	hat = cockpitFlightData.z - OTWDriver.GetGroundLevel (ownship->XPos(), ownship->YPos());

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv1313[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	subss	xmm0, DWORD PTR tv1313[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+5080], xmm0

; 297  : 
; 298  : 	// Max hat if no rad alt
; 299  : 	if (ownship->mFaults && ownship->mFaults->GetFault(FaultClass::ralt_fault))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx+928], 0
	je	SHORT $LN125@DrawAltitu
	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN125@DrawAltitu

; 300  : 		hat = -999999.9F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c97423fe
	movss	DWORD PTR [ecx+5080], xmm0
$LN125@DrawAltitu:

; 301  : 
; 302  : 	// Window 25 (ALOW warning)
; 303  : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	$LN124@DrawAltitu

; 304  : 	{
; 305  : 		//MI original code
; 306  : 		if (-hat < lowAltWarning && flash && ((AircraftClass*)ownship)->af->gearPos < 0.5F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4960]
	comiss	xmm1, xmm0
	jbe	$LN123@DrawAltitu
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	$LN123@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [ecx+1552]
	jbe	$LN123@DrawAltitu

; 307  : 		{
; 308  : 			sprintf (tmpStr, "AL %.0f", -hat);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07KFONKJBG@AL?5?$CF?40f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 309  : 			ShiAssert (strlen(tmpStr) < 40);
; 310  : 			DrawWindowString (25, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 311  : 			F4SoundFXSetDist( ownship->af->GetAltitudeSnd(), FALSE, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAltitudeSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetAltitudeSnd
	push	eax
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN123@DrawAltitu:

; 312  : 		}
; 313  : 	}
; 314  : 	else

	jmp	$LN102@DrawAltitu
$LN124@DrawAltitu:

; 315  : 	{
; 316  : 		//MI modified stuff
; 317  : 		if(((AircraftClass*)ownship)->af->platform->IsPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN102@DrawAltitu

; 318  : 		{
; 319  : 			if(radarSwitch == BARO){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4880], 1
	jne	SHORT $LN120@DrawAltitu

; 320  : 				DrawRALTBox();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRALTBox@HudClass@@QAEXXZ		; HudClass::DrawRALTBox

; 321  : 				DrawRALT();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRALT@HudClass@@QAEXXZ		; HudClass::DrawRALT
	jmp	$LN102@DrawAltitu
$LN120@DrawAltitu:

; 322  : 			}
; 323  : 			else if(radarSwitch == RADAR_AUTO){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4880], 2
	jne	$LN118@DrawAltitu

; 324  : 				if(-cockpitFlightData.z >= 1200){

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@44960000
	jb	SHORT $LN117@DrawAltitu

; 325  : 					DrawRALTBox();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRALTBox@HudClass@@QAEXXZ		; HudClass::DrawRALTBox

; 326  : 					DrawRALT();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRALT@HudClass@@QAEXXZ		; HudClass::DrawRALT

; 327  : 				}
; 328  : 				else {

	jmp	$LN110@DrawAltitu
$LN117@DrawAltitu:

; 329  : 					if (-hat < lowAltWarning && (FindRollAngle(-hat) && FindPitchAngle(-hat)) &&
; 330  : 							((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4960]
	comiss	xmm1, xmm0
	jbe	$LN115@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	$LN115@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	$LN115@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN115@DrawAltitu

; 331  : 					{
; 332  : 						if(Warnflash && !((AircraftClass*)ownship)->OnGround()){

	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	SHORT $LN114@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN114@DrawAltitu

; 333  : 							DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
	jmp	SHORT $LN112@DrawAltitu
$LN114@DrawAltitu:

; 334  : 						}
; 335  : 						else if(((AircraftClass*)ownship)->OnGround()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN112@DrawAltitu

; 336  : 							DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN112@DrawAltitu:

; 337  : 						}
; 338  : 						if(((AircraftClass*)ownship)->af->gearPos < 0.8F){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [eax+1552]
	jbe	SHORT $LN111@DrawAltitu

; 339  : 							F4SoundFXSetDist(ownship->af->GetAltitudeSnd(), FALSE, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetAltitudeSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetAltitudeSnd
	push	eax
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN111@DrawAltitu:

; 340  : 						}
; 341  : 					}
; 342  : 					else{

	jmp	SHORT $LN110@DrawAltitu
$LN115@DrawAltitu:

; 343  : 						DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN110@DrawAltitu:

; 344  : 					}
; 345  : 				}
; 346  : 			}
; 347  : 			else {

	jmp	$LN102@DrawAltitu
$LN118@DrawAltitu:

; 348  : 				if(FCC->GetMasterMode() !=FireControlComputer::Dogfight && FCC->GetMasterMode() !=FireControlComputer::MissileOverride)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	$LN102@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	je	$LN102@DrawAltitu

; 349  : 				{
; 350  : 					if(-hat < lowAltWarning && (FindRollAngle(-hat) && FindPitchAngle(-hat)) &&
; 351  : 							((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4960]
	comiss	xmm1, xmm0
	jbe	$LN107@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	$LN107@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	$LN107@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN107@DrawAltitu

; 352  : 					{
; 353  : 						if(Warnflash && !((AircraftClass*)ownship)->OnGround()){

	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	SHORT $LN106@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN106@DrawAltitu

; 354  : 							DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
	jmp	SHORT $LN104@DrawAltitu
$LN106@DrawAltitu:

; 355  : 						}
; 356  : 						else if(((AircraftClass*)ownship)->OnGround()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN104@DrawAltitu

; 357  : 							DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN104@DrawAltitu:

; 358  : 						}
; 359  : 						if(((AircraftClass*)ownship)->af->gearPos < 0.8F){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [edx+1552]
	jbe	SHORT $LN103@DrawAltitu

; 360  : 							F4SoundFXSetDist(ownship->af->GetAltitudeSnd(), FALSE, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetAltitudeSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetAltitudeSnd
	push	eax
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN103@DrawAltitu:

; 361  : 						}
; 362  : 					}
; 363  : 					else {

	jmp	SHORT $LN102@DrawAltitu
$LN107@DrawAltitu:

; 364  : 						DrawALString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawALString@HudClass@@QAEXXZ		; HudClass::DrawALString
$LN102@DrawAltitu:

; 365  : 					}
; 366  : 				}
; 367  : 			}
; 368  : 		}
; 369  : 	}
; 370  : 
; 371  : 
; 372  : 
; 373  : 	winCenter = hudWinY[ALTITUDE_WINDOW] + hudWinHeight[ALTITUDE_WINDOW] * 0.5F;

	mov	edx, 4
	imul	edx, 39					; 00000027H
	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _winCenter$[ebp], xmm0

; 374  : 	boxY = winCenter + display->TextHeight() * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+88]
	call	eax
	fstp	DWORD PTR tv1417[ebp]
	movss	xmm0, DWORD PTR tv1417[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR _boxY$[ebp], xmm0

; 375  : 	//TJL 03/07/04 Only for F16 or default HUD
; 376  : 	if ((ownship->IsF16() || ownship->af->GetTypeAC() == 0) && (scalesSwitch == VAH  || scalesSwitch == VV_VAH) 
; 377  : 			&& (FCC->GetMasterMode() !=FireControlComputer::Dogfight))//me123 status test.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN100@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN101@DrawAltitu
$LN100@DrawAltitu:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4864], 1
	je	SHORT $LN99@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 0
	jne	$LN101@DrawAltitu
$LN99@DrawAltitu:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	$LN101@DrawAltitu

; 378  : 	{
; 379  : 		//MI
; 380  : 		if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN97@DrawAltitu

; 381  : 		{
; 382  : 			if (scalesSwitch == VAH)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 1
	jne	SHORT $LN97@DrawAltitu

; 383  : 				boxY = 2.0F;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _boxY$[ebp], xmm0
$LN97@DrawAltitu:

; 384  : 		}
; 385  : 		//MI
; 386  : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN96@DrawAltitu

; 387  : 		{
; 388  : 			bigTickLen = hudWinWidth[ALTITUDE_WINDOW] * 0.5F;

	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 389  : 			smallTickLen = bigTickLen * 0.5F;

	movss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 390  : 		}
; 391  : 		else

	jmp	SHORT $LN95@DrawAltitu
$LN96@DrawAltitu:

; 392  : 		{
; 393  : 			bigTickLen = hudWinWidth[ALTITUDE_WINDOW] * 0.2F;

	mov	edx, 4
	imul	edx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 394  : 			smallTickLen = bigTickLen * 0.55F;

	movss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR _smallTickLen$[ebp], xmm0
$LN95@DrawAltitu:

; 395  : 		}
; 396  : 
; 397  : 		leftEdge = hudWinX[ALTITUDE_WINDOW];

	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinX@@3PAMA[eax]
	movss	DWORD PTR _leftEdge$[ebp], xmm0

; 398  : 		/*bigTickLen = hudWinWidth[ALTITUDE_WINDOW] * 0.5F;
; 399  : 		  smallTickLen = bigTickLen * 0.5F;*/
; 400  : 		tickInc = hudWinHeight[ALTITUDE_WINDOW] / (float)(NUM_VERTICAL_TICKS - 1);

	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 401  : 
; 402  : 		// Choose the right scale
; 403  : 		if (radarSwitch == BARO)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4880], 1
	jne	SHORT $LN94@DrawAltitu

; 404  : 		{
; 405  : 			theAlt = cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	movss	DWORD PTR _theAlt$[ebp], xmm0
	jmp	$LN76@DrawAltitu
$LN94@DrawAltitu:

; 406  : 		}
; 407  : 		else if (radarSwitch == ALT_RADAR)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4880], 0
	jne	$LN92@DrawAltitu

; 408  : 		{
; 409  : 			//MI for CARA switch
; 410  : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN91@DrawAltitu

; 411  : 			{
; 412  : 				if(((AircraftClass*)ownship)->af->platform->IsPlayer() &&
; 413  : 						((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN90@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	SHORT $LN90@DrawAltitu

; 414  : 				{
; 415  : 					if(FindRollAngle(-hat) && FindPitchAngle(-hat))

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	SHORT $LN89@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	SHORT $LN89@DrawAltitu

; 416  : 					{
; 417  : 						//CARA is ready and we're within limits
; 418  : 						DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 419  : 						theAlt = hat;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	movss	DWORD PTR _theAlt$[ebp], xmm0

; 420  : 					}
; 421  : 					else

	jmp	SHORT $LN88@DrawAltitu
$LN89@DrawAltitu:

; 422  : 						theAlt = cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN88@DrawAltitu:

; 423  : 				}
; 424  : 				else

	jmp	SHORT $LN87@DrawAltitu
$LN90@DrawAltitu:

; 425  : 				{
; 426  : 					//CARA is not yet ready
; 427  : 					theAlt = cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN87@DrawAltitu:

; 428  : 				}
; 429  : 			}
; 430  : 			else

	jmp	SHORT $LN86@DrawAltitu
$LN91@DrawAltitu:

; 431  : 			{
; 432  : 				DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 433  : 				theAlt = hat;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN86@DrawAltitu:

; 434  : 			}
; 435  : 		}
; 436  : 		else

	jmp	$LN76@DrawAltitu
$LN92@DrawAltitu:

; 437  : 		{
; 438  : 			if (hat > -1200.0F || (cockpitFlightData.zDot < 0.0F && hat > -1500.0F))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	comiss	xmm0, DWORD PTR __real@c4960000
	ja	SHORT $LN83@DrawAltitu
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	jbe	$LN84@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	comiss	xmm0, DWORD PTR __real@c4bb8000
	jbe	$LN84@DrawAltitu
$LN83@DrawAltitu:

; 439  : 			{
; 440  : 				//MI for CARA switch
; 441  : 				if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN82@DrawAltitu

; 442  : 				{
; 443  : 					if(((AircraftClass*)ownship)->af->platform->IsPlayer() &&
; 444  : 							((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN81@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	SHORT $LN81@DrawAltitu

; 445  : 					{
; 446  : 						if(FindRollAngle(-hat) && FindPitchAngle(-hat))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	SHORT $LN80@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	SHORT $LN80@DrawAltitu

; 447  : 						{ 
; 448  : 							//CARA is ready and we're within limits
; 449  : 							DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 450  : 							theAlt = hat;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	movss	DWORD PTR _theAlt$[ebp], xmm0

; 451  : 						}
; 452  : 						else

	jmp	SHORT $LN79@DrawAltitu
$LN80@DrawAltitu:

; 453  : 							theAlt = cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN79@DrawAltitu:

; 454  : 					}
; 455  : 					else

	jmp	SHORT $LN78@DrawAltitu
$LN81@DrawAltitu:

; 456  : 					{
; 457  : 						//CARA is not yet ready
; 458  : 						theAlt = cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN78@DrawAltitu:

; 459  : 					}
; 460  : 				}
; 461  : 				else

	jmp	SHORT $LN77@DrawAltitu
$LN82@DrawAltitu:

; 462  : 				{
; 463  : 					DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 464  : 					theAlt = hat;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN77@DrawAltitu:

; 465  : 				}
; 466  : 			}
; 467  : 			else

	jmp	SHORT $LN76@DrawAltitu
$LN84@DrawAltitu:

; 468  : 			{
; 469  : 				theAlt = cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN76@DrawAltitu:

; 470  : 			}
; 471  : 		}
; 472  : 
; 473  : 		a = -FloatToInt32(theAlt);

	push	ecx
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	neg	eax
	mov	DWORD PTR _a$[ebp], eax

; 474  : 		// Under 1500 going up or below 1200 going down
; 475  : 		if (a < 1200 || (cockpitFlightData.zDot < 0.0F && a < 1500)){

	cmp	DWORD PTR _a$[ebp], 1200		; 000004b0H
	jl	SHORT $LN74@DrawAltitu
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	jbe	SHORT $LN75@DrawAltitu
	cmp	DWORD PTR _a$[ebp], 1500		; 000005dcH
	jge	SHORT $LN75@DrawAltitu
$LN74@DrawAltitu:

; 476  : 			lowAlt = TRUE;

	mov	DWORD PTR _lowAlt$[ebp], 1

; 477  : 		}
; 478  : 		else{

	jmp	SHORT $LN73@DrawAltitu
$LN75@DrawAltitu:

; 479  : 			lowAlt = FALSE;

	mov	DWORD PTR _lowAlt$[ebp], 0
$LN73@DrawAltitu:

; 480  : 		}
; 481  : 
; 482  : 		// Non-Auto altitude scale
; 483  : 		if (radarSwitch != RADAR_AUTO || !lowAlt){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4880], 2
	jne	SHORT $LN71@DrawAltitu
	cmp	DWORD PTR _lowAlt$[ebp], 0
	jne	$LN72@DrawAltitu
$LN71@DrawAltitu:

; 484  : 			if (lowAlt){

	cmp	DWORD PTR _lowAlt$[ebp], 0
	je	SHORT $LN70@DrawAltitu

; 485  : 				tickInterval = 20;

	mov	DWORD PTR _tickInterval$[ebp], 20	; 00000014H

; 486  : 				labelInterval = 100;

	mov	DWORD PTR _labelInterval$[ebp], 100	; 00000064H

; 487  : 				labelMod = 100;

	mov	DWORD PTR _labelMod$[ebp], 100		; 00000064H

; 488  : 				formatStr = lowFormat;

	lea	edx, DWORD PTR _lowFormat$[ebp]
	mov	DWORD PTR _formatStr$[ebp], edx

; 489  : 			} 
; 490  : 			else {

	jmp	SHORT $LN69@DrawAltitu
$LN70@DrawAltitu:

; 491  : 				tickInterval = 100;

	mov	DWORD PTR _tickInterval$[ebp], 100	; 00000064H

; 492  : 				labelInterval = 500;

	mov	DWORD PTR _labelInterval$[ebp], 500	; 000001f4H

; 493  : 				labelMod = 1000;

	mov	DWORD PTR _labelMod$[ebp], 1000		; 000003e8H

; 494  : 				formatStr = highFormat;

	lea	eax, DWORD PTR _highFormat$[ebp]
	mov	DWORD PTR _formatStr$[ebp], eax
$LN69@DrawAltitu:

; 495  : 			}
; 496  : 
; 497  : 			a -= labelInterval;

	mov	ecx, DWORD PTR _a$[ebp]
	sub	ecx, DWORD PTR _labelInterval$[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 498  : 			a -= a%tickInterval;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _tickInterval$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, edx
	mov	DWORD PTR _a$[ebp], eax

; 499  : 			y1 = winCenter - (-theAlt - a) / tickInterval * tickInc;

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtsi2ss xmm1, DWORD PTR _a$[ebp]
	subss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _tickInterval$[ebp]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	xmm1, DWORD PTR _winCenter$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _y1$[ebp], xmm1

; 500  : 
; 501  : 			x1 = leftEdge;

	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 502  : 			leftEdge *= 0.95F;   // JPG 0.95F

	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR _leftEdge$[ebp], xmm0

; 503  : 
; 504  : 			// Draw index tick
; 505  : 			//MI
; 506  : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN68@DrawAltitu

; 507  : 			{
; 508  : 				if (!(FCC->GetMasterMode() == FireControlComputer::Missile) &&
; 509  : 						!(FCC->GetMasterMode() == FireControlComputer::Dogfight) &&
; 510  : 						!(FCC->GetMasterMode() == FireControlComputer::MissileOverride))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 2
	je	SHORT $LN67@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN67@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN67@DrawAltitu

; 511  : 				{
; 512  : 					display->Line(leftEdge, winCenter,
; 513  : 							leftEdge - hudWinWidth[ALTITUDE_WINDOW] * 0.5F, winCenter);

	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	edx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _leftEdge$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN67@DrawAltitu:

; 514  : 				}
; 515  : 			}
; 516  : 			else{

	jmp	SHORT $LN66@DrawAltitu
$LN68@DrawAltitu:

; 517  : 				display->Line (leftEdge, winCenter, leftEdge - bigTickLen, winCenter);

	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN66@DrawAltitu:

; 518  : 			}
; 519  : 
; 520  : 			//Cobra Add in the delay 
; 521  : 			if ((unsigned long)hudAltDelayTimer < SimLibElapsedTime) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5156]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN65@DrawAltitu

; 522  : 				altHud=theAlt;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	movss	DWORD PTR [edx+5168], xmm0

; 523  : 				altHudn=-theAlt;//Seed the other while in this loop

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+5172], xmm0

; 524  : 				hudAltDelayTimer = SimLibElapsedTime + 250;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 250				; 000000faH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5156], ecx
$LN65@DrawAltitu:

; 525  : 			}
; 526  : 
; 527  : 			// Add Discretes to tape
; 528  : 			if (theAlt > 0.0F){

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN64@DrawAltitu

; 529  : 				//MI
; 530  : 				if(g_bRealisticAvionics){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN63@DrawAltitu

; 531  : 					//only show 10's of feet
; 532  : 					theAlt = ((static_cast<int>(altHud) + 5) / 10) * 10.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [ecx+5168]
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN63@DrawAltitu:

; 533  : 				}
; 534  : 				sprintf (tmpStr, "%2d,%03d", -FloatToInt32(theAlt * 0.001F),
; 535  : 						FloatToInt32(theAlt - FloatToInt32(theAlt * 0.001F) * 1000.0F));

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	xmm1, DWORD PTR _theAlt$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	neg	eax
	push	eax
	push	OFFSET ??_C@_08MHFJHILJ@?$CF2d?0?$CF03d?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 536  : 			}
; 537  : 			else{

	jmp	$LN62@DrawAltitu
$LN64@DrawAltitu:

; 538  : 				//MI
; 539  : 				if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN61@DrawAltitu

; 540  : 					//only show 10's of feet
; 541  : 					theAlt = ((static_cast<int>(altHud) + 5) / 10) * 10.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [ecx+5168]
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN61@DrawAltitu:

; 542  : 				}
; 543  : 				sprintf (tmpStr, "%2d,%03d", -FloatToInt32(theAlt * 0.001F),
; 544  : 						-(FloatToInt32(theAlt - FloatToInt32(theAlt * 0.001F) * 1000.0F)));

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	xmm1, DWORD PTR _theAlt$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	neg	eax
	push	eax
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	neg	eax
	push	eax
	push	OFFSET ??_C@_08MHFJHILJ@?$CF2d?0?$CF03d?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN62@DrawAltitu:

; 545  : 			}
; 546  : 			//MI
; 547  : 			//ATARIBABY fix for missaligned alt readout in 3d padlock
; 548  : 			//if(!g_bRealisticAvionics || OTWDriver.GetOTWDisplayMode() == OTWDriverClass::Mode3DCockpit)
; 549  : 			// sfr: caused hud altitude missaligned
; 550  : #if 0
; 551  : 			if (!g_bRealisticAvionics || OTWDriver.GetOTWDisplayMode() == OTWDriverClass::Mode3DCockpit || OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModePadlockF3)
; 552  : 			{
; 553  : 				display->TextRight(hudWinX[ALTITUDE_WINDOW] + 0.01F + hudWinWidth[ALTITUDE_WINDOW],
; 554  : 						boxY, tmpStr, 4);
; 555  : 			}
; 556  : 			else
; 557  : 			{
; 558  : 				display->TextRight(hudWinX[ALTITUDE_WINDOW] + 0.17F + hudWinWidth[ALTITUDE_WINDOW],
; 559  : 						boxY, tmpStr, 4);
; 560  : 			}
; 561  : #endif
; 562  : 
; 563  : 			// sfr: above code was causing altitude hud missalignment and changed from .17 to .22
; 564  : 			display->TextRight(hudWinX[ALTITUDE_WINDOW] + 0.22F + hudWinWidth[ALTITUDE_WINDOW], boxY, tmpStr, 4);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _boxY$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinX@@3PAMA[ecx]
	addss	xmm0, DWORD PTR __real@3e6147ae
	mov	edx, 4
	imul	edx, 39					; 00000027H
	addss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 565  : 
; 566  : 			for (i=0; i<NUM_VERTICAL_TICKS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN60@DrawAltitu
$LN59@DrawAltitu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN60@DrawAltitu:
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jge	$LN58@DrawAltitu

; 567  : 			{
; 568  : 				//MI don't draw into the text!
; 569  : 				/*if (a >= 0 && 
; 570  : 				  (y1 - boxY > display->TextHeight() * 1.1F ||
; 571  : 				  y1 - boxY < -tickInc))*/
; 572  : 				if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN57@DrawAltitu

; 573  : 				{
; 574  : 					if (a >= 0 && (y1 - boxY > tickInc || y1 - boxY < (-tickInc * 3.0F)))

	cmp	DWORD PTR _a$[ebp], 0
	jl	$LN56@DrawAltitu
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	comiss	xmm0, DWORD PTR _tickInc$[ebp]
	ja	SHORT $LN55@DrawAltitu
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	movss	xmm1, DWORD PTR _tickInc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR __real@40400000
	comiss	xmm1, xmm0
	jbe	$LN56@DrawAltitu
$LN55@DrawAltitu:

; 575  : 					{ 
; 576  : 						if (a % labelInterval)

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelInterval$[ebp]
	test	edx, edx
	je	SHORT $LN54@DrawAltitu

; 577  : 							x2 = x1 + smallTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 578  : 						else

	jmp	$LN53@DrawAltitu
$LN54@DrawAltitu:

; 579  : 						{
; 580  : 							if (formatStr == lowFormat)

	lea	edx, DWORD PTR _lowFormat$[ebp]
	cmp	DWORD PTR _formatStr$[ebp], edx
	jne	SHORT $LN52@DrawAltitu

; 581  : 								sprintf (tmpStr, formatStr, a/labelMod, a%labelMod);

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	push	eax
	mov	eax, DWORD PTR _formatStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 582  : 							else

	jmp	SHORT $LN51@DrawAltitu
$LN52@DrawAltitu:

; 583  : 								sprintf (tmpStr, formatStr, a/labelMod, (a%labelMod) / 100);

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	mov	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	push	eax
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	push	eax
	mov	edx, DWORD PTR _formatStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN51@DrawAltitu:

; 584  : 							ShiAssert (strlen(tmpStr) < 12);
; 585  : 							x2 = x1 + bigTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 586  : 							display->TextLeftVertical(x2 + smallTickLen * 0.5F, y1 + 0.01F, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _x2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN53@DrawAltitu:

; 587  : 						}
; 588  : 						display->Line (x1, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN56@DrawAltitu:

; 589  : 					}                    
; 590  : 				}
; 591  : 				else

	jmp	$LN50@DrawAltitu
$LN57@DrawAltitu:

; 592  : 				{
; 593  : 					if (a % labelInterval)

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelInterval$[ebp]
	test	edx, edx
	je	SHORT $LN49@DrawAltitu

; 594  : 						x2 = x1 + smallTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 595  : 					else

	jmp	$LN45@DrawAltitu
$LN49@DrawAltitu:

; 596  : 					{
; 597  : 						if (formatStr == lowFormat)

	lea	ecx, DWORD PTR _lowFormat$[ebp]
	cmp	DWORD PTR _formatStr$[ebp], ecx
	jne	SHORT $LN47@DrawAltitu

; 598  : 							sprintf (tmpStr, formatStr, a/labelMod, a%labelMod);

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	push	eax
	mov	edx, DWORD PTR _formatStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 599  : 						else

	jmp	SHORT $LN46@DrawAltitu
$LN47@DrawAltitu:

; 600  : 							sprintf (tmpStr, formatStr, a/labelMod, (a%labelMod) / 100);

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	mov	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	push	eax
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _labelMod$[ebp]
	push	eax
	mov	edx, DWORD PTR _formatStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN46@DrawAltitu:

; 601  : 						ShiAssert (strlen(tmpStr) < 12);
; 602  : 						x2 = x1 + bigTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 603  : 						if(a >= 0 && (y1 - boxY > tickInc || y1 - boxY < (-tickInc * 3.0F)))

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN45@DrawAltitu
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	comiss	xmm0, DWORD PTR _tickInc$[ebp]
	ja	SHORT $LN44@DrawAltitu
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	movss	xmm1, DWORD PTR _tickInc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR __real@40400000
	comiss	xmm1, xmm0
	jbe	SHORT $LN45@DrawAltitu
$LN44@DrawAltitu:

; 604  : 							display->TextLeftVertical(x2 + smallTickLen * 0.5F, y1 + 0.01F, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _x2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN45@DrawAltitu:

; 605  : 					}
; 606  : 					display->Line (x1, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN50@DrawAltitu:

; 607  : 				}
; 608  : 				a += tickInterval;

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, DWORD PTR _tickInterval$[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 609  : 				y1 += tickInc;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 610  : 			}

	jmp	$LN59@DrawAltitu
$LN58@DrawAltitu:

; 611  : 		}
; 612  : 		else

	jmp	$LN43@DrawAltitu
$LN72@DrawAltitu:

; 613  : 			// Auto display in low altitude mode
; 614  : 		{
; 615  : 			y1 = hudWinY[ALTITUDE_WINDOW];

	mov	edx, 4
	imul	edx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _y1$[ebp], xmm0

; 616  : 
; 617  : 			x1 = leftEdge;

	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 618  : 			tickInc *= 0.75F;

	movss	xmm0, DWORD PTR _tickInc$[ebp]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 619  : 
; 620  : 			// Label the bottom
; 621  : 			display->Line (x1, y1, x1 + bigTickLen, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 622  : 			y1 += tickInc;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 623  : 
; 624  : 			// Draw the thermometer scale
; 625  : 			for (i=1; i<NUM_VERTICAL_TICKS * 2; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN42@DrawAltitu
$LN41@DrawAltitu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN42@DrawAltitu:
	cmp	DWORD PTR _i$[ebp], 22			; 00000016H
	jge	$LN40@DrawAltitu

; 626  : 			{
; 627  : 				if (i % 2)

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN135@DrawAltitu
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN135@DrawAltitu:
	test	ecx, ecx
	je	SHORT $LN39@DrawAltitu

; 628  : 					x2 = x1 + smallTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 629  : 				else

	jmp	$LN37@DrawAltitu
$LN39@DrawAltitu:

; 630  : 				{
; 631  : 					x2 = x1 + bigTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 632  : 					if (i % 4 == 0)

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN136@DrawAltitu
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN136@DrawAltitu:
	test	edx, edx
	jne	SHORT $LN37@DrawAltitu

; 633  : 					{
; 634  : 						sprintf (tmpStr, "%d", i / 2);

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 635  : 						ShiAssert (strlen(tmpStr) < 12);
; 636  : 						display->TextLeftVertical(x2 + smallTickLen * 0.5F, y1 + 0.01F, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _x2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN37@DrawAltitu:

; 637  : 					}
; 638  : 				}
; 639  : 				display->Line (x1, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 640  : 
; 641  : 				y1 += tickInc;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 642  : 			}

	jmp	$LN41@DrawAltitu
$LN40@DrawAltitu:

; 643  : 			x2 = x1 + bigTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 644  : 			display->Line (x1, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 645  : 			display->TextLeft(x2 + smallTickLen * 0.5F, y1 + 0.01F, "15");

	push	0
	push	OFFSET ??_C@_02IHCGGLPM@15?$AA@
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _x2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 646  : 
; 647  : 			// Add the current altitude
; 648  : 			x1 *= 0.95F;

	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR _x1$[ebp], xmm0

; 649  : 			y1 = hudWinY[ALTITUDE_WINDOW];

	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	movss	DWORD PTR _y1$[ebp], xmm0

; 650  : 			if (-theAlt < 1000.0F)

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR __real@447a0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN36@DrawAltitu

; 651  : 			{
; 652  : 				y2 = -theAlt / 1000.0F * (NUM_VERTICAL_TICKS * 2 - 2) * tickInc;

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@41a00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 653  : 			}
; 654  : 			else

	jmp	SHORT $LN35@DrawAltitu
$LN36@DrawAltitu:

; 655  : 			{
; 656  : 				y2 = (NUM_VERTICAL_TICKS * 2 - 2) * tickInc + (-theAlt - 1000.0F) / 500.0F * 2 * tickInc;

	movss	xmm0, DWORD PTR __real@41a00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	xmm1, DWORD PTR _theAlt$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm1, DWORD PTR __real@447a0000
	divss	xmm1, DWORD PTR __real@43fa0000
	mulss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _tickInc$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _y2$[ebp], xmm0
$LN35@DrawAltitu:

; 657  : 			}
; 658  : 			display->Line (x1, y1, x1 - smallTickLen, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 659  : 			display->Line (x1 - smallTickLen, y1, x1 - smallTickLen, y1 + y2);

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 660  : 			display->Line (x1, y1 + y2, x1 - smallTickLen, y1 + y2);

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 661  : 
; 662  : 			// Add the current alow setting
; 663  : 			if (lowAltWarning < 1000.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@447a0000
	comiss	xmm0, DWORD PTR [ecx+4960]
	jbe	SHORT $LN34@DrawAltitu

; 664  : 			{
; 665  : 				y2 = lowAltWarning / 1000.0F * (NUM_VERTICAL_TICKS * 2 - 2) * tickInc;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4960]
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@41a00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 666  : 			}
; 667  : 			else

	jmp	SHORT $LN33@DrawAltitu
$LN34@DrawAltitu:

; 668  : 			{
; 669  : 				y2 = (NUM_VERTICAL_TICKS * 2 - 2) * tickInc + (lowAltWarning - 1000.0F) / 500.0F * 2 * tickInc;

	movss	xmm0, DWORD PTR __real@41a00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4960]
	subss	xmm1, DWORD PTR __real@447a0000
	divss	xmm1, DWORD PTR __real@43fa0000
	mulss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _tickInc$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _y2$[ebp], xmm0
$LN33@DrawAltitu:

; 670  : 			}
; 671  : 			display->Line (x1 - bigTickLen, y1 + y2, x1 - smallTickLen, y1 + y2);

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 672  : 			display->Line (x1 - bigTickLen, y1 + y2 - smallTickLen, x1 - bigTickLen, y1 + y2 + smallTickLen);

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN43@DrawAltitu:

; 673  : 		}
; 674  : 
; 675  : 		// Add Vertical Velocity if needed
; 676  : 		if (FCC->GetMasterMode() == FireControlComputer::Nav && scalesSwitch == VV_VAH)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 4
	jne	$LN32@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 0
	jne	$LN32@DrawAltitu

; 677  : 		{
; 678  : 			tickInc = hudWinHeight[ALTITUDE_WINDOW] / 9;

	mov	eax, 4
	imul	eax, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	divss	xmm0, DWORD PTR __real@41100000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 679  : 			leftEdge -= 2.0F * bigTickLen;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	xmm1, DWORD PTR _leftEdge$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _leftEdge$[ebp], xmm1

; 680  : 			y1 = winCenter - 6.0F * tickInc;

	movss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	xmm1, DWORD PTR _winCenter$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _y1$[ebp], xmm1

; 681  : 			x1 = leftEdge + bigTickLen;

	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 682  : 			x2 = leftEdge + smallTickLen;

	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 683  : 
; 684  : 			// Add Scale
; 685  : 			for (i=0; i<14; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@DrawAltitu
$LN30@DrawAltitu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN31@DrawAltitu:
	cmp	DWORD PTR _i$[ebp], 14			; 0000000eH
	jge	$LN29@DrawAltitu

; 686  : 			{
; 687  : 				if (i % 2 == 1)

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN137@DrawAltitu
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN137@DrawAltitu:
	cmp	edx, 1
	jne	SHORT $LN28@DrawAltitu

; 688  : 					display->Line (leftEdge, y1, x1, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 689  : 				else

	jmp	SHORT $LN27@DrawAltitu
$LN28@DrawAltitu:

; 690  : 					display->Line (leftEdge, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN27@DrawAltitu:

; 691  : 
; 692  : 				y1 += tickInc;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 693  : 			}

	jmp	$LN30@DrawAltitu
$LN29@DrawAltitu:

; 694  : 
; 695  : 			// Add marker NOTE: ZDelta is Ft/Sec
; 696  : 			y1 = (-cockpitFlightData.zDot * MIN_TO_SEC) / 500.0F * tickInc;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42700000
	divss	xmm0, DWORD PTR __real@43fa0000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 697  : 			y1 = min ( max (y1, -6.0F * tickInc), 6.0F * tickInc);

	movss	xmm0, DWORD PTR __real@c0c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN129@DrawAltitu
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv958[ebp], xmm0
	jmp	SHORT $LN130@DrawAltitu
$LN129@DrawAltitu:
	movss	xmm0, DWORD PTR __real@c0c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR tv958[ebp], xmm0
$LN130@DrawAltitu:
	movss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	comiss	xmm0, DWORD PTR tv958[ebp]
	jbe	SHORT $LN133@DrawAltitu
	movss	xmm0, DWORD PTR __real@c0c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN131@DrawAltitu
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv967[ebp], xmm0
	jmp	SHORT $LN132@DrawAltitu
$LN131@DrawAltitu:
	movss	xmm0, DWORD PTR __real@c0c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR tv967[ebp], xmm0
$LN132@DrawAltitu:
	movss	xmm0, DWORD PTR tv967[ebp]
	movss	DWORD PTR tv970[ebp], xmm0
	jmp	SHORT $LN134@DrawAltitu
$LN133@DrawAltitu:
	movss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR tv970[ebp], xmm0
$LN134@DrawAltitu:
	movss	xmm0, DWORD PTR tv970[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 698  : 			y1 += winCenter;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 699  : 			display->Line (leftEdge, y1, leftEdge - smallTickLen, y1 + smallTickLen);

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 700  : 			display->Line (leftEdge, y1, leftEdge - smallTickLen, y1 - smallTickLen);

	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 701  : 			display->Line (leftEdge - smallTickLen, y1 + smallTickLen, leftEdge - smallTickLen, y1 - smallTickLen);

	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN32@DrawAltitu:

; 702  : 
; 703  : 		}
; 704  : 	}
; 705  : 	else	//Scales OFF

	jmp	$LN26@DrawAltitu
$LN101@DrawAltitu:

; 706  : 	{
; 707  : 
; 708  : 		// Choose the right scale
; 709  : 		if (radarSwitch == BARO)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4880], 1
	jne	SHORT $LN25@DrawAltitu

; 710  : 		{
; 711  : 			theAlt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
	jmp	$LN7@DrawAltitu
$LN25@DrawAltitu:

; 712  : 		}
; 713  : 		else if (radarSwitch == ALT_RADAR)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4880], 0
	jne	$LN23@DrawAltitu

; 714  : 		{
; 715  : 			//MI for CARA switch
; 716  : 			if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN22@DrawAltitu

; 717  : 			{
; 718  : 				if(((AircraftClass*)ownship)->af->platform->IsPlayer() &&
; 719  : 						((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN21@DrawAltitu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN21@DrawAltitu

; 720  : 				{
; 721  : 					if(FindRollAngle(-hat) && FindPitchAngle(-hat))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	SHORT $LN20@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	SHORT $LN20@DrawAltitu

; 722  : 					{
; 723  : 						//CARA is ready and we're within limits
; 724  : 						DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 725  : 						theAlt = -hat;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0

; 726  : 					}
; 727  : 					else

	jmp	SHORT $LN19@DrawAltitu
$LN20@DrawAltitu:

; 728  : 						theAlt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN19@DrawAltitu:

; 729  : 				}
; 730  : 				else

	jmp	SHORT $LN18@DrawAltitu
$LN21@DrawAltitu:

; 731  : 				{
; 732  : 					//CARA is not yet ready
; 733  : 					theAlt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN18@DrawAltitu:

; 734  : 				}
; 735  : 			}
; 736  : 			else

	jmp	SHORT $LN17@DrawAltitu
$LN22@DrawAltitu:

; 737  : 			{
; 738  : 				DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 739  : 				theAlt = -hat;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN17@DrawAltitu:

; 740  : 			}
; 741  : 		}
; 742  : 		else

	jmp	$LN7@DrawAltitu
$LN23@DrawAltitu:

; 743  : 		{
; 744  : 			if (hat > -1200.0F || (cockpitFlightData.zDot < 0.0F && hat > -1500.0F))

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	comiss	xmm0, DWORD PTR __real@c4960000
	ja	SHORT $LN14@DrawAltitu
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	jbe	$LN15@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	comiss	xmm0, DWORD PTR __real@c4bb8000
	jbe	$LN15@DrawAltitu
$LN14@DrawAltitu:

; 745  : 			{
; 746  : 				//MI for CARA switch
; 747  : 				if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN13@DrawAltitu

; 748  : 				{
; 749  : 					if(((AircraftClass*)ownship)->af->platform->IsPlayer() &&
; 750  : 							((AircraftClass*)ownship)->af->platform->RaltReady())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN12@DrawAltitu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?RaltReady@AircraftClass@@QAEHXZ	; AircraftClass::RaltReady
	test	eax, eax
	je	$LN12@DrawAltitu

; 751  : 					{
; 752  : 						if(FindRollAngle(-hat) && FindPitchAngle(-hat))

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindRollAngle@HudClass@@QAEHM@Z	; HudClass::FindRollAngle
	test	eax, eax
	je	SHORT $LN11@DrawAltitu
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindPitchAngle@HudClass@@QAEHM@Z	; HudClass::FindPitchAngle
	test	eax, eax
	je	SHORT $LN11@DrawAltitu

; 753  : 						{ 
; 754  : 							//CARA is ready and we're within limits
; 755  : 							DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 756  : 							theAlt = -hat;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0

; 757  : 						} 
; 758  : 						else

	jmp	SHORT $LN10@DrawAltitu
$LN11@DrawAltitu:

; 759  : 							theAlt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN10@DrawAltitu:

; 760  : 					}
; 761  : 					else

	jmp	SHORT $LN9@DrawAltitu
$LN12@DrawAltitu:

; 762  : 					{
; 763  : 						//CARA is not yet ready
; 764  : 						theAlt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN9@DrawAltitu:

; 765  : 					}
; 766  : 
; 767  : 				}
; 768  : 				else

	jmp	SHORT $LN8@DrawAltitu
$LN13@DrawAltitu:

; 769  : 				{
; 770  : 					DrawWindowString(6, "R");

	push	0
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 771  : 					theAlt = -hat;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+5080]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN8@DrawAltitu:

; 772  : 				}
; 773  : 			}
; 774  : 			else

	jmp	SHORT $LN7@DrawAltitu
$LN15@DrawAltitu:

; 775  : 			{
; 776  : 				theAlt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN7@DrawAltitu:

; 777  : 			}
; 778  : 		}
; 779  : 		//Cobra Add in the delay
; 780  : 		if ((unsigned long)hudAltDelayTimer < SimLibElapsedTime)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5156]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN6@DrawAltitu

; 781  : 		{
; 782  : 			altHudn=theAlt;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	movss	DWORD PTR [ecx+5172], xmm0

; 783  : 			altHud = -theAlt;//seed the other while in this loop

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+5168], xmm0

; 784  : 			hudAltDelayTimer = SimLibElapsedTime + 250;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 250				; 000000faH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5156], eax
$LN6@DrawAltitu:

; 785  : 		}
; 786  : 
; 787  : 		if (theAlt > 0.0F)

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN5@DrawAltitu

; 788  : 		{
; 789  : 			//MI
; 790  : 			if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN4@DrawAltitu

; 791  : 			{
; 792  : 				//only show 10's of feet
; 793  : 				theAlt = ((static_cast<int>(altHudn) + 5) / 10) * 10.0f;

	mov	eax, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [eax+5172]
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN4@DrawAltitu:

; 794  : 			}
; 795  : 			sprintf (tmpStr, "%2d,%03d", FloatToInt32(theAlt * 0.001F),
; 796  : 					FloatToInt32(theAlt - FloatToInt32(theAlt * 0.001F) * 1000.0F));

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	xmm1, DWORD PTR _theAlt$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_08MHFJHILJ@?$CF2d?0?$CF03d?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 797  : 		}
; 798  : 		else

	jmp	$LN3@DrawAltitu
$LN5@DrawAltitu:

; 799  : 		{
; 800  : 			//MI
; 801  : 			if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN2@DrawAltitu

; 802  : 			{
; 803  : 				//only show 10's of feet
; 804  : 				theAlt = ((static_cast<int>(altHudn) + 5) / 10) * 10.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [ecx+5172]
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _theAlt$[ebp], xmm0
$LN2@DrawAltitu:

; 805  : 			}
; 806  : 			sprintf (tmpStr, "-%2d,%03d", abs(FloatToInt32(theAlt * 0.001F)),
; 807  : 					abs(FloatToInt32(theAlt - FloatToInt32(theAlt * 0.001F) * 1000.0F)));

	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	xmm1, DWORD PTR _theAlt$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	call	_abs
	add	esp, 4
	push	eax
	movss	xmm0, DWORD PTR _theAlt$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_09HIHJIMAB@?9?$CF2d?0?$CF03d?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN3@DrawAltitu:

; 808  : 		}
; 809  : 		ShiAssert (strlen(tmpStr) < 12);
; 810  : 		//MI
; 811  : 		//ATARIBABY fix for missaligned alt readout in 3d padlock
; 812  : 		//if(!g_bRealisticAvionics || OTWDriver.GetOTWDisplayMode() == OTWDriverClass::Mode3DCockpit)
; 813  : 		// sfr: caused hud missalignment
; 814  : #if 0
; 815  : 		if(!g_bRealisticAvionics || OTWDriver.GetOTWDisplayMode() == OTWDriverClass::Mode3DCockpit || OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModePadlockF3)
; 816  : 			display->TextRight (hudWinX[ALTITUDE_WINDOW] + 0.01F + hudWinWidth[ALTITUDE_WINDOW],
; 817  : 					boxY, tmpStr, 4);
; 818  : 		else
; 819  : 			display->TextRight (hudWinX[ALTITUDE_WINDOW] + 0.17F + hudWinWidth[ALTITUDE_WINDOW],
; 820  : 					boxY, tmpStr, 4);
; 821  : #endif
; 822  : 		// sfr: changed .17 to .20
; 823  : 		display->TextRight(hudWinX[ALTITUDE_WINDOW] + hudWinWidth[ALTITUDE_WINDOW] + 0.22F, boxY, tmpStr, 4);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _boxY$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	mov	edx, 4
	imul	edx, 39					; 00000027H
	movss	xmm0, DWORD PTR ?hudWinX@@3PAMA[ecx]
	addss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	addss	xmm0, DWORD PTR __real@3e6147ae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+60]
	call	edx
$LN26@DrawAltitu:

; 824  : 
; 825  : 	}
; 826  : 	//MI MSL Floor Check
; 827  : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawAltitu

; 828  : 	{
; 829  : 		CheckMSLFloor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckMSLFloor@HudClass@@QAEXXZ		; HudClass::CheckMSLFloor
$LN1@DrawAltitu:
$LN127@DrawAltitu:

; 830  : 	}
; 831  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAltitude@HudClass@@AAEXXZ ENDP			; HudClass::DrawAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\navhud.cpp
_TEXT	SEGMENT
_origfont$ = -136					; size = 4
tv677 = -132						; size = 4
_leftEdge$ = -128					; size = 4
_temp$ = -124						; size = 4
tv647 = -120						; size = 4
tv446 = -116						; size = 4
tv192 = -112						; size = 4
tv426 = -108						; size = 4
tv450 = -104						; size = 4
tv333 = -100						; size = 4
tv514 = -96						; size = 4
tv376 = -92						; size = 4
tv522 = -88						; size = 4
$T1 = -84						; size = 4
tv521 = -80						; size = 4
tv197 = -76						; size = 4
tv144 = -72						; size = 4
_delta$ = -68						; size = 4
_i$ = -64						; size = 4
_winCenter$ = -60					; size = 4
_x2$ = -56						; size = 4
_tickInc$ = -52						; size = 4
_boxY$ = -48						; size = 4
_bigTickLen$ = -44					; size = 4
_rightEdge$ = -40					; size = 4
_x1$ = -36						; size = 4
_smallTickLen$ = -32					; size = 4
_a$ = -28						; size = 4
_y1$ = -24						; size = 4
_this$ = -20						; size = 4
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?DrawAirspeed@HudClass@@AAEXXZ PROC			; HudClass::DrawAirspeed
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 	char tmpStr[12]={0};

	mov	BYTE PTR _tmpStr$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _tmpStr$[ebp+1], eax
	mov	DWORD PTR _tmpStr$[ebp+5], eax
	mov	WORD PTR _tmpStr$[ebp+9], ax
	mov	BYTE PTR _tmpStr$[ebp+11], al

; 46   : 	float rightEdge=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rightEdge$[ebp], xmm0

; 47   : 	float leftEdge = 0.0F;	//MI

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _leftEdge$[ebp], xmm0

; 48   : 	float bigTickLen=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 49   : 	float smallTickLen=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 50   : 	float tickInc=0.0F, delta=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tickInc$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delta$[ebp], xmm0

; 51   : 	float x1=0.0F, x2=0.0F, y1=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y1$[ebp], xmm0

; 52   : 	float winCenter = hudWinY[AIRSPEED_WINDOW] + hudWinHeight[AIRSPEED_WINDOW] * 0.5F;

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	movss	DWORD PTR _winCenter$[ebp], xmm0

; 53   : 	float boxY = winCenter + display->TextHeight() * 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+88]
	call	edx
	fstp	DWORD PTR tv647[ebp]
	movss	xmm0, DWORD PTR tv647[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR _boxY$[ebp], xmm0

; 54   : 	int i=0, a=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _a$[ebp], 0

; 55   : 	int origfont = 0;//TJL 03/07/04

	mov	DWORD PTR _origfont$[ebp], 0

; 56   : 
; 57   : 	if(!ownship) {	// VWF added 10/20/98 to avoid crash

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN50@DrawAirspe

; 58   : 		return;

	jmp	$LN51@DrawAirspe
$LN50@DrawAirspe:

; 59   : 	}
; 60   : 
; 61   : 	//rightEdge = hudWinX[AIRSPEED_WINDOW] + hudWinWidth[AIRSPEED_WINDOW];
; 62   : 	rightEdge = hudWinX[AIRSPEED_WINDOW] + (hudWinWidth[AIRSPEED_WINDOW] * 0.5f);

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinX@@3PAMA[ecx]
	movss	DWORD PTR _rightEdge$[ebp], xmm0

; 63   : 
; 64   : 	//MI
; 65   : 	//leftEdge = hudWinX[ALTITUDE_WINDOW] - (hudWinWidth[ALTITUDE_WINDOW] * 0.5F);
; 66   : 	leftEdge = hudWinX[AIRSPEED_WINDOW] - (hudWinWidth[AIRSPEED_WINDOW] * 0.5F);

	mov	eax, 4
	imul	eax, 38					; 00000026H
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR ?hudWinX@@3PAMA[eax]
	subss	xmm1, xmm0
	movss	DWORD PTR _leftEdge$[ebp], xmm1

; 67   : 
; 68   : 	//MI
; 69   : 	if(g_bRealisticAvionics && (((AircraftClass*)ownship)->af->gearPos > 0.5F)){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN49@DrawAirspe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN49@DrawAirspe

; 70   : 		a = FloatToInt32(cockpitFlightData.kias);

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 71   : 		DrawWindowString (2, "C");

	push	0
	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 72   : 	}
; 73   : 	else{

	jmp	$LN46@DrawAirspe
$LN49@DrawAirspe:

; 74   : 		switch (velocitySwitch)	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4876]
	mov	DWORD PTR tv144[ebp], ecx
	cmp	DWORD PTR tv144[ebp], 0
	je	SHORT $LN45@DrawAirspe
	cmp	DWORD PTR tv144[ebp], 1
	je	SHORT $LN44@DrawAirspe
	cmp	DWORD PTR tv144[ebp], 2
	je	SHORT $LN43@DrawAirspe
	jmp	$LN46@DrawAirspe
$LN45@DrawAirspe:

; 75   : 			case CAS:
; 76   : 				a = FloatToInt32(cockpitFlightData.kias);

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 77   : 				DrawWindowString (2, "C");

	push	0
	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 78   : 				break;

	jmp	$LN46@DrawAirspe
$LN44@DrawAirspe:

; 79   : 
; 80   : 			case TAS:
; 81   : 				a = FloatToInt32(cockpitFlightData.vt * FTPSEC_TO_KNOTS);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+56
	mulss	xmm0, DWORD PTR __real@3f17ac60
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 82   : 				DrawWindowString (2, "T");

	push	0
	push	OFFSET ??_C@_01GAPBHFFA@T?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 83   : 				break;

	jmp	SHORT $LN46@DrawAirspe
$LN43@DrawAirspe:

; 84   : 
; 85   : 			case GND_SPD:
; 86   : 				a = FloatToInt32((float)sqrt(cockpitFlightData.xDot*cockpitFlightData.xDot +
; 87   : 							cockpitFlightData.yDot*cockpitFlightData.yDot) * FTPSEC_TO_KNOTS);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+12
	mulss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+12
	movss	xmm1, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+16
	mulss	xmm1, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+16
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv677[ebp]
	movss	xmm0, DWORD PTR tv677[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 88   : 				DrawWindowString (2, "G");

	push	0
	push	OFFSET ??_C@_01BBODEMC@G?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN46@DrawAirspe:

; 89   : 				break;
; 90   : 		}
; 91   : 	}
; 92   : 
; 93   : 	//Cobra let's add a slight delay
; 94   : 	int temp = FloatToInt32(cockpitFlightData.kias);

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _temp$[ebp], eax

; 95   : 	if ((unsigned long)hudDelayTimer < SimLibElapsedTime)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5152]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN42@DrawAirspe

; 96   : 	{
; 97   : 		aspeedHud=a;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+5164], edx

; 98   : 		hudDelayTimer = SimLibElapsedTime + 250;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 250				; 000000faH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5152], eax
$LN42@DrawAirspe:

; 99   : 	}
; 100  : 
; 101  : 	// M.N. added full realism mode
; 102  : 	if ((PlayerOptions.GetAvionicsType() == ATRealistic) || (PlayerOptions.GetAvionicsType() == ATRealisticAV)){

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	je	SHORT $LN40@DrawAirspe
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 3
	jne	SHORT $LN38@DrawAirspe
$LN40@DrawAirspe:

; 103  : 		if (temp < 60){

	cmp	DWORD PTR _temp$[ebp], 60		; 0000003cH
	jge	SHORT $LN39@DrawAirspe

; 104  : 			aspeedHud = 0;//Cobra

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5164], 0

; 105  : 			a = 0;

	mov	DWORD PTR _a$[ebp], 0

; 106  : 		}
; 107  : 		else {

	jmp	SHORT $LN38@DrawAirspe
$LN39@DrawAirspe:

; 108  : 			aspeedHud = max(aspeedHud, 60);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5164], 60		; 0000003cH
	jle	SHORT $LN53@DrawAirspe
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5164]
	mov	DWORD PTR tv192[ebp], edx
	jmp	SHORT $LN54@DrawAirspe
$LN53@DrawAirspe:
	mov	DWORD PTR tv192[ebp], 60		; 0000003cH
$LN54@DrawAirspe:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR [eax+5164], ecx
$LN38@DrawAirspe:

; 109  : 		}
; 110  : 	}
; 111  : 	sprintf (tmpStr, "%4d", min(aspeedHud, 9999));

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+5164], 9999		; 0000270fH
	jge	SHORT $LN55@DrawAirspe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5164]
	mov	DWORD PTR tv197[ebp], ecx
	jmp	SHORT $LN56@DrawAirspe
$LN55@DrawAirspe:
	mov	DWORD PTR tv197[ebp], 9999		; 0000270fH
$LN56@DrawAirspe:
	mov	edx, DWORD PTR tv197[ebp]
	push	edx
	push	OFFSET ??_C@_03GLKEJMAA@?$CF4d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 112  : 
; 113  : 
; 114  : 	//MI hack to make the new code working when below 100 kts :-(
; 115  : 	if(aspeedHud < 100)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+5164], 100		; 00000064H
	jge	SHORT $LN37@DrawAirspe

; 116  : 	{
; 117  : 		sprintf (tmpStr, " %03d", aspeedHud);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5164]
	push	eax
	push	OFFSET ??_C@_05JHCHPGNF@?5?$CF03d?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 118  : 		tmpStr[4] = '\0';

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 12			; 0000000cH
	jae	SHORT $LN57@DrawAirspe
	jmp	SHORT $LN58@DrawAirspe
$LN57@DrawAirspe:
	call	___report_rangecheckfailure
$LN58@DrawAirspe:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _tmpStr$[ebp+eax], 0
$LN37@DrawAirspe:

; 119  : 	}
; 120  : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 121  : 
; 122  : 	//TJL 03/07/04 Removing ticks from everything but F-16 or default HUD
; 123  : 	//if ((scalesSwitch == VAH || scalesSwitch == VV_VAH) && (FCC->GetMasterMode() != FireControlComputer::Dogfight))//me123 status test.
; 124  : 	if (
; 125  : 		(ownship->IsF16() || (ownship->af->GetTypeAC() == 0)) && 
; 126  : 		((scalesSwitch == VAH) || (scalesSwitch == VV_VAH)) && 
; 127  : 		(FCC->GetMasterMode() != FireControlComputer::Dogfight))//me123 status test.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN35@DrawAirspe
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN36@DrawAirspe
$LN35@DrawAirspe:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4864], 1
	je	SHORT $LN34@DrawAirspe
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 0
	jne	$LN36@DrawAirspe
$LN34@DrawAirspe:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	$LN36@DrawAirspe

; 128  : 	{  
; 129  : 		//MI
; 130  : 		if(!g_bRealisticAvionics){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN33@DrawAirspe

; 131  : 			if (scalesSwitch == VAH){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4864], 1
	jne	SHORT $LN32@DrawAirspe

; 132  : 				boxY = 2.0F;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _boxY$[ebp], xmm0

; 133  : 			}
; 134  : 			else{

	jmp	SHORT $LN31@DrawAirspe
$LN32@DrawAirspe:

; 135  : 				display->TextRight(rightEdge - 0.03F, boxY, tmpStr, 8);

	push	8
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _boxY$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax
$LN31@DrawAirspe:

; 136  : 			}
; 137  : 			bigTickLen = hudWinWidth[AIRSPEED_WINDOW] * 0.5F;

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 138  : 			smallTickLen = bigTickLen * 0.5F;

	movss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 139  : 			tickInc = hudWinHeight[AIRSPEED_WINDOW] / (float)(NUM_VERTICAL_TICKS - 1);

	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 140  : 			display->Line(rightEdge * 0.95F, winCenter, rightEdge * 0.95F + bigTickLen, winCenter);

	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 141  : 		}
; 142  : 		else {

	jmp	$LN30@DrawAirspe
$LN33@DrawAirspe:

; 143  : 			// this is the line which draws the airspeed box
; 144  : 			display->TextRight(rightEdge - 0.06F, boxY, tmpStr, 8);

	push	8
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _boxY$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	subss	xmm0, DWORD PTR __real@3d75c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 145  : 			bigTickLen = hudWinWidth[AIRSPEED_WINDOW] * 0.2F;

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _bigTickLen$[ebp], xmm0

; 146  : 			smallTickLen = bigTickLen * 0.6F;

	movss	xmm0, DWORD PTR _bigTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR _smallTickLen$[ebp], xmm0

; 147  : 			tickInc = hudWinHeight[AIRSPEED_WINDOW] / (float)(NUM_VERTICAL_TICKS - 1);

	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _tickInc$[ebp], xmm0

; 148  : 			display->Line(rightEdge * 0.95F, winCenter, rightEdge * 0.95F + hudWinWidth[AIRSPEED_WINDOW] * 0.5F, winCenter);

	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm1, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _winCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN30@DrawAirspe:

; 149  : 		}
; 150  : 		x1 = rightEdge;

	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 151  : 		y1 = hudWinY[AIRSPEED_WINDOW] - (a%10) * tickInc * 0.1F;

	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	esi, 10					; 0000000aH
	idiv	esi
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	xmm1, DWORD PTR ?hudWinY@@3PAMA[ecx]
	subss	xmm1, xmm0
	movss	DWORD PTR _y1$[ebp], xmm1

; 152  : 		a = a/10 - 5;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	sub	eax, 5
	mov	DWORD PTR _a$[ebp], eax

; 153  : 
; 154  : 		for (i=0; i<NUM_VERTICAL_TICKS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN29@DrawAirspe
$LN28@DrawAirspe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN29@DrawAirspe:
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jge	$LN27@DrawAirspe

; 155  : 		{
; 156  : 			//MI don't draw into the text!
; 157  : 			/*if (a >= 0 &&
; 158  : 			  (y1 - boxY > display->TextHeight() * 1.1F ||
; 159  : 			  y1 - boxY < -tickInc))*/
; 160  : 			if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN26@DrawAirspe

; 161  : 			{
; 162  : 				if((a >= 0) && ((y1 - boxY > tickInc) || (y1 - boxY < (-tickInc * 3.0F))))

	cmp	DWORD PTR _a$[ebp], 0
	jl	$LN25@DrawAirspe
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	comiss	xmm0, DWORD PTR _tickInc$[ebp]
	ja	SHORT $LN24@DrawAirspe
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	movss	xmm1, DWORD PTR _tickInc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR __real@40400000
	comiss	xmm1, xmm0
	jbe	$LN25@DrawAirspe
$LN24@DrawAirspe:

; 163  : 				{
; 164  : 					if (a % 5){

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	test	edx, edx
	je	SHORT $LN23@DrawAirspe

; 165  : 						x2 = x1 - smallTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 166  : 					}
; 167  : 					else {

	jmp	SHORT $LN22@DrawAirspe
$LN23@DrawAirspe:

; 168  : 						x2 = x1 - bigTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 169  : 						display->TextRightVertical(x2 - smallTickLen * 0.5F, y1 + 0.01F, hudNumbers[min (a, 99)]);

	cmp	DWORD PTR _a$[ebp], 99			; 00000063H
	jge	SHORT $LN59@DrawAirspe
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv333[ebp], edx
	jmp	SHORT $LN60@DrawAirspe
$LN59@DrawAirspe:
	mov	DWORD PTR tv333[ebp], 99		; 00000063H
$LN60@DrawAirspe:
	push	0
	mov	eax, DWORD PTR tv333[ebp]
	mov	ecx, DWORD PTR ?hudNumbers@@3PAPADA[eax*4]
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _x2$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+68]
	call	eax
$LN22@DrawAirspe:

; 170  : 					}
; 171  : 					display->Line (x1, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN25@DrawAirspe:

; 172  : 				}
; 173  : 			}
; 174  : 			else

	jmp	$LN21@DrawAirspe
$LN26@DrawAirspe:

; 175  : 			{
; 176  : 				if (a % 5){

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	test	edx, edx
	je	SHORT $LN20@DrawAirspe

; 177  : 					x2 = x1 - smallTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 178  : 				}
; 179  : 				else{

	jmp	SHORT $LN19@DrawAirspe
$LN20@DrawAirspe:

; 180  : 					x2 = x1 - bigTickLen;

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _bigTickLen$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN19@DrawAirspe:

; 181  : 				}
; 182  : 				if(!(a % 5)){

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	test	edx, edx
	jne	$LN17@DrawAirspe

; 183  : 					if(a >= 0 && (y1 - boxY > tickInc || y1 - boxY < (-tickInc * 3.0F))){

	cmp	DWORD PTR _a$[ebp], 0
	jl	$LN17@DrawAirspe
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	comiss	xmm0, DWORD PTR _tickInc$[ebp]
	ja	SHORT $LN16@DrawAirspe
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _boxY$[ebp]
	movss	xmm1, DWORD PTR _tickInc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR __real@40400000
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@DrawAirspe
$LN16@DrawAirspe:

; 184  : 						display->TextRightVertical(x2 - smallTickLen * 0.5F, y1 + 0.01F, hudNumbers[min (a, 99)]);			  

	cmp	DWORD PTR _a$[ebp], 99			; 00000063H
	jge	SHORT $LN61@DrawAirspe
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv376[ebp], edx
	jmp	SHORT $LN62@DrawAirspe
$LN61@DrawAirspe:
	mov	DWORD PTR tv376[ebp], 99		; 00000063H
$LN62@DrawAirspe:
	push	0
	mov	eax, DWORD PTR tv376[ebp]
	mov	ecx, DWORD PTR ?hudNumbers@@3PAPADA[eax*4]
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _x2$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+68]
	call	eax
$LN17@DrawAirspe:

; 185  : 					}
; 186  : 				}
; 187  : 				display->Line (x1, y1, x2, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN21@DrawAirspe:

; 188  : 			}                    
; 189  : 			a++;

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 1
	mov	DWORD PTR _a$[ebp], ecx

; 190  : 			y1 += tickInc;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _tickInc$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 191  : 		}

	jmp	$LN28@DrawAirspe
$LN27@DrawAirspe:

; 192  : 
; 193  : 		// Draw Desired speed caret
; 194  : 		{
; 195  : 			//MI we don't get this with gear down
; 196  : 			if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	$LN15@DrawAirspe

; 197  : 			{
; 198  : 				y1 = hudWinY[AIRSPEED_WINDOW] + hudWinHeight[AIRSPEED_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 38					; 00000026H
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR _y1$[ebp], xmm0

; 199  : 				x1 = rightEdge;

	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 200  : 
; 201  : 				delta = waypointSpeed - (cockpitFlightData.kias);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4928]
	subss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR _delta$[ebp], xmm0

; 202  : 				delta *= 0.1F;

	movss	xmm0, DWORD PTR _delta$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _delta$[ebp], xmm0

; 203  : 				y1 += delta * tickInc;

	movss	xmm0, DWORD PTR _delta$[ebp]
	mulss	xmm0, DWORD PTR _tickInc$[ebp]
	addss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 204  : 				y1 = max ( min ( y1, hudWinY[AIRSPEED_WINDOW] + hudWinHeight[AIRSPEED_WINDOW] - smallTickLen),
; 205  : 						hudWinY[AIRSPEED_WINDOW]);

	mov	eax, 4
	imul	eax, 38					; 00000026H
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN63@DrawAirspe
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv426[ebp], xmm0
	jmp	SHORT $LN64@DrawAirspe
$LN63@DrawAirspe:
	mov	edx, 4
	imul	edx, 38					; 00000026H
	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR tv426[ebp], xmm0
$LN64@DrawAirspe:
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	movss	xmm0, DWORD PTR tv426[ebp]
	comiss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	jbe	SHORT $LN67@DrawAirspe
	mov	edx, 4
	imul	edx, 38					; 00000026H
	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN65@DrawAirspe
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR tv446[ebp], xmm0
	jmp	SHORT $LN66@DrawAirspe
$LN65@DrawAirspe:
	mov	ecx, 4
	imul	ecx, 38					; 00000026H
	mov	edx, 4
	imul	edx, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	addss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	subss	xmm0, DWORD PTR _smallTickLen$[ebp]
	movss	DWORD PTR tv446[ebp], xmm0
$LN66@DrawAirspe:
	movss	xmm0, DWORD PTR tv446[ebp]
	movss	DWORD PTR tv450[ebp], xmm0
	jmp	SHORT $LN68@DrawAirspe
$LN67@DrawAirspe:
	mov	eax, 4
	imul	eax, 38					; 00000026H
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	movss	DWORD PTR tv450[ebp], xmm0
$LN68@DrawAirspe:
	movss	xmm0, DWORD PTR tv450[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 206  : 				display->Line (x1, y1, x1 + bigTickLen, y1 + (smallTickLen * 0.5F));

	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 207  : 				display->Line (x1, y1, x1 + bigTickLen, y1 - (smallTickLen * 0.5F));

	movss	xmm0, DWORD PTR _smallTickLen$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _bigTickLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 208  : 			}
; 209  : 			else {

	jmp	SHORT $LN12@DrawAirspe
$LN15@DrawAirspe:

; 210  : 				if(((AircraftClass*)ownship)->af->gearPos < 0.5F) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [eax+1552]
	jbe	SHORT $LN12@DrawAirspe

; 211  : 					// sfr: changed order here (no semantic change, was if else if)
; 212  : 					//CruiseTOS in all modes, others only in NAV
; 213  : 					if (
; 214  : 						(FCC->GetMasterMode() == FireControlComputer::Nav) ||
; 215  : 						(OTWDriver.pCockpitManager->mpIcp->GetCruiseIndex() == 0)
; 216  : 					){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 4
	je	SHORT $LN11@DrawAirspe
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?GetCruiseIndex@ICPClass@@QAEHXZ	; ICPClass::GetCruiseIndex
	test	eax, eax
	jne	SHORT $LN12@DrawAirspe
$LN11@DrawAirspe:

; 217  : 						DrawCruiseIndexes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCruiseIndexes@HudClass@@QAEXXZ	; HudClass::DrawCruiseIndexes
$LN12@DrawAirspe:

; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  : 		}
; 222  : 	}
; 223  : 	else

	jmp	$LN1@DrawAirspe
$LN36@DrawAirspe:

; 224  : 	{
; 225  : 		//MI
; 226  : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN9@DrawAirspe

; 227  : 		{
; 228  : 			display->TextRight (rightEdge - 0.03F, boxY, tmpStr, 8);

	push	8
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _boxY$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 229  : 			//      if (FCC->GetMasterMode() == FireControlComputer::Nav)
; 230  : 			{
; 231  : 				// Desired speed to reach waypoint on time
; 232  : 				sprintf (tmpStr, "%.0f", max( min(waypointSpeed, 9999.0F), 0.0F));

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR [ecx+4928]
	jbe	SHORT $LN69@DrawAirspe
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4928]
	movss	DWORD PTR tv514[ebp], xmm0
	jmp	SHORT $LN70@DrawAirspe
$LN69@DrawAirspe:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv514[ebp], xmm0
$LN70@DrawAirspe:
	movss	xmm0, DWORD PTR tv514[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN73@DrawAirspe
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c3c00
	comiss	xmm0, DWORD PTR [eax+4928]
	jbe	SHORT $LN71@DrawAirspe
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4928]
	movss	DWORD PTR tv521[ebp], xmm0
	jmp	SHORT $LN72@DrawAirspe
$LN71@DrawAirspe:
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR tv521[ebp], xmm0
$LN72@DrawAirspe:
	movss	xmm0, DWORD PTR tv521[ebp]
	movss	DWORD PTR tv522[ebp], xmm0
	jmp	SHORT $LN74@DrawAirspe
$LN73@DrawAirspe:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv522[ebp], xmm0
$LN74@DrawAirspe:
	cvtss2sd xmm0, DWORD PTR tv522[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 233  : 				ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 234  : 				DrawWindowString (35, tmpStr);

	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	35					; 00000023H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 235  : 			}
; 236  : 		}
; 237  : 		else

	jmp	$LN1@DrawAirspe
$LN9@DrawAirspe:

; 238  : 		{
; 239  : 			//ATARIBABY to not SPD box jump if no scales or DF master mode //Cobra 11/04/04 TJL
; 240  : 			//display->TextRight (rightEdge - 0.03F, boxY, tmpStr, 8);
; 241  : 			display->TextRight (rightEdge - 0.06F, boxY, tmpStr, 8);

	push	8
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _boxY$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightEdge$[ebp]
	subss	xmm0, DWORD PTR __real@3d75c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 242  : 			if (FCC->GetMasterMode() == FireControlComputer::Nav)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 4
	jne	SHORT $LN1@DrawAirspe

; 243  : 			{
; 244  : 				// Desired speed to reach waypoint on time
; 245  : 				//sprintf (SpeedText, "%.0f", max( min(waypointSpeed, 9999.0F), 0.0F));
; 246  : 				//MI
; 247  : 				if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN6@DrawAirspe

; 248  : 				{
; 249  : 					if(((AircraftClass*)ownship)->af->gearPos < 0.5F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [edx+1552]
	jbe	SHORT $LN2@DrawAirspe

; 250  : 					{
; 251  : 						//CruiseTOS in all modes, others only in NAV
; 252  : 						if(FCC->GetMasterMode() == FireControlComputer::Nav)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 4
	jne	SHORT $LN4@DrawAirspe

; 253  : 							DrawCruiseIndexes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCruiseIndexes@HudClass@@QAEXXZ	; HudClass::DrawCruiseIndexes

; 254  : 						else

	jmp	SHORT $LN2@DrawAirspe
$LN4@DrawAirspe:

; 255  : 						{
; 256  : 							if(OTWDriver.pCockpitManager->mpIcp->GetCruiseIndex() == 0)

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?GetCruiseIndex@ICPClass@@QAEHXZ	; ICPClass::GetCruiseIndex
	test	eax, eax
	jne	SHORT $LN2@DrawAirspe

; 257  : 								DrawCruiseIndexes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCruiseIndexes@HudClass@@QAEXXZ	; HudClass::DrawCruiseIndexes
$LN2@DrawAirspe:

; 258  : 						}
; 259  : 					}
; 260  : 				}
; 261  : 				else

	jmp	SHORT $LN1@DrawAirspe
$LN6@DrawAirspe:

; 262  : 				{
; 263  : 					DrawCruiseIndexes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCruiseIndexes@HudClass@@QAEXXZ	; HudClass::DrawCruiseIndexes
$LN1@DrawAirspe:
$LN51@DrawAirspe:

; 264  : 				}
; 265  : 				ShiAssert (strlen(SpeedText) < sizeof(SpeedText));
; 266  : 				//  DrawWindowString (35, SpeedText); //JPG 29 Apr 04 - This should not be here.
; 267  : 			}
; 268  : 		}
; 269  : 	}
; 270  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAirspeed@HudClass@@AAEXXZ ENDP			; HudClass::DrawAirspeed
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
