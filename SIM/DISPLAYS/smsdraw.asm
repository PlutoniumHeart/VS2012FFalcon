; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DISPLAYS\smsdraw.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?flash@SmsDrawable@@2HA				; SmsDrawable::flash
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?InputFlash@SmsDrawable@@2HA			; SmsDrawable::InputFlash
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?isJSOW@@3_NA					; isJSOW
PUBLIC	?isJDAM@@3_NA					; isJDAM
PUBLIC	?maxripple@@3HA					; maxripple
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?flash@SmsDrawable@@2HA DD 01H DUP (?)			; SmsDrawable::flash
?InputFlash@SmsDrawable@@2HA DD 01H DUP (?)		; SmsDrawable::InputFlash
?isJSOW@@3_NA DB 01H DUP (?)				; isJSOW
	ALIGN	4

?isJDAM@@3_NA DB 01H DUP (?)				; isJDAM
	ALIGN	4

?maxripple@@3HA DD 01H DUP (?)				; maxripple
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
_DATA	SEGMENT
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_cosf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	?EntityDriver@VuEntity@@QAEPAVVuDriver@@XZ	; VuEntity::EntityDriver
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?CameraCount@VuSessionEntity@@QBEHXZ		; VuSessionEntity::CameraCount
PUBLIC	?size@?$vector@V?$VuBin@VVuEntity@@@@V?$allocator@V?$VuBin@VVuEntity@@@@@std@@@std@@QBEIXZ ; std::vector<VuBin<VuEntity>,std::allocator<VuBin<VuEntity> > >::size
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?CurrentForegroundColor@ContextMPR@@QAEHXZ	; ContextMPR::CurrentForegroundColor
PUBLIC	??0VirtualDisplay@@QAE@XZ			; VirtualDisplay::VirtualDisplay
PUBLIC	??1VirtualDisplay@@UAE@XZ			; VirtualDisplay::~VirtualDisplay
PUBLIC	?Circle@VirtualDisplay@@UAEXMMM@Z		; VirtualDisplay::Circle
PUBLIC	?Arc@VirtualDisplay@@UAEXMMMMM@Z		; VirtualDisplay::Arc
PUBLIC	?TextWidth@VirtualDisplay@@UAEMPAD@Z		; VirtualDisplay::TextWidth
PUBLIC	?TextHeight@VirtualDisplay@@UAEMXZ		; VirtualDisplay::TextHeight
PUBLIC	?CurFont@VirtualDisplay@@SAHXZ			; VirtualDisplay::CurFont
PUBLIC	?SetLineStyle@VirtualDisplay@@UAEXH@Z		; VirtualDisplay::SetLineStyle
PUBLIC	?Color@VirtualDisplay@@UAEKXZ			; VirtualDisplay::Color
PUBLIC	??_GVirtualDisplay@@UAEPAXI@Z			; VirtualDisplay::`scalar deleting destructor'
PUBLIC	??0Render2D@@QAE@XZ				; Render2D::Render2D
PUBLIC	??1Render2D@@UAE@XZ				; Render2D::~Render2D
PUBLIC	?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ	; Render2D::GetImageBuffer
PUBLIC	?ClearDraw@Render2D@@UAEXXZ			; Render2D::ClearDraw
PUBLIC	?ClearZBuffer@Render2D@@UAEXXZ			; Render2D::ClearZBuffer
PUBLIC	?Color@Render2D@@UAEKXZ				; Render2D::Color
PUBLIC	?SetColor@Render2D@@UAEXK@Z			; Render2D::SetColor
PUBLIC	?SetBackground@Render2D@@UAEXK@Z		; Render2D::SetBackground
PUBLIC	?SetLineStyle@Render2D@@UAEXH@Z			; Render2D::SetLineStyle
PUBLIC	??_GRender2D@@UAEPAXI@Z				; Render2D::`scalar deleting destructor'
PUBLIC	??0DrawableClass@@IAE@XZ			; DrawableClass::DrawableClass
PUBLIC	??1DrawableClass@@UAE@XZ			; DrawableClass::~DrawableClass
PUBLIC	?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z ; DrawableClass::Display
PUBLIC	?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z ; DrawableClass::DisplayInit
PUBLIC	?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ ; DrawableClass::GetDisplay
PUBLIC	?IsSOI@DrawableClass@@QAEHXZ			; DrawableClass::IsSOI
PUBLIC	?OnMFD@DrawableClass@@QAEHXZ			; DrawableClass::OnMFD
PUBLIC	?SetIntensity@DrawableClass@@QAEXI@Z		; DrawableClass::SetIntensity
PUBLIC	?GetIntensity@DrawableClass@@QAEIXZ		; DrawableClass::GetIntensity
PUBLIC	?PushButton@DrawableClass@@UAEXHH@Z		; DrawableClass::PushButton
PUBLIC	??_GDrawableClass@@UAEPAXI@Z			; DrawableClass::`scalar deleting destructor'
PUBLIC	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ		; MFDClass::CurMode
PUBLIC	?GetOwnShip@MFDClass@@QAEPAVAircraftClass@@XZ	; MFDClass::GetOwnShip
PUBLIC	?GetTGPWarning@MFDClass@@QAEHXZ			; MFDClass::GetTGPWarning
PUBLIC	??0MfdDrawable@@QAE@XZ				; MfdDrawable::MfdDrawable
PUBLIC	?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z	; MfdDrawable::Display
PUBLIC	??_GMfdDrawable@@UAEPAXI@Z			; MfdDrawable::`scalar deleting destructor'
PUBLIC	?GetSPType@SimBaseClass@@QBEEXZ			; SimBaseClass::GetSPType
PUBLIC	??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator!
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
PUBLIC	?SqrtF@@YAMM@Z					; SqrtF
PUBLIC	?GetFOVLevel@MissileClass@@QAEMXZ		; MissileClass::GetFOVLevel
PUBLIC	?GetEXPLevel@MissileClass@@QAEMXZ		; MissileClass::GetEXPLevel
PUBLIC	?GetTargetPosition@MissileClass@@QAEXPAM00@Z	; MissileClass::GetTargetPosition
PUBLIC	?SetXYZ@MissileDisplayClass@@QAEXMMM@Z		; MissileDisplayClass::SetXYZ
PUBLIC	?CurFOV@MaverickDisplayClass@@QAEMXZ		; MaverickDisplayClass::CurFOV
PUBLIC	?ToggleFOV@MaverickDisplayClass@@QAEXXZ		; MaverickDisplayClass::ToggleFOV
PUBLIC	?IsLocked@LaserPodClass@@QAEHXZ			; LaserPodClass::IsLocked
PUBLIC	?CurFOV@LaserPodClass@@QAEMXZ			; LaserPodClass::CurFOV
PUBLIC	?GetTargetPosition@LaserPodClass@@QAEXPAM00@Z	; LaserPodClass::GetTargetPosition
PUBLIC	?IsSetBombFlag@BombClass@@QAEHH@Z		; BombClass::IsSetBombFlag
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?IsAGMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsAGMasterMode
PUBLIC	?IsNavMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsNavMasterMode
PUBLIC	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
PUBLIC	?GetDgftGunSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetDgftGunSubMode
PUBLIC	??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z ; VuBin<MissileClass>::VuBin<MissileClass>
PUBLIC	??1?$VuBin@VMissileClass@@@@QAE@XZ		; VuBin<MissileClass>::~VuBin<MissileClass>
PUBLIC	?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ; VuBin<MissileClass>::reset
PUBLIC	?CurStationOK@SMSBaseClass@@QAEHXZ		; SMSBaseClass::CurStationOK
PUBLIC	?NumHardpoints@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumHardpoints
PUBLIC	?CurHardpoint@SMSBaseClass@@QAEHXZ		; SMSBaseClass::CurHardpoint
PUBLIC	?NumCurrentWpn@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumCurrentWpn
PUBLIC	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?ToggleMavPower@SMSBaseClass@@QAEXXZ		; SMSBaseClass::ToggleMavPower
PUBLIC	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ	; SMSBaseClass::GetHARMPowerState
PUBLIC	?GetHARMInitTimer@SMSBaseClass@@QAEMXZ		; SMSBaseClass::GetHARMInitTimer
PUBLIC	?ToggleHARMPower@SMSBaseClass@@QAEXXZ		; SMSBaseClass::ToggleHARMPower
PUBLIC	?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::GetCurrentHardpoint
PUBLIC	?AimId@SMSClass@@QAEHXZ				; SMSClass::AimId
PUBLIC	?NextAimId@SMSClass@@QAEXXZ			; SMSClass::NextAimId
PUBLIC	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ	; SMSClass::GetCoolState
PUBLIC	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z	; SMSClass::SetCoolState
PUBLIC	?NextAGBProfile@SMSClass@@QAEXXZ		; SMSClass::NextAGBProfile
PUBLIC	?GetAGBRippleCount@SMSClass@@QAEHXZ		; SMSClass::GetAGBRippleCount
PUBLIC	?GetAGBRippleInterval@SMSClass@@QAEHXZ		; SMSClass::GetAGBRippleInterval
PUBLIC	?GetAGBFuze@SMSClass@@QAEHXZ			; SMSClass::GetAGBFuze
PUBLIC	?GetAGBBurstAlt@SMSClass@@QAEHXZ		; SMSClass::GetAGBBurstAlt
PUBLIC	?GetAGBReleaseAngle@SMSClass@@QAEHXZ		; SMSClass::GetAGBReleaseAngle
PUBLIC	?GetAGBC1ArmDelay1@SMSClass@@QAEMXZ		; SMSClass::GetAGBC1ArmDelay1
PUBLIC	?GetAGBC1ArmDelay2@SMSClass@@QAEMXZ		; SMSClass::GetAGBC1ArmDelay2
PUBLIC	?GetAGBC2ArmDelay@SMSClass@@QAEMXZ		; SMSClass::GetAGBC2ArmDelay
PUBLIC	?GetAGBPair@SMSClass@@QAE_NXZ			; SMSClass::GetAGBPair
PUBLIC	?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ; SMSClass::GetAGBSubMode
PUBLIC	?SetAGBFuze@SMSClass@@QAEXH@Z			; SMSClass::SetAGBFuze
PUBLIC	?SetAGBPair@SMSClass@@QAEX_N@Z			; SMSClass::SetAGBPair
PUBLIC	??0SmsDrawable@@QAE@PAVSMSClass@@@Z		; SmsDrawable::SmsDrawable
PUBLIC	??1SmsDrawable@@UAE@XZ				; SmsDrawable::~SmsDrawable
PUBLIC	?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z ; SmsDrawable::DisplayInit
PUBLIC	?Display@SmsDrawable@@UAEXPAVVirtualDisplay@@@Z	; SmsDrawable::Display
PUBLIC	?DisplayExit@SmsDrawable@@UAEXXZ		; SmsDrawable::DisplayExit
PUBLIC	?GetDisplay@SmsDrawable@@UAEPAVVirtualDisplay@@XZ ; SmsDrawable::GetDisplay
PUBLIC	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
PUBLIC	?StepDisplayMode@SmsDrawable@@QAEXXZ		; SmsDrawable::StepDisplayMode
PUBLIC	?PushButton@SmsDrawable@@UAEXHH@Z		; SmsDrawable::PushButton
PUBLIC	?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z	; SmsDrawable::IsSet
PUBLIC	?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z	; SmsDrawable::UnsetFlag
PUBLIC	?ToggleFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ; SmsDrawable::ToggleFlag
PUBLIC	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z	; SmsDrawable::SetGroundSpotPos
PUBLIC	?UpdateGroundSpot@SmsDrawable@@QAEXXZ		; SmsDrawable::UpdateGroundSpot
PUBLIC	?HdptStationSym@SmsDrawable@@QAEDH@Z		; SmsDrawable::HdptStationSym
PUBLIC	?EmergJetDisplay@SmsDrawable@@QAEXXZ		; SmsDrawable::EmergJetDisplay
PUBLIC	?ChangeProf@SmsDrawable@@QAEXXZ			; SmsDrawable::ChangeProf
PUBLIC	?ChangeToInput@SmsDrawable@@QAEXH@Z		; SmsDrawable::ChangeToInput
PUBLIC	?SetWeapParams@SmsDrawable@@QAEXXZ		; SmsDrawable::SetWeapParams
PUBLIC	?MavSMSDisplay@SmsDrawable@@QAEXXZ		; SmsDrawable::MavSMSDisplay
PUBLIC	?MissileDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::MissileDisplay
PUBLIC	?MaverickDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::MaverickDisplay
PUBLIC	?AAMDisplay@SmsDrawable@@AAEXXZ			; SmsDrawable::AAMDisplay
PUBLIC	?HarmDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::HarmDisplay
PUBLIC	?GBUDisplay@SmsDrawable@@AAEXXZ			; SmsDrawable::GBUDisplay
PUBLIC	?CameraDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::CameraDisplay
PUBLIC	?BombDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::BombDisplay
PUBLIC	?AGMenuDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::AGMenuDisplay
PUBLIC	?DogfightDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::DogfightDisplay
PUBLIC	?SelectiveJettison@SmsDrawable@@AAEXXZ		; SmsDrawable::SelectiveJettison
PUBLIC	?ShowMissiles@SmsDrawable@@AAEXH@Z		; SmsDrawable::ShowMissiles
PUBLIC	?MissileOverrideDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::MissileOverrideDisplay
PUBLIC	?BottomRow@SmsDrawable@@AAEXXZ			; SmsDrawable::BottomRow
PUBLIC	?TopRow@SmsDrawable@@AAEXH@Z			; SmsDrawable::TopRow
PUBLIC	?SJPushButton@SmsDrawable@@AAEXHH@Z		; SmsDrawable::SJPushButton
PUBLIC	?WpnPushButton@SmsDrawable@@AAEXHH@Z		; SmsDrawable::WpnPushButton
PUBLIC	?WpnAGPushButton@SmsDrawable@@AAEXHH@Z		; SmsDrawable::WpnAGPushButton
PUBLIC	?WpnAAPushButton@SmsDrawable@@AAEXHH@Z		; SmsDrawable::WpnAAPushButton
PUBLIC	?WpnNavPushButton@SmsDrawable@@AAEXHH@Z		; SmsDrawable::WpnNavPushButton
PUBLIC	?WpnOtherPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnOtherPushButton
PUBLIC	?WpnAAMissileButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAAMissileButton
PUBLIC	?WpnAGMenu@SmsDrawable@@AAEXHH@Z		; SmsDrawable::WpnAGMenu
PUBLIC	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z	; SmsDrawable::StepSelectiveJettisonMode
PUBLIC	?JDAMDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::JDAMDisplay
PUBLIC	??_GSmsDrawable@@UAEPAXI@Z			; SmsDrawable::`scalar deleting destructor'
PUBLIC	?DisplayInCockpit@OTWDriverClass@@QAEHXZ	; OTWDriverClass::DisplayInCockpit
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	?GetMaxRippleCount@AirframeClass@@QAEHXZ	; AirframeClass::GetMaxRippleCount
PUBLIC	?GetSPType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSPType
PUBLIC	?SetScanDir@RadarDopplerClass@@QAEXM@Z		; RadarDopplerClass::SetScanDir
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_7VirtualDisplay@@6B@				; VirtualDisplay::`vftable'
PUBLIC	??_7Render2D@@6B@				; Render2D::`vftable'
PUBLIC	??_7DrawableClass@@6B@				; DrawableClass::`vftable'
PUBLIC	??_7MfdDrawable@@6B@				; MfdDrawable::`vftable'
PUBLIC	??_7SmsDrawable@@6B@				; SmsDrawable::`vftable'
PUBLIC	??_C@_03OONHJAKL@SMS?$AA@			; `string'
PUBLIC	??_C@_03MPPIHBHJ@OFF?$AA@			; `string'
PUBLIC	??_C@_03MJJMMJAE@AAM?$AA@			; `string'
PUBLIC	??_C@_03MNBBLFLG@AGM?$AA@			; `string'
PUBLIC	??_C@_03HCLOBDMK@A?9G?$AA@			; `string'
PUBLIC	??_C@_03NMPFMOLH@GUN?$AA@			; `string'
PUBLIC	??_C@_0BI@FDKECMHJ@Sms?5Weapon?5in?5Nav?5mode?6?$AA@ ; `string'
PUBLIC	??_C@_04LKKJOPPH@WARM?$AA@			; `string'
PUBLIC	??_C@_04MCPDKIOE@COOL?$AA@			; `string'
PUBLIC	??_C@_04KBFEHFJ@SLAV?$AA@			; `string'
PUBLIC	??_C@_04DKKPAKDO@BORE?$AA@			; `string'
PUBLIC	??_C@_02PPBOCKIA@TD?$AA@			; `string'
PUBLIC	??_C@_02MJBLCCBH@BP?$AA@			; `string'
PUBLIC	??_C@_04CIHCOAPG@SPOT?$AA@			; `string'
PUBLIC	??_C@_04NAGNMPFG@SCAN?$AA@			; `string'
PUBLIC	??_C@_03EODKJOEK@BIT?$AA@			; `string'
PUBLIC	??_C@_05IHLLIMHE@ALBIT?$AA@			; `string'
PUBLIC	??_C@_02OLOABKKD@ID?$AA@			; `string'
PUBLIC	??_C@_02CONMJBMJ@TM?$AA@			; `string'
PUBLIC	??_C@_02ONHIBMNM@M?5?$AA@			; `string'
PUBLIC	??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@		; `string'
PUBLIC	??_C@_03NAHIIPNL@SAF?$AA@			; `string'
PUBLIC	??_C@_03DNJPAHKI@SIM?$AA@			; `string'
PUBLIC	??_C@_03KDFFCEML@RDY?$AA@			; `string'
PUBLIC	??_C@_03JKFBEHPN@MAL?$AA@			; `string'
PUBLIC	??_C@_03NOAAMIEF@VIS?$AA@			; `string'
PUBLIC	??_C@_03PHIAGONP@PRE?$AA@			; `string'
PUBLIC	??_C@_04NGKPLICF@OPER?$AA@			; `string'
PUBLIC	??_C@_03PHODBHCN@FOV?$AA@			; `string'
PUBLIC	??_C@_03KKGFKKLA@EXP?$AA@			; `string'
PUBLIC	??_C@_03CAIJIGAK@HOC?$AA@			; `string'
PUBLIC	??_C@_04OFGPHIIG@NARO?$AA@			; `string'
PUBLIC	??_C@_04KPGPJCNC@WIDE?$AA@			; `string'
PUBLIC	??_C@_04HKIOICEJ@TBL1?$AA@			; `string'
PUBLIC	??_C@_03GEAIMIOL@TER?$AA@			; `string'
PUBLIC	??_C@_03KOECGNEM@INV?$AA@			; `string'
PUBLIC	??_C@_03PEMICIKC@PWR?$AA@			; `string'
PUBLIC	??_C@_05OKAJNMKE@ALIGN?$AA@			; `string'
PUBLIC	??_C@_04LGGJDDML@INIT?$AA@			; `string'
PUBLIC	??_C@_02BFICIOJL@ON?$AA@			; `string'
PUBLIC	??_C@_02OGHHJPHF@CD?$AA@			; `string'
PUBLIC	??_C@_04NFKAHBOI@PAIR?$AA@			; `string'
PUBLIC	??_C@_03COBKBLOD@SGL?$AA@			; `string'
PUBLIC	??_C@_04GKDMIDBA@CNTL?$AA@			; `string'
PUBLIC	??_C@_06JKMMOJOB@PROF?51?$AA@			; `string'
PUBLIC	??_C@_06LBOBLKCC@PROF?52?$AA@			; `string'
PUBLIC	??_C@_07LPGDFIGO@?$CFd?5PAIR?$AA@		; `string'
PUBLIC	??_C@_06FNBDGPPC@?$CFd?5SGL?$AA@		; `string'
PUBLIC	??_C@_04COHIKBOA@?$CFdFT?$AA@			; `string'
PUBLIC	??_C@_02NFDNIBGH@RP?$AA@			; `string'
PUBLIC	??_C@_0L@JDHHFEFM@AD?5?$CF?42fSEC?$AA@		; `string'
PUBLIC	??_C@_0L@KPDBGAEJ@REL?5ANG?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_09DCKDOAA@BA?5?$CF?40fFT?$AA@		; `string'
PUBLIC	??_C@_08JIGPNNJC@PR?525000?$AA@			; `string'
PUBLIC	??_C@_09OOMNNBBE@TOF?528?400?$AA@		; `string'
PUBLIC	??_C@_08JGHEKJJF@MRA?51105?$AA@			; `string'
PUBLIC	??_C@_07JGACOHHB@AD?5?$CF?40f?$AA@		; `string'
PUBLIC	??_C@_04DANPMIOD@NSTL?$AA@			; `string'
PUBLIC	??_C@_04POJNINAI@NOSE?$AA@			; `string'
PUBLIC	??_C@_04PEGBOIPH@TAIL?$AA@			; `string'
PUBLIC	??_C@_07EKLFMPDF@BA?5?$CF?40f?$AA@		; `string'
PUBLIC	??_C@_04GKNPDGLD@CCIP?$AA@			; `string'
PUBLIC	??_C@_04HKKMHKCC@CCRP?$AA@			; `string'
PUBLIC	??_C@_04DKJBKKPE@DTOS?$AA@			; `string'
PUBLIC	??_C@_04GEPACNOP@LADD?$AA@			; `string'
PUBLIC	??_C@_03KIGHCFHP@MAN?$AA@			; `string'
PUBLIC	??_C@_03LLDCGJBK@RUN?$AA@			; `string'
PUBLIC	??_C@_06LAIPFJMN@IDX?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_04FPNANLBH@RPOD?$AA@			; `string'
PUBLIC	??_C@_03DNAAPCJD@S?9J?$AA@			; `string'
PUBLIC	??_C@_04BKGGJKLP@STBY?$AA@			; `string'
PUBLIC	??_C@_03IFPDDAOD@MSL?$AA@			; `string'
PUBLIC	??_C@_04OBEHOCAG@EEGS?$AA@			; `string'
PUBLIC	??_C@_04DNACHFNH@SSLC?$AA@			; `string'
PUBLIC	??_C@_04MHCPIOBD@LCOS?$AA@			; `string'
PUBLIC	??_C@_04PGEGCIFE@SNAP?$AA@			; `string'
PUBLIC	??_C@_04DIKNPPMN@DGFT?$AA@			; `string'
PUBLIC	??_C@_03JKJFCLEN@FCR?$AA@			; `string'
PUBLIC	??_C@_04IILMDFMO@MENU?$AA@			; `string'
PUBLIC	??_C@_04NLFHDAEB@SWAP?$AA@			; `string'
PUBLIC	??_C@_03EIHCPKNA@E?9J?$AA@			; `string'
PUBLIC	??_C@_03KGBHJMEC@CLR?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_04MOOLDHHD@STEP?$AA@			; `string'
PUBLIC	??_C@_07CMDFHNJL@TGT?3?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_07GGAABMKK@OBJ?3?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_09MCKHKIBB@RNG?3?5?$CF?42f?$AA@		; `string'
PUBLIC	??_C@_0BB@KNFNFKJN@LAT?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@ ; `string'
PUBLIC	??_C@_0BA@IJOFIFMH@LAT?3?5?$CF3d?$CK?$CF2?42f?8?$AA@ ; `string'
PUBLIC	??_C@_0BB@HGKIMIJB@LNG?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@ ; `string'
PUBLIC	??_C@_0BA@MHLOFPON@LNG?3?5?$CF3d?$CK?$CF2?42f?8?$AA@ ; `string'
PUBLIC	??_C@_06KANKHHOL@STEP?5?$FO?$AA@		; `string'
PUBLIC	??_C@_03DBNGLLAD@TGT?$AA@			; `string'
PUBLIC	??_C@_06PNIHNJEB@STEP?5v?$AA@			; `string'
PUBLIC	??_C@_02KOENCFNK@PB?$AA@			; `string'
PUBLIC	??_C@_03JGPDCBCB@TOO?$AA@			; `string'
PUBLIC	??_C@_09MGHNDNCF@AUTO?5STEP?$AA@		; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Render2D@@8			; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRender2D@@@8				; Render2D `RTTI Type Descriptor'
PUBLIC	??_R3Render2D@@8				; Render2D::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Render2D@@8				; Render2D::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VirtualDisplay@@8			; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVirtualDisplay@@@8			; VirtualDisplay `RTTI Type Descriptor'
PUBLIC	??_R3VirtualDisplay@@8				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VirtualDisplay@@8				; VirtualDisplay::`RTTI Base Class Array'
PUBLIC	??_R4VirtualDisplay@@6B@			; VirtualDisplay::`RTTI Complete Object Locator'
PUBLIC	??_R4Render2D@@6B@				; Render2D::`RTTI Complete Object Locator'
PUBLIC	??_R4DrawableClass@@6B@				; DrawableClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDrawableClass@@@8			; DrawableClass `RTTI Type Descriptor'
PUBLIC	??_R3DrawableClass@@8				; DrawableClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DrawableClass@@8				; DrawableClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DrawableClass@@8			; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MfdDrawable@@6B@				; MfdDrawable::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMfdDrawable@@@8				; MfdDrawable `RTTI Type Descriptor'
PUBLIC	??_R3MfdDrawable@@8				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MfdDrawable@@8				; MfdDrawable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MfdDrawable@@8			; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SmsDrawable@@6B@				; SmsDrawable::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSmsDrawable@@@8				; SmsDrawable `RTTI Type Descriptor'
PUBLIC	??_R3SmsDrawable@@8				; SmsDrawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SmsDrawable@@8				; SmsDrawable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SmsDrawable@@8			; SmsDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@392c987a
PUBLIC	__real@3c8efa34
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d7a35db
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3f5eb852
PUBLIC	__real@3f666666
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3fcccccd
PUBLIC	__real@3fe00000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40e00000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@45be3840
PUBLIC	__real@4b9fa682
PUBLIC	__real@bdcccccd
PUBLIC	__real@be4ccccd
PUBLIC	__real@be99999a
PUBLIC	__real@bf19999a
PUBLIC	__real@bf4ccccd
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_sprintf:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetDriver@VuEntity@@QAEPAVVuDriver@@PAV2@@Z:PROC ; VuEntity::SetDriver
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Insert
EXTRN	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Remove
EXTRN	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z:PROC ; VuSessionEntity::GetCameraEntity
EXTRN	?AttachCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z:PROC ; VuSessionEntity::AttachCamera
EXTRN	?RemoveCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z:PROC ; VuSessionEntity::RemoveCamera
EXTRN	??0SpotEntity@@QAE@G@Z:PROC			; SpotEntity::SpotEntity
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??0ContextMPR@@QAE@XZ:PROC			; ContextMPR::ContextMPR
EXTRN	??1ContextMPR@@UAE@XZ:PROC			; ContextMPR::~ContextMPR
EXTRN	?SetState@ContextMPR@@QAEXGK@Z:PROC		; ContextMPR::SetState
EXTRN	?ClearBuffers@ContextMPR@@QAEXG@Z:PROC		; ContextMPR::ClearBuffers
EXTRN	?SelectForegroundColor@ContextMPR@@QAEXH@Z:PROC	; ContextMPR::SelectForegroundColor
EXTRN	?RestoreState@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::RestoreState
EXTRN	?Setup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Setup
EXTRN	?Cleanup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Cleanup
EXTRN	?Point@VirtualDisplay@@UAEXMM@Z:PROC		; VirtualDisplay::Point
EXTRN	?Line@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Line@VirtualDisplay@@UAEXMMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Tri@VirtualDisplay@@UAEXMMMMMM@Z:PROC		; VirtualDisplay::Tri
EXTRN	?Oval@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Oval
EXTRN	?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z:PROC	; VirtualDisplay::OvalArc
EXTRN	?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextLeft
EXTRN	?TextRight@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextRight
EXTRN	?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextLeftVertical
EXTRN	?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextRightVertical
EXTRN	?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextCenter
EXTRN	?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextCenterVertical
EXTRN	?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z:PROC	; VirtualDisplay::TextWrap
EXTRN	?ScreenTextHeight@VirtualDisplay@@SAHXZ:PROC	; VirtualDisplay::ScreenTextHeight
EXTRN	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z:PROC	; VirtualDisplay::ScreenTextWidth
EXTRN	?SetFont@VirtualDisplay@@SAXH@Z:PROC		; VirtualDisplay::SetFont
EXTRN	?SetViewport@VirtualDisplay@@UAEXMMMM@Z:PROC	; VirtualDisplay::SetViewport
EXTRN	?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z:PROC ; VirtualDisplay::SetViewportRelative
EXTRN	?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z:PROC	; VirtualDisplay::Render2DTri
EXTRN	??_EVirtualDisplay@@UAEPAXI@Z:PROC		; VirtualDisplay::`vector deleting destructor'
EXTRN	?Setup@Render2D@@UAEXPAVImageBuffer@@@Z:PROC	; Render2D::Setup
EXTRN	?Cleanup@Render2D@@UAEXXZ:PROC			; Render2D::Cleanup
EXTRN	?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z:PROC ; Render2D::SetImageBuffer
EXTRN	?StartDraw@Render2D@@UAEXXZ:PROC		; Render2D::StartDraw
EXTRN	?EndDraw@Render2D@@UAEXXZ:PROC			; Render2D::EndDraw
EXTRN	?SetViewport@Render2D@@UAEXMMMM@Z:PROC		; Render2D::SetViewport
EXTRN	?Render2DPoint@Render2D@@UAEXMM@Z:PROC		; Render2D::Render2DPoint
EXTRN	?Render2DLine@Render2D@@UAEXMMMM@Z:PROC		; Render2D::Render2DLine
EXTRN	?Render2DTri@Render2D@@UAEXMMMMMM@Z:PROC	; Render2D::Render2DTri
EXTRN	?ScreenText@Render2D@@UAEXMMPBDH@Z:PROC		; Render2D::ScreenText
EXTRN	??_ERender2D@@UAEPAXI@Z:PROC			; Render2D::`vector deleting destructor'
EXTRN	??0SpotDriver@@QAE@PAVVuEntity@@@Z:PROC		; SpotDriver::SpotDriver
EXTRN	?DisplayExit@DrawableClass@@UAEXXZ:PROC		; DrawableClass::DisplayExit
EXTRN	?LabelButton@DrawableClass@@QAEXHPAD0H@Z:PROC	; DrawableClass::LabelButton
EXTRN	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z:PROC	; DrawableClass::GetButtonPos
EXTRN	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z:PROC ; DrawableClass::GetMfdColor
EXTRN	??_EDrawableClass@@UAEPAXI@Z:PROC		; DrawableClass::`vector deleting destructor'
EXTRN	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z:PROC	; MFDClass::SetNewMode
EXTRN	??1MfdDrawable@@UAE@XZ:PROC			; MfdDrawable::~MfdDrawable
EXTRN	?DisplayInit@MfdDrawable@@UAEXPAVImageBuffer@@@Z:PROC ; MfdDrawable::DisplayInit
EXTRN	?PushButton@MfdDrawable@@UAEXHH@Z:PROC		; MfdDrawable::PushButton
EXTRN	?BottomRow@MfdDrawable@@QAEXXZ:PROC		; MfdDrawable::BottomRow
EXTRN	?DrawReference@MfdDrawable@@QAEXPAVAircraftClass@@@Z:PROC ; MfdDrawable::DrawReference
EXTRN	?DrawRedBreak@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z:PROC ; MfdDrawable::DrawRedBreak
EXTRN	?TGPAttitudeWarning@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z:PROC ; MfdDrawable::TGPAttitudeWarning
EXTRN	??_EMfdDrawable@@UAEPAXI@Z:PROC			; MfdDrawable::`vector deleting destructor'
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?ToggleFOV@LaserPodClass@@QAEXXZ:PROC		; LaserPodClass::ToggleFOV
EXTRN	?NextSubMode@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::NextSubMode
EXTRN	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z:PROC ; FireControlComputer::SetMasterMode
EXTRN	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z:PROC ; FireControlComputer::SetSubMode
EXTRN	?WeaponStep@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::WeaponStep
EXTRN	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ:PROC ; FireControlComputer::GetMainMasterMode
EXTRN	?ToggleAAGunMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::ToggleAAGunMode
EXTRN	?ToggleAGGunMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::ToggleAGGunMode
EXTRN	?StationOK@SMSBaseClass@@QAEHH@Z:PROC		; SMSBaseClass::StationOK
EXTRN	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z:PROC	; SMSBaseClass::StepMavSubMode
EXTRN	?IncrementRippleCount@SMSClass@@QAEXXZ:PROC	; SMSClass::IncrementRippleCount
EXTRN	?IncrementRippleInterval@SMSClass@@QAEXXZ:PROC	; SMSClass::IncrementRippleInterval
EXTRN	?IncrementBurstHeight@SMSClass@@QAEXXZ:PROC	; SMSClass::IncrementBurstHeight
EXTRN	?Incrementarmingdelay@SMSClass@@QAEXXZ:PROC	; SMSClass::Incrementarmingdelay
EXTRN	?StepAAWeapon@SMSClass@@QAEXXZ:PROC		; SMSClass::StepAAWeapon
EXTRN	?StepAGWeapon@SMSClass@@QAEXXZ:PROC		; SMSClass::StepAGWeapon
EXTRN	?InputDisplay@SmsDrawable@@QAEXXZ:PROC		; SmsDrawable::InputDisplay
EXTRN	?InputPushButton@SmsDrawable@@QAEXHH@Z:PROC	; SmsDrawable::InputPushButton
EXTRN	?ClearDigits@SmsDrawable@@QAEXXZ:PROC		; SmsDrawable::ClearDigits
EXTRN	?GunDisplay@SmsDrawable@@AAEXXZ:PROC		; SmsDrawable::GunDisplay
EXTRN	?InventoryDisplay@SmsDrawable@@AAEXH@Z:PROC	; SmsDrawable::InventoryDisplay
EXTRN	?InvPushButton@SmsDrawable@@AAEXHH@Z:PROC	; SmsDrawable::InvPushButton
EXTRN	??_ESmsDrawable@@UAEPAXI@Z:PROC			; SmsDrawable::`vector deleting destructor'
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?DrawBullseyeCircle@@YAXPAVVirtualDisplay@@MM@Z:PROC ; DrawBullseyeCircle
EXTRN	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z:PROC ; FindLaserPod
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?pFontSet@VirtualDisplay@@2PAUFontSet@@A:DWORD	; VirtualDisplay::pFontSet
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?FALCON_ORIGIN_LAT@@3MA:DWORD			; FALCON_ORIGIN_LAT
EXTRN	?FALCON_ORIGIN_LONG@@3MA:DWORD			; FALCON_ORIGIN_LONG
EXTRN	?F4FlyingEyeType@@3HA:DWORD			; F4FlyingEyeType
EXTRN	?g_bMLU@@3_NA:BYTE				; g_bMLU
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf4ccccd
CONST	SEGMENT
__real@bf4ccccd DD 0bf4ccccdr			; -0.8
CONST	ENDS
;	COMDAT __real@bf19999a
CONST	SEGMENT
__real@bf19999a DD 0bf19999ar			; -0.6
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@be4ccccd
CONST	SEGMENT
__real@be4ccccd DD 0be4ccccdr			; -0.2
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@4b9fa682
CONST	SEGMENT
__real@4b9fa682 DD 04b9fa682r			; 2.09257e+007
CONST	ENDS
;	COMDAT __real@45be3840
CONST	SEGMENT
__real@45be3840 DD 045be3840r			; 6087.03
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe00000
CONST	SEGMENT
__real@3fe00000 DD 03fe00000r			; 1.75
CONST	ENDS
;	COMDAT __real@3fcccccd
CONST	SEGMENT
__real@3fcccccd DD 03fcccccdr			; 1.6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f5eb852
CONST	SEGMENT
__real@3f5eb852 DD 03f5eb852r			; 0.87
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d7a35db
CONST	SEGMENT
__real@3d7a35db DD 03d7a35dbr			; 0.0610865
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@SmsDrawable@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SmsDrawable@@8 DD FLAT:??_R0?AVSmsDrawable@@@8 ; SmsDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SmsDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R2SmsDrawable@@8
rdata$r	SEGMENT
??_R2SmsDrawable@@8 DD FLAT:??_R1A@?0A@EA@SmsDrawable@@8 ; SmsDrawable::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3SmsDrawable@@8
rdata$r	SEGMENT
??_R3SmsDrawable@@8 DD 00H				; SmsDrawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SmsDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSmsDrawable@@@8
_DATA	SEGMENT
??_R0?AVSmsDrawable@@@8 DD FLAT:??_7type_info@@6B@	; SmsDrawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSmsDrawable@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SmsDrawable@@6B@
rdata$r	SEGMENT
??_R4SmsDrawable@@6B@ DD 00H				; SmsDrawable::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSmsDrawable@@@8
	DD	FLAT:??_R3SmsDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MfdDrawable@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MfdDrawable@@8 DD FLAT:??_R0?AVMfdDrawable@@@8 ; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R2MfdDrawable@@8
rdata$r	SEGMENT
??_R2MfdDrawable@@8 DD FLAT:??_R1A@?0A@EA@MfdDrawable@@8 ; MfdDrawable::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3MfdDrawable@@8
rdata$r	SEGMENT
??_R3MfdDrawable@@8 DD 00H				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMfdDrawable@@@8
_DATA	SEGMENT
??_R0?AVMfdDrawable@@@8 DD FLAT:??_7type_info@@6B@	; MfdDrawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMfdDrawable@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MfdDrawable@@6B@
rdata$r	SEGMENT
??_R4MfdDrawable@@6B@ DD 00H				; MfdDrawable::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMfdDrawable@@@8
	DD	FLAT:??_R3MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DrawableClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DrawableClass@@8 DD FLAT:??_R0?AVDrawableClass@@@8 ; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R2DrawableClass@@8
rdata$r	SEGMENT
??_R2DrawableClass@@8 DD FLAT:??_R1A@?0A@EA@DrawableClass@@8 ; DrawableClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DrawableClass@@8
rdata$r	SEGMENT
??_R3DrawableClass@@8 DD 00H				; DrawableClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawableClass@@@8
_DATA	SEGMENT
??_R0?AVDrawableClass@@@8 DD FLAT:??_7type_info@@6B@	; DrawableClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawableClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DrawableClass@@6B@
rdata$r	SEGMENT
??_R4DrawableClass@@6B@ DD 00H				; DrawableClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDrawableClass@@@8
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R4Render2D@@6B@
rdata$r	SEGMENT
??_R4Render2D@@6B@ DD 00H				; Render2D::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRender2D@@@8
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R4VirtualDisplay@@6B@
rdata$r	SEGMENT
??_R4VirtualDisplay@@6B@ DD 00H				; VirtualDisplay::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVirtualDisplay@@@8
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2VirtualDisplay@@8
rdata$r	SEGMENT
??_R2VirtualDisplay@@8 DD FLAT:??_R1A@?0A@EA@VirtualDisplay@@8 ; VirtualDisplay::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VirtualDisplay@@8
rdata$r	SEGMENT
??_R3VirtualDisplay@@8 DD 00H				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVirtualDisplay@@@8
_DATA	SEGMENT
??_R0?AVVirtualDisplay@@@8 DD FLAT:??_7type_info@@6B@	; VirtualDisplay `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVirtualDisplay@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VirtualDisplay@@8 DD FLAT:??_R0?AVVirtualDisplay@@@8 ; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2Render2D@@8
rdata$r	SEGMENT
??_R2Render2D@@8 DD FLAT:??_R1A@?0A@EA@Render2D@@8	; Render2D::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R3Render2D@@8
rdata$r	SEGMENT
??_R3Render2D@@8 DD 00H					; Render2D::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRender2D@@@8
_DATA	SEGMENT
??_R0?AVRender2D@@@8 DD FLAT:??_7type_info@@6B@		; Render2D `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRender2D@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Render2D@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Render2D@@8 DD FLAT:??_R0?AVRender2D@@@8	; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09MGHNDNCF@AUTO?5STEP?$AA@
CONST	SEGMENT
??_C@_09MGHNDNCF@AUTO?5STEP?$AA@ DB 'AUTO STEP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGPDCBCB@TOO?$AA@
CONST	SEGMENT
??_C@_03JGPDCBCB@TOO?$AA@ DB 'TOO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENCFNK@PB?$AA@
CONST	SEGMENT
??_C@_02KOENCFNK@PB?$AA@ DB 'PB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNIHNJEB@STEP?5v?$AA@
CONST	SEGMENT
??_C@_06PNIHNJEB@STEP?5v?$AA@ DB 'STEP v', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DBNGLLAD@TGT?$AA@
CONST	SEGMENT
??_C@_03DBNGLLAD@TGT?$AA@ DB 'TGT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KANKHHOL@STEP?5?$FO?$AA@
CONST	SEGMENT
??_C@_06KANKHHOL@STEP?5?$FO?$AA@ DB 'STEP ^', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MHLOFPON@LNG?3?5?$CF3d?$CK?$CF2?42f?8?$AA@
CONST	SEGMENT
??_C@_0BA@MHLOFPON@LNG?3?5?$CF3d?$CK?$CF2?42f?8?$AA@ DB 'LNG: %3d*%2.2f'''
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HGKIMIJB@LNG?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@
CONST	SEGMENT
??_C@_0BB@HGKIMIJB@LNG?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@ DB 'LNG: %3d*0%2.2f'
	DB	'''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IJOFIFMH@LAT?3?5?$CF3d?$CK?$CF2?42f?8?$AA@
CONST	SEGMENT
??_C@_0BA@IJOFIFMH@LAT?3?5?$CF3d?$CK?$CF2?42f?8?$AA@ DB 'LAT: %3d*%2.2f'''
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KNFNFKJN@LAT?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@
CONST	SEGMENT
??_C@_0BB@KNFNFKJN@LAT?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@ DB 'LAT: %3d*0%2.2f'
	DB	'''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09MCKHKIBB@RNG?3?5?$CF?42f?$AA@
CONST	SEGMENT
??_C@_09MCKHKIBB@RNG?3?5?$CF?42f?$AA@ DB 'RNG: %.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGAABMKK@OBJ?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07GGAABMKK@OBJ?3?5?$CFs?$AA@ DB 'OBJ: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMDFHNJL@TGT?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07CMDFHNJL@TGT?3?5?$CFs?$AA@ DB 'TGT: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOOLDHHD@STEP?$AA@
CONST	SEGMENT
??_C@_04MOOLDHHD@STEP?$AA@ DB 'STEP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGBHJMEC@CLR?$AA@
CONST	SEGMENT
??_C@_03KGBHJMEC@CLR?$AA@ DB 'CLR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EIHCPKNA@E?9J?$AA@
CONST	SEGMENT
??_C@_03EIHCPKNA@E?9J?$AA@ DB 'E-J', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLFHDAEB@SWAP?$AA@
CONST	SEGMENT
??_C@_04NLFHDAEB@SWAP?$AA@ DB 'SWAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IILMDFMO@MENU?$AA@
CONST	SEGMENT
??_C@_04IILMDFMO@MENU?$AA@ DB 'MENU', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKJFCLEN@FCR?$AA@
CONST	SEGMENT
??_C@_03JKJFCLEN@FCR?$AA@ DB 'FCR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIKNPPMN@DGFT?$AA@
CONST	SEGMENT
??_C@_04DIKNPPMN@DGFT?$AA@ DB 'DGFT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGEGCIFE@SNAP?$AA@
CONST	SEGMENT
??_C@_04PGEGCIFE@SNAP?$AA@ DB 'SNAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHCPIOBD@LCOS?$AA@
CONST	SEGMENT
??_C@_04MHCPIOBD@LCOS?$AA@ DB 'LCOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNACHFNH@SSLC?$AA@
CONST	SEGMENT
??_C@_04DNACHFNH@SSLC?$AA@ DB 'SSLC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OBEHOCAG@EEGS?$AA@
CONST	SEGMENT
??_C@_04OBEHOCAG@EEGS?$AA@ DB 'EEGS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFPDDAOD@MSL?$AA@
CONST	SEGMENT
??_C@_03IFPDDAOD@MSL?$AA@ DB 'MSL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKGGJKLP@STBY?$AA@
CONST	SEGMENT
??_C@_04BKGGJKLP@STBY?$AA@ DB 'STBY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNAAPCJD@S?9J?$AA@
CONST	SEGMENT
??_C@_03DNAAPCJD@S?9J?$AA@ DB 'S-J', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPNANLBH@RPOD?$AA@
CONST	SEGMENT
??_C@_04FPNANLBH@RPOD?$AA@ DB 'RPOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAIPFJMN@IDX?5?$CFd?$AA@
CONST	SEGMENT
??_C@_06LAIPFJMN@IDX?5?$CFd?$AA@ DB 'IDX %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LLDCGJBK@RUN?$AA@
CONST	SEGMENT
??_C@_03LLDCGJBK@RUN?$AA@ DB 'RUN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KIGHCFHP@MAN?$AA@
CONST	SEGMENT
??_C@_03KIGHCFHP@MAN?$AA@ DB 'MAN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEPACNOP@LADD?$AA@
CONST	SEGMENT
??_C@_04GEPACNOP@LADD?$AA@ DB 'LADD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKJBKKPE@DTOS?$AA@
CONST	SEGMENT
??_C@_04DKJBKKPE@DTOS?$AA@ DB 'DTOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HKKMHKCC@CCRP?$AA@
CONST	SEGMENT
??_C@_04HKKMHKCC@CCRP?$AA@ DB 'CCRP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKNPDGLD@CCIP?$AA@
CONST	SEGMENT
??_C@_04GKNPDGLD@CCIP?$AA@ DB 'CCIP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKLFMPDF@BA?5?$CF?40f?$AA@
CONST	SEGMENT
??_C@_07EKLFMPDF@BA?5?$CF?40f?$AA@ DB 'BA %.0f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PEGBOIPH@TAIL?$AA@
CONST	SEGMENT
??_C@_04PEGBOIPH@TAIL?$AA@ DB 'TAIL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POJNINAI@NOSE?$AA@
CONST	SEGMENT
??_C@_04POJNINAI@NOSE?$AA@ DB 'NOSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DANPMIOD@NSTL?$AA@
CONST	SEGMENT
??_C@_04DANPMIOD@NSTL?$AA@ DB 'NSTL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGACOHHB@AD?5?$CF?40f?$AA@
CONST	SEGMENT
??_C@_07JGACOHHB@AD?5?$CF?40f?$AA@ DB 'AD %.0f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGHEKJJF@MRA?51105?$AA@
CONST	SEGMENT
??_C@_08JGHEKJJF@MRA?51105?$AA@ DB 'MRA 1105', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOMNNBBE@TOF?528?400?$AA@
CONST	SEGMENT
??_C@_09OOMNNBBE@TOF?528?400?$AA@ DB 'TOF 28.00', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JIGPNNJC@PR?525000?$AA@
CONST	SEGMENT
??_C@_08JIGPNNJC@PR?525000?$AA@ DB 'PR 25000', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCKDOAA@BA?5?$CF?40fFT?$AA@
CONST	SEGMENT
??_C@_09DCKDOAA@BA?5?$CF?40fFT?$AA@ DB 'BA %.0fFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KPDBGAEJ@REL?5ANG?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@KPDBGAEJ@REL?5ANG?5?$CFd?$AA@ DB 'REL ANG %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDHHFEFM@AD?5?$CF?42fSEC?$AA@
CONST	SEGMENT
??_C@_0L@JDHHFEFM@AD?5?$CF?42fSEC?$AA@ DB 'AD %.2fSEC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NFDNIBGH@RP?$AA@
CONST	SEGMENT
??_C@_02NFDNIBGH@RP?$AA@ DB 'RP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04COHIKBOA@?$CFdFT?$AA@
CONST	SEGMENT
??_C@_04COHIKBOA@?$CFdFT?$AA@ DB '%dFT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNBDGPPC@?$CFd?5SGL?$AA@
CONST	SEGMENT
??_C@_06FNBDGPPC@?$CFd?5SGL?$AA@ DB '%d SGL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LPGDFIGO@?$CFd?5PAIR?$AA@
CONST	SEGMENT
??_C@_07LPGDFIGO@?$CFd?5PAIR?$AA@ DB '%d PAIR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LBOBLKCC@PROF?52?$AA@
CONST	SEGMENT
??_C@_06LBOBLKCC@PROF?52?$AA@ DB 'PROF 2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JKMMOJOB@PROF?51?$AA@
CONST	SEGMENT
??_C@_06JKMMOJOB@PROF?51?$AA@ DB 'PROF 1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKDMIDBA@CNTL?$AA@
CONST	SEGMENT
??_C@_04GKDMIDBA@CNTL?$AA@ DB 'CNTL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03COBKBLOD@SGL?$AA@
CONST	SEGMENT
??_C@_03COBKBLOD@SGL?$AA@ DB 'SGL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NFKAHBOI@PAIR?$AA@
CONST	SEGMENT
??_C@_04NFKAHBOI@PAIR?$AA@ DB 'PAIR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OGHHJPHF@CD?$AA@
CONST	SEGMENT
??_C@_02OGHHJPHF@CD?$AA@ DB 'CD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BFICIOJL@ON?$AA@
CONST	SEGMENT
??_C@_02BFICIOJL@ON?$AA@ DB 'ON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LGGJDDML@INIT?$AA@
CONST	SEGMENT
??_C@_04LGGJDDML@INIT?$AA@ DB 'INIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKAJNMKE@ALIGN?$AA@
CONST	SEGMENT
??_C@_05OKAJNMKE@ALIGN?$AA@ DB 'ALIGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PEMICIKC@PWR?$AA@
CONST	SEGMENT
??_C@_03PEMICIKC@PWR?$AA@ DB 'PWR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KOECGNEM@INV?$AA@
CONST	SEGMENT
??_C@_03KOECGNEM@INV?$AA@ DB 'INV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GEAIMIOL@TER?$AA@
CONST	SEGMENT
??_C@_03GEAIMIOL@TER?$AA@ DB 'TER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HKIOICEJ@TBL1?$AA@
CONST	SEGMENT
??_C@_04HKIOICEJ@TBL1?$AA@ DB 'TBL1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KPGPJCNC@WIDE?$AA@
CONST	SEGMENT
??_C@_04KPGPJCNC@WIDE?$AA@ DB 'WIDE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFGPHIIG@NARO?$AA@
CONST	SEGMENT
??_C@_04OFGPHIIG@NARO?$AA@ DB 'NARO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CAIJIGAK@HOC?$AA@
CONST	SEGMENT
??_C@_03CAIJIGAK@HOC?$AA@ DB 'HOC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KKGFKKLA@EXP?$AA@
CONST	SEGMENT
??_C@_03KKGFKKLA@EXP?$AA@ DB 'EXP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHODBHCN@FOV?$AA@
CONST	SEGMENT
??_C@_03PHODBHCN@FOV?$AA@ DB 'FOV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NGKPLICF@OPER?$AA@
CONST	SEGMENT
??_C@_04NGKPLICF@OPER?$AA@ DB 'OPER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHIAGONP@PRE?$AA@
CONST	SEGMENT
??_C@_03PHIAGONP@PRE?$AA@ DB 'PRE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOAAMIEF@VIS?$AA@
CONST	SEGMENT
??_C@_03NOAAMIEF@VIS?$AA@ DB 'VIS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKFBEHPN@MAL?$AA@
CONST	SEGMENT
??_C@_03JKFBEHPN@MAL?$AA@ DB 'MAL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDFFCEML@RDY?$AA@
CONST	SEGMENT
??_C@_03KDFFCEML@RDY?$AA@ DB 'RDY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNJPAHKI@SIM?$AA@
CONST	SEGMENT
??_C@_03DNJPAHKI@SIM?$AA@ DB 'SIM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NAHIIPNL@SAF?$AA@
CONST	SEGMENT
??_C@_03NAHIIPNL@SAF?$AA@ DB 'SAF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@
CONST	SEGMENT
??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@ DB '%d%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ONHIBMNM@M?5?$AA@
CONST	SEGMENT
??_C@_02ONHIBMNM@M?5?$AA@ DB 'M ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CONMJBMJ@TM?$AA@
CONST	SEGMENT
??_C@_02CONMJBMJ@TM?$AA@ DB 'TM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OLOABKKD@ID?$AA@
CONST	SEGMENT
??_C@_02OLOABKKD@ID?$AA@ DB 'ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHLLIMHE@ALBIT?$AA@
CONST	SEGMENT
??_C@_05IHLLIMHE@ALBIT?$AA@ DB 'ALBIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EODKJOEK@BIT?$AA@
CONST	SEGMENT
??_C@_03EODKJOEK@BIT?$AA@ DB 'BIT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NAGNMPFG@SCAN?$AA@
CONST	SEGMENT
??_C@_04NAGNMPFG@SCAN?$AA@ DB 'SCAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIHCOAPG@SPOT?$AA@
CONST	SEGMENT
??_C@_04CIHCOAPG@SPOT?$AA@ DB 'SPOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJBLCCBH@BP?$AA@
CONST	SEGMENT
??_C@_02MJBLCCBH@BP?$AA@ DB 'BP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPBOCKIA@TD?$AA@
CONST	SEGMENT
??_C@_02PPBOCKIA@TD?$AA@ DB 'TD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKKPAKDO@BORE?$AA@
CONST	SEGMENT
??_C@_04DKKPAKDO@BORE?$AA@ DB 'BORE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEHFJ@SLAV?$AA@
CONST	SEGMENT
??_C@_04KBFEHFJ@SLAV?$AA@ DB 'SLAV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MCPDKIOE@COOL?$AA@
CONST	SEGMENT
??_C@_04MCPDKIOE@COOL?$AA@ DB 'COOL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LKKJOPPH@WARM?$AA@
CONST	SEGMENT
??_C@_04LKKJOPPH@WARM?$AA@ DB 'WARM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FDKECMHJ@Sms?5Weapon?5in?5Nav?5mode?6?$AA@
CONST	SEGMENT
??_C@_0BI@FDKECMHJ@Sms?5Weapon?5in?5Nav?5mode?6?$AA@ DB 'Sms Weapon in Na'
	DB	'v mode', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03NMPFMOLH@GUN?$AA@
CONST	SEGMENT
??_C@_03NMPFMOLH@GUN?$AA@ DB 'GUN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HCLOBDMK@A?9G?$AA@
CONST	SEGMENT
??_C@_03HCLOBDMK@A?9G?$AA@ DB 'A-G', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MNBBLFLG@AGM?$AA@
CONST	SEGMENT
??_C@_03MNBBLFLG@AGM?$AA@ DB 'AGM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJJMMJAE@AAM?$AA@
CONST	SEGMENT
??_C@_03MJJMMJAE@AAM?$AA@ DB 'AAM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MPPIHBHJ@OFF?$AA@
CONST	SEGMENT
??_C@_03MPPIHBHJ@OFF?$AA@ DB 'OFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OONHJAKL@SMS?$AA@
CONST	SEGMENT
??_C@_03OONHJAKL@SMS?$AA@ DB 'SMS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7SmsDrawable@@6B@
CONST	SEGMENT
??_7SmsDrawable@@6B@ DD FLAT:??_R4SmsDrawable@@6B@	; SmsDrawable::`vftable'
	DD	FLAT:??_ESmsDrawable@@UAEPAXI@Z
	DD	FLAT:?Display@SmsDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@SmsDrawable@@UAEXXZ
	DD	FLAT:?GetDisplay@SmsDrawable@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@SmsDrawable@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_7MfdDrawable@@6B@
CONST	SEGMENT
??_7MfdDrawable@@6B@ DD FLAT:??_R4MfdDrawable@@6B@	; MfdDrawable::`vftable'
	DD	FLAT:??_EMfdDrawable@@UAEPAXI@Z
	DD	FLAT:?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@MfdDrawable@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@MfdDrawable@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_7DrawableClass@@6B@
CONST	SEGMENT
??_7DrawableClass@@6B@ DD FLAT:??_R4DrawableClass@@6B@	; DrawableClass::`vftable'
	DD	FLAT:??_EDrawableClass@@UAEPAXI@Z
	DD	FLAT:?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@DrawableClass@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_7Render2D@@6B@
CONST	SEGMENT
??_7Render2D@@6B@ DD FLAT:??_R4Render2D@@6B@		; Render2D::`vftable'
	DD	FLAT:??_ERender2D@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@Render2D@@UAEXXZ
	DD	FLAT:?StartDraw@Render2D@@UAEXXZ
	DD	FLAT:?ClearDraw@Render2D@@UAEXXZ
	DD	FLAT:?EndDraw@Render2D@@UAEXXZ
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:?SetColor@Render2D@@UAEXK@Z
	DD	FLAT:?SetBackground@Render2D@@UAEXK@Z
	DD	FLAT:?ScreenText@Render2D@@UAEXMMPBDH@Z
	DD	FLAT:?SetLineStyle@Render2D@@UAEXH@Z
	DD	FLAT:?Color@Render2D@@UAEKXZ
	DD	FLAT:?SetViewport@Render2D@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Render2DPoint@Render2D@@UAEXMM@Z
	DD	FLAT:?Render2DLine@Render2D@@UAEXMMMM@Z
	DD	FLAT:?Render2DTri@Render2D@@UAEXMMMMMM@Z
	DD	FLAT:?Setup@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?ClearZBuffer@Render2D@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7VirtualDisplay@@6B@
CONST	SEGMENT
??_7VirtualDisplay@@6B@ DD FLAT:??_R4VirtualDisplay@@6B@ ; VirtualDisplay::`vftable'
	DD	FLAT:??_EVirtualDisplay@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@VirtualDisplay@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?SetLineStyle@VirtualDisplay@@UAEXH@Z
	DD	FLAT:?Color@VirtualDisplay@@UAEKXZ
	DD	FLAT:?SetViewport@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z$0
__unwindtable$??1SmsDrawable@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SmsDrawable@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SmsDrawable@@UAE@XZ$1
__unwindtable$??0SmsDrawable@@QAE@PAVSMSClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$3
__ehfuncinfo$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1SmsDrawable@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SmsDrawable@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SmsDrawable@@QAE@PAVSMSClass@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0SmsDrawable@@QAE@PAVSMSClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetScanDir@RadarDopplerClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dir$ = 8						; size = 4
?SetScanDir@RadarDopplerClass@@QAEXM@Z PROC		; RadarDopplerClass::SetScanDir, COMDAT
; _this$ = ecx

; 247  : 	void SetScanDir(float dir)	{scanDir = dir;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [eax+252], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScanDir@RadarDopplerClass@@QAEXM@Z ENDP		; RadarDopplerClass::SetScanDir
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSPType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSPType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSPType, COMDAT
; _this$ = ecx

; 291  : 	uchar GetSPType (void) const						{	return (EntityType())->classInfo_[VU_SPTYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 2
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSPType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSPType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetMaxRippleCount@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxRippleCount@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetMaxRippleCount, COMDAT
; _this$ = ecx

; 1244 : 	int GetMaxRippleCount(void) {return auxaeroData->maxRippleCount; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+2528]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxRippleCount@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetMaxRippleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?DisplayInCockpit@OTWDriverClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisplayInCockpit@OTWDriverClass@@QAEHXZ PROC		; OTWDriverClass::DisplayInCockpit, COMDAT
; _this$ = ecx

; 244  : 		inline BOOL DisplayInCockpit( void ){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 			if (mOTWDisplayMode >= ModeHud && mOTWDisplayMode <= ModePadlockEFOV )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32328], 1
	jl	SHORT $LN1@DisplayInC
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32328], 5
	jg	SHORT $LN1@DisplayInC

; 246  : 		  		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN2@DisplayInC
$LN1@DisplayInC:

; 247  : 			return FALSE;

	xor	eax, eax
$LN2@DisplayInC:

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayInCockpit@OTWDriverClass@@QAEHXZ ENDP		; OTWDriverClass::DisplayInCockpit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSmsDrawable@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSmsDrawable@@UAEPAXI@Z PROC				; SmsDrawable::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SmsDrawable@@UAE@XZ			; SmsDrawable::~SmsDrawable
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSmsDrawable@@UAEPAXI@Z ENDP				; SmsDrawable::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_playerAC$ = -264					; size = 4
tv1015 = -260						; size = 4
tv950 = -256						; size = 4
tv978 = -252						; size = 4
tv945 = -248						; size = 4
tv969 = -244						; size = 4
_cosLatitude$1 = -240					; size = 4
_dX$2 = -236						; size = 4
_xCurr$3 = -232						; size = 4
_dY$4 = -228						; size = 4
_yCurr$5 = -224						; size = 4
_longMin$6 = -220					; size = 4
tv668 = -216						; size = 4
_latDeg$7 = -212					; size = 4
_longDeg$8 = -208					; size = 4
_CAPplayer$ = -204					; size = 4
_latMin$9 = -200					; size = 4
_pFCC$ = -196						; size = 4
_longitude$10 = -192					; size = 4
_latitude$11 = -188					; size = 4
_self$ = -184						; size = 4
_this$ = -180						; size = 4
_tempstr$12 = -176					; size = 80
_tempstr$13 = -96					; size = 80
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?JDAMDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::JDAMDisplay
; _this$ = ecx

; 2702 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2703 : 	char tmpStr[12];
; 2704 : 	FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 2705 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2706 : 	AircraftClass *self = ((AircraftClass*)playerAC);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	DWORD PTR _self$[ebp], ecx

; 2707 : 	int CAPplayer = 0;

	mov	DWORD PTR _CAPplayer$[ebp], 0

; 2708 : 	if (self->autopilotType == AircraftClass::CombatAP)

	mov	edx, DWORD PTR _self$[ebp]
	cmp	DWORD PTR [edx+968], 2
	jne	SHORT $LN49@JDAMDispla

; 2709 : 		CAPplayer = 1;

	mov	DWORD PTR _CAPplayer$[ebp], 1
$LN49@JDAMDispla:

; 2710 : 	TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 2711 : 	BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 2712 : 	if(IsSet(MENUMODE)) {

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z ; SmsDrawable::IsSet
	test	eax, eax
	je	SHORT $LN48@JDAMDispla

; 2713 : 	    AGMenuDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AGMenuDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::AGMenuDisplay

; 2714 : 	    return;

	jmp	$LN50@JDAMDispla
$LN48@JDAMDispla:

; 2715 : 	}
; 2716 : 	// Count number of current weapons
; 2717 : 	sprintf (tmpStr, "%d%s", Sms->NumCurrentWpn(), Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->mnemonic);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+148]
	call	edx
	add	eax, 28					; 0000001cH
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	push	eax
	push	OFFSET ??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2718 : 	ShiAssert(strlen(tmpStr) < 12);
; 2719 : 	LabelButton (5,  tmpStr, "");

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2720 : 	
; 2721 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN47@JDAMDispla

; 2722 : 		SetWeapParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWeapParams@SmsDrawable@@QAEXXZ	; SmsDrawable::SetWeapParams
$LN47@JDAMDispla:

; 2723 : 	// OSS Button Labels
; 2724 : 	if (Sms->curWeaponClass == wcRocketWpn)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+156], 1
	jne	SHORT $LN46@JDAMDispla

; 2725 : 	{
; 2726 : 		// since pair/single is the only thing modelled for rockets
; 2727 : 		if (Sms->GetAGBPair())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN45@JDAMDispla

; 2728 : 			LabelButton (7,  "PAIR");

	push	0
	push	0
	push	OFFSET ??_C@_04NFKAHBOI@PAIR?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2729 : 		else

	jmp	SHORT $LN44@JDAMDispla
$LN45@JDAMDispla:

; 2730 : 			LabelButton (7,  "SGL");

	push	0
	push	0
	push	OFFSET ??_C@_03COBKBLOD@SGL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN44@JDAMDispla:

; 2731 : 	}
; 2732 : 	else

	jmp	$LN43@JDAMDispla
$LN46@JDAMDispla:

; 2733 : 	{ 
; 2734 : 		LabelButton (4,  "CNTL");

	push	0
	push	0
	push	OFFSET ??_C@_04GKDMIDBA@CNTL?$AA@
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2735 : 
; 2736 : 		if (CAPplayer)

	cmp	DWORD PTR _CAPplayer$[ebp], 0
	je	SHORT $LN42@JDAMDispla

; 2737 : 		{
; 2738 : 			Sms->JDAMPowered = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	BYTE PTR [eax+28], 1

; 2739 : 			Sms->JDAMInitTimer = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+32], xmm0

; 2740 : 			LabelButton (6,  "RDY");

	push	0
	push	0
	push	OFFSET ??_C@_03KDFFCEML@RDY?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2741 : 			Sms->JDAMtargeting = SMSBaseClass::PB;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR [ecx+36], 0

; 2742 : 		}
; 2743 : 		else

	jmp	$LN33@JDAMDispla
$LN42@JDAMDispla:

; 2744 : 		{
; 2745 : 			if(!Sms->JDAMPowered) // MLR 4/3/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movzx	ecx, BYTE PTR [eax+28]
	test	ecx, ecx
	jne	SHORT $LN40@JDAMDispla

; 2746 : 				LabelButton (6,  "PWR", "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	$LN33@JDAMDispla
$LN40@JDAMDispla:

; 2747 : 			else if (Sms->JDAMPowered && !Sms->curWeapon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movzx	ecx, BYTE PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN38@JDAMDispla
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	add	ecx, 164				; 000000a4H
	call	??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator!
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@JDAMDispla

; 2748 : 				LabelButton (6,  "PWR", "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	$LN33@JDAMDispla
$LN38@JDAMDispla:

; 2749 : 			else if (Sms->JDAMPowered && Sms->JDAMInitTimer > 7)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movzx	eax, BYTE PTR [edx+28]
	test	eax, eax
	je	SHORT $LN36@JDAMDispla
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movss	xmm0, DWORD PTR [edx+32]
	comiss	xmm0, DWORD PTR __real@40e00000
	jbe	SHORT $LN36@JDAMDispla

; 2750 : 				LabelButton (6,  "ALIGN");

	push	0
	push	0
	push	OFFSET ??_C@_05OKAJNMKE@ALIGN?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN33@JDAMDispla
$LN36@JDAMDispla:

; 2751 : 			else if (Sms->JDAMPowered && Sms->JDAMInitTimer > 4)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	movzx	edx, BYTE PTR [ecx+28]
	test	edx, edx
	je	SHORT $LN34@JDAMDispla
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	movss	xmm0, DWORD PTR [ecx+32]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN34@JDAMDispla

; 2752 : 				LabelButton (6,  "INIT");

	push	0
	push	0
	push	OFFSET ??_C@_04LGGJDDML@INIT?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2753 : 			else

	jmp	SHORT $LN33@JDAMDispla
$LN34@JDAMDispla:

; 2754 : 				LabelButton (6,  "RDY");

	push	0
	push	0
	push	OFFSET ??_C@_03KDFFCEML@RDY?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN33@JDAMDispla:

; 2755 : 		}
; 2756 : 
; 2757 : 
; 2758 : 		if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN32@JDAMDispla

; 2759 : 		{
; 2760 : 			if (Sms->GetAGBPair())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN31@JDAMDispla

; 2761 : 				LabelButton (7,  "PAIR");

	push	0
	push	0
	push	OFFSET ??_C@_04NFKAHBOI@PAIR?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2762 : 			else

	jmp	SHORT $LN30@JDAMDispla
$LN31@JDAMDispla:

; 2763 : 				LabelButton (7,  "SGL");

	push	0
	push	0
	push	OFFSET ??_C@_03COBKBLOD@SGL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN30@JDAMDispla:

; 2764 : 		}
; 2765 : 		else

	jmp	SHORT $LN29@JDAMDispla
$LN32@JDAMDispla:

; 2766 : 		{
; 2767 : 			if (Sms->GetAGBPair())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@JDAMDispla

; 2768 : 				sprintf(tmpStr, "%d PAIR", Sms->GetAGBRippleCount() + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_07LPGDFIGO@?$CFd?5PAIR?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2769 : 			else

	jmp	SHORT $LN27@JDAMDispla
$LN28@JDAMDispla:

; 2770 : 				sprintf(tmpStr, "%d SGL", Sms->GetAGBRippleCount() + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_06FNBDGPPC@?$CFd?5SGL?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN27@JDAMDispla:

; 2771 : 
; 2772 : 			LabelButton(7, tmpStr);

	push	0
	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN29@JDAMDispla:

; 2773 : 		}
; 2774 : 
; 2775 : 		sprintf (tmpStr, "%dFT", Sms->GetAGBRippleInterval());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBRippleInterval@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleInterval
	push	eax
	push	OFFSET ??_C@_04COHIKBOA@?$CFdFT?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2776 : 		LabelButton (8,  tmpStr);

	push	0
	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2777 : 
; 2778 : 		sprintf(tmpStr, "%d", Sms->GetAGBRippleCount() + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2779 : 		LabelButton(9, "RP", tmpStr);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	OFFSET ??_C@_02NFDNIBGH@RP?$AA@
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2780 : 
; 2781 : 		// RV - Biker - Only display target name if we're in PB
; 2782 : 		//if(g_bRealisticAvionics && !g_bMLU) 
; 2783 : 		if(g_bRealisticAvionics && !g_bMLU) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN22@JDAMDispla
	movzx	ecx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	ecx, ecx
	jne	$LN22@JDAMDispla

; 2784 : 		{
; 2785 : 			if ((Sms->JDAMtargeting == SMSBaseClass::PB && self->JDAMtargetRange > 0) || (CAPplayer)) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN23@JDAMDispla
	mov	ecx, DWORD PTR _self$[ebp]
	movss	xmm0, DWORD PTR [ecx+1772]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN24@JDAMDispla
$LN23@JDAMDispla:
	cmp	DWORD PTR _CAPplayer$[ebp], 0
	je	$LN25@JDAMDispla
$LN24@JDAMDispla:

; 2786 : 			{
; 2787 : 				char tempstr[80]; //JAM 27Sep03 - Changed from 10, stack over run
; 2788 : 				//sprintf(tempstr, "AD %.2fSEC", Sms->armingdelay / 100);
; 2789 : 				sprintf(tempstr,"TGT: %s", self->JDAMtargetName);

	mov	edx, DWORD PTR _self$[ebp]
	add	edx, 1604				; 00000644H
	push	edx
	push	OFFSET ??_C@_07CMDFHNJL@TGT?3?5?$CFs?$AA@
	lea	eax, DWORD PTR _tempstr$12[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2790 : 				display->TextLeft(-0.6F, 0.2F, tempstr);

	push	0
	lea	ecx, DWORD PTR _tempstr$12[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2791 : 				sprintf(tempstr,"OBJ: %s",self->JDAMtargetName1);

	mov	ecx, DWORD PTR _self$[ebp]
	add	ecx, 1684				; 00000694H
	push	ecx
	push	OFFSET ??_C@_07GGAABMKK@OBJ?3?5?$CFs?$AA@
	lea	edx, DWORD PTR _tempstr$12[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2792 : 				display->TextLeft(-0.6F, 0.1F, tempstr);

	push	0
	lea	eax, DWORD PTR _tempstr$12[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2793 : 				
; 2794 : 				sprintf(tempstr,"RNG: %.2f",self->JDAMtargetRange);

	mov	ecx, DWORD PTR _self$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1772]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09MCKHKIBB@RNG?3?5?$CF?42f?$AA@
	lea	edx, DWORD PTR _tempstr$12[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2795 : 				display->TextLeft(-0.6F, 0.0F, tempstr);

	push	0
	lea	eax, DWORD PTR _tempstr$12[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2796 : 			}
; 2797 : 			else 

	jmp	$LN22@JDAMDispla
$LN25@JDAMDispla:

; 2798 : 			{
; 2799 : 				char tempstr[80];
; 2800 : 				float xCurr = pFCC->groundDesignateX;

	mov	ecx, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR [ecx+376]
	movss	DWORD PTR _xCurr$3[ebp], xmm0

; 2801 : 				float yCurr = pFCC->groundDesignateY;

	mov	edx, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR [edx+380]
	movss	DWORD PTR _yCurr$5[ebp], xmm0

; 2802 : 
; 2803 : 				float dX = xCurr - self->XPos();

	mov	ecx, DWORD PTR _self$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv945[ebp]
	movss	xmm0, DWORD PTR _xCurr$3[ebp]
	subss	xmm0, DWORD PTR tv945[ebp]
	movss	DWORD PTR _dX$2[ebp], xmm0

; 2804 : 				float dY = yCurr - self->YPos();

	mov	ecx, DWORD PTR _self$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv950[ebp]
	movss	xmm0, DWORD PTR _yCurr$5[ebp]
	subss	xmm0, DWORD PTR tv950[ebp]
	movss	DWORD PTR _dY$4[ebp], xmm0

; 2805 : 				
; 2806 : 				float latitude	= (FALCON_ORIGIN_LAT * FT_PER_DEGREE + xCurr) / EARTH_RADIUS_FT;

	movss	xmm0, DWORD PTR ?FALCON_ORIGIN_LAT@@3MA
	mulss	xmm0, DWORD PTR __real@45be3840
	mulss	xmm0, DWORD PTR __real@42700000
	addss	xmm0, DWORD PTR _xCurr$3[ebp]
	divss	xmm0, DWORD PTR __real@4b9fa682
	movss	DWORD PTR _latitude$11[ebp], xmm0

; 2807 : 				float cosLatitude = (float)cos(latitude);

	push	ecx
	movss	xmm0, DWORD PTR _latitude$11[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosLatitude$1[ebp]

; 2808 : 				float longitude	= ((FALCON_ORIGIN_LONG * DTR * EARTH_RADIUS_FT * cosLatitude) + yCurr) / (EARTH_RADIUS_FT * cosLatitude);

	movss	xmm0, DWORD PTR ?FALCON_ORIGIN_LONG@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mulss	xmm0, DWORD PTR __real@4b9fa682
	mulss	xmm0, DWORD PTR _cosLatitude$1[ebp]
	addss	xmm0, DWORD PTR _yCurr$5[ebp]
	movss	xmm1, DWORD PTR __real@4b9fa682
	mulss	xmm1, DWORD PTR _cosLatitude$1[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _longitude$10[ebp], xmm0

; 2809 : 			
; 2810 : 				latitude	*= RTD;

	movss	xmm0, DWORD PTR _latitude$11[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _latitude$11[ebp], xmm0

; 2811 : 				longitude	*= RTD;

	movss	xmm0, DWORD PTR _longitude$10[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _longitude$10[ebp], xmm0

; 2812 : 		
; 2813 : 				int   longDeg = FloatToInt32(longitude);

	push	ecx
	movss	xmm0, DWORD PTR _longitude$10[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _longDeg$8[ebp], eax

; 2814 : 				float longMin = (float)fabs(longitude - longDeg) * DEG_TO_MIN;

	cvtsi2ss xmm0, DWORD PTR _longDeg$8[ebp]
	movss	xmm1, DWORD PTR _longitude$10[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv969[ebp]
	movss	xmm0, DWORD PTR tv969[ebp]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR _longMin$6[ebp], xmm0

; 2815 : 
; 2816 : 				int   latDeg = FloatToInt32(latitude);

	push	ecx
	movss	xmm0, DWORD PTR _latitude$11[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _latDeg$7[ebp], eax

; 2817 : 				float latMin = (float)fabs(latitude - latDeg) * DEG_TO_MIN;

	cvtsi2ss xmm0, DWORD PTR _latDeg$7[ebp]
	movss	xmm1, DWORD PTR _latitude$11[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv978[ebp]
	movss	xmm0, DWORD PTR tv978[ebp]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR _latMin$9[ebp], xmm0

; 2818 : 
; 2819 : 				// format lat/long here
; 2820 : 				if(latMin < 10.0F) 

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _latMin$9[ebp]
	jbe	SHORT $LN21@JDAMDispla

; 2821 : 					sprintf(tempstr, "LAT: %3d*0%2.2f\'", latDeg, latMin);

	cvtss2sd xmm0, DWORD PTR _latMin$9[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _latDeg$7[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@KNFNFKJN@LAT?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@
	lea	ecx, DWORD PTR _tempstr$13[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 2822 : 				else 

	jmp	SHORT $LN20@JDAMDispla
$LN21@JDAMDispla:

; 2823 : 					sprintf(tempstr, "LAT: %3d*%2.2f\'", latDeg, latMin);

	cvtss2sd xmm0, DWORD PTR _latMin$9[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _latDeg$7[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@IJOFIFMH@LAT?3?5?$CF3d?$CK?$CF2?42f?8?$AA@
	lea	eax, DWORD PTR _tempstr$13[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
$LN20@JDAMDispla:

; 2824 : 
; 2825 : 				display->TextLeft(-0.6F, 0.2F, tempstr);

	push	0
	lea	ecx, DWORD PTR _tempstr$13[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2826 : 		
; 2827 : 				if(longMin < 10.0F) 

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _longMin$6[ebp]
	jbe	SHORT $LN19@JDAMDispla

; 2828 : 					sprintf(tempstr, "LNG: %3d*0%2.2f\'", longDeg, longMin);

	cvtss2sd xmm0, DWORD PTR _longMin$6[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _longDeg$8[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@HGKIMIJB@LNG?3?5?$CF3d?$CK0?$CF2?42f?8?$AA@
	lea	edx, DWORD PTR _tempstr$13[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 2829 : 				else 

	jmp	SHORT $LN18@JDAMDispla
$LN19@JDAMDispla:

; 2830 : 					sprintf(tempstr, "LNG: %3d*%2.2f\'", longDeg, longMin);

	cvtss2sd xmm0, DWORD PTR _longMin$6[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _longDeg$8[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MHLOFPON@LNG?3?5?$CF3d?$CK?$CF2?42f?8?$AA@
	lea	ecx, DWORD PTR _tempstr$13[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
$LN18@JDAMDispla:

; 2831 : 
; 2832 : 				display->TextLeft(-0.6F, 0.1F, tempstr);

	push	0
	lea	edx, DWORD PTR _tempstr$13[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2833 : 
; 2834 : 				sprintf(tempstr,"RNG: %.2f", SqrtF(dX*dX+dY*dY) * FT_TO_NM);

	movss	xmm0, DWORD PTR _dX$2[ebp]
	mulss	xmm0, DWORD PTR _dX$2[ebp]
	movss	xmm1, DWORD PTR _dY$4[ebp]
	mulss	xmm1, DWORD PTR _dY$4[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtF@@YAMM@Z				; SqrtF
	add	esp, 4
	fstp	DWORD PTR tv1015[ebp]
	movss	xmm0, DWORD PTR tv1015[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09MCKHKIBB@RNG?3?5?$CF?42f?$AA@
	lea	eax, DWORD PTR _tempstr$13[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2835 : 				display->TextLeft(-0.6F, 0.0F, tempstr);

	push	0
	lea	ecx, DWORD PTR _tempstr$13[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN22@JDAMDispla:

; 2836 : 			}
; 2837 : 		}
; 2838 : 
; 2839 : 
; 2840 : 		//OWLOOK we need a switch here for arming delay
; 2841 : 		//if (g_bArmingDelay)	MI
; 2842 : 		if(g_bRealisticAvionics && g_bMLU)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN17@JDAMDispla
	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	je	SHORT $LN17@JDAMDispla

; 2843 : 		{
; 2844 : 			sprintf (tmpStr, "AD %.0f", Sms->armingdelay);//me123 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cvtss2sd xmm0, DWORD PTR [ecx+172]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07JGACOHHB@AD?5?$CF?40f?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2845 : 			LabelButton (15,  tmpStr);//me123 

	push	0
	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN14@JDAMDispla
$LN17@JDAMDispla:

; 2846 : 		}
; 2847 : 		else if(!g_bMLU)

	movzx	ecx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	ecx, ecx
	jne	SHORT $LN15@JDAMDispla

; 2848 : 		{
; 2849 : 			//Target Step
; 2850 : 			LabelButton (15, "TGT", "STEP ^");

	push	0
	push	OFFSET ??_C@_06KANKHHOL@STEP?5?$FO?$AA@
	push	OFFSET ??_C@_03DBNGLLAD@TGT?$AA@
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2851 : 			LabelButton (16, "TGT", "STEP v");

	push	0
	push	OFFSET ??_C@_06PNIHNJEB@STEP?5v?$AA@
	push	OFFSET ??_C@_03DBNGLLAD@TGT?$AA@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2852 : 		}
; 2853 : 		else

	jmp	SHORT $LN14@JDAMDispla
$LN15@JDAMDispla:

; 2854 : 			//Target Step
; 2855 : 			LabelButton (16, "TGT", "STEP");

	push	0
	push	OFFSET ??_C@_04MOOLDHHD@STEP?$AA@
	push	OFFSET ??_C@_03DBNGLLAD@TGT?$AA@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN14@JDAMDispla:

; 2856 : 
; 2857 : 		//MI
; 2858 : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN13@JDAMDispla

; 2859 : 		{
; 2860 : 			switch(Sms->GetAGBFuze())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBFuze@SMSClass@@QAEHXZ		; SMSClass::GetAGBFuze
	mov	DWORD PTR tv668[ebp], eax
	cmp	DWORD PTR tv668[ebp], 0
	je	SHORT $LN10@JDAMDispla
	cmp	DWORD PTR tv668[ebp], 1
	je	SHORT $LN9@JDAMDispla
	cmp	DWORD PTR tv668[ebp], 2
	je	SHORT $LN8@JDAMDispla
	jmp	SHORT $LN11@JDAMDispla
$LN10@JDAMDispla:

; 2861 : 			{
; 2862 : 			case 0:
; 2863 : 				LabelButton (17, "NSTL");

	push	0
	push	0
	push	OFFSET ??_C@_04DANPMIOD@NSTL?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2864 : 				break;

	jmp	SHORT $LN11@JDAMDispla
$LN9@JDAMDispla:

; 2865 : 			case 1:
; 2866 : 				LabelButton (17, "NOSE");

	push	0
	push	0
	push	OFFSET ??_C@_04POJNINAI@NOSE?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2867 : 				break;

	jmp	SHORT $LN11@JDAMDispla
$LN8@JDAMDispla:

; 2868 : 			case 2:
; 2869 : 				LabelButton (17, "TAIL");

	push	0
	push	0
	push	OFFSET ??_C@_04PEGBOIPH@TAIL?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN11@JDAMDispla:

; 2870 : 				break;
; 2871 : 			}
; 2872 : 		}
; 2873 : 		else

	jmp	SHORT $LN7@JDAMDispla
$LN13@JDAMDispla:

; 2874 : 			LabelButton (17, "NSTL");

	push	0
	push	0
	push	OFFSET ??_C@_04DANPMIOD@NSTL?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN7@JDAMDispla:

; 2875 : 		//MI not here in real
; 2876 : 
; 2877 : 		//PB or TOO
; 2878 : 		if (Sms->JDAMtargeting == SMSBaseClass::PB) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN6@JDAMDispla

; 2879 : 		{
; 2880 : 			LabelButton (18, "PB");

	push	0
	push	0
	push	OFFSET ??_C@_02KOENCFNK@PB?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2881 : 			// RV - Biker - Automaically designate JDAMs???  FRB - Yes...Targets are Pre-Programmed
; 2882 : 			if (self->JDAMAllowAutoStep && Sms->JDAMPowered && Sms->JDAMInitTimer <= 4.0f && pFCC->designateCmd == FALSE) 

	mov	eax, DWORD PTR _self$[ebp]
	movzx	ecx, BYTE PTR [eax+1788]
	test	ecx, ecx
	je	SHORT $LN5@JDAMDispla
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movzx	ecx, BYTE PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN5@JDAMDispla
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movss	xmm0, DWORD PTR __real@40800000
	comiss	xmm0, DWORD PTR [eax+32]
	jb	SHORT $LN5@JDAMDispla
	mov	ecx, DWORD PTR _pFCC$[ebp]
	movsx	edx, BYTE PTR [ecx+184]
	test	edx, edx
	jne	SHORT $LN5@JDAMDispla

; 2883 : 			{
; 2884 : 				pFCC->designateCmd = TRUE;

	mov	eax, DWORD PTR _pFCC$[ebp]
	mov	BYTE PTR [eax+184], 1
$LN5@JDAMDispla:

; 2885 : 			}
; 2886 : 		}
; 2887 : 		else 

	jmp	SHORT $LN4@JDAMDispla
$LN6@JDAMDispla:

; 2888 : 			LabelButton (18, "TOO");

	push	0
	push	0
	push	OFFSET ??_C@_03JGPDCBCB@TOO?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN4@JDAMDispla:

; 2889 : 
; 2890 : 		//RV - I-Hawk - GPS targets STEP/NO-STEP display
; 2891 : 		if ( g_bRealisticAvionics )

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN1@JDAMDispla

; 2892 : 		{
; 2893 : 			if ( self->JDAMAllowAutoStep )

	mov	edx, DWORD PTR _self$[ebp]
	movzx	eax, BYTE PTR [edx+1788]
	test	eax, eax
	je	SHORT $LN2@JDAMDispla

; 2894 : 			{
; 2895 : 				LabelButton (19, "AUTO STEP");

	push	0
	push	0
	push	OFFSET ??_C@_09MGHNDNCF@AUTO?5STEP?$AA@
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2896 : 			}
; 2897 : 			else

	jmp	SHORT $LN1@JDAMDispla
$LN2@JDAMDispla:

; 2898 : 			{
; 2899 : 				LabelButton (19, "MAN" , "STEP");

	push	0
	push	OFFSET ??_C@_04MOOLDHHD@STEP?$AA@
	push	OFFSET ??_C@_03KIGHCFHP@MAN?$AA@
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@JDAMDispla:

; 2900 : 			}
; 2901 : 		}
; 2902 :         	
; 2903 : 		ShowMissiles(5);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowMissiles@SmsDrawable@@AAEXH@Z	; SmsDrawable::ShowMissiles
$LN43@JDAMDispla:
$LN50@JDAMDispla:

; 2904 : 	}
; 2905 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?JDAMDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::JDAMDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_bit$ = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_hp$ = 8						; size = 4
?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z PROC	; SmsDrawable::StepSelectiveJettisonMode
; _this$ = ecx

; 1402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1403 : 	int bit = 1 << hp;

	mov	eax, 1
	mov	ecx, DWORD PTR _hp$[ebp]
	shl	eax, cl
	mov	DWORD PTR _bit$[ebp], eax

; 1404 : 
; 1405 : 	//if(Sms->hardPoint[hp]->GetRackDataFlags() & RDF_BMSDEFINITION)
; 1406 : 	{
; 1407 : 		switch(sjSelected[hp])

	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+36]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN5@StepSelect
	cmp	DWORD PTR tv68[ebp], 4
	je	SHORT $LN3@StepSelect
	jmp	$LN1@StepSelect
$LN5@StepSelect:

; 1408 : 		{
; 1409 : 		case JettisonNone:
; 1410 : 			sjSelected[hp] = SelectiveWeapon;

	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+36], 4

; 1411 : 			if((Sms->hardPoint[hp]->GetRackDataFlags() & RDF_SELECTIVE_JETT_WEAPON))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+104]
	call	edx
	and	eax, 4
	je	SHORT $LN3@StepSelect

; 1412 : 				break;

	jmp	SHORT $LN8@StepSelect
$LN3@StepSelect:

; 1413 : 
; 1414 : 		case SelectiveWeapon:
; 1415 : 			sjSelected[hp] = SelectiveRack;

	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+36], 12		; 0000000cH

; 1416 : 			if((Sms->hardPoint[hp]->GetRackDataFlags() & RDF_SELECTIVE_JETT_RACK))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax+104]
	call	edx
	and	eax, 16					; 00000010H
	je	SHORT $LN1@StepSelect

; 1417 : 				break;

	jmp	SHORT $LN8@StepSelect
$LN1@StepSelect:

; 1418 : 
; 1419 : 		case SelectiveRack:
; 1420 : 		default:
; 1421 : 			sjSelected[hp] = JettisonNone;

	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+36], 0
$LN8@StepSelect:

; 1422 : 			break;
; 1423 : 		}
; 1424 : 	}
; 1425 : 	/*
; 1426 : 	else
; 1427 : 	{   // SP3 data compatible
; 1428 : 		switch(sjSelected[hp])
; 1429 : 		{
; 1430 : 		case JettisonNone:
; 1431 : 			sjSelected[hp] = SelectiveRack;
; 1432 : 			break;
; 1433 : 		case SelectiveRack:
; 1434 : 		default:
; 1435 : 			sjSelected[hp] = JettisonNone;
; 1436 : 			break;
; 1437 : 		}
; 1438 : 	}
; 1439 : 	*/
; 1440 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ENDP	; SmsDrawable::StepSelectiveJettisonMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_playerAC$ = -20					; size = 4
_this$ = -16						; size = 4
_pradar$ = -12						; size = 4
tv94 = -8						; size = 4
_pFCC$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?WpnAGMenu@SmsDrawable@@AAEXHH@Z PROC			; SmsDrawable::WpnAGMenu
; _this$ = ecx

; 1173 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1174 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1175 : 	RadarDopplerClass* pradar = (RadarDopplerClass*) FindSensor (playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$[ebp], eax

; 1176 :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	mov	DWORD PTR _pFCC$[ebp], eax

; 1177 : 	if(pradar)	//MI fix

	cmp	DWORD PTR _pradar$[ebp], 0
	je	SHORT $LN9@WpnAGMenu

; 1178 : 		pradar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pradar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir
$LN9@WpnAGMenu:

; 1179 :     switch(whichButton) {

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	sub	ecx, 15					; 0000000fH
	mov	DWORD PTR tv94[ebp], ecx
	cmp	DWORD PTR tv94[ebp], 4
	ja	SHORT $LN1@WpnAGMenu
	mov	edx, DWORD PTR tv94[ebp]
	jmp	DWORD PTR $LN12@WpnAGMenu[edx*4]
$LN6@WpnAGMenu:

; 1180 :     case 19:
; 1181 : 		pFCC->SetSubMode(FireControlComputer::CCIP); // MLR 4/4/2004 - SetSubMode calls Sms->SetAGBSubMode()

	push	7
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1182 : 		break;

	jmp	SHORT $LN7@WpnAGMenu
$LN5@WpnAGMenu:

; 1183 :     case 18:
; 1184 : 		pFCC->SetSubMode(FireControlComputer::CCRP);

	push	8
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1185 : 		pradar->SelectLastAGMode();

	mov	eax, DWORD PTR _pradar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1186 : 		break;

	jmp	SHORT $LN7@WpnAGMenu
$LN4@WpnAGMenu:

; 1187 :     case 17:
; 1188 : 		pFCC->SetSubMode(FireControlComputer::DTOSS);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1189 : 		break;

	jmp	SHORT $LN7@WpnAGMenu
$LN3@WpnAGMenu:

; 1190 :     case 16:
; 1191 : 		pFCC->SetSubMode(FireControlComputer::LADD);

	push	9
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1192 : 		break;

	jmp	SHORT $LN7@WpnAGMenu
$LN2@WpnAGMenu:

; 1193 :     case 15:
; 1194 : 		pFCC->SetSubMode(FireControlComputer::MAN);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1195 : 		break;

	jmp	SHORT $LN7@WpnAGMenu
$LN1@WpnAGMenu:

; 1196 :     default:
; 1197 : 		return; // nothing interesting

	jmp	SHORT $LN10@WpnAGMenu
$LN7@WpnAGMenu:

; 1198 :     }
; 1199 :     UnsetFlag(MENUMODE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ; SmsDrawable::UnsetFlag
$LN10@WpnAGMenu:

; 1200 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN12@WpnAGMenu:
	DD	$LN2@WpnAGMenu
	DD	$LN3@WpnAGMenu
	DD	$LN4@WpnAGMenu
	DD	$LN5@WpnAGMenu
	DD	$LN6@WpnAGMenu
?WpnAGMenu@SmsDrawable@@AAEXHH@Z ENDP			; SmsDrawable::WpnAGMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv229 = -24						; size = 4
tv206 = -20						; size = 4
tv134 = -16						; size = 4
tv76 = -12						; size = 4
_cw$ = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMfd$ = 12						; size = 4
?WpnAAMissileButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::WpnAAMissileButton
; _this$ = ecx

; 2005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2006 : 	SimWeaponClass *cw = Sms->GetCurrentWeapon();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _cw$[ebp], eax

; 2007 : 	switch(whichButton) {

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 16			; 00000010H
	ja	$LN24@WpnAAMissi
	mov	edx, DWORD PTR tv76[ebp]
	movzx	eax, BYTE PTR $LN32@WpnAAMissi[edx]
	jmp	DWORD PTR $LN33@WpnAAMissi[eax*4]
$LN21@WpnAAMissi:

; 2008 : 		// Marco Edit - SPOT/SCAN Mode
; 2009 : 		case 2:
; 2010 : 			if (g_bRealisticAvionics && cw && Sms->curWeaponType == wtAim9){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN20@WpnAAMissi
	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN20@WpnAAMissi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 1
	jne	SHORT $LN20@WpnAAMissi

; 2011 : 				//MI fixup... only toggle for the 9M
; 2012 : 				if (cw->GetSPType() != SPTYPE_AIM9P){

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetSPType@SimBaseClass@@QBEEXZ		; SimBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN20@WpnAAMissi

; 2013 : 					((MissileClass*)cw)->isSpot = !((MissileClass*)cw)->isSpot;

	mov	edx, DWORD PTR _cw$[ebp]
	cmp	DWORD PTR [edx+732], 0
	jne	SHORT $LN26@WpnAAMissi
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN27@WpnAAMissi
$LN26@WpnAAMissi:
	mov	DWORD PTR tv134[ebp], 0
$LN27@WpnAAMissi:
	mov	eax, DWORD PTR _cw$[ebp]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR [eax+732], ecx
$LN20@WpnAAMissi:

; 2014 : 				}
; 2015 : 			}
; 2016 : 		break;

	jmp	$LN24@WpnAAMissi
$LN18@WpnAAMissi:

; 2017 :     case 7:
; 2018 : 		if (Sms->curWeaponType == wtAim120) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 2
	jne	SHORT $LN17@WpnAAMissi

; 2019 : 			// code for AIM120 BIT test
; 2020 : 		}
; 2021 : 		//MI only with M's
; 2022 : 		else if (

	jmp	SHORT $LN16@WpnAAMissi
$LN17@WpnAAMissi:

; 2023 : 			Sms->curWeaponType == wtAim9 && 
; 2024 : 			cw->GetSPType() != SPTYPE_AIM9P
; 2025 : 		){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN16@WpnAAMissi
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetSPType@SimBaseClass@@QBEEXZ		; SimBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN16@WpnAAMissi

; 2026 : 			if (Sms->GetCoolState() == SMSClass::WARM || Sms->GetCoolState() == SMSClass::WARMING) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	test	eax, eax
	je	SHORT $LN13@WpnAAMissi
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	cmp	eax, 3
	jne	SHORT $LN14@WpnAAMissi
$LN13@WpnAAMissi:

; 2027 : 			{
; 2028 : 				/*if (Sms->aim9warmtime != 0.0)
; 2029 : 				{
; 2030 : 					Sms->aim9cooltime = (SimLibElapsedTime + 3 * CampaignSeconds) - ((Sms->aim9warmtime - SimLibElapsedTime) / 20); // 20 = 60/3
; 2031 : 					Sms->aim9warmtime = 0.0;
; 2032 : 				}
; 2033 : 				else
; 2034 : 				{
; 2035 : 					Sms->aim9cooltime = SimLibElapsedTime + 3 * CampaignSeconds; // in 3 seconds
; 2036 : 				}*/
; 2037 : 				Sms->SetCoolState(SMSClass::COOLING);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState
$LN14@WpnAAMissi:

; 2038 : 			}
; 2039 : 			if (Sms->GetCoolState() == SMSClass::COOL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	cmp	eax, 2
	jne	SHORT $LN16@WpnAAMissi

; 2040 : 			{
; 2041 : 				//Sms->aim9warmtime = SimLibElapsedTime + 60 * CampaignSeconds; // in 60 seconds
; 2042 : 				Sms->SetCoolState(SMSClass::WARMING);

	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState
$LN16@WpnAAMissi:

; 2043 : 			}
; 2044 : 		}
; 2045 : 	break;

	jmp	$LN24@WpnAAMissi
$LN10@WpnAAMissi:

; 2046 :     case 8:
; 2047 : 		if (Sms->curWeaponType == wtAim120) {
; 2048 : 			// code for AIM120 ALBIT test
; 2049 : 		}
; 2050 : 	break;

	jmp	$LN24@WpnAAMissi
$LN9@WpnAAMissi:

; 2051 :     case 16:
; 2052 : 		if (Sms->curWeaponType == wtAim120) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 2
	jne	SHORT $LN8@WpnAAMissi

; 2053 : 			Sms->NextAimId(); // JPO bump the AIM 120 id.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?NextAimId@SMSClass@@QAEXXZ		; SMSClass::NextAimId
$LN8@WpnAAMissi:

; 2054 : 		}
; 2055 : 	break;

	jmp	$LN24@WpnAAMissi
$LN6@WpnAAMissi:

; 2056 :     case 17:
; 2057 : 		if (Sms->curWeaponType == wtAim120) {
; 2058 : 			// code for AIM120 Telemetry toggle
; 2059 : 		}
; 2060 : 		if (Sms->curWeaponType == wtAim9)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN5@WpnAAMissi

; 2061 : 		{
; 2062 : 			// Marco Edit - Auto Uncage TD/BP Mode
; 2063 : 			if (g_bRealisticAvionics && cw && Sms->curWeaponType == wtAim9){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN5@WpnAAMissi
	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN5@WpnAAMissi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN5@WpnAAMissi

; 2064 : 				//MI fixup... only toggle for pM
; 2065 : 				if(cw->GetSPType() != SPTYPE_AIM9P){

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetSPType@SimBaseClass@@QBEEXZ		; SimBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN5@WpnAAMissi

; 2066 : 					((MissileClass*)cw)->isTD = !((MissileClass*)cw)->isTD;

	mov	ecx, DWORD PTR _cw$[ebp]
	cmp	DWORD PTR [ecx+740], 0
	jne	SHORT $LN28@WpnAAMissi
	mov	DWORD PTR tv206[ebp], 1
	jmp	SHORT $LN29@WpnAAMissi
$LN28@WpnAAMissi:
	mov	DWORD PTR tv206[ebp], 0
$LN29@WpnAAMissi:
	mov	edx, DWORD PTR _cw$[ebp]
	mov	eax, DWORD PTR tv206[ebp]
	mov	DWORD PTR [edx+740], eax
$LN5@WpnAAMissi:

; 2067 : 				}
; 2068 : 			}
; 2069 : 		}
; 2070 : 	break;

	jmp	SHORT $LN24@WpnAAMissi
$LN2@WpnAAMissi:

; 2071 :     case 18:
; 2072 : 		//MI fixup... only for the M
; 2073 : 		if (g_bRealisticAvionics && cw && cw->GetSPType() != SPTYPE_AIM9P) {

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN24@WpnAAMissi
	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN24@WpnAAMissi
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetSPType@SimBaseClass@@QBEEXZ		; SimBaseClass::GetSPType
	movzx	edx, al
	cmp	edx, 17					; 00000011H
	je	SHORT $LN24@WpnAAMissi

; 2074 : 			((MissileClass*)cw)->isSlave = !((MissileClass*)cw)->isSlave;

	mov	eax, DWORD PTR _cw$[ebp]
	cmp	DWORD PTR [eax+736], 0
	jne	SHORT $LN30@WpnAAMissi
	mov	DWORD PTR tv229[ebp], 1
	jmp	SHORT $LN31@WpnAAMissi
$LN30@WpnAAMissi:
	mov	DWORD PTR tv229[ebp], 0
$LN31@WpnAAMissi:
	mov	ecx, DWORD PTR _cw$[ebp]
	mov	edx, DWORD PTR tv229[ebp]
	mov	DWORD PTR [ecx+736], edx
$LN24@WpnAAMissi:

; 2075 : 		}
; 2076 : 	break;
; 2077 :    }
; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN33@WpnAAMissi:
	DD	$LN21@WpnAAMissi
	DD	$LN18@WpnAAMissi
	DD	$LN10@WpnAAMissi
	DD	$LN9@WpnAAMissi
	DD	$LN6@WpnAAMissi
	DD	$LN2@WpnAAMissi
	DD	$LN24@WpnAAMissi
$LN32@WpnAAMissi:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	5
?WpnAAMissileButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::WpnAAMissileButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv78 = -12						; size = 4
_this$ = -8						; size = 4
_pFCC$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?WpnOtherPushButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::WpnOtherPushButton
; _this$ = ecx

; 1204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1205 :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 1206 : 
; 1207 :     switch (whichButton)

	mov	ecx, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 15			; 0000000fH
	ja	SHORT $LN1@WpnOtherPu
	mov	edx, DWORD PTR tv78[ebp]
	movzx	eax, BYTE PTR $LN14@WpnOtherPu[edx]
	jmp	DWORD PTR $LN15@WpnOtherPu[eax*4]
$LN9@WpnOtherPu:

; 1208 :     {
; 1209 :     case 0:
; 1210 : 	break;

	jmp	SHORT $LN12@WpnOtherPu
$LN8@WpnOtherPu:

; 1211 :     case 1:
; 1212 : 	if(pFCC->GetMasterMode() == FireControlComputer::Dogfight && g_bRealisticAvionics)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN7@WpnOtherPu
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN7@WpnOtherPu

; 1213 : 	{	
; 1214 : 		pFCC->NextSubMode(); // MLR 4/2/2004 - 

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?NextSubMode@FireControlComputer@@QAEXXZ ; FireControlComputer::NextSubMode

; 1215 : 		break;

	jmp	SHORT $LN12@WpnOtherPu
$LN7@WpnOtherPu:

; 1216 : 	}
; 1217 : 
; 1218 : 	break;

	jmp	SHORT $LN12@WpnOtherPu
$LN6@WpnOtherPu:

; 1219 : 	
; 1220 : 	case 5: // MLR 2/8/2004 - simplified
; 1221 : 		if(pFCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN5@WpnOtherPu

; 1222 : 			break;

	jmp	SHORT $LN12@WpnOtherPu
$LN5@WpnOtherPu:

; 1223 : 
; 1224 : 		Sms->StepAAWeapon();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon

; 1225 : 		break;

	jmp	SHORT $LN12@WpnOtherPu
$LN4@WpnOtherPu:

; 1226 : 
; 1227 : 	case 6: // MLR 2/8/2004 - simplified
; 1228 : 		if(pFCC->GetMasterMode() != FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN3@WpnOtherPu

; 1229 : 			break;

	jmp	SHORT $LN12@WpnOtherPu
$LN3@WpnOtherPu:

; 1230 : 
; 1231 : 		Sms->StepAAWeapon();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon

; 1232 : 		break;

	jmp	SHORT $LN12@WpnOtherPu
$LN2@WpnOtherPu:

; 1233 : 	
; 1234 :     case 9:
; 1235 :     case 15:
; 1236 :         pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep

; 1237 : 	break;

	jmp	SHORT $LN12@WpnOtherPu
$LN1@WpnOtherPu:

; 1238 : 	
; 1239 :     default:
; 1240 : 	WpnAAMissileButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAAMissileButton@SmsDrawable@@AAEXHH@Z ; SmsDrawable::WpnAAMissileButton
$LN12@WpnOtherPu:

; 1241 : 	break;
; 1242 :    }
; 1243 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN15@WpnOtherPu:
	DD	$LN9@WpnOtherPu
	DD	$LN8@WpnOtherPu
	DD	$LN6@WpnOtherPu
	DD	$LN4@WpnOtherPu
	DD	$LN2@WpnOtherPu
	DD	$LN1@WpnOtherPu
$LN14@WpnOtherPu:
	DB	0
	DB	1
	DB	5
	DB	5
	DB	5
	DB	2
	DB	3
	DB	5
	DB	5
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?WpnOtherPushButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::WpnOtherPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?WpnNavPushButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::WpnNavPushButton
; _this$ = ecx

; 1247 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1248 :     MonoPrint("Sms Weapon in Nav mode\n");

	push	OFFSET ??_C@_0BI@FDKECMHJ@Sms?5Weapon?5in?5Nav?5mode?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 1249 :     // shouldn't happen.
; 1250 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?WpnNavPushButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::WpnNavPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv78 = -12						; size = 4
_this$ = -8						; size = 4
_pFCC$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?WpnAAPushButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::WpnAAPushButton
; _this$ = ecx

; 1254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1255 :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 1256 : 
; 1257 :     switch (whichButton)

	mov	ecx, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 15			; 0000000fH
	ja	SHORT $LN2@WpnAAPushB
	mov	edx, DWORD PTR tv78[ebp]
	movzx	eax, BYTE PTR $LN14@WpnAAPushB[edx]
	jmp	DWORD PTR $LN15@WpnAAPushB[eax*4]
$LN9@WpnAAPushB:

; 1258 :     {
; 1259 :     case 0: // in AA between guns and missiles.
; 1260 : 		pFCC->ToggleAAGunMode();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?ToggleAAGunMode@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleAAGunMode

; 1261 : 
; 1262 : 	break;

	jmp	SHORT $LN12@WpnAAPushB
$LN8@WpnAAPushB:

; 1263 :     case 1:
; 1264 : 	if (pFCC->GetMasterMode() == FireControlComputer::AAGun)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	test	eax, eax
	jne	SHORT $LN7@WpnAAPushB

; 1265 : 	{
; 1266 : 	    pFCC->NextSubMode();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?NextSubMode@FireControlComputer@@QAEXXZ ; FireControlComputer::NextSubMode
$LN7@WpnAAPushB:

; 1267 : 	}
; 1268 : 	break;

	jmp	SHORT $LN12@WpnAAPushB
$LN6@WpnAAPushB:

; 1269 : 	
; 1270 : 	case 5: // MLR 2/8/2004 - simplified
; 1271 : 		if(pFCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN5@WpnAAPushB

; 1272 : 			break;

	jmp	SHORT $LN12@WpnAAPushB
$LN5@WpnAAPushB:

; 1273 : 
; 1274 : 		Sms->StepAAWeapon();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon

; 1275 : 		break;

	jmp	SHORT $LN12@WpnAAPushB

; 1276 : 
; 1277 : 	break;

	jmp	SHORT $LN12@WpnAAPushB
$LN4@WpnAAPushB:

; 1278 : 	
; 1279 :     case 9:
; 1280 :     case 15:
; 1281 : 	if(pFCC->GetMasterMode() == FireControlComputer::Missile)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 2
	jne	SHORT $LN3@WpnAAPushB

; 1282 : 	    pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep
$LN3@WpnAAPushB:

; 1283 : 	break;

	jmp	SHORT $LN12@WpnAAPushB
$LN2@WpnAAPushB:

; 1284 : 	
; 1285 :     default:
; 1286 : 	if(pFCC->GetMasterMode() == FireControlComputer::Missile)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 2
	jne	SHORT $LN12@WpnAAPushB

; 1287 : 	    WpnAAMissileButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAAMissileButton@SmsDrawable@@AAEXHH@Z ; SmsDrawable::WpnAAMissileButton
$LN12@WpnAAPushB:

; 1288 : 	break;
; 1289 :    }
; 1290 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN15@WpnAAPushB:
	DD	$LN9@WpnAAPushB
	DD	$LN8@WpnAAPushB
	DD	$LN6@WpnAAPushB
	DD	$LN4@WpnAAPushB
	DD	$LN2@WpnAAPushB
$LN14@WpnAAPushB:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?WpnAAPushButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::WpnAAPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_playerAC$ = -40					; size = 4
_laserPod$1 = -36					; size = 4
_mavDisplay$2 = -32					; size = 4
tv80 = -28						; size = 4
_i$3 = -24						; size = 4
_laserPod$4 = -20					; size = 4
_self$ = -16						; size = 4
_pFCC$ = -12						; size = 4
_this$ = -8						; size = 4
tv329 = -2						; size = 1
tv317 = -1						; size = 1
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?WpnAGPushButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::WpnAGPushButton
; _this$ = ecx

; 840  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 841  :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 842  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 843  : 	AircraftClass *self = ((AircraftClass*)playerAC);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	DWORD PTR _self$[ebp], ecx

; 844  : 
; 845  :     switch (whichButton)

	mov	edx, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 19			; 00000013H
	ja	$LN99@WpnAGPushB
	mov	eax, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN105@WpnAGPushB[eax*4]
$LN96@WpnAGPushB:

; 846  :     {
; 847  :     case 0:   // in AG mode, toggle between guns and bombs
; 848  : 		pFCC->ToggleAGGunMode();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?ToggleAGGunMode@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleAGGunMode

; 849  : 	break;

	jmp	$LN99@WpnAGPushB
$LN95@WpnAGPushB:

; 850  :     case 1:
; 851  : 	if (g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN94@WpnAGPushB

; 852  : 	{
; 853  : 		//MI temporary until we can get the LGB's going
; 854  : 		if(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser  ||
; 855  : 		   pFCC->GetMasterMode() == FireControlComputer::AirGroundRocket || // MLR 4/3/2004 - 
; 856  : 		   pFCC->GetMasterMode() == FireControlComputer::AGGun)//           || // MLR 4/3/2004 - 

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	je	SHORT $LN92@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN92@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 1
	jne	SHORT $LN93@WpnAGPushB
$LN92@WpnAGPushB:

; 857  : 		   //pFCC->GetSubMode()    == FireControlComputer::OBSOLETERCKT) // MLR 4/3/2004 - 
; 858  : 			break;

	jmp	$LN99@WpnAGPushB
$LN93@WpnAGPushB:

; 859  : 			
; 860  : 		
; 861  : 	    ToggleFlag(MENUMODE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ; SmsDrawable::ToggleFlag

; 862  : 	}
; 863  : 	else

	jmp	SHORT $LN91@WpnAGPushB
$LN94@WpnAGPushB:

; 864  : 	    pFCC->NextSubMode();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?NextSubMode@FireControlComputer@@QAEXXZ ; FireControlComputer::NextSubMode
$LN91@WpnAGPushB:

; 865  : 	break;

	jmp	$LN99@WpnAGPushB
$LN90@WpnAGPushB:

; 866  : 	
; 867  :     case 2:
; 868  : 	if (Sms->curWeaponType == wtAgm65 && Sms->curWeapon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 4
	jne	SHORT $LN89@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN89@WpnAGPushB

; 869  : 	{
; 870  : 		ShiAssert(Sms->curWeapon->IsMissile());
; 871  : 		MaverickDisplayClass* mavDisplay =
; 872  : 		(MaverickDisplayClass*)((MissileClass*)Sms->GetCurrentWeapon())->display;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	eax, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$2[ebp], eax

; 873  : 
; 874  : 		if (mavDisplay){

	cmp	DWORD PTR _mavDisplay$2[ebp], 0
	je	SHORT $LN88@WpnAGPushB

; 875  : 			mavDisplay->ToggleFOV();

	mov	ecx, DWORD PTR _mavDisplay$2[ebp]
	call	?ToggleFOV@MaverickDisplayClass@@QAEXXZ	; MaverickDisplayClass::ToggleFOV
$LN88@WpnAGPushB:

; 876  : 		}
; 877  : 	}

	jmp	SHORT $LN87@WpnAGPushB
$LN89@WpnAGPushB:

; 878  : 	else if (Sms->curWeaponClass == wcGbuWpn)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN87@WpnAGPushB

; 879  : 	{
; 880  : 		LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (Sms->ownship);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 881  : 
; 882  : 		if (laserPod)

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	SHORT $LN87@WpnAGPushB

; 883  : 		{
; 884  : 			laserPod->ToggleFOV();

	mov	ecx, DWORD PTR _laserPod$1[ebp]
	call	?ToggleFOV@LaserPodClass@@QAEXXZ	; LaserPodClass::ToggleFOV
$LN87@WpnAGPushB:

; 885  : 		}
; 886  : 	}
; 887  : 	break;

	jmp	$LN99@WpnAGPushB
$LN84@WpnAGPushB:

; 888  : 
; 889  : 	//MI
; 890  : 	case 4:
; 891  : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN83@WpnAGPushB

; 892  : 		{
; 893  : 			if((pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) || //me123 status test. addet four lines
; 894  : 				(pFCC->GetMasterMode() == FireControlComputer::AirGroundRocket) || // MLR 4/3/2004 - 
; 895  : 				(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser))

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN81@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN81@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN83@WpnAGPushB
$LN81@WpnAGPushB:

; 896  : 			{
; 897  : 				ChangeToInput(whichButton);

	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeToInput@SmsDrawable@@QAEXH@Z	; SmsDrawable::ChangeToInput
$LN83@WpnAGPushB:

; 898  : 			}
; 899  : 		}
; 900  : 	break;

	jmp	$LN99@WpnAGPushB
$LN80@WpnAGPushB:

; 901  : 	
; 902  :     case 5:
; 903  : 		Sms->StepAGWeapon(); // MLR 2/8/2004 - changed to use the new step code

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?StepAGWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAGWeapon

; 904  : 		//Sms->GetNextWeapon(wdGround);
; 905  : 	
; 906  : 		//MI
; 907  : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN79@WpnAGPushB

; 908  : 		{
; 909  : 			SetWeapParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWeapParams@SmsDrawable@@QAEXXZ	; SmsDrawable::SetWeapParams
$LN79@WpnAGPushB:

; 910  : 		}
; 911  : 		break;

	jmp	$LN99@WpnAGPushB
$LN78@WpnAGPushB:

; 912  : 		//MI
; 913  : 	case 6:	
; 914  : 		if (isJDAM || isJSOW)

	movzx	ecx, BYTE PTR ?isJDAM@@3_NA		; isJDAM
	test	ecx, ecx
	jne	SHORT $LN76@WpnAGPushB
	movzx	edx, BYTE PTR ?isJSOW@@3_NA		; isJSOW
	test	edx, edx
	je	$LN77@WpnAGPushB
$LN76@WpnAGPushB:

; 915  : 			{
; 916  : 			if (!Sms->JDAMPowered && Sms->curWeapon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	movzx	edx, BYTE PTR [ecx+28]
	test	edx, edx
	jne	SHORT $LN75@WpnAGPushB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN75@WpnAGPushB

; 917  : 				{
; 918  : 				Sms->JDAMPowered = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	BYTE PTR [eax+28], 1

; 919  : 				break;

	jmp	$LN99@WpnAGPushB
	jmp	SHORT $LN77@WpnAGPushB
$LN75@WpnAGPushB:

; 920  : 				}
; 921  : 			else if (Sms->JDAMPowered && !Sms->curWeapon)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movzx	eax, BYTE PTR [edx+28]
	test	eax, eax
	je	SHORT $LN73@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	add	ecx, 164				; 000000a4H
	call	??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator!
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN73@WpnAGPushB

; 922  : 				{
; 923  : 				Sms->JDAMPowered = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	BYTE PTR [ecx+28], 0

; 924  : 				break;

	jmp	$LN99@WpnAGPushB

; 925  : 				}
; 926  : 			else 

	jmp	SHORT $LN77@WpnAGPushB
$LN73@WpnAGPushB:

; 927  : 				{
; 928  : 				Sms->JDAMPowered = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	BYTE PTR [eax+28], 0

; 929  : 				break;

	jmp	$LN99@WpnAGPushB
$LN77@WpnAGPushB:

; 930  : 				}
; 931  : 			}
; 932  : 		if(!g_bRealisticAvionics || Sms->CurHardpoint() < 0)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN70@WpnAGPushB
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jge	SHORT $LN71@WpnAGPushB
$LN70@WpnAGPushB:

; 933  : 			break;

	jmp	$LN99@WpnAGPushB
$LN71@WpnAGPushB:

; 934  : 
; 935  : 		if(( pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) || //me123 status test. addet four lines
; 936  : 			(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser) )

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN68@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN69@WpnAGPushB
$LN68@WpnAGPushB:

; 937  : 		{ 
; 938  : 			ChangeProf();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeProf@SmsDrawable@@QAEXXZ		; SmsDrawable::ChangeProf

; 939  : 			SetWeapParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWeapParams@SmsDrawable@@QAEXXZ	; SmsDrawable::SetWeapParams

; 940  : 		}
; 941  : 		else 

	jmp	SHORT $LN67@WpnAGPushB
$LN69@WpnAGPushB:

; 942  : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile &&
; 943  : 				Sms->curWeaponType == wtAgm65)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN66@WpnAGPushB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 4
	jne	SHORT $LN66@WpnAGPushB

; 944  : 			{
; 945  : 				Sms->ToggleMavPower();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?ToggleMavPower@SMSBaseClass@@QAEXXZ	; SMSBaseClass::ToggleMavPower

; 946  : 			}
; 947  : 
; 948  : 		// RV - I-Hawk - HARM power
; 949  : 		else 

	jmp	SHORT $LN67@WpnAGPushB
$LN66@WpnAGPushB:

; 950  : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundHARM &&
; 951  : 				Sms->curWeaponType == wtAgm88)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 7
	jne	SHORT $LN67@WpnAGPushB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 3
	jne	SHORT $LN67@WpnAGPushB

; 952  : 			{
; 953  : 				Sms->ToggleHARMPower();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?ToggleHARMPower@SMSBaseClass@@QAEXXZ	; SMSBaseClass::ToggleHARMPower
$LN67@WpnAGPushB:

; 954  : 			}
; 955  : 
; 956  : 	break;

	jmp	$LN99@WpnAGPushB
$LN63@WpnAGPushB:

; 957  : 
; 958  :     case 7:
; 959  : 		if(g_bRealisticAvionics && Sms->CurHardpoint() >= 0)	//MI

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN62@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	SHORT $LN62@WpnAGPushB

; 960  : 		{
; 961  : 			if((pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb  ) || //me123 status test. addet four lines
; 962  : 				(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser) ||
; 963  : 				pFCC->GetMasterMode() == FireControlComputer::AirGroundRocket)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN60@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	je	SHORT $LN60@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN61@WpnAGPushB
$LN60@WpnAGPushB:

; 964  : 			{
; 965  : 				Sms->SetAGBPair(!Sms->GetAGBPair());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN101@WpnAGPushB
	mov	BYTE PTR tv317[ebp], 1
	jmp	SHORT $LN102@WpnAGPushB
$LN101@WpnAGPushB:
	mov	BYTE PTR tv317[ebp], 0
$LN102@WpnAGPushB:
	movzx	ecx, BYTE PTR tv317[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?SetAGBPair@SMSClass@@QAEX_N@Z		; SMSClass::SetAGBPair
$LN61@WpnAGPushB:

; 966  : 			}
; 967  : 		}
; 968  : 		else

	jmp	SHORT $LN59@WpnAGPushB
$LN62@WpnAGPushB:

; 969  : 		{
; 970  : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) //me123 status test. addet four lines

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	jne	SHORT $LN59@WpnAGPushB

; 971  : 			{
; 972  : 				Sms->SetAGBPair(!Sms->GetAGBPair());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN103@WpnAGPushB
	mov	BYTE PTR tv329[ebp], 1
	jmp	SHORT $LN104@WpnAGPushB
$LN103@WpnAGPushB:
	mov	BYTE PTR tv329[ebp], 0
$LN104@WpnAGPushB:
	movzx	edx, BYTE PTR tv329[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?SetAGBPair@SMSClass@@QAEX_N@Z		; SMSClass::SetAGBPair
$LN59@WpnAGPushB:

; 973  : 				/*
; 974  : 				if (Sms->pair)
; 975  : 					Sms->SetPair(FALSE);
; 976  : 				else
; 977  : 					Sms->SetPair(TRUE);
; 978  : 				*/
; 979  : 			}
; 980  : 		}
; 981  : 	break;

	jmp	$LN99@WpnAGPushB
$LN57@WpnAGPushB:

; 982  : 	
; 983  :     case 8:
; 984  : 		if(g_bRealisticAvionics && Sms->CurHardpoint() >= 0)	//MI

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN56@WpnAGPushB
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	SHORT $LN56@WpnAGPushB

; 985  : 		{
; 986  : 			if((pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) || //me123 status test. addet four lines
; 987  : 				(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser))

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN54@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN55@WpnAGPushB
$LN54@WpnAGPushB:

; 988  : 			{
; 989  : 				ChangeToInput(whichButton);

	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeToInput@SmsDrawable@@QAEXH@Z	; SmsDrawable::ChangeToInput
$LN55@WpnAGPushB:

; 990  : 			}
; 991  : 		}
; 992  : 		else

	jmp	SHORT $LN53@WpnAGPushB
$LN56@WpnAGPushB:

; 993  : 		{
; 994  : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) //me123 status test. addet four lines

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	jne	SHORT $LN53@WpnAGPushB

; 995  : 				Sms->IncrementRippleInterval();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?IncrementRippleInterval@SMSClass@@QAEXXZ ; SMSClass::IncrementRippleInterval
$LN53@WpnAGPushB:

; 996  : 		}
; 997  : 	break;

	jmp	$LN99@WpnAGPushB
$LN51@WpnAGPushB:

; 998  : 	
; 999  :     case 9:
; 1000 : 		if(g_bRealisticAvionics && Sms->CurHardpoint() >= 0)	//MI

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN50@WpnAGPushB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	SHORT $LN50@WpnAGPushB

; 1001 : 		{
; 1002 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN49@WpnAGPushB

; 1003 : 				pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep

; 1004 : 			else if((pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) || //me123 status test. addet four lines

	jmp	SHORT $LN48@WpnAGPushB
$LN49@WpnAGPushB:

; 1005 : 				(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser))

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN46@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN48@WpnAGPushB
$LN46@WpnAGPushB:

; 1006 : 			{
; 1007 : 				ChangeToInput(whichButton);

	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeToInput@SmsDrawable@@QAEXH@Z	; SmsDrawable::ChangeToInput
$LN48@WpnAGPushB:

; 1008 : 			}
; 1009 : 		}
; 1010 : 		else

	jmp	SHORT $LN45@WpnAGPushB
$LN50@WpnAGPushB:

; 1011 : 		{
; 1012 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN44@WpnAGPushB

; 1013 : 				pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep
	jmp	SHORT $LN45@WpnAGPushB
$LN44@WpnAGPushB:

; 1014 : 			else if(pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	jne	SHORT $LN45@WpnAGPushB

; 1015 : 				Sms->IncrementRippleCount();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?IncrementRippleCount@SMSClass@@QAEXXZ	; SMSClass::IncrementRippleCount
$LN45@WpnAGPushB:

; 1016 : 		}
; 1017 : 	break;

	jmp	$LN99@WpnAGPushB
$LN41@WpnAGPushB:

; 1018 : 
; 1019 :     case 15:
; 1020 : 		if(g_bRealisticAvionics && Sms->CurHardpoint() >= 0)	//MI

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN40@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	SHORT $LN40@WpnAGPushB

; 1021 : 		{
; 1022 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN39@WpnAGPushB

; 1023 : 				pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep

; 1024 : 			else if((pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) || //me123 status test. addet four lines

	jmp	SHORT $LN38@WpnAGPushB
$LN39@WpnAGPushB:

; 1025 : 				(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser)) //MI LGB's

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	je	SHORT $LN36@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN38@WpnAGPushB
$LN36@WpnAGPushB:

; 1026 : 			{
; 1027 : 				if(g_bMLU)

	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	je	SHORT $LN35@WpnAGPushB

; 1028 : 					ChangeToInput(whichButton);

	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeToInput@SmsDrawable@@QAEXH@Z	; SmsDrawable::ChangeToInput

; 1029 : 				else

	jmp	SHORT $LN38@WpnAGPushB
$LN35@WpnAGPushB:

; 1030 : 				{
; 1031 : 					self->JDAMStep = -1;

	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+1764], -1
$LN38@WpnAGPushB:

; 1032 : 				}
; 1033 : 			}
; 1034 : 		}
; 1035 : 		else

	jmp	SHORT $LN33@WpnAGPushB
$LN40@WpnAGPushB:

; 1036 : 		{
; 1037 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN32@WpnAGPushB

; 1038 : 				pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep
	jmp	SHORT $LN33@WpnAGPushB
$LN32@WpnAGPushB:

; 1039 : 			else if(pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) //me123 status test. addet four lines

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	jne	SHORT $LN33@WpnAGPushB

; 1040 : 				Sms->Incrementarmingdelay();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?Incrementarmingdelay@SMSClass@@QAEXXZ	; SMSClass::Incrementarmingdelay
$LN33@WpnAGPushB:

; 1041 : 		}
; 1042 : 	break;

	jmp	$LN99@WpnAGPushB
$LN29@WpnAGPushB:

; 1043 : 
; 1044 : 	case 16:
; 1045 : 		//JDAM
; 1046 : 		if (isJDAM || isJSOW) {

	movzx	eax, BYTE PTR ?isJDAM@@3_NA		; isJDAM
	test	eax, eax
	jne	SHORT $LN27@WpnAGPushB
	movzx	ecx, BYTE PTR ?isJSOW@@3_NA		; isJSOW
	test	ecx, ecx
	je	SHORT $LN28@WpnAGPushB
$LN27@WpnAGPushB:

; 1047 : 			self->JDAMStep = 1;

	mov	edx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [edx+1764], 1
$LN28@WpnAGPushB:

; 1048 : 		}
; 1049 : 
; 1050 : 		break;

	jmp	$LN99@WpnAGPushB
$LN26@WpnAGPushB:

; 1051 : 	//MI
; 1052 : 	case 17:
; 1053 : 		if(g_bRealisticAvionics && Sms->CurHardpoint() >= 0) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN25@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	SHORT $LN25@WpnAGPushB

; 1054 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundBomb) {

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 5
	jne	SHORT $LN25@WpnAGPushB

; 1055 : 				int i; // MLR 4/3/2004 - 
; 1056 : 
; 1057 : 				i = Sms->GetAGBFuze()+1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetAGBFuze@SMSClass@@QAEHXZ		; SMSClass::GetAGBFuze
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax

; 1058 : 				if(i>2) 

	cmp	DWORD PTR _i$3[ebp], 2
	jle	SHORT $LN23@WpnAGPushB

; 1059 : 					i=0;

	mov	DWORD PTR _i$3[ebp], 0
$LN23@WpnAGPushB:

; 1060 : 				Sms->SetAGBFuze(i);

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?SetAGBFuze@SMSClass@@QAEXH@Z		; SMSClass::SetAGBFuze

; 1061 : 
; 1062 : 				/*
; 1063 : 				if(Sms->Prof1)
; 1064 : 				{
; 1065 : 					Sms->Prof1NSTL++;
; 1066 : 					if(Sms->Prof1NSTL > 2)
; 1067 : 						Sms->Prof1NSTL = 0;
; 1068 : 				}
; 1069 : 				else
; 1070 : 				{
; 1071 : 					Sms->Prof2NSTL++;
; 1072 : 					if(Sms->Prof2NSTL > 2)
; 1073 : 						Sms->Prof2NSTL = 0;
; 1074 : 				}*/
; 1075 : 				SetWeapParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWeapParams@SmsDrawable@@QAEXXZ	; SmsDrawable::SetWeapParams
$LN25@WpnAGPushB:

; 1076 : 			}
; 1077 : 		}
; 1078 : 	break;	

	jmp	$LN99@WpnAGPushB
$LN22@WpnAGPushB:

; 1079 :     case 18:
; 1080 : 		if (isJDAM || isJSOW) 

	movzx	edx, BYTE PTR ?isJDAM@@3_NA		; isJDAM
	test	edx, edx
	jne	SHORT $LN20@WpnAGPushB
	movzx	eax, BYTE PTR ?isJSOW@@3_NA		; isJSOW
	test	eax, eax
	je	$LN21@WpnAGPushB
$LN20@WpnAGPushB:

; 1081 : 		{
; 1082 : 			if (Sms->JDAMtargeting == SMSBaseClass::PB) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN19@WpnAGPushB

; 1083 : 			{
; 1084 : 				Sms->JDAMtargeting = SMSBaseClass::TOO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR [ecx+36], 1

; 1085 : 				// RV - Biker - If we have a locked target on laser pod go to TOO
; 1086 : 				LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (Sms->ownship);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$4[ebp], eax

; 1087 : 				if (laserPod && laserPod->IsLocked()) 

	cmp	DWORD PTR _laserPod$4[ebp], 0
	je	SHORT $LN18@WpnAGPushB
	mov	ecx, DWORD PTR _laserPod$4[ebp]
	call	?IsLocked@LaserPodClass@@QAEHXZ		; LaserPodClass::IsLocked
	test	eax, eax
	je	SHORT $LN18@WpnAGPushB

; 1088 : 					laserPod->SetDesiredTarget(NULL);

	push	0
	mov	edx, DWORD PTR _laserPod$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _laserPod$4[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN18@WpnAGPushB:

; 1089 : 				// RV - Biker - Only allow auto step when in PB
; 1090 : 				self->JDAMAllowAutoStep = false;

	mov	eax, DWORD PTR _self$[ebp]
	mov	BYTE PTR [eax+1788], 0

; 1091 : 				break;

	jmp	$LN99@WpnAGPushB

; 1092 : 			}
; 1093 : 			else 

	jmp	SHORT $LN21@WpnAGPushB
$LN19@WpnAGPushB:

; 1094 : 			{
; 1095 : 				Sms->JDAMtargeting = SMSBaseClass::PB;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	DWORD PTR [edx+36], 0

; 1096 : 				self->JDAMAllowAutoStep = true;

	mov	eax, DWORD PTR _self$[ebp]
	mov	BYTE PTR [eax+1788], 1

; 1097 : 				break;

	jmp	$LN99@WpnAGPushB
$LN21@WpnAGPushB:

; 1098 : 			}
; 1099 : 		}
; 1100 : 
; 1101 : 		if (Sms->curHardpoint >= 0 && Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+44], 0
	jl	SHORT $LN16@WpnAGPushB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+148]
	call	edx
	mov	eax, DWORD PTR [eax]
	and	eax, 4
	je	SHORT $LN16@WpnAGPushB

; 1102 : 			//MI not here in real
; 1103 : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN15@WpnAGPushB

; 1104 : 				break;

	jmp	$LN99@WpnAGPushB
$LN15@WpnAGPushB:

; 1105 : 			Sms->IncrementBurstHeight();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?IncrementBurstHeight@SMSClass@@QAEXXZ	; SMSClass::IncrementBurstHeight
	jmp	SHORT $LN14@WpnAGPushB
$LN16@WpnAGPushB:

; 1106 : 		}
; 1107 : 		//I-Hawk - Moved this to WpnMfd
; 1108 : 		//else if (Sms->curWeaponType == wtAgm88) {
; 1109 : 		//	// HTS used HSD display range for now, so...
; 1110 : 		//	//SimHSDRangeStepDown (0, KEY_DOWN, NULL); 
; 1111 : 		//}
; 1112 : 
; 1113 : 		else if(g_bRealisticAvionics && pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile && Sms->curWeaponType == wtAgm65)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN14@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN14@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN14@WpnAGPushB

; 1114 : 			pFCC->WeaponStep();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep
$LN14@WpnAGPushB:

; 1115 : 		break;

	jmp	$LN99@WpnAGPushB
$LN12@WpnAGPushB:

; 1116 : 	
; 1117 :     case 19:
; 1118 : 		//MI
; 1119 : 		if(g_bRealisticAvionics) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN11@WpnAGPushB

; 1120 : 		{
; 1121 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile) 

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	jne	SHORT $LN10@WpnAGPushB
	jmp	SHORT $LN9@WpnAGPushB
$LN10@WpnAGPushB:

; 1122 : 			{ 
; 1123 : 				//Doc says it's been deleted from the real thing
; 1124 : 				//pFCC->NextSubMode();
; 1125 : 			}
; 1126 : 			//I-Hawk - Moved this to WpnMfd
; 1127 : 			//else if (Sms->curWeaponType == wtAgm88)	
; 1128 : 			//{ 
; 1129 : 			//	// HTS used HSD display range for now, so...
; 1130 : 			//	//SimHSDRangeStepUp (0, KEY_DOWN, NULL); 
; 1131 : 			//}
; 1132 : 
; 1133 : 			else if (isJDAM || isJSOW) 

	movzx	ecx, BYTE PTR ?isJDAM@@3_NA		; isJDAM
	test	ecx, ecx
	jne	SHORT $LN7@WpnAGPushB
	movzx	edx, BYTE PTR ?isJSOW@@3_NA		; isJSOW
	test	edx, edx
	je	SHORT $LN9@WpnAGPushB
$LN7@WpnAGPushB:

; 1134 : 			{
; 1135 : 				//RV - I-Hawk - toggle status of the JDAMAllowAutoStep flag
; 1136 : 				if (Sms->JDAMtargeting == SMSBaseClass::PB) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN6@WpnAGPushB

; 1137 : 				{
; 1138 : 					if ( self->JDAMAllowAutoStep ) 

	mov	edx, DWORD PTR _self$[ebp]
	movzx	eax, BYTE PTR [edx+1788]
	test	eax, eax
	je	SHORT $LN5@WpnAGPushB

; 1139 : 					{
; 1140 : 						self->JDAMAllowAutoStep = false;

	mov	ecx, DWORD PTR _self$[ebp]
	mov	BYTE PTR [ecx+1788], 0

; 1141 : 					}
; 1142 : 					else 

	jmp	SHORT $LN4@WpnAGPushB
$LN5@WpnAGPushB:

; 1143 : 					{
; 1144 : 						self->JDAMAllowAutoStep = true;

	mov	edx, DWORD PTR _self$[ebp]
	mov	BYTE PTR [edx+1788], 1
$LN4@WpnAGPushB:

; 1145 : 					}
; 1146 : 				}
; 1147 : 				// RV - Biker - Only allow auto step when in PB
; 1148 : 				else 

	jmp	SHORT $LN9@WpnAGPushB
$LN6@WpnAGPushB:

; 1149 : 				{
; 1150 : 					self->JDAMAllowAutoStep = false;

	mov	eax, DWORD PTR _self$[ebp]
	mov	BYTE PTR [eax+1788], 0
$LN9@WpnAGPushB:

; 1151 : 				}
; 1152 : 			}
; 1153 : 			break;

	jmp	SHORT $LN99@WpnAGPushB
$LN11@WpnAGPushB:

; 1154 : 		}
; 1155 : 		if (pFCC->GetMasterMode() == FireControlComputer::AirGroundMissile ||
; 1156 : 			(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser &&
; 1157 : 			Sms->curWeaponClass == wcGbuWpn))

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 6
	je	SHORT $LN1@WpnAGPushB
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN99@WpnAGPushB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN99@WpnAGPushB
$LN1@WpnAGPushB:

; 1158 : 		{
; 1159 : 			pFCC->NextSubMode();

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?NextSubMode@FireControlComputer@@QAEXXZ ; FireControlComputer::NextSubMode
$LN99@WpnAGPushB:

; 1160 : 		}
; 1161 : 		//I-Hawk - Moved this to WpnMfd
; 1162 : 		//else if (Sms->curWeaponType == wtAgm88)
; 1163 : 		//{
; 1164 : 		//	// HTS used HSD display range for now, so...
; 1165 : 		//	//SimHSDRangeStepUp (0, KEY_DOWN, NULL); 
; 1166 : 		//}
; 1167 :    break;
; 1168 :    }
; 1169 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN105@WpnAGPushB:
	DD	$LN96@WpnAGPushB
	DD	$LN95@WpnAGPushB
	DD	$LN90@WpnAGPushB
	DD	$LN99@WpnAGPushB
	DD	$LN84@WpnAGPushB
	DD	$LN80@WpnAGPushB
	DD	$LN78@WpnAGPushB
	DD	$LN63@WpnAGPushB
	DD	$LN57@WpnAGPushB
	DD	$LN51@WpnAGPushB
	DD	$LN99@WpnAGPushB
	DD	$LN99@WpnAGPushB
	DD	$LN99@WpnAGPushB
	DD	$LN99@WpnAGPushB
	DD	$LN99@WpnAGPushB
	DD	$LN41@WpnAGPushB
	DD	$LN29@WpnAGPushB
	DD	$LN26@WpnAGPushB
	DD	$LN22@WpnAGPushB
	DD	$LN12@WpnAGPushB
?WpnAGPushButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::WpnAGPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv266 = -20						; size = 4
tv159 = -16						; size = 4
tv78 = -12						; size = 4
_pFCC$ = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?WpnPushButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::WpnPushButton
; _this$ = ecx

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 717  :     
; 718  :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 719  :     switch(whichButton) { // common controls.

	mov	ecx, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR tv78[ebp]
	sub	edx, 1
	mov	DWORD PTR tv78[ebp], edx
	cmp	DWORD PTR tv78[ebp], 18			; 00000012H
	ja	$LN9@WpnPushBut
	mov	eax, DWORD PTR tv78[ebp]
	movzx	ecx, BYTE PTR $LN53@WpnPushBut[eax]
	jmp	DWORD PTR $LN54@WpnPushBut[ecx*4]
$LN48@WpnPushBut:

; 720  : 	//MI
; 721  : 	case 1:
; 722  : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN47@WpnPushBut

; 723  : 		{
; 724  : 			if(Sms->curWeaponType == wtAgm65 && Sms->curWeapon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 4
	jne	SHORT $LN46@WpnPushBut
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@WpnPushBut

; 725  : 			{
; 726  : 				Sms->StepMavSubMode();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z	; SMSBaseClass::StepMavSubMode

; 727  : 			}
; 728  : 			else if(pFCC->GetMasterMode() == FireControlComputer::Dogfight || pFCC->GetMasterMode() ==

	jmp	$LN45@WpnPushBut
$LN46@WpnPushBut:

; 729  : 				FireControlComputer::MissileOverride)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN43@WpnPushBut
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN44@WpnPushBut
$LN43@WpnPushBut:

; 730  : 			{
; 731  : 				WpnOtherPushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnOtherPushButton@SmsDrawable@@AAEXHH@Z ; SmsDrawable::WpnOtherPushButton
	jmp	SHORT $LN45@WpnPushBut
$LN44@WpnPushBut:

; 732  : 			}
; 733  : 			else if(pFCC->GetMainMasterMode() == MM_AA)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 1
	jne	SHORT $LN41@WpnPushBut

; 734  : 				WpnAAPushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAAPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAAPushButton
	jmp	SHORT $LN45@WpnPushBut
$LN41@WpnPushBut:

; 735  : 			else if(pFCC->GetMainMasterMode() == MM_AG)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	test	eax, eax
	jne	SHORT $LN45@WpnPushBut

; 736  : 			{
; 737  : 				if (IsSet(MENUMODE))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z ; SmsDrawable::IsSet
	test	eax, eax
	je	SHORT $LN38@WpnPushBut

; 738  : 					WpnAGMenu(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAGMenu@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAGMenu

; 739  : 				else

	jmp	SHORT $LN45@WpnPushBut
$LN38@WpnPushBut:

; 740  : 					WpnAGPushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAGPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAGPushButton
$LN45@WpnPushBut:

; 741  : 			}
; 742  : 		}
; 743  : 		else

	jmp	$LN36@WpnPushBut
$LN47@WpnPushBut:

; 744  : 		{
; 745  : 			switch(pFCC->GetMainMasterMode()) 

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	mov	DWORD PTR tv159[ebp], eax
	cmp	DWORD PTR tv159[ebp], 0
	je	SHORT $LN33@WpnPushBut
	cmp	DWORD PTR tv159[ebp], 1
	je	SHORT $LN30@WpnPushBut
	cmp	DWORD PTR tv159[ebp], 2
	je	SHORT $LN29@WpnPushBut
	jmp	SHORT $LN28@WpnPushBut
$LN33@WpnPushBut:

; 746  : 			{
; 747  : 			case MM_AG:
; 748  : 				if (IsSet(MENUMODE))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z ; SmsDrawable::IsSet
	test	eax, eax
	je	SHORT $LN32@WpnPushBut

; 749  : 					WpnAGMenu(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAGMenu@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAGMenu

; 750  : 				else

	jmp	SHORT $LN31@WpnPushBut
$LN32@WpnPushBut:

; 751  : 					WpnAGPushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAGPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAGPushButton
$LN31@WpnPushBut:

; 752  : 			break;

	jmp	SHORT $LN36@WpnPushBut
$LN30@WpnPushBut:

; 753  : 			case MM_AA:
; 754  : 				WpnAAPushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAAPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAAPushButton

; 755  : 			break;

	jmp	SHORT $LN36@WpnPushBut
$LN29@WpnPushBut:

; 756  : 			case MM_NAV:
; 757  : 				WpnNavPushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnNavPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnNavPushButton

; 758  : 			break;

	jmp	SHORT $LN36@WpnPushBut
$LN28@WpnPushBut:

; 759  : 			default:
; 760  : 				WpnOtherPushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnOtherPushButton@SmsDrawable@@AAEXHH@Z ; SmsDrawable::WpnOtherPushButton
$LN36@WpnPushBut:

; 761  : 			break;
; 762  : 			}
; 763  : 		} 
; 764  : 	break;

	jmp	$LN51@WpnPushBut
$LN27@WpnPushBut:

; 765  :     case 3:
; 766  : 	UnsetFlag(MENUMODE); // force out of menu mode JPO

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ; SmsDrawable::UnsetFlag

; 767  : 	SetDisplayMode(Inv);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 768  : 	break;

	jmp	$LN51@WpnPushBut
$LN26@WpnPushBut:

; 769  :     case 10:
; 770  : 	UnsetFlag(MENUMODE); // force out of menu mode JPO

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ; SmsDrawable::UnsetFlag

; 771  : 	SetDisplayMode (SelJet);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 772  : 	break;

	jmp	$LN51@WpnPushBut
$LN25@WpnPushBut:

; 773  :     case 11:
; 774  : 	if (g_bRealisticAvionics) {

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN24@WpnPushBut

; 775  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
$LN24@WpnPushBut:

; 776  : 	}
; 777  : 	break;

	jmp	$LN51@WpnPushBut
$LN23@WpnPushBut:

; 778  : 	
; 779  :     case 12:
; 780  : 	if (g_bRealisticAvionics) {

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN22@WpnPushBut

; 781  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 782  : 	}
; 783  : 	else 

	jmp	SHORT $LN21@WpnPushBut
$LN22@WpnPushBut:

; 784  : 	{
; 785  : 	    MfdDisplay[whichMFD]->SetNewMode(MFDClass::FCRMode);

	push	10					; 0000000aH
	mov	edx, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN21@WpnPushBut:

; 786  : 	}
; 787  : 	break;

	jmp	$LN51@WpnPushBut
$LN20@WpnPushBut:

; 788  : 	
; 789  :     case 13:
; 790  : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN19@WpnPushBut

; 791  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 792  : 	}
; 793  : 	else if(pFCC->GetMasterMode() == FireControlComputer::ILS ||

	jmp	SHORT $LN18@WpnPushBut
$LN19@WpnPushBut:

; 794  : 	    pFCC->GetMasterMode() == FireControlComputer::Nav)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 3
	je	SHORT $LN16@WpnPushBut
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 4
	jne	SHORT $LN17@WpnPushBut
$LN16@WpnPushBut:

; 795  : 	{
; 796  : 	    MfdDisplay[whichMFD]->SetNewMode(MFDClass::MfdMenu);

	push	1
	mov	eax, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 797  : 	}
; 798  : 	else

	jmp	SHORT $LN18@WpnPushBut
$LN17@WpnPushBut:

; 799  : 	{	
; 800  : 	    SetDisplayMode(Wpn);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 801  : 	    pFCC->SetMasterMode( FireControlComputer::Nav );

	push	4
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN18@WpnPushBut:

; 802  : 	}
; 803  : 	break;

	jmp	$LN51@WpnPushBut
$LN14@WpnPushBut:

; 804  : 	
; 805  :     case 14:
; 806  : 	MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 807  : 	break;

	jmp	$LN51@WpnPushBut
$LN13@WpnPushBut:

; 808  : 	//MI
; 809  : 	case 19:
; 810  : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN9@WpnPushBut

; 811  : 		{
; 812  : 			if(Sms->FEDS)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movzx	eax, BYTE PTR [edx+14]
	test	eax, eax
	je	SHORT $LN11@WpnPushBut

; 813  : 				Sms->FEDS = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	BYTE PTR [edx+14], 0

; 814  : 			else

	jmp	SHORT $LN9@WpnPushBut
$LN11@WpnPushBut:

; 815  : 				Sms->FEDS = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	BYTE PTR [ecx+14], 1
$LN9@WpnPushBut:

; 816  : 		}
; 817  :     default:
; 818  : 	switch(pFCC->GetMainMasterMode()) {

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	mov	DWORD PTR tv266[ebp], eax
	cmp	DWORD PTR tv266[ebp], 0
	je	SHORT $LN6@WpnPushBut
	cmp	DWORD PTR tv266[ebp], 1
	je	SHORT $LN3@WpnPushBut
	cmp	DWORD PTR tv266[ebp], 2
	je	SHORT $LN2@WpnPushBut
	jmp	SHORT $LN1@WpnPushBut
$LN6@WpnPushBut:

; 819  : 	case MM_AG:
; 820  : 	    if (IsSet(MENUMODE))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z ; SmsDrawable::IsSet
	test	eax, eax
	je	SHORT $LN5@WpnPushBut

; 821  : 		WpnAGMenu(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAGMenu@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAGMenu

; 822  : 	    else

	jmp	SHORT $LN4@WpnPushBut
$LN5@WpnPushBut:

; 823  : 		WpnAGPushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAGPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAGPushButton
$LN4@WpnPushBut:

; 824  : 	    break;

	jmp	SHORT $LN51@WpnPushBut
$LN3@WpnPushBut:

; 825  : 	case MM_AA:
; 826  : 	    WpnAAPushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnAAPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnAAPushButton

; 827  : 	    break;

	jmp	SHORT $LN51@WpnPushBut
$LN2@WpnPushBut:

; 828  : 	case MM_NAV:
; 829  : 	    WpnNavPushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnNavPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnNavPushButton

; 830  : 	    break;

	jmp	SHORT $LN51@WpnPushBut
$LN1@WpnPushBut:

; 831  : 	default:
; 832  : 	    WpnOtherPushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnOtherPushButton@SmsDrawable@@AAEXHH@Z ; SmsDrawable::WpnOtherPushButton
$LN51@WpnPushBut:

; 833  : 	    break;
; 834  : 	}
; 835  :     }
; 836  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN54@WpnPushBut:
	DD	$LN48@WpnPushBut
	DD	$LN27@WpnPushBut
	DD	$LN26@WpnPushBut
	DD	$LN25@WpnPushBut
	DD	$LN23@WpnPushBut
	DD	$LN20@WpnPushBut
	DD	$LN14@WpnPushBut
	DD	$LN13@WpnPushBut
	DD	$LN9@WpnPushBut
$LN53@WpnPushBut:
	DB	0
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
?WpnPushButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::WpnPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_pFCC$ = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?SJPushButton@SmsDrawable@@AAEXHH@Z PROC		; SmsDrawable::SJPushButton
; _this$ = ecx

; 1293 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1294 :     
; 1295 :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 1296 : 
; 1297 :     switch (whichButton)

	mov	ecx, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR tv78[ebp]
	sub	edx, 2
	mov	DWORD PTR tv78[ebp], edx
	cmp	DWORD PTR tv78[ebp], 16			; 00000010H
	ja	$LN26@SJPushButt
	mov	eax, DWORD PTR tv78[ebp]
	jmp	DWORD PTR $LN28@SJPushButt[eax*4]
$LN23@SJPushButt:

; 1298 :     {
; 1299 :     case 2:
; 1300 : 	if (Sms->hardPoint[5]->GetWeaponClass() != wcECM &&
; 1301 : 	    Sms->hardPoint[5]->GetWeaponClass() != wcCamera)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, 4
	je	SHORT $LN22@SJPushButt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN22@SJPushButt

; 1302 : 	{
; 1303 : 		StepSelectiveJettisonMode(5);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode
$LN22@SJPushButt:

; 1304 :   //          hardPointSelected ^= (1 << 5);
; 1305 :   //			sjHardPointSelected = hardPointSelected;
; 1306 : 	}
; 1307 : 	break;

	jmp	$LN26@SJPushButt
$LN21@SJPushButt:

; 1308 : 	
; 1309 :     case 6:
; 1310 : 		StepSelectiveJettisonMode(6);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode

; 1311 : //	hardPointSelected ^= (1 << 6);
; 1312 : //	sjHardPointSelected = hardPointSelected;
; 1313 : 	break;

	jmp	$LN26@SJPushButt
$LN20@SJPushButt:

; 1314 : 	
; 1315 :     case 7:
; 1316 : 		StepSelectiveJettisonMode(7);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode

; 1317 : //	hardPointSelected ^= (1 << 7);
; 1318 : //	sjHardPointSelected = hardPointSelected;
; 1319 : 	break;

	jmp	$LN26@SJPushButt
$LN19@SJPushButt:

; 1320 : 	
; 1321 :     case 8:
; 1322 : 		StepSelectiveJettisonMode(8);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode

; 1323 : //	hardPointSelected ^= (1 << 8);
; 1324 : //	sjHardPointSelected = hardPointSelected;
; 1325 : 	break;

	jmp	$LN26@SJPushButt
$LN18@SJPushButt:

; 1326 : 	
; 1327 :     case 10:
; 1328 : 	{
; 1329 : 	    SetDisplayMode (lastMode);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 1330 : 	}
; 1331 : 	break;

	jmp	$LN26@SJPushButt
$LN17@SJPushButt:

; 1332 :     case 11:
; 1333 : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN16@SJPushButt

; 1334 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
$LN16@SJPushButt:

; 1335 : 	}
; 1336 : 	break;

	jmp	$LN26@SJPushButt
$LN15@SJPushButt:

; 1337 : 	
; 1338 :     case 12:
; 1339 : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN14@SJPushButt

; 1340 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 1341 : 	}
; 1342 : 	else

	jmp	SHORT $LN13@SJPushButt
$LN14@SJPushButt:

; 1343 : 	{
; 1344 : 	    SetDisplayMode(Wpn);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN13@SJPushButt:

; 1345 : 	}
; 1346 : 	break;

	jmp	$LN26@SJPushButt
$LN12@SJPushButt:

; 1347 : 	
; 1348 :     case 13:
; 1349 : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN11@SJPushButt

; 1350 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 1351 : 	}
; 1352 : 	else if(pFCC->GetMasterMode() == FireControlComputer::ILS ||

	jmp	SHORT $LN10@SJPushButt
$LN11@SJPushButt:

; 1353 : 	    pFCC->GetMasterMode() == FireControlComputer::Nav)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 3
	je	SHORT $LN8@SJPushButt
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 4
	jne	SHORT $LN9@SJPushButt
$LN8@SJPushButt:

; 1354 : 	{
; 1355 : 	    SetDisplayMode(Wpn);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 1356 : 	    pFCC->SetMasterMode( FireControlComputer::Nav );

	push	4
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 1357 : 	}
; 1358 : 	else

	jmp	SHORT $LN10@SJPushButt
$LN9@SJPushButt:

; 1359 : 	{	
; 1360 : 	    SetDisplayMode(Wpn);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 1361 : 	    pFCC->SetMasterMode( FireControlComputer::Nav );

	push	4
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN10@SJPushButt:

; 1362 : 	}
; 1363 : 	break;

	jmp	SHORT $LN26@SJPushButt
$LN6@SJPushButt:

; 1364 : 	
; 1365 :     case 14:
; 1366 : 	MfdDrawable::PushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 1367 : 	break;

	jmp	SHORT $LN26@SJPushButt

; 1368 : 	
; 1369 :     case 15:
; 1370 : 	break;

	jmp	SHORT $LN26@SJPushButt
$LN4@SJPushButt:

; 1371 : 	
; 1372 :     case 16:
; 1373 : 		StepSelectiveJettisonMode(2);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode

; 1374 : //	    hardPointSelected ^= (1 << 2);
; 1375 : //		sjHardPointSelected = hardPointSelected;
; 1376 : 	break;

	jmp	SHORT $LN26@SJPushButt
$LN3@SJPushButt:

; 1377 : 	
; 1378 :     case 17:
; 1379 : 		StepSelectiveJettisonMode(3);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode

; 1380 : //	    hardPointSelected ^= (1 << 3);
; 1381 : //		sjHardPointSelected = hardPointSelected;
; 1382 : 	break;

	jmp	SHORT $LN26@SJPushButt
$LN2@SJPushButt:

; 1383 : 	
; 1384 :     case 18:
; 1385 : 		StepSelectiveJettisonMode(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepSelectiveJettisonMode@SmsDrawable@@AAEXH@Z ; SmsDrawable::StepSelectiveJettisonMode
$LN26@SJPushButt:

; 1386 : //	    hardPointSelected ^= (1 << 4);
; 1387 : //		sjHardPointSelected = hardPointSelected;
; 1388 : 	break;
; 1389 : 	
; 1390 :     case 19:
; 1391 : 	break;
; 1392 :    }
; 1393 : 	//MI commented out to fix SJ remembering stuff
; 1394 : 	//sjHardPointSelected = hardPointSelected;
; 1395 :    // 2000-08-26 ADDED BY S.G. SO WE SAVE THE JETTISON SELECTION
; 1396 :    //	if (displayMode == SelJet)	// Until I fixe oldp01 being private
; 1397 :    //		((AircraftClass *)Sms->ownship)->af->oldp01[5] = hardPointSelected;
; 1398 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN28@SJPushButt:
	DD	$LN23@SJPushButt
	DD	$LN26@SJPushButt
	DD	$LN26@SJPushButt
	DD	$LN26@SJPushButt
	DD	$LN21@SJPushButt
	DD	$LN20@SJPushButt
	DD	$LN19@SJPushButt
	DD	$LN26@SJPushButt
	DD	$LN18@SJPushButt
	DD	$LN17@SJPushButt
	DD	$LN15@SJPushButt
	DD	$LN12@SJPushButt
	DD	$LN6@SJPushButt
	DD	$LN26@SJPushButt
	DD	$LN4@SJPushButt
	DD	$LN3@SJPushButt
	DD	$LN2@SJPushButt
?SJPushButton@SmsDrawable@@AAEXHH@Z ENDP		; SmsDrawable::SJPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv251 = -24						; size = 4
tv211 = -20						; size = 4
tv160 = -16						; size = 4
tv134 = -12						; size = 4
_FCC$ = -8						; size = 4
_this$ = -4						; size = 4
_isinv$ = 8						; size = 4
?TopRow@SmsDrawable@@AAEXH@Z PROC			; SmsDrawable::TopRow
; _this$ = ecx

; 2305 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2306 :     FireControlComputer *FCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _FCC$[ebp], eax

; 2307 :     
; 2308 :     if (isinv)  {

	cmp	DWORD PTR _isinv$[ebp], 0
	je	SHORT $LN38@TopRow

; 2309 : 	if (!FCC->IsNavMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsNavMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsNavMasterMode
	test	eax, eax
	jne	SHORT $LN37@TopRow

; 2310 : 	    LabelButton(3, "INV", NULL, 1);

	push	1
	push	0
	push	OFFSET ??_C@_03KOECGNEM@INV?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN37@TopRow:

; 2311 :     }
; 2312 :     else

	jmp	SHORT $LN36@TopRow
$LN38@TopRow:

; 2313 : 	LabelButton(3, "INV");

	push	0
	push	0
	push	OFFSET ??_C@_03KOECGNEM@INV?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN36@TopRow:

; 2314 :     
; 2315 :     switch (FCC->GetMasterMode()) {

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv134[ebp], eax
	cmp	DWORD PTR tv134[ebp], 10		; 0000000aH
	ja	$LN8@TopRow
	mov	ecx, DWORD PTR tv134[ebp]
	movzx	edx, BYTE PTR $LN41@TopRow[ecx]
	jmp	DWORD PTR $LN42@TopRow[edx*4]
$LN33@TopRow:

; 2316 :     case FireControlComputer::ILS:
; 2317 :     case FireControlComputer::Nav:
; 2318 : 	LabelButton(0, "STBY");

	push	0
	push	0
	push	OFFSET ??_C@_04BKGGJKLP@STBY?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2319 : 	break;

	jmp	$LN39@TopRow
$LN32@TopRow:

; 2320 :     case FireControlComputer::MissileOverride:
; 2321 : 	LabelButton(0, "MSL");

	push	0
	push	0
	push	OFFSET ??_C@_03IFPDDAOD@MSL?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2322 : 	// ASSOCIATOR 03/12/03: Added the combined SnapShot LCOS Gunmode SSLC 
; 2323 : 	if(g_bRealisticAvionics && Sms->curWeaponType == wtGuns)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN31@TopRow
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 0
	jne	SHORT $LN31@TopRow

; 2324 : 	{ 
; 2325 : 		switch(FCC->GetSubMode()) 

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	mov	DWORD PTR tv160[ebp], eax
	cmp	DWORD PTR tv160[ebp], 3
	ja	SHORT $LN31@TopRow
	mov	eax, DWORD PTR tv160[ebp]
	jmp	DWORD PTR $LN43@TopRow[eax*4]
$LN28@TopRow:

; 2326 : 		{
; 2327 : 		case FireControlComputer::EEGS:
; 2328 : 			LabelButton(1, "EEGS");

	push	0
	push	0
	push	OFFSET ??_C@_04OBEHOCAG@EEGS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2329 : 			break;

	jmp	SHORT $LN31@TopRow
$LN27@TopRow:

; 2330 : 		case FireControlComputer::SSLC:
; 2331 : 			LabelButton(1, "SSLC");

	push	0
	push	0
	push	OFFSET ??_C@_04DNACHFNH@SSLC?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2332 : 			break;

	jmp	SHORT $LN31@TopRow
$LN26@TopRow:

; 2333 : 		case FireControlComputer::LCOS:
; 2334 : 			LabelButton(1, "LCOS");

	push	0
	push	0
	push	OFFSET ??_C@_04MHCPIOBD@LCOS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2335 : 			break;

	jmp	SHORT $LN31@TopRow
$LN25@TopRow:

; 2336 : 		case FireControlComputer::Snapshot:
; 2337 : 			LabelButton(1, "SNAP");

	push	0
	push	0
	push	OFFSET ??_C@_04PGEGCIFE@SNAP?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN31@TopRow:

; 2338 : 			break;
; 2339 : 		}
; 2340 : 	}
; 2341 : 	break;

	jmp	$LN39@TopRow
$LN24@TopRow:

; 2342 : 	// ASSOCIATOR 03/12/03: Added the combined SnapShot LCOS Gunmode SSLC 
; 2343 :     case FireControlComputer::Dogfight:
; 2344 :         LabelButton(0, "DGFT");

	push	0
	push	0
	push	OFFSET ??_C@_04DIKNPPMN@DGFT?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2345 : 		if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN23@TopRow

; 2346 : 		{
; 2347 : 			switch(FCC->GetSubMode()) 

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	mov	DWORD PTR tv211[ebp], eax
	cmp	DWORD PTR tv211[ebp], 3
	ja	SHORT $LN21@TopRow
	mov	edx, DWORD PTR tv211[ebp]
	jmp	DWORD PTR $LN44@TopRow[edx*4]
$LN20@TopRow:

; 2348 : 			{
; 2349 : 			case FireControlComputer::EEGS:
; 2350 : 				LabelButton(1, "EEGS");

	push	0
	push	0
	push	OFFSET ??_C@_04OBEHOCAG@EEGS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2351 : 				break;

	jmp	SHORT $LN21@TopRow
$LN19@TopRow:

; 2352 : 			case FireControlComputer::SSLC:
; 2353 : 				LabelButton(1, "SSLC");

	push	0
	push	0
	push	OFFSET ??_C@_04DNACHFNH@SSLC?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2354 : 				break;

	jmp	SHORT $LN21@TopRow
$LN18@TopRow:

; 2355 : 			case FireControlComputer::LCOS:
; 2356 : 				LabelButton(1, "LCOS");

	push	0
	push	0
	push	OFFSET ??_C@_04MHCPIOBD@LCOS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2357 : 				break;

	jmp	SHORT $LN21@TopRow
$LN17@TopRow:

; 2358 : 			case FireControlComputer::Snapshot:
; 2359 : 				LabelButton(1, "SNAP");

	push	0
	push	0
	push	OFFSET ??_C@_04PGEGCIFE@SNAP?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN21@TopRow:

; 2360 : 				break;
; 2361 : 			}
; 2362 : 		}
; 2363 : 		else

	jmp	SHORT $LN16@TopRow
$LN23@TopRow:

; 2364 : 		{
; 2365 : 			switch(FCC->GetDgftGunSubMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetDgftGunSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetDgftGunSubMode
	mov	DWORD PTR tv251[ebp], eax
	cmp	DWORD PTR tv251[ebp], 3
	ja	SHORT $LN16@TopRow
	mov	eax, DWORD PTR tv251[ebp]
	jmp	DWORD PTR $LN45@TopRow[eax*4]
$LN13@TopRow:

; 2366 : 			{
; 2367 : 			case FireControlComputer::EEGS:
; 2368 : 				LabelButton(1, "EEGS");

	push	0
	push	0
	push	OFFSET ??_C@_04OBEHOCAG@EEGS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2369 : 				break;

	jmp	SHORT $LN16@TopRow
$LN12@TopRow:

; 2370 : 			case FireControlComputer::SSLC:
; 2371 : 				LabelButton(1, "SSLC");

	push	0
	push	0
	push	OFFSET ??_C@_04DNACHFNH@SSLC?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2372 : 				break;

	jmp	SHORT $LN16@TopRow
$LN11@TopRow:

; 2373 : 			case FireControlComputer::LCOS:
; 2374 : 				LabelButton(1, "LCOS");

	push	0
	push	0
	push	OFFSET ??_C@_04MHCPIOBD@LCOS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2375 : 				break;

	jmp	SHORT $LN16@TopRow
$LN10@TopRow:

; 2376 : 			case FireControlComputer::Snapshot:
; 2377 : 				LabelButton(1, "SNAP");

	push	0
	push	0
	push	OFFSET ??_C@_04PGEGCIFE@SNAP?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN16@TopRow:

; 2378 : 				break;
; 2379 : 			}
; 2380 : 		}
; 2381 : 		break;

	jmp	$LN39@TopRow
$LN9@TopRow:

; 2382 :     case FireControlComputer::AAGun:
; 2383 :     case FireControlComputer::AGGun:
; 2384 :         LabelButton(0, "GUN");

	push	0
	push	0
	push	OFFSET ??_C@_03NMPFMOLH@GUN?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2385 : 		
; 2386 : 	LabelButton(1, FCC->subModeString);

	push	0
	push	0
	mov	ecx, DWORD PTR _FCC$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2387 : 	break;

	jmp	$LN39@TopRow
$LN8@TopRow:

; 2388 :     default:
; 2389 :         if (FCC->IsAGMasterMode()) 

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	je	$LN7@TopRow

; 2390 : 		{
; 2391 : 			LabelButton(0, "A-G");

	push	0
	push	0
	push	OFFSET ??_C@_03HCLOBDMK@A?9G?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2392 : 			//MI temporary till we get LGB's going
; 2393 : 			if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN6@TopRow

; 2394 : 			{
; 2395 : 				if(FCC->GetMasterMode() == FireControlComputer::AirGroundLaser || Sms && Sms->curWeaponDomain != wdGround)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	je	SHORT $LN4@TopRow
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	SHORT $LN5@TopRow
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+152], 2
	je	SHORT $LN5@TopRow
$LN4@TopRow:

; 2396 : 					LabelButton(1, "");

	push	0
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2397 : 				else

	jmp	SHORT $LN3@TopRow
$LN5@TopRow:

; 2398 : 					LabelButton(1, FCC->subModeString);

	push	0
	push	0
	mov	eax, DWORD PTR _FCC$[ebp]
	add	eax, 400				; 00000190H
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN3@TopRow:

; 2399 : 			}
; 2400 : 			else

	jmp	SHORT $LN2@TopRow
$LN6@TopRow:

; 2401 : 				LabelButton(1, FCC->subModeString);

	push	0
	push	0
	mov	ecx, DWORD PTR _FCC$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN2@TopRow:

; 2402 : 		} 
; 2403 : 		else

	jmp	SHORT $LN39@TopRow
$LN7@TopRow:

; 2404 : 	    LabelButton(0, "AAM");

	push	0
	push	0
	push	OFFSET ??_C@_03MJJMMJAE@AAM?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN39@TopRow:

; 2405 :     break;
; 2406 :     }
; 2407 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN42@TopRow:
	DD	$LN9@TopRow
	DD	$LN33@TopRow
	DD	$LN24@TopRow
	DD	$LN32@TopRow
	DD	$LN8@TopRow
$LN41@TopRow:
	DB	0
	DB	0
	DB	4
	DB	1
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	3
	npad	1
$LN43@TopRow:
	DD	$LN28@TopRow
	DD	$LN27@TopRow
	DD	$LN26@TopRow
	DD	$LN25@TopRow
$LN44@TopRow:
	DD	$LN20@TopRow
	DD	$LN19@TopRow
	DD	$LN18@TopRow
	DD	$LN17@TopRow
$LN45@TopRow:
	DD	$LN13@TopRow
	DD	$LN12@TopRow
	DD	$LN11@TopRow
	DD	$LN10@TopRow
?TopRow@SmsDrawable@@AAEXH@Z ENDP			; SmsDrawable::TopRow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_cX$ = -40						; size = 4
_x$1 = -36						; size = 4
_y$2 = -32						; size = 4
tv284 = -28						; size = 4
_playerAC$ = -24					; size = 4
_cY$ = -20						; size = 4
tv94 = -16						; size = 4
_theRadar$ = -12					; size = 4
_mode$ = -8						; size = 4
_this$ = -4						; size = 4
?BottomRow@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::BottomRow
; _this$ = ecx

; 2410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2411 : 	//MI
; 2412 : 	float cX, cY = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cY$[ebp], xmm0

; 2413 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2414 : 	RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 2415 : 	if(!theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	jne	SHORT $LN15@BottomRow

; 2416 : 	{
; 2417 : 		ShiWarning("Oh Oh shouldn't be here without a radar!");
; 2418 : 		return;

	jmp	$LN16@BottomRow

; 2419 : 	}
; 2420 : 	else

	jmp	SHORT $LN14@BottomRow
$LN15@BottomRow:

; 2421 : 		theRadar->GetCursorPosition (&cX, &cY);

	lea	ecx, DWORD PTR _cY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cX$[ebp]
	push	edx
	mov	eax, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax
$LN14@BottomRow:

; 2422 :     char *mode = "";

	mov	DWORD PTR _mode$[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@

; 2423 :     switch (Sms->MasterArm())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	mov	DWORD PTR tv94[ebp], eax
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN11@BottomRow
	cmp	DWORD PTR tv94[ebp], 1
	je	SHORT $LN8@BottomRow
	cmp	DWORD PTR tv94[ebp], 2
	je	SHORT $LN7@BottomRow
	jmp	SHORT $LN12@BottomRow
$LN11@BottomRow:

; 2424 :  	{
; 2425 :  	case SMSBaseClass::Safe:
; 2426 :  		//MI not here in real
; 2427 :  		if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN10@BottomRow

; 2428 :  			mode = "SAF";

	mov	DWORD PTR _mode$[ebp], OFFSET ??_C@_03NAHIIPNL@SAF?$AA@

; 2429 :  		else

	jmp	SHORT $LN9@BottomRow
$LN10@BottomRow:

; 2430 :  			mode = "";

	mov	DWORD PTR _mode$[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN9@BottomRow:

; 2431 :  	break;

	jmp	SHORT $LN12@BottomRow
$LN8@BottomRow:

; 2432 :  	case SMSBaseClass::Sim:
; 2433 :  	    mode = "SIM";

	mov	DWORD PTR _mode$[ebp], OFFSET ??_C@_03DNJPAHKI@SIM?$AA@

; 2434 :  	break;

	jmp	SHORT $LN12@BottomRow
$LN7@BottomRow:

; 2435 :  	case SMSBaseClass::Arm:
; 2436 : 		mode = "RDY";

	mov	DWORD PTR _mode$[ebp], OFFSET ??_C@_03KDFFCEML@RDY?$AA@
$LN12@BottomRow:

; 2437 : 	break;
; 2438 :  	}
; 2439 : 
; 2440 :     if (g_bRealisticAvionics) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN6@BottomRow

; 2441 : 	{
; 2442 : 		float x, y;
; 2443 : 		GetButtonPos (12, &x, &y);

	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$1[ebp]
	push	edx
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z ; DrawableClass::GetButtonPos

; 2444 : 		// JPO - do this ourselves, so we can pass the rest off to the superclass.
; 2445 : 		display->TextCenter(x, y + display->TextHeight(), mode);

	push	0
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+88]
	call	eax
	fstp	DWORD PTR tv284[ebp]
	movss	xmm0, DWORD PTR tv284[ebp]
	addss	xmm0, DWORD PTR _y$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 2446 : 		MfdDrawable::BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@MfdDrawable@@QAEXXZ		; MfdDrawable::BottomRow

; 2447 : 		//MI changed
; 2448 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@BottomRow

; 2449 : 		{
; 2450 : 			if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&
; 2451 : 				OTWDriver.pCockpitManager->mpIcp->ShowBullseyeInfo)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN4@BottomRow
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [edx+688], 0
	je	SHORT $LN4@BottomRow
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	movzx	edx, BYTE PTR [ecx+300]
	test	edx, edx
	je	SHORT $LN4@BottomRow

; 2452 : 			{
; 2453 : 				DrawBullseyeCircle(display, cX, cY);

	push	ecx
	movss	xmm0, DWORD PTR _cY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?DrawBullseyeCircle@@YAXPAVVirtualDisplay@@MM@Z ; DrawBullseyeCircle
	add	esp, 12					; 0000000cH

; 2454 : 			}
; 2455 : 			else

	jmp	SHORT $LN3@BottomRow
$LN4@BottomRow:

; 2456 : 				MfdDrawable::DrawReference((AircraftClass*)Sms->Ownship());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawReference@MfdDrawable@@QAEXPAVAircraftClass@@@Z ; MfdDrawable::DrawReference
$LN3@BottomRow:

; 2457 : 		}
; 2458 : 		else

	jmp	SHORT $LN2@BottomRow
$LN5@BottomRow:

; 2459 : 			MfdDrawable::DrawReference((AircraftClass*)Sms->Ownship());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawReference@MfdDrawable@@QAEXPAVAircraftClass@@@Z ; MfdDrawable::DrawReference
$LN2@BottomRow:

; 2460 :     }
; 2461 :     else 

	jmp	SHORT $LN1@BottomRow
$LN6@BottomRow:

; 2462 :     {
; 2463 : 		LabelButton (10, "S-J");

	push	0
	push	0
	push	OFFSET ??_C@_03DNAAPCJD@S?9J?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2464 : 		LabelButton (12, "FCR", mode);

	push	0
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	push	OFFSET ??_C@_03JKJFCLEN@FCR?$AA@
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2465 : 		LabelButton (13, "MENU", NULL, 1);//me123

	push	1
	push	0
	push	OFFSET ??_C@_04IILMDFMO@MENU?$AA@
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2466 : 		LabelButton (14, "SWAP");

	push	0
	push	0
	push	OFFSET ??_C@_04NLFHDAEB@SWAP?$AA@
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@BottomRow:
$LN16@BottomRow:

; 2467 :     }
; 2468 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BottomRow@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::BottomRow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv193 = -28						; size = 4
_wpn$ = -24						; size = 4
_this$ = -20						; size = 4
_idnum$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?MissileOverrideDisplay@SmsDrawable@@AAEXXZ PROC	; SmsDrawable::MissileOverrideDisplay
; _this$ = ecx

; 1562 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1563 :     TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 1564 :     BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 1565 : 	//MI 19/01/02
; 1566 : 	// JPO ID and Telemetry readouts.
; 1567 : 	// Marco Edit - SLAVE/BORE Mode
; 1568 :     SimWeaponClass* wpn = NULL;

	mov	DWORD PTR _wpn$[ebp], 0

; 1569 : 	ShiAssert(Sms);
; 1570 : 	wpn = Sms->GetCurrentWeapon();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _wpn$[ebp], eax

; 1571 : 	
; 1572 : 	//MI changed 29/01/02 to be more accurate
; 1573 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN26@MissileOve

; 1574 : 	{
; 1575 : 		if(Sms->curWeaponType == wtAim120)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 2
	jne	$LN25@MissileOve

; 1576 : 		{
; 1577 : 			char idnum[10];
; 1578 : 			sprintf(idnum, "%d", Sms->AimId());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?AimId@SMSClass@@QAEHXZ			; SMSClass::AimId
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	ecx, DWORD PTR _idnum$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1579 : 			LabelButton (16, "ID", idnum);

	push	0
	lea	edx, DWORD PTR _idnum$1[ebp]
	push	edx
	push	OFFSET ??_C@_02OLOABKKD@ID?$AA@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1580 : 			LabelButton (17, "TM", "OFF"); // 20 Jan 04 ON is for telemetry missile

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_02CONMJBMJ@TM?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1581 : 			if(Sms->curWeapon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@MissileOve

; 1582 : 			{
; 1583 : 				ShiAssert(Sms->curWeapon->IsMissile());
; 1584 : 				if(((MissileClass*)Sms->GetCurrentWeapon())->isSlave) // && Sms->curWeaponType == wtAim9)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN23@MissileOve

; 1585 : 				{
; 1586 : 					LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1587 : 				}
; 1588 : 				else // if (((MissileClass*)Sms->curWeapon)->isCaged)

	jmp	SHORT $LN24@MissileOve
$LN23@MissileOve:

; 1589 : 				{
; 1590 : 					LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN24@MissileOve:

; 1591 : 				}
; 1592 : 			}
; 1593 : 		}

	jmp	$LN26@MissileOve
$LN25@MissileOve:

; 1594 : 		else if(Sms->curWeaponType == wtAim9 && wpn && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	$LN20@MissileOve
	cmp	DWORD PTR _wpn$[ebp], 0
	je	$LN20@MissileOve
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	$LN20@MissileOve

; 1595 : 		{
; 1596 : 			ShiAssert(Sms->curWeapon && Sms->curWeapon->IsMissile());
; 1597 : 			// JPO new Aim9 code
; 1598 : 			switch(Sms->GetCoolState()) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	mov	DWORD PTR tv193[ebp], eax
	cmp	DWORD PTR tv193[ebp], 3
	ja	SHORT $LN18@MissileOve
	mov	edx, DWORD PTR tv193[ebp]
	jmp	DWORD PTR $LN29@MissileOve[edx*4]
$LN17@MissileOve:

; 1599 : 			{
; 1600 : 			case SMSClass::WARM:
; 1601 : 				LabelButton (7, "WARM"); // needs cooling

	push	0
	push	0
	push	OFFSET ??_C@_04LKKJOPPH@WARM?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1602 : 				break;

	jmp	SHORT $LN18@MissileOve
$LN16@MissileOve:

; 1603 : 			case SMSClass::COOLING:
; 1604 : 				LabelButton (7, "WARM", NULL, 1); // is cooling

	push	1
	push	0
	push	OFFSET ??_C@_04LKKJOPPH@WARM?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1605 : 				break;

	jmp	SHORT $LN18@MissileOve
$LN15@MissileOve:

; 1606 : 			case SMSClass::COOL:
; 1607 : 				LabelButton (7, "COOL");

	push	0
	push	0
	push	OFFSET ??_C@_04MCPDKIOE@COOL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1608 : 				break;

	jmp	SHORT $LN18@MissileOve
$LN14@MissileOve:

; 1609 : 			case SMSClass::WARMING:
; 1610 : 				LabelButton (7, "COOL", NULL, 1); // Is warming back up

	push	1
	push	0
	push	OFFSET ??_C@_04MCPDKIOE@COOL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN18@MissileOve:

; 1611 : 				break;
; 1612 : 			}
; 1613 : 			
; 1614 : 			if(Sms && Sms->GetCurrentWeapon() && ((MissileClass*)Sms->GetCurrentWeapon())->isSlave)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	SHORT $LN13@MissileOve
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	je	SHORT $LN13@MissileOve
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN13@MissileOve

; 1615 : 			{
; 1616 : 				LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1617 : 			}
; 1618 : 			else

	jmp	SHORT $LN12@MissileOve
$LN13@MissileOve:

; 1619 : 			{
; 1620 : 				LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN12@MissileOve:

; 1621 : 			}
; 1622 : 			// Marco Edit - TD/BP Mode
; 1623 : 			if(Sms && Sms->curWeapon && ((MissileClass*)Sms->GetCurrentWeapon())->isTD && wpn && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+296], 0
	je	SHORT $LN11@MissileOve
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@MissileOve
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+740], 0
	je	SHORT $LN11@MissileOve
	cmp	DWORD PTR _wpn$[ebp], 0
	je	SHORT $LN11@MissileOve
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN11@MissileOve

; 1624 : 			{
; 1625 : 				LabelButton (17, "TD");

	push	0
	push	0
	push	OFFSET ??_C@_02PPBOCKIA@TD?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN10@MissileOve
$LN11@MissileOve:

; 1626 : 			}
; 1627 : 			else if(wpn && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	cmp	DWORD PTR _wpn$[ebp], 0
	je	SHORT $LN10@MissileOve
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	edx, al
	cmp	edx, 17					; 00000011H
	je	SHORT $LN10@MissileOve

; 1628 : 			{
; 1629 : 				LabelButton (17, "BP");

	push	0
	push	0
	push	OFFSET ??_C@_02MJBLCCBH@BP?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN10@MissileOve:

; 1630 : 			}
; 1631 : 
; 1632 : 			// Marco Edit - SPOT/SCAN Mode
; 1633 : 			if(Sms && Sms->curWeapon && ((MissileClass*)Sms->GetCurrentWeapon())->isSpot && wpn && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	SHORT $LN8@MissileOve
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@MissileOve
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	cmp	DWORD PTR [eax+732], 0
	je	SHORT $LN8@MissileOve
	cmp	DWORD PTR _wpn$[ebp], 0
	je	SHORT $LN8@MissileOve
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN8@MissileOve

; 1634 : 			{
; 1635 : 				LabelButton (2, "SPOT");

	push	0
	push	0
	push	OFFSET ??_C@_04CIHCOAPG@SPOT?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN7@MissileOve
$LN8@MissileOve:

; 1636 : 			}
; 1637 : 			else if(wpn && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	cmp	DWORD PTR _wpn$[ebp], 0
	je	SHORT $LN7@MissileOve
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN7@MissileOve

; 1638 : 			{
; 1639 : 				LabelButton (2, "SCAN");

	push	0
	push	0
	push	OFFSET ??_C@_04NAGNMPFG@SCAN?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN7@MissileOve:

; 1640 : 			}
; 1641 : 		}

	jmp	SHORT $LN26@MissileOve
$LN20@MissileOve:

; 1642 : 		else if(Sms->curWeaponType == wtGuns)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 0
	jne	SHORT $LN26@MissileOve

; 1643 : 		{
; 1644 : 			GunDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GunDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::GunDisplay
$LN26@MissileOve:

; 1645 : 		}
; 1646 : 	}
; 1647 : 	//MI
; 1648 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@MissileOve

; 1649 : 	{
; 1650 : 		if(Sms->curWeaponType != wtGuns)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 0
	je	SHORT $LN2@MissileOve

; 1651 : 			ShowMissiles(5);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowMissiles@SmsDrawable@@AAEXH@Z	; SmsDrawable::ShowMissiles
$LN2@MissileOve:

; 1652 : 	}
; 1653 : 	else

	jmp	SHORT $LN27@MissileOve
$LN3@MissileOve:

; 1654 : 		ShowMissiles(5);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowMissiles@SmsDrawable@@AAEXH@Z	; SmsDrawable::ShowMissiles
$LN27@MissileOve:

; 1655 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN29@MissileOve:
	DD	$LN17@MissileOve
	DD	$LN16@MissileOve
	DD	$LN15@MissileOve
	DD	$LN14@MissileOve
?MissileOverrideDisplay@SmsDrawable@@AAEXXZ ENDP	; SmsDrawable::MissileOverrideDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv423 = -68						; size = 4
_y1$ = -64						; size = 4
_width$ = -60						; size = 4
tv310 = -56						; size = 4
$T1 = -52						; size = 4
tv345 = -48						; size = 4
tv180 = -44						; size = 4
_leftEdge$ = -40					; size = 4
_x$ = -36						; size = 4
_y$ = -32						; size = 4
_i$ = -28						; size = 4
_c$2 = -21						; size = 1
_this$ = -20						; size = 4
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_buttonNum$ = 8						; size = 4
?ShowMissiles@SmsDrawable@@AAEXH@Z PROC			; SmsDrawable::ShowMissiles
; _this$ = ecx

; 1706 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1707 :     char tmpStr[12];
; 1708 :     float leftEdge;
; 1709 :     int i;
; 1710 :     float width = display->TextWidth("M ");

	push	OFFSET ??_C@_02ONHIBMNM@M?5?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+84]
	call	edx
	fstp	DWORD PTR _width$[ebp]

; 1711 :     
; 1712 :     if (Sms->curHardpoint < 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+44], 0
	jge	SHORT $LN19@ShowMissil

; 1713 : 	return;

	jmp	$LN20@ShowMissil
$LN19@ShowMissil:

; 1714 :     
; 1715 :     sprintf (tmpStr, "%d%s", Sms->NumCurrentWpn(), Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->mnemonic);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	add	eax, 28					; 0000001cH
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	push	eax
	push	OFFSET ??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1716 :     ShiAssert (strlen(tmpStr) < sizeof (tmpStr));
; 1717 :     LabelButton (buttonNum, tmpStr);

	push	0
	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _buttonNum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1718 :     if (Sms->CurStationOK())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?CurStationOK@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurStationOK
	test	eax, eax
	je	SHORT $LN18@ShowMissil

; 1719 :     {
; 1720 : 	switch (Sms->MasterArm())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	mov	DWORD PTR tv180[ebp], eax
	cmp	DWORD PTR tv180[ebp], 0
	je	SHORT $LN15@ShowMissil
	cmp	DWORD PTR tv180[ebp], 1
	je	SHORT $LN12@ShowMissil
	cmp	DWORD PTR tv180[ebp], 2
	je	SHORT $LN11@ShowMissil
	jmp	SHORT $LN16@ShowMissil
$LN15@ShowMissil:

; 1721 : 	{
; 1722 : 	case SMSBaseClass::Safe:
; 1723 : 		//MI not here in real
; 1724 : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN14@ShowMissil

; 1725 :             sprintf (tmpStr, "SAF");

	push	OFFSET ??_C@_03NAHIIPNL@SAF?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 1726 : 		else

	jmp	SHORT $LN13@ShowMissil
$LN14@ShowMissil:

; 1727 : 			sprintf(tmpStr, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN13@ShowMissil:

; 1728 : 	    break;

	jmp	SHORT $LN16@ShowMissil
$LN12@ShowMissil:

; 1729 : 	    
; 1730 : 	case SMSBaseClass::Sim:
; 1731 :             sprintf (tmpStr, "SIM");

	push	OFFSET ??_C@_03DNJPAHKI@SIM?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 1732 : 	    break;

	jmp	SHORT $LN16@ShowMissil
$LN11@ShowMissil:

; 1733 : 	    
; 1734 : 	case SMSBaseClass::Arm:
; 1735 :             sprintf (tmpStr, "RDY");

	push	OFFSET ??_C@_03KDFFCEML@RDY?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN16@ShowMissil:

; 1736 : 	    break;
; 1737 : 	}
; 1738 :     }
; 1739 :     else

	jmp	SHORT $LN10@ShowMissil
$LN18@ShowMissil:

; 1740 :     {
; 1741 : 	sprintf (tmpStr, "MAL");

	push	OFFSET ??_C@_03JKFBEHPN@MAL?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN10@ShowMissil:

; 1742 :     }
; 1743 :     float x, y, y1;
; 1744 : 	GetButtonPos(buttonNum, &x, &y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buttonNum$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z ; DrawableClass::GetButtonPos

; 1745 : 	//MI
; 1746 : 	if(g_bRealisticAvionics && Sms->curWeaponType == wtAgm65 && Sms->curWeapon)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN8@ShowMissil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN8@ShowMissil
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ShowMissil

; 1747 : 	{
; 1748 : 		if(!Sms->Powered || Sms->MavCoolTimer > 0.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN7@ShowMissil
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movss	xmm0, DWORD PTR [eax+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@ShowMissil
$LN7@ShowMissil:

; 1749 : 			sprintf(tmpStr,"");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN8@ShowMissil:

; 1750 : 	}
; 1751 :     display->TextCenter (0.3F, y, tmpStr);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+72]
	call	edx

; 1752 :     GetButtonPos(9, &x, &y); // use button 9 as a reference (lower rhs)

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z ; DrawableClass::GetButtonPos

; 1753 :     GetButtonPos(8, &x, &y1); // get button 8 y loc

	lea	edx, DWORD PTR _y1$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z ; DrawableClass::GetButtonPos

; 1754 : 		y = y + fabs(y-y1)*0.25f; // move up

	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv423[ebp]
	movss	xmm0, DWORD PTR tv423[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	addss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 1755 :     // List stations with Current Missile
; 1756 :     for (i=0; i<Sms->NumHardpoints(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@ShowMissil
$LN5@ShowMissil:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@ShowMissil:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN4@ShowMissil

; 1757 :     {
; 1758 : 			// JPO redone to use this routine. Returns the appropriate character
; 1759 : 			char c = HdptStationSym(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HdptStationSym@SmsDrawable@@QAEDH@Z	; SmsDrawable::HdptStationSym
	mov	BYTE PTR _c$2[ebp], al

; 1760 : 			if (c == ' ') continue; // Don't bother drawing blanks.

	movsx	ecx, BYTE PTR _c$2[ebp]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@ShowMissil
	jmp	SHORT $LN5@ShowMissil
$LN3@ShowMissil:

; 1761 : 			tmpStr[0] = c;

	mov	edx, 1
	imul	edx, 0
	mov	al, BYTE PTR _c$2[ebp]
	mov	BYTE PTR _tmpStr$[ebp+edx], al

; 1762 : 			tmpStr[1] = '\0';

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 12			; 0000000cH
	jae	SHORT $LN22@ShowMissil
	jmp	SHORT $LN23@ShowMissil
$LN22@ShowMissil:
	call	___report_rangecheckfailure
$LN23@ShowMissil:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _tmpStr$[ebp+ecx], 0

; 1763 : 			if (i < 6)

	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN2@ShowMissil

; 1764 : 			{
; 1765 : 					leftEdge = -x + width * (i-1);

	movss	xmm0, DWORD PTR _x$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR _width$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _leftEdge$[ebp], xmm0

; 1766 : 					display->TextLeft (leftEdge, y, tmpStr, (Sms->curHardpoint == i ? 2 : 0));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR _i$[ebp]
	jne	SHORT $LN24@ShowMissil
	mov	DWORD PTR tv310[ebp], 2
	jmp	SHORT $LN25@ShowMissil
$LN24@ShowMissil:
	mov	DWORD PTR tv310[ebp], 0
$LN25@ShowMissil:
	mov	eax, DWORD PTR tv310[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1767 : 			}
; 1768 : 			else

	jmp	SHORT $LN1@ShowMissil
$LN2@ShowMissil:

; 1769 : 			{
; 1770 : 					leftEdge = x - width * (Sms->NumHardpoints() - i - 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	sub	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _width$[ebp]
	movss	xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _leftEdge$[ebp], xmm1

; 1771 : 					// Box the current station
; 1772 : 					display->TextRight (leftEdge, y, tmpStr, (Sms->curHardpoint == i ? 2 : 0));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+44]
	cmp	ecx, DWORD PTR _i$[ebp]
	jne	SHORT $LN26@ShowMissil
	mov	DWORD PTR tv345[ebp], 2
	jmp	SHORT $LN27@ShowMissil
$LN26@ShowMissil:
	mov	DWORD PTR tv345[ebp], 0
$LN27@ShowMissil:
	mov	edx, DWORD PTR tv345[ebp]
	push	edx
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftEdge$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+60]
	call	eax
$LN1@ShowMissil:

; 1773 : 			}
; 1774 :     }

	jmp	$LN5@ShowMissil
$LN4@ShowMissil:
$LN20@ShowMissil:

; 1775 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowMissiles@SmsDrawable@@AAEXH@Z ENDP			; SmsDrawable::ShowMissiles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectiveJettison@SmsDrawable@@AAEXXZ PROC		; SmsDrawable::SelectiveJettison
; _this$ = ecx

; 2296 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2297 : 	LabelButton (1, "S-J", NULL, 1);

	push	1
	push	0
	push	OFFSET ??_C@_03DNAAPCJD@S?9J?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2298 : 	
; 2299 : 	BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 2300 : 	
; 2301 : 	InventoryDisplay (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InventoryDisplay@SmsDrawable@@AAEXH@Z	; SmsDrawable::InventoryDisplay

; 2302 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectiveJettison@SmsDrawable@@AAEXXZ ENDP		; SmsDrawable::SelectiveJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv92 = -28						; size = 4
_wpn$ = -24						; size = 4
_this$ = -20						; size = 4
_idnum$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?DogfightDisplay@SmsDrawable@@AAEXXZ PROC		; SmsDrawable::DogfightDisplay
; _this$ = ecx

; 1448 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1449 : 	GunDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GunDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::GunDisplay

; 1450 : 	ShowMissiles(6);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowMissiles@SmsDrawable@@AAEXH@Z	; SmsDrawable::ShowMissiles

; 1451 : 	// Marco Edit - SLAVE/BORE Mode
; 1452 : 	SimWeaponClass *wpn = Sms->GetCurrentWeapon();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _wpn$[ebp], eax

; 1453 : 	if(!wpn) return; // prevent CTD

	cmp	DWORD PTR _wpn$[ebp], 0
	jne	SHORT $LN32@DogfightDi
	jmp	$LN33@DogfightDi
$LN32@DogfightDi:

; 1454 : 	
; 1455 : 	//MI 29/01/02 changed to be more accurate
; 1456 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN31@DogfightDi

; 1457 : 	{
; 1458 : 		ShiAssert(Sms->curWeapon && Sms->curWeapon->IsMissile());
; 1459 : 		if(Sms->curWeaponType == wtAim9 && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	$LN30@DogfightDi
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	$LN30@DogfightDi

; 1460 : 		{
; 1461 : 			// JPO new Aim9 code
; 1462 : 			switch(Sms->GetCoolState()) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	mov	DWORD PTR tv92[ebp], eax
	cmp	DWORD PTR tv92[ebp], 3
	ja	SHORT $LN28@DogfightDi
	mov	edx, DWORD PTR tv92[ebp]
	jmp	DWORD PTR $LN35@DogfightDi[edx*4]
$LN27@DogfightDi:

; 1463 : 			{
; 1464 : 			case SMSClass::WARM:
; 1465 : 				LabelButton (7, "WARM"); // needs cooling

	push	0
	push	0
	push	OFFSET ??_C@_04LKKJOPPH@WARM?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1466 : 				break;

	jmp	SHORT $LN28@DogfightDi
$LN26@DogfightDi:

; 1467 : 			case SMSClass::COOLING:
; 1468 : 				LabelButton (7, "WARM", NULL, 1); // is cooling

	push	1
	push	0
	push	OFFSET ??_C@_04LKKJOPPH@WARM?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1469 : 				break;

	jmp	SHORT $LN28@DogfightDi
$LN25@DogfightDi:

; 1470 : 			case SMSClass::COOL:
; 1471 : 				LabelButton (7, "COOL");

	push	0
	push	0
	push	OFFSET ??_C@_04MCPDKIOE@COOL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1472 : 				break;

	jmp	SHORT $LN28@DogfightDi
$LN24@DogfightDi:

; 1473 : 			case SMSClass::WARMING:
; 1474 : 				LabelButton (7, "COOL", NULL, 1); // Is warming back up

	push	1
	push	0
	push	OFFSET ??_C@_04MCPDKIOE@COOL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN28@DogfightDi:

; 1475 : 				break;
; 1476 : 			}
; 1477 : 			
; 1478 : 			if(((MissileClass*)Sms->GetCurrentWeapon())->isSlave)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN23@DogfightDi

; 1479 : 			{
; 1480 : 				LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1481 : 			}
; 1482 : 			else

	jmp	SHORT $LN22@DogfightDi
$LN23@DogfightDi:

; 1483 : 			{
; 1484 : 				LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN22@DogfightDi:

; 1485 : 			}
; 1486 : 			// Marco Edit - TD/BP Mode
; 1487 : 			if(((MissileClass*)Sms->GetCurrentWeapon())->isTD && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	cmp	DWORD PTR [eax+740], 0
	je	SHORT $LN21@DogfightDi
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN21@DogfightDi

; 1488 : 			{
; 1489 : 				LabelButton (17, "TD");

	push	0
	push	0
	push	OFFSET ??_C@_02PPBOCKIA@TD?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN20@DogfightDi
$LN21@DogfightDi:

; 1490 : 			}
; 1491 : 			else if(((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN20@DogfightDi

; 1492 : 			{
; 1493 : 				LabelButton (17, "BP");

	push	0
	push	0
	push	OFFSET ??_C@_02MJBLCCBH@BP?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN20@DogfightDi:

; 1494 : 			}
; 1495 : 
; 1496 : 			// Marco Edit - SPOT/SCAN Mode
; 1497 : 			if (((MissileClass*)Sms->GetCurrentWeapon())->isSpot && 
; 1498 : 				((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P
; 1499 : 			){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+732], 0
	je	SHORT $LN18@DogfightDi
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN18@DogfightDi

; 1500 : 				LabelButton (2, "SPOT");

	push	0
	push	0
	push	OFFSET ??_C@_04CIHCOAPG@SPOT?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN17@DogfightDi
$LN18@DogfightDi:

; 1501 : 			}
; 1502 : 			else if(((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	edx, al
	cmp	edx, 17					; 00000011H
	je	SHORT $LN17@DogfightDi

; 1503 : 			{
; 1504 : 				LabelButton (2, "SCAN");

	push	0
	push	0
	push	OFFSET ??_C@_04NAGNMPFG@SCAN?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN17@DogfightDi:

; 1505 : 			}
; 1506 : 		}

	jmp	$LN15@DogfightDi
$LN30@DogfightDi:

; 1507 : 		else if(Sms->curWeaponType == wtAim120)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 2
	jne	$LN15@DogfightDi

; 1508 : 		{
; 1509 : 			if (Sms->curWeaponType == wtAim120 &&
; 1510 : 				Sms->MasterArm() == SMSBaseClass::Safe ||
; 1511 : 				Sms->MasterArm() == SMSBaseClass::Sim) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 2
	jne	SHORT $LN11@DogfightDi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	je	SHORT $LN12@DogfightDi
$LN11@DogfightDi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 1
	jne	SHORT $LN13@DogfightDi
$LN12@DogfightDi:

; 1512 : 			{ // JPO new AIM120 code
; 1513 : 				LabelButton(7, "BIT");

	push	0
	push	0
	push	OFFSET ??_C@_03EODKJOEK@BIT?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1514 : 				LabelButton(8, "ALBIT");

	push	0
	push	0
	push	OFFSET ??_C@_05IHLLIMHE@ALBIT?$AA@
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN13@DogfightDi:

; 1515 : 			}
; 1516 : 			char idnum[10];
; 1517 : 			sprintf(idnum, "%d", Sms->AimId());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?AimId@SMSClass@@QAEHXZ			; SMSClass::AimId
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	ecx, DWORD PTR _idnum$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1518 : 			LabelButton (16, "ID", idnum);

	push	0
	lea	edx, DWORD PTR _idnum$1[ebp]
	push	edx
	push	OFFSET ??_C@_02OLOABKKD@ID?$AA@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1519 : 			LabelButton (17, "TM", "OFF");  // JPG 12 Jan 03 - ON is for telemetry missile

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_02CONMJBMJ@TM?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1520 : 
; 1521 : 			if(Sms && Sms->GetCurrentWeapon() && ((MissileClass*)Sms->GetCurrentWeapon())->isSlave)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	SHORT $LN10@DogfightDi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	je	SHORT $LN10@DogfightDi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN10@DogfightDi

; 1522 : 			{
; 1523 : 				LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1524 : 			}
; 1525 : 			else

	jmp	SHORT $LN15@DogfightDi
$LN10@DogfightDi:

; 1526 : 			{
; 1527 : 				LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN15@DogfightDi:

; 1528 : 			}
; 1529 : 		}
; 1530 : 	}

	jmp	$LN33@DogfightDi
$LN31@DogfightDi:

; 1531 : 	// AIM9Ps only have Bore/Slave to worry about
; 1532 : 	else if (Sms->curWeapon && ((CampBaseClass*)wpn)->GetSPType() == SPTYPE_AIM9P ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@DogfightDi
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN7@DogfightDi

; 1533 : 	    ShiAssert(Sms->curWeapon->IsMissile());
; 1534 : 		if (((MissileClass*)Sms->GetCurrentWeapon())->isSlave){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN6@DogfightDi

; 1535 : 			LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1536 : 		}
; 1537 : 		else {

	jmp	SHORT $LN5@DogfightDi
$LN6@DogfightDi:

; 1538 : 			LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN5@DogfightDi:

; 1539 : 		}

	jmp	SHORT $LN33@DogfightDi
$LN7@DogfightDi:

; 1540 : 	}
; 1541 : 	else if (Sms->curWeapon && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN33@DogfightDi
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN33@DogfightDi

; 1542 : 	{
; 1543 : 		// Keep non-full avionics mode as is display wise
; 1544 : 		ShiAssert(Sms->curWeapon->IsMissile());
; 1545 : 
; 1546 : 		if (((MissileClass*)Sms->GetCurrentWeapon())->isCaged)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+728], 0
	je	SHORT $LN2@DogfightDi

; 1547 : 		{
; 1548 : 			LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1549 : 		}
; 1550 : 		else

	jmp	SHORT $LN33@DogfightDi
$LN2@DogfightDi:

; 1551 : 		{
; 1552 : 			LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN33@DogfightDi:

; 1553 : 		}
; 1554 : 	}
; 1555 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN35@DogfightDi:
	DD	$LN27@DogfightDi
	DD	$LN26@DogfightDi
	DD	$LN25@DogfightDi
	DD	$LN24@DogfightDi
?DogfightDisplay@SmsDrawable@@AAEXXZ ENDP		; SmsDrawable::DogfightDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv170 = -28						; size = 4
tv157 = -24						; size = 4
tv144 = -20						; size = 4
tv131 = -16						; size = 4
tv86 = -12						; size = 4
_pFCC$ = -8						; size = 4
_this$ = -4						; size = 4
?AGMenuDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::AGMenuDisplay
; _this$ = ecx

; 2253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 :     FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 2255 :     ShiAssert(FALSE==F4IsBadReadPtr(pFCC, sizeof *pFCC));
; 2256 :     LabelButton(19, "CCIP", NULL, pFCC->GetSubMode() == FireControlComputer::CCIP);

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 7
	jne	SHORT $LN3@AGMenuDisp
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN4@AGMenuDisp
$LN3@AGMenuDisp:
	mov	DWORD PTR tv86[ebp], 0
$LN4@AGMenuDisp:
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	push	0
	push	OFFSET ??_C@_04GKNPDGLD@CCIP?$AA@
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2257 :     LabelButton(18, "CCRP", NULL, pFCC->GetSubMode() == FireControlComputer::CCRP);

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 8
	jne	SHORT $LN5@AGMenuDisp
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN6@AGMenuDisp
$LN5@AGMenuDisp:
	mov	DWORD PTR tv131[ebp], 0
$LN6@AGMenuDisp:
	mov	edx, DWORD PTR tv131[ebp]
	push	edx
	push	0
	push	OFFSET ??_C@_04HKKMHKCC@CCRP?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2258 :     LabelButton(17, "DTOS", NULL, pFCC->GetSubMode() == FireControlComputer::DTOSS);

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN7@AGMenuDisp
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN8@AGMenuDisp
$LN7@AGMenuDisp:
	mov	DWORD PTR tv144[ebp], 0
$LN8@AGMenuDisp:
	mov	eax, DWORD PTR tv144[ebp]
	push	eax
	push	0
	push	OFFSET ??_C@_04DKJBKKPE@DTOS?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2259 :     LabelButton(16, "LADD", NULL, pFCC->GetSubMode() == FireControlComputer::LADD);

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 9
	jne	SHORT $LN9@AGMenuDisp
	mov	DWORD PTR tv157[ebp], 1
	jmp	SHORT $LN10@AGMenuDisp
$LN9@AGMenuDisp:
	mov	DWORD PTR tv157[ebp], 0
$LN10@AGMenuDisp:
	mov	ecx, DWORD PTR tv157[ebp]
	push	ecx
	push	0
	push	OFFSET ??_C@_04GEPACNOP@LADD?$AA@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2260 :     LabelButton(15, "MAN", NULL, pFCC->GetSubMode() == FireControlComputer::MAN);

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN11@AGMenuDisp
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN12@AGMenuDisp
$LN11@AGMenuDisp:
	mov	DWORD PTR tv170[ebp], 0
$LN12@AGMenuDisp:
	mov	edx, DWORD PTR tv170[ebp]
	push	edx
	push	0
	push	OFFSET ??_C@_03KIGHCFHP@MAN?$AA@
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AGMenuDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::AGMenuDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv499 = -40						; size = 4
_pFCC$ = -36						; size = 4
_this$ = -32						; size = 4
_tempstr$1 = -28					; size = 12
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?BombDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::BombDisplay
; _this$ = ecx

; 2125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2126 : 	char tmpStr[12];
; 2127 : 	FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 2128 : 	TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 2129 : 	BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 2130 : 	if(IsSet(MENUMODE)) {

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z ; SmsDrawable::IsSet
	test	eax, eax
	je	SHORT $LN29@BombDispla

; 2131 : 	    AGMenuDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AGMenuDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::AGMenuDisplay

; 2132 : 	    return;

	jmp	$LN30@BombDispla
$LN29@BombDispla:

; 2133 : 	}
; 2134 : 	// Count number of current weapons
; 2135 : 	sprintf (tmpStr, "%d%s", Sms->NumCurrentWpn(), Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->mnemonic);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	push	eax
	push	OFFSET ??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2136 : 	ShiAssert(strlen(tmpStr) < 12);
; 2137 : 	LabelButton (5,  tmpStr, "");

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2138 : 	
; 2139 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN28@BombDispla

; 2140 : 		SetWeapParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWeapParams@SmsDrawable@@QAEXXZ	; SmsDrawable::SetWeapParams
$LN28@BombDispla:

; 2141 : 	// OSS Button Labels
; 2142 : 	//MI
; 2143 : 
; 2144 : 	if (Sms->curWeaponClass == wcRocketWpn)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+156], 1
	jne	SHORT $LN27@BombDispla

; 2145 : 	{
; 2146 : 		// since pair/single is the only thing modelled for rockets
; 2147 : 		if (Sms->GetAGBPair())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@BombDispla

; 2148 : 			LabelButton (7,  "PAIR");

	push	0
	push	0
	push	OFFSET ??_C@_04NFKAHBOI@PAIR?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2149 : 		else

	jmp	SHORT $LN25@BombDispla
$LN26@BombDispla:

; 2150 : 			LabelButton (7,  "SGL");

	push	0
	push	0
	push	OFFSET ??_C@_03COBKBLOD@SGL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN25@BombDispla:

; 2151 : 	}
; 2152 : 	else

	jmp	$LN1@BombDispla
$LN27@BombDispla:

; 2153 : 	{ 
; 2154 : 		LabelButton (4,  "CNTL");

	push	0
	push	0
	push	OFFSET ??_C@_04GKDMIDBA@CNTL?$AA@
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2155 : 
; 2156 : 		if(Sms->curProfile==0) // MLR 4/3/2004 - 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+196], 0
	jne	SHORT $LN23@BombDispla

; 2157 : 			LabelButton (6,  "PROF 1");

	push	0
	push	0
	push	OFFSET ??_C@_06JKMMOJOB@PROF?51?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2158 : 		else

	jmp	SHORT $LN22@BombDispla
$LN23@BombDispla:

; 2159 : 			LabelButton (6,  "PROF 2");

	push	0
	push	0
	push	OFFSET ??_C@_06LBOBLKCC@PROF?52?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN22@BombDispla:

; 2160 : 
; 2161 : 		if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN21@BombDispla

; 2162 : 		{
; 2163 : 			if (Sms->GetAGBPair())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@BombDispla

; 2164 : 				LabelButton (7,  "PAIR");

	push	0
	push	0
	push	OFFSET ??_C@_04NFKAHBOI@PAIR?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2165 : 			else

	jmp	SHORT $LN19@BombDispla
$LN20@BombDispla:

; 2166 : 				LabelButton (7,  "SGL");

	push	0
	push	0
	push	OFFSET ??_C@_03COBKBLOD@SGL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN19@BombDispla:

; 2167 : 		}
; 2168 : 		else

	jmp	SHORT $LN18@BombDispla
$LN21@BombDispla:

; 2169 : 		{
; 2170 : 			if (Sms->GetAGBPair())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetAGBPair@SMSClass@@QAE_NXZ		; SMSClass::GetAGBPair
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@BombDispla

; 2171 : 				sprintf(tmpStr, "%d PAIR", Sms->GetAGBRippleCount() + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_07LPGDFIGO@?$CFd?5PAIR?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2172 : 			else

	jmp	SHORT $LN16@BombDispla
$LN17@BombDispla:

; 2173 : 				sprintf(tmpStr, "%d SGL", Sms->GetAGBRippleCount() + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_06FNBDGPPC@?$CFd?5SGL?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN16@BombDispla:

; 2174 : 
; 2175 : 			LabelButton(7, tmpStr);

	push	0
	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN18@BombDispla:

; 2176 : 		}
; 2177 : 
; 2178 : 		sprintf (tmpStr, "%dFT", Sms->GetAGBRippleInterval());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBRippleInterval@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleInterval
	push	eax
	push	OFFSET ??_C@_04COHIKBOA@?$CFdFT?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2179 : 		LabelButton (8,  tmpStr);

	push	0
	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2180 : 
; 2181 : 		sprintf(tmpStr, "%d", Sms->GetAGBRippleCount() + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBRippleCount@SMSClass@@QAEHXZ	; SMSClass::GetAGBRippleCount
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2182 : 		LabelButton(9, "RP", tmpStr);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	OFFSET ??_C@_02NFDNIBGH@RP?$AA@
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2183 : 
; 2184 : 		if(g_bRealisticAvionics && !g_bMLU) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN11@BombDispla
	movzx	ecx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	ecx, ecx
	jne	$LN11@BombDispla

; 2185 : 		{
; 2186 : 			char tempstr[12]; //JAM 27Sep03 - Changed from 10, stack over run
; 2187 : 			sprintf(tempstr, "AD %.2fSEC", Sms->armingdelay / 100);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movss	xmm0, DWORD PTR [eax+172]
	divss	xmm0, DWORD PTR __real@42c80000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@JDHHFEFM@AD?5?$CF?42fSEC?$AA@
	lea	ecx, DWORD PTR _tempstr$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2188 : 			
; 2189 : 			display->TextLeft(-0.3F, 0.2F, tempstr);

	push	0
	lea	edx, DWORD PTR _tempstr$1[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2190 : 
; 2191 : 			if(pFCC && (pFCC->GetSubMode() == FireControlComputer::LADD ||
; 2192 : 				pFCC->GetSubMode() == FireControlComputer::CCRP ||
; 2193 : 				pFCC->GetSubMode() == FireControlComputer::DTOSS))

	cmp	DWORD PTR _pFCC$[ebp], 0
	je	SHORT $LN14@BombDispla
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 9
	je	SHORT $LN13@BombDispla
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 8
	je	SHORT $LN13@BombDispla
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN14@BombDispla
$LN13@BombDispla:

; 2194 : 			{
; 2195 : 				sprintf(tempstr, "REL ANG %d", Sms->GetAGBReleaseAngle());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBReleaseAngle@SMSClass@@QAEHXZ	; SMSClass::GetAGBReleaseAngle
	push	eax
	push	OFFSET ??_C@_0L@KPDBGAEJ@REL?5ANG?5?$CFd?$AA@
	lea	ecx, DWORD PTR _tempstr$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2196 : 				display->TextLeft(-0.3F, 0.0F, tempstr);

	push	0
	lea	edx, DWORD PTR _tempstr$1[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+56]
	call	edx
$LN14@BombDispla:

; 2197 : 			}
; 2198 : 			if (Sms->curHardpoint >= 0 &&
; 2199 : 				Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+44], 0
	jl	$LN12@BombDispla
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	eax, DWORD PTR [eax]
	and	eax, 4
	je	SHORT $LN12@BombDispla

; 2200 : 			{ 
; 2201 : 				sprintf (tempstr, "BA %.0fFT", Sms->burstHeight);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cvtss2sd xmm0, DWORD PTR [edx+76]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DCKDOAA@BA?5?$CF?40fFT?$AA@
	lea	eax, DWORD PTR _tempstr$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2202 : 				display->TextLeft(-0.3F, 0.1F, tempstr);

	push	0
	lea	ecx, DWORD PTR _tempstr$1[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN12@BombDispla:

; 2203 : 			}
; 2204 : 			if(pFCC && pFCC->GetSubMode() == FireControlComputer::LADD)

	cmp	DWORD PTR _pFCC$[ebp], 0
	je	$LN11@BombDispla
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 9
	jne	$LN11@BombDispla

; 2205 : 			{
; 2206 : 				display->TextCenter(-0.3F, -0.1F, "PR 25000");

	push	0
	push	OFFSET ??_C@_08JIGPNNJC@PR?525000?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@bdcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 2207 : 				display->TextCenter(-0.3F, -0.2F, "TOF 28.00");

	push	0
	push	OFFSET ??_C@_09OOMNNBBE@TOF?528?400?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@be4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 2208 : 				display->TextCenter(-0.3F, -0.3F, "MRA 1105");

	push	0
	push	OFFSET ??_C@_08JGHEKJJF@MRA?51105?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN11@BombDispla:

; 2209 : 			}
; 2210 : 		}
; 2211 : 
; 2212 : 		//OWLOOK we need a switch here for arming delay
; 2213 : 		//if (g_bArmingDelay)	MI
; 2214 : 		if(g_bRealisticAvionics && g_bMLU)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN10@BombDispla
	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	je	SHORT $LN10@BombDispla

; 2215 : 		{
; 2216 : 			sprintf (tmpStr, "AD %.0f", Sms->armingdelay);//me123 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cvtss2sd xmm0, DWORD PTR [ecx+172]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07JGACOHHB@AD?5?$CF?40f?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2217 : 			LabelButton (15,  tmpStr);//me123 

	push	0
	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN10@BombDispla:

; 2218 : 		}
; 2219 : 		
; 2220 : 		//MI
; 2221 : 		if(g_bRealisticAvionics) {

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN9@BombDispla

; 2222 : 			switch(Sms->GetAGBFuze()) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetAGBFuze@SMSClass@@QAEHXZ		; SMSClass::GetAGBFuze
	mov	DWORD PTR tv499[ebp], eax
	cmp	DWORD PTR tv499[ebp], 0
	je	SHORT $LN6@BombDispla
	cmp	DWORD PTR tv499[ebp], 1
	je	SHORT $LN5@BombDispla
	cmp	DWORD PTR tv499[ebp], 2
	je	SHORT $LN4@BombDispla
	jmp	SHORT $LN7@BombDispla
$LN6@BombDispla:

; 2223 : 				case 0:
; 2224 : 					LabelButton (17, "NSTL");

	push	0
	push	0
	push	OFFSET ??_C@_04DANPMIOD@NSTL?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2225 : 					break;

	jmp	SHORT $LN7@BombDispla
$LN5@BombDispla:

; 2226 : 				case 1:
; 2227 : 					LabelButton (17, "NOSE");

	push	0
	push	0
	push	OFFSET ??_C@_04POJNINAI@NOSE?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2228 : 					break;

	jmp	SHORT $LN7@BombDispla
$LN4@BombDispla:

; 2229 : 				case 2:
; 2230 : 					LabelButton (17, "TAIL");

	push	0
	push	0
	push	OFFSET ??_C@_04PEGBOIPH@TAIL?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN7@BombDispla:

; 2231 : 					break;
; 2232 : 			}
; 2233 : 		}
; 2234 : 		else {

	jmp	SHORT $LN3@BombDispla
$LN9@BombDispla:

; 2235 : 			LabelButton (17, "NSTL");

	push	0
	push	0
	push	OFFSET ??_C@_04DANPMIOD@NSTL?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN3@BombDispla:

; 2236 : 		}
; 2237 : 
; 2238 : 		//MI not here in real
; 2239 : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN1@BombDispla

; 2240 : 		{
; 2241 : 			if (Sms->curHardpoint >= 0 &&
; 2242 : 				Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+44], 0
	jl	$LN1@BombDispla
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+148]
	call	edx
	mov	eax, DWORD PTR [eax]
	and	eax, 4
	je	SHORT $LN1@BombDispla

; 2243 : 			{
; 2244 : 				sprintf (tmpStr, "BA %.0f", Sms->burstHeight);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cvtss2sd xmm0, DWORD PTR [edx+76]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07EKLFMPDF@BA?5?$CF?40f?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2245 : 				LabelButton (18,  tmpStr);

	push	0
	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@BombDispla:
$LN30@BombDispla:

; 2246 : 			}
; 2247 : 		}
; 2248 : 	}
; 2249 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?BombDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::BombDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?CameraDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::CameraDisplay
; _this$ = ecx

; 2267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2268 : 	char tmpStr[12];
; 2269 : 	TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 2270 : 	if (!Sms->CurStationOK())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?CurStationOK@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurStationOK
	test	eax, eax
	jne	SHORT $LN4@CameraDisp

; 2271 : 	{
; 2272 : 		LabelButton (2, "MAL");

	push	0
	push	0
	push	OFFSET ??_C@_03JKFBEHPN@MAL?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN3@CameraDisp
$LN4@CameraDisp:

; 2273 : 	}
; 2274 : 	else if (Sms->ownship->OnGround())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN2@CameraDisp

; 2275 : 	{
; 2276 : 		LabelButton (2, "RDY");

	push	0
	push	0
	push	OFFSET ??_C@_03KDFFCEML@RDY?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2277 : 	}
; 2278 : 	else

	jmp	SHORT $LN3@CameraDisp
$LN2@CameraDisp:

; 2279 : 	{
; 2280 : 		LabelButton (2, "RUN");

	push	0
	push	0
	push	OFFSET ??_C@_03LLDCGJBK@RUN?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN3@CameraDisp:

; 2281 : 	}
; 2282 : 	
; 2283 : 	BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 2284 : 	
; 2285 : 	sprintf (tmpStr, "IDX %d", frameCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ??_C@_06LAIPFJMN@IDX?5?$CFd?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2286 : 	LabelButton (19, tmpStr);

	push	0
	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2287 : 	
; 2288 : 	LabelButton (5, "RPOD");

	push	0
	push	0
	push	OFFSET ??_C@_04FPNANLBH@RPOD?$AA@
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2289 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::CameraDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_pFCC$ = -20						; size = 4
tv248 = -16						; size = 4
tv243 = -12						; size = 4
_laserPod$ = -8						; size = 4
_this$ = -4						; size = 4
?GBUDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::GBUDisplay
; _this$ = ecx

; 1884 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1885 : 	flash = (vuxRealTime & 0x200);

	mov	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	eax, 512				; 00000200H
	mov	DWORD PTR ?flash@SmsDrawable@@2HA, eax	; SmsDrawable::flash

; 1886 : 
; 1887 : 	LaserPodClass* laserPod = (LaserPodClass*)FindLaserPod (Sms->ownship);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$[ebp], eax

; 1888 : 	FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	mov	DWORD PTR _pFCC$[ebp], eax

; 1889 : 		
; 1890 : 	if (laserPod)

	cmp	DWORD PTR _laserPod$[ebp], 0
	je	SHORT $LN7@GBUDisplay

; 1891 : 	{
; 1892 : 		laserPod->SetIntensity(GetIntensity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIntensity@DrawableClass@@QAEIXZ	; DrawableClass::GetIntensity
	push	eax
	mov	ecx, DWORD PTR _laserPod$[ebp]
	call	?SetIntensity@DrawableClass@@QAEXI@Z	; DrawableClass::SetIntensity

; 1893 : 		laserPod->Display(display);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _laserPod$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _laserPod$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN7@GBUDisplay:

; 1894 : 	}
; 1895 : 	
; 1896 : 	// OSS Button Labels
; 1897 : 	LabelButton (0, "OPER");

	push	0
	push	0
	push	OFFSET ??_C@_04NGKPLICF@OPER?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1898 : 	//MI
; 1899 : 	//if (laserPod && laserPod->CurFOV() < (3.0F * DTR))
; 1900 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@GBUDisplay

; 1901 : 	{
; 1902 : 		if (laserPod && laserPod->CurFOV() < (3.5F * DTR))

	cmp	DWORD PTR _laserPod$[ebp], 0
	je	SHORT $LN5@GBUDisplay
	mov	ecx, DWORD PTR _laserPod$[ebp]
	call	?CurFOV@LaserPodClass@@QAEMXZ		; LaserPodClass::CurFOV
	fstp	DWORD PTR tv243[ebp]
	movss	xmm0, DWORD PTR __real@3d7a35db
	comiss	xmm0, DWORD PTR tv243[ebp]
	jbe	SHORT $LN5@GBUDisplay

; 1903 : 			LabelButton (2, "EXP", NULL, 1);

	push	1
	push	0
	push	OFFSET ??_C@_03KKGFKKLA@EXP?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1904 : 		else

	jmp	SHORT $LN4@GBUDisplay
$LN5@GBUDisplay:

; 1905 : 			LabelButton (2, "FOV");

	push	0
	push	0
	push	OFFSET ??_C@_03PHODBHCN@FOV?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN4@GBUDisplay:

; 1906 : 	}
; 1907 : 	else

	jmp	SHORT $LN1@GBUDisplay
$LN6@GBUDisplay:

; 1908 : 	{
; 1909 : 		if(laserPod && laserPod->CurFOV() < (3.5F * DTR))

	cmp	DWORD PTR _laserPod$[ebp], 0
	je	SHORT $LN2@GBUDisplay
	mov	ecx, DWORD PTR _laserPod$[ebp]
	call	?CurFOV@LaserPodClass@@QAEMXZ		; LaserPodClass::CurFOV
	fstp	DWORD PTR tv248[ebp]
	movss	xmm0, DWORD PTR __real@3d7a35db
	comiss	xmm0, DWORD PTR tv248[ebp]
	jbe	SHORT $LN2@GBUDisplay

; 1910 : 			LabelButton (2, "NARO", NULL);

	push	0
	push	0
	push	OFFSET ??_C@_04OFGPHIIG@NARO?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1911 : 		else

	jmp	SHORT $LN1@GBUDisplay
$LN2@GBUDisplay:

; 1912 : 			LabelButton (2, "WIDE", NULL);

	push	0
	push	0
	push	OFFSET ??_C@_04KPGPJCNC@WIDE?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@GBUDisplay:

; 1913 : 	}
; 1914 : 
; 1915 : 	BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 1916 : 	LabelButton (19, pFCC->subModeString, NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _pFCC$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1917 : 	
; 1918 : 	// Show Available wpns
; 1919 : 	ShowMissiles(5);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowMissiles@SmsDrawable@@AAEXH@Z	; SmsDrawable::ShowMissiles

; 1920 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GBUDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::GBUDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_FCC$ = -20						; size = 4
_harmPod$ = -16						; size = 4
tv279 = -12						; size = 4
tv272 = -8						; size = 4
_this$ = -4						; size = 4
?HarmDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::HarmDisplay
; _this$ = ecx

; 2085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2086 :     HarmTargetingPod* harmPod = (HarmTargetingPod*)FindSensor(Sms->ownship, SensorClass::HTS);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _harmPod$[ebp], eax

; 2087 : 	FireControlComputer *FCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _FCC$[ebp], eax

; 2088 :      
; 2089 :     LabelButton (0,  "A-G");

	push	0
	push	0
	push	OFFSET ??_C@_03HCLOBDMK@A?9G?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2090 :     LabelButton (1,  "TER", "TBL1");

	push	0
	push	OFFSET ??_C@_04HKIOICEJ@TBL1?$AA@
	push	OFFSET ??_C@_03GEAIMIOL@TER?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2091 : 
; 2092 : 	LabelButton (3,  "INV");

	push	0
	push	0
	push	OFFSET ??_C@_03KOECGNEM@INV?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2093 : 
; 2094 : 	// RV - I-Hawk - HARM power up timing
; 2095 : 	if( !Sms->GetHARMPowerState() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ; SMSBaseClass::GetHARMPowerState
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@HarmDispla

; 2096 : 	{
; 2097 :         LabelButton (6,  "PWR", "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	$LN1@HarmDispla
$LN6@HarmDispla:

; 2098 : 	}
; 2099 : 
; 2100 : 	else if ( Sms->GetHARMPowerState() && Sms->GetHARMInitTimer() > 1.75f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ; SMSBaseClass::GetHARMPowerState
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@HarmDispla
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetHARMInitTimer@SMSBaseClass@@QAEMXZ	; SMSBaseClass::GetHARMInitTimer
	fstp	DWORD PTR tv272[ebp]
	movss	xmm0, DWORD PTR tv272[ebp]
	comiss	xmm0, DWORD PTR __real@3fe00000
	jbe	SHORT $LN4@HarmDispla

; 2101 : 	{
; 2102 : 		LabelButton (6,  "ALIGN");

	push	0
	push	0
	push	OFFSET ??_C@_05OKAJNMKE@ALIGN?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN1@HarmDispla
$LN4@HarmDispla:

; 2103 : 	}
; 2104 : 
; 2105 : 	else if ( Sms->GetHARMPowerState() && Sms->GetHARMInitTimer() > 1.0f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ; SMSBaseClass::GetHARMPowerState
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@HarmDispla
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetHARMInitTimer@SMSBaseClass@@QAEMXZ	; SMSBaseClass::GetHARMInitTimer
	fstp	DWORD PTR tv279[ebp]
	movss	xmm0, DWORD PTR tv279[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN2@HarmDispla

; 2106 : 	{
; 2107 : 		LabelButton (6,  "INIT");

	push	0
	push	0
	push	OFFSET ??_C@_04LGGJDDML@INIT?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2108 : 	}
; 2109 : 
; 2110 : 	else

	jmp	SHORT $LN1@HarmDispla
$LN2@HarmDispla:

; 2111 : 		LabelButton (6,  "PWR", "ON");

	push	0
	push	OFFSET ??_C@_02BFICIOJL@ON?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@HarmDispla:

; 2112 : 
; 2113 :     LabelButton (7,  "BIT");

	push	0
	push	0
	push	OFFSET ??_C@_03EODKJOEK@BIT?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2114 : 
; 2115 : 	LabelButton (19,  "CD", "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_02OGHHJPHF@CD?$AA@
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2116 : 
; 2117 :     BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 2118 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HarmDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::HarmDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv156 = -28						; size = 4
_wpn$ = -24						; size = 4
_this$ = -20						; size = 4
_idnum$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?AAMDisplay@SmsDrawable@@AAEXXZ PROC			; SmsDrawable::AAMDisplay
; _this$ = ecx

; 1927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1928 : 	// Marco Edit - SLAVE/BORE Mode
; 1929 :     SimWeaponClass* wpn = NULL; 

	mov	DWORD PTR _wpn$[ebp], 0

; 1930 : 	wpn = Sms->GetCurrentWeapon();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _wpn$[ebp], eax

; 1931 : 
; 1932 : 	ShiAssert(wpn != NULL);
; 1933 : // MN return for now if no weapon found...CTD "fix"
; 1934 : 	if (!wpn)

	cmp	DWORD PTR _wpn$[ebp], 0
	jne	SHORT $LN24@AAMDisplay

; 1935 : 		return;

	jmp	$LN25@AAMDisplay
$LN24@AAMDisplay:

; 1936 : 
; 1937 : 	if (Sms->curWeaponType == wtAim120 &&
; 1938 : 	    Sms->MasterArm() == SMSBaseClass::Safe ||
; 1939 : 		Sms->MasterArm() == SMSBaseClass::Sim) { // JPO new AIM120 code

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 2
	jne	SHORT $LN21@AAMDisplay
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	je	SHORT $LN22@AAMDisplay
$LN21@AAMDisplay:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 1
	jne	SHORT $LN23@AAMDisplay
$LN22@AAMDisplay:

; 1940 : 	    LabelButton(7, "BIT");

	push	0
	push	0
	push	OFFSET ??_C@_03EODKJOEK@BIT?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1941 : 	    LabelButton(8, "ALBIT");

	push	0
	push	0
	push	OFFSET ??_C@_05IHLLIMHE@ALBIT?$AA@
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	$LN20@AAMDisplay
$LN23@AAMDisplay:

; 1942 : 	}
; 1943 : 	else if (Sms->curWeaponType == wtAim9 && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	$LN20@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN20@AAMDisplay

; 1944 : 	{ // JPO new Aim9 code
; 1945 : 	    switch (Sms->GetCoolState() ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	mov	DWORD PTR tv156[ebp], eax
	cmp	DWORD PTR tv156[ebp], 3
	ja	SHORT $LN20@AAMDisplay
	mov	edx, DWORD PTR tv156[ebp]
	jmp	DWORD PTR $LN27@AAMDisplay[edx*4]
$LN16@AAMDisplay:

; 1946 : 		{
; 1947 : 	    case SMSClass::WARM:
; 1948 : 			LabelButton (7, "WARM"); // needs cooling

	push	0
	push	0
	push	OFFSET ??_C@_04LKKJOPPH@WARM?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1949 : 			break;

	jmp	SHORT $LN20@AAMDisplay
$LN15@AAMDisplay:

; 1950 : 	    case SMSClass::COOLING:
; 1951 : 			LabelButton (7, "WARM", NULL, 1); // is cooling

	push	1
	push	0
	push	OFFSET ??_C@_04LKKJOPPH@WARM?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1952 : 			break;

	jmp	SHORT $LN20@AAMDisplay
$LN14@AAMDisplay:

; 1953 : 	    case SMSClass::COOL:
; 1954 : 			LabelButton (7, "COOL");

	push	0
	push	0
	push	OFFSET ??_C@_04MCPDKIOE@COOL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1955 : 			break;

	jmp	SHORT $LN20@AAMDisplay
$LN13@AAMDisplay:

; 1956 : 		case SMSClass::WARMING:
; 1957 : 			LabelButton (7, "COOL", NULL, 1); // Is warming back up

	push	1
	push	0
	push	OFFSET ??_C@_04MCPDKIOE@COOL?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN20@AAMDisplay:

; 1958 : 			break;
; 1959 : 	    }	    
; 1960 : 	}
; 1961 : 	// JPO ID and Telemetry readouts.
; 1962 : 	if (Sms->curWeaponType == wtAim120) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 2
	jne	SHORT $LN12@AAMDisplay

; 1963 : 	    char idnum[10];
; 1964 : 	    sprintf (idnum, "%d", Sms->AimId());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?AimId@SMSClass@@QAEHXZ			; SMSClass::AimId
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	eax, DWORD PTR _idnum$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1965 : 	    LabelButton (16, "ID", idnum);

	push	0
	lea	ecx, DWORD PTR _idnum$1[ebp]
	push	ecx
	push	OFFSET ??_C@_02OLOABKKD@ID?$AA@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1966 : 	    LabelButton (17, "TM", "OFF"); // JPG 20 Jan 04 - telemetry OFF

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_02CONMJBMJ@TM?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN12@AAMDisplay:

; 1967 : 	}
; 1968 : 	if (g_bRealisticAvionics && Sms->curWeapon)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN25@AAMDisplay
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN25@AAMDisplay

; 1969 : 	{
; 1970 : 	    ShiAssert(Sms->curWeapon->IsMissile());
; 1971 : 		if (((MissileClass*)Sms->GetCurrentWeapon())->isSlave && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P) // && Sms->curWeaponType == wtAim9)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN10@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN10@AAMDisplay

; 1972 : 		{
; 1973 : 			LabelButton (18, "SLAV");

	push	0
	push	0
	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN9@AAMDisplay
$LN10@AAMDisplay:

; 1974 : 		}
; 1975 : 		else if(Sms->curWeaponType != wtAim9 || ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+148], 1
	jne	SHORT $LN7@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	ecx, al
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN9@AAMDisplay
$LN7@AAMDisplay:

; 1976 : 		{
; 1977 : 			LabelButton (18, "BORE");

	push	0
	push	0
	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN9@AAMDisplay:

; 1978 : 		}
; 1979 : 		// Marco Edit - TD/BP Mode
; 1980 : 		if (((MissileClass*)Sms->GetCurrentWeapon())->isTD && Sms->curWeaponType == wtAim9 && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+740], 0
	je	SHORT $LN6@AAMDisplay
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN6@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN6@AAMDisplay

; 1981 : 		{
; 1982 : 			LabelButton (17, "TD");

	push	0
	push	0
	push	OFFSET ??_C@_02PPBOCKIA@TD?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN5@AAMDisplay
$LN6@AAMDisplay:

; 1983 : 		}
; 1984 : 		else if (Sms->curWeaponType == wtAim9 && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN5@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN5@AAMDisplay

; 1985 : 		{
; 1986 : 			LabelButton (17, "BP");

	push	0
	push	0
	push	OFFSET ??_C@_02MJBLCCBH@BP?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN5@AAMDisplay:

; 1987 : 		}
; 1988 : 
; 1989 : 		// Marco Edit - SPOT/SCAN Mode
; 1990 : 		if (
; 1991 : 			((MissileClass*)Sms->GetCurrentWeapon())->isSpot && 
; 1992 : 			Sms->curWeaponType == wtAim9 && 
; 1993 : 			((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P
; 1994 : 		){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+732], 0
	je	SHORT $LN3@AAMDisplay
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN3@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN3@AAMDisplay

; 1995 : 			LabelButton (2, "SPOT");

	push	0
	push	0
	push	OFFSET ??_C@_04CIHCOAPG@SPOT?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN25@AAMDisplay
$LN3@AAMDisplay:

; 1996 : 		}
; 1997 : 		else if (Sms->curWeaponType == wtAim9 && ((CampBaseClass*)wpn)->GetSPType() != SPTYPE_AIM9P){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 1
	jne	SHORT $LN25@AAMDisplay
	mov	ecx, DWORD PTR _wpn$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	cmp	eax, 17					; 00000011H
	je	SHORT $LN25@AAMDisplay

; 1998 : 			LabelButton (2, "SCAN");

	push	0
	push	0
	push	OFFSET ??_C@_04NAGNMPFG@SCAN?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN25@AAMDisplay:

; 1999 : 		}
; 2000 : 	}
; 2001 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN27@AAMDisplay:
	DD	$LN16@AAMDisplay
	DD	$LN15@AAMDisplay
	DD	$LN14@AAMDisplay
	DD	$LN13@AAMDisplay
?AAMDisplay@SmsDrawable@@AAEXXZ ENDP			; SmsDrawable::AAMDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_range$ = -96						; size = 4
tv623 = -92						; size = 4
tv617 = -88						; size = 4
tv611 = -84						; size = 4
tv597 = -80						; size = 4
tv579 = -76						; size = 4
tv571 = -72						; size = 4
_self$ = -68						; size = 4
_playerAC$ = -64					; size = 4
tv478 = -60						; size = 4
_percentRange$ = -56					; size = 4
tv413 = -52						; size = 4
tv411 = -48						; size = 4
_dz$ = -44						; size = 4
_dy$ = -40						; size = 4
_dx$ = -36						; size = 4
_ZoomMin$ = -32						; size = 4
_ZoomMax$ = -28						; size = 4
_yOffset$ = -24						; size = 4
_rMax$ = -20						; size = 4
_rMin$ = -16						; size = 4
_mavDisplay$ = -12					; size = 4
_pFCC$ = -8						; size = 4
_this$ = -4						; size = 4
?MaverickDisplay@SmsDrawable@@AAEXXZ PROC		; SmsDrawable::MaverickDisplay
; _this$ = ecx

; 1782 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1783 : 	FireControlComputer* pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 1784 : 	MaverickDisplayClass* mavDisplay = NULL;

	mov	DWORD PTR _mavDisplay$[ebp], 0

; 1785 : 	//MI
; 1786 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1787 : 	AircraftClass *self = ((AircraftClass*)playerAC);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	DWORD PTR _self$[ebp], ecx

; 1788 : 	if(!self)

	cmp	DWORD PTR _self$[ebp], 0
	jne	SHORT $LN10@MaverickDi

; 1789 : 		return;

	jmp	$LN11@MaverickDi
$LN10@MaverickDi:

; 1790 : 	float yOffset;
; 1791 : 	float percentRange;
; 1792 : 	float rMax, rMin;
; 1793 : 	float range;
; 1794 : 	float dx, dy, dz;
; 1795 : 	
; 1796 : 	if (Sms->curWeapon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN6@MaverickDi

; 1797 : 	{
; 1798 : 	    ShiAssert(Sms->curWeapon->IsMissile());
; 1799 : 		mavDisplay = (MaverickDisplayClass*)((MissileClass*)Sms->GetCurrentWeapon())->display;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$[ebp], ecx

; 1800 : 
; 1801 : 		if (mavDisplay)

	cmp	DWORD PTR _mavDisplay$[ebp], 0
	je	SHORT $LN8@MaverickDi

; 1802 : 		{
; 1803 : 			mavDisplay->SetIntensity(GetIntensity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIntensity@DrawableClass@@QAEIXZ	; DrawableClass::GetIntensity
	push	eax
	mov	ecx, DWORD PTR _mavDisplay$[ebp]
	call	?SetIntensity@DrawableClass@@QAEXI@Z	; DrawableClass::SetIntensity

; 1804 : 			mavDisplay->viewPoint = viewPoint;

	mov	edx, DWORD PTR _mavDisplay$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 1805 : 			mavDisplay->Display(display);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mavDisplay$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _mavDisplay$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN8@MaverickDi:

; 1806 : 		}
; 1807 : 		
; 1808 : 		if (mavDisplay->IsSOI())

	mov	ecx, DWORD PTR _mavDisplay$[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN7@MaverickDi

; 1809 : 			LabelButton (1, "VIS", "");

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_03NOAAMIEF@VIS?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1810 : 		else

	jmp	SHORT $LN6@MaverickDi
$LN7@MaverickDi:

; 1811 : 			LabelButton (1, "PRE", "");

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_03PHIAGONP@PRE?$AA@
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN6@MaverickDi:

; 1812 : 	}
; 1813 : 	
; 1814 : 	// OSS Button Labels
; 1815 : 	LabelButton (0, "OPER");

	push	0
	push	0
	push	OFFSET ??_C@_04NGKPLICF@OPER?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1816 : 	//MI
; 1817 : 	//if (mavDisplay && mavDisplay->CurFOV() > (3.0F * DTR))
; 1818 : 	
; 1819 : 	// RV - Biker - Make FOV switching this dynamic
; 1820 : 	//if (mavDisplay && mavDisplay->CurFOV() > (3.5F * DTR))
; 1821 : 	float ZoomMin;
; 1822 : 	float ZoomMax;
; 1823 : 
; 1824 : 	if((MissileClass*)Sms->GetCurrentWeapon() && ((MissileClass*)Sms->GetCurrentWeapon())->GetEXPLevel() > 0 && ((MissileClass*)Sms->GetCurrentWeapon())->GetFOVLevel() > 0) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	je	$LN5@MaverickDi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	?GetEXPLevel@MissileClass@@QAEMXZ	; MissileClass::GetEXPLevel
	fstp	DWORD PTR tv571[ebp]
	movss	xmm0, DWORD PTR tv571[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@MaverickDi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	?GetFOVLevel@MissileClass@@QAEMXZ	; MissileClass::GetFOVLevel
	fstp	DWORD PTR tv579[ebp]
	movss	xmm0, DWORD PTR tv579[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@MaverickDi

; 1825 : 		ZoomMin = ((MissileClass*)Sms->GetCurrentWeapon())->GetFOVLevel();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	?GetFOVLevel@MissileClass@@QAEMXZ	; MissileClass::GetFOVLevel
	fstp	DWORD PTR _ZoomMin$[ebp]

; 1826 : 		ZoomMax = ((MissileClass*)Sms->GetCurrentWeapon())->GetEXPLevel();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	?GetEXPLevel@MissileClass@@QAEMXZ	; MissileClass::GetEXPLevel
	fstp	DWORD PTR _ZoomMax$[ebp]

; 1827 : 	}
; 1828 : 	else {

	jmp	SHORT $LN4@MaverickDi
$LN5@MaverickDi:

; 1829 : 		// This should work for old values
; 1830 : 		ZoomMin = 3.0f;

	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _ZoomMin$[ebp], xmm0

; 1831 : 		ZoomMax = 6.0f;

	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR _ZoomMax$[ebp], xmm0
$LN4@MaverickDi:

; 1832 : 	}
; 1833 : 
; 1834 : 	if (mavDisplay && mavDisplay->CurFOV() > 12.0f/(ZoomMax-(ZoomMax-ZoomMin)/2.0f) * DTR)

	cmp	DWORD PTR _mavDisplay$[ebp], 0
	je	SHORT $LN3@MaverickDi
	mov	ecx, DWORD PTR _mavDisplay$[ebp]
	call	?CurFOV@MaverickDisplayClass@@QAEMXZ	; MaverickDisplayClass::CurFOV
	fstp	DWORD PTR tv597[ebp]
	movss	xmm0, DWORD PTR tv597[ebp]
	movss	xmm1, DWORD PTR _ZoomMax$[ebp]
	subss	xmm1, DWORD PTR _ZoomMin$[ebp]
	divss	xmm1, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR _ZoomMax$[ebp]
	subss	xmm2, xmm1
	movss	xmm1, DWORD PTR __real@41400000
	divss	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@3c8efa34
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@MaverickDi

; 1835 : 		LabelButton (2, "FOV");

	push	0
	push	0
	push	OFFSET ??_C@_03PHODBHCN@FOV?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1836 : 	else

	jmp	SHORT $LN2@MaverickDi
$LN3@MaverickDi:

; 1837 : 		LabelButton (2, "EXP", NULL, 1);

	push	1
	push	0
	push	OFFSET ??_C@_03KKGFKKLA@EXP?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN2@MaverickDi:

; 1838 : 	LabelButton (4, "HOC");

	push	0
	push	0
	push	OFFSET ??_C@_03CAIJIGAK@HOC?$AA@
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1839 : 	BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 1840 : 	LabelButton (19, pFCC->subModeString);

	push	0
	push	0
	mov	ecx, DWORD PTR _pFCC$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 1841 : 	
; 1842 : 	// Mav DLZ
; 1843 : 	if (pFCC->missileTarget)

	mov	edx, DWORD PTR _pFCC$[ebp]
	movsx	eax, BYTE PTR [edx+192]
	test	eax, eax
	je	$LN1@MaverickDi

; 1844 : 	{
; 1845 : 		// Range Carat / Closure
; 1846 : 		rMax   = pFCC->missileRMax;

	mov	ecx, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR [ecx+288]
	movss	DWORD PTR _rMax$[ebp], xmm0

; 1847 : 		rMin   = pFCC->missileRMin;

	mov	edx, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR [edx+292]
	movss	DWORD PTR _rMin$[ebp], xmm0

; 1848 : 		
; 1849 : 		// get range to ground designaate point
; 1850 : 		dx = Sms->ownship->XPos() - pFCC->groundDesignateX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv611[ebp]
	movss	xmm0, DWORD PTR tv611[ebp]
	mov	edx, DWORD PTR _pFCC$[ebp]
	subss	xmm0, DWORD PTR [edx+376]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1851 : 		dy = Sms->ownship->YPos() - pFCC->groundDesignateY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv617[ebp]
	movss	xmm0, DWORD PTR tv617[ebp]
	mov	edx, DWORD PTR _pFCC$[ebp]
	subss	xmm0, DWORD PTR [edx+380]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1852 : 		dz = Sms->ownship->ZPos() - pFCC->groundDesignateZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv623[ebp]
	movss	xmm0, DWORD PTR tv623[ebp]
	mov	edx, DWORD PTR _pFCC$[ebp]
	subss	xmm0, DWORD PTR [edx+384]
	movss	DWORD PTR _dz$[ebp], xmm0

; 1853 : 		range = (float)sqrt( dx*dx + dy*dy + dz*dz );

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _range$[ebp]

; 1854 : 		
; 1855 : 		// Normailze the ranges for DLZ display
; 1856 : 		percentRange = range / pFCC->missileWEZDisplayRange;

	mov	eax, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR _range$[ebp]
	divss	xmm0, DWORD PTR [eax+312]
	movss	DWORD PTR _percentRange$[ebp], xmm0

; 1857 : 		rMin /= pFCC->missileWEZDisplayRange;

	mov	ecx, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR _rMin$[ebp]
	divss	xmm0, DWORD PTR [ecx+312]
	movss	DWORD PTR _rMin$[ebp], xmm0

; 1858 : 		rMax /= pFCC->missileWEZDisplayRange;

	mov	edx, DWORD PTR _pFCC$[ebp]
	movss	xmm0, DWORD PTR _rMax$[ebp]
	divss	xmm0, DWORD PTR [edx+312]
	movss	DWORD PTR _rMax$[ebp], xmm0

; 1859 : 		
; 1860 : 		// Clamp in place
; 1861 : 		rMin = min (rMin, 1.0F);

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rMin$[ebp]
	jbe	SHORT $LN13@MaverickDi
	movss	xmm0, DWORD PTR _rMin$[ebp]
	movss	DWORD PTR tv411[ebp], xmm0
	jmp	SHORT $LN14@MaverickDi
$LN13@MaverickDi:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv411[ebp], xmm0
$LN14@MaverickDi:
	movss	xmm0, DWORD PTR tv411[ebp]
	movss	DWORD PTR _rMin$[ebp], xmm0

; 1862 : 		rMax = min (rMax, 1.0F);

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rMax$[ebp]
	jbe	SHORT $LN15@MaverickDi
	movss	xmm0, DWORD PTR _rMax$[ebp]
	movss	DWORD PTR tv413[ebp], xmm0
	jmp	SHORT $LN16@MaverickDi
$LN15@MaverickDi:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv413[ebp], xmm0
$LN16@MaverickDi:
	movss	xmm0, DWORD PTR tv413[ebp]
	movss	DWORD PTR _rMax$[ebp], xmm0

; 1863 : 		
; 1864 : 		// Draw the symbol
; 1865 : 		
; 1866 : 		// Rmin/Rmax
; 1867 : 		display->Line (0.9F, -0.8F + rMin * 1.6F, 0.95F, -0.8F + rMin * 1.6F);

	movss	xmm0, DWORD PTR _rMin$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rMin$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1868 : 		display->Line (0.9F, -0.8F + rMin * 1.6F, 0.9F,  -0.8F + rMax * 1.6F);

	movss	xmm0, DWORD PTR _rMax$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rMin$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1869 : 		display->Line (0.9F, -0.8F + rMax * 1.6F, 0.95F, -0.8F + rMax * 1.6F);

	movss	xmm0, DWORD PTR _rMax$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rMax$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1870 : 		
; 1871 : 		// Range Caret
; 1872 : 		yOffset = min (-0.8F + percentRange * 1.6F, 1.0F);

	movss	xmm0, DWORD PTR _percentRange$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@MaverickDi
	movss	xmm0, DWORD PTR _percentRange$[ebp]
	mulss	xmm0, DWORD PTR __real@3fcccccd
	addss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR tv478[ebp], xmm0
	jmp	SHORT $LN18@MaverickDi
$LN17@MaverickDi:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv478[ebp], xmm0
$LN18@MaverickDi:
	movss	xmm0, DWORD PTR tv478[ebp]
	movss	DWORD PTR _yOffset$[ebp], xmm0

; 1873 : 		
; 1874 : 		display->Line (0.9F, yOffset, 0.9F - 0.03F, yOffset + 0.03F);

	movss	xmm0, DWORD PTR _yOffset$[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f5eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yOffset$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1875 : 		display->Line (0.9F, yOffset, 0.9F - 0.03F, yOffset - 0.03F);

	movss	xmm0, DWORD PTR _yOffset$[ebp]
	subss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f5eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yOffset$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN1@MaverickDi:
$LN11@MaverickDi:

; 1876 : 	}
; 1877 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MaverickDisplay@SmsDrawable@@AAEXXZ ENDP		; SmsDrawable::MaverickDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv85 = -8						; size = 4
_this$ = -4						; size = 4
?MissileDisplay@SmsDrawable@@AAEXXZ PROC		; SmsDrawable::MissileDisplay
; _this$ = ecx

; 1662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1663 : 	display->SetColor (GetMfdColor(MFD_LABELS));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 1664 : 
; 1665 : 	switch (Sms->curWeaponType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR tv85[ebp], edx
	mov	eax, DWORD PTR tv85[ebp]
	sub	eax, 1
	mov	DWORD PTR tv85[ebp], eax
	cmp	DWORD PTR tv85[ebp], 3
	ja	SHORT $LN6@MissileDis
	mov	ecx, DWORD PTR tv85[ebp]
	jmp	DWORD PTR $LN10@MissileDis[ecx*4]
$LN5@MissileDis:

; 1666 : 	{
; 1667 : 	case wtAgm65:
; 1668 : 		//MI
; 1669 : 		if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN4@MissileDis

; 1670 : 			MaverickDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MaverickDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::MaverickDisplay

; 1671 : 		else

	jmp	SHORT $LN3@MissileDis
$LN4@MissileDis:

; 1672 : 			MavSMSDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MavSMSDisplay@SmsDrawable@@QAEXXZ	; SmsDrawable::MavSMSDisplay
$LN3@MissileDis:

; 1673 : 		break;

	jmp	SHORT $LN6@MissileDis
$LN2@MissileDis:

; 1674 : 		
; 1675 : 	case wtAgm88:
; 1676 : 		HarmDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HarmDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::HarmDisplay

; 1677 : 		break;

	jmp	SHORT $LN6@MissileDis
$LN1@MissileDis:

; 1678 : 		
; 1679 : 	case wtAim9:
; 1680 : 	case wtAim120:
; 1681 : 	    TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 1682 : 	    BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 1683 : 	    AAMDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AAMDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::AAMDisplay
$LN6@MissileDis:

; 1684 : 		break;
; 1685 : 	}
; 1686 : 	
; 1687 : 	ShowMissiles(5);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowMissiles@SmsDrawable@@AAEXH@Z	; SmsDrawable::ShowMissiles

; 1688 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@MissileDis:
	DD	$LN1@MissileDis
	DD	$LN1@MissileDis
	DD	$LN2@MissileDis
	DD	$LN5@MissileDis
?MissileDisplay@SmsDrawable@@AAEXXZ ENDP		; SmsDrawable::MissileDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_pFCC$ = -32						; size = 4
_self$ = -28						; size = 4
_CAPplayer$ = -24					; size = 4
_this$ = -20						; size = 4
_tempstr$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?MavSMSDisplay@SmsDrawable@@QAEXXZ PROC			; SmsDrawable::MavSMSDisplay
; _this$ = ecx

; 2661 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2662 : 	AircraftClass *self = ((AircraftClass*)SimDriver.GetPlayerAircraft());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _self$[ebp], eax

; 2663 : 	int CAPplayer = 0;

	mov	DWORD PTR _CAPplayer$[ebp], 0

; 2664 : 	if (self->autopilotType == AircraftClass::CombatAP)

	mov	eax, DWORD PTR _self$[ebp]
	cmp	DWORD PTR [eax+968], 2
	jne	SHORT $LN9@MavSMSDisp

; 2665 : 		CAPplayer = 1;

	mov	DWORD PTR _CAPplayer$[ebp], 1
$LN9@MavSMSDisp:

; 2666 : 	FireControlComputer *pFCC = Sms->ownship->GetFCC();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	mov	DWORD PTR _pFCC$[ebp], eax

; 2667 : 	if(!pFCC)

	cmp	DWORD PTR _pFCC$[ebp], 0
	jne	SHORT $LN8@MavSMSDisp

; 2668 : 		return;

	jmp	$LN10@MavSMSDisp
$LN8@MavSMSDisp:

; 2669 : 	char tempstr[10] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _tempstr$[ebp], al
	xor	ecx, ecx
	mov	DWORD PTR _tempstr$[ebp+1], ecx
	mov	DWORD PTR _tempstr$[ebp+5], ecx
	mov	BYTE PTR _tempstr$[ebp+9], cl

; 2670 : 
; 2671 : 	if (CAPplayer)

	cmp	DWORD PTR _CAPplayer$[ebp], 0
	je	SHORT $LN7@MavSMSDisp

; 2672 : 	{
; 2673 : 		Sms->Powered = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	BYTE PTR [eax+16], 1

; 2674 : 		Sms->MavCoolTimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+20], xmm0

; 2675 : 		Sms->MavSubMode = SMSBaseClass::VIS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR [ecx+24], 1

; 2676 : 		LabelButton(6, "PWR", "ON");

	push	0
	push	OFFSET ??_C@_02BFICIOJL@ON?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN7@MavSMSDisp:

; 2677 : 	}
; 2678 : 
; 2679 : 	LabelButton(0, "A-G");

	push	0
	push	0
	push	OFFSET ??_C@_03HCLOBDMK@A?9G?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2680 : 	if(Sms->MavSubMode == SMSBaseClass::PRE)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN6@MavSMSDisp

; 2681 : 		sprintf(tempstr,"PRE");

	push	OFFSET ??_C@_03PHIAGONP@PRE?$AA@
	lea	ecx, DWORD PTR _tempstr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN3@MavSMSDisp
$LN6@MavSMSDisp:

; 2682 : 	else if(Sms->MavSubMode == SMSBaseClass::VIS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN4@MavSMSDisp

; 2683 : 		sprintf(tempstr, "VIS");

	push	OFFSET ??_C@_03NOAAMIEF@VIS?$AA@
	lea	ecx, DWORD PTR _tempstr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 2684 : 	else

	jmp	SHORT $LN3@MavSMSDisp
$LN4@MavSMSDisp:

; 2685 : 		sprintf(tempstr,"BORE");

	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	lea	edx, DWORD PTR _tempstr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN3@MavSMSDisp:

; 2686 : 	LabelButton(1,tempstr);

	push	0
	push	0
	lea	eax, DWORD PTR _tempstr$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2687 : 	LabelButton(3, "INV");

	push	0
	push	0
	push	OFFSET ??_C@_03KOECGNEM@INV?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2688 : 
; 2689 : 	if((Sms->Powered)&&(!CAPplayer))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	movzx	eax, BYTE PTR [edx+16]
	test	eax, eax
	je	SHORT $LN2@MavSMSDisp
	cmp	DWORD PTR _CAPplayer$[ebp], 0
	jne	SHORT $LN2@MavSMSDisp

; 2690 : 		LabelButton(6, "PWR", "ON");

	push	0
	push	OFFSET ??_C@_02BFICIOJL@ON?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2691 : 	else

	jmp	SHORT $LN1@MavSMSDisp
$LN2@MavSMSDisp:

; 2692 : 		LabelButton(6, "PWR", "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	OFFSET ??_C@_03PEMICIKC@PWR?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@MavSMSDisp:

; 2693 : 	LabelButton(7, "RP", "1");

	push	0
	push	OFFSET ??_C@_01HIHLOKLC@1?$AA@
	push	OFFSET ??_C@_02NFDNIBGH@RP?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2694 : 	LabelButton(18, "STEP");

	push	0
	push	0
	push	OFFSET ??_C@_04MOOLDHHD@STEP?$AA@
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2695 : 	//not here in the real deal
; 2696 : 	//LabelButton(19, pFCC->subModeString);
; 2697 : 	BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow
$LN10@MavSMSDisp:

; 2698 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?MavSMSDisplay@SmsDrawable@@QAEXXZ ENDP			; SmsDrawable::MavSMSDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetWeapParams@SmsDrawable@@QAEXXZ PROC			; SmsDrawable::SetWeapParams
; _this$ = ecx

; 2612 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2613 : 	if(Sms->curHardpoint >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+44], 0
	jl	$LN1@SetWeapPar

; 2614 : 	{
; 2615 : 		if(Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	eax, DWORD PTR [eax]
	and	eax, 4
	je	SHORT $LN5@SetWeapPar

; 2616 : 		{
; 2617 : 			//Sms->armingdelay = Sms->C2AD;
; 2618 : 			Sms->armingdelay = Sms->GetAGBC2ArmDelay();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBC2ArmDelay@SMSClass@@QAEMXZ	; SMSClass::GetAGBC2ArmDelay
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	fstp	DWORD PTR [eax+172]

; 2619 : 			//Sms->burstHeight = Sms->C2BA;
; 2620 : 			Sms->burstHeight = (float)Sms->GetAGBBurstAlt();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBBurstAlt@SMSClass@@QAEHXZ	; SMSClass::GetAGBBurstAlt
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	movss	DWORD PTR [eax+76], xmm0

; 2621 : 		}
; 2622 : 		else

	jmp	SHORT $LN1@SetWeapPar
$LN5@SetWeapPar:

; 2623 : 		{
; 2624 : 			// MLR 4/3/2004 - 
; 2625 : 			//Sms->rippleCount    = Sms->GetAGBRippleCount();
; 2626 : 			//Sms->rippleInterval = Sms->GetAGBRippleInterval();
; 2627 : 			//Sms->SetPair        ( Sms->GetAGBPair() );
; 2628 : 
; 2629 : 			if(Sms->GetAGBFuze() == 0 || Sms->GetAGBFuze() == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBFuze@SMSClass@@QAEHXZ		; SMSClass::GetAGBFuze
	test	eax, eax
	je	SHORT $LN2@SetWeapPar
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?GetAGBFuze@SMSClass@@QAEHXZ		; SMSClass::GetAGBFuze
	cmp	eax, 2
	jne	SHORT $LN3@SetWeapPar
$LN2@SetWeapPar:

; 2630 : 				Sms->armingdelay = Sms->GetAGBC1ArmDelay2();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBC1ArmDelay2@SMSClass@@QAEMXZ	; SMSClass::GetAGBC1ArmDelay2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	fstp	DWORD PTR [edx+172]

; 2631 : 			else

	jmp	SHORT $LN1@SetWeapPar
$LN3@SetWeapPar:

; 2632 : 				Sms->armingdelay = Sms->GetAGBC1ArmDelay1();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetAGBC1ArmDelay1@SMSClass@@QAEMXZ	; SMSClass::GetAGBC1ArmDelay1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	fstp	DWORD PTR [edx+172]
$LN1@SetWeapPar:

; 2633 : 			
; 2634 : 
; 2635 : 
; 2636 : 			/*
; 2637 : 			if(Sms->Prof1)
; 2638 : 			{ 
; 2639 : 				Sms->rippleCount = Sms->Prof1RP;
; 2640 : 				Sms->rippleInterval = Sms->Prof1RS;
; 2641 : 				Sms->SetPair(Sms->Prof1Pair);
; 2642 : 				if(Sms->Prof1NSTL == 0 || Sms->Prof1NSTL == 2)
; 2643 : 					Sms->armingdelay = Sms->C1AD2;
; 2644 : 				else
; 2645 : 					Sms->armingdelay = Sms->C1AD1;
; 2646 : 			}
; 2647 : 			else
; 2648 : 			{
; 2649 : 				Sms->rippleCount = Sms->Prof2RP;
; 2650 : 				Sms->rippleInterval = Sms->Prof2RS;
; 2651 : 				Sms->SetPair(Sms->Prof2Pair);
; 2652 : 				if(Sms->Prof2NSTL == 0 || Sms->Prof2NSTL == 2)
; 2653 : 					Sms->armingdelay = Sms->C1AD2;
; 2654 : 				else
; 2655 : 					Sms->armingdelay = Sms->C1AD1;
; 2656 : 			} */
; 2657 : 		}
; 2658 : 	}
; 2659 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetWeapParams@SmsDrawable@@QAEXXZ ENDP			; SmsDrawable::SetWeapParams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_button$ = 8						; size = 4
?ChangeToInput@SmsDrawable@@QAEXH@Z PROC		; SmsDrawable::ChangeToInput
; _this$ = ecx

; 2496 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2497 : 	ClearDigits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearDigits@SmsDrawable@@QAEXXZ	; SmsDrawable::ClearDigits

; 2498 : 	lastInputMode = displayMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR [eax+208], edx

; 2499 : 	SetDisplayMode(InputMode);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 2500 : 	InputLine = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+252], 0

; 2501 : 	MaxInputLines = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+256], 1

; 2502 : 	InputsMade = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], 0

; 2503 : 	switch(button)

	mov	eax, DWORD PTR _button$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, 4
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 14			; 0000000eH
	ja	$LN11@ChangeToIn
	mov	edx, DWORD PTR tv72[ebp]
	movzx	eax, BYTE PTR $LN13@ChangeToIn[edx]
	jmp	DWORD PTR $LN14@ChangeToIn[eax*4]
$LN8@ChangeToIn:

; 2504 : 	{
; 2505 : 	case 4:
; 2506 : 		PossibleInputs = 4;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], 4

; 2507 : 		InputModus = CONTROL_PAGE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], 3

; 2508 : 		if(Sms->curHardpoint >= 0 &&
; 2509 : 			Sms->hardPoint[Sms->curHardpoint]->GetWeaponData()->flags & SMSClass::HasBurstHeight)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+44], 0
	jl	SHORT $LN7@ChangeToIn
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	eax, DWORD PTR [eax]
	and	eax, 4
	je	SHORT $LN7@ChangeToIn

; 2510 : 		{
; 2511 : 			C1Weap = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+260], 0

; 2512 : 			C2Weap = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+261], 1

; 2513 : 			C3Weap = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+262], 0

; 2514 : 			C4Weap = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+263], 0

; 2515 : 		}
; 2516 : 		else

	jmp	SHORT $LN6@ChangeToIn
$LN7@ChangeToIn:

; 2517 : 		{
; 2518 : 			C1Weap = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+260], 1

; 2519 : 			C2Weap = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+261], 0

; 2520 : 			C3Weap = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+262], 0

; 2521 : 			C4Weap = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+263], 0
$LN6@ChangeToIn:

; 2522 : 		}
; 2523 : 	break;

	jmp	SHORT $LN11@ChangeToIn
$LN5@ChangeToIn:

; 2524 : 	case 8:
; 2525 : 		PossibleInputs = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+216], 3

; 2526 : 		InputModus = RELEASE_SPACE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], 2

; 2527 : 	break;

	jmp	SHORT $LN11@ChangeToIn
$LN4@ChangeToIn:

; 2528 : 	case 9:
; 2529 : 		PossibleInputs = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+216], 2

; 2530 : 		InputModus = RELEASE_PULSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+212], 1

; 2531 : 	break;

	jmp	SHORT $LN11@ChangeToIn
$LN3@ChangeToIn:

; 2532 : 	case 15:
; 2533 : 		PossibleInputs = 4;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], 4

; 2534 : 		InputModus = ARMING_DELAY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], 4

; 2535 : 	break;

	jmp	SHORT $LN11@ChangeToIn
$LN2@ChangeToIn:

; 2536 : 	case 18:
; 2537 : 		PossibleInputs = 4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+216], 4

; 2538 : 		InputModus = BURST_ALT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], 5
$LN11@ChangeToIn:

; 2539 : 	break;
; 2540 : 	default:
; 2541 : 	break;
; 2542 : 	}
; 2543 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN14@ChangeToIn:
	DD	$LN8@ChangeToIn
	DD	$LN5@ChangeToIn
	DD	$LN4@ChangeToIn
	DD	$LN3@ChangeToIn
	DD	$LN2@ChangeToIn
	DD	$LN11@ChangeToIn
$LN13@ChangeToIn:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	4
?ChangeToInput@SmsDrawable@@QAEXH@Z ENDP		; SmsDrawable::ChangeToInput
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_playerAC$ = -16					; size = 4
_pFCC$ = -12						; size = 4
_this$ = -8						; size = 4
_pradar$ = -4						; size = 4
?ChangeProf@SmsDrawable@@QAEXXZ PROC			; SmsDrawable::ChangeProf
; _this$ = ecx

; 2545 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2546 : 	FireControlComputer *pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 2547 : 
; 2548 : 	//if(pFCC->GetSubMode() == FireControlComputer::OBSOLETERCKT)
; 2549 : 	// MLR 5/30/2004 - going to allow rockets 
; 2550 : 	//if(pFCC->GetMasterMode() == FireControlComputer::AirGroundRocket)
; 2551 : 	//	return; // MLR 4/3/2004 - Rockets have no profiles
; 2552 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2553 : 	RadarDopplerClass* pradar = (RadarDopplerClass*) FindSensor (playerAC, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$[ebp], eax

; 2554 : 	if(pradar)	//MI fix

	cmp	DWORD PTR _pradar$[ebp], 0
	je	SHORT $LN4@ChangeProf

; 2555 : 	{
; 2556 : 		pradar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pradar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir

; 2557 : 		pradar->SelectLastAGMode();

	mov	edx, DWORD PTR _pradar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pradar$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
$LN4@ChangeProf:

; 2558 : 	}
; 2559 : 	//change profiles
; 2560 : 
; 2561 : 	Sms->NextAGBProfile(); // MLR 4/3/2004 - 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?NextAGBProfile@SMSClass@@QAEXXZ	; SMSClass::NextAGBProfile

; 2562 : 
; 2563 : 	//Sms->rippleCount    = Sms->GetAGBRippleCount();
; 2564 : 	//Sms->rippleInterval = Sms->GetAGBRippleInterval();
; 2565 : 	//Sms->SetPair(Sms->GetAGBPair());
; 2566 : 	if(pFCC)

	cmp	DWORD PTR _pFCC$[ebp], 0
	je	SHORT $LN1@ChangeProf

; 2567 : 	{
; 2568 : 		if(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser)

	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN2@ChangeProf

; 2569 : 			pFCC->SetSubMode(FireControlComputer::SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2570 : 		else

	jmp	SHORT $LN1@ChangeProf
$LN2@ChangeProf:

; 2571 : 		{
; 2572 : 			pFCC->SetSubMode(Sms->GetAGBSubMode());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ; SMSClass::GetAGBSubMode
	push	eax
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN1@ChangeProf:

; 2573 : 		}
; 2574 : 	}	
; 2575 : 
; 2576 : 	/*
; 2577 : 	Sms->Prof1 = !Sms->Prof1;
; 2578 : 
; 2579 : 	if(Sms->Prof1)
; 2580 : 	{
; 2581 : 		Sms->rippleCount = Sms->Prof1RP;
; 2582 : 		Sms->rippleInterval = Sms->Prof1RS;
; 2583 : 		Sms->SetPair(Sms->Prof1Pair);
; 2584 : 		if(pFCC)
; 2585 : 		{
; 2586 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser)
; 2587 : 				pFCC->SetSubMode(FireControlComputer::SLAVE);
; 2588 : 			else
; 2589 : 			{
; 2590 : 				pFCC->SetSubMode(Sms->Prof1SubMode);
; 2591 : 			}
; 2592 : 		}
; 2593 : 	}
; 2594 : 	else
; 2595 : 	{
; 2596 : 		Sms->rippleCount = Sms->Prof2RP;
; 2597 : 		Sms->rippleInterval = Sms->Prof2RS;
; 2598 : 		Sms->SetPair(Sms->Prof2Pair);
; 2599 : 		if(pFCC)
; 2600 : 		{
; 2601 : 			if(pFCC->GetMasterMode() == FireControlComputer::AirGroundLaser)
; 2602 : 				pFCC->SetSubMode(FireControlComputer::SLAVE);
; 2603 : 			else
; 2604 : 			{
; 2605 : 				pFCC->SetSubMode(Sms->Prof2SubMode);
; 2606 : 			}
; 2607 : 		}
; 2608 : 	}
; 2609 : 	*/
; 2610 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ChangeProf@SmsDrawable@@QAEXXZ ENDP			; SmsDrawable::ChangeProf
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_curStation$ = -4					; size = 4
?EmergJetDisplay@SmsDrawable@@QAEXXZ PROC		; SmsDrawable::EmergJetDisplay
; _this$ = ecx

; 2471 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2472 : 	int curStation = 0;

	mov	DWORD PTR _curStation$[ebp], 0

; 2473 : 	LabelButton(0, "E-J", NULL);

	push	0
	push	0
	push	OFFSET ??_C@_03EIHCPKNA@E?9J?$AA@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2474 : 	LabelButton(4, "CLR", NULL);

	push	0
	push	0
	push	OFFSET ??_C@_03KGBHJMEC@CLR?$AA@
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 2475 : 	InventoryDisplay(2);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InventoryDisplay@SmsDrawable@@AAEXH@Z	; SmsDrawable::InventoryDisplay

; 2476 : 	for(curStation = Sms->numHardpoints-1; curStation>0; curStation--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	DWORD PTR _curStation$[ebp], edx
	jmp	SHORT $LN6@EmergJetDi
$LN5@EmergJetDi:
	mov	eax, DWORD PTR _curStation$[ebp]
	sub	eax, 1
	mov	DWORD PTR _curStation$[ebp], eax
$LN6@EmergJetDi:
	cmp	DWORD PTR _curStation$[ebp], 0
	jle	$LN4@EmergJetDi

; 2477 : 	{
; 2478 : // OW Jettison fix
; 2479 : #if 0
; 2480 : 		if( !(((AircraftClass *)Sms->ownship)->IsF16() &&
; 2481 :          (curStation == 1 || curStation == 9 || hardPoint[curStation]->GetWeaponClass() == wcECM)) &&
; 2482 :          hardPoint[curStation]->GetRack())
; 2483 : #else
; 2484 : 		if( !(((AircraftClass *)Sms->ownship)->IsF16() &&
; 2485 :          (curStation == 1 || curStation == 9 || Sms->hardPoint[curStation]->GetWeaponClass() == wcECM || Sms->hardPoint[curStation]->GetWeaponClass() == wcAimWpn)) &&
; 2486 :          (Sms->hardPoint[curStation]->GetRack() || curStation == 5 && Sms->hardPoint[curStation]->GetWeaponClass() == wcTank))//me123 in the line above addet a check so we don't emergency jettison a-a missiles

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+56]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	SHORT $LN2@EmergJetDi
	cmp	DWORD PTR _curStation$[ebp], 1
	je	$LN3@EmergJetDi
	cmp	DWORD PTR _curStation$[ebp], 9
	je	$LN3@EmergJetDi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+164]
	call	edx
	cmp	eax, 4
	je	$LN3@EmergJetDi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+164]
	call	edx
	test	eax, eax
	je	SHORT $LN3@EmergJetDi
$LN2@EmergJetDi:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+116]
	call	edx
	test	eax, eax
	jne	SHORT $LN1@EmergJetDi
	cmp	DWORD PTR _curStation$[ebp], 5
	jne	SHORT $LN3@EmergJetDi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _curStation$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+164]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN3@EmergJetDi
$LN1@EmergJetDi:

; 2487 : #endif
; 2488 : 		{
; 2489 : 			hardPointSelected |= (1 << curStation);

	mov	eax, 1
	mov	ecx, DWORD PTR _curStation$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN3@EmergJetDi:

; 2490 : 		}
; 2491 : 	}

	jmp	$LN5@EmergJetDi
$LN4@EmergJetDi:

; 2492 : 	BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 2493 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?EmergJetDisplay@SmsDrawable@@QAEXXZ ENDP		; SmsDrawable::EmergJetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?HdptStationSym@SmsDrawable@@QAEDH@Z PROC		; SmsDrawable::HdptStationSym
; _this$ = ecx

; 1694 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1695 :     if (Sms->hardPoint[n] == NULL) return ' '; // empty hp

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN5@HdptStatio
	mov	al, 32					; 00000020H
	jmp	$LN6@HdptStatio
$LN5@HdptStatio:

; 1696 : 	if(Sms->hardPoint[n]->weaponCount <= 0) return ' ';	//MI don't bother drawing empty hardpoints

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	test	eax, eax
	jg	SHORT $LN4@HdptStatio
	mov	al, 32					; 00000020H
	jmp	$LN6@HdptStatio
$LN4@HdptStatio:

; 1697 :     if (Sms->StationOK(n) == FALSE) return 'F'; // malfunction on  HP

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+296]
	call	?StationOK@SMSBaseClass@@QAEHH@Z	; SMSBaseClass::StationOK
	test	eax, eax
	jne	SHORT $LN3@HdptStatio
	mov	al, 70					; 00000046H
	jmp	$LN6@HdptStatio
$LN3@HdptStatio:

; 1698 :     if (Sms->hardPoint[n]->GetWeaponType() == Sms->curWeaponType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+156]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	eax, DWORD PTR [edx+148]
	jne	SHORT $LN2@HdptStatio

; 1699 : 	return '0' + n; // exact match for weapon

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 48					; 00000030H
	jmp	SHORT $LN6@HdptStatio
$LN2@HdptStatio:

; 1700 :     if (Sms->hardPoint[n]->GetWeaponClass() == Sms->curWeaponClass)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+164]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	eax, DWORD PTR [edx+156]
	jne	SHORT $LN1@HdptStatio

; 1701 : 	return 'M'; // weapon of similar class

	mov	al, 77					; 0000004dH
	jmp	SHORT $LN6@HdptStatio
$LN1@HdptStatio:

; 1702 :     return ' ';

	mov	al, 32					; 00000020H
$LN6@HdptStatio:

; 1703 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?HdptStationSym@SmsDrawable@@QAEDH@Z ENDP		; SmsDrawable::HdptStationSym
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv360 = -36						; size = 4
_laserPod$1 = -32					; size = 4
tv150 = -28						; size = 4
_i$ = -24						; size = 4
_rz$ = -20						; size = 4
_ry$ = -16						; size = 4
_rx$ = -12						; size = 4
_theMissile$ = -8					; size = 4
_this$ = -4						; size = 4
?UpdateGroundSpot@SmsDrawable@@QAEXXZ PROC		; SmsDrawable::UpdateGroundSpot
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 	int i;
; 258  : 	float rx, ry, rz;
; 259  : 	MissileClass* theMissile = static_cast<MissileClass*>(Sms->GetCurrentWeapon());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _theMissile$[ebp], eax

; 260  : 	
; 261  : 	thePrevMissile.reset(theMissile);

	mov	eax, DWORD PTR _theMissile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ; VuBin<MissileClass>::reset

; 262  : 
; 263  : 	// 2002-01-28 ADDED BY S.G. Keep a note on the previous missile if we currently have no missile selected...
; 264  : 	/*if (thePrevMissile) {
; 265  : 		// If it's a new missile, switch to it
; 266  : 		if (theMissile && (thePrevMissile != theMissile)){
; 267  : 			if (thePrevMissileIsRef){
; 268  : 				VuDeReferenceEntity((VuEntity *)thePrevMissile);
; 269  : 			}
; 270  : 			thePrevMissile = theMissile;
; 271  : 			if (thePrevMissile->RefCount() > 0) {
; 272  : 				VuReferenceEntity((VuEntity *)thePrevMissile);
; 273  : 				thePrevMissileIsRef = TRUE;
; 274  : 			}
; 275  : 			else {
; 276  : 				thePrevMissileIsRef = FALSE;
; 277  : 			}
; 278  : 		}
; 279  : 	}
; 280  : 	// If we have a missile now, keep note of it for later
; 281  : 	else if (theMissile) {
; 282  : 		thePrevMissile = theMissile;
; 283  : 		if (theMissile->RefCount() > 0) {
; 284  : 			VuReferenceEntity((VuEntity *)thePrevMissile);
; 285  : 			thePrevMissileIsRef = TRUE;
; 286  : 		}
; 287  : 	}
; 288  : 
; 289  : 	// If our previous missile is now dead
; 290  : 	if (thePrevMissile && (thePrevMissile != theMissile) && thePrevMissile->IsDead()) {
; 291  : 		if (thePrevMissileIsRef)
; 292  : 			VuDeReferenceEntity((VuEntity *)thePrevMissile);
; 293  : 		thePrevMissileIsRef = FALSE;
; 294  : 		thePrevMissile = NULL;
; 295  : 	}
; 296  : 
; 297  : 	// Now check if it's time to reference our thePrevMissile
; 298  : 	if (thePrevMissile && thePrevMissileIsRef == FALSE && thePrevMissile->RefCount() > 0) {
; 299  : 		VuReferenceEntity((VuEntity *)thePrevMissile);
; 300  : 		thePrevMissileIsRef = TRUE;
; 301  : 	}
; 302  : 
; 303  : 	// If we don't currently have a missile but had one, use it.
; 304  : 	if (thePrevMissile && !theMissile){
; 305  : 		theMissile = thePrevMissile.get();
; 306  : 	}*/
; 307  : 	// END OF ADDED SECTION
; 308  : 
; 309  : 	// If a weapon has the spot, use it
; 310  : 	if (Sms->curHardpoint > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+44], 0
	jle	$LN25@UpdateGrou

; 311  : 	{
; 312  : 		switch (Sms->hardPoint[Sms->curHardpoint]->GetWeaponClass())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+164]
	call	edx
	mov	DWORD PTR tv150[ebp], eax
	cmp	DWORD PTR tv150[ebp], 6
	je	SHORT $LN24@UpdateGrou
	cmp	DWORD PTR tv150[ebp], 7
	je	$LN18@UpdateGrou
	cmp	DWORD PTR tv150[ebp], 9
	je	$LN14@UpdateGrou
	jmp	$LN9@UpdateGrou
$LN24@UpdateGrou:

; 313  : 		{
; 314  : 		case wcAgmWpn:
; 315  :             if (Sms->curWeaponType == wtAgm65)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	cmp	DWORD PTR [ecx+148], 4
	jne	$LN22@UpdateGrou

; 316  :             {
; 317  : 				if (theMissile && theMissile->IsMissile())

	cmp	DWORD PTR _theMissile$[ebp], 0
	je	$LN22@UpdateGrou
	mov	edx, DWORD PTR _theMissile$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theMissile$[ebp]
	mov	edx, DWORD PTR [eax+156]
	call	edx
	test	eax, eax
	je	$LN22@UpdateGrou

; 318  : 				{
; 319  : 					theMissile->GetTargetPosition (&rx, &ry, &rz);

	lea	eax, DWORD PTR _rz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ry$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _theMissile$[ebp]
	call	?GetTargetPosition@MissileClass@@QAEXPAM00@Z ; MissileClass::GetTargetPosition

; 320  : 					if (rx < 0.0F || ry < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	ja	SHORT $LN20@UpdateGrou
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _ry$[ebp]
	jbe	SHORT $LN21@UpdateGrou
$LN20@UpdateGrou:

; 321  : 						SetGroundSpotPos (Sms->ownship->XPos(), Sms->ownship->YPos(), Sms->ownship->ZPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ; SmsDrawable::SetGroundSpotPos

; 322  : 					else

	jmp	SHORT $LN19@UpdateGrou
$LN21@UpdateGrou:

; 323  : 						SetGroundSpotPos (rx, ry, rz);

	push	ecx
	movss	xmm0, DWORD PTR _rz$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ; SmsDrawable::SetGroundSpotPos
$LN19@UpdateGrou:

; 324  : 					hadCamera = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+284], 1
$LN22@UpdateGrou:

; 325  : 				}
; 326  :             }
; 327  : 			break;

	jmp	$LN25@UpdateGrou
$LN18@UpdateGrou:

; 328  : 			
; 329  : 		case wcHARMWpn:
; 330  : 			if (theMissile && theMissile->IsMissile())

	cmp	DWORD PTR _theMissile$[ebp], 0
	je	$LN17@UpdateGrou
	mov	ecx, DWORD PTR _theMissile$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theMissile$[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	$LN17@UpdateGrou

; 331  : 			{
; 332  : 				theMissile->GetTargetPosition (&rx, &ry, &rz);

	lea	ecx, DWORD PTR _rz$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ry$[ebp]
	push	edx
	lea	eax, DWORD PTR _rx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theMissile$[ebp]
	call	?GetTargetPosition@MissileClass@@QAEXPAM00@Z ; MissileClass::GetTargetPosition

; 333  : 				if (rx < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	SHORT $LN16@UpdateGrou

; 334  : 					SetGroundSpotPos (Sms->ownship->XPos(), Sms->ownship->YPos(), Sms->ownship->ZPos());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ; SmsDrawable::SetGroundSpotPos

; 335  : 				else

	jmp	SHORT $LN15@UpdateGrou
$LN16@UpdateGrou:

; 336  : 					SetGroundSpotPos (rx, ry, rz);

	push	ecx
	movss	xmm0, DWORD PTR _rz$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ; SmsDrawable::SetGroundSpotPos
$LN15@UpdateGrou:

; 337  : 				hadCamera = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 1
$LN17@UpdateGrou:

; 338  : 			}
; 339  : 			break;

	jmp	$LN25@UpdateGrou
$LN14@UpdateGrou:

; 340  : 			
; 341  : 		case wcGbuWpn:
; 342  : 			{
; 343  : 				SensorClass* laserPod = FindLaserPod (Sms->ownship);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 344  : 				
; 345  : 				if (laserPod)

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	$LN13@UpdateGrou

; 346  : 				{
; 347  : 					((LaserPodClass*)laserPod)->GetTargetPosition (&rx, &ry, &rz);

	lea	edx, DWORD PTR _rz$[ebp]
	push	edx
	lea	eax, DWORD PTR _ry$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _laserPod$1[ebp]
	call	?GetTargetPosition@LaserPodClass@@QAEXPAM00@Z ; LaserPodClass::GetTargetPosition

; 348  : 					if (rx < 0.0F || ry < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	ja	SHORT $LN11@UpdateGrou
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _ry$[ebp]
	jbe	SHORT $LN12@UpdateGrou
$LN11@UpdateGrou:

; 349  : 						SetGroundSpotPos (Sms->ownship->XPos(), Sms->ownship->YPos(), Sms->ownship->ZPos());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ; SmsDrawable::SetGroundSpotPos

; 350  : 					else

	jmp	SHORT $LN10@UpdateGrou
$LN12@UpdateGrou:

; 351  : 						SetGroundSpotPos (rx, ry, rz);

	push	ecx
	movss	xmm0, DWORD PTR _rz$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ; SmsDrawable::SetGroundSpotPos
$LN10@UpdateGrou:

; 352  : 					hadCamera = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], 1
$LN13@UpdateGrou:

; 353  : 				}
; 354  : 			}
; 355  : 			break;

	jmp	SHORT $LN25@UpdateGrou
$LN9@UpdateGrou:

; 356  : 			
; 357  : 		default:
; 358  :             if (hadCamera)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+284], 0
	je	SHORT $LN8@UpdateGrou

; 359  : 				needCamera = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], 1
$LN8@UpdateGrou:

; 360  :             hadCamera = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], 0
$LN25@UpdateGrou:

; 361  : 			break;
; 362  : 		}
; 363  : 	}
; 364  : 	
; 365  : 	// Add the camera if needed
; 366  : 	// edg: only do it if the display is in the cockpit
; 367  : 	if (needCamera && OTWDriver.DisplayInCockpit() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+288], 0
	je	$LN7@UpdateGrou
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?DisplayInCockpit@OTWDriverClass@@QAEHXZ ; OTWDriverClass::DisplayInCockpit
	test	eax, eax
	je	$LN7@UpdateGrou

; 368  : 	{
; 369  : 		needCamera = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], 0

; 370  : 		groundSpot->EntityDriver()->Exec(vuxGameTime);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+300]
	call	?EntityDriver@VuEntity@@QAEPAVVuDriver@@XZ ; VuEntity::EntityDriver
	mov	DWORD PTR tv360[ebp], eax
	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	push	eax
	mov	ecx, DWORD PTR tv360[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv360[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 371  : 		for (i=0; i<FalconLocalSession->CameraCount(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@UpdateGrou
$LN5@UpdateGrou:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@UpdateGrou:
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?CameraCount@VuSessionEntity@@QBEHXZ	; VuSessionEntity::CameraCount
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN4@UpdateGrou

; 372  : 		{
; 373  : 			if (FalconLocalSession->GetCameraEntity(i) == groundSpot){

	movzx	edx, BYTE PTR _i$[ebp]
	push	edx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+300]
	jne	SHORT $LN3@UpdateGrou

; 374  : 				break;

	jmp	SHORT $LN4@UpdateGrou
$LN3@UpdateGrou:

; 375  : 			}
; 376  : 		}

	jmp	SHORT $LN5@UpdateGrou
$LN4@UpdateGrou:

; 377  : 		
; 378  : 		if (i == FalconLocalSession->CameraCount())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?CameraCount@VuSessionEntity@@QBEHXZ	; VuSessionEntity::CameraCount
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN2@UpdateGrou

; 379  : 		{
; 380  : 			FalconLocalSession->AttachCamera(groundSpot);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	push	eax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?AttachCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z ; VuSessionEntity::AttachCamera
$LN2@UpdateGrou:

; 381  : 		}
; 382  : 	}
; 383  : 	else

	jmp	SHORT $LN1@UpdateGrou
$LN7@UpdateGrou:

; 384  : 	{
; 385  : 		// sfr: cleanup camera mess
; 386  : 		FalconLocalSession->RemoveCamera(groundSpot);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	push	edx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?RemoveCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z ; VuSessionEntity::RemoveCamera
$LN1@UpdateGrou:

; 387  : 		//for (i=0; i<FalconLocalSession->CameraCount(); i++)
; 388  : 		//{
; 389  : 		//	if (FalconLocalSession->GetCameraEntity(i) == groundSpot)
; 390  : 		//	{
; 391  : 		//		FalconLocalSession->RemoveCamera(groundSpot);
; 392  : 		//		break;
; 393  : 		//	}
; 394  : 		//}
; 395  : 	}
; 396  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateGroundSpot@SmsDrawable@@QAEXXZ ENDP		; SmsDrawable::UpdateGroundSpot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z PROC		; SmsDrawable::SetGroundSpotPos
; _this$ = ecx

; 403  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 404  : 	F4Assert (groundSpot);
; 405  : 	
; 406  : 	groundSpot->SetPosition (x, y, z);

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 407  : 	
; 408  : 	needCamera = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], 1

; 409  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetGroundSpotPos@SmsDrawable@@QAEXMMM@Z ENDP		; SmsDrawable::SetGroundSpotPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\smsdraw.h
;	COMDAT ?ToggleFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?ToggleFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z PROC	; SmsDrawable::ToggleFlag, COMDAT
; _this$ = ecx

; 38   : 	void ToggleFlag(SmsDrawFlags fl) { flags ^= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	xor	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ENDP	; SmsDrawable::ToggleFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\smsdraw.h
;	COMDAT ?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z PROC	; SmsDrawable::UnsetFlag, COMDAT
; _this$ = ecx

; 37   : 	void UnsetFlag(SmsDrawFlags fl) { flags &= ~fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+164]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?UnsetFlag@SmsDrawable@@QAEXW4SmsDrawFlags@1@@Z ENDP	; SmsDrawable::UnsetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\smsdraw.h
;	COMDAT ?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z PROC	; SmsDrawable::IsSet, COMDAT
; _this$ = ecx

; 35   : 	int IsSet(SmsDrawFlags fl) { return (flags & fl) ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	and	ecx, DWORD PTR _fl$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@SmsDrawable@@QAEHW4SmsDrawFlags@1@@Z ENDP	; SmsDrawable::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?PushButton@SmsDrawable@@UAEXHH@Z PROC			; SmsDrawable::PushButton
; _this$ = ecx

; 691  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 692  :     switch (displayMode) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 5
	ja	SHORT $LN8@PushButton
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN10@PushButton[edx*4]
$LN5@PushButton:

; 693  :     case Off:
; 694  : 	MfdDrawable::PushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 695  : 	break;

	jmp	SHORT $LN8@PushButton
$LN4@PushButton:

; 696  :     case Wpn:
; 697  : 	WpnPushButton (whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WpnPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::WpnPushButton

; 698  : 	break;

	jmp	SHORT $LN8@PushButton
$LN3@PushButton:

; 699  :     case Inv:
; 700  : 	InvPushButton (whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::InvPushButton

; 701  : 	break;

	jmp	SHORT $LN8@PushButton
$LN2@PushButton:

; 702  :     case SelJet:
; 703  : 	SJPushButton (whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SJPushButton@SmsDrawable@@AAEXHH@Z	; SmsDrawable::SJPushButton

; 704  : 	break;

	jmp	SHORT $LN8@PushButton
$LN1@PushButton:

; 705  : 	//MI
; 706  : 	case InputMode:
; 707  : 	InputPushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InputPushButton@SmsDrawable@@QAEXHH@Z	; SmsDrawable::InputPushButton
$LN8@PushButton:

; 708  : 	break;
; 709  :     }
; 710  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN10@PushButton:
	DD	$LN5@PushButton
	DD	$LN3@PushButton
	DD	$LN4@PushButton
	DD	$LN2@PushButton
	DD	$LN8@PushButton
	DD	$LN1@PushButton
?PushButton@SmsDrawable@@UAEXHH@Z ENDP			; SmsDrawable::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?StepDisplayMode@SmsDrawable@@QAEXXZ PROC		; SmsDrawable::StepDisplayMode
; _this$ = ecx

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 659  : // 2000-08-26 MODIFIED BY S.G. SO WE SAVE THE JETTISON SELECTION
; 660  : // hardPointSelected = 0; MOVED WITHIN THE CASE
; 661  : // case SelJet ADDED AS WELL
; 662  : // EXCEPT FOR SelJet WERE WE READ oldp01[5] INSTEAD
; 663  : 	switch (displayMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN4@StepDispla
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN3@StepDispla
	cmp	DWORD PTR tv65[ebp], 3
	je	SHORT $LN2@StepDispla
	jmp	SHORT $LN1@StepDispla
$LN4@StepDispla:

; 664  : 	{
; 665  : 	case Off:
; 666  : 	    break;

	jmp	SHORT $LN7@StepDispla
$LN3@StepDispla:

; 667  : 	case Wpn:
; 668  : 		displayMode = Inv;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], 1

; 669  : 		hardPointSelected = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 670  : 		break;

	jmp	SHORT $LN7@StepDispla
$LN2@StepDispla:

; 671  : 		
; 672  : 	case SelJet:
; 673  : //		hardPointSelected = ((AircraftClass *)Sms->ownship)->af->oldp01[5];
; 674  : //		hardPointSelected = sjHardPointSelected;	// Until I fixe oldp01 being private // MLR 3/9/2004 - 
; 675  : 		break;

	jmp	SHORT $LN7@StepDispla
$LN1@StepDispla:

; 676  : 
; 677  : 	case Inv:
; 678  : 	default:
; 679  : 		displayMode = Wpn;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 2

; 680  : 		hardPointSelected = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
$LN7@StepDispla:

; 681  : 		break;
; 682  : 	}
; 683  : //	hardPointSelected = 0;
; 684  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepDisplayMode@SmsDrawable@@QAEXXZ ENDP		; SmsDrawable::StepDisplayMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_newDisplayMode$ = 8					; size = 4
?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z PROC ; SmsDrawable::SetDisplayMode
; _this$ = ecx

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 630  :     // 2000-08-26 MODIFIED BY S.G. SO WE SAVE THE JETTISON SELECTION
; 631  :     // hardPointSelected = 0; MOVED WITHIN THE CASE
; 632  :     // EXCEPT FOR SelJet WERE WE READ oldp01[5] INSTEAD
; 633  :     switch (newDisplayMode)

	mov	eax, DWORD PTR _newDisplayMode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN3@SetDisplay
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN2@SetDisplay
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN1@SetDisplay
	jmp	SHORT $LN4@SetDisplay
$LN3@SetDisplay:

; 634  :     {
; 635  :     case Inv:
; 636  : 	hardPointSelected = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 637  : 	break;

	jmp	SHORT $LN4@SetDisplay
$LN2@SetDisplay:

; 638  : 	
; 639  :     case Wpn:
; 640  : 	hardPointSelected = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 641  : 	break;

	jmp	SHORT $LN4@SetDisplay
$LN1@SetDisplay:

; 642  : 	
; 643  :     case SelJet:
; 644  : 	lastMode = displayMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR [eax+308], edx
$LN4@SetDisplay:

; 645  : 	//		hardPointSelected = ((AircraftClass *)Sms->ownship)->af->oldp01[5];
; 646  : 	//hardPointSelected = sjHardPointSelected;	// Until I fixe oldp01 being private // MLR 3/9/2004 - 
; 647  : 	break;
; 648  :     }
; 649  :     //	hardPointSelected = 0;
; 650  :     displayMode = newDisplayMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newDisplayMode$[ebp]
	mov	DWORD PTR [eax+304], ecx

; 651  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ENDP ; SmsDrawable::SetDisplayMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
tv576 = -60						; size = 4
tv593 = -56						; size = 4
tv559 = -52						; size = 4
tv154 = -48						; size = 4
_ry$ = -44						; size = 4
_retval$ = -40						; size = 4
_rz$ = -36						; size = 4
_theMissile$ = -32					; size = 4
_rx$ = -28						; size = 4
_theDisplay$ = -24					; size = 4
_this$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?GetDisplay@SmsDrawable@@UAEPAVVirtualDisplay@@XZ PROC	; SmsDrawable::GetDisplay
; _this$ = ecx

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 	VirtualDisplay* retval= privateDisplay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _retval$[ebp], ecx

; 175  : 	MissileClass* theMissile = (MissileClass*)(Sms->GetCurrentWeapon());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _theMissile$[ebp], eax

; 176  : 	MaverickDisplayClass* theDisplay;
; 177  : 	float rx, ry, rz;
; 178  : 	Tpoint pos;
; 179  : 	
; 180  : 	if (Sms->curHardpoint <0 || displayMode == Off)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+44], 0
	jl	SHORT $LN12@GetDisplay
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+304], 0
	jne	SHORT $LN13@GetDisplay
$LN12@GetDisplay:

; 181  : 	{
; 182  : 		return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	jmp	$LN14@GetDisplay
$LN13@GetDisplay:

; 183  : 	}
; 184  : 	
; 185  : 	switch (Sms->hardPoint[Sms->curHardpoint]->GetWeaponClass())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	mov	DWORD PTR tv154[ebp], eax
	cmp	DWORD PTR tv154[ebp], 6
	je	SHORT $LN9@GetDisplay
	cmp	DWORD PTR tv154[ebp], 9
	je	$LN3@GetDisplay
	jmp	$LN2@GetDisplay
$LN9@GetDisplay:

; 186  : 	{
; 187  : 	case wcAgmWpn:
; 188  : 		if (Sms->curWeaponType == wtAgm65)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+148], 4
	jne	$LN6@GetDisplay

; 189  : 		{
; 190  :       if (theMissile && theMissile->IsMissile())

	cmp	DWORD PTR _theMissile$[ebp], 0
	je	$LN6@GetDisplay
	mov	eax, DWORD PTR _theMissile$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theMissile$[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	$LN6@GetDisplay

; 191  :       {
; 192  : 				theDisplay = (MaverickDisplayClass*)theMissile->display;

	mov	ecx, DWORD PTR _theMissile$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	mov	DWORD PTR _theDisplay$[ebp], edx

; 193  : 				if (theDisplay)

	cmp	DWORD PTR _theDisplay$[ebp], 0
	je	$LN6@GetDisplay

; 194  : 				{
; 195  : 					if (!theDisplay->GetDisplay())

	mov	eax, DWORD PTR _theDisplay$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theDisplay$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	test	eax, eax
	jne	$LN5@GetDisplay

; 196  : 					{
; 197  : 						if (privateDisplay)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN4@GetDisplay

; 198  : 						{
; 199  : 							theDisplay->DisplayInit(((Render2D*)(privateDisplay))->GetImageBuffer());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	call	?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ ; Render2D::GetImageBuffer
	push	eax
	mov	eax, DWORD PTR _theDisplay$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theDisplay$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN4@GetDisplay:

; 200  : 						}
; 201  : 						theDisplay->viewPoint = viewPoint;

	mov	ecx, DWORD PTR _theDisplay$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax

; 202  : 						
; 203  : 						// Set missile initial position
; 204  : 						Sms->hardPoint[Sms->curHardpoint]->GetSubPosition(Sms->curWpnNum, &rx, &ry, &rz);

	lea	ecx, DWORD PTR _rz$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ry$[ebp]
	push	edx
	lea	eax, DWORD PTR _rx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+136]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 205  : 						rx += 5.0F;

	movss	xmm0, DWORD PTR _rx$[ebp]
	addss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _rx$[ebp], xmm0

; 206  : 						pos.x = Sms->ownship->XPos() + Sms->ownship->dmx[0][0]*rx + Sms->ownship->dmx[1][0]*ry +
; 207  : 							Sms->ownship->dmx[2][0]*rz;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv559[ebp]
	movss	xmm0, DWORD PTR tv559[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _rx$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _ry$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _rz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _pos$[ebp], xmm0

; 208  : 						pos.y = Sms->ownship->YPos() + Sms->ownship->dmx[0][1]*rx + Sms->ownship->dmx[1][1]*ry +
; 209  : 							Sms->ownship->dmx[2][1]*rz;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv576[ebp]
	movss	xmm0, DWORD PTR tv576[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _rx$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _ry$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _rz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _pos$[ebp+4], xmm0

; 210  : 						pos.z = Sms->ownship->ZPos() + Sms->ownship->dmx[0][2]*rx + Sms->ownship->dmx[1][2]*ry +
; 211  : 							Sms->ownship->dmx[2][2]*rz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv593[ebp]
	movss	xmm0, DWORD PTR tv593[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _rx$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _ry$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _rz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _pos$[ebp+8], xmm0

; 212  : 						theDisplay->SetXYZ (pos.x, pos.y, pos.z);

	push	ecx
	movss	xmm0, DWORD PTR _pos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theDisplay$[ebp]
	call	?SetXYZ@MissileDisplayClass@@QAEXMMM@Z	; MissileDisplayClass::SetXYZ
$LN5@GetDisplay:

; 213  : 					}
; 214  : 					retval = theDisplay->GetDisplay();

	mov	ecx, DWORD PTR _theDisplay$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theDisplay$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _retval$[ebp], eax
$LN6@GetDisplay:

; 215  : 				}
; 216  :       }
; 217  : 		}
; 218  : 		break;

	jmp	SHORT $LN10@GetDisplay
$LN3@GetDisplay:

; 219  : 		
; 220  : 	case wcGbuWpn:
; 221  : 		{
; 222  : // Cobra - causes TGP MFD display to disappear in 3D pit
; 223  : /*		
; 224  : 			SensorClass* laserPod = FindLaserPod (Sms->ownship);
; 225  : 			
; 226  : 			if (laserPod)
; 227  : 			{
; 228  : 				if (!laserPod->GetDisplay())
; 229  : 				{
; 230  : 					if (privateDisplay)
; 231  : 					{
; 232  :  						laserPod->DisplayInit(((Render2D*)(privateDisplay))->GetImageBuffer());
; 233  : 					}
; 234  : 					laserPod->viewPoint = viewPoint;
; 235  : 				}
; 236  : 				retval = laserPod->GetDisplay();
; 237  : 			}
; 238  : */		
; 239  : 		}
; 240  : 		break;

	jmp	SHORT $LN10@GetDisplay
$LN2@GetDisplay:

; 241  : 		
; 242  : 	default:
; 243  : 		if (hadCamera)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+284], 0
	je	SHORT $LN1@GetDisplay

; 244  :             needCamera = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 1
$LN1@GetDisplay:

; 245  : 		hadCamera = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+284], 0
$LN10@GetDisplay:

; 246  : 		break;
; 247  : 	}
; 248  : 	return (retval);

	mov	eax, DWORD PTR _retval$[ebp]
$LN14@GetDisplay:

; 249  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@SmsDrawable@@UAEPAVVirtualDisplay@@XZ ENDP	; SmsDrawable::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisplayExit@SmsDrawable@@UAEXXZ PROC			; SmsDrawable::DisplayExit
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	isDisplayed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0

; 433  : 	
; 434  : 	DrawableClass::DisplayExit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisplayExit@DrawableClass@@UAEXXZ	; DrawableClass::DisplayExit

; 435  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayExit@SmsDrawable@@UAEXXZ ENDP			; SmsDrawable::DisplayExit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_ofont$1 = -52						; size = 4
_playerAC$ = -48					; size = 4
tv429 = -44						; size = 4
tv425 = -40						; size = 4
_cX$ = -36						; size = 4
tv260 = -32						; size = 4
tv170 = -28						; size = 4
_FCC$ = -24						; size = 4
_cY$ = -20						; size = 4
_bc$ = -16						; size = 4
_i$2 = -12						; size = 4
_theRadar$ = -8						; size = 4
_this$ = -4						; size = 4
_newDisplay$ = 8					; size = 4
?Display@SmsDrawable@@UAEXPAVVirtualDisplay@@@Z PROC	; SmsDrawable::Display
; _this$ = ecx

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 	isDisplayed = TRUE; // MLR 3/22/2004 - Because sometimes DisplayInit is NOT called when the SMS is displayed.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 1

; 444  : 	                    // appears to happen when cycling AG stores
; 445  : 
; 446  :     float cX, cY = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cY$[ebp], xmm0

; 447  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 448  : 	RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 449  : 	// sfr: @todo remove this or check why it happens
; 450  : 	if(!theRadar){

	cmp	DWORD PTR _theRadar$[ebp], 0
	jne	SHORT $LN44@Display

; 451  : 		ShiWarning("Oh Oh shouldn't be here without a radar!");
; 452  : 		return;

	jmp	$LN45@Display
$LN44@Display:

; 453  : 	}
; 454  : 
; 455  : 	theRadar->GetCursorPosition(&cX, &cY);

	lea	edx, DWORD PTR _cY$[ebp]
	push	edx
	lea	eax, DWORD PTR _cX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax

; 456  : 	display = newDisplay;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newDisplay$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 457  :     FireControlComputer *FCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _FCC$[ebp], eax

; 458  : 	isJSOW = FALSE;

	mov	BYTE PTR ?isJSOW@@3_NA, 0		; isJSOW

; 459  : 	isJDAM = FALSE;

	mov	BYTE PTR ?isJDAM@@3_NA, 0		; isJDAM

; 460  : 	// sfr: no waypoint selected, NULL bc. Had CTDs here.
; 461  : 	BombClass *bc = Sms->CurHardpoint() == -1 ? 
; 462  : 		NULL : 
; 463  : 		static_cast<BombClass*>(Sms->hardPoint[Sms->CurHardpoint()]->weaponPointer.get())
; 464  : 	;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	cmp	eax, -1
	jne	SHORT $LN47@Display
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN48@Display
$LN47@Display:
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	add	ecx, 12					; 0000000cH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	DWORD PTR tv170[ebp], eax
$LN48@Display:
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _bc$[ebp], edx

; 465  : 	if ((Sms->GetCurrentWeapon() != NULL) && (Sms->GetCurrentHardpoint() > 0) && 
; 466  : 		bc && bc->IsSetBombFlag(BombClass::IsJSOW)) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+296]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	test	eax, eax
	je	SHORT $LN43@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentHardpoint
	test	eax, eax
	jle	SHORT $LN43@Display
	cmp	DWORD PTR _bc$[ebp], 0
	je	SHORT $LN43@Display
	push	512					; 00000200H
	mov	ecx, DWORD PTR _bc$[ebp]
	call	?IsSetBombFlag@BombClass@@QAEHH@Z	; BombClass::IsSetBombFlag
	test	eax, eax
	je	SHORT $LN43@Display

; 467  : 		isJSOW = TRUE;

	mov	BYTE PTR ?isJSOW@@3_NA, 1		; isJSOW

; 468  : 	}
; 469  : 	else {

	jmp	SHORT $LN42@Display
$LN43@Display:

; 470  : 		isJSOW = FALSE;

	mov	BYTE PTR ?isJSOW@@3_NA, 0		; isJSOW
$LN42@Display:

; 471  : 	}
; 472  : 
; 473  : 	if ((Sms->GetCurrentWeapon() != NULL) && (Sms->GetCurrentHardpoint() > 0) && 
; 474  : 		bc && bc->IsSetBombFlag(BombClass::IsGPS)) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+296]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	je	SHORT $LN41@Display
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentHardpoint
	test	eax, eax
	jle	SHORT $LN41@Display
	cmp	DWORD PTR _bc$[ebp], 0
	je	SHORT $LN41@Display
	push	256					; 00000100H
	mov	ecx, DWORD PTR _bc$[ebp]
	call	?IsSetBombFlag@BombClass@@QAEHH@Z	; BombClass::IsSetBombFlag
	test	eax, eax
	je	SHORT $LN41@Display

; 475  : 		isJDAM = TRUE;

	mov	BYTE PTR ?isJDAM@@3_NA, 1		; isJDAM

; 476  : 	}
; 477  : 	else {

	jmp	SHORT $LN40@Display
$LN41@Display:

; 478  : 		isJDAM = FALSE;

	mov	BYTE PTR ?isJDAM@@3_NA, 0		; isJDAM
$LN40@Display:

; 479  : 	}
; 480  : 
; 481  : 	// MN get aircrafts maximum ripple count
; 482  : 	maxripple = ((AircraftClass*)(Sms->ownship))->af->GetMaxRippleCount();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetMaxRippleCount@AirframeClass@@QAEHXZ ; AirframeClass::GetMaxRippleCount
	mov	DWORD PTR ?maxripple@@3HA, eax		; maxripple

; 483  : 
; 484  :     if (!((AircraftClass*)(Sms->ownship))->HasPower(AircraftClass::SMSPower)) {

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	ecx, DWORD PTR [eax+56]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	SHORT $LN39@Display

; 485  : 		if (displayMode != Off) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	je	SHORT $LN38@Display

; 486  : 			lastMode = displayMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	mov	DWORD PTR [edx+308], ecx

; 487  : 			displayMode = Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], 0
$LN38@Display:

; 488  : 		}
; 489  :     }

	jmp	SHORT $LN36@Display
$LN39@Display:

; 490  :     else if (displayMode == Off){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+304], 0
	jne	SHORT $LN36@Display

; 491  : 		displayMode = lastMode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+308]
	mov	DWORD PTR [ecx+304], eax
$LN36@Display:

; 492  : 	}
; 493  : 
; 494  :     switch (displayMode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR tv260[ebp], edx
	cmp	DWORD PTR tv260[ebp], 5
	ja	$LN34@Display
	mov	eax, DWORD PTR tv260[ebp]
	jmp	DWORD PTR $LN50@Display[eax*4]
$LN33@Display:

; 495  :     {
; 496  : 		case Off:
; 497  : 		{
; 498  : 			display->TextCenter(0.0f, 0.2f, "SMS");  // JPG 14 Dec 03 - Fixed these

	push	0
	push	OFFSET ??_C@_03OONHJAKL@SMS?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 499  : 			int ofont = display->CurFont();

	call	?CurFont@VirtualDisplay@@SAHXZ		; VirtualDisplay::CurFont
	mov	DWORD PTR _ofont$1[ebp], eax

; 500  : 			display->SetFont(2);

	push	2
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 501  : 			display->TextCenter(0.0f, 0.0f, "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 502  : 			display->SetFont(ofont);

	mov	ecx, DWORD PTR _ofont$1[ebp]
	push	ecx
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 503  : 			theRadar->GetCursorPosition (&cX, &cY);

	lea	edx, DWORD PTR _cY$[ebp]
	push	edx
	lea	eax, DWORD PTR _cX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax

; 504  : 			// JPG 14 Dec 03 - Added BE/ownship info
; 505  : 			if(
; 506  : 				OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&  
; 507  : 				OTWDriver.pCockpitManager->mpIcp->ShowBullseyeInfo
; 508  : 			){

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN32@Display
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN32@Display
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	movzx	ecx, BYTE PTR [eax+300]
	test	ecx, ecx
	je	SHORT $LN32@Display

; 509  : 				DrawBullseyeCircle(display, cX, cY);

	push	ecx
	movss	xmm0, DWORD PTR _cY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?DrawBullseyeCircle@@YAXPAVVirtualDisplay@@MM@Z ; DrawBullseyeCircle
	add	esp, 12					; 0000000cH

; 510  : 			}
; 511  : 			else {

	jmp	SHORT $LN31@Display
$LN32@Display:

; 512  : 				DrawReference(MfdDisplay[OnMFD()]->GetOwnShip());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnMFD@DrawableClass@@QAEHXZ		; DrawableClass::OnMFD
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax*4]
	call	?GetOwnShip@MFDClass@@QAEPAVAircraftClass@@XZ ; MFDClass::GetOwnShip
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawReference@MfdDrawable@@QAEXPAVAircraftClass@@@Z ; MfdDrawable::DrawReference
$LN31@Display:

; 513  : 			}
; 514  : 			BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 515  : 		}
; 516  : 		break;

	jmp	$LN34@Display
$LN30@Display:

; 517  : 		case Inv:
; 518  : 			InventoryDisplay(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InventoryDisplay@SmsDrawable@@AAEXH@Z	; SmsDrawable::InventoryDisplay

; 519  : 		break;

	jmp	$LN34@Display
$LN29@Display:

; 520  : 		
; 521  : 		case SelJet:
; 522  : 			SelectiveJettison();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectiveJettison@SmsDrawable@@AAEXXZ	; SmsDrawable::SelectiveJettison

; 523  : 		break;

	jmp	$LN34@Display
$LN28@Display:

; 524  : 
; 525  : 		//MI
; 526  : 		case EmergJet:
; 527  : 			EmergJetDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmergJetDisplay@SmsDrawable@@QAEXXZ	; SmsDrawable::EmergJetDisplay

; 528  : 		break;

	jmp	$LN34@Display
$LN27@Display:

; 529  : 
; 530  : 		//MI
; 531  : 		case InputMode:
; 532  : 			InputDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InputDisplay@SmsDrawable@@QAEXXZ	; SmsDrawable::InputDisplay

; 533  : 		break;

	jmp	$LN34@Display
$LN26@Display:

; 534  : 		
; 535  : 		case Wpn:
; 536  : 		// common stuff.
; 537  : 		if (FCC->IsNavMasterMode()) {// shouldn't happened really

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsNavMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsNavMasterMode
	test	eax, eax
	je	SHORT $LN25@Display

; 538  : 			SetDisplayMode(Inv);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 539  : 			InventoryDisplay(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InventoryDisplay@SmsDrawable@@AAEXH@Z	; SmsDrawable::InventoryDisplay
	jmp	$LN14@Display
$LN25@Display:

; 540  : 		}
; 541  : 		else if (FCC->GetMasterMode() == FireControlComputer::Dogfight){

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN23@Display

; 542  : 			DogfightDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DogfightDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::DogfightDisplay
	jmp	$LN14@Display
$LN23@Display:

; 543  : 		}
; 544  : 		else if (FCC->GetMasterMode() == FireControlComputer::MissileOverride){

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN21@Display

; 545  : 			MissileOverrideDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MissileOverrideDisplay@SmsDrawable@@AAEXXZ ; SmsDrawable::MissileOverrideDisplay

; 546  : 		}
; 547  : 		else {

	jmp	$LN14@Display
$LN21@Display:

; 548  : 			if (Sms->curHardpoint < 0){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	cmp	DWORD PTR [edx+44], 0
	jge	SHORT $LN19@Display

; 549  : 				TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 550  : 				LabelButton (5, "AAM");

	push	0
	push	0
	push	OFFSET ??_C@_03MJJMMJAE@AAM?$AA@
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 551  : 				LabelButton (6, "AGM");

	push	0
	push	0
	push	OFFSET ??_C@_03MNBBLFLG@AGM?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 552  : 				LabelButton (7, "A-G");

	push	0
	push	0
	push	OFFSET ??_C@_03HCLOBDMK@A?9G?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 553  : 				LabelButton (8, "GUN");

	push	0
	push	0
	push	OFFSET ??_C@_03NMPFMOLH@GUN?$AA@
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 554  : 				BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow

; 555  : 			}
; 556  : 			else {

	jmp	$LN14@Display
$LN19@Display:

; 557  : 				//cobra test
; 558  : 				if (isJDAM || isJSOW) {

	movzx	eax, BYTE PTR ?isJDAM@@3_NA		; isJDAM
	test	eax, eax
	jne	SHORT $LN16@Display
	movzx	ecx, BYTE PTR ?isJSOW@@3_NA		; isJSOW
	test	ecx, ecx
	je	SHORT $LN17@Display
$LN16@Display:

; 559  : 					JDAMDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JDAMDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::JDAMDisplay

; 560  : 					break;

	jmp	$LN34@Display
$LN17@Display:

; 561  : 				}
; 562  : 
; 563  : 				switch (Sms->hardPoint[Sms->GetCurrentHardpoint()]->GetWeaponClass())

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+296]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	call	?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentHardpoint
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv425[ebp], edx
	mov	eax, DWORD PTR tv425[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv425[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	mov	DWORD PTR tv429[ebp], eax
	cmp	DWORD PTR tv429[ebp], 10		; 0000000aH
	ja	SHORT $LN6@Display
	mov	ecx, DWORD PTR tv429[ebp]
	movzx	edx, BYTE PTR $LN49@Display[ecx]
	jmp	DWORD PTR $LN51@Display[edx*4]
$LN13@Display:

; 564  : 				{
; 565  : 					case wcAimWpn:
; 566  : 					case wcAgmWpn:
; 567  : 					case wcSamWpn:
; 568  : 					case wcHARMWpn:
; 569  : 						MissileDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MissileDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::MissileDisplay

; 570  : 						break;

	jmp	$LN14@Display
$LN12@Display:

; 571  : 					    
; 572  : 					case wcGunWpn:
; 573  : 						GunDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GunDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::GunDisplay

; 574  : 						break;

	jmp	$LN14@Display
$LN11@Display:

; 575  : 					    
; 576  : 					case wcBombWpn:
; 577  : 					case wcRocketWpn:
; 578  : 						BombDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BombDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::BombDisplay

; 579  : 						break;

	jmp	$LN14@Display
$LN10@Display:

; 580  : 					    
; 581  : 					case wcGbuWpn:
; 582  : 						if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN9@Display

; 583  : 							GBUDisplay();	

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GBUDisplay@SmsDrawable@@AAEXXZ		; SmsDrawable::GBUDisplay

; 584  : 						else

	jmp	SHORT $LN8@Display
$LN9@Display:

; 585  : 							BombDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BombDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::BombDisplay
$LN8@Display:

; 586  : 						break;

	jmp	SHORT $LN14@Display
$LN7@Display:

; 587  : 					    
; 588  : 					case wcCamera:
; 589  : 						CameraDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CameraDisplay@SmsDrawable@@AAEXXZ	; SmsDrawable::CameraDisplay

; 590  : 						break;

	jmp	SHORT $LN14@Display
$LN6@Display:

; 591  : 					    
; 592  : 					default:
; 593  : 						TopRow(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TopRow@SmsDrawable@@AAEXH@Z		; SmsDrawable::TopRow

; 594  : 						LabelButton (5, "AAM");

	push	0
	push	0
	push	OFFSET ??_C@_03MJJMMJAE@AAM?$AA@
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 595  : 						LabelButton (6, "AGM");

	push	0
	push	0
	push	OFFSET ??_C@_03MNBBLFLG@AGM?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 596  : 						LabelButton (7, "A-G");

	push	0
	push	0
	push	OFFSET ??_C@_03HCLOBDMK@A?9G?$AA@
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 597  : 						LabelButton (8, "GUN");

	push	0
	push	0
	push	OFFSET ??_C@_03NMPFMOLH@GUN?$AA@
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 598  : 						BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@SmsDrawable@@AAEXXZ		; SmsDrawable::BottomRow
$LN14@Display:
$LN34@Display:

; 599  : 						break;
; 600  : 				}
; 601  : 			}
; 602  : 		}
; 603  : 		break;
; 604  : 	}
; 605  : 	
; 606  : 	//Booster 15/09/2004 - Draw Pull Up cross on MFD-SMS if ground Collision
; 607  : 	if (playerAC->mFaults->GetFault(alt_low)){

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN5@Display

; 608  : 		DrawRedBreak(display);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRedBreak@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z ; MfdDrawable::DrawRedBreak
$LN5@Display:

; 609  : 	}
; 610  : 
; 611  : 	// RV - I-Hawk
; 612  : 	// Check, if 1 of the MFDs is showing TGP and the attitude warning is set, show it... 
; 613  : 	// (works on all MFDs and not only here)
; 614  : 	for ( int i = 0; i < 4; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@Display
$LN3@Display:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@Display:
	cmp	DWORD PTR _i$2[ebp], 4
	jge	SHORT $LN2@Display

; 615  : 	{
; 616  : 		if ( (MfdDisplay[i])->GetTGPWarning() && (MfdDisplay[i])->CurMode() == MFDClass::TGPMode )

	mov	edx, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx*4]
	call	?GetTGPWarning@MFDClass@@QAEHXZ		; MFDClass::GetTGPWarning
	test	eax, eax
	je	SHORT $LN1@Display
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax*4]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 8
	jne	SHORT $LN1@Display

; 617  : 			{ 
; 618  : 				TGPAttitudeWarning(display);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TGPAttitudeWarning@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z ; MfdDrawable::TGPAttitudeWarning

; 619  : 				break;

	jmp	SHORT $LN2@Display
$LN1@Display:

; 620  : 			}
; 621  : 	}

	jmp	SHORT $LN3@Display
$LN2@Display:
$LN45@Display:

; 622  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN50@Display:
	DD	$LN33@Display
	DD	$LN30@Display
	DD	$LN26@Display
	DD	$LN29@Display
	DD	$LN28@Display
	DD	$LN27@Display
$LN51@Display:
	DD	$LN13@Display
	DD	$LN11@Display
	DD	$LN12@Display
	DD	$LN10@Display
	DD	$LN7@Display
	DD	$LN6@Display
$LN49@Display:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	5
	DB	5
	DB	0
	DB	0
	DB	0
	DB	3
	DB	4
?Display@SmsDrawable@@UAEXPAVVirtualDisplay@@@Z ENDP	; SmsDrawable::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv86 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_image$ = 8						; size = 4
?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z PROC	; SmsDrawable::DisplayInit
; _this$ = ecx

; 416  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 	DisplayExit();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 418  : 	
; 419  : 	privateDisplay = new Render2D;

	push	262840					; 000402b8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@DisplayIni
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Render2D@@QAE@XZ			; Render2D::Render2D
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN4@DisplayIni
$LN3@DisplayIni:
	mov	DWORD PTR tv86[ebp], 0
$LN4@DisplayIni:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+24], eax

; 420  : 	((Render2D*)privateDisplay)->Setup (image);

	mov	ecx, DWORD PTR _image$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 421  : 	
; 422  : 	privateDisplay->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 423  : 	isDisplayed = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], 1

; 424  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayInit@SmsDrawable@@UAEXPAVImageBuffer@@@Z ENDP	; SmsDrawable::DisplayInit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SmsDrawable@@UAE@XZ PROC				; SmsDrawable::~SmsDrawable
; _this$ = ecx

; 155  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SmsDrawable@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SmsDrawable@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 156  : 	vuDatabase->Remove(groundSpot);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove

; 157  : 
; 158  : 	// sfr: this seems quite odd...
; 159  : 	// 2002-01-28 ADDED BY S.G. Clean up our act once we get destroyed
; 160  : 	//if (thePrevMissile && thePrevMissileIsRef){
; 161  : 	//	VuDeReferenceEntity((VuEntity *)thePrevMissile);
; 162  : 	//}
; 163  : 	//thePrevMissileIsRef = FALSE;
; 164  : 	//thePrevMissile = NULL;
; 165  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	??1?$VuBin@VMissileClass@@@@QAE@XZ	; VuBin<MissileClass>::~VuBin<MissileClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1SmsDrawable@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
__unwindfunclet$??1SmsDrawable@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	jmp	??1?$VuBin@VMissileClass@@@@QAE@XZ	; VuBin<MissileClass>::~VuBin<MissileClass>
__ehhandler$??1SmsDrawable@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SmsDrawable@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SmsDrawable@@UAE@XZ ENDP				; SmsDrawable::~SmsDrawable
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\smsdraw.cpp
_TEXT	SEGMENT
$T2 = -52						; size = 4
$T3 = -48						; size = 4
_pFCC$ = -44						; size = 4
tv157 = -40						; size = 4
$T4 = -36						; size = 4
tv135 = -32						; size = 4
$T5 = -28						; size = 4
_l$ = -24						; size = 4
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_self$ = 8						; size = 4
??0SmsDrawable@@QAE@PAVSMSClass@@@Z PROC		; SmsDrawable::SmsDrawable
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SmsDrawable@@QAE@PAVSMSClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MfdDrawable@@QAE@XZ			; MfdDrawable::MfdDrawable
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SmsDrawable@@6B@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z ; VuBin<MissileClass>::VuBin<MissileClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 68   :     int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 69   : 	lastMode = displayMode = Inv;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+308], 1

; 70   : 	Sms = self;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [eax+296], ecx

; 71   : 	groundSpot = new SpotEntity(F4FlyingEyeType+VU_LAST_ENTITY_TYPE);

	push	144					; 00000090H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN13@SmsDrawabl
	mov	edx, DWORD PTR ?F4FlyingEyeType@@3HA	; F4FlyingEyeType
	add	edx, 100				; 00000064H
	push	edx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0SpotEntity@@QAE@G@Z			; SpotEntity::SpotEntity
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN14@SmsDrawabl
$LN13@SmsDrawabl:
	mov	DWORD PTR tv135[ebp], 0
$LN14@SmsDrawabl:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+300], edx

; 72   : 	vuDatabase->/*Quick*/Insert(groundSpot);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 73   : 	frameCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 74   : 	isDisplayed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0

; 75   : 	/*sjHardPointSelected = */hardPointSelected = 0; // MLR 3/9/2004 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 76   : 	groundSpot->SetDriver(new SpotDriver(groundSpot));

	push	116					; 00000074H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN15@SmsDrawabl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0SpotDriver@@QAE@PAVVuEntity@@@Z	; SpotDriver::SpotDriver
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN16@SmsDrawabl
$LN15@SmsDrawabl:
	mov	DWORD PTR tv157[ebp], 0
$LN16@SmsDrawabl:
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	call	?SetDriver@VuEntity@@QAEPAVVuDriver@@PAV2@@Z ; VuEntity::SetDriver

; 77   : 	hadCamera = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0

; 78   : 	needCamera = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0

; 79   : 	flags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 80   : 	//MI new stuff
; 81   : 	Sms->BHOT = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	BYTE PTR [edx+12], 1

; 82   : 	EmergStoreMode = Inv;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+200], 1

; 83   : 	DataInputMode = Inv;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+204], 1

; 84   : 	lastInputMode = Inv;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+208], 1

; 85   : 	PossibleInputs = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+216], 0

; 86   : 	InputModus = NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], 0

; 87   : 	for(i = 0; i < MAX_DIGITS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SmsDrawabl
$LN9@SmsDrawabl:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@SmsDrawabl:
	cmp	DWORD PTR _i$[ebp], 7
	jge	SHORT $LN8@SmsDrawabl

; 88   : 		Input_Digits[i] = 25;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+224], 25		; 00000019H
	jmp	SHORT $LN9@SmsDrawabl
$LN8@SmsDrawabl:

; 89   : 	Manual_Input = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+264], 0

; 90   : 	for(i = 0; i < STR_LEN; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SmsDrawabl
$LN6@SmsDrawabl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SmsDrawabl:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN5@SmsDrawabl

; 91   : 		inputstr[i] = ' ';

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+266], 32			; 00000020H
	jmp	SHORT $LN6@SmsDrawabl
$LN5@SmsDrawabl:

; 92   : 	inputstr[STR_LEN - 1] = '\0';

	mov	edx, 1
	imul	edx, 11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+266], 0

; 93   : 	wrong = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+265], 0

; 94   : 	InputsMade =0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], 0

; 95   : 	C1Weap = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+260], 0

; 96   : 	C2Weap = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+261], 0

; 97   : 	C3Weap = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+262], 0

; 98   : 	C4Weap = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+263], 0

; 99   : 	InputLine = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+252], 0

; 100  : 	MaxInputLines = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+256], 0

; 101  : 
; 102  : 	//Init some stuff
; 103  : 	//Sms->Prof1 = !Sms->Prof1;  // MLR 4/5/2004 - Why???
; 104  : 
; 105  : 	FireControlComputer *pFCC = Sms->ownship->GetFCC();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$[ebp], eax

; 106  : 	
; 107  : 	// MLR 4/3/2004 - 
; 108  : 	//Sms->rippleCount    = Sms->GetAGBRippleCount();
; 109  : 	//Sms->rippleInterval = Sms->GetAGBRippleInterval();
; 110  : 	//Sms->SetPair( Sms->GetAGBPair() );
; 111  : 	//Sms->angle          = Sms->GetAGBReleaseAngle();
; 112  : 	//Sms->armingdelay    = Sms->agbProfile[Sms->curProfile].armingDelay;
; 113  : 
; 114  : 
; 115  : 	if(pFCC)

	cmp	DWORD PTR _pFCC$[ebp], 0
	je	SHORT $LN4@SmsDrawabl

; 116  : 		pFCC->SetSubMode(Sms->GetAGBSubMode());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+296]
	call	?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ; SMSClass::GetAGBSubMode
	push	eax
	mov	ecx, DWORD PTR _pFCC$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN4@SmsDrawabl:

; 117  : 
; 118  : 	/*
; 119  : 	if(Sms->Prof1)
; 120  : 	{
; 121  : 		Sms->rippleCount = Sms->Prof1RP;
; 122  : 		Sms->rippleInterval = Sms->Prof1RS;
; 123  : 		Sms->SetPair(Sms->Prof1Pair);
; 124  : 		if(pFCC)
; 125  : 			pFCC->SetSubMode(Sms->Prof1SubMode);
; 126  : 	}
; 127  : 	else
; 128  : 	{
; 129  : 		Sms->rippleCount = Sms->Prof2RP;
; 130  : 		Sms->rippleInterval = Sms->Prof2RS;
; 131  : 		Sms->SetPair(Sms->Prof2Pair);
; 132  : 		if(pFCC)
; 133  : 			pFCC->SetSubMode(Sms->Prof2SubMode);
; 134  : 	}*/
; 135  : 
; 136  : 	// 2002-01-28 ADDED BY S.G. Init our stuff to keep the target deaggregated until last missile impact
; 137  : 	//thePrevMissile = NULL;
; 138  : 	// Stupid shit because theMissile isn't inserted into VU (therefore not referenced) until launched
; 139  : 	//thePrevMissileIsRef = FALSE; 
; 140  : 	thePrevMissile.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ; VuBin<MissileClass>::reset

; 141  : 
; 142  : 	int l;
; 143  : 	for(l=0;l<32;l++)

	mov	DWORD PTR _l$[ebp], 0
	jmp	SHORT $LN3@SmsDrawabl
$LN2@SmsDrawabl:
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx
$LN3@SmsDrawabl:
	cmp	DWORD PTR _l$[ebp], 32			; 00000020H
	jge	SHORT $LN11@SmsDrawabl

; 144  : 	{
; 145  : 		sjSelected[l]=JettisonNone;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+36], 0

; 146  : 	}

	jmp	SHORT $LN2@SmsDrawabl
$LN11@SmsDrawabl:

; 147  : 
; 148  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	jmp	??1?$VuBin@VMissileClass@@@@QAE@XZ	; VuBin<MissileClass>::~VuBin<MissileClass>
__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$2:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SmsDrawable@@QAE@PAVSMSClass@@@Z$3:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0SmsDrawable@@QAE@PAVSMSClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SmsDrawable@@QAE@PAVSMSClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SmsDrawable@@QAE@PAVSMSClass@@@Z ENDP		; SmsDrawable::SmsDrawable
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBPair@SMSClass@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 1
?SetAGBPair@SMSClass@@QAEX_N@Z PROC			; SMSClass::SetAGBPair, COMDAT
; _this$ = ecx

; 325  : 	void SetAGBPair(bool x)           { agbProfile[curProfile].releasePair    = x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _x$[ebp]
	mov	BYTE PTR [edx+ecx+232], al
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBPair@SMSClass@@QAEX_N@Z ENDP			; SMSClass::SetAGBPair
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBFuze@SMSClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?SetAGBFuze@SMSClass@@QAEXH@Z PROC			; SMSClass::SetAGBFuze, COMDAT
; _this$ = ecx

; 319  : 	void SetAGBFuze(int x)            { agbProfile[curProfile].fuzeNoseTail   = x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx+208], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBFuze@SMSClass@@QAEXH@Z ENDP			; SMSClass::SetAGBFuze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ PROC ; SMSClass::GetAGBSubMode, COMDAT
; _this$ = ecx

; 315  : 	FireControlComputer::FCCSubMode  GetAGBSubMode(void)        { return agbProfile[curProfile].subMode;         }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+236]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ENDP ; SMSClass::GetAGBSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBPair@SMSClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBPair@SMSClass@@QAE_NXZ PROC			; SMSClass::GetAGBPair, COMDAT
; _this$ = ecx

; 314  : 	bool GetAGBPair(void)          { return agbProfile[curProfile].releasePair;     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+232]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBPair@SMSClass@@QAE_NXZ ENDP			; SMSClass::GetAGBPair
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBC2ArmDelay@SMSClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBC2ArmDelay@SMSClass@@QAEMXZ PROC			; SMSClass::GetAGBC2ArmDelay, COMDAT
; _this$ = ecx

; 313  : 	float GetAGBC2ArmDelay(void)   { return agbProfile[curProfile].C2ArmDelay;      }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+ecx+228]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBC2ArmDelay@SMSClass@@QAEMXZ ENDP			; SMSClass::GetAGBC2ArmDelay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBC1ArmDelay2@SMSClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBC1ArmDelay2@SMSClass@@QAEMXZ PROC		; SMSClass::GetAGBC1ArmDelay2, COMDAT
; _this$ = ecx

; 312  : 	float GetAGBC1ArmDelay2(void)  { return agbProfile[curProfile].C1ArmDelay2;     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+ecx+224]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBC1ArmDelay2@SMSClass@@QAEMXZ ENDP		; SMSClass::GetAGBC1ArmDelay2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBC1ArmDelay1@SMSClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBC1ArmDelay1@SMSClass@@QAEMXZ PROC		; SMSClass::GetAGBC1ArmDelay1, COMDAT
; _this$ = ecx

; 311  : 	float GetAGBC1ArmDelay1(void)  { return agbProfile[curProfile].C1ArmDelay1;     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+ecx+220]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBC1ArmDelay1@SMSClass@@QAEMXZ ENDP		; SMSClass::GetAGBC1ArmDelay1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBReleaseAngle@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBReleaseAngle@SMSClass@@QAEHXZ PROC		; SMSClass::GetAGBReleaseAngle, COMDAT
; _this$ = ecx

; 310  : 	int GetAGBReleaseAngle(void)   { return agbProfile[curProfile].releaseAngle;    }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+216]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBReleaseAngle@SMSClass@@QAEHXZ ENDP		; SMSClass::GetAGBReleaseAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBBurstAlt@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBBurstAlt@SMSClass@@QAEHXZ PROC			; SMSClass::GetAGBBurstAlt, COMDAT
; _this$ = ecx

; 309  : 	int GetAGBBurstAlt(void)       { return agbProfile[curProfile].burstAltitude;   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+212]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBBurstAlt@SMSClass@@QAEHXZ ENDP			; SMSClass::GetAGBBurstAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBFuze@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBFuze@SMSClass@@QAEHXZ PROC			; SMSClass::GetAGBFuze, COMDAT
; _this$ = ecx

; 308  : 	int GetAGBFuze(void)           { return agbProfile[curProfile].fuzeNoseTail;    }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+208]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBFuze@SMSClass@@QAEHXZ ENDP			; SMSClass::GetAGBFuze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBRippleInterval@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBRippleInterval@SMSClass@@QAEHXZ PROC		; SMSClass::GetAGBRippleInterval, COMDAT
; _this$ = ecx

; 307  : 	int GetAGBRippleInterval(void) { return agbProfile[curProfile].rippleInterval;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+204]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBRippleInterval@SMSClass@@QAEHXZ ENDP		; SMSClass::GetAGBRippleInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBRippleCount@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBRippleCount@SMSClass@@QAEHXZ PROC		; SMSClass::GetAGBRippleCount, COMDAT
; _this$ = ecx

; 306  : 	int GetAGBRippleCount(void)    { return agbProfile[curProfile].rippleCount;     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+200]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBRippleCount@SMSClass@@QAEHXZ ENDP		; SMSClass::GetAGBRippleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NextAGBProfile@SMSClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NextAGBProfile@SMSClass@@QAEXXZ PROC			; SMSClass::NextAGBProfile, COMDAT
; _this$ = ecx

; 303  : 	void NextAGBProfile(void) { curProfile = (curProfile + 1) & 1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	add	ecx, 1
	and	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextAGBProfile@SMSClass@@QAEXXZ ENDP			; SMSClass::NextAGBProfile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z PROC	; SMSClass::SetCoolState, COMDAT
; _this$ = ecx

; 271  : 	void SetCoolState (Aim9Mode state) { aim9mode = state; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+180], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ENDP	; SMSClass::SetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ PROC	; SMSClass::GetCoolState, COMDAT
; _this$ = ecx

; 270  : 	Aim9Mode GetCoolState() { return aim9mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ENDP	; SMSClass::GetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NextAimId@SMSClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NextAimId@SMSClass@@QAEXXZ PROC			; SMSClass::NextAimId, COMDAT
; _this$ = ecx

; 268  : 	void NextAimId () { aim120id = (aim120id + 1) % 4; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 1
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN3@NextAimId
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN3@NextAimId:
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+176], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextAimId@SMSClass@@QAEXXZ ENDP			; SMSClass::NextAimId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?AimId@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AimId@SMSClass@@QAEHXZ PROC				; SMSClass::AimId, COMDAT
; _this$ = ecx

; 267  : 	int AimId () { return aim120id+1; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+176]
	add	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?AimId@SMSClass@@QAEHXZ ENDP				; SMSClass::AimId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::GetCurrentHardpoint, COMDAT
; _this$ = ecx

; 129  : 	int GetCurrentHardpoint(void) {return curHardpoint;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentHardpoint@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::GetCurrentHardpoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?ToggleHARMPower@SMSBaseClass@@QAEXXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?ToggleHARMPower@SMSBaseClass@@QAEXXZ PROC		; SMSBaseClass::ToggleHARMPower, COMDAT
; _this$ = ecx

; 127  : 	void ToggleHARMPower(void) { HARMPowered = !HARMPowered; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	jne	SHORT $LN3@ToggleHARM
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@ToggleHARM
$LN3@ToggleHARM:
	mov	DWORD PTR tv68[ebp], 0
$LN4@ToggleHARM:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv68[ebp]
	mov	BYTE PTR [edx+60], al
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleHARMPower@SMSBaseClass@@QAEXXZ ENDP		; SMSBaseClass::ToggleHARMPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetHARMInitTimer@SMSBaseClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHARMInitTimer@SMSBaseClass@@QAEMXZ PROC		; SMSBaseClass::GetHARMInitTimer, COMDAT
; _this$ = ecx

; 126  : 	float GetHARMInitTimer(void) { return HARMInitTimer; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHARMInitTimer@SMSBaseClass@@QAEMXZ ENDP		; SMSBaseClass::GetHARMInitTimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetHARMPowerState@SMSBaseClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHARMPowerState@SMSBaseClass@@QAE_NXZ PROC		; SMSBaseClass::GetHARMPowerState, COMDAT
; _this$ = ecx

; 125  : 	bool GetHARMPowerState(void) { return HARMPowered; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHARMPowerState@SMSBaseClass@@QAE_NXZ ENDP		; SMSBaseClass::GetHARMPowerState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?ToggleMavPower@SMSBaseClass@@QAEXXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?ToggleMavPower@SMSBaseClass@@QAEXXZ PROC		; SMSBaseClass::ToggleMavPower, COMDAT
; _this$ = ecx

; 118  : 	void ToggleMavPower(void)	{Powered = !Powered;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	jne	SHORT $LN3@ToggleMavP
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@ToggleMavP
$LN3@ToggleMavP:
	mov	DWORD PTR tv68[ebp], 0
$LN4@ToggleMavP:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv68[ebp]
	mov	BYTE PTR [edx+16], al
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleMavPower@SMSBaseClass@@QAEXXZ ENDP		; SMSBaseClass::ToggleMavPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ PROC	; SMSBaseClass::Ownship, COMDAT
; _this$ = ecx

; 91   : 	SimVehicleClass* Ownship(void) {return ownship;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ENDP	; SMSBaseClass::Ownship
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumCurrentWpn@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumCurrentWpn@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumCurrentWpn, COMDAT
; _this$ = ecx

; 89   : 	int  NumCurrentWpn(void) {return numCurrentWpn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumCurrentWpn@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumCurrentWpn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?CurHardpoint@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurHardpoint@SMSBaseClass@@QAEHXZ PROC			; SMSBaseClass::CurHardpoint, COMDAT
; _this$ = ecx

; 88   : 	int CurHardpoint (void) {return curHardpoint;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurHardpoint@SMSBaseClass@@QAEHXZ ENDP			; SMSBaseClass::CurHardpoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumHardpoints@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumHardpoints@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumHardpoints, COMDAT
; _this$ = ecx

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumHardpoints@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumHardpoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?CurStationOK@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurStationOK@SMSBaseClass@@QAEHXZ PROC			; SMSBaseClass::CurStationOK, COMDAT
; _this$ = ecx

; 85   : 	int CurStationOK (void) { return StationOK(curHardpoint); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StationOK@SMSBaseClass@@QAEHH@Z	; SMSBaseClass::StationOK
	mov	esp, ebp
	pop	ebp
	ret	0
?CurStationOK@SMSBaseClass@@QAEHXZ ENDP			; SMSBaseClass::CurStationOK
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newe$ = 8						; size = 4
?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z PROC ; VuBin<MissileClass>::reset, COMDAT
; _this$ = ecx

; 60   : 	void reset(E *newe = NULL){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if (newe == e){ return; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newe$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@reset
	jmp	SHORT $LN2@reset
$LN1@reset:

; 62   : 		VuReferenceEntity(newe); // ref new pointer

	mov	edx, DWORD PTR _newe$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 63   : 		VuDeReferenceEntity(e);  // unref old pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 64   : 		e = newe;                // get new pointer

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@reset:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ENDP ; VuBin<MissileClass>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??1?$VuBin@VMissileClass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$VuBin@VMissileClass@@@@QAE@XZ PROC			; VuBin<MissileClass>::~VuBin<MissileClass>, COMDAT
; _this$ = ecx

; 19   : 	~VuBin(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 		VuDeReferenceEntity((VuEntity *)e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 21   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$VuBin@VMissileClass@@@@QAE@XZ ENDP			; VuBin<MissileClass>::~VuBin<MissileClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z PROC ; VuBin<MissileClass>::VuBin<MissileClass>, COMDAT
; _this$ = ecx

; 11   : 	explicit VuBin(E *e = NULL) : e(e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], ecx

; 12   : 		VuReferenceEntity(e);

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z ENDP ; VuBin<MissileClass>::VuBin<MissileClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetDgftGunSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDgftGunSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ PROC ; FireControlComputer::GetDgftGunSubMode, COMDAT
; _this$ = ecx

; 285  : 	FCCSubMode GetDgftGunSubMode(void) {return (lastDogfightGunSubMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDgftGunSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ENDP ; FireControlComputer::GetDgftGunSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ PROC ; FireControlComputer::GetSubMode, COMDAT
; _this$ = ecx

; 281  : 	FCCSubMode GetSubMode (void) {return (subMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ENDP ; FireControlComputer::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsNavMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsNavMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsNavMasterMode, COMDAT
; _this$ = ecx

; 280  : 	int IsNavMasterMode() { return GetMainMasterMode() == MM_NAV; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 2
	jne	SHORT $LN3@IsNavMaste
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsNavMaste
$LN3@IsNavMaste:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsNavMaste:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNavMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsNavMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsAGMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsAGMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsAGMasterMode, COMDAT
; _this$ = ecx

; 278  : 	int IsAGMasterMode() { return GetMainMasterMode() == MM_AG; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	test	eax, eax
	jne	SHORT $LN3@IsAGMaster
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAGMaster
$LN3@IsAGMaster:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAGMaster:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAGMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsAGMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\bomb.h
;	COMDAT ?IsSetBombFlag@BombClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSetBombFlag@BombClass@@QAEHH@Z PROC			; BombClass::IsSetBombFlag, COMDAT
; _this$ = ecx

; 102  : 	int IsSetBombFlag (int newFlag) {return flags & newFlag ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	and	ecx, DWORD PTR _newFlag$[ebp]
	je	SHORT $LN3@IsSetBombF
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSetBombF
$LN3@IsSetBombF:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSetBombF:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetBombFlag@BombClass@@QAEHH@Z ENDP			; BombClass::IsSetBombFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\laserpod.h
;	COMDAT ?GetTargetPosition@LaserPodClass@@QAEXPAM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?GetTargetPosition@LaserPodClass@@QAEXPAM00@Z PROC	; LaserPodClass::GetTargetPosition, COMDAT
; _this$ = ecx

; 30   : 	void GetTargetPosition (float* a, float* b, float* c)	{ *a=tgtX; *b=tgtY; *c=tgtZ; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTargetPosition@LaserPodClass@@QAEXPAM00@Z ENDP	; LaserPodClass::GetTargetPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\laserpod.h
;	COMDAT ?CurFOV@LaserPodClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurFOV@LaserPodClass@@QAEMXZ PROC			; LaserPodClass::CurFOV, COMDAT
; _this$ = ecx

; 22   : 	float CurFOV (void)							{return curFOV;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+88]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurFOV@LaserPodClass@@QAEMXZ ENDP			; LaserPodClass::CurFOV
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\laserpod.h
;	COMDAT ?IsLocked@LaserPodClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsLocked@LaserPodClass@@QAEHXZ PROC			; LaserPodClass::IsLocked, COMDAT
; _this$ = ecx

; 19   : 	int IsLocked (void)							{return (hasTarget == TargetLocked);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 1
	jne	SHORT $LN3@IsLocked
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsLocked
$LN3@IsLocked:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsLocked:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLocked@LaserPodClass@@QAEHXZ ENDP			; LaserPodClass::IsLocked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mavdisp.h
;	COMDAT ?ToggleFOV@MaverickDisplayClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleFOV@MaverickDisplayClass@@QAEXXZ PROC		; MaverickDisplayClass::ToggleFOV, COMDAT
; _this$ = ecx

; 33   :       void ToggleFOV (void) {toggleFOV = TRUE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleFOV@MaverickDisplayClass@@QAEXXZ ENDP		; MaverickDisplayClass::ToggleFOV
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mavdisp.h
;	COMDAT ?CurFOV@MaverickDisplayClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurFOV@MaverickDisplayClass@@QAEMXZ PROC		; MaverickDisplayClass::CurFOV, COMDAT
; _this$ = ecx

; 32   :       float CurFOV (void) {return curFOV;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurFOV@MaverickDisplayClass@@QAEMXZ ENDP		; MaverickDisplayClass::CurFOV
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\misldisp.h
;	COMDAT ?SetXYZ@MissileDisplayClass@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetXYZ@MissileDisplayClass@@QAEXMMM@Z PROC		; MissileDisplayClass::SetXYZ, COMDAT
; _this$ = ecx

; 20   :       void SetXYZ (float x, float y, float z) { platform->SetPosition (x, y, z); } ;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetXYZ@MissileDisplayClass@@QAEXMMM@Z ENDP		; MissileDisplayClass::SetXYZ
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?GetTargetPosition@MissileClass@@QAEXPAM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newX$ = 8						; size = 4
_newY$ = 12						; size = 4
_newZ$ = 16						; size = 4
?GetTargetPosition@MissileClass@@QAEXPAM00@Z PROC	; MissileClass::GetTargetPosition, COMDAT
; _this$ = ecx

; 322  : 	void GetTargetPosition (float* newX, float* newY, float* newZ) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 		*newX = targetX; *newY = targetY; *newZ = targetZ;};

	mov	eax, DWORD PTR _newX$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _newY$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+908]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _newZ$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTargetPosition@MissileClass@@QAEXPAM00@Z ENDP	; MissileClass::GetTargetPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?GetEXPLevel@MissileClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEXPLevel@MissileClass@@QAEMXZ PROC			; MissileClass::GetEXPLevel, COMDAT
; _this$ = ecx

; 271  : 	float GetEXPLevel (void) { return auxData->EXPLevel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	fld	DWORD PTR [ecx+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEXPLevel@MissileClass@@QAEMXZ ENDP			; MissileClass::GetEXPLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?GetFOVLevel@MissileClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFOVLevel@MissileClass@@QAEMXZ PROC			; MissileClass::GetFOVLevel, COMDAT
; _this$ = ecx

; 270  : 	float GetFOVLevel (void) { return auxData->FOVLevel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	fld	DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFOVLevel@MissileClass@@QAEMXZ ENDP			; MissileClass::GetFOVLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h
;	COMDAT ?SqrtF@@YAMM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?SqrtF@@YAMM@Z PROC					; SqrtF, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	_asm
; 51   : 	{
; 52   : 		fld f;

	fld	DWORD PTR _f$[ebp]

; 53   : 		fsqrt;

	fsqrt

; 54   : 		fstp f;

	fstp	DWORD PTR _f$[ebp]

; 55   : 	}
; 56   : 
; 57   : 	return f;

	fld	DWORD PTR _f$[ebp]

; 58   : }

	pop	ebp
	ret	0
?SqrtF@@YAMM@Z ENDP					; SqrtF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator!, COMDAT
; _this$ = ecx

; 37   : 	bool operator!() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 		return e == NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 39   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??7?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetSPType@SimBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSPType@SimBaseClass@@QBEEXZ PROC			; SimBaseClass::GetSPType, COMDAT
; _this$ = ecx

; 163  : 	uchar GetSPType() const					{	return (EntityType())->classInfo_[VU_SPTYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 2
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSPType@SimBaseClass@@QBEEXZ ENDP			; SimBaseClass::GetSPType
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GMfdDrawable@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMfdDrawable@@UAEPAXI@Z PROC				; MfdDrawable::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMfdDrawable@@UAEPAXI@Z ENDP				; MfdDrawable::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vd$ = 8						; size = 4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z PROC	; MfdDrawable::Display, COMDAT
; _this$ = ecx

; 138  :       virtual void Display (VirtualDisplay*vd) { display = vd; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vd$[ebp]
	mov	DWORD PTR [eax+20], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z ENDP	; MfdDrawable::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ??0MfdDrawable@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MfdDrawable@@QAE@XZ PROC				; MfdDrawable::MfdDrawable, COMDAT
; _this$ = ecx

; 135  :       MfdDrawable () {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DrawableClass@@IAE@XZ		; DrawableClass::DrawableClass
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MfdDrawable@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0MfdDrawable@@QAE@XZ ENDP				; MfdDrawable::MfdDrawable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?GetTGPWarning@MFDClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTGPWarning@MFDClass@@QAEHXZ PROC			; MFDClass::GetTGPWarning, COMDAT
; _this$ = ecx

; 94   : 	int GetTGPWarning() { return TGPWarning; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTGPWarning@MFDClass@@QAEHXZ ENDP			; MFDClass::GetTGPWarning
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?GetOwnShip@MFDClass@@QAEPAVAircraftClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwnShip@MFDClass@@QAEPAVAircraftClass@@XZ PROC	; MFDClass::GetOwnShip, COMDAT
; _this$ = ecx

; 82   : 	AircraftClass *GetOwnShip() { return ownship; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+132]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwnShip@MFDClass@@QAEPAVAircraftClass@@XZ ENDP	; MFDClass::GetOwnShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ PROC		; MFDClass::CurMode, COMDAT
; _this$ = ecx

; 71   : 	MfdMode CurMode() { return mode == MfdMenu ? restoreMode : mode; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN3@CurMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN4@CurMode
$LN3@CurMode:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv68[ebp], ecx
$LN4@CurMode:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ ENDP		; MFDClass::CurMode
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GDrawableClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDrawableClass@@UAEPAXI@Z PROC			; DrawableClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DrawableClass@@UAE@XZ		; DrawableClass::~DrawableClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDrawableClass@@UAEPAXI@Z ENDP			; DrawableClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?PushButton@DrawableClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?PushButton@DrawableClass@@UAEXHH@Z PROC		; DrawableClass::PushButton, COMDAT
; _this$ = ecx

; 152  :       virtual void PushButton (int, int)	{};								// Override to get button messages in subclasses

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?PushButton@DrawableClass@@UAEXHH@Z ENDP		; DrawableClass::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?GetIntensity@DrawableClass@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIntensity@DrawableClass@@QAEIXZ PROC		; DrawableClass::GetIntensity, COMDAT
; _this$ = ecx

; 148  :       unsigned int GetIntensity(void) { return intensity; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIntensity@DrawableClass@@QAEIXZ ENDP		; DrawableClass::GetIntensity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?SetIntensity@DrawableClass@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?SetIntensity@DrawableClass@@QAEXI@Z PROC		; DrawableClass::SetIntensity, COMDAT
; _this$ = ecx

; 147  :       void  SetIntensity (unsigned int val) { intensity = val; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetIntensity@DrawableClass@@QAEXI@Z ENDP		; DrawableClass::SetIntensity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?OnMFD@DrawableClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMFD@DrawableClass@@QAEHXZ PROC			; DrawableClass::OnMFD, COMDAT
; _this$ = ecx

; 145  :       int	OnMFD (void)			{return MFDOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?OnMFD@DrawableClass@@QAEHXZ ENDP			; DrawableClass::OnMFD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?IsSOI@DrawableClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsSOI@DrawableClass@@QAEHXZ PROC			; DrawableClass::IsSOI, COMDAT
; _this$ = ecx

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN3@IsSOI
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSOI
$LN3@IsSOI:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSOI:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSOI@DrawableClass@@QAEHXZ ENDP			; DrawableClass::IsSOI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ PROC ; DrawableClass::GetDisplay, COMDAT
; _this$ = ecx

; 139  :       virtual VirtualDisplay* GetDisplay (void)	{return privateDisplay;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ ENDP ; DrawableClass::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z PROC	; DrawableClass::DisplayInit, COMDAT
; _this$ = ecx

; 137  :       virtual void DisplayInit (ImageBuffer*)	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z ENDP	; DrawableClass::DisplayInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z PROC	; DrawableClass::Display, COMDAT
; _this$ = ecx

; 136  :       virtual void Display(VirtualDisplay*)		{ ShiWarning( "No Display!" ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z ENDP	; DrawableClass::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ??1DrawableClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DrawableClass@@UAE@XZ PROC				; DrawableClass::~DrawableClass, COMDAT
; _this$ = ecx

; 132  :       virtual ~DrawableClass (void)				{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DrawableClass@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DrawableClass@@UAE@XZ ENDP				; DrawableClass::~DrawableClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ??0DrawableClass@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DrawableClass@@IAE@XZ PROC				; DrawableClass::DrawableClass, COMDAT
; _this$ = ecx

; 126  :       DrawableClass(void) {privateDisplay = display = NULL; viewPoint = NULL; drawFlags = 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DrawableClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DrawableClass@@IAE@XZ ENDP				; DrawableClass::DrawableClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRender2D@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRender2D@@UAEPAXI@Z PROC				; Render2D::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Render2D@@UAE@XZ			; Render2D::~Render2D
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRender2D@@UAEPAXI@Z ENDP				; Render2D::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetLineStyle@Render2D@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@Render2D@@UAEXH@Z PROC			; Render2D::SetLineStyle, COMDAT
; _this$ = ecx

; 60   : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@Render2D@@UAEXH@Z ENDP			; Render2D::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetBackground@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetBackground@Render2D@@UAEXK@Z PROC			; Render2D::SetBackground, COMDAT
; _this$ = ecx

; 50   : 	virtual void SetBackground(DWORD packedRGBA){ context.SetState(MPR_STA_BG_COLOR,packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBackground@Render2D@@UAEXK@Z ENDP			; Render2D::SetBackground
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetColor@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetColor@Render2D@@UAEXK@Z PROC			; Render2D::SetColor, COMDAT
; _this$ = ecx

; 49   : 	virtual void SetColor(DWORD packedRGBA)	{ context.RestoreState(STATE_SOLID); context.SelectForegroundColor(packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SelectForegroundColor@ContextMPR@@QAEXH@Z ; ContextMPR::SelectForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	4
?SetColor@Render2D@@UAEXK@Z ENDP			; Render2D::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?Color@Render2D@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@Render2D@@UAEKXZ PROC				; Render2D::Color, COMDAT
; _this$ = ecx

; 48   : 	virtual DWORD Color(void) { return context.CurrentForegroundColor(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?CurrentForegroundColor@ContextMPR@@QAEHXZ ; ContextMPR::CurrentForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@Render2D@@UAEKXZ ENDP				; Render2D::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearZBuffer@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearZBuffer@Render2D@@UAEXXZ PROC			; Render2D::ClearZBuffer, COMDAT
; _this$ = ecx

; 42   : 	virtual void ClearZBuffer( void )	{ context.ClearBuffers( MPR_CI_ZBUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearZBuffer@Render2D@@UAEXXZ ENDP			; Render2D::ClearZBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearDraw@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDraw@Render2D@@UAEXXZ PROC			; Render2D::ClearDraw, COMDAT
; _this$ = ecx

; 41   : 	virtual void ClearDraw( void )		{ context.ClearBuffers( MPR_CI_DRAW_BUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDraw@Render2D@@UAEXXZ ENDP			; Render2D::ClearDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ PROC	; Render2D::GetImageBuffer, COMDAT
; _this$ = ecx

; 38   : 	ImageBuffer* GetImageBuffer(void) {return image;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ ENDP	; Render2D::GetImageBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??1Render2D@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Render2D@@UAE@XZ PROC				; Render2D::~Render2D, COMDAT
; _this$ = ecx

; 32   : 	virtual ~Render2D()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	esp, ebp
	pop	ebp
	ret	0
??1Render2D@@UAE@XZ ENDP				; Render2D::~Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??0Render2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Render2D@@QAE@XZ PROC				; Render2D::Render2D, COMDAT
; _this$ = ecx

; 31   : 	Render2D()			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VirtualDisplay@@QAE@XZ		; VirtualDisplay::VirtualDisplay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Render2D@@QAE@XZ ENDP				; Render2D::Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVirtualDisplay@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVirtualDisplay@@UAEPAXI@Z PROC			; VirtualDisplay::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVirtualDisplay@@UAEPAXI@Z ENDP			; VirtualDisplay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Color@VirtualDisplay@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@VirtualDisplay@@UAEKXZ PROC			; VirtualDisplay::Color, COMDAT
; _this$ = ecx

; 136  : 	virtual DWORD Color( void )	{return 0x0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@VirtualDisplay@@UAEKXZ ENDP			; VirtualDisplay::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?SetLineStyle@VirtualDisplay@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@VirtualDisplay@@UAEXH@Z PROC		; VirtualDisplay::SetLineStyle, COMDAT
; _this$ = ecx

; 135  : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@VirtualDisplay@@UAEXH@Z ENDP		; VirtualDisplay::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CurFont@VirtualDisplay@@SAHXZ
_TEXT	SEGMENT
?CurFont@VirtualDisplay@@SAHXZ PROC			; VirtualDisplay::CurFont, COMDAT

; 132  : 	static int CurFont(void) { return pFontSet->fontNum; };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	eax, DWORD PTR [eax+24672]
	pop	ebp
	ret	0
?CurFont@VirtualDisplay@@SAHXZ ENDP			; VirtualDisplay::CurFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextHeight@VirtualDisplay@@UAEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?TextHeight@VirtualDisplay@@UAEMXZ PROC			; VirtualDisplay::TextHeight, COMDAT
; _this$ = ecx

; 121  : 	virtual float TextHeight(void)			{ return ScreenTextHeight()/scaleY; };		// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR tv71[ebp], xmm0
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TextHeight@VirtualDisplay@@UAEMXZ ENDP			; VirtualDisplay::TextHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextWidth@VirtualDisplay@@UAEMPAD@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_string$ = 8						; size = 4
?TextWidth@VirtualDisplay@@UAEMPAD@Z PROC		; VirtualDisplay::TextWidth, COMDAT
; _this$ = ecx

; 120  : 	virtual float TextWidth(char *string)	{ return ScreenTextWidth(string)/scaleX; };	// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?TextWidth@VirtualDisplay@@UAEMPAD@Z ENDP		; VirtualDisplay::TextWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Arc@VirtualDisplay@@UAEXMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
_start$ = 20						; size = 4
_stop$ = 24						; size = 4
?Arc@VirtualDisplay@@UAEXMMMMM@Z PROC			; VirtualDisplay::Arc, COMDAT
; _this$ = ecx

; 109  : 		{ OvalArc(x, y, xRadius, xRadius*scaleX/scaleY, start, stop); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _stop$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Arc@VirtualDisplay@@UAEXMMMMM@Z ENDP			; VirtualDisplay::Arc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Circle@VirtualDisplay@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
?Circle@VirtualDisplay@@UAEXMMM@Z PROC			; VirtualDisplay::Circle, COMDAT
; _this$ = ecx

; 107  : 		{ Oval(x, y, xRadius, xRadius*scaleX/scaleY); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Circle@VirtualDisplay@@UAEXMMM@Z ENDP			; VirtualDisplay::Circle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??1VirtualDisplay@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VirtualDisplay@@UAE@XZ PROC				; VirtualDisplay::~VirtualDisplay, COMDAT
; _this$ = ecx

; 86   :     virtual ~VirtualDisplay()	{ ShiAssert( ready == FALSE ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??1ContextMPR@@UAE@XZ			; ContextMPR::~ContextMPR
	mov	esp, ebp
	pop	ebp
	ret	0
??1VirtualDisplay@@UAE@XZ ENDP				; VirtualDisplay::~VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??0VirtualDisplay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VirtualDisplay@@QAE@XZ PROC				; VirtualDisplay::VirtualDisplay, COMDAT
; _this$ = ecx

; 85   :     VirtualDisplay()			{ ready = FALSE; tLeft = tTop = tRight = tBottom = txRes = tyRes = 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0ContextMPR@@QAE@XZ			; ContextMPR::ContextMPR
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262776], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262772], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262768], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262764], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262760], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262756], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VirtualDisplay@@QAE@XZ ENDP				; VirtualDisplay::VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\context.h
;	COMDAT ?CurrentForegroundColor@ContextMPR@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentForegroundColor@ContextMPR@@QAEHXZ PROC		; ContextMPR::CurrentForegroundColor, COMDAT
; _this$ = ecx

; 708  : 	int CurrentForegroundColor(void) {return m_colFG_Raw;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentForegroundColor@ContextMPR@@QAEHXZ ENDP		; ContextMPR::CurrentForegroundColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$VuBin@VVuEntity@@@@V?$allocator@V?$VuBin@VVuEntity@@@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@V?$VuBin@VVuEntity@@@@V?$allocator@V?$VuBin@VVuEntity@@@@@std@@@std@@QBEIXZ PROC ; std::vector<VuBin<VuEntity>,std::allocator<VuBin<VuEntity> > >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1088 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@V?$VuBin@VVuEntity@@@@V?$allocator@V?$VuBin@VVuEntity@@@@@std@@@std@@QBEIXZ ENDP ; std::vector<VuBin<VuEntity>,std::allocator<VuBin<VuEntity> > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vusessn.h
;	COMDAT ?CameraCount@VuSessionEntity@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CameraCount@VuSessionEntity@@QBEHXZ PROC		; VuSessionEntity::CameraCount, COMDAT
; _this$ = ecx

; 228  : 	int CameraCount() const { return cameras_.size(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 380				; 0000017cH
	call	?size@?$vector@V?$VuBin@VVuEntity@@@@V?$allocator@V?$VuBin@VVuEntity@@@@@std@@@std@@QBEIXZ ; std::vector<VuBin<VuEntity>,std::allocator<VuBin<VuEntity> > >::size
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraCount@VuSessionEntity@@QBEHXZ ENDP		; VuSessionEntity::CameraCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityDriver@VuEntity@@QAEPAVVuDriver@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityDriver@VuEntity@@QAEPAVVuDriver@@XZ PROC		; VuEntity::EntityDriver, COMDAT
; _this$ = ecx

; 180  : 	VuDriver *EntityDriver()	{ return driver_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityDriver@VuEntity@@QAEPAVVuDriver@@XZ ENDP		; VuEntity::EntityDriver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
