; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\RWR\tracklst.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?Type@SensorClass@@QAE?AW4SensorType@1@XZ	; SensorClass::Type
PUBLIC	?IsTracked@VehRwrClass@@QAEPAUDetectListElement@1@PAVFalconEntity@@@Z ; VehRwrClass::IsTracked
PUBLIC	?AddTrack@VehRwrClass@@IAEPAUDetectListElement@1@PAVFalconEntity@@M@Z ; VehRwrClass::AddTrack
PUBLIC	?DropTrack@VehRwrClass@@IAEXH@Z			; VehRwrClass::DropTrack
PUBLIC	?SortDetectionList@VehRwrClass@@IAEXXZ		; VehRwrClass::SortDetectionList
PUBLIC	?ResortList@VehRwrClass@@IAEXPAUDetectListElement@1@@Z ; VehRwrClass::ResortList
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	__real@00000000
PUBLIC	__real@3f8ccccd
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?RadarDataTable@@3PAURadarDataType@@A:DWORD	; RadarDataTable
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\rwr\tracklst.cpp
_TEXT	SEGMENT
_tmpElement$ = -52					; size = 32
_thisLethality$ = -20					; size = 4
_thisId$ = -16						; size = 4
_newId$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_theElement$ = 8					; size = 4
?ResortList@VehRwrClass@@IAEXPAUDetectListElement@1@@Z PROC ; VehRwrClass::ResortList
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	float thisLethality = theElement->lethality;

	mov	eax, DWORD PTR _theElement$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR _thisLethality$[ebp], xmm0

; 156  : 	int i;
; 157  : 	int thisId = -1;

	mov	DWORD PTR _thisId$[ebp], -1

; 158  : 	int newId = 0;

	mov	DWORD PTR _newId$[ebp], 0

; 159  : 	DetectListElement tmpElement;
; 160  : 	
; 161  : 	// Find out where this element should go
; 162  : 	for (i=0; i<numContacts; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@ResortList
$LN15@ResortList:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN16@ResortList:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+588]
	jge	SHORT $LN14@ResortList

; 163  : 	{
; 164  : 		if (&detectionList[i] == theElement)

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+76]
	cmp	eax, DWORD PTR _theElement$[ebp]
	jne	SHORT $LN13@ResortList

; 165  : 		{
; 166  : 			tmpElement = detectionList[i];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [edx+ecx+76]
	mov	ecx, 8
	lea	edi, DWORD PTR _tmpElement$[ebp]
	rep movsd

; 167  : 			thisId = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _thisId$[ebp], eax
$LN13@ResortList:

; 168  : 		}
; 169  : 		
; 170  : 		if (detectionList[i].lethality >= thisLethality)//me123 addet =

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+100]
	comiss	xmm0, DWORD PTR _thisLethality$[ebp]
	jb	SHORT $LN12@ResortList

; 171  : 			newId = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _newId$[ebp], eax
$LN12@ResortList:

; 172  : 	}

	jmp	SHORT $LN15@ResortList
$LN14@ResortList:

; 173  : 	
; 174  : 	if (newId < thisId)

	mov	ecx, DWORD PTR _newId$[ebp]
	cmp	ecx, DWORD PTR _thisId$[ebp]
	jge	$LN11@ResortList

; 175  : 	{
; 176  : 		// Moving up in the world (moving into a lower number/higher priority slot)
; 177  : 		// Push others down to fill in the hole we're leaving behind
; 178  : 		for (i=thisId; i > newId; i--)

	mov	edx, DWORD PTR _thisId$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN10@ResortList
$LN9@ResortList:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@ResortList:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _newId$[ebp]
	jle	SHORT $LN8@ResortList

; 179  : 		{
; 180  : 			detectionList[i] = detectionList[i-1];

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [eax+edx+76]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+76]
	mov	ecx, 8
	rep movsd

; 181  : 		}

	jmp	SHORT $LN9@ResortList
$LN8@ResortList:

; 182  : 		
; 183  : 		// Drop into our new slot
; 184  : 		ShiAssert( i == newId );
; 185  : 		detectionList[newId] = tmpElement;

	mov	eax, DWORD PTR _newId$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [ecx+eax+76]
	mov	ecx, 8
	lea	esi, DWORD PTR _tmpElement$[ebp]
	rep movsd

; 186  : 
; 187  : 		// Bring the selected flag back if we pushed it out of the default slot
; 188  : 		if ((newId == 0) && (detectionList[1].selected)) {

	cmp	DWORD PTR _newId$[ebp], 0
	jne	SHORT $LN7@ResortList
	mov	edx, 32					; 00000020H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN7@ResortList

; 189  : 			detectionList[1].selected	= 0;

	mov	edx, 32					; 00000020H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -65				; ffffffbfH
	mov	edx, 32					; 00000020H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 190  : 			detectionList[0].selected	= 1;

	mov	ecx, 32					; 00000020H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	or	eax, 64					; 00000040H
	mov	ecx, 32					; 00000020H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax
$LN7@ResortList:

; 191  : 		}
; 192  : 	}

	jmp	$LN1@ResortList
$LN11@ResortList:

; 193  : 	else if (newId > thisId)

	mov	eax, DWORD PTR _newId$[ebp]
	cmp	eax, DWORD PTR _thisId$[ebp]
	jle	$LN1@ResortList

; 194  : 	{
; 195  : 		// Moving down in the world (moving into a higher number/lower priority slot)
; 196  : 		// Pull others up to fill in the hole we're leaving behind
; 197  : 		for (i=thisId; i < newId; i++)

	mov	ecx, DWORD PTR _thisId$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@ResortList
$LN3@ResortList:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ResortList:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _newId$[ebp]
	jge	SHORT $LN2@ResortList

; 198  : 		{
; 199  : 			detectionList[i] = detectionList[i+1];

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [edx+ecx+76]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [ecx+eax+76]
	mov	ecx, 8
	rep movsd

; 200  : 		}

	jmp	SHORT $LN3@ResortList
$LN2@ResortList:

; 201  : 		
; 202  : 		// Drop into our new slot
; 203  : 		ShiAssert( i == newId );
; 204  : 		detectionList[newId] = tmpElement;

	mov	edx, DWORD PTR _newId$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [eax+edx+76]
	mov	ecx, 8
	lea	esi, DWORD PTR _tmpElement$[ebp]
	rep movsd

; 205  : 
; 206  : 		// Put the selected flag back if we took it with us out of the default slot
; 207  : 		if ((thisId == 0) && (detectionList[newId].selected)) {

	cmp	DWORD PTR _thisId$[ebp], 0
	jne	SHORT $LN1@ResortList
	mov	ecx, DWORD PTR _newId$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN1@ResortList

; 208  : 			detectionList[newId].selected	= 0;

	mov	ecx, DWORD PTR _newId$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -65				; ffffffbfH
	mov	ecx, DWORD PTR _newId$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 209  : 			detectionList[0].selected		= 1;

	mov	eax, 32					; 00000020H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	or	edx, 64					; 00000040H
	mov	eax, 32					; 00000020H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx
$LN1@ResortList:

; 210  : 		}
; 211  : 	}
; 212  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ResortList@VehRwrClass@@IAEXPAUDetectListElement@1@@Z ENDP ; VehRwrClass::ResortList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\rwr\tracklst.cpp
_TEXT	SEGMENT
_tmpElement$ = -44					; size = 32
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?SortDetectionList@VehRwrClass@@IAEXXZ PROC		; VehRwrClass::SortDetectionList
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	int i,j;
; 119  : 	DetectListElement tmpElement;
; 120  : 
; 121  : 	for(i = 1; i < numContacts; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN8@SortDetect
$LN7@SortDetect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@SortDetect:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+588]
	jge	$LN6@SortDetect

; 122  : 	{
; 123  : 		//if we don't need to move, don't do any unnecessary copies
; 124  : 		if(detectionList[i-1].lethality < detectionList[i].lethality)

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+100]
	comiss	xmm0, DWORD PTR [esi+eax+100]
	jbe	$LN5@SortDetect

; 125  : 		{
; 126  : 			//copy data for current entry
; 127  : 			tmpElement = detectionList[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [ecx+eax+76]
	mov	ecx, 8
	lea	edi, DWORD PTR _tmpElement$[ebp]
	rep movsd

; 128  : 			j = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], edx
$LN4@SortDetect:

; 129  : 
; 130  : 			while(detectionList[j-1].lethality < tmpElement.lethality)

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpElement$[ebp+24]
	comiss	xmm0, DWORD PTR [ecx+eax+100]
	jbe	SHORT $LN3@SortDetect

; 131  : 			{
; 132  : 				//if our lethality is greater than lethality of entry before us move it down
; 133  : 				detectionList[j] = detectionList[j-1];

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [eax+edx+76]
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+76]
	mov	ecx, 8
	rep movsd

; 134  : 				j--;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 135  : 				if(!j)

	jne	SHORT $LN2@SortDetect

; 136  : 				{
; 137  : 					//check to prevent going off top of array
; 138  : 					if(detectionList[1].selected)

	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN1@SortDetect

; 139  : 					{
; 140  : 						// Bring the selected flag back if we pushed it out of the default slot
; 141  : 						detectionList[1].selected	= 0;

	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -65				; ffffffbfH
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 142  : 						tmpElement.selected	= 1;

	mov	eax, DWORD PTR _tmpElement$[ebp+20]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _tmpElement$[ebp+20], eax
$LN1@SortDetect:

; 143  : 					}
; 144  : 					break;

	jmp	SHORT $LN3@SortDetect
$LN2@SortDetect:

; 145  : 				}
; 146  : 			}

	jmp	$LN4@SortDetect
$LN3@SortDetect:

; 147  : 			//insert us back into new place in list
; 148  : 			detectionList[j] = tmpElement;

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+76]
	mov	ecx, 8
	lea	esi, DWORD PTR _tmpElement$[ebp]
	rep movsd
$LN5@SortDetect:

; 149  : 		}
; 150  : 	}

	jmp	$LN7@SortDetect
$LN6@SortDetect:

; 151  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SortDetectionList@VehRwrClass@@IAEXXZ ENDP		; VehRwrClass::SortDetectionList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\rwr\tracklst.cpp
_TEXT	SEGMENT
_tmpPtr$ = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_trackNum$ = 8						; size = 4
?DropTrack@VehRwrClass@@IAEXH@Z PROC			; VehRwrClass::DropTrack
; _this$ = ecx

; 215  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 216  : SimObjectType* tmpPtr = platform->targetList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+660]
	mov	DWORD PTR _tmpPtr$[ebp], edx
$LN11@DropTrack:

; 217  : 
; 218  : 	ShiAssert (numContacts > 0);
; 219  : 
; 220  : 	// Find this object in the target list, and mark the RWR as not tracking
; 221  : 	// TODO:  Make the entity pointer in the detectionList be a SimObjectType to avoid this...
; 222  : 	while (tmpPtr)

	cmp	DWORD PTR _tmpPtr$[ebp], 0
	je	SHORT $LN10@DropTrack

; 223  : 	{
; 224  : 		if (tmpPtr->BaseData() == detectionList[trackNum].entity)

	mov	ecx, DWORD PTR _tmpPtr$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, DWORD PTR _trackNum$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+76]
	jne	SHORT $LN9@DropTrack

; 225  : 		{
; 226  : 			tmpPtr->localData->sensorState[Type()] = NoTrack;

	mov	eax, DWORD PTR _tmpPtr$[ebp]
	mov	esi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@SensorClass@@QAE?AW4SensorType@1@XZ ; SensorClass::Type
	mov	DWORD PTR [esi+eax*4+192], 0

; 227  : 			break;

	jmp	SHORT $LN10@DropTrack
$LN9@DropTrack:

; 228  : 		}
; 229  : 		tmpPtr = tmpPtr->next;

	mov	ecx, DWORD PTR _tmpPtr$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _tmpPtr$[ebp], edx

; 230  : 	}

	jmp	SHORT $LN11@DropTrack
$LN10@DropTrack:

; 231  : 
; 232  : 	// Let go of the entity
; 233  : 	VuDeReferenceEntity (detectionList[trackNum].entity);

	mov	eax, DWORD PTR _trackNum$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+76]
	push	edx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 234  : 	detectionList[trackNum].entity = NULL;

	mov	eax, DWORD PTR _trackNum$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+76], 0

; 235  : 
; 236  : 	// Fix up the "selected" flag if this record had it
; 237  : 	if (detectionList[trackNum].selected) {

	mov	edx, DWORD PTR _trackNum$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN6@DropTrack

; 238  : 		if (trackNum == 0)

	cmp	DWORD PTR _trackNum$[ebp], 0
	jne	SHORT $LN7@DropTrack

; 239  : 			// We're going to delete the default one and shift number 1 up to the default slot
; 240  : 			detectionList[1].selected = 1;

	mov	edx, 32					; 00000020H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	or	ecx, 64					; 00000040H
	mov	edx, 32					; 00000020H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 241  : 		else

	jmp	SHORT $LN6@DropTrack
$LN7@DropTrack:

; 242  : 			// We deleted the selected emitter, so send it back to the default
; 243  : 			detectionList[0].selected = 1;

	mov	ecx, 32					; 00000020H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	or	eax, 64					; 00000040H
	mov	ecx, 32					; 00000020H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax
$LN6@DropTrack:

; 244  : 	}
; 245  : 
; 246  : 	// Shift other contacts up
; 247  : 	for (int i=trackNum; i<numContacts; i++)

	mov	eax, DWORD PTR _trackNum$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN5@DropTrack
$LN4@DropTrack:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN5@DropTrack:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR [edx+588]
	jge	$LN3@DropTrack

; 248  : 	{
; 249  : 		if (i+1<MaxRWRTracks)

	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN2@DropTrack

; 250  : 			detectionList[i] = detectionList[i+1];

	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [eax+edx+76]
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+76]
	mov	ecx, 8
	rep movsd

; 251  : 		else

	jmp	$LN1@DropTrack
$LN2@DropTrack:

; 252  : 		{
; 253  : 			detectionList[i].entity				= NULL;

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+76], 0

; 254  : 			detectionList[i].lastHit			= 0;

	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+88], 0

; 255  : 			detectionList[i].lethality			= 0.0F;

	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+100], xmm0

; 256  : 			detectionList[i].isLocked			= 0;

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx

; 257  : 			detectionList[i].isAGLocked			= 0;//Cobra TJL

	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 258  : 			detectionList[i].missileActivity	= 0;

	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 259  : 			detectionList[i].missileLaunch		= 0;

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx

; 260  : 			detectionList[i].selected			= 0;

	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 261  : // JB 010727 RP5 RWR
; 262  : // 2001-02-15 ADDED BY S.G. SO THE NEW cantPlay field IS ZEROED AS WELL AND playIt AS WELL
; 263  : 			detectionList[i].cantPlay			= 0;

	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -257				; fffffeffH
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 264  : 			detectionList[i].playIt				= 0;

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx
$LN1@DropTrack:

; 265  : // END OF ADDED SECTION
; 266  : 		}
; 267  : 	}

	jmp	$LN4@DropTrack
$LN3@DropTrack:

; 268  : 
; 269  : 	// Note the decrease in our total number of tracks
; 270  : 	numContacts--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+588], eax

; 271  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?DropTrack@VehRwrClass@@IAEXH@Z ENDP			; VehRwrClass::DropTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\rwr\tracklst.cpp
_TEXT	SEGMENT
_retval$ = -28						; size = 4
tv299 = -24						; size = 4
tv130 = -20						; size = 4
_tmpPtr$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_object$ = 8						; size = 4
_lethality$ = 12					; size = 4
?AddTrack@VehRwrClass@@IAEPAUDetectListElement@1@PAVFalconEntity@@M@Z PROC ; VehRwrClass::AddTrack
; _this$ = ecx

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 	int					i, j;
; 32   : 	DetectListElement	*retval = NULL;

	mov	DWORD PTR _retval$[ebp], 0

; 33   : 	SimObjectType* tmpPtr;
; 34   : 
; 35   : 	for (i=0; i<numContacts; i++) // JB 010727

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@AddTrack
$LN16@AddTrack:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@AddTrack:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+588]
	jge	SHORT $LN15@AddTrack

; 36   : 		detectionList[i].newDetectionDisplay = FALSE; // JB 010727

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx
	jmp	SHORT $LN16@AddTrack
$LN15@AddTrack:

; 37   : 	
; 38   : 	// Find the first contact with lower lethality
; 39   : 	for (i=0; i<numContacts; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@AddTrack
$LN13@AddTrack:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN14@AddTrack:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	SHORT $LN12@AddTrack

; 40   : 	{
; 41   : 		// JB 010718
; 42   : 		//We bump the lethality of things by 10% already in the list
; 43   : 		//to keep from putting things in and out all the time
; 44   : 		if (detectionList[i].lethality * 1.1f < lethality) // 1.1f and < instead of <= (RP5)

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+100]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	movss	xmm1, DWORD PTR _lethality$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@AddTrack

; 45   : 		{
; 46   : 			break;

	jmp	SHORT $LN12@AddTrack
$LN11@AddTrack:

; 47   : 		}
; 48   : 	}

	jmp	SHORT $LN13@AddTrack
$LN12@AddTrack:

; 49   : 
; 50   : 	// Does this track qualify for addition to the list?
; 51   : 	if (i <= numContacts && i < MaxRWRTracks)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+588]
	jg	$LN2@AddTrack
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN2@AddTrack

; 52   : 	{
; 53   : 		// Drop the last entry if the list is full
; 54   : 		if (detectionList[MaxRWRTracks-1].entity)

	mov	eax, 32					; 00000020H
	imul	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+76], 0
	je	SHORT $LN9@AddTrack

; 55   : 		{
; 56   : 			DropTrack(MaxRWRTracks-1);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropTrack@VehRwrClass@@IAEXH@Z		; VehRwrClass::DropTrack
$LN9@AddTrack:

; 57   : 		}
; 58   : 		
; 59   : 		// Shift everything down to make room for the new entry 
; 60   : 		for (j=min(numContacts, MaxRWRTracks-1); j>i; j--)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+588], 15			; 0000000fH
	jge	SHORT $LN20@AddTrack
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN21@AddTrack
$LN20@AddTrack:
	mov	DWORD PTR tv130[ebp], 15		; 0000000fH
$LN21@AddTrack:
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $LN8@AddTrack
$LN7@AddTrack:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN8@AddTrack:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _i$[ebp]
	jle	SHORT $LN6@AddTrack

; 61   : 		{
; 62   : 			detectionList[j] = detectionList[j-1]; //ME123 this loop was fucked up. fixed.

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR [eax+edx+76]
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+76]
	mov	ecx, 8
	rep movsd

; 63   : 		}

	jmp	SHORT $LN7@AddTrack
$LN6@AddTrack:

; 64   : 		ShiAssert( j <= i );
; 65   : 
; 66   : 		// Initialize the new entry -- the rest of the elements will be set by the caller
; 67   : 		detectionList[i].entity				= object;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [ecx+eax+76], edx

; 68   : 		detectionList[i].radarData			= &RadarDataTable[object->GetRadarType()];

	mov	eax, DWORD PTR _object$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	imul	eax, 58					; 0000003aH
	add	eax, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+80], eax

; 69   : 		detectionList[i].lastPlayed			= 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+92], 0

; 70   : 		detectionList[i].isLocked			= 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 71   : 		detectionList[i].isAGLocked			= 0;//Cobra TJL

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 72   : 		detectionList[i].missileActivity	= 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx

; 73   : 		detectionList[i].missileLaunch		= 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 74   : // JB 010727 RP5 RWR
; 75   : // 2001-02-15 ADDED BY S.G. SO THE NEW cantPlay field IS ZEROED AS WELL AND playIt AS WELL
; 76   : 		detectionList[i].cantPlay			= 0;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -257				; fffffeffH
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 77   : 		detectionList[i].playIt				= 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx

; 78   : // END OF ADDED SECTION
; 79   : 		detectionList[i].previouslyLocked	= FALSE;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 80   : 		detectionList[i].newDetection		= TRUE;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 81   : 		detectionList[i].newDetectionDisplay		= TRUE; // JB 010727

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx

; 82   : 		detectionList[i].lethality			= lethality;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _lethality$[ebp]
	movss	DWORD PTR [eax+edx+100], xmm0

; 83   : 
; 84   : 		VuReferenceEntity( object );

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 85   : 		retval = &detectionList[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+76]
	mov	DWORD PTR _retval$[ebp], ecx

; 86   : 		
; 87   : 		// Maintain the "selected" flag
; 88   : 		if (i != 0) {

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN5@AddTrack

; 89   : 			// If we didn't go into the top slot, we won't change who's selected
; 90   : 			detectionList[i].selected	= 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+96]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+96], ecx

; 91   : 		} else {

	jmp	SHORT $LN4@AddTrack
$LN5@AddTrack:

; 92   : 			// If we went into the top slot, we'll inherit the flag from whomever we pushed out
; 93   : 			// Just make sure the guy we pushed out doesn't think he still has it.
; 94   : 			detectionList[1].selected	= 0;

	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, -65				; ffffffbfH
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax
$LN4@AddTrack:

; 95   : 		}
; 96   : 
; 97   : 		// Find this object in the target list, and mark the RWR as tracking
; 98   : 		// TODO:  Make the entity pointer in the detectionList be a SimObjectType to avoid this...
; 99   : 		tmpPtr = platform->targetList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+660]
	mov	DWORD PTR _tmpPtr$[ebp], edx
$LN3@AddTrack:

; 100  : 		while (tmpPtr)

	cmp	DWORD PTR _tmpPtr$[ebp], 0
	je	SHORT $LN2@AddTrack

; 101  : 		{
; 102  : 			if (tmpPtr->BaseData() == object)

	mov	ecx, DWORD PTR _tmpPtr$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	eax, DWORD PTR _object$[ebp]
	jne	SHORT $LN1@AddTrack

; 103  : 			{
; 104  : 				tmpPtr->localData->sensorState[Type()] = SensorTrack;

	mov	eax, DWORD PTR _tmpPtr$[ebp]
	mov	esi, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@SensorClass@@QAE?AW4SensorType@1@XZ ; SensorClass::Type
	mov	DWORD PTR [esi+eax*4+192], 3

; 105  : 				break;

	jmp	SHORT $LN2@AddTrack
$LN1@AddTrack:

; 106  : 			}
; 107  : 			tmpPtr = tmpPtr->next;

	mov	ecx, DWORD PTR _tmpPtr$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _tmpPtr$[ebp], edx

; 108  : 		}

	jmp	SHORT $LN3@AddTrack
$LN2@AddTrack:

; 109  : 	}
; 110  : 	
; 111  : 	numContacts = min (numContacts+1, MaxRWRTracks);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 1
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN22@AddTrack
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	add	eax, 1
	mov	DWORD PTR tv299[ebp], eax
	jmp	SHORT $LN23@AddTrack
$LN22@AddTrack:
	mov	DWORD PTR tv299[ebp], 16		; 00000010H
$LN23@AddTrack:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv299[ebp]
	mov	DWORD PTR [ecx+588], edx

; 112  : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 113  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddTrack@VehRwrClass@@IAEPAUDetectListElement@1@PAVFalconEntity@@M@Z ENDP ; VehRwrClass::AddTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\rwr\tracklst.cpp
_TEXT	SEGMENT
_retval$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_object$ = 8						; size = 4
?IsTracked@VehRwrClass@@QAEPAUDetectListElement@1@PAVFalconEntity@@@Z PROC ; VehRwrClass::IsTracked
; _this$ = ecx

; 13   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 14   : int	i;
; 15   : DetectListElement* retval = NULL;

	mov	DWORD PTR _retval$[ebp], 0

; 16   : 
; 17   : 	// Check for existing tracked object
; 18   : 	for (i=0; i<numContacts+1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@IsTracked
$LN3@IsTracked:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@IsTracked:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	add	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN2@IsTracked

; 19   : 		{
; 20   : 		if (detectionList[i].entity == object)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+76]
	cmp	edx, DWORD PTR _object$[ebp]
	jne	SHORT $LN1@IsTracked

; 21   : 			{
; 22   : 			retval = &detectionList[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+76]
	mov	DWORD PTR _retval$[ebp], edx
$LN1@IsTracked:

; 23   : 			}
; 24   : 		}

	jmp	SHORT $LN3@IsTracked
$LN2@IsTracked:

; 25   : 
; 26   :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 27   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsTracked@VehRwrClass@@QAEPAUDetectListElement@1@PAVFalconEntity@@@Z ENDP ; VehRwrClass::IsTracked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?Type@SensorClass@@QAE?AW4SensorType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@SensorClass@@QAE?AW4SensorType@1@XZ PROC		; SensorClass::Type, COMDAT
; _this$ = ecx

; 36   : 	SensorType	Type(void)			{ return sensorType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@SensorClass@@QAE?AW4SensorType@1@XZ ENDP		; SensorClass::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
