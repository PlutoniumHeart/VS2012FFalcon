; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\ICP\IcpFACK.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?GetFaultCount@FaultClass@@QAEHXZ		; FaultClass::GetFaultCount
PUBLIC	?GetFFaultCount@FackClass@@QAEHXZ		; FackClass::GetFFaultCount
PUBLIC	?GetFirstFault@FackClass@@QAEHPAW4type_FSubSystem@FaultClass@@PAH@Z ; FackClass::GetFirstFault
PUBLIC	?ExecFACKMode@ICPClass@@QAEXXZ			; ICPClass::ExecFACKMode
PUBLIC	?PNUpdateFACKMode@ICPClass@@QAEXHH@Z		; ICPClass::PNUpdateFACKMode
PUBLIC	?PflFault@ICPClass@@QAEXW4type_FSubSystem@FaultClass@@H@Z ; ICPClass::PflFault
PUBLIC	?PflNoFaults@ICPClass@@QAEXXZ			; ICPClass::PflNoFaults
PUBLIC	?ExecPfl@ICPClass@@QAEXXZ			; ICPClass::ExecPfl
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BA@CMOKLJJH@?5?5?5?5?5?5NO?5FAULTS?$AA@	; `string'
PUBLIC	??_C@_0BB@DNIEMOMJ@?5?5?5?5?5?5ALL?5SYS?5OK?$AA@ ; `string'
PUBLIC	??_C@_0O@NCICLAGP@?5?5?5?5?5?5?5?5FAULT?$AA@	; `string'
PUBLIC	??_C@_0P@EIAMFMII@?5?5?5?$CF4s?5?$CF4s?5?$CF4s?$AA@ ; `string'
PUBLIC	??_C@_09FMJGLIFF@NO?5FAULTS?$AA@		; `string'
PUBLIC	??_C@_0L@EIJOBBFE@ALL?5SYS?5OK?$AA@		; `string'
PUBLIC	??_C@_05KJCLNFLA@FAULT?$AA@			; `string'
PUBLIC	??_C@_0M@BCNFJELD@?$CF4s?5?$CF4s?5?$CF4s?$AA@	; `string'
EXTRN	_sprintf:PROC
EXTRN	_strlen:PROC
EXTRN	?GetFirstFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z:PROC ; FaultClass::GetFirstFault
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetFaultNames@FackClass@@QAEXW4type_FSubSystem@FaultClass@@HPAUstr_FNames@3@@Z:PROC ; FackClass::GetFaultNames
EXTRN	?FillPFLMatrix@ICPClass@@QAEXHHPADH@Z:PROC	; ICPClass::FillPFLMatrix
EXTRN	?ClearPFLLines@ICPClass@@QAEXXZ:PROC		; ICPClass::ClearPFLLines
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_0M@BCNFJELD@?$CF4s?5?$CF4s?5?$CF4s?$AA@
CONST	SEGMENT
??_C@_0M@BCNFJELD@?$CF4s?5?$CF4s?5?$CF4s?$AA@ DB '%4s %4s %4s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJCLNFLA@FAULT?$AA@
CONST	SEGMENT
??_C@_05KJCLNFLA@FAULT?$AA@ DB 'FAULT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EIJOBBFE@ALL?5SYS?5OK?$AA@
CONST	SEGMENT
??_C@_0L@EIJOBBFE@ALL?5SYS?5OK?$AA@ DB 'ALL SYS OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMJGLIFF@NO?5FAULTS?$AA@
CONST	SEGMENT
??_C@_09FMJGLIFF@NO?5FAULTS?$AA@ DB 'NO FAULTS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EIAMFMII@?5?5?5?$CF4s?5?$CF4s?5?$CF4s?$AA@
CONST	SEGMENT
??_C@_0P@EIAMFMII@?5?5?5?$CF4s?5?$CF4s?5?$CF4s?$AA@ DB '   %4s %4s %4s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NCICLAGP@?5?5?5?5?5?5?5?5FAULT?$AA@
CONST	SEGMENT
??_C@_0O@NCICLAGP@?5?5?5?5?5?5?5?5FAULT?$AA@ DB '        FAULT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNIEMOMJ@?5?5?5?5?5?5ALL?5SYS?5OK?$AA@
CONST	SEGMENT
??_C@_0BB@DNIEMOMJ@?5?5?5?5?5?5ALL?5SYS?5OK?$AA@ DB '      ALL SYS OK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CMOKLJJH@?5?5?5?5?5?5NO?5FAULTS?$AA@
CONST	SEGMENT
??_C@_0BA@CMOKLJJH@?5?5?5?5?5?5NO?5FAULTS?$AA@ DB '      NO FAULTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\icp\icpfack.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?ExecPfl@ICPClass@@QAEXXZ PROC				; ICPClass::ExecPfl
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 69   : 	if ((mUpdateFlags & FACK_UPDATE) == 0) // nothing to update;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN6@ExecPfl

; 70   :     ClearPFLLines(); // reset the display

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPFLLines@ICPClass@@QAEXXZ		; ICPClass::ClearPFLLines
$LN6@ExecPfl:

; 71   :     mUpdateFlags &= ~FACK_UPDATE; // we'll have updated.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -65				; ffffffbfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 72   :     if (m_FaultDisplay == false || !playerAC || !playerAC->mFaults)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+468]
	test	eax, eax
	je	SHORT $LN4@ExecPfl
	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN4@ExecPfl
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+928], 0
	jne	SHORT $LN5@ExecPfl
$LN4@ExecPfl:

; 73   : 	return; // nothing to show

	jmp	SHORT $LN7@ExecPfl
$LN5@ExecPfl:

; 74   : 
; 75   :     if (playerAC->mFaults->GetFFaultCount() <= 0) {

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFFaultCount@FackClass@@QAEHXZ	; FackClass::GetFFaultCount
	test	eax, eax
	jg	SHORT $LN3@ExecPfl

; 76   : 	PflNoFaults();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PflNoFaults@ICPClass@@QAEXXZ		; ICPClass::PflNoFaults

; 77   :     }
; 78   :     else {

	jmp	SHORT $LN7@ExecPfl
$LN3@ExecPfl:

; 79   : 		if (m_function == FaultClass::nofault)					//Wombat778 10-20-2003 removed change because it seemed to break PFL in realistic modes.  Changed code in ICPclass instead.

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+476], 0
	jne	SHORT $LN1@ExecPfl

; 80   : 			playerAC->mFaults->GetFirstFault(&m_subsystem, &m_function);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476				; 000001dcH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 472				; 000001d8H
	push	edx
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFirstFault@FackClass@@QAEHPAW4type_FSubSystem@FaultClass@@PAH@Z ; FackClass::GetFirstFault
$LN1@ExecPfl:

; 81   : 		PflFault(m_subsystem, m_function);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+472]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PflFault@ICPClass@@QAEXW4type_FSubSystem@FaultClass@@H@Z ; ICPClass::PflFault
$LN7@ExecPfl:

; 82   : 
; 83   : 	} 
; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ExecPfl@ICPClass@@QAEXXZ ENDP				; ICPClass::ExecPfl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\icp\icpfack.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PflNoFaults@ICPClass@@QAEXXZ PROC			; ICPClass::PflNoFaults
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   :     //Line1
; 89   :     FillPFLMatrix(0,10, "NO FAULTS");

	push	0
	push	OFFSET ??_C@_09FMJGLIFF@NO?5FAULTS?$AA@
	push	10					; 0000000aH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FillPFLMatrix@ICPClass@@QAEXHHPADH@Z	; ICPClass::FillPFLMatrix

; 90   :     //Line3
; 91   :     FillPFLMatrix(2,9, "ALL SYS OK");

	push	0
	push	OFFSET ??_C@_0L@EIJOBBFE@ALL?5SYS?5OK?$AA@
	push	9
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FillPFLMatrix@ICPClass@@QAEXHHPADH@Z	; ICPClass::FillPFLMatrix

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PflNoFaults@ICPClass@@QAEXXZ ENDP			; ICPClass::PflNoFaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\icp\icpfack.cpp
_TEXT	SEGMENT
_faultNames$ = -64					; size = 12
_playerAC$ = -52					; size = 4
_this$ = -48						; size = 4
_tempstr$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_sys$ = 8						; size = 4
_func$ = 12						; size = 4
?PflFault@ICPClass@@QAEXW4type_FSubSystem@FaultClass@@H@Z PROC ; ICPClass::PflFault
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 97   : 	char tempstr[40];
; 98   :     FaultClass::str_FNames	faultNames;
; 99   : 
; 100  :     playerAC->mFaults->GetFaultNames(sys, func, &faultNames);

	lea	eax, DWORD PTR _faultNames$[ebp]
	push	eax
	mov	ecx, DWORD PTR _func$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sys$[ebp]
	push	edx
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFaultNames@FackClass@@QAEXW4type_FSubSystem@FaultClass@@HPAUstr_FNames@3@@Z ; FackClass::GetFaultNames

; 101  :     //Line1
; 102  :     FillPFLMatrix(0,12,"FAULT");

	push	0
	push	OFFSET ??_C@_05KJCLNFLA@FAULT?$AA@
	push	12					; 0000000cH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FillPFLMatrix@ICPClass@@QAEXHHPADH@Z	; ICPClass::FillPFLMatrix

; 103  :     //Line3
; 104  :     //fix (better hack) to prevent strange stuff beeing written onto the PFL
; 105  :     sprintf(tempstr, "%4s %4s %4s", 
; 106  : 	faultNames.elpFSubSystemNames,
; 107  : 	faultNames.elpFFunctionNames,
; 108  : 	faultNames.elpFSeverityNames);

	mov	ecx, DWORD PTR _faultNames$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _faultNames$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _faultNames$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@BCNFJELD@?$CF4s?5?$CF4s?5?$CF4s?$AA@
	lea	ecx, DWORD PTR _tempstr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 109  : 
; 110  :     FillPFLMatrix(2,((25-strlen(tempstr))/2), tempstr);

	push	0
	lea	edx, DWORD PTR _tempstr$[ebp]
	push	edx
	lea	eax, DWORD PTR _tempstr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, 25					; 00000019H
	sub	ecx, eax
	shr	ecx, 1
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FillPFLMatrix@ICPClass@@QAEXHHPADH@Z	; ICPClass::FillPFLMatrix

; 111  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?PflFault@ICPClass@@QAEXW4type_FSubSystem@FaultClass@@H@Z ENDP ; ICPClass::PflFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\icp\icpfack.cpp
_TEXT	SEGMENT
_testFunc$ = -24					; size = 4
_playerAC$ = -20					; size = 4
_failedFuncs$ = -16					; size = 4
_funcIdx$ = -12						; size = 4
_faultIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_button$ = 8						; size = 4
___formal$ = 12						; size = 4
?PNUpdateFACKMode@ICPClass@@QAEXHH@Z PROC		; ICPClass::PNUpdateFACKMode
; _this$ = ecx

; 113  : void ICPClass::PNUpdateFACKMode(int button, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 
; 115  : 	int faultIdx;
; 116  :    int failedFuncs;
; 117  :    int funcIdx;
; 118  :    int testFunc;
; 119  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 120  : 
; 121  : 	if(!playerAC) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN26@PNUpdateFA

; 122  : 		return;

	jmp	$LN27@PNUpdateFA
$LN26@PNUpdateFA:

; 123  : 	}
; 124  : 
; 125  : 	if (button == PREV_BUTTON && playerAC->mFaults->GetFFaultCount() >= 1) {

	cmp	DWORD PTR _button$[ebp], 13		; 0000000dH
	jne	$LN25@PNUpdateFA
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFFaultCount@FackClass@@QAEHXZ	; FackClass::GetFFaultCount
	cmp	eax, 1
	jl	$LN25@PNUpdateFA

; 126  : 		
; 127  : 		faultIdx = mFaultNum;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	mov	DWORD PTR _faultIdx$[ebp], edx

; 128  :       failedFuncs = playerAC->mFaults->GetFault((FaultClass::type_FSubSystem) faultIdx);

	mov	eax, DWORD PTR _faultIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	mov	DWORD PTR _failedFuncs$[ebp], eax

; 129  : 
; 130  :       // previous failures on the System?
; 131  :       testFunc = mFaultFunc - 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]
	sub	eax, 1
	mov	DWORD PTR _testFunc$[ebp], eax

; 132  :       if (mFaultFunc && (failedFuncs & ((1 << testFunc)- 1)) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+264], 0
	je	SHORT $LN20@PNUpdateFA
	mov	edx, 1
	mov	ecx, DWORD PTR _testFunc$[ebp]
	shl	edx, cl
	sub	edx, 1
	and	edx, DWORD PTR _failedFuncs$[ebp]
	jle	SHORT $LN20@PNUpdateFA

; 133  :       {
; 134  :          mFaultFunc -= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	sub	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], ecx

; 135  :          funcIdx = (1 << mFaultFunc);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+264]
	shl	edx, cl
	mov	DWORD PTR _funcIdx$[ebp], edx
$LN23@PNUpdateFA:

; 136  :          while ((failedFuncs & funcIdx) == 0)

	mov	eax, DWORD PTR _failedFuncs$[ebp]
	and	eax, DWORD PTR _funcIdx$[ebp]
	jne	SHORT $LN22@PNUpdateFA

; 137  :          {
; 138  :             mFaultFunc --;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+264], edx

; 139  :             funcIdx = funcIdx >> 1;

	mov	ecx, DWORD PTR _funcIdx$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _funcIdx$[ebp], ecx

; 140  : 
; 141  :          }

	jmp	SHORT $LN23@PNUpdateFA
$LN22@PNUpdateFA:

; 142  :       }
; 143  :       else

	jmp	SHORT $LN21@PNUpdateFA
$LN20@PNUpdateFA:

; 144  :       {
; 145  :          // Find the previous sub-subsystem
; 146  : 		   do {
; 147  : 			   faultIdx--;

	mov	edx, DWORD PTR _faultIdx$[ebp]
	sub	edx, 1
	mov	DWORD PTR _faultIdx$[ebp], edx

; 148  : 			   if(faultIdx < 0) {

	jns	SHORT $LN17@PNUpdateFA

; 149  : 				   faultIdx = FaultClass::NumFaultListSubSystems - 1;

	mov	DWORD PTR _faultIdx$[ebp], 28		; 0000001cH
$LN17@PNUpdateFA:

; 150  : 			   }
; 151  : 			   failedFuncs = playerAC->mFaults->GetFault((FaultClass::type_FSubSystem) faultIdx);

	mov	eax, DWORD PTR _faultIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	mov	DWORD PTR _failedFuncs$[ebp], eax

; 152  : 		   }	   
; 153  : 		   while(!failedFuncs && faultIdx != mFaultNum);

	cmp	DWORD PTR _failedFuncs$[ebp], 0
	jne	SHORT $LN18@PNUpdateFA
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _faultIdx$[ebp]
	cmp	eax, DWORD PTR [edx+260]
	jne	SHORT $LN20@PNUpdateFA
$LN18@PNUpdateFA:

; 154  : 		   
; 155  : 
; 156  :          // Find highest failed sub-system
; 157  :          funcIdx = (1 << 31);

	mov	DWORD PTR _funcIdx$[ebp], -2147483648	; 80000000H

; 158  :          mFaultFunc = 31;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], 31			; 0000001fH
$LN15@PNUpdateFA:

; 159  :          while ((failedFuncs & funcIdx) == 0)

	mov	edx, DWORD PTR _failedFuncs$[ebp]
	and	edx, DWORD PTR _funcIdx$[ebp]
	jne	SHORT $LN21@PNUpdateFA

; 160  :          {
; 161  :             mFaultFunc --;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], ecx

; 162  :             funcIdx = funcIdx >> 1;

	mov	eax, DWORD PTR _funcIdx$[ebp]
	sar	eax, 1
	mov	DWORD PTR _funcIdx$[ebp], eax

; 163  :          }

	jmp	SHORT $LN15@PNUpdateFA
$LN21@PNUpdateFA:

; 164  :       }
; 165  : 
; 166  : 		mFaultNum = faultIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _faultIdx$[ebp]
	mov	DWORD PTR [ecx+260], edx

; 167  :       mFaultFunc ++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], ecx
	jmp	$LN13@PNUpdateFA
$LN25@PNUpdateFA:

; 168  : 	}
; 169  : 	else if(button == NEXT_BUTTON && playerAC->mFaults->GetFFaultCount() >= 1) {

	cmp	DWORD PTR _button$[ebp], 14		; 0000000eH
	jne	$LN13@PNUpdateFA
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFFaultCount@FackClass@@QAEHXZ	; FackClass::GetFFaultCount
	cmp	eax, 1
	jl	$LN13@PNUpdateFA

; 170  : 
; 171  : 		faultIdx = mFaultNum;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	mov	DWORD PTR _faultIdx$[ebp], edx

; 172  :       failedFuncs = playerAC->mFaults->GetFault((FaultClass::type_FSubSystem) faultIdx);

	mov	eax, DWORD PTR _faultIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	mov	DWORD PTR _failedFuncs$[ebp], eax

; 173  : 
; 174  :       // next failures on the System?
; 175  :       if ((failedFuncs & ~((1 << mFaultFunc)- 1)) > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+264]
	shl	eax, cl
	sub	eax, 1
	not	eax
	and	eax, DWORD PTR _failedFuncs$[ebp]
	jle	SHORT $LN7@PNUpdateFA

; 176  :       {
; 177  :          funcIdx = (1 << mFaultFunc);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+264]
	shl	edx, cl
	mov	DWORD PTR _funcIdx$[ebp], edx
$LN10@PNUpdateFA:

; 178  :          while ((failedFuncs & funcIdx) == 0)

	mov	eax, DWORD PTR _failedFuncs$[ebp]
	and	eax, DWORD PTR _funcIdx$[ebp]
	jne	SHORT $LN9@PNUpdateFA

; 179  :          {
; 180  :             mFaultFunc ++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+264], edx

; 181  :             funcIdx = funcIdx << 1;

	mov	ecx, DWORD PTR _funcIdx$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _funcIdx$[ebp], ecx

; 182  :          }

	jmp	SHORT $LN10@PNUpdateFA
$LN9@PNUpdateFA:

; 183  :       }
; 184  :       else

	jmp	SHORT $LN8@PNUpdateFA
$LN7@PNUpdateFA:

; 185  :       {
; 186  : 		  do
; 187  : 		  {
; 188  : 			  faultIdx++;

	mov	edx, DWORD PTR _faultIdx$[ebp]
	add	edx, 1
	mov	DWORD PTR _faultIdx$[ebp], edx

; 189  : 			  if(faultIdx >= FaultClass::NumFaultListSubSystems)

	cmp	DWORD PTR _faultIdx$[ebp], 29		; 0000001dH
	jl	SHORT $LN4@PNUpdateFA

; 190  : 			  {
; 191  : 				  faultIdx = 0;

	mov	DWORD PTR _faultIdx$[ebp], 0
$LN4@PNUpdateFA:

; 192  : 			  }
; 193  : 			  failedFuncs = playerAC->mFaults->GetFault((FaultClass::type_FSubSystem) faultIdx);

	mov	eax, DWORD PTR _faultIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	mov	DWORD PTR _failedFuncs$[ebp], eax

; 194  : 		  }		  
; 195  : 		  while(!failedFuncs && faultIdx != mFaultNum);

	cmp	DWORD PTR _failedFuncs$[ebp], 0
	jne	SHORT $LN5@PNUpdateFA
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _faultIdx$[ebp]
	cmp	eax, DWORD PTR [edx+260]
	jne	SHORT $LN7@PNUpdateFA
$LN5@PNUpdateFA:

; 196  : 			  
; 197  : 		  // Find lowest failed sub-system
; 198  : 		  funcIdx = 1;

	mov	DWORD PTR _funcIdx$[ebp], 1

; 199  : 		  mFaultFunc = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], 0
$LN2@PNUpdateFA:

; 200  : 		  while ((failedFuncs & funcIdx) == 0)

	mov	edx, DWORD PTR _failedFuncs$[ebp]
	and	edx, DWORD PTR _funcIdx$[ebp]
	jne	SHORT $LN8@PNUpdateFA

; 201  : 		  {
; 202  : 			  mFaultFunc ++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], ecx

; 203  : 			  funcIdx = funcIdx << 1;

	mov	eax, DWORD PTR _funcIdx$[ebp]
	shl	eax, 1
	mov	DWORD PTR _funcIdx$[ebp], eax

; 204  : 		  }

	jmp	SHORT $LN2@PNUpdateFA
$LN8@PNUpdateFA:

; 205  :       }
; 206  : 
; 207  : 		mFaultNum = faultIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _faultIdx$[ebp]
	mov	DWORD PTR [ecx+260], edx

; 208  :       mFaultFunc ++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], ecx
$LN13@PNUpdateFA:

; 209  : 	}
; 210  : 
; 211  : 	mUpdateFlags |= FACK_UPDATE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN27@PNUpdateFA:

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PNUpdateFACKMode@ICPClass@@QAEXHH@Z ENDP		; ICPClass::PNUpdateFACKMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\icp\icpfack.cpp
_TEXT	SEGMENT
_faultNames$1 = -24					; size = 12
_faultCount$2 = -12					; size = 4
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?ExecFACKMode@ICPClass@@QAEXXZ PROC			; ICPClass::ExecFACKMode
; _this$ = ecx

; 10   : void ICPClass::ExecFACKMode(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 11   : 	
; 12   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 13   : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN10@ExecFACKMo

; 14   : 	{
; 15   : 		//MI original Code
; 16   : 
; 17   : 	   FaultClass::str_FNames	faultNames;
; 18   : 		int			faultCount;
; 19   : 
; 20   : 		if(!playerAC) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN9@ExecFACKMo

; 21   : 			return;

	jmp	$LN11@ExecFACKMo
$LN9@ExecFACKMo:

; 22   : 		}
; 23   : 
; 24   : 		faultCount	= playerAC->mFaults->GetFFaultCount();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFFaultCount@FackClass@@QAEHXZ	; FackClass::GetFFaultCount
	mov	DWORD PTR _faultCount$2[ebp], eax

; 25   : 
; 26   : 		if(mUpdateFlags & FACK_UPDATE || (!(mUpdateFlags & FACK_UPDATE) && faultCount)) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 64					; 00000040H
	jne	SHORT $LN7@ExecFACKMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 64					; 00000040H
	jne	$LN8@ExecFACKMo
	cmp	DWORD PTR _faultCount$2[ebp], 0
	je	$LN8@ExecFACKMo
$LN7@ExecFACKMo:

; 27   : 
; 28   : 			mUpdateFlags &= !FACK_UPDATE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 29   : 
; 30   : 			if(!faultCount) {

	cmp	DWORD PTR _faultCount$2[ebp], 0
	jne	SHORT $LN6@ExecFACKMo

; 31   : 
; 32   : 				sprintf(mpLine1, "      NO FAULTS");

	push	OFFSET ??_C@_0BA@CMOKLJJH@?5?5?5?5?5?5NO?5FAULTS?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	call	_sprintf
	add	esp, 8

; 33   : 				sprintf(mpLine2, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	call	_sprintf
	add	esp, 8

; 34   : 				sprintf(mpLine3, "      ALL SYS OK");

	push	OFFSET ??_C@_0BB@DNIEMOMJ@?5?5?5?5?5?5ALL?5SYS?5OK?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 156				; 0000009cH
	push	edx
	call	_sprintf
	add	esp, 8

; 35   : 			}
; 36   : 			else {

	jmp	SHORT $LN8@ExecFACKMo
$LN6@ExecFACKMo:

; 37   : 
; 38   : 				playerAC->mFaults->GetFaultNames((FaultClass::type_FSubSystem)mFaultNum, mFaultFunc, &faultNames);

	lea	eax, DWORD PTR _faultNames$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFaultNames@FackClass@@QAEXW4type_FSubSystem@FaultClass@@HPAUstr_FNames@3@@Z ; FackClass::GetFaultNames

; 39   : 
; 40   : 				sprintf(mpLine1, "        FAULT");

	push	OFFSET ??_C@_0O@NCICLAGP@?5?5?5?5?5?5?5?5FAULT?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	call	_sprintf
	add	esp, 8

; 41   : 				sprintf(mpLine2, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	call	_sprintf
	add	esp, 8

; 42   : 				sprintf(mpLine3, "   %4s %4s %4s", faultNames.elpFSubSystemNames,
; 43   : 															faultNames.elpFFunctionNames,
; 44   : 															faultNames.elpFSeverityNames);

	mov	edx, DWORD PTR _faultNames$1[ebp+8]
	push	edx
	mov	eax, DWORD PTR _faultNames$1[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _faultNames$1[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@EIAMFMII@?5?5?5?$CF4s?5?$CF4s?5?$CF4s?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 156				; 0000009cH
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H
$LN8@ExecFACKMo:

; 45   : 			}
; 46   : 		}
; 47   : 	}
; 48   : 	else

	jmp	SHORT $LN11@ExecFACKMo
$LN10@ExecFACKMo:

; 49   : 	{
; 50   : 		if(!playerAC) 

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@ExecFACKMo

; 51   : 		{
; 52   : 			return;

	jmp	SHORT $LN11@ExecFACKMo
$LN3@ExecFACKMo:

; 53   : 		}
; 54   : 
; 55   : 		if(playerAC->mFaults->GetFFaultCount() <= 0)

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFFaultCount@FackClass@@QAEHXZ	; FackClass::GetFFaultCount
	test	eax, eax
	jg	SHORT $LN2@ExecFACKMo

; 56   : 		{
; 57   : 		    PflNoFaults();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PflNoFaults@ICPClass@@QAEXXZ		; ICPClass::PflNoFaults

; 58   : 		}
; 59   : 		else 

	jmp	SHORT $LN11@ExecFACKMo
$LN2@ExecFACKMo:

; 60   : 		{
; 61   : 		    PflFault((FaultClass::type_FSubSystem)mFaultNum, (FaultClass::type_FFunction)mFaultFunc);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PflFault@ICPClass@@QAEXW4type_FSubSystem@FaultClass@@H@Z ; ICPClass::PflFault
$LN11@ExecFACKMo:

; 62   : 		}
; 63   : 	}
; 64   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ExecFACKMode@ICPClass@@QAEXXZ ENDP			; ICPClass::ExecFACKMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?GetFirstFault@FackClass@@QAEHPAW4type_FSubSystem@FaultClass@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystemp$ = 8					; size = 4
_functionp$ = 12					; size = 4
?GetFirstFault@FackClass@@QAEHPAW4type_FSubSystem@FaultClass@@PAH@Z PROC ; FackClass::GetFirstFault, COMDAT
; _this$ = ecx

; 66   :     { return mFaults.GetFirstFault(subsystemp, functionp); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _functionp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _subsystemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetFirstFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z ; FaultClass::GetFirstFault
	mov	esp, ebp
	pop	ebp
	ret	8
?GetFirstFault@FackClass@@QAEHPAW4type_FSubSystem@FaultClass@@PAH@Z ENDP ; FackClass::GetFirstFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?GetFFaultCount@FackClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFFaultCount@FackClass@@QAEHXZ PROC			; FackClass::GetFFaultCount, COMDAT
; _this$ = ecx

; 47   :     int		GetFFaultCount(void) {return mFaults.GetFaultCount();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetFaultCount@FaultClass@@QAEHXZ	; FaultClass::GetFaultCount
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFFaultCount@FackClass@@QAEHXZ ENDP			; FackClass::GetFFaultCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fault.h
;	COMDAT ?GetFaultCount@FaultClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFaultCount@FaultClass@@QAEHXZ PROC			; FaultClass::GetFaultCount, COMDAT
; _this$ = ecx

; 180  :        int	GetFaultCount(void) {return mFaultCount;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+256]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFaultCount@FaultClass@@QAEHXZ ENDP			; FaultClass::GetFaultCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
