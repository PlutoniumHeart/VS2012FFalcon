; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\ICP\IcpCNISwitch.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?CNISwitch@ICPClass@@QAEXH@Z			; ICPClass::CNISwitch
PUBLIC	?SetICPFlag@ICPClass@@QAEXH@Z			; ICPClass::SetICPFlag
PUBLIC	?ClearICPFlag@ICPClass@@QAEXH@Z			; ICPClass::ClearICPFlag
PUBLIC	?IsICPSet@ICPClass@@QAEHH@Z			; ICPClass::IsICPSet
EXTRN	_memset:PROC
EXTRN	?StepCruise@ICPClass@@QAEXXZ:PROC		; ICPClass::StepCruise
EXTRN	?ClearStrings@ICPClass@@QAEXXZ:PROC		; ICPClass::ClearStrings
EXTRN	?ClearDigits@ICPClass@@QAEXXZ:PROC		; ICPClass::ClearDigits
EXTRN	?ChangeToCNI@ICPClass@@QAEXXZ:PROC		; ICPClass::ChangeToCNI
EXTRN	?ToggleDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::ToggleDomain
EXTRN	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ:PROC ; NavigationSystem::GetControlSrc
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?IsICPSet@ICPClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsICPSet@ICPClass@@QAEHH@Z PROC			; ICPClass::IsICPSet, COMDAT
; _this$ = ecx

; 499  : 	int IsICPSet (int testFlag) {return ICPModeFlags & testFlag ? 1 : 0;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1376]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsICPSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsICPSet
$LN3@IsICPSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsICPSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsICPSet@ICPClass@@QAEHH@Z ENDP			; ICPClass::IsICPSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?ClearICPFlag@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearICPFlag@ICPClass@@QAEXH@Z PROC			; ICPClass::ClearICPFlag, COMDAT
; _this$ = ecx

; 498  : 	void ClearICPFlag (int newFlag) {ICPModeFlags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1376]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1376], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearICPFlag@ICPClass@@QAEXH@Z ENDP			; ICPClass::ClearICPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?SetICPFlag@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetICPFlag@ICPClass@@QAEXH@Z PROC			; ICPClass::SetICPFlag, COMDAT
; _this$ = ecx

; 497  : 	void SetICPFlag (int newFlag) {ICPModeFlags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1376]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1376], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetICPFlag@ICPClass@@QAEXH@Z ENDP			; ICPClass::SetICPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\icp\icpcniswitch.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 4
?CNISwitch@ICPClass@@QAEXH@Z PROC			; ICPClass::CNISwitch
; _this$ = ecx

; 8    : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9    : 	if(mode == UP_MODE)

	cmp	DWORD PTR _mode$[ebp], 28		; 0000001cH
	jne	$LN184@CNISwitch

; 10   : 	{
; 11   : 		ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 12   : 
; 13   : 		//CNI Page
; 14   : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == NONE_MODE)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN183@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN183@CNISwitch

; 15   : 		{
; 16   : 			if(gNavigationSys->GetControlSrc() == NavigationSystem::AUXCOMM)

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ ; NavigationSystem::GetControlSrc
	cmp	eax, 1
	jne	SHORT $LN182@CNISwitch

; 17   : 			{
; 18   : 				ClearICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 19   : 				ClearICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 20   : 				//Backup mode
; 21   : 				return;

	jmp	$LN185@CNISwitch

; 22   : 			}
; 23   : 			else

	jmp	$LN183@CNISwitch
$LN182@CNISwitch:

; 24   : 			{
; 25   : 				// MD -- 20040204: actually the UHF entry is always on line one
; 26   : 				//if(WhichRadio == 0)	//COMM1 is active
; 27   : 				//{
; 28   : 					if(IsICPSet(ICPClass::EDIT_STPT))

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN180@CNISwitch

; 29   : 					{
; 30   : 						ClearICPFlag(ICPClass::EDIT_STPT);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 31   : 						SetICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN183@CNISwitch
$LN180@CNISwitch:

; 32   : 					}
; 33   : 					else if(IsICPSet(ICPClass::EDIT_VHF))

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN178@CNISwitch

; 34   : 					{
; 35   : 						ClearICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 36   : 						SetICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN183@CNISwitch
$LN178@CNISwitch:

; 37   : 					}
; 38   : 					else if(IsICPSet(ICPClass::EDIT_UHF))

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN183@CNISwitch

; 39   : 					{
; 40   : 						ClearICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 41   : 						SetICPFlag(ICPClass::EDIT_STPT);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN183@CNISwitch:

; 42   : 					}
; 43   : 				//}
; 44   : 				//else	//COMM2 is active
; 45   : 				//{
; 46   : 				//	if(IsICPSet(ICPClass::EDIT_STPT))
; 47   : 				//	{
; 48   : 				//		ClearICPFlag(ICPClass::EDIT_STPT);
; 49   : 				//		SetICPFlag(ICPClass::EDIT_UHF);
; 50   : 				//	}
; 51   : 				//	else if(IsICPSet(ICPClass::EDIT_UHF))
; 52   : 				//	{
; 53   : 				//		ClearICPFlag(ICPClass::EDIT_UHF);
; 54   : 				//		SetICPFlag(ICPClass::EDIT_VHF);
; 55   : 				//	}
; 56   : 				//	else if(IsICPSet(ICPClass::EDIT_VHF))
; 57   : 				//	{
; 58   : 				//		ClearICPFlag(ICPClass::EDIT_VHF);
; 59   : 				//		SetICPFlag(ICPClass::EDIT_STPT);
; 60   : 				//	}
; 61   : 				//}
; 62   : 			}
; 63   : 		}
; 64   : 		//ILS
; 65   : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == ONE_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN175@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 4
	jne	SHORT $LN175@CNISwitch

; 66   : 		{
; 67   : 			if(ILSPageSel == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+296], 0
	jne	SHORT $LN174@CNISwitch

; 68   : 				ILSPageSel = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+296], 1

; 69   : 			else

	jmp	SHORT $LN175@CNISwitch
$LN174@CNISwitch:

; 70   : 				ILSPageSel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0
$LN175@CNISwitch:

; 71   : 		}
; 72   : 		//ALOW
; 73   : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == TWO_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN172@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 9
	jne	SHORT $LN172@CNISwitch

; 74   : 		{
; 75   : 			if(!EDITMSLFLOOR && !TFADV)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1528]
	test	ecx, ecx
	jne	SHORT $LN171@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1529]
	test	eax, eax
	jne	SHORT $LN171@CNISwitch

; 76   : 				TFADV = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1529], 1
	jmp	SHORT $LN170@CNISwitch
$LN171@CNISwitch:

; 77   : 			else if(TFADV)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1529]
	test	eax, eax
	je	SHORT $LN169@CNISwitch

; 78   : 			{
; 79   : 				TFADV = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1529], 0

; 80   : 				EDITMSLFLOOR = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1528], 1

; 81   : 			}
; 82   : 			else

	jmp	SHORT $LN170@CNISwitch
$LN169@CNISwitch:

; 83   : 				EDITMSLFLOOR = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1528], 0
$LN170@CNISwitch:
	jmp	$LN167@CNISwitch
$LN172@CNISwitch:

; 84   : 		}
; 85   : 		//DEST
; 86   : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == ONE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN166@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 4
	jne	$LN166@CNISwitch

; 87   : 		{
; 88   : 			if((IsICPSet(ICPClass::EDIT_LAT) || IsICPSet(ICPClass::EDIT_LONG)) && Manual_Input)

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	jne	SHORT $LN164@CNISwitch
	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN165@CNISwitch
$LN164@CNISwitch:
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+732]
	test	eax, eax
	je	SHORT $LN165@CNISwitch

; 89   : 				return;

	jmp	$LN185@CNISwitch
$LN165@CNISwitch:

; 90   : 
; 91   : 			if(OA1 ||OA2)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+429]
	test	edx, edx
	jne	SHORT $LN162@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+430]
	test	ecx, ecx
	je	$LN163@CNISwitch
$LN162@CNISwitch:

; 92   : 			{
; 93   : 				if(Manual_Input)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+732]
	test	eax, eax
	je	SHORT $LN161@CNISwitch

; 94   : 					return;

	jmp	$LN185@CNISwitch
$LN161@CNISwitch:

; 95   : 
; 96   : 				ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 97   : 				InputsMade = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+744], 0

; 98   : 				if(OA_RNG)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+668]
	test	eax, eax
	je	SHORT $LN160@CNISwitch

; 99   : 				{
; 100  : 					OA_RNG = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+668], 0

; 101  : 					OA_ALT = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+670], 1
	jmp	SHORT $LN159@CNISwitch
$LN160@CNISwitch:

; 102  : 				}
; 103  : 				else if(OA_BRG)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+669]
	test	ecx, ecx
	je	SHORT $LN158@CNISwitch

; 104  : 				{
; 105  : 					OA_BRG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+669], 0

; 106  : 					OA_RNG = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+668], 1
	jmp	SHORT $LN159@CNISwitch
$LN158@CNISwitch:

; 107  : 				}
; 108  : 				else if(OA_ALT)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+670]
	test	edx, edx
	je	SHORT $LN159@CNISwitch

; 109  : 				{
; 110  : 					OA_ALT = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+670], 0

; 111  : 					OA_BRG = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+669], 1
$LN159@CNISwitch:

; 112  : 				}
; 113  : 			}

	jmp	SHORT $LN155@CNISwitch
$LN163@CNISwitch:

; 114  : 			else if(IsICPSet(ICPClass::EDIT_LAT))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN154@CNISwitch

; 115  : 			{ 
; 116  : 				ClearICPFlag(ICPClass::EDIT_LAT);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 117  : 				SetICPFlag(ICPClass::EDIT_LONG);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 118  : 			} 
; 119  : 			else

	jmp	SHORT $LN155@CNISwitch
$LN154@CNISwitch:

; 120  : 			{ 
; 121  : 				ClearICPFlag(ICPClass::EDIT_LONG);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 122  : 				SetICPFlag(ICPClass::EDIT_LAT);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN155@CNISwitch:

; 123  : 			} 

	jmp	$LN167@CNISwitch
$LN166@CNISwitch:

; 124  : 		}
; 125  : 		//VIP
; 126  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == THREE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN151@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 22			; 00000016H
	jne	$LN151@CNISwitch

; 127  : 		{
; 128  : 			if(Manual_Input)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+732]
	test	ecx, ecx
	je	SHORT $LN150@CNISwitch

; 129  : 				return;

	jmp	$LN185@CNISwitch
$LN150@CNISwitch:

; 130  : 
; 131  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 132  : 			InputsMade = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], 0

; 133  : 			if(VIP_BRG)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+697]
	test	ecx, ecx
	je	SHORT $LN149@CNISwitch

; 134  : 			{
; 135  : 				VIP_BRG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+697], 0

; 136  : 				VIP_ALT = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+698], 1
	jmp	SHORT $LN148@CNISwitch
$LN149@CNISwitch:

; 137  : 			}
; 138  : 			else if(VIP_RNG)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+696]
	test	edx, edx
	je	SHORT $LN147@CNISwitch

; 139  : 			{
; 140  : 				VIP_RNG = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+696], 0

; 141  : 				VIP_BRG = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+697], 1
	jmp	SHORT $LN148@CNISwitch
$LN147@CNISwitch:

; 142  : 			}
; 143  : 			else if(VIP_ALT)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+698]
	test	eax, eax
	je	SHORT $LN148@CNISwitch

; 144  : 			{
; 145  : 				VIP_ALT = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+698], 0

; 146  : 				VIP_RNG = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+696], 1
$LN148@CNISwitch:

; 147  : 			}
; 148  : 		}

	jmp	$LN167@CNISwitch
$LN151@CNISwitch:

; 149  : 		//VRP
; 150  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == NINE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN143@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 25			; 00000019H
	jne	$LN143@CNISwitch

; 151  : 		{
; 152  : 			if(Manual_Input)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+732]
	test	edx, edx
	je	SHORT $LN142@CNISwitch

; 153  : 				return;

	jmp	$LN185@CNISwitch
$LN142@CNISwitch:

; 154  : 
; 155  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 156  : 			InputsMade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+744], 0

; 157  : 			if(VRP_BRG)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+713]
	test	edx, edx
	je	SHORT $LN141@CNISwitch

; 158  : 			{
; 159  : 				VRP_BRG = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+713], 0

; 160  : 				VRP_ALT = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+714], 1
	jmp	SHORT $LN140@CNISwitch
$LN141@CNISwitch:

; 161  : 			}
; 162  : 			else if(VRP_RNG)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+712]
	test	eax, eax
	je	SHORT $LN139@CNISwitch

; 163  : 			{
; 164  : 				VRP_RNG = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+712], 0

; 165  : 				VRP_BRG = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+713], 1
	jmp	SHORT $LN140@CNISwitch
$LN139@CNISwitch:

; 166  : 			}
; 167  : 			else if(VRP_ALT)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+714]
	test	ecx, ecx
	je	SHORT $LN140@CNISwitch

; 168  : 			{
; 169  : 				VRP_ALT = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+714], 0

; 170  : 				VRP_RNG = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+712], 1
$LN140@CNISwitch:

; 171  : 			}
; 172  : 		}

	jmp	$LN167@CNISwitch
$LN143@CNISwitch:

; 173  : 		//EWS
; 174  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == EWS_MODE)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN135@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 55			; 00000037H
	jne	$LN135@CNISwitch

; 175  : 		{
; 176  : 			if(EWSMain)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+480]
	test	eax, eax
	je	$LN134@CNISwitch

; 177  : 			{
; 178  : 				if(Manual_Input)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+732]
	test	edx, edx
	je	SHORT $LN133@CNISwitch

; 179  : 					return;

	jmp	$LN185@CNISwitch
$LN133@CNISwitch:

; 180  : 
; 181  : 				if(IsICPSet(ICPClass::CHAFF_BINGO))

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN132@CNISwitch

; 182  : 				{
; 183  : 					ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 184  : 					ClearICPFlag(ICPClass::CHAFF_BINGO);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 185  : 					SetICPFlag(ICPClass::EWS_EDIT_BINGO);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	$LN131@CNISwitch
$LN132@CNISwitch:

; 186  : 				}
; 187  : 				else if(IsICPSet(ICPClass::FLARE_BINGO))

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN130@CNISwitch

; 188  : 				{
; 189  : 					ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 190  : 					ClearICPFlag(ICPClass::FLARE_BINGO);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 191  : 					SetICPFlag(ICPClass::CHAFF_BINGO);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN131@CNISwitch
$LN130@CNISwitch:

; 192  : 					
; 193  : 				}
; 194  : 				else if(IsICPSet(ICPClass::EDIT_JAMMER))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN128@CNISwitch

; 195  : 				{
; 196  : 					ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 197  : 					ClearICPFlag(ICPClass::EDIT_JAMMER);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 198  : 					SetICPFlag(ICPClass::FLARE_BINGO);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 199  : 				}
; 200  : 				else

	jmp	SHORT $LN131@CNISwitch
$LN128@CNISwitch:

; 201  : 				{
; 202  : 					ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 203  : 					ClearICPFlag(ICPClass::EWS_EDIT_BINGO);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 204  : 					SetICPFlag(ICPClass::EDIT_JAMMER);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN131@CNISwitch:

; 205  : 				}

	jmp	$LN126@CNISwitch
$LN134@CNISwitch:

; 206  : 			}
; 207  : 			else if(PGMChaff || PGMFlare)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+481]
	test	ecx, ecx
	jne	SHORT $LN124@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+482]
	test	eax, eax
	je	$LN126@CNISwitch
$LN124@CNISwitch:

; 208  : 			{
; 209  : 				if(Manual_Input)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+732]
	test	edx, edx
	je	SHORT $LN123@CNISwitch

; 210  : 					return;

	jmp	$LN185@CNISwitch
$LN123@CNISwitch:

; 211  : 
; 212  : 				ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 213  : 				InputsMade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+744], 0

; 214  : 				if(BQ)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+496]
	test	edx, edx
	je	SHORT $LN122@CNISwitch

; 215  : 				{
; 216  : 					BQ = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+496], 0

; 217  : 					SI = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+499], 1
	jmp	SHORT $LN126@CNISwitch
$LN122@CNISwitch:

; 218  : 				}
; 219  : 				else if(SI)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+499]
	test	eax, eax
	je	SHORT $LN120@CNISwitch

; 220  : 				{
; 221  : 					SI = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+499], 0

; 222  : 					SQ = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+498], 1
	jmp	SHORT $LN126@CNISwitch
$LN120@CNISwitch:

; 223  : 				}
; 224  : 				else if(SQ)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+498]
	test	ecx, ecx
	je	SHORT $LN118@CNISwitch

; 225  : 				{
; 226  : 					SQ = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+498], 0

; 227  : 					BI = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+497], 1

; 228  : 				}
; 229  : 				else

	jmp	SHORT $LN126@CNISwitch
$LN118@CNISwitch:

; 230  : 				{
; 231  : 					BI = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+497], 0

; 232  : 					BQ = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+496], 1
$LN126@CNISwitch:

; 233  : 				}
; 234  : 			}
; 235  : 		}

	jmp	$LN167@CNISwitch
$LN135@CNISwitch:

; 236  : 		//INS
; 237  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == SIX_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN115@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 23			; 00000017H
	jne	SHORT $LN115@CNISwitch

; 238  : 		{
; 239  : 			INSLine--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1560]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1560], edx

; 240  : 			if(INSLine < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1560], 0
	jge	SHORT $LN114@CNISwitch

; 241  : 				INSLine = 3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1560], 3
$LN114@CNISwitch:

; 242  : 		}

	jmp	SHORT $LN167@CNISwitch
$LN115@CNISwitch:

; 243  : 		//Laser
; 244  : 		else if(IsICPSet(ICPClass::MISC_MODE) && mICPSecondaryMode == FIFE_BUTTON)

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN167@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 5
	jne	SHORT $LN167@CNISwitch

; 245  : 		{
; 246  : 			if(LaserLine == 1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1660], 1
	jne	SHORT $LN111@CNISwitch

; 247  : 				LaserLine = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1660], 2

; 248  : 			else

	jmp	SHORT $LN167@CNISwitch
$LN111@CNISwitch:

; 249  : 				LaserLine = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1660], 1
$LN167@CNISwitch:

; 250  : 		}
; 251  : 	}

	jmp	$LN185@CNISwitch
$LN184@CNISwitch:

; 252  : 	else if(mode == DOWN_MODE)

	cmp	DWORD PTR _mode$[ebp], 29		; 0000001dH
	jne	$LN108@CNISwitch

; 253  : 	{
; 254  : 		ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 255  : 
; 256  : 		//CNI Page
; 257  : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == NONE_MODE)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN107@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$LN107@CNISwitch

; 258  : 		{
; 259  : 			if(gNavigationSys->GetControlSrc() == NavigationSystem::AUXCOMM)

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ ; NavigationSystem::GetControlSrc
	cmp	eax, 1
	jne	SHORT $LN106@CNISwitch

; 260  : 			{
; 261  : 				ClearICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 262  : 				ClearICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 263  : 				//Backup mode
; 264  : 				return;

	jmp	$LN185@CNISwitch

; 265  : 			}
; 266  : 			else

	jmp	$LN107@CNISwitch
$LN106@CNISwitch:

; 267  : 			{
; 268  : 				// MD -- 20040204: actually the UHF entry is always on line one
; 269  : 				//if(WhichRadio == 0)	//COMM1 active
; 270  : 				//{
; 271  : 					if(IsICPSet(ICPClass::EDIT_STPT))

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN104@CNISwitch

; 272  : 					{
; 273  : 						ClearICPFlag(ICPClass::EDIT_STPT);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 274  : 						SetICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN107@CNISwitch
$LN104@CNISwitch:

; 275  : 					}
; 276  : 					else if(IsICPSet(ICPClass::EDIT_UHF))

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN102@CNISwitch

; 277  : 					{
; 278  : 						ClearICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 279  : 						SetICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN107@CNISwitch
$LN102@CNISwitch:

; 280  : 					}
; 281  : 					else if(IsICPSet(ICPClass::EDIT_VHF))

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN107@CNISwitch

; 282  : 					{
; 283  : 						ClearICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 284  : 						SetICPFlag(ICPClass::EDIT_STPT);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN107@CNISwitch:

; 285  : 					}
; 286  : 				//}
; 287  : 				//else	//COMM2 active
; 288  : 				//{
; 289  : 				//	if(IsICPSet(ICPClass::EDIT_STPT))
; 290  : 				//	{
; 291  : 				//		ClearICPFlag(ICPClass::EDIT_STPT);
; 292  : 				//		SetICPFlag(ICPClass::EDIT_VHF);
; 293  : 				//	}
; 294  : 				//	else if(IsICPSet(ICPClass::EDIT_VHF))
; 295  : 				//	{
; 296  : 				//		ClearICPFlag(ICPClass::EDIT_VHF);
; 297  : 				//		SetICPFlag(ICPClass::EDIT_UHF);
; 298  : 				//	}
; 299  : 				//	else if(IsICPSet(ICPClass::EDIT_UHF))
; 300  : 				//	{
; 301  : 				//		ClearICPFlag(ICPClass::EDIT_UHF);
; 302  : 				//		SetICPFlag(ICPClass::EDIT_STPT);
; 303  : 				//	}
; 304  : 				//}
; 305  : 			}
; 306  : 		}
; 307  : 		//ILS
; 308  : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == ONE_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN99@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 4
	jne	SHORT $LN99@CNISwitch

; 309  : 		{
; 310  : 			if(ILSPageSel == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+296], 0
	jne	SHORT $LN98@CNISwitch

; 311  : 				ILSPageSel = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 1

; 312  : 			else

	jmp	SHORT $LN99@CNISwitch
$LN98@CNISwitch:

; 313  : 				ILSPageSel = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+296], 0
$LN99@CNISwitch:

; 314  : 		}
; 315  : 		//ALOW
; 316  : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == TWO_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN96@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 9
	jne	SHORT $LN96@CNISwitch

; 317  : 		{
; 318  : 			if(!EDITMSLFLOOR && !TFADV)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1528]
	test	edx, edx
	jne	SHORT $LN95@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1529]
	test	ecx, ecx
	jne	SHORT $LN95@CNISwitch

; 319  : 				EDITMSLFLOOR = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1528], 1
	jmp	SHORT $LN94@CNISwitch
$LN95@CNISwitch:

; 320  : 			else if(EDITMSLFLOOR)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1528]
	test	ecx, ecx
	je	SHORT $LN93@CNISwitch

; 321  : 			{
; 322  : 				TFADV = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1529], 1

; 323  : 				EDITMSLFLOOR = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1528], 0

; 324  : 			}
; 325  : 			else

	jmp	SHORT $LN94@CNISwitch
$LN93@CNISwitch:

; 326  : 				TFADV = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1529], 0
$LN94@CNISwitch:
	jmp	$LN91@CNISwitch
$LN96@CNISwitch:

; 327  : 		}
; 328  : 		//DEST
; 329  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == ONE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN90@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 4
	jne	$LN90@CNISwitch

; 330  : 		{
; 331  : 			if((IsICPSet(ICPClass::EDIT_LAT) || IsICPSet(ICPClass::EDIT_LONG)) && Manual_Input)

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	jne	SHORT $LN88@CNISwitch
	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN89@CNISwitch
$LN88@CNISwitch:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+732]
	test	ecx, ecx
	je	SHORT $LN89@CNISwitch

; 332  : 				return;

	jmp	$LN185@CNISwitch
$LN89@CNISwitch:

; 333  : 
; 334  : 			if(OA1 || OA2)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+429]
	test	eax, eax
	jne	SHORT $LN86@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+430]
	test	edx, edx
	je	$LN87@CNISwitch
$LN86@CNISwitch:

; 335  : 			{
; 336  : 				if(Manual_Input)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+732]
	test	ecx, ecx
	je	SHORT $LN85@CNISwitch

; 337  : 					return;

	jmp	$LN185@CNISwitch
$LN85@CNISwitch:

; 338  : 
; 339  : 				ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 340  : 				InputsMade = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], 0

; 341  : 				if(OA_RNG)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+668]
	test	ecx, ecx
	je	SHORT $LN84@CNISwitch

; 342  : 				{
; 343  : 					OA_RNG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+668], 0

; 344  : 					OA_BRG = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+669], 1
	jmp	SHORT $LN83@CNISwitch
$LN84@CNISwitch:

; 345  : 				}
; 346  : 				else if(OA_BRG)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+669]
	test	edx, edx
	je	SHORT $LN82@CNISwitch

; 347  : 				{
; 348  : 					OA_BRG = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+669], 0

; 349  : 					OA_ALT = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+670], 1
	jmp	SHORT $LN83@CNISwitch
$LN82@CNISwitch:

; 350  : 				}
; 351  : 				else if(OA_ALT)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+670]
	test	eax, eax
	je	SHORT $LN83@CNISwitch

; 352  : 				{
; 353  : 					OA_ALT = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+670], 0

; 354  : 					OA_RNG = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+668], 1
$LN83@CNISwitch:

; 355  : 				}
; 356  : 			}

	jmp	SHORT $LN79@CNISwitch
$LN87@CNISwitch:

; 357  : 			else if(IsICPSet(ICPClass::EDIT_LAT))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN78@CNISwitch

; 358  : 			{ 
; 359  : 				ClearICPFlag(ICPClass::EDIT_LAT);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 360  : 				SetICPFlag(ICPClass::EDIT_LONG);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 361  : 			} 
; 362  : 			else

	jmp	SHORT $LN79@CNISwitch
$LN78@CNISwitch:

; 363  : 			{ 
; 364  : 				ClearICPFlag(ICPClass::EDIT_LONG);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 365  : 				SetICPFlag(ICPClass::EDIT_LAT);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN79@CNISwitch:

; 366  : 			}

	jmp	$LN91@CNISwitch
$LN90@CNISwitch:

; 367  : 		}
; 368  : 		//VIP
; 369  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == THREE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN75@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 22			; 00000016H
	jne	$LN75@CNISwitch

; 370  : 		{
; 371  : 			if(Manual_Input)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+732]
	test	edx, edx
	je	SHORT $LN74@CNISwitch

; 372  : 				return;

	jmp	$LN185@CNISwitch
$LN74@CNISwitch:

; 373  : 
; 374  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 375  : 			InputsMade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+744], 0

; 376  : 			if(VIP_BRG)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+697]
	test	edx, edx
	je	SHORT $LN73@CNISwitch

; 377  : 			{
; 378  : 				VIP_BRG = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+697], 0

; 379  : 				VIP_RNG = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+696], 1
	jmp	SHORT $LN72@CNISwitch
$LN73@CNISwitch:

; 380  : 			}
; 381  : 			else if(VIP_RNG)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+696]
	test	eax, eax
	je	SHORT $LN71@CNISwitch

; 382  : 			{
; 383  : 				VIP_RNG = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+696], 0

; 384  : 				VIP_ALT = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+698], 1
	jmp	SHORT $LN72@CNISwitch
$LN71@CNISwitch:

; 385  : 			}
; 386  : 			else if(VIP_ALT)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+698]
	test	ecx, ecx
	je	SHORT $LN72@CNISwitch

; 387  : 			{
; 388  : 				VIP_ALT = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+698], 0

; 389  : 				VIP_BRG = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+697], 1
$LN72@CNISwitch:

; 390  : 			}
; 391  : 		}

	jmp	$LN91@CNISwitch
$LN75@CNISwitch:

; 392  : 		//VRP
; 393  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == NINE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN67@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 25			; 00000019H
	jne	$LN67@CNISwitch

; 394  : 		{
; 395  : 			if(Manual_Input)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+732]
	test	eax, eax
	je	SHORT $LN66@CNISwitch

; 396  : 				return;

	jmp	$LN185@CNISwitch
$LN66@CNISwitch:

; 397  : 
; 398  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 399  : 			InputsMade = 0;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+744], 0

; 400  : 			if(VRP_BRG)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+713]
	test	eax, eax
	je	SHORT $LN65@CNISwitch

; 401  : 			{
; 402  : 				VRP_BRG = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+713], 0

; 403  : 				VRP_RNG = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+712], 1
	jmp	SHORT $LN64@CNISwitch
$LN65@CNISwitch:

; 404  : 			}
; 405  : 			else if(VRP_RNG)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+712]
	test	ecx, ecx
	je	SHORT $LN63@CNISwitch

; 406  : 			{
; 407  : 				VRP_RNG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+712], 0

; 408  : 				VRP_ALT = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+714], 1
	jmp	SHORT $LN64@CNISwitch
$LN63@CNISwitch:

; 409  : 			}
; 410  : 			else if(VRP_ALT)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+714]
	test	edx, edx
	je	SHORT $LN64@CNISwitch

; 411  : 			{
; 412  : 				VRP_ALT = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+714], 0

; 413  : 				VRP_BRG = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+713], 1
$LN64@CNISwitch:

; 414  : 			}			
; 415  : 		}

	jmp	$LN91@CNISwitch
$LN67@CNISwitch:

; 416  : 		//EWS
; 417  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == EWS_MODE)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN59@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 55			; 00000037H
	jne	$LN59@CNISwitch

; 418  : 		{
; 419  : 			if(EWSMain)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+480]
	test	ecx, ecx
	je	$LN58@CNISwitch

; 420  : 			{
; 421  : 				if(Manual_Input)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+732]
	test	eax, eax
	je	SHORT $LN57@CNISwitch

; 422  : 					return;

	jmp	$LN185@CNISwitch
$LN57@CNISwitch:

; 423  : 
; 424  : 				ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 425  : 				InputsMade = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+744], 0

; 426  : 				if(IsICPSet(ICPClass::CHAFF_BINGO))

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN56@CNISwitch

; 427  : 				{
; 428  : 					ClearICPFlag(ICPClass::CHAFF_BINGO);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 429  : 					SetICPFlag(ICPClass::FLARE_BINGO);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN55@CNISwitch
$LN56@CNISwitch:

; 430  : 				}
; 431  : 				else if(IsICPSet(ICPClass::FLARE_BINGO))

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN54@CNISwitch

; 432  : 				{
; 433  : 					ClearICPFlag(ICPClass::FLARE_BINGO);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 434  : 					SetICPFlag(ICPClass::EDIT_JAMMER);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
	jmp	SHORT $LN55@CNISwitch
$LN54@CNISwitch:

; 435  : 				}
; 436  : 				else if(IsICPSet(ICPClass::EDIT_JAMMER))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN52@CNISwitch

; 437  : 				{
; 438  : 					ClearICPFlag(ICPClass::EDIT_JAMMER);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 439  : 					SetICPFlag(ICPClass::EWS_EDIT_BINGO);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 440  : 				}
; 441  : 				else

	jmp	SHORT $LN55@CNISwitch
$LN52@CNISwitch:

; 442  : 				{
; 443  : 					ClearICPFlag(ICPClass::EWS_EDIT_BINGO);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 444  : 					SetICPFlag(ICPClass::CHAFF_BINGO);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN55@CNISwitch:

; 445  : 				}

	jmp	$LN50@CNISwitch
$LN58@CNISwitch:

; 446  : 			}
; 447  : 			else if(PGMChaff || PGMFlare)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+481]
	test	eax, eax
	jne	SHORT $LN48@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+482]
	test	edx, edx
	je	$LN50@CNISwitch
$LN48@CNISwitch:

; 448  : 			{
; 449  : 				if(Manual_Input)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+732]
	test	ecx, ecx
	je	SHORT $LN47@CNISwitch

; 450  : 					return;

	jmp	$LN185@CNISwitch
$LN47@CNISwitch:

; 451  : 
; 452  : 				ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 453  : 				InputsMade = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], 0

; 454  : 				if(BQ)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+496]
	test	ecx, ecx
	je	SHORT $LN46@CNISwitch

; 455  : 				{
; 456  : 					BQ = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+496], 0

; 457  : 					BI = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+497], 1
	jmp	SHORT $LN50@CNISwitch
$LN46@CNISwitch:

; 458  : 				}
; 459  : 				else if(BI)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+497]
	test	edx, edx
	je	SHORT $LN44@CNISwitch

; 460  : 				{
; 461  : 					BI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+497], 0

; 462  : 					SQ = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+498], 1
	jmp	SHORT $LN50@CNISwitch
$LN44@CNISwitch:

; 463  : 				}
; 464  : 				else if(SQ)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+498]
	test	eax, eax
	je	SHORT $LN42@CNISwitch

; 465  : 				{
; 466  : 					SQ = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+498], 0

; 467  : 					SI = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+499], 1

; 468  : 				}
; 469  : 				else

	jmp	SHORT $LN50@CNISwitch
$LN42@CNISwitch:

; 470  : 				{
; 471  : 					SI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+499], 0

; 472  : 					BQ = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+496], 1
$LN50@CNISwitch:

; 473  : 				}
; 474  : 			}
; 475  : 		}

	jmp	$LN91@CNISwitch
$LN59@CNISwitch:

; 476  : 		//INS
; 477  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == SIX_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN39@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 23			; 00000017H
	jne	SHORT $LN39@CNISwitch

; 478  : 		{
; 479  : 			INSLine++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1560]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1560], ecx

; 480  : 			if(INSLine > 3)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1560], 3
	jle	SHORT $LN38@CNISwitch

; 481  : 				INSLine = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1560], 0
$LN38@CNISwitch:

; 482  : 		}

	jmp	SHORT $LN91@CNISwitch
$LN39@CNISwitch:

; 483  : 		//Laser
; 484  : 		else if(IsICPSet(ICPClass::MISC_MODE) && mICPSecondaryMode == FIFE_BUTTON)

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN91@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 5
	jne	SHORT $LN91@CNISwitch

; 485  : 		{
; 486  : 			if(LaserLine == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1660], 1
	jne	SHORT $LN35@CNISwitch

; 487  : 				LaserLine = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1660], 2

; 488  : 			else

	jmp	SHORT $LN91@CNISwitch
$LN35@CNISwitch:

; 489  : 				LaserLine = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1660], 1
$LN91@CNISwitch:

; 490  : 		}
; 491  : 	}

	jmp	$LN185@CNISwitch
$LN108@CNISwitch:

; 492  : 	else if(mode == SEQ_MODE)

	cmp	DWORD PTR _mode$[ebp], 31		; 0000001fH
	jne	$LN32@CNISwitch

; 493  : 	{
; 494  : 		ClearDigits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearDigits@ICPClass@@QAEXXZ		; ICPClass::ClearDigits

; 495  : 
; 496  : 		if(!IsICPSet(ICPClass::MODE_FACK))

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	jne	SHORT $LN31@CNISwitch

; 497  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings
$LN31@CNISwitch:

; 498  : 
; 499  : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == NONE_MODE)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN30@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN30@CNISwitch

; 500  : 		{
; 501  : 			if(ShowWind == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+428]
	cmp	edx, 1
	jne	SHORT $LN29@CNISwitch

; 502  : 			{
; 503  : 				memset(DEDLines[1], ' ', MAX_DED_LEN - 1);

	push	25					; 00000019H
	push	32					; 00000020H
	mov	eax, 26					; 0000001aH
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+764]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 504  : 				ShowWind = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+428], 0

; 505  : 			}
; 506  : 			else

	jmp	SHORT $LN30@CNISwitch
$LN29@CNISwitch:

; 507  : 				ShowWind = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+428], 1
$LN30@CNISwitch:

; 508  : 		}
; 509  : 		if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == ONE_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN27@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 4
	jne	SHORT $LN27@CNISwitch

; 510  : 		{
; 511  : 			if(gNavigationSys->GetControlSrc() == NavigationSystem::AUXCOMM)

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ ; NavigationSystem::GetControlSrc
	cmp	eax, 1
	jne	SHORT $LN26@CNISwitch

; 512  : 			{
; 513  : 				ClearICPFlag(ICPClass::EDIT_STPT);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 514  : 				ClearICPFlag(ICPClass::EDIT_VHF);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 515  : 				ClearICPFlag(ICPClass::EDIT_UHF);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 516  : 				//Backup mode
; 517  : 				return;

	jmp	$LN185@CNISwitch

; 518  : 			}
; 519  : 			else

	jmp	SHORT $LN25@CNISwitch
$LN26@CNISwitch:

; 520  : 			{
; 521  : 				if(gNavigationSys)

	cmp	DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A, 0 ; gNavigationSys
	je	SHORT $LN25@CNISwitch

; 522  : 					gNavigationSys->ToggleDomain(NavigationSystem::ICP);

	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?ToggleDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::ToggleDomain
$LN25@CNISwitch:

; 523  : 			}

	jmp	$LN23@CNISwitch
$LN27@CNISwitch:

; 524  : 		}
; 525  : 		else if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == FOUR_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN22@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN22@CNISwitch

; 526  : 		{
; 527  : 			if(MAN)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+431]
	test	edx, edx
	je	SHORT $LN21@CNISwitch

; 528  : 				MAN = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+431], 0

; 529  : 			else

	jmp	SHORT $LN20@CNISwitch
$LN21@CNISwitch:

; 530  : 				MAN = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+431], 1
$LN20@CNISwitch:
	jmp	$LN23@CNISwitch
$LN22@CNISwitch:

; 531  : 		}
; 532  : 		else if(IsICPSet(ICPClass::MODE_CNI) && mICPSecondaryMode == FIFE_BUTTON)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN18@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 5
	jne	SHORT $LN18@CNISwitch

; 533  : 			StepCruise();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepCruise@ICPClass@@QAEXXZ		; ICPClass::StepCruise
	jmp	$LN23@CNISwitch
$LN18@CNISwitch:

; 534  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == ONE_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN16@CNISwitch
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 4
	jne	$LN16@CNISwitch

; 535  : 		{
; 536  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 537  : 			ClearCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1488], 0

; 538  : 			Manual_Input = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+732], 0

; 539  : 
; 540  : 			if(OA1)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+429]
	test	ecx, ecx
	je	SHORT $LN15@CNISwitch

; 541  : 			{
; 542  : 				OA1 = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+429], 0

; 543  : 				OA2 = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+430], 1

; 544  : 				OA_RNG = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+668], 1

; 545  : 				OA_BRG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+669], 0

; 546  : 				OA_ALT = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+670], 0
	jmp	$LN14@CNISwitch
$LN15@CNISwitch:

; 547  : 			}
; 548  : 			else if(OA2)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+430]
	test	edx, edx
	je	SHORT $LN13@CNISwitch

; 549  : 			{
; 550  : 				OA2 = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+430], 0

; 551  : 				OA_RNG = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+668], 0

; 552  : 				OA_BRG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+669], 0

; 553  : 				OA_ALT = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+670], 0

; 554  : 				SetICPFlag(ICPClass::EDIT_LAT);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 555  : 			}
; 556  : 			else

	jmp	SHORT $LN14@CNISwitch
$LN13@CNISwitch:

; 557  : 			{
; 558  : 				OA1 = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+429], 1

; 559  : 				OA_RNG = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+668], 1

; 560  : 				OA_BRG = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+669], 0

; 561  : 				OA_ALT = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+670], 0

; 562  : 				ClearICPFlag(ICPClass::EDIT_LAT);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 563  : 				ClearICPFlag(ICPClass::EDIT_LONG);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag
$LN14@CNISwitch:

; 564  : 			}

	jmp	$LN23@CNISwitch
$LN16@CNISwitch:

; 565  : 		}
; 566  : 		//EWS
; 567  : 		else if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == EWS_MODE)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN23@CNISwitch
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 55			; 00000037H
	jne	$LN23@CNISwitch

; 568  : 		{
; 569  : 			Manual_Input = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+732], 0

; 570  : 			ClearCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1488], 0

; 571  : 			InputsMade = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], 0

; 572  : 			ClearStrings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 573  : 			
; 574  : 			if(EWSMain)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+480]
	test	ecx, ecx
	je	SHORT $LN9@CNISwitch

; 575  : 			{
; 576  : 				EWSMain = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+480], 0

; 577  : 				PGMChaff = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+481], 1

; 578  : 				BQ = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+496], 1

; 579  : 				BI = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+497], 0

; 580  : 				SQ = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+498], 0

; 581  : 				SI = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+499], 0

; 582  : 				ClearICPFlag(ICPClass::CHAFF_BINGO);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 583  : 				ClearICPFlag(ICPClass::FLARE_BINGO);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 584  : 				ClearICPFlag(ICPClass::EDIT_JAMMER);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 585  : 				ClearICPFlag(ICPClass::EWS_EDIT_BINGO);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag
	jmp	$LN23@CNISwitch
$LN9@CNISwitch:

; 586  : 			}
; 587  : 			else if(PGMChaff)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+481]
	test	eax, eax
	je	SHORT $LN7@CNISwitch

; 588  : 			{
; 589  : 				PGMChaff = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+481], 0

; 590  : 				PGMFlare = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+482], 1

; 591  : 				BQ = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+496], 1

; 592  : 				BI = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+497], 0

; 593  : 				SQ = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+498], 0

; 594  : 				SI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+499], 0

; 595  : 			}
; 596  : 			else

	jmp	SHORT $LN23@CNISwitch
$LN7@CNISwitch:

; 597  : 			{
; 598  : 				PGMFlare = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+482], 0

; 599  : 				EWSMain = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+480], 1

; 600  : 				BQ = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+496], 0

; 601  : 				BI = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+497], 0

; 602  : 				SQ = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+498], 0

; 603  : 				SI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+499], 0

; 604  : 				SetICPFlag(ICPClass::CHAFF_BINGO);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag
$LN23@CNISwitch:

; 605  : 			}
; 606  : 		}
; 607  : 		if(IsICPSet(ICPClass::MODE_LIST) && mICPSecondaryMode == EIGHT_BUTTON)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN5@CNISwitch
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 24			; 00000018H
	jne	SHORT $LN5@CNISwitch

; 608  : 		{
; 609  : 			ClearCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1488], 0

; 610  : 			InputsMade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+744], 0

; 611  : 			if(IN_AA)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+729]
	test	edx, edx
	je	SHORT $LN4@CNISwitch

; 612  : 			{
; 613  : 				IN_AA = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+729], 0

; 614  : 				IN_AG = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+728], 1

; 615  : 			}
; 616  : 			else

	jmp	SHORT $LN5@CNISwitch
$LN4@CNISwitch:

; 617  : 			{
; 618  : 				IN_AG = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+728], 0

; 619  : 				IN_AA = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+729], 1
$LN5@CNISwitch:

; 620  : 			}
; 621  : 		}
; 622  : 	}

	jmp	SHORT $LN185@CNISwitch
$LN32@CNISwitch:

; 623  : 	else if(mode == CNI_MODE)

	cmp	DWORD PTR _mode$[ebp], 27		; 0000001bH
	jne	SHORT $LN185@CNISwitch

; 624  : 		ChangeToCNI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeToCNI@ICPClass@@QAEXXZ		; ICPClass::ChangeToCNI
$LN185@CNISwitch:

; 625  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CNISwitch@ICPClass@@QAEXH@Z ENDP			; ICPClass::CNISwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
