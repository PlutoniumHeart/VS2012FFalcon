; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\FCC\navfcc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	??_C@_03JKJFCLEN@FCR?$AA@			; `string'
PUBLIC	??_C@_03PHIAGONP@PRE?$AA@			; `string'
PUBLIC	??_C@_04GIGGHHFN@AIFF?$AA@			; `string'
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	??_C@_04GKDMIDBA@CNTL?$AA@			; `string'
PUBLIC	??_C@_05KIIDMJOE@LINE1?$AA@			; `string'
PUBLIC	??_C@_05IDKOJKCH@LINE2?$AA@			; `string'
PUBLIC	??_C@_05JKLFKLGG@LINE3?$AA@			; `string'
PUBLIC	??_C@_05NFPEDNKB@LINE4?$AA@			; `string'
PUBLIC	??_C@_05MFBAHHEE@RINGS?$AA@			; `string'
PUBLIC	??_C@_03DNAAPCJD@S?9J?$AA@			; `string'
PUBLIC	??_C@_03OONHJAKL@SMS?$AA@			; `string'
PUBLIC	??_C@_03HKPEEKNJ@HSD?$AA@			; `string'
PUBLIC	??_C@_04NLFHDAEB@SWAP?$AA@			; `string'
PUBLIC	??_C@_05JPABKIJN@ADLNK?$AA@			; `string'
PUBLIC	??_C@_05EJFIELIA@GDLNK?$AA@			; `string'
PUBLIC	??_C@_04GBOMOGKA@NAV3?$AA@			; `string'
PUBLIC	??_C@_04HIPHNHOB@NAV2?$AA@			; `string'
PUBLIC	??_C@_04FDNKIECC@NAV1?$AA@			; `string'
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A ; FireControlComputer::hsdcntlcfg
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?HsdRangeTbl@FireControlComputer@@0PAHA		; FireControlComputer::HsdRangeTbl
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
_DATA	SEGMENT
?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A DD FLAT:??_C@_03JKJFCLEN@FCR?$AA@ ; FireControlComputer::hsdcntlcfg
	DD	040H
	DD	FLAT:??_C@_03PHIAGONP@PRE?$AA@
	DD	080H
	DD	FLAT:??_C@_04GIGGHHFN@AIFF?$AA@
	DD	0100H
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	00H
	DD	FLAT:??_C@_04GKDMIDBA@CNTL?$AA@
	DD	010H
	DD	FLAT:??_C@_05KIIDMJOE@LINE1?$AA@
	DD	0200H
	DD	FLAT:??_C@_05IDKOJKCH@LINE2?$AA@
	DD	0400H
	DD	FLAT:??_C@_05JKLFKLGG@LINE3?$AA@
	DD	0800H
	DD	FLAT:??_C@_05NFPEDNKB@LINE4?$AA@
	DD	00H
	DD	FLAT:??_C@_05MFBAHHEE@RINGS?$AA@
	DD	02000H
	DD	FLAT:??_C@_03DNAAPCJD@S?9J?$AA@
	DD	00H
	DD	FLAT:??_C@_03OONHJAKL@SMS?$AA@
	DD	00H
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	00H
	DD	FLAT:??_C@_03HKPEEKNJ@HSD?$AA@
	DD	00H
	DD	FLAT:??_C@_04NLFHDAEB@SWAP?$AA@
	DD	00H
	DD	FLAT:??_C@_05JPABKIJN@ADLNK?$AA@
	DD	020000H
	DD	FLAT:??_C@_05EJFIELIA@GDLNK?$AA@
	DD	040000H
	DD	FLAT:??_C@_04GBOMOGKA@NAV3?$AA@
	DD	010000H
	DD	FLAT:??_C@_04HIPHNHOB@NAV2?$AA@
	DD	08000H
	DD	FLAT:??_C@_04FDNKIECC@NAV1?$AA@
	DD	04000H
?HsdRangeTbl@FireControlComputer@@0PAHA DD 0fH		; FireControlComputer::HsdRangeTbl
	DD	01eH
	DD	03cH
	DD	078H
	DD	0f0H
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ??_C@_04FDNKIECC@NAV1?$AA@
CONST	SEGMENT
??_C@_04FDNKIECC@NAV1?$AA@ DB 'NAV1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIPHNHOB@NAV2?$AA@
CONST	SEGMENT
??_C@_04HIPHNHOB@NAV2?$AA@ DB 'NAV2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBOMOGKA@NAV3?$AA@
CONST	SEGMENT
??_C@_04GBOMOGKA@NAV3?$AA@ DB 'NAV3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJFIELIA@GDLNK?$AA@
CONST	SEGMENT
??_C@_05EJFIELIA@GDLNK?$AA@ DB 'GDLNK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPABKIJN@ADLNK?$AA@
CONST	SEGMENT
??_C@_05JPABKIJN@ADLNK?$AA@ DB 'ADLNK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLFHDAEB@SWAP?$AA@
CONST	SEGMENT
??_C@_04NLFHDAEB@SWAP?$AA@ DB 'SWAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKPEEKNJ@HSD?$AA@
CONST	SEGMENT
??_C@_03HKPEEKNJ@HSD?$AA@ DB 'HSD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OONHJAKL@SMS?$AA@
CONST	SEGMENT
??_C@_03OONHJAKL@SMS?$AA@ DB 'SMS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNAAPCJD@S?9J?$AA@
CONST	SEGMENT
??_C@_03DNAAPCJD@S?9J?$AA@ DB 'S-J', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFBAHHEE@RINGS?$AA@
CONST	SEGMENT
??_C@_05MFBAHHEE@RINGS?$AA@ DB 'RINGS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFPEDNKB@LINE4?$AA@
CONST	SEGMENT
??_C@_05NFPEDNKB@LINE4?$AA@ DB 'LINE4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKLFKLGG@LINE3?$AA@
CONST	SEGMENT
??_C@_05JKLFKLGG@LINE3?$AA@ DB 'LINE3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IDKOJKCH@LINE2?$AA@
CONST	SEGMENT
??_C@_05IDKOJKCH@LINE2?$AA@ DB 'LINE2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KIIDMJOE@LINE1?$AA@
CONST	SEGMENT
??_C@_05KIIDMJOE@LINE1?$AA@ DB 'LINE1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKDMIDBA@CNTL?$AA@
CONST	SEGMENT
??_C@_04GKDMIDBA@CNTL?$AA@ DB 'CNTL', 00H		; `string'
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ??_C@_04GIGGHHFN@AIFF?$AA@
CONST	SEGMENT
??_C@_04GIGGHHFN@AIFF?$AA@ DB 'AIFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHIAGONP@PRE?$AA@
CONST	SEGMENT
??_C@_03PHIAGONP@PRE?$AA@ DB 'PRE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKJFCLEN@FCR?$AA@
CONST	SEGMENT
??_C@_03JKJFCLEN@FCR?$AA@ DB 'FCR', 00H			; `string'
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
CONST	SEGMENT
_beginline DD	03ca3d70ar			; 0.02
_endline DD	03d4ccccdr			; 0.05
_LGDELTA DD	03dcccccdr			; 0.1
_TriangleDist DD 03d4ccccdr			; 0.05
_CircleDia DD	03d4ccccdr			; 0.05
_L_2	DD	03f317218r			; 0.693147
_SCH_ANG_INC DD	041380000r			; 11.5
_SCH_FACT DD	044c80000r			; 1600
_trackScale DD	03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_atanf
PUBLIC	_ceilf
PUBLIC	_cosf
PUBLIC	_floorf
PUBLIC	_sinf
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?ceil@@YAMM@Z					; ceil
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?floor@@YAMM@Z					; floor
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ	; VirtualDisplay::CenterOriginInViewport
PUBLIC	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ	; VirtualDisplay::ZeroRotationAboutOrigin
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?GetWPArrivalTime@WayPointClass@@QAEKXZ		; WayPointClass::GetWPArrivalTime
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?GetINSLatDrift@AircraftClass@@QAEMXZ		; AircraftClass::GetINSLatDrift
PUBLIC	?GetINSLongDrift@AircraftClass@@QAEMXZ		; AircraftClass::GetINSLongDrift
PUBLIC	?GetINSAltOffset@AircraftClass@@QAEMXZ		; AircraftClass::GetINSAltOffset
PUBLIC	?GetUserData@ListElementClass@@QAEPAXXZ		; ListElementClass::GetUserData
PUBLIC	?GetNext@ListElementClass@@QAEPAV1@XZ		; ListElementClass::GetNext
PUBLIC	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
PUBLIC	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ		; MFDClass::CurMode
PUBLIC	?GetTGPWarning@MFDClass@@QAEHXZ			; MFDClass::GetTGPWarning
PUBLIC	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
PUBLIC	?SeekerAz@SensorClass@@QAEMXZ			; SensorClass::SeekerAz
PUBLIC	?SetICPWPIndex@ICPClass@@QAEXH@Z		; ICPClass::SetICPWPIndex
PUBLIC	?SetICPUpdateFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPUpdateFlag
PUBLIC	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
PUBLIC	?GetNext@GroundListElement@@QAEPAV1@XZ		; GroundListElement::GetNext
PUBLIC	?SetFlag@GroundListElement@@QAEXH@Z		; GroundListElement::SetFlag
PUBLIC	?IsSet@GroundListElement@@QAEHH@Z		; GroundListElement::IsSet
PUBLIC	?ClearFlag@GroundListElement@@QAEXH@Z		; GroundListElement::ClearFlag
PUBLIC	?NavMode@FireControlComputer@@AAEXXZ		; FireControlComputer::NavMode
PUBLIC	?StepPoint@FireControlComputer@@AAEXXZ		; FireControlComputer::StepPoint
PUBLIC	?InitNewStptMode@FireControlComputer@@AAEXXZ	; FireControlComputer::InitNewStptMode
PUBLIC	?StepNextWayPoint@FireControlComputer@@AAEXXZ	; FireControlComputer::StepNextWayPoint
PUBLIC	?StepPrevWayPoint@FireControlComputer@@AAEXXZ	; FireControlComputer::StepPrevWayPoint
PUBLIC	?NavDisplay@FireControlComputer@@AAEXXZ		; FireControlComputer::NavDisplay
PUBLIC	?DrawNavPoints@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawNavPoints
PUBLIC	?DrawWayPoints@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawWayPoints
PUBLIC	?DrawMarkPoints@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawMarkPoints
PUBLIC	?DrawLinkPoints@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawLinkPoints
PUBLIC	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay
PUBLIC	?DrawPointPair@FireControlComputer@@AAEXPAVWayPointClass@@MMMM@Z ; FireControlComputer::DrawPointPair
PUBLIC	?DrawPointSymbol@FireControlComputer@@AAEXPAVWayPointClass@@MM@Z ; FireControlComputer::DrawPointSymbol
PUBLIC	?DrawTGTSymbol@FireControlComputer@@AAEXMM@Z	; FireControlComputer::DrawTGTSymbol
PUBLIC	?DrawIPSymbol@FireControlComputer@@AAEXMM@Z	; FireControlComputer::DrawIPSymbol
PUBLIC	?DrawMarkSymbol@FireControlComputer@@AAEXMMH@Z	; FireControlComputer::DrawMarkSymbol
PUBLIC	?DrawFLOT@FireControlComputer@@AAEXXZ		; FireControlComputer::DrawFLOT
PUBLIC	?DrawPPThreats@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawPPThreats
PUBLIC	?DrawBullseye@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawBullseye
PUBLIC	?DrawGhostCursor@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawGhostCursor
PUBLIC	?DrawScanVolume@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawScanVolume
PUBLIC	?DrawBuggedTarget@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawBuggedTarget
PUBLIC	?DrawWingmen@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawWingmen
PUBLIC	?Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z ; FireControlComputer::Draw1Wingman
PUBLIC	?DrawAIFF@FireControlComputer@@AAEXXZ		; FireControlComputer::DrawAIFF
PUBLIC	?Draw1WingmanGnd@FireControlComputer@@AAEXPAVAircraftClass@@@Z ; FireControlComputer::Draw1WingmanGnd
PUBLIC	?SetStptMode@FireControlComputer@@QAEXW4FCCStptMode@1@@Z ; FireControlComputer::SetStptMode
PUBLIC	?SetWaypointNum@FireControlComputer@@QAEXH@Z	; FireControlComputer::SetWaypointNum
PUBLIC	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
PUBLIC	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
PUBLIC	?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ; FireControlComputer::GetFirstGroundElement
PUBLIC	?DrawDESTOAPoints@FireControlComputer@@QAEXXZ	; FireControlComputer::DrawDESTOAPoints
PUBLIC	?DrawVIPOAPoints@FireControlComputer@@QAEXXZ	; FireControlComputer::DrawVIPOAPoints
PUBLIC	?DrawVRPOAPoints@FireControlComputer@@QAEXXZ	; FireControlComputer::DrawVRPOAPoints
PUBLIC	?DrawDESTOASymbol@FireControlComputer@@QAEXMM@Z	; FireControlComputer::DrawDESTOASymbol
PUBLIC	?DrawVIPOASymbol@FireControlComputer@@QAEXMM@Z	; FireControlComputer::DrawVIPOASymbol
PUBLIC	?DrawVRPOASymbol@FireControlComputer@@QAEXMM@Z	; FireControlComputer::DrawVRPOASymbol
PUBLIC	?ToggleHSDZoom@FireControlComputer@@QAEXXZ	; FireControlComputer::ToggleHSDZoom
PUBLIC	?HSDDisplay@FireControlComputer@@QAEXXZ		; FireControlComputer::HSDDisplay
PUBLIC	?MoveCursor@FireControlComputer@@QAEXXZ		; FireControlComputer::MoveCursor
PUBLIC	?ChangeSTPT@FireControlComputer@@QAEXPAVWayPointClass@@@Z ; FireControlComputer::ChangeSTPT
PUBLIC	?MapWaypointToXY@FireControlComputer@@QAEXPAVWayPointClass@@@Z ; FireControlComputer::MapWaypointToXY
PUBLIC	?CheckPP@FireControlComputer@@QAEXXZ		; FireControlComputer::CheckPP
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?IsSet@RadarDopplerClass@@QAEHH@Z		; RadarDopplerClass::IsSet
PUBLIC	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ClearFlagBit
PUBLIC	?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ; RadarDopplerClass::GMSPWaypt
PUBLIC	?TStance@TeamClass@@QAEHE@Z			; TeamClass::TStance
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_03EPLBPKJA@CEN?$AA@			; `string'
PUBLIC	??_C@_03GCHPNPG@DEP?$AA@			; `string'
PUBLIC	??_C@_03GHGKPJIJ@CPL?$AA@			; `string'
PUBLIC	??_C@_04CNHPCPAB@DCPL?$AA@			; `string'
PUBLIC	??_C@_04DHIGGNDH@NORM?$AA@			; `string'
PUBLIC	??_C@_04NJGNBJE@EXP1?$AA@			; `string'
PUBLIC	??_C@_04CGLLICFH@EXP2?$AA@			; `string'
PUBLIC	??_C@_03EPKIGIAC@FRZ?$AA@			; `string'
PUBLIC	??_C@_04GHNNFJCK@?$CF?40f?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@392c987a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa34
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d0f5c29
PUBLIC	__real@3d23d70a
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3d8f5c29
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f060a91
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@3f99999a
PUBLIC	__real@3fa66666
PUBLIC	__real@3fc00000
PUBLIC	__real@3fe00000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40490fd9
PUBLIC	__real@40800000
PUBLIC	__real@4097e9d7
PUBLIC	__real@40c880df
PUBLIC	__real@40c90fd9
PUBLIC	__real@40c90fdb
PUBLIC	__real@40d00000
PUBLIC	__real@42a00000
PUBLIC	__real@447a0000
PUBLIC	__real@44d48000
PUBLIC	__real@461c4000
PUBLIC	__real@8000000000000000
PUBLIC	__real@bca3d70a
PUBLIC	__real@bd4ccccd
PUBLIC	__real@bd8f5c29
PUBLIC	__real@bdcccccd
PUBLIC	__real@bdf5c28f
PUBLIC	__real@be19999a
PUBLIC	__real@becccccd
PUBLIC	__real@bf666666
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0490fd9
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_abs:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_ceil:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_sprintf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z:PROC ; VirtualDisplay::AdjustOriginInViewport
EXTRN	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z:PROC ; VirtualDisplay::AdjustRotationAboutOrigin
EXTRN	?SaveDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z:PROC ; VirtualDisplay::SaveDisplayMatrix
EXTRN	?RestoreDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z:PROC ; VirtualDisplay::RestoreDisplayMatrix
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentNumber
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?LabelButton@DrawableClass@@QAEXHPAD0H@Z:PROC	; DrawableClass::LabelButton
EXTRN	?DrawBorder@DrawableClass@@QAEXXZ:PROC		; DrawableClass::DrawBorder
EXTRN	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z:PROC	; DrawableClass::GetButtonPos
EXTRN	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z:PROC ; DrawableClass::GetMfdColor
EXTRN	?BottomRow@MfdDrawable@@QAEXXZ:PROC		; MfdDrawable::BottomRow
EXTRN	?DrawReference@MfdDrawable@@QAEXPAVAircraftClass@@@Z:PROC ; MfdDrawable::DrawReference
EXTRN	?DrawRedBreak@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z:PROC ; MfdDrawable::DrawRedBreak
EXTRN	?TGPAttitudeWarning@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z:PROC ; MfdDrawable::TGPAttitudeWarning
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z:PROC ; OTWDriverClass::GetApproxGroundLevel
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z:PROC ; FackClass::GetFault
EXTRN	?ClearStrings@ICPClass@@QAEXXZ:PROC		; ICPClass::ClearStrings
EXTRN	?GetMarkWayPoint@NavigationSystem@@QAEXPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetMarkWayPoint
EXTRN	?GetMarkWayPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetMarkWayPoint
EXTRN	?GetMarkIndex@NavigationSystem@@QAEHXZ:PROC	; NavigationSystem::GetMarkIndex
EXTRN	?GotoPrevMark@NavigationSystem@@QAEXXZ:PROC	; NavigationSystem::GotoPrevMark
EXTRN	?GotoNextMark@NavigationSystem@@QAEXXZ:PROC	; NavigationSystem::GotoNextMark
EXTRN	?GetDLinkWayPoint@NavigationSystem@@QAEXPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetDLinkWayPoint
EXTRN	?GetDLinkWayPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetDLinkWayPoint
EXTRN	?GotoPrevDLink@NavigationSystem@@QAEXXZ:PROC	; NavigationSystem::GotoPrevDLink
EXTRN	?GotoNextDLink@NavigationSystem@@QAEXXZ:PROC	; NavigationSystem::GotoNextDLink
EXTRN	?GetDLinkIndex@NavigationSystem@@QAEHXZ:PROC	; NavigationSystem::GetDLinkIndex
EXTRN	?GetDESTOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetDESTOAPoint
EXTRN	?GetVIPOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetVIPOAPoint
EXTRN	?GetVRPOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z:PROC ; NavigationSystem::GetVRPOAPoint
EXTRN	?DrawSymbol@RwrClass@@SAXPAVVirtualDisplay@@HH@Z:PROC ; RwrClass::DrawSymbol
EXTRN	?HandoffBaseObject@GroundListElement@@QAEXXZ:PROC ; GroundListElement::HandoffBaseObject
EXTRN	?UpdatePlanned@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::UpdatePlanned
EXTRN	?GetBullseyeSimLocation@CampaignClass@@QAEXPAM0@Z:PROC ; CampaignClass::GetBullseyeSimLocation
EXTRN	?DistSqu@@YAMMMMM@Z:PROC			; DistSqu
EXTRN	?UnpackXY@@YAXPAXPAF1@Z:PROC			; UnpackXY
EXTRN	?GridToSim@@YAMF@Z:PROC				; GridToSim
EXTRN	?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z:PROC ; RadarDopplerClass::SetGMSPWaypt
EXTRN	?CalcKIAS@@YAMMM@Z:PROC				; CalcKIAS
EXTRN	?DrawBullseyeData@@YAXPAVVirtualDisplay@@MM@Z:PROC ; DrawBullseyeData
EXTRN	?DrawCursorBullseyeData@@YAXPAVVirtualDisplay@@MM@Z:PROC ; DrawCursorBullseyeData
EXTRN	?DrawBullseyeCircle@@YAXPAVVirtualDisplay@@MM@Z:PROC ; DrawBullseyeCircle
EXTRN	?DrawSteerPointCursorData@@YAXPAVVirtualDisplay@@PAVFalconEntity@@MM@Z:PROC ; DrawSteerPointCursorData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?FLOTList@@3PAVListClass@@A:DWORD		; FLOTList
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
EXTRN	?CursorRate@FireControlComputer@@2MB:DWORD	; FireControlComputer::CursorRate
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?FLOTDrawDistance@@3MA:DWORD			; FLOTDrawDistance
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?g_bEnableColorMfd@@3_NA:BYTE			; g_bEnableColorMfd
EXTRN	?g_fCursorSpeed@@3MA:DWORD			; g_fCursorSpeed
EXTRN	?g_fRadarScale@@3MA:DWORD			; g_fRadarScale
EXTRN	?g_bINS@@3_NA:BYTE				; g_bINS
EXTRN	?g_bRQDFix@@3_NA:BYTE				; g_bRQDFix
EXTRN	?g_bSetWaypointNumFix@@3_NA:BYTE		; g_bSetWaypointNumFix
EXTRN	?g_fHSDSymbolSize@@3MA:DWORD			; g_fHSDSymbolSize
EXTRN	?g_bHsdStptFix@@3_NA:BYTE			; g_bHsdStptFix
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_trackTriH DD	01H DUP (?)
_trackTriV DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0490fd9
CONST	SEGMENT
__real@c0490fd9 DD 0c0490fd9r			; -3.14159
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf666666
CONST	SEGMENT
__real@bf666666 DD 0bf666666r			; -0.9
CONST	ENDS
;	COMDAT __real@becccccd
CONST	SEGMENT
__real@becccccd DD 0becccccdr			; -0.4
CONST	ENDS
;	COMDAT __real@be19999a
CONST	SEGMENT
__real@be19999a DD 0be19999ar			; -0.15
CONST	ENDS
;	COMDAT __real@bdf5c28f
CONST	SEGMENT
__real@bdf5c28f DD 0bdf5c28fr			; -0.12
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@bd8f5c29
CONST	SEGMENT
__real@bd8f5c29 DD 0bd8f5c29r			; -0.07
CONST	ENDS
;	COMDAT __real@bd4ccccd
CONST	SEGMENT
__real@bd4ccccd DD 0bd4ccccdr			; -0.05
CONST	ENDS
;	COMDAT __real@bca3d70a
CONST	SEGMENT
__real@bca3d70a DD 0bca3d70ar			; -0.02
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@44d48000
CONST	SEGMENT
__real@44d48000 DD 044d48000r			; 1700
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@40d00000
CONST	SEGMENT
__real@40d00000 DD 040d00000r			; 6.5
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40c880df
CONST	SEGMENT
__real@40c880df DD 040c880dfr			; 6.26573
CONST	ENDS
;	COMDAT __real@4097e9d7
CONST	SEGMENT
__real@4097e9d7 DD 04097e9d7r			; 4.74729
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe00000
CONST	SEGMENT
__real@3fe00000 DD 03fe00000r			; 1.75
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fa66666
CONST	SEGMENT
__real@3fa66666 DD 03fa66666r			; 1.3
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3d8f5c29
CONST	SEGMENT
__real@3d8f5c29 DD 03d8f5c29r			; 0.07
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3d0f5c29
CONST	SEGMENT
__real@3d0f5c29 DD 03d0f5c29r			; 0.035
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
CONST	SEGMENT
?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB DD 03d4ccccdr ; 0.05 ; `FireControlComputer::Draw1Wingman'::`8'::wingBugY
CONST	ENDS
;	COMDAT ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
CONST	SEGMENT
?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB DD 03d4ccccdr ; 0.05 ; `FireControlComputer::Draw1Wingman'::`8'::wingBugX
CONST	ENDS
;	COMDAT ?GCURS_OFF@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
CONST	SEGMENT
?GCURS_OFF@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB DD 03d4ccccdr ; 0.05 ; `FireControlComputer::DrawBuggedTarget'::`29'::GCURS_OFF
CONST	ENDS
;	COMDAT ?GCURS_LEN@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
CONST	SEGMENT
?GCURS_LEN@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB DD 03d4ccccdr ; 0.05 ; `FireControlComputer::DrawBuggedTarget'::`29'::GCURS_LEN
CONST	ENDS
;	COMDAT ?GCURS_OFF@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
CONST	SEGMENT
?GCURS_OFF@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB DD 03d4ccccdr ; 0.05 ; `FireControlComputer::DrawGhostCursor'::`12'::GCURS_OFF
CONST	ENDS
;	COMDAT ?GCURS_LEN@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
CONST	SEGMENT
?GCURS_LEN@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB DD 03d4ccccdr ; 0.05 ; `FireControlComputer::DrawGhostCursor'::`12'::GCURS_LEN
CONST	ENDS
;	COMDAT ??_C@_04GHNNFJCK@?$CF?40f?$AA@
CONST	SEGMENT
??_C@_04GHNNFJCK@?$CF?40f?$AA@ DB '%.0f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EPKIGIAC@FRZ?$AA@
CONST	SEGMENT
??_C@_03EPKIGIAC@FRZ?$AA@ DB 'FRZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGLLICFH@EXP2?$AA@
CONST	SEGMENT
??_C@_04CGLLICFH@EXP2?$AA@ DB 'EXP2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NJGNBJE@EXP1?$AA@
CONST	SEGMENT
??_C@_04NJGNBJE@EXP1?$AA@ DB 'EXP1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHIGGNDH@NORM?$AA@
CONST	SEGMENT
??_C@_04DHIGGNDH@NORM?$AA@ DB 'NORM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNHPCPAB@DCPL?$AA@
CONST	SEGMENT
??_C@_04CNHPCPAB@DCPL?$AA@ DB 'DCPL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GHGKPJIJ@CPL?$AA@
CONST	SEGMENT
??_C@_03GHGKPJIJ@CPL?$AA@ DB 'CPL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCHPNPG@DEP?$AA@
CONST	SEGMENT
??_C@_03GCHPNPG@DEP?$AA@ DB 'DEP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EPLBPKJA@CEN?$AA@
CONST	SEGMENT
??_C@_03EPLBPKJA@CEN?$AA@ DB 'CEN', 00H			; `string'
CONST	ENDS
;	COMDAT ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
CONST	SEGMENT
?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB DD 03d315b57r ; 0.0433 ; `FireControlComputer::NavDisplay'::`5'::arrowW
CONST	ENDS
;	COMDAT ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
CONST	SEGMENT
?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB DD 03d19999ar ; 0.0375 ; `FireControlComputer::NavDisplay'::`5'::arrowH
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_trackTriH$initializer$ DD FLAT:??__EtrackTriH@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_trackTriV$initializer$ DD FLAT:??__EtrackTriV@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
;	COMDAT ??__EtrackTriV@@YAXXZ
text$yc	SEGMENT
tv72 = -4						; size = 4
??__EtrackTriV@@YAXXZ PROC				; `dynamic initializer for 'trackTriV'', COMDAT

; 1884 : static const float trackTriV = trackScale * (float)sin( DTR * 30.0f );

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f060a91
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv72[ebp]
	movss	xmm0, DWORD PTR tv72[ebp]
	mulss	xmm0, DWORD PTR _trackScale
	movss	DWORD PTR _trackTriV, xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
??__EtrackTriV@@YAXXZ ENDP				; `dynamic initializer for 'trackTriV''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
;	COMDAT ??__EtrackTriH@@YAXXZ
text$yc	SEGMENT
tv72 = -4						; size = 4
??__EtrackTriH@@YAXXZ PROC				; `dynamic initializer for 'trackTriH'', COMDAT

; 1883 : static const float trackTriH = trackScale * (float)cos( DTR * 30.0f );

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f060a91
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv72[ebp]
	movss	xmm0, DWORD PTR tv72[ebp]
	mulss	xmm0, DWORD PTR _trackScale
	movss	DWORD PTR _trackTriH, xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
??__EtrackTriH@@YAXXZ ENDP				; `dynamic initializer for 'trackTriH''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?TStance@TeamClass@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_team$ = 8						; size = 1
?TStance@TeamClass@@QAEHE@Z PROC			; TeamClass::TStance, COMDAT
; _this$ = ecx

; 317  : 	int TStance(Team team)						{ return stance[team]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _team$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [ecx+eax*2+580]
	mov	esp, ebp
	pop	ebp
	ret	4
?TStance@TeamClass@@QAEHE@Z ENDP			; TeamClass::TStance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ PROC ; RadarDopplerClass::GMSPWaypt, COMDAT
; _this$ = ecx

; 424  : 	WayPointClass* GMSPWaypt() { return GMSPPseudoWaypt; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+536]
	mov	esp, ebp
	pop	ebp
	ret	0
?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ENDP ; RadarDopplerClass::GMSPWaypt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ClearFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ClearFlagBit, COMDAT
; _this$ = ecx

; 238  : 	void ClearFlagBit (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+492]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ClearFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsSet@RadarDopplerClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@RadarDopplerClass@@QAEHH@Z PROC			; RadarDopplerClass::IsSet, COMDAT
; _this$ = ecx

; 236  :    int  IsSet (int newFlag) {return (newFlag & flags) ? TRUE : FALSE;}; //MI moved to public

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	and	ecx, DWORD PTR [eax+492]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@RadarDopplerClass@@QAEHH@Z ENDP			; RadarDopplerClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_trig$ = -68						; size = 8
tv260 = -60						; size = 4
tv255 = -56						; size = 4
_myY$ = -52						; size = 4
tv251 = -48						; size = 4
_myX$ = -44						; size = 4
tv246 = -40						; size = 4
_CursGPRange$1 = -36					; size = 4
_tolerance$2 = -32					; size = 4
_displayX$ = -28					; size = 4
_playerAC$ = -24					; size = 4
_displayY$ = -20					; size = 4
_gp$ = -16						; size = 4
_y2$ = -12						; size = 4
_x2$ = -8						; size = 4
_this$ = -4						; size = 4
?CheckPP@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::CheckPP
; _this$ = ecx

; 2494 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 2495 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2496 : 	GroundListElement *gp;
; 2497 : 	mlTrig trig;
; 2498 :     mlSinCos (&trig, platform->Yaw());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2499 :     float myX, myY, x2, y2, displayX, displayY;
; 2500 :     myX = platform->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _myX$[ebp]

; 2501 :     myY = platform->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _myY$[ebp]

; 2502 :     UpdatePlanned();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlanned@FireControlComputer@@QAEXXZ ; FireControlComputer::UpdatePlanned

; 2503 :     // Draw all known emmitters
; 2504 : 	for (gp = GetFirstGroundElement(); gp; gp = gp->GetNext()) 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ; FireControlComputer::GetFirstGroundElement
	mov	DWORD PTR _gp$[ebp], eax
	jmp	SHORT $LN13@CheckPP
$LN12@CheckPP:
	mov	ecx, DWORD PTR _gp$[ebp]
	call	?GetNext@GroundListElement@@QAEPAV1@XZ	; GroundListElement::GetNext
	mov	DWORD PTR _gp$[ebp], eax
$LN13@CheckPP:
	cmp	DWORD PTR _gp$[ebp], 0
	je	$LN11@CheckPP

; 2505 : 	{
; 2506 : 		gp->HandoffBaseObject();

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?HandoffBaseObject@GroundListElement@@QAEXXZ ; GroundListElement::HandoffBaseObject

; 2507 : 		if(gp->BaseObject() == NULL) 

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	test	eax, eax
	jne	SHORT $LN10@CheckPP

; 2508 : 			continue; // probably dead.

	jmp	SHORT $LN12@CheckPP
$LN10@CheckPP:

; 2509 : 
; 2510 : 		y2 = (gp->BaseObject()->XPos() - myX) * FT_TO_NM;

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv246[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	subss	xmm0, DWORD PTR _myX$[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _y2$[ebp], xmm0

; 2511 : 		x2 = (gp->BaseObject()->YPos() - myY) * FT_TO_NM;

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv251[ebp]
	movss	xmm0, DWORD PTR tv251[ebp]
	subss	xmm0, DWORD PTR _myY$[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _x2$[ebp], xmm0

; 2512 : 
; 2513 : 		//MI add in INS Drift
; 2514 : 		if(g_bINS)

	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN8@CheckPP

; 2515 : 		{
; 2516 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@CheckPP

; 2517 : 			{
; 2518 : 				y2 += (playerAC->GetINSLatDrift() * FT_TO_NM);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv255[ebp]
	movss	xmm0, DWORD PTR tv255[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	addss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2519 : 				x2 += (playerAC->GetINSLongDrift() * FT_TO_NM);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv260[ebp]
	movss	xmm0, DWORD PTR tv260[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	addss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN8@CheckPP:

; 2520 : 			}
; 2521 : 		}
; 2522 : 	
; 2523 : 		if(HSDZoom == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jne	SHORT $LN7@CheckPP

; 2524 : 		{
; 2525 : 			y2 /= HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2526 : 			x2 /= HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2527 : 		}
; 2528 : 		else

	jmp	SHORT $LN6@CheckPP
$LN7@CheckPP:

; 2529 : 		{
; 2530 : 			y2 /= HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2531 : 			x2 /= HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2532 : 			y2 *= HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+468]
	mulss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2533 : 			x2 *= HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+468]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN6@CheckPP:

; 2534 : 		}
; 2535 : 
; 2536 : 		displayX = trig.cos * x2 - trig.sin * y2;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2537 : 		displayY = trig.sin * x2 + trig.cos * y2;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2538 : 
; 2539 : 		if(!IsHsdState(HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN5@CheckPP

; 2540 : 			displayY -= 0.4F;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR _displayY$[ebp], xmm0
$LN5@CheckPP:

; 2541 : 	
; 2542 : 		float CursGPRange = (float)sqrt((displayX-xPos)*(displayX-xPos) + 
; 2543 : 			(displayY-yPos)*(displayY-yPos));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR [eax+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _displayX$[ebp]
	subss	xmm1, DWORD PTR [ecx+472]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _displayY$[ebp]
	subss	xmm1, DWORD PTR [edx+476]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR _displayY$[ebp]
	subss	xmm2, DWORD PTR [eax+476]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _CursGPRange$1[ebp]

; 2544 : 		float tolerance = 0.03F;

	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR _tolerance$2[ebp], xmm0

; 2545 : 		if(CursGPRange < tolerance && CursGPRange > -tolerance)

	movss	xmm0, DWORD PTR _tolerance$2[ebp]
	comiss	xmm0, DWORD PTR _CursGPRange$1[ebp]
	jbe	SHORT $LN1@CheckPP
	movss	xmm0, DWORD PTR _tolerance$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _CursGPRange$1[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@CheckPP

; 2546 : 		{ 
; 2547 : 			if(HSDDesignate < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+480], 0
	jge	SHORT $LN3@CheckPP

; 2548 : 			{
; 2549 : 				gp->ClearFlag(GroundListElement::RangeRing);

	push	2
	mov	ecx, DWORD PTR _gp$[ebp]
	call	?ClearFlag@GroundListElement@@QAEXH@Z	; GroundListElement::ClearFlag

; 2550 : 				HSDDesignate = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+480], 0
	jmp	SHORT $LN1@CheckPP
$LN3@CheckPP:

; 2551 : 			}
; 2552 : 			else if(HSDDesignate == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+480], 1
	jne	SHORT $LN1@CheckPP

; 2553 : 			{
; 2554 : 				gp->SetFlag(GroundListElement::RangeRing);

	push	2
	mov	ecx, DWORD PTR _gp$[ebp]
	call	?SetFlag@GroundListElement@@QAEXH@Z	; GroundListElement::SetFlag

; 2555 : 				HSDDesignate = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], 0
$LN1@CheckPP:

; 2556 : 			}
; 2557 : 		}
; 2558 : 	}

	jmp	$LN12@CheckPP
$LN11@CheckPP:

; 2559 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckPP@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::CheckPP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_trig$ = -52						; size = 8
_wpZ$ = -44						; size = 4
tv197 = -40						; size = 4
tv191 = -36						; size = 4
tv179 = -32						; size = 4
tv174 = -28						; size = 4
_wpY$ = -24						; size = 4
_wpX$ = -20						; size = 4
_playerAC$ = -16					; size = 4
_y2$ = -12						; size = 4
_x2$ = -8						; size = 4
_this$ = -4						; size = 4
_tmpWp$ = 8						; size = 4
?MapWaypointToXY@FireControlComputer@@QAEXPAVWayPointClass@@@Z PROC ; FireControlComputer::MapWaypointToXY
; _this$ = ecx

; 2459 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 2460 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2461 : 	float wpX, wpY, wpZ;
; 2462 : 	tmpWp->GetLocation(&wpX, &wpY, &wpZ);

	lea	eax, DWORD PTR _wpZ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wpY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wpX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _tmpWp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 2463 : 	//add in INS Drift
; 2464 : 	if(g_bINS)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN3@MapWaypoin

; 2465 : 	{
; 2466 : 		if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN3@MapWaypoin

; 2467 : 		{
; 2468 : 			wpX += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv174[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	addss	xmm0, DWORD PTR _wpX$[ebp]
	movss	DWORD PTR _wpX$[ebp], xmm0

; 2469 : 			wpY += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv179[ebp]
	movss	xmm0, DWORD PTR tv179[ebp]
	addss	xmm0, DWORD PTR _wpY$[ebp]
	movss	DWORD PTR _wpY$[ebp], xmm0
$LN3@MapWaypoin:

; 2470 : 		}
; 2471 : 	}
; 2472 : 	mlTrig trig;
; 2473 : 	mlSinCos (&trig, platform->Yaw());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2474 : 	float y2 = (wpX - platform->XPos()) * FT_TO_NM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv191[ebp]
	movss	xmm0, DWORD PTR _wpX$[ebp]
	subss	xmm0, DWORD PTR tv191[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _y2$[ebp], xmm0

; 2475 : 	float x2 = (wpY - platform->YPos()) * FT_TO_NM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv197[ebp]
	movss	xmm0, DWORD PTR _wpY$[ebp]
	subss	xmm0, DWORD PTR tv197[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _x2$[ebp], xmm0

; 2476 : 	
; 2477 : 	if(HSDZoom == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jne	SHORT $LN2@MapWaypoin

; 2478 : 	{
; 2479 : 		y2 /= HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2480 : 		x2 /= HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2481 : 	}
; 2482 : 	else

	jmp	SHORT $LN1@MapWaypoin
$LN2@MapWaypoin:

; 2483 : 	{
; 2484 : 		y2 /= HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2485 : 		x2 /= HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2486 : 		y2 *= HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+468]
	mulss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2487 : 		x2 *= HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+468]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN1@MapWaypoin:

; 2488 : 	}
; 2489 : 	DispX = trig.cos * x2 - trig.sin * y2;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+488], xmm0

; 2490 : 	DispY = trig.sin * x2 + trig.cos * y2;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+492], xmm0

; 2491 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MapWaypointToXY@FireControlComputer@@QAEXPAVWayPointClass@@@Z ENDP ; FireControlComputer::MapWaypointToXY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_tmpWp$ = 8						; size = 4
?ChangeSTPT@FireControlComputer@@QAEXPAVWayPointClass@@@Z PROC ; FireControlComputer::ChangeSTPT
; _this$ = ecx

; 2450 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN2@ChangeSTPT:

; 2451 : 	while(platform->curWaypoint && platform->curWaypoint != tmpWp)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	cmp	DWORD PTR [ecx+728], 0
	je	SHORT $LN3@ChangeSTPT
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+728]
	cmp	ecx, DWORD PTR _tmpWp$[ebp]
	je	SHORT $LN3@ChangeSTPT

; 2452 : 	{
; 2453 : 		waypointStepCmd = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+194], 1

; 2454 : 		StepPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepPoint@FireControlComputer@@AAEXXZ	; FireControlComputer::StepPoint

; 2455 : 	}

	jmp	SHORT $LN2@ChangeSTPT
$LN3@ChangeSTPT:

; 2456 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeSTPT@FireControlComputer@@QAEXPAVWayPointClass@@@Z ENDP ; FireControlComputer::ChangeSTPT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_CursWPRange$1 = -44					; size = 4
_tolerance$2 = -40					; size = 4
tv200 = -36						; size = 4
tv199 = -32						; size = 4
tv192 = -28						; size = 4
tv185 = -24						; size = 4
tv184 = -20						; size = 4
tv177 = -16						; size = 4
tv170 = -12						; size = 4
_tmpWp$3 = -8						; size = 4
_this$ = -4						; size = 4
?MoveCursor@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::MoveCursor
; _this$ = ecx

; 2368 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 2369 : 	if(HSDCursorXCmd != 0.0F || HSDCursorYCmd != 0.0F)

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@MoveCursor
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN20@MoveCursor
$LN19@MoveCursor:

; 2370 : 	{
; 2371 : 		if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == true) && (IO.AnalogIsUsed(AXIS_CURSOR_Y) == true))

	push	11					; 0000000bH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	edx, al
	cmp	edx, 1
	jne	$LN18@MoveCursor
	push	12					; 0000000cH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	cmp	eax, 1
	jne	$LN18@MoveCursor

; 2372 : 		{
; 2373 : 			xPos += (HSDCursorXCmd / 10000.0F) * g_fCursorSpeed * (6.5F * CursorRate) * SimLibMajorFrameTime;	      

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+204]
	divss	xmm0, DWORD PTR __real@461c4000
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	movss	xmm1, DWORD PTR __real@40d00000
	mulss	xmm1, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+472]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+472], xmm0

; 2374 : 			yPos += (HSDCursorYCmd / 10000.0F) * g_fCursorSpeed * (6.5F * CursorRate) * SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR __real@461c4000
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	movss	xmm1, DWORD PTR __real@40d00000
	mulss	xmm1, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+476]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+476], xmm0

; 2375 : 		}
; 2376 : 		else

	jmp	$LN17@MoveCursor
$LN18@MoveCursor:

; 2377 : 		{
; 2378 : 			xPos += HSDCursorXCmd * g_fCursorSpeed * curCursorRate * SimLibMajorFrameTime;	      

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+204]
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+484]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+472], xmm0

; 2379 : 			yPos += HSDCursorYCmd * g_fCursorSpeed * curCursorRate * SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+208]
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+484]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+476]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+476], xmm0

; 2380 : 
; 2381 : 			curCursorRate = min (curCursorRate + CursorRate * SimLibMajorFrameTime * (4.0F), (6.5F) * CursorRate);

	movss	xmm0, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@40800000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+484]
	movss	xmm1, DWORD PTR __real@40d00000
	mulss	xmm1, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	comiss	xmm1, xmm0
	jbe	SHORT $LN23@MoveCursor
	movss	xmm0, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@40800000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+484]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN24@MoveCursor
$LN23@MoveCursor:
	movss	xmm0, DWORD PTR __real@40d00000
	mulss	xmm0, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	movss	DWORD PTR tv170[ebp], xmm0
$LN24@MoveCursor:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR [edx+484], xmm0
$LN17@MoveCursor:

; 2382 : 		}
; 2383 : 
; 2384 : 		xPos = min ( max (xPos, -1.0F), 1.0F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+472]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN25@MoveCursor
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+472]
	movss	DWORD PTR tv177[ebp], xmm0
	jmp	SHORT $LN26@MoveCursor
$LN25@MoveCursor:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv177[ebp], xmm0
$LN26@MoveCursor:
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv177[ebp]
	jbe	SHORT $LN29@MoveCursor
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+472]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN27@MoveCursor
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+472]
	movss	DWORD PTR tv184[ebp], xmm0
	jmp	SHORT $LN28@MoveCursor
$LN27@MoveCursor:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv184[ebp], xmm0
$LN28@MoveCursor:
	movss	xmm0, DWORD PTR tv184[ebp]
	movss	DWORD PTR tv185[ebp], xmm0
	jmp	SHORT $LN30@MoveCursor
$LN29@MoveCursor:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv185[ebp], xmm0
$LN30@MoveCursor:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR [ecx+472], xmm0

; 2385 : 		yPos = min ( max (yPos, -1.0F), 1.0F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+476]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN31@MoveCursor
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+476]
	movss	DWORD PTR tv192[ebp], xmm0
	jmp	SHORT $LN32@MoveCursor
$LN31@MoveCursor:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv192[ebp], xmm0
$LN32@MoveCursor:
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv192[ebp]
	jbe	SHORT $LN35@MoveCursor
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+476]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN33@MoveCursor
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+476]
	movss	DWORD PTR tv199[ebp], xmm0
	jmp	SHORT $LN34@MoveCursor
$LN33@MoveCursor:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv199[ebp], xmm0
$LN34@MoveCursor:
	movss	xmm0, DWORD PTR tv199[ebp]
	movss	DWORD PTR tv200[ebp], xmm0
	jmp	SHORT $LN36@MoveCursor
$LN35@MoveCursor:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv200[ebp], xmm0
$LN36@MoveCursor:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv200[ebp]
	movss	DWORD PTR [eax+476], xmm0

; 2386 : 
; 2387 : 		//range bump
; 2388 : 		if(HSDZoom == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jne	$LN11@MoveCursor

; 2389 : 		{
; 2390 : 			//if we bump it' we decouple automatically
; 2391 : 			if(yPos > 0.9F && HsdRangeTbl[HsdRangeIndex] < 240)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+476]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN15@MoveCursor
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	cmp	DWORD PTR ?HsdRangeTbl@FireControlComputer@@0PAHA[ecx*4], 240 ; 000000f0H
	jge	SHORT $LN15@MoveCursor

; 2392 : 			{
; 2393 : 				HSDRangeStepCmd = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+195], 1

; 2394 : 				yPos = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+476], xmm0

; 2395 : 				if(IsHsdState(HSDCPL))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN14@MoveCursor

; 2396 : 					ToggleHsdState(HSDCPL);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN14@MoveCursor:

; 2397 : 			}

	jmp	SHORT $LN11@MoveCursor
$LN15@MoveCursor:

; 2398 :             else if(yPos < -0.9F && HsdRangeTbl[HsdRangeIndex] > 15)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf666666
	comiss	xmm0, DWORD PTR [ecx+476]
	jbe	SHORT $LN11@MoveCursor
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	cmp	DWORD PTR ?HsdRangeTbl@FireControlComputer@@0PAHA[eax*4], 15 ; 0000000fH
	jle	SHORT $LN11@MoveCursor

; 2399 : 			{
; 2400 : 				HSDRangeStepCmd = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+195], -1

; 2401 : 				yPos = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+476], xmm0

; 2402 : 				if(IsHsdState(HSDCPL))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN11@MoveCursor

; 2403 : 					ToggleHsdState(HSDCPL);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN11@MoveCursor:

; 2404 : 			}
; 2405 : 		}
; 2406 : 	}
; 2407 : 	else

	jmp	SHORT $LN10@MoveCursor
$LN20@MoveCursor:

; 2408 : 		curCursorRate = CursorRate;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	movss	DWORD PTR [eax+484], xmm0
$LN10@MoveCursor:

; 2409 : 
; 2410 : 	//check if our cursor is over a waypoint, only if their not decluttered
; 2411 : 	if(!IsHsdState(HSDNONAV1))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN6@MoveCursor

; 2412 : 	{
; 2413 : 		WayPointClass *tmpWp = platform->waypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR _tmpWp$3[ebp], eax

; 2414 : 		if(tmpWp)

	cmp	DWORD PTR _tmpWp$3[ebp], 0
	je	$LN6@MoveCursor

; 2415 : 		{
; 2416 : 			//do this stuff for all waypoints
; 2417 : 			tmpWp = tmpWp->GetNextWP();

	mov	ecx, DWORD PTR _tmpWp$3[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWp$3[ebp], eax
$LN7@MoveCursor:

; 2418 : 			while(tmpWp)

	cmp	DWORD PTR _tmpWp$3[ebp], 0
	je	$LN6@MoveCursor

; 2419 : 			{
; 2420 : 				//cursor position
; 2421 : 				MapWaypointToXY(tmpWp);

	mov	ecx, DWORD PTR _tmpWp$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToXY@FireControlComputer@@QAEXPAVWayPointClass@@@Z ; FireControlComputer::MapWaypointToXY

; 2422 : 				if(!IsHsdState(HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN5@MoveCursor

; 2423 : 					DispY -= 0.4F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+492]
	subss	xmm0, DWORD PTR __real@3ecccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+492], xmm0
$LN5@MoveCursor:

; 2424 : 				float tolerance = 0.05F;	//just about the size of the circle

	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _tolerance$2[ebp], xmm0

; 2425 : 				float CursWPRange = (float)sqrt((DispX-xPos)*(DispX-xPos) + (DispY-yPos)*(DispY-yPos));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+488]
	subss	xmm0, DWORD PTR [edx+472]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+488]
	subss	xmm1, DWORD PTR [ecx+472]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+492]
	subss	xmm1, DWORD PTR [eax+476]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [ecx+492]
	subss	xmm2, DWORD PTR [edx+476]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _CursWPRange$1[ebp]

; 2426 : 				//CursWPRange;
; 2427 : 				if(CursWPRange < tolerance && CursWPRange > -tolerance)

	movss	xmm0, DWORD PTR _tolerance$2[ebp]
	comiss	xmm0, DWORD PTR _CursWPRange$1[ebp]
	jbe	SHORT $LN3@MoveCursor
	movss	xmm0, DWORD PTR _tolerance$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _CursWPRange$1[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@MoveCursor

; 2428 : 				{
; 2429 : 					//did we designate?
; 2430 : 					if(HSDDesignate == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+480], 1
	jne	SHORT $LN3@MoveCursor

; 2431 : 					{
; 2432 : 						//need to find which waypoint our cursor is over now
; 2433 : 						if(platform->curWaypoint != tmpWp)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+728]
	cmp	eax, DWORD PTR _tmpWp$3[ebp]
	je	SHORT $LN2@MoveCursor

; 2434 : 						{
; 2435 : 							ChangeSTPT(tmpWp);

	mov	ecx, DWORD PTR _tmpWp$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeSTPT@FireControlComputer@@QAEXPAVWayPointClass@@@Z ; FireControlComputer::ChangeSTPT
$LN2@MoveCursor:

; 2436 : 						}
; 2437 : 						HSDDesignate = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+480], 0
$LN3@MoveCursor:

; 2438 : 					}
; 2439 : 				}
; 2440 : 				tmpWp = tmpWp->GetNextWP();

	mov	ecx, DWORD PTR _tmpWp$3[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWp$3[ebp], eax

; 2441 : 			}

	jmp	$LN7@MoveCursor
$LN6@MoveCursor:

; 2442 : 		}
; 2443 : 	}
; 2444 : 	//check for preplanned threads, only if not decluttered
; 2445 : 	if(!IsHsdState(HSDNOPRE))

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN1@MoveCursor

; 2446 : 		CheckPP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckPP@FireControlComputer@@QAEXXZ	; FireControlComputer::CheckPP
$LN1@MoveCursor:

; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MoveCursor@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::MoveCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HSDDisplay@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::HSDDisplay
; _this$ = ecx

; 2355 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2356 : 	//add cursor symbol
; 2357 :     display->SetColor(GetMfdColor(MFD_CURSOR));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 2358 :     display->Line (xPos + beginline, yPos, xPos + endline, yPos); 

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+476]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+472]
	addss	xmm0, DWORD PTR _endline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+476]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+472]
	addss	xmm0, DWORD PTR _beginline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2359 :     display->Line (xPos - beginline, yPos, xPos -endline, yPos);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+476]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+472]
	subss	xmm0, DWORD PTR _endline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+476]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+472]
	subss	xmm0, DWORD PTR _beginline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2360 : 	display->Line (xPos, yPos + beginline, xPos, yPos + endline);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+476]
	addss	xmm0, DWORD PTR _endline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+472]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+476]
	addss	xmm0, DWORD PTR _beginline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+472]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2361 : 	display->Line (xPos, yPos - beginline, xPos, yPos - endline);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+476]
	subss	xmm0, DWORD PTR _endline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+472]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+476]
	subss	xmm0, DWORD PTR _beginline
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+472]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2362 : 
; 2363 : 	//check for movement
; 2364 : 	MoveCursor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveCursor@FireControlComputer@@QAEXXZ	; FireControlComputer::MoveCursor

; 2365 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HSDDisplay@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::HSDDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleHSDZoom@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::ToggleHSDZoom
; _this$ = ecx

; 2320 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2321 : 	//Wombat778 11-10-2003 Changed so HSD will center on cursor when zoomed.
; 2322 : 	if(HSDZoom == 0){		

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	jne	$LN6@ToggleHSDZ

; 2323 : 		//Take the current cursor position and save it to the HSDXPos and HSDYPos variables
; 2324 : 		HSDXPos = xPos*2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+472]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+496], xmm0

; 2325 : 		HSDYPos = yPos*2;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+476]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+500], xmm0

; 2326 : 		if (IsSOI){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	je	SHORT $LN5@ToggleHSDZ

; 2327 : 			//if the MFD is the SOI, center the cursor in the display when zooming
; 2328 : 			xPos=0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+472], xmm0

; 2329 : 			yPos=0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+476], xmm0
$LN5@ToggleHSDZ:

; 2330 : 		}
; 2331 : 		HSDZoom = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+468], 2
	jmp	$LN1@ToggleHSDZ
$LN6@ToggleHSDZ:

; 2332 : 	}
; 2333 : 	else if(HSDZoom == 2){					

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 2
	jne	$LN3@ToggleHSDZ

; 2334 : 		// Take the current cursor position and save it to the HSDXPos 
; 2335 : 		// and HSDYPos variables.  Adjust for the fact that we arent at the original zoom anymore
; 2336 : 		HSDXPos = HSDZoom*(HSDXPos+(xPos));		

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+468]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+472]
	addss	xmm1, DWORD PTR [ecx+496]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+496], xmm0

; 2337 : 		HSDYPos = HSDZoom*(HSDYPos+(yPos));

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+468]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+476]
	addss	xmm1, DWORD PTR [edx+500]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+500], xmm0

; 2338 : 
; 2339 : 		if (IsSOI){

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN2@ToggleHSDZ

; 2340 : 			//if the MFD is the SOI, center the cursor in the display when zooming
; 2341 : 			xPos=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+472], xmm0

; 2342 : 			yPos=0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+476], xmm0
$LN2@ToggleHSDZ:

; 2343 : 		}
; 2344 : 		HSDZoom = 4;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], 4

; 2345 : 	}
; 2346 : 	else {

	jmp	SHORT $LN1@ToggleHSDZ
$LN3@ToggleHSDZ:

; 2347 : 		HSDZoom = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+468], 0
$LN1@ToggleHSDZ:

; 2348 : 	}
; 2349 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleHSDZoom@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::ToggleHSDZoom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_playerAC$ = -4						; size = 4
_displayX$ = 8						; size = 4
_displayY$ = 12						; size = 4
?DrawVRPOASymbol@FireControlComputer@@QAEXMM@Z PROC	; FireControlComputer::DrawVRPOASymbol
; _this$ = ecx

; 1478 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1480 : 	//MI
; 1481 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawVRPOAS
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN1@DrawVRPOAS

; 1482 : 	{
; 1483 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@DrawVRPOAS
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawVRPOAS

; 1484 : 			return;

	jmp	SHORT $LN3@DrawVRPOAS
$LN1@DrawVRPOAS:

; 1485 : 	}
; 1486 : 
; 1487 : 	display->Circle(displayX, displayY, CircleDia);

	push	ecx
	movss	xmm0, DWORD PTR _CircleDia
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax
$LN3@DrawVRPOAS:

; 1488 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawVRPOASymbol@FireControlComputer@@QAEXMM@Z ENDP	; FireControlComputer::DrawVRPOASymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_playerAC$ = -4						; size = 4
_displayX$ = 8						; size = 4
_displayY$ = 12						; size = 4
?DrawVIPOASymbol@FireControlComputer@@QAEXMM@Z PROC	; FireControlComputer::DrawVIPOASymbol
; _this$ = ecx

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1467 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1468 : 	//MI
; 1469 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawVIPOAS
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN1@DrawVIPOAS

; 1470 : 	{
; 1471 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@DrawVIPOAS
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawVIPOAS

; 1472 : 			return;

	jmp	SHORT $LN3@DrawVIPOAS
$LN1@DrawVIPOAS:

; 1473 : 	}
; 1474 : 
; 1475 : 	display->Circle(displayX, displayY, CircleDia);

	push	ecx
	movss	xmm0, DWORD PTR _CircleDia
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax
$LN3@DrawVIPOAS:

; 1476 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawVIPOASymbol@FireControlComputer@@QAEXMM@Z ENDP	; FireControlComputer::DrawVIPOASymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -24					; size = 4
_YOffset$ = -20						; size = 4
_XOffset$ = -16						; size = 4
_this$ = -12						; size = 4
_X1$ = -8						; size = 4
_Y1$ = -4						; size = 4
_displayX$ = 8						; size = 4
_displayY$ = 12						; size = 4
?DrawDESTOASymbol@FireControlComputer@@QAEXMM@Z PROC	; FireControlComputer::DrawDESTOASymbol
; _this$ = ecx

; 1447 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1448 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1449 : 	//MI
; 1450 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawDESTOA
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN1@DrawDESTOA

; 1451 : 	{
; 1452 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@DrawDESTOA
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawDESTOA

; 1453 : 			return;

	jmp	$LN3@DrawDESTOA
$LN1@DrawDESTOA:

; 1454 : 	}
; 1455 : 
; 1456 : 	//put our input as the center of the triangle
; 1457 : 	float XOffset = (TriangleDist*1.3F)/2;

	movss	xmm0, DWORD PTR _TriangleDist
	mulss	xmm0, DWORD PTR __real@3fa66666
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _XOffset$[ebp], xmm0

; 1458 : 	float YOffset = (TriangleDist*1.75F)/2;

	movss	xmm0, DWORD PTR _TriangleDist
	mulss	xmm0, DWORD PTR __real@3fe00000
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _YOffset$[ebp], xmm0

; 1459 : 	float X1 = displayX - XOffset;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _XOffset$[ebp]
	movss	DWORD PTR _X1$[ebp], xmm0

; 1460 : 	float Y1 = displayY - YOffset;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _YOffset$[ebp]
	movss	DWORD PTR _Y1$[ebp], xmm0

; 1461 : 	display->Line(X1, Y1, X1 + XOffset*2, Y1);

	push	ecx
	movss	xmm0, DWORD PTR _Y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _XOffset$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _X1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _Y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _X1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1462 : 	display->Line(X1 + XOffset*2,Y1, X1 + XOffset, Y1 + YOffset*2);

	movss	xmm0, DWORD PTR _YOffset$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _Y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _X1$[ebp]
	addss	xmm0, DWORD PTR _XOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _Y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _XOffset$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _X1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1463 : 	display->Line(X1 + XOffset, Y1 + YOffset*2, X1, Y1);    

	push	ecx
	movss	xmm0, DWORD PTR _Y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _X1$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _YOffset$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _Y1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _X1$[ebp]
	addss	xmm0, DWORD PTR _XOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawDESTOA:

; 1464 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawDESTOASymbol@FireControlComputer@@QAEXMM@Z ENDP	; FireControlComputer::DrawDESTOASymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_displayX$ = -20					; size = 4
_displayY$ = -16					; size = 4
_this$ = -12						; size = 4
_curWaypoint$ = -8					; size = 4
_i$ = -4						; size = 4
?DrawVRPOAPoints@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::DrawVRPOAPoints
; _this$ = ecx

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 	//MI
; 1243 : 	/*if(g_bRealisticAvionics && g_bINS)
; 1244 : 	{
; 1245 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_NAV))
; 1246 : 			return;
; 1247 : 	}*/
; 1248 : 
; 1249 : 	WayPointClass* curWaypoint = NULL;

	mov	DWORD PTR _curWaypoint$[ebp], 0

; 1250 : 	int				i;
; 1251 : 	float			displayX;
; 1252 : 	float			displayY;
; 1253 : 
; 1254 : 	for(i = 0; i < MAX_VRPOA; i++) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@DrawVRPOAP
$LN5@DrawVRPOAP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@DrawVRPOAP:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN4@DrawVRPOAP

; 1255 : 	{
; 1256 : 		gNavigationSys->GetVRPOAPoint(i, &curWaypoint);

	lea	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetVRPOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetVRPOAPoint

; 1257 : 		if(curWaypoint) 

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN1@DrawVRPOAP

; 1258 : 		{
; 1259 : 			//only do this is this is our target
; 1260 : 			if(platform->curWaypoint->GetWPFlags() & WPF_TARGET)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN1@DrawVRPOAP

; 1261 : 			{
; 1262 : 				MapWaypointToDisplay(curWaypoint, &displayX, &displayY);

	lea	edx, DWORD PTR _displayY$[ebp]
	push	edx
	lea	eax, DWORD PTR _displayX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1263 : 				if (g_bRealisticAvionics) 

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN1@DrawVRPOAP

; 1264 : 					DrawVRPOASymbol(displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawVRPOASymbol@FireControlComputer@@QAEXMM@Z ; FireControlComputer::DrawVRPOASymbol
$LN1@DrawVRPOAP:

; 1265 : 			}
; 1266 : 		}
; 1267 : 	}

	jmp	SHORT $LN5@DrawVRPOAP
$LN4@DrawVRPOAP:

; 1268 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawVRPOAPoints@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::DrawVRPOAPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_displayX$ = -20					; size = 4
_displayY$ = -16					; size = 4
_this$ = -12						; size = 4
_curWaypoint$ = -8					; size = 4
_i$ = -4						; size = 4
?DrawVIPOAPoints@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::DrawVIPOAPoints
; _this$ = ecx

; 1212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1213 : 	//MI
; 1214 : 	/*if(g_bRealisticAvionics && g_bINS)
; 1215 : 	{
; 1216 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_NAV))
; 1217 : 			return;
; 1218 : 	}*/
; 1219 : 
; 1220 : 	WayPointClass* curWaypoint = NULL;

	mov	DWORD PTR _curWaypoint$[ebp], 0

; 1221 : 	int				i;
; 1222 : 	float			displayX;
; 1223 : 	float			displayY;
; 1224 : 
; 1225 : 	for(i = 0; i < MAX_VIPOA; i++) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@DrawVIPOAP
$LN5@DrawVIPOAP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@DrawVIPOAP:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN4@DrawVIPOAP

; 1226 : 	{
; 1227 : 		gNavigationSys->GetVIPOAPoint(i, &curWaypoint);

	lea	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetVIPOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetVIPOAPoint

; 1228 : 		if(curWaypoint) 

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN1@DrawVIPOAP

; 1229 : 		{
; 1230 : 			//only do this is this is our target
; 1231 : 			if(platform->curWaypoint->GetWPFlags() & WPF_TARGET)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN1@DrawVIPOAP

; 1232 : 			{
; 1233 : 				MapWaypointToDisplay(curWaypoint, &displayX, &displayY);

	lea	edx, DWORD PTR _displayY$[ebp]
	push	edx
	lea	eax, DWORD PTR _displayX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1234 : 				if (g_bRealisticAvionics) 

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN1@DrawVIPOAP

; 1235 : 					DrawVIPOASymbol(displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawVIPOASymbol@FireControlComputer@@QAEXMM@Z ; FireControlComputer::DrawVIPOASymbol
$LN1@DrawVIPOAP:

; 1236 : 			}
; 1237 : 		}
; 1238 : 	}

	jmp	SHORT $LN5@DrawVIPOAP
$LN4@DrawVIPOAP:

; 1239 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawVIPOAPoints@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::DrawVIPOAPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_displayX$ = -24					; size = 4
_displayY$ = -20					; size = 4
_playerAC$ = -16					; size = 4
_this$ = -12						; size = 4
_curWaypoint$ = -8					; size = 4
_i$ = -4						; size = 4
?DrawDESTOAPoints@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::DrawDESTOAPoints
; _this$ = ecx

; 1182 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1183 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1184 : 	//MI
; 1185 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN7@DrawDESTOA
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN7@DrawDESTOA

; 1186 : 	{
; 1187 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN7@DrawDESTOA
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN7@DrawDESTOA

; 1188 : 			return;

	jmp	$LN9@DrawDESTOA
$LN7@DrawDESTOA:

; 1189 : 	}
; 1190 : 
; 1191 : 	WayPointClass* curWaypoint = NULL;

	mov	DWORD PTR _curWaypoint$[ebp], 0

; 1192 : 	int				i;
; 1193 : 	float			displayX;
; 1194 : 	float			displayY;
; 1195 : 
; 1196 : 	for(i = 0; i < MAX_DESTOA; i++) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@DrawDESTOA
$LN5@DrawDESTOA:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@DrawDESTOA:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN4@DrawDESTOA

; 1197 : 	{
; 1198 : 		gNavigationSys->GetDESTOAPoint(i, &curWaypoint);

	lea	eax, DWORD PTR _curWaypoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDESTOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetDESTOAPoint

; 1199 : 		if(curWaypoint) 

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN1@DrawDESTOA

; 1200 : 		{
; 1201 : 			//only do this is this is our target
; 1202 : 			if(platform->curWaypoint->GetWPFlags() & WPF_TARGET)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN1@DrawDESTOA

; 1203 : 			{
; 1204 : 				MapWaypointToDisplay(curWaypoint, &displayX, &displayY);

	lea	ecx, DWORD PTR _displayY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _displayX$[ebp]
	push	edx
	mov	eax, DWORD PTR _curWaypoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1205 : 				if (g_bRealisticAvionics) 

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN1@DrawDESTOA

; 1206 : 					DrawDESTOASymbol(displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDESTOASymbol@FireControlComputer@@QAEXMM@Z ; FireControlComputer::DrawDESTOASymbol
$LN1@DrawDESTOA:

; 1207 : 			}
; 1208 : 		}
; 1209 : 	}

	jmp	SHORT $LN5@DrawDESTOA
$LN4@DrawDESTOA:
$LN9@DrawDESTOA:

; 1210 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawDESTOAPoints@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::DrawDESTOAPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ PROC ; FireControlComputer::GetFirstGroundElement, COMDAT
; _this$ = ecx

; 305  : 	GroundListElement *GetFirstGroundElement() { return grndlist; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ENDP ; FireControlComputer::GetFirstGroundElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_st$ = 8						; size = 4
?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z PROC ; FireControlComputer::IsHsdState, COMDAT
; _this$ = ecx

; 300  :    BOOL IsHsdState (HsdStates st) { return (hsdstates & st) == (unsigned int) st ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	and	ecx, DWORD PTR _st$[ebp]
	cmp	ecx, DWORD PTR _st$[ebp]
	jne	SHORT $LN3@IsHsdState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsHsdState
$LN3@IsHsdState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsHsdState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ENDP ; FireControlComputer::IsHsdState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_st$ = 8						; size = 4
?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z PROC ; FireControlComputer::ToggleHsdState, COMDAT
; _this$ = ecx

; 299  :    void ToggleHsdState (HsdStates st) { hsdstates ^= st; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	xor	ecx, DWORD PTR _st$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ENDP ; FireControlComputer::ToggleHsdState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_rx$ = -28						; size = 4
_ry$ = -24						; size = 4
_rz$ = -20						; size = 4
_theRadar$ = -16					; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 4
_curWaypoint$ = -4					; size = 4
_num$ = 8						; size = 4
?SetWaypointNum@FireControlComputer@@QAEXH@Z PROC	; FireControlComputer::SetWaypointNum
; _this$ = ecx

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 527  : WayPointClass* curWaypoint = platform->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _curWaypoint$[ebp], edx

; 528  : RadarClass* theRadar = (RadarClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 529  : float			rx, ry, rz;
; 530  : int i;
; 531  : 
; 532  :    TheHud->waypointNum = num;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR [edx+4948], eax

; 533  :    OTWDriver.pCockpitManager->mpIcp->SetICPWPIndex(TheHud->waypointNum);

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+4948]
	push	edx
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?SetICPWPIndex@ICPClass@@QAEXH@Z	; ICPClass::SetICPWPIndex

; 534  :    OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(STPT_UPDATE);

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 535  : 	platform->curWaypoint->GetLocation (&rx, &ry, &rz);

	lea	edx, DWORD PTR _rz$[ebp]
	push	edx
	lea	eax, DWORD PTR _ry$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 536  : //find the first waypoint
; 537  :    for (i=0; curWaypoint->GetPrevWP(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SetWaypoin
$LN9@SetWaypoin:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@SetWaypoin:
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN8@SetWaypoin

; 538  :       curWaypoint	= curWaypoint->GetPrevWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _curWaypoint$[ebp], eax
	jmp	SHORT $LN9@SetWaypoin
$LN8@SetWaypoin:

; 539  : //find the corect waypoint
; 540  :    for (i=0; i<num && curWaypoint; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SetWaypoin
$LN6@SetWaypoin:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@SetWaypoin:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	SHORT $LN5@SetWaypoin
	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN5@SetWaypoin

; 541  : // 2001-07-28 MODIFIED BY S.G. ITS THE *NEXT* WAYPOINT, NOT THE PREVIOUS!!! NOT CHECKED SO COMMENTED OUT
; 542  : // 2002-04-18 MN let's add a config file variable to test that later - AI uses this function, too, 
; 543  : // so we need to be sure it works...
; 544  :     if (!g_bSetWaypointNumFix)

	movzx	ecx, BYTE PTR ?g_bSetWaypointNumFix@@3_NA ; g_bSetWaypointNumFix
	test	ecx, ecx
	jne	SHORT $LN4@SetWaypoin

; 545  : 		curWaypoint	= curWaypoint->GetPrevWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _curWaypoint$[ebp], eax

; 546  : 	else

	jmp	SHORT $LN3@SetWaypoin
$LN4@SetWaypoin:

; 547  : 	    curWaypoint	= curWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _curWaypoint$[ebp], eax
$LN3@SetWaypoin:
	jmp	SHORT $LN6@SetWaypoin
$LN5@SetWaypoin:

; 548  : 
; 549  :    if (theRadar && curWaypoint)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN2@SetWaypoin
	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN2@SetWaypoin

; 550  :    {
; 551  : 		platform->curWaypoint->GetLocation (&rx, &ry, &rz);

	lea	edx, DWORD PTR _rz$[ebp]
	push	edx
	lea	eax, DWORD PTR _ry$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 552  : 	   theRadar->SetGroundPoint(rx, ry, rz);

	push	ecx
	movss	xmm0, DWORD PTR _rz$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
$LN2@SetWaypoin:

; 553  :    }
; 554  :    if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN1@SetWaypoin

; 555  : 	   OTWDriver.pCockpitManager->mpIcp->ClearStrings();

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings
$LN1@SetWaypoin:

; 556  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetWaypointNum@FireControlComputer@@QAEXH@Z ENDP	; FireControlComputer::SetWaypointNum
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 4
?SetStptMode@FireControlComputer@@QAEXW4FCCStptMode@1@@Z PROC ; FireControlComputer::SetStptMode
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 	if(platform == (SimVehicleClass*)SimDriver.GetPlayerAircraft()) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+140], eax
	jne	SHORT $LN2@SetStptMod

; 422  : 		mNewStptMode	= mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN2@SetStptMod:

; 423  : 	}
; 424  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetStptMode@FireControlComputer@@QAEXW4FCCStptMode@1@@Z ENDP ; FireControlComputer::SetStptMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_speed$ = -148						; size = 4
_wingBugY$ = -144					; size = 4
_wingBugX$ = -140					; size = 4
tv522 = -136						; size = 4
tv536 = -132						; size = 4
tv585 = -128						; size = 4
tv548 = -124						; size = 4
tv578 = -120						; size = 4
tv562 = -116						; size = 4
tv570 = -112						; size = 4
tv667 = -108						; size = 4
tv555 = -104						; size = 4
tv659 = -100						; size = 4
tv541 = -96						; size = 4
tv651 = -92						; size = 4
_alt$ = -88						; size = 4
_trig$ = -84						; size = 8
_dist$1 = -76						; size = 4
_locked$ = -72						; size = 4
_dsq$ = -68						; size = 4
_playerAC$ = -64					; size = 4
_x$ = -60						; size = 4
_dir$ = -56						; size = 4
_xPos$ = -52						; size = 4
_y$ = -48						; size = 4
_yPos$ = -44						; size = 4
_theRadar$ = -40					; size = 4
_lockedData$ = -36					; size = 4
_ang$2 = -32						; size = 4
_displayX$ = -28					; size = 4
_displayY$ = -24					; size = 4
_this$ = -20						; size = 4
_no$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_wing$ = 8						; size = 4
?Draw1WingmanGnd@FireControlComputer@@AAEXPAVAircraftClass@@@Z PROC ; FireControlComputer::Draw1WingmanGnd
; _this$ = ecx

; 1995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1996 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1997 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN14@Draw1Wingm
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN14@Draw1Wingm

; 1998 : 	{
; 1999 : 	if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN14@Draw1Wingm
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN14@Draw1Wingm

; 2000 : 		return;

	jmp	$LN16@Draw1Wingm
$LN14@Draw1Wingm:

; 2001 : 	}
; 2002 : 
; 2003 : 	//Cobra This is where the Digi draws his bugged Target
; 2004 : 	//Will make it distinguish between A/A and A/G
; 2005 :     float xPos, yPos, speed;
; 2006 : 	int alt = 0;

	mov	DWORD PTR _alt$[ebp], 0

; 2007 : 	float dir = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dir$[ebp], xmm0

; 2008 : 	float displayX = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2009 : 	float displayY = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2010 : 	float dsq = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dsq$[ebp], xmm0

; 2011 : 	float wingBugX = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wingBugX$[ebp], xmm0

; 2012 : 	float wingBugY = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wingBugY$[ebp], xmm0

; 2013 : 	float x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x$[ebp], xmm0

; 2014 : 	float y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y$[ebp], xmm0

; 2015 : 	char no[10]/*, thealt[20]*/;
; 2016 :     mlTrig trig;
; 2017 : 	
; 2018 :     SimObjectType *locked;
; 2019 :     RadarClass* theRadar = (RadarClass*)FindSensor (wing, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _wing$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 2020 : #if NO_REMOTE_BUGGED_TARGET
; 2021 : 	if (theRadar == NULL || ((locked = theRadar->CurrentTarget ()) == NULL)){ return; }

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN12@Draw1Wingm
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
	mov	DWORD PTR _locked$[ebp], eax
	cmp	DWORD PTR _locked$[ebp], 0
	jne	SHORT $LN13@Draw1Wingm
$LN12@Draw1Wingm:
	jmp	$LN16@Draw1Wingm
$LN13@Draw1Wingm:

; 2022 : #else
; 2023 :     if (((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget == NULL &&
; 2024 : 		(theRadar == NULL || (locked = theRadar->CurrentTarget ()) == NULL)) return;
; 2025 : #endif
; 2026 : 
; 2027 : 	if (theRadar->GetRadarModeR() != RadarClass::GM && theRadar->GetRadarModeR() != RadarClass::GMT){

	mov	eax, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN11@Draw1Wingm
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN11@Draw1Wingm

; 2028 : 		return;

	jmp	$LN16@Draw1Wingm
$LN11@Draw1Wingm:

; 2029 : 	}
; 2030 : 
; 2031 : #if NO_REMOTE_BUGGED_TARGET
; 2032 : 	FalconEntity *lockedData = locked->BaseData();

	mov	ecx, DWORD PTR _locked$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR _lockedData$[ebp], eax

; 2033 : 	xPos = lockedData->XPos();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _xPos$[ebp]

; 2034 : 	yPos = lockedData->YPos();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _yPos$[ebp]

; 2035 : 	alt  = FTOL(lockedData->ZPos()/1000.0f);

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv522[ebp]
	movss	xmm0, DWORD PTR tv522[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _alt$[ebp], eax

; 2036 : 	dir = lockedData->Yaw();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _dir$[ebp]

; 2037 : 	speed = lockedData->GetVt();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lockedData$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR _speed$[ebp]

; 2038 : #else
; 2039 : 	if (!((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget){
; 2040 : 		xPos = locked->BaseData()->XPos();
; 2041 : 		yPos = locked->BaseData()->YPos();
; 2042 : 		alt  = (int)locked->BaseData()->ZPos()/1000;
; 2043 : 		dir = locked->BaseData()->Yaw();
; 2044 : 		speed = locked->BaseData()->GetVt();
; 2045 : 	}
; 2046 : 	else {
; 2047 : 		xPos = ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->XPos();
; 2048 : 		yPos = ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->YPos();
; 2049 : 		alt  = (int)-((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->ZPos()/1000;
; 2050 : 		dir = ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->Yaw();
; 2051 : 		speed = 300.0f;
; 2052 : 	}
; 2053 : #endif
; 2054 : 
; 2055 : 	sprintf (no, "%d", wing->vehicleInUnit+1);

	mov	ecx, DWORD PTR _wing$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	eax, DWORD PTR _no$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2056 : 
; 2057 : 	//MI adopt for zoom
; 2058 : 	 if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN10@Draw1Wingm

; 2059 : 	 {
; 2060 : 		 //MI add in INS Drift
; 2061 : 		if(g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	SHORT $LN8@Draw1Wingm

; 2062 : 		{
; 2063 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@Draw1Wingm

; 2064 : 			{
; 2065 : 				xPos += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv536[ebp]
	movss	xmm0, DWORD PTR tv536[ebp]
	addss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 2066 : 				yPos += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv541[ebp]
	movss	xmm0, DWORD PTR tv541[ebp]
	addss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR _yPos$[ebp], xmm0
$LN8@Draw1Wingm:

; 2067 : 			}
; 2068 : 		}
; 2069 : 		 if(HSDZoom == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	jne	SHORT $LN7@Draw1Wingm

; 2070 : 		 {
; 2071 : 			 y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv548[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv548[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 2072 : 			 x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv555[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv555[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x$[ebp], xmm0

; 2073 : 		 }
; 2074 : 		 else

	jmp	$LN6@Draw1Wingm
$LN7@Draw1Wingm:

; 2075 : 		 {
; 2076 : 			 y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv562[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv562[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _y$[ebp], xmm0

; 2077 : 			 x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv570[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv570[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _x$[ebp], xmm0
$LN6@Draw1Wingm:

; 2078 : 		 }
; 2079 : 	 }
; 2080 : 	 else

	jmp	SHORT $LN5@Draw1Wingm
$LN10@Draw1Wingm:

; 2081 : 	 {
; 2082 : 		 y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv578[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv578[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 2083 : 		 x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv585[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv585[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x$[ebp], xmm0
$LN5@Draw1Wingm:

; 2084 : 	 }
; 2085 : 	mlSinCos (&trig, platform->Yaw());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2086 :     displayX = trig.cos * x - trig.sin * y;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2087 :     displayY = trig.sin * x + trig.cos * y;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2088 : 
; 2089 :     display->SetColor( GetMfdColor(MFD_UNKNOWN) );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2090 :     dsq = displayX * displayX + displayY * displayY;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	mulss	xmm0, DWORD PTR _displayX$[ebp]
	movss	xmm1, DWORD PTR _displayY$[ebp]
	mulss	xmm1, DWORD PTR _displayY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dsq$[ebp], xmm0

; 2091 :     if (dsq > 1.0f) { // off the display- so triange

	movss	xmm0, DWORD PTR _dsq$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN4@Draw1Wingm

; 2092 : 	float dist = (float)sqrt(dsq);

	push	ecx
	movss	xmm0, DWORD PTR _dsq$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$1[ebp]

; 2093 : 	displayX /= dist;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	divss	xmm0, DWORD PTR _dist$1[ebp]
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2094 : 	displayY /= dist;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	divss	xmm0, DWORD PTR _dist$1[ebp]
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2095 : 	display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2096 : 	dir = (float)atan2(displayY, displayX);

	cvtss2sd xmm0, DWORD PTR _displayX$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _displayY$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dir$[ebp]

; 2097 : 	display->AdjustRotationAboutOrigin (dir);

	push	ecx
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2098 : 	display->Tri(-0.05f, -0.05f, 0.0f, 0.0f, 0.05f, -0.05f);

	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 2099 : 	display->AdjustRotationAboutOrigin (-dir);

	movss	xmm0, DWORD PTR _dir$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2100 :     }
; 2101 :     else {

	jmp	$LN3@Draw1Wingm
$LN4@Draw1Wingm:

; 2102 : 	display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2103 : 	
; 2104 : 	float ang = dir - platform->Yaw();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv651[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp]
	subss	xmm0, DWORD PTR tv651[ebp]
	movss	DWORD PTR _ang$2[ebp], xmm0

; 2105 : 	if (ang >= 0.0)

	cvtss2sd xmm0, DWORD PTR _ang$2[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN2@Draw1Wingm

; 2106 : 	    ang = SCH_ANG_INC*(float)floor(ang/(SCH_ANG_INC * DTR));

	movss	xmm0, DWORD PTR _SCH_ANG_INC
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _ang$2[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?floor@@YAMM@Z				; floor
	add	esp, 4
	fstp	DWORD PTR tv659[ebp]
	movss	xmm0, DWORD PTR tv659[ebp]
	mulss	xmm0, DWORD PTR _SCH_ANG_INC
	movss	DWORD PTR _ang$2[ebp], xmm0

; 2107 : 	else

	jmp	SHORT $LN1@Draw1Wingm
$LN2@Draw1Wingm:

; 2108 : 	    ang = SCH_ANG_INC*(float)ceil(ang/(SCH_ANG_INC * DTR));

	movss	xmm0, DWORD PTR _SCH_ANG_INC
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _ang$2[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?ceil@@YAMM@Z				; ceil
	add	esp, 4
	fstp	DWORD PTR tv667[ebp]
	movss	xmm0, DWORD PTR tv667[ebp]
	mulss	xmm0, DWORD PTR _SCH_ANG_INC
	movss	DWORD PTR _ang$2[ebp], xmm0
$LN1@Draw1Wingm:

; 2109 : 	display->AdjustRotationAboutOrigin (ang * DTR);

	movss	xmm0, DWORD PTR _ang$2[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2110 : 	display->Circle(0.0F, 0.0F, g_fRadarScale * 0.035f);

	movss	xmm0, DWORD PTR ?g_fRadarScale@@3MA
	mulss	xmm0, DWORD PTR __real@3d0f5c29
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 2111 : 	display->AdjustRotationAboutOrigin (-ang * DTR);

	movss	xmm0, DWORD PTR _ang$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin
$LN3@Draw1Wingm:

; 2112 :     }
; 2113 : 
; 2114 : 	display->TextCenterVertical(0.0f, 0.08f, no);

	push	0
	lea	edx, DWORD PTR _no$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+76]
	call	edx

; 2115 : 	display->AdjustOriginInViewport (-displayX, -displayY);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN16@Draw1Wingm:

; 2116 : 
; 2117 : 	}//end function

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?Draw1WingmanGnd@FireControlComputer@@AAEXPAVAircraftClass@@@Z ENDP ; FireControlComputer::Draw1WingmanGnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_trig$ = -80						; size = 8
_dsq$1 = -72						; size = 4
tv347 = -68						; size = 4
tv339 = -64						; size = 4
tv332 = -60						; size = 4
tv325 = -56						; size = 4
tv318 = -52						; size = 4
tv313 = -48						; size = 4
tv248 = -44						; size = 4
_rdrData$ = -40						; size = 4
_sy$2 = -36						; size = 4
_sx$3 = -32						; size = 4
_displayX$4 = -28					; size = 4
_displayY$5 = -24					; size = 4
_y$6 = -20						; size = 4
_x$7 = -16						; size = 4
_playerAC$ = -12					; size = 4
_rdrObj$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawAIFF@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawAIFF
; _this$ = ecx

; 2561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 2562 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2563 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN10@DrawAIFF
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN10@DrawAIFF

; 2564 : 	{
; 2565 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN10@DrawAIFF
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN10@DrawAIFF

; 2566 : 			return;

	jmp	$LN12@DrawAIFF
$LN10@DrawAIFF:

; 2567 : 	}
; 2568 : 	
; 2569 :     //float xPos, yPos, dir, speed;
; 2570 :     mlTrig trig;
; 2571 : 	
; 2572 : 	SimObjectLocalData* rdrData;
; 2573 : 	SimObjectType* rdrObj = platform->targetList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+660]
	mov	DWORD PTR _rdrObj$[ebp], ecx
$LN9@DrawAIFF:

; 2574 : 
; 2575 :     while (rdrObj) 

	cmp	DWORD PTR _rdrObj$[ebp], 0
	je	$LN8@DrawAIFF

; 2576 : 	{
; 2577 : 		rdrData = rdrObj->localData;

	mov	edx, DWORD PTR _rdrObj$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _rdrData$[ebp], eax

; 2578 : 
; 2579 : 		if (rdrData->rdrY[0] > 1.0)

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _rdrData$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+104]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	$LN1@DrawAIFF

; 2580 : 			{
; 2581 : 			float x = rdrObj->BaseData()->XPos();

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _x$7[ebp]

; 2582 : 			float y = rdrObj->BaseData()->YPos();

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _y$6[ebp]

; 2583 : 
; 2584 : 				if(g_bINS && g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN5@DrawAIFF
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@DrawAIFF

; 2585 : 				{
; 2586 : 					if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN5@DrawAIFF

; 2587 : 					{
; 2588 : 						x += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv313[ebp]
	movss	xmm0, DWORD PTR tv313[ebp]
	addss	xmm0, DWORD PTR _x$7[ebp]
	movss	DWORD PTR _x$7[ebp], xmm0

; 2589 : 						y += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv318[ebp]
	movss	xmm0, DWORD PTR tv318[ebp]
	addss	xmm0, DWORD PTR _y$6[ebp]
	movss	DWORD PTR _y$6[ebp], xmm0
$LN5@DrawAIFF:

; 2590 : 					}
; 2591 : 				}
; 2592 : 
; 2593 : 				float sx;
; 2594 : 				float sy;
; 2595 : 				if(HSDZoom == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jne	SHORT $LN4@DrawAIFF

; 2596 : 				{
; 2597 : 					sy = (x - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv325[ebp]
	movss	xmm0, DWORD PTR _x$7[ebp]
	subss	xmm0, DWORD PTR tv325[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _sy$2[ebp], xmm0

; 2598 : 					sx = (y - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv332[ebp]
	movss	xmm0, DWORD PTR _y$6[ebp]
	subss	xmm0, DWORD PTR tv332[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _sx$3[ebp], xmm0

; 2599 : 				}
; 2600 : 				else

	jmp	$LN3@DrawAIFF
$LN4@DrawAIFF:

; 2601 : 				{
; 2602 : 					sy = (x - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv339[ebp]
	movss	xmm0, DWORD PTR _x$7[ebp]
	subss	xmm0, DWORD PTR tv339[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _sy$2[ebp], xmm0

; 2603 : 					sx = (y - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv347[ebp]
	movss	xmm0, DWORD PTR _y$6[ebp]
	subss	xmm0, DWORD PTR tv347[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _sx$3[ebp], xmm0
$LN3@DrawAIFF:

; 2604 : 				}
; 2605 : 				mlSinCos (&trig, platform->Yaw());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2606 : 				float displayX = trig.cos * sx - trig.sin * sy;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _sx$3[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _sy$2[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$4[ebp], xmm0

; 2607 : 				float displayY = trig.sin * sx + trig.cos * sy;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _sx$3[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _sy$2[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$5[ebp], xmm0

; 2608 : 
; 2609 : 				float dsq = displayX * displayX + displayY * displayY;

	movss	xmm0, DWORD PTR _displayX$4[ebp]
	mulss	xmm0, DWORD PTR _displayX$4[ebp]
	movss	xmm1, DWORD PTR _displayY$5[ebp]
	mulss	xmm1, DWORD PTR _displayY$5[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dsq$1[ebp], xmm0

; 2610 : 
; 2611 : 				
; 2612 : 				
; 2613 : 				if (dsq < 1.0f && rdrData->ata <= 60.0f * DTR)//Cobra ATA constraints 60 degrees

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _dsq$1[ebp]
	jbe	$LN1@DrawAIFF
	mov	eax, DWORD PTR _rdrData$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR [eax]
	jb	$LN1@DrawAIFF

; 2614 : 					{
; 2615 : 					if ( rdrData->interrogated && TeamInfo[platform->GetTeam()]->TStance(rdrObj->BaseData()->GetTeam()) == Allied)

	mov	ecx, DWORD PTR _rdrData$[ebp]
	cmp	DWORD PTR [ecx+156], 0
	je	$LN1@DrawAIFF
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv248[ebp], eax
	mov	edx, DWORD PTR tv248[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv248[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?TStance@TeamClass@@QAEHE@Z		; TeamClass::TStance
	cmp	eax, 1
	jne	$LN1@DrawAIFF

; 2616 : 						{
; 2617 : 						display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$5[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$4[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2618 : 						display->Circle(0, 0, 0.03f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+48]
	call	edx

; 2619 : 						display->AdjustOriginInViewport (-displayX, -displayY);

	movss	xmm0, DWORD PTR _displayY$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN1@DrawAIFF:

; 2620 : 						}
; 2621 : 					}
; 2622 : 				
; 2623 : 				
; 2624 : 				
; 2625 : 			}
; 2626 : 
; 2627 : 		rdrObj = rdrObj->next;

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _rdrObj$[ebp], edx

; 2628 : 	}

	jmp	$LN9@DrawAIFF
$LN8@DrawAIFF:
$LN12@DrawAIFF:

; 2629 : 
; 2630 : 	}//Close function

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAIFF@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawAIFF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_speed$ = -224						; size = 4
tv914 = -220						; size = 4
tv902 = -216						; size = 4
tv907 = -212						; size = 4
tv962 = -208						; size = 4
tv944 = -204						; size = 4
tv1122 = -200						; size = 4
tv1100 = -196						; size = 4
tv1242 = -192						; size = 4
tv957 = -188						; size = 4
tv1234 = -184						; size = 4
tv928 = -180						; size = 4
tv1226 = -176						; size = 4
tv1117 = -172						; size = 4
tv1166 = -168						; size = 4
tv1052 = -164						; size = 4
tv1159 = -160						; size = 4
tv1320 = -156						; size = 4
tv1151 = -152						; size = 4
tv951 = -148						; size = 4
tv1143 = -144						; size = 4
tv936 = -140						; size = 4
tv1136 = -136						; size = 4
tv1129 = -132						; size = 4
tv921 = -128						; size = 4
tv445 = -124						; size = 4
_dist$1 = -120						; size = 4
_dist$2 = -116						; size = 4
_locked$ = -112						; size = 4
_trig$ = -108						; size = 8
_WingX$ = -100						; size = 4
_xPos$ = -96						; size = 4
_yPos$ = -92						; size = 4
_theRadar$ = -88					; size = 4
_dsq$ = -84						; size = 4
_WingY$ = -80						; size = 4
_alt$ = -76						; size = 4
_lockedData$ = -72					; size = 4
_ang$3 = -68						; size = 4
_playerAC$ = -64					; size = 4
_dir$ = -60						; size = 4
_y$ = -56						; size = 4
_x$ = -52						; size = 4
_displayY$ = -48					; size = 4
_displayX$ = -44					; size = 4
_this$ = -40						; size = 4
_thealt$ = -36						; size = 20
_no$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_wing$ = 8						; size = 4
?Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z PROC ; FireControlComputer::Draw1Wingman
; _this$ = ecx

; 2120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2121 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2122 : 	//MI
; 2123 : 	if (g_bRealisticAvionics && g_bINS){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN26@Draw1Wingm
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN26@Draw1Wingm

; 2124 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF)){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN26@Draw1Wingm
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN26@Draw1Wingm

; 2125 : 			return;

	jmp	$LN28@Draw1Wingm
$LN26@Draw1Wingm:

; 2126 : 		}
; 2127 : 	}
; 2128 : 
; 2129 :     ShiAssert(wing != NULL);
; 2130 :     char no[10], thealt[20];
; 2131 :     mlTrig trig;
; 2132 :     static const float wingBugX = 0.05f;
; 2133 :     static const float wingBugY = 0.05f;
; 2134 : 
; 2135 : 	if (wing->mFaults->GetFault(FaultClass::dlnk_fault)){ return; }

	push	5
	mov	edx, DWORD PTR _wing$[ebp]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN25@Draw1Wingm
	jmp	$LN28@Draw1Wingm
$LN25@Draw1Wingm:

; 2136 : 
; 2137 : 	float x = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x$[ebp], xmm0

; 2138 : 	float y = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y$[ebp], xmm0

; 2139 : 	float WingX = wing->XPos();

	mov	ecx, DWORD PTR _wing$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _WingX$[ebp]

; 2140 : 	float WingY = wing->YPos();

	mov	ecx, DWORD PTR _wing$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _WingY$[ebp]

; 2141 : 	//MI changed
; 2142 : 	if(g_bRealisticAvionics){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN24@Draw1Wingm

; 2143 : 		//MI add in INS Drift
; 2144 : 		if(g_bINS){

	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN22@Draw1Wingm

; 2145 : 			if(playerAC){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN22@Draw1Wingm

; 2146 : 				WingX += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv902[ebp]
	movss	xmm0, DWORD PTR tv902[ebp]
	addss	xmm0, DWORD PTR _WingX$[ebp]
	movss	DWORD PTR _WingX$[ebp], xmm0

; 2147 : 				WingY += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv907[ebp]
	movss	xmm0, DWORD PTR tv907[ebp]
	addss	xmm0, DWORD PTR _WingY$[ebp]
	movss	DWORD PTR _WingY$[ebp], xmm0
$LN22@Draw1Wingm:

; 2148 : 			}
; 2149 : 		}
; 2150 : 
; 2151 : 		if(HSDZoom == 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jne	SHORT $LN21@Draw1Wingm

; 2152 : 			y = (WingX - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv914[ebp]
	movss	xmm0, DWORD PTR _WingX$[ebp]
	subss	xmm0, DWORD PTR tv914[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 2153 : 			x = (WingY - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv921[ebp]
	movss	xmm0, DWORD PTR _WingY$[ebp]
	subss	xmm0, DWORD PTR tv921[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _x$[ebp], xmm0

; 2154 : 		}
; 2155 : 		else {

	jmp	$LN20@Draw1Wingm
$LN21@Draw1Wingm:

; 2156 : 			y = (WingX - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv928[ebp]
	movss	xmm0, DWORD PTR _WingX$[ebp]
	subss	xmm0, DWORD PTR tv928[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _y$[ebp], xmm0

; 2157 : 			x = (WingY - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv936[ebp]
	movss	xmm0, DWORD PTR _WingY$[ebp]
	subss	xmm0, DWORD PTR tv936[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _x$[ebp], xmm0
$LN20@Draw1Wingm:

; 2158 : 		}
; 2159 : 	}
; 2160 : 	else {

	jmp	SHORT $LN19@Draw1Wingm
$LN24@Draw1Wingm:

; 2161 : 		y = (WingX - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv944[ebp]
	movss	xmm0, DWORD PTR _WingX$[ebp]
	subss	xmm0, DWORD PTR tv944[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 2162 : 		x = (WingY - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv951[ebp]
	movss	xmm0, DWORD PTR _WingY$[ebp]
	subss	xmm0, DWORD PTR tv951[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x$[ebp], xmm0
$LN19@Draw1Wingm:

; 2163 : 	}
; 2164 :     float dir = wing->Yaw() - platform->Yaw();

	mov	ecx, DWORD PTR _wing$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv957[ebp]
	movss	xmm0, DWORD PTR tv957[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv1320[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv962[ebp]
	movss	xmm0, DWORD PTR tv1320[ebp]
	subss	xmm0, DWORD PTR tv962[ebp]
	movss	DWORD PTR _dir$[ebp], xmm0

; 2165 : 	display->SetColor(GetMfdColor(MFD_DL_TEAM14));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 2166 :     mlSinCos (&trig, platform->Yaw());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2167 :     float displayX = trig.cos * x - trig.sin * y;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2168 :     float displayY = trig.sin * x + trig.cos * y;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2169 :     float dsq = displayX * displayX + displayY * displayY;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	mulss	xmm0, DWORD PTR _displayX$[ebp]
	movss	xmm1, DWORD PTR _displayY$[ebp]
	mulss	xmm1, DWORD PTR _displayY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dsq$[ebp], xmm0

; 2170 : 
; 2171 :     if (dsq > 1.0f) { // off the display - so a pointer

	movss	xmm0, DWORD PTR _dsq$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN18@Draw1Wingm

; 2172 : 		float dist = (float)sqrt(dsq);

	push	ecx
	movss	xmm0, DWORD PTR _dsq$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$2[ebp]

; 2173 : 		displayX /= dist;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	divss	xmm0, DWORD PTR _dist$2[ebp]
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2174 : 		displayY /= dist;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	divss	xmm0, DWORD PTR _dist$2[ebp]
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2175 : 		display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2176 : 		dir = (float)atan2(displayY, displayX);

	cvtss2sd xmm0, DWORD PTR _displayX$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _displayY$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dir$[ebp]

; 2177 : 		display->AdjustRotationAboutOrigin (dir);

	push	ecx
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2178 : 		display->Tri(-0.05f, -0.05f, 0.0f, 0.0f, 0.05f, -0.05f);

	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 2179 :     }
; 2180 :     else { // real thing

	jmp	$LN17@Draw1Wingm
$LN18@Draw1Wingm:

; 2181 : 		display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2182 : 		display->AdjustRotationAboutOrigin (dir);

	push	ecx
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2183 : 		display->Arc(0.00f, -0.1f, 0.05f, 180.0f * DTR, 359.0f * DTR); // arc bit

	push	ecx
	movss	xmm0, DWORD PTR __real@40c880df
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+52]
	call	edx

; 2184 : 		display->Line (0.0f, -0.07f, 0.0f, 0.0f); // line bit

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd8f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN17@Draw1Wingm:

; 2185 :     }
; 2186 :     display->AdjustRotationAboutOrigin(-dir);

	movss	xmm0, DWORD PTR _dir$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2187 : 	int alt = FTOL(-wing->ZPos());

	mov	ecx, DWORD PTR _wing$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1052[ebp]
	movss	xmm0, DWORD PTR tv1052[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _alt$[ebp], eax

; 2188 :     alt = (alt + 500) / 1000;

	mov	eax, DWORD PTR _alt$[ebp]
	add	eax, 500				; 000001f4H
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _alt$[ebp], eax

; 2189 :     sprintf (thealt, "%d", alt);

	mov	edx, DWORD PTR _alt$[ebp]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	eax, DWORD PTR _thealt$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2190 : 	display->TextCenterVertical(0.0f, -0.12f, thealt);

	push	0
	lea	ecx, DWORD PTR _thealt$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 2191 :     sprintf (no, "%d", wing->vehicleInUnit+1);

	mov	ecx, DWORD PTR _wing$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	eax, DWORD PTR _no$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2192 : 	display->TextCenterVertical(0.0f, 0.08f, no);

	push	0
	lea	ecx, DWORD PTR _no$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 2193 :     display->AdjustOriginInViewport (-displayX, -displayY);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2194 :     
; 2195 : 	// Cobra This is where the Digi draws his bugged Target
; 2196 : 	// Will make it distinguish between A/A and A/G
; 2197 : 
; 2198 :     float xPos, yPos, speed;
; 2199 :     RadarClass* theRadar = (RadarClass*)FindSensor (wing, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _wing$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 2200 : 	SimObjectType *locked = (theRadar == NULL) ? NULL :  theRadar->CurrentTarget();

	cmp	DWORD PTR _theRadar$[ebp], 0
	jne	SHORT $LN30@Draw1Wingm
	mov	DWORD PTR tv445[ebp], 0
	jmp	SHORT $LN31@Draw1Wingm
$LN30@Draw1Wingm:
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
	mov	DWORD PTR tv445[ebp], eax
$LN31@Draw1Wingm:
	mov	eax, DWORD PTR tv445[ebp]
	mov	DWORD PTR _locked$[ebp], eax

; 2201 :     if (
; 2202 : #if !NO_REMOTE_BUGGED_TARGET
; 2203 : 		static_cast<SimVehicleClass*>(wing)->sensorArray[1]->RemoteBuggedTarget == NULL && 
; 2204 : #endif
; 2205 : 		(theRadar == NULL || locked == NULL)
; 2206 : 	){

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN15@Draw1Wingm
	cmp	DWORD PTR _locked$[ebp], 0
	jne	SHORT $LN16@Draw1Wingm
$LN15@Draw1Wingm:

; 2207 : 		return;

	jmp	$LN28@Draw1Wingm
$LN16@Draw1Wingm:

; 2208 : 	}
; 2209 : 
; 2210 : #if NO_REMOTE_BUGGED_TARGET
; 2211 : 	if (locked->localData->ata > 60.0f*DTR){ return; }

	mov	ecx, DWORD PTR _locked$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	SHORT $LN14@Draw1Wingm
	jmp	$LN28@Draw1Wingm
$LN14@Draw1Wingm:

; 2212 : #else
; 2213 : 	//Cobra Is this within the ATA??
; 2214 : 	SimObjectType *ta = wing->targetPtr;
; 2215 : 	SimObjectLocalData* localData=NULL;
; 2216 : 	if (locked){
; 2217 : 		//no CTD on null pointers :)
; 2218 : 		localData = ta->localData;
; 2219 : 		if (localData->ata > 60*DTR){ return; }
; 2220 : 	}
; 2221 : 	else {
; 2222 : 		return;
; 2223 : 	}
; 2224 : #endif
; 2225 : 
; 2226 : #if NO_REMOTE_BUGGED_TARGET
; 2227 : 	FalconEntity *lockedData = locked->BaseData();

	mov	ecx, DWORD PTR _locked$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR _lockedData$[ebp], eax

; 2228 : 	if (lockedData)

	cmp	DWORD PTR _lockedData$[ebp], 0
	je	SHORT $LN13@Draw1Wingm

; 2229 : 	{
; 2230 : 		xPos = lockedData->XPos();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _xPos$[ebp]

; 2231 : 		yPos = lockedData->YPos();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _yPos$[ebp]

; 2232 : 		alt  = FTOL(lockedData->ZPos()/1000.0f);

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1100[ebp]
	movss	xmm0, DWORD PTR tv1100[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _alt$[ebp], eax

; 2233 : 		dir = lockedData->Yaw();

	mov	ecx, DWORD PTR _lockedData$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _dir$[ebp]

; 2234 : 		speed = lockedData->GetVt();

	mov	eax, DWORD PTR _lockedData$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lockedData$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR _speed$[ebp]
$LN13@Draw1Wingm:

; 2235 : 	}
; 2236 : #else
; 2237 : 	if (!((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget){
; 2238 : 		xPos = locked->BaseData()->XPos();
; 2239 : 		yPos = locked->BaseData()->YPos();
; 2240 : 		alt  = (int)locked->BaseData()->ZPos()/1000;
; 2241 : 		dir = locked->BaseData()->Yaw();
; 2242 : 		speed = locked->BaseData()->GetVt();
; 2243 : 	}
; 2244 : 	else {
; 2245 : 		xPos = ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->XPos();
; 2246 : 		yPos = ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->YPos();
; 2247 : 		alt  = (int)-((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->ZPos()/1000;
; 2248 : 		dir = ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->Yaw();
; 2249 : 		speed = 300.0f;//me123 it ctd's ((SimVehicleClass*)wing)->sensorArray[1]->RemoteBuggedTarget->GetVt();
; 2250 : 	}
; 2251 : #endif
; 2252 : 
; 2253 : 	//Cobra we don't want to draw A/G stuff and certainly not with A/A symbology
; 2254 : 	if ((theRadar->GetRadarModeR() != RadarClass::AA) || (abs(alt) <= 1)){

	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN11@Draw1Wingm
	mov	ecx, DWORD PTR _alt$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	cmp	eax, 1
	jg	SHORT $LN12@Draw1Wingm
$LN11@Draw1Wingm:

; 2255 : 		return;

	jmp	$LN28@Draw1Wingm
$LN12@Draw1Wingm:

; 2256 : 	}
; 2257 : 
; 2258 : 	//MI adopt for zoom
; 2259 : 	if(g_bRealisticAvionics){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN10@Draw1Wingm

; 2260 : 		 //MI add in INS Drift
; 2261 : 		if (g_bINS){

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN8@Draw1Wingm

; 2262 : 			if(playerAC){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@Draw1Wingm

; 2263 : 				xPos += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv1117[ebp]
	movss	xmm0, DWORD PTR tv1117[ebp]
	addss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 2264 : 				yPos += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv1122[ebp]
	movss	xmm0, DWORD PTR tv1122[ebp]
	addss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR _yPos$[ebp], xmm0
$LN8@Draw1Wingm:

; 2265 : 			}
; 2266 : 		}
; 2267 : 		if (HSDZoom == 0){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jne	SHORT $LN7@Draw1Wingm

; 2268 : 			y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1129[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv1129[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 2269 : 			x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1136[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv1136[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x$[ebp], xmm0

; 2270 : 		}
; 2271 : 		else {

	jmp	$LN6@Draw1Wingm
$LN7@Draw1Wingm:

; 2272 : 			y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1143[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv1143[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _y$[ebp], xmm0

; 2273 : 			x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1151[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv1151[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _x$[ebp], xmm0
$LN6@Draw1Wingm:

; 2274 : 		}
; 2275 : 	}
; 2276 : 	else {

	jmp	SHORT $LN5@Draw1Wingm
$LN10@Draw1Wingm:

; 2277 : 		 y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1159[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv1159[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 2278 : 		 x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1166[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv1166[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _x$[ebp], xmm0
$LN5@Draw1Wingm:

; 2279 : 	}
; 2280 : 	displayX = trig.cos * x - trig.sin * y;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2281 :     displayY = trig.sin * x + trig.cos * y;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2282 : 
; 2283 :     display->SetColor( GetMfdColor(MFD_UNKNOWN) );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2284 :     dsq = displayX * displayX + displayY * displayY;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	mulss	xmm0, DWORD PTR _displayX$[ebp]
	movss	xmm1, DWORD PTR _displayY$[ebp]
	mulss	xmm1, DWORD PTR _displayY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dsq$[ebp], xmm0

; 2285 :     if (dsq > 1.0f) { // off the display- so triange

	movss	xmm0, DWORD PTR _dsq$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN4@Draw1Wingm

; 2286 : 		float dist = (float)sqrt(dsq);

	push	ecx
	movss	xmm0, DWORD PTR _dsq$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$1[ebp]

; 2287 : 		displayX /= dist;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	divss	xmm0, DWORD PTR _dist$1[ebp]
	movss	DWORD PTR _displayX$[ebp], xmm0

; 2288 : 		displayY /= dist;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	divss	xmm0, DWORD PTR _dist$1[ebp]
	movss	DWORD PTR _displayY$[ebp], xmm0

; 2289 : 		display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2290 : 		dir = (float)atan2(displayY, displayX);

	cvtss2sd xmm0, DWORD PTR _displayX$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _displayY$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dir$[ebp]

; 2291 : 		display->AdjustRotationAboutOrigin (dir);

	push	ecx
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2292 : 		display->Tri(-0.05f, -0.05f, 0.0f, 0.0f, 0.05f, -0.05f);

	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 2293 : 		display->AdjustRotationAboutOrigin (-dir);

	movss	xmm0, DWORD PTR _dir$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2294 :     }
; 2295 :     else {

	jmp	$LN3@Draw1Wingm
$LN4@Draw1Wingm:

; 2296 : 		display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2297 : 		
; 2298 : 		float ang = dir - platform->Yaw();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv1226[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp]
	subss	xmm0, DWORD PTR tv1226[ebp]
	movss	DWORD PTR _ang$3[ebp], xmm0

; 2299 : 		if (ang >= 0.0){

	cvtss2sd xmm0, DWORD PTR _ang$3[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN2@Draw1Wingm

; 2300 : 			ang = SCH_ANG_INC*(float)floor(ang/(SCH_ANG_INC * DTR));

	movss	xmm0, DWORD PTR _SCH_ANG_INC
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _ang$3[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?floor@@YAMM@Z				; floor
	add	esp, 4
	fstp	DWORD PTR tv1234[ebp]
	movss	xmm0, DWORD PTR tv1234[ebp]
	mulss	xmm0, DWORD PTR _SCH_ANG_INC
	movss	DWORD PTR _ang$3[ebp], xmm0

; 2301 : 		}
; 2302 : 		else {

	jmp	SHORT $LN1@Draw1Wingm
$LN2@Draw1Wingm:

; 2303 : 			ang = SCH_ANG_INC*(float)ceil(ang/(SCH_ANG_INC * DTR));

	movss	xmm0, DWORD PTR _SCH_ANG_INC
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _ang$3[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?ceil@@YAMM@Z				; ceil
	add	esp, 4
	fstp	DWORD PTR tv1242[ebp]
	movss	xmm0, DWORD PTR tv1242[ebp]
	mulss	xmm0, DWORD PTR _SCH_ANG_INC
	movss	DWORD PTR _ang$3[ebp], xmm0
$LN1@Draw1Wingm:

; 2304 : 		}
; 2305 : 		display->AdjustRotationAboutOrigin (ang * DTR);

	movss	xmm0, DWORD PTR _ang$3[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 2306 : 		display->Line(-wingBugX, 0.00f, -wingBugX, wingBugY);

	push	ecx
	movss	xmm0, DWORD PTR ?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2307 : 		display->Line(-wingBugX, wingBugY,  wingBugX, wingBugY);

	push	ecx
	movss	xmm0, DWORD PTR ?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2308 : 		display->Line( wingBugX, wingBugY,  wingBugX, 0.00f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?wingBugX@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2309 : 		display->Line(/*-wingBugX,*/0.00f, 0.10f, /*-wingBugY,*/ 0.00f, wingBugY /*DD_LENGTH*speed/SCH_FACT */);

	push	ecx
	movss	xmm0, DWORD PTR ?wingBugY@?7??Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2310 : 		display->AdjustRotationAboutOrigin (-ang * DTR);

	movss	xmm0, DWORD PTR _ang$3[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin
$LN3@Draw1Wingm:

; 2311 :     }
; 2312 :     sprintf (thealt, "%d", abs(alt));

	mov	edx, DWORD PTR _alt$[ebp]
	push	edx
	call	_abs
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	eax, DWORD PTR _thealt$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2313 : 	display->TextCenterVertical(0.0f, -0.12f, thealt);

	push	0
	lea	ecx, DWORD PTR _thealt$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 2314 : 	display->TextCenterVertical(0.0f, 0.08f, no);

	push	0
	lea	ecx, DWORD PTR _no$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 2315 : 	display->AdjustOriginInViewport (-displayX, -displayY);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN28@Draw1Wingm:

; 2316 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z ENDP ; FireControlComputer::Draw1Wingman
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -16					; size = 4
_wingman$1 = -12					; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
?DrawWingmen@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawWingmen
; _this$ = ecx

; 1968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1969 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1970 : 	//MI
; 1971 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN10@DrawWingme
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN10@DrawWingme

; 1972 : 	{
; 1973 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN10@DrawWingme
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN10@DrawWingme

; 1974 : 			return;

	jmp	$LN11@DrawWingme
$LN10@DrawWingme:

; 1975 : 	}
; 1976 : 
; 1977 : 	if (((AircraftClass*)platform)->mFaults->GetFault(FaultClass::dlnk_fault) ||
; 1978 : 		!((AircraftClass*)platform)->HasPower(AircraftClass::DLPower))

	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN7@DrawWingme
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	SHORT $LN8@DrawWingme
$LN7@DrawWingme:

; 1979 : 		return;

	jmp	$LN11@DrawWingme
$LN8@DrawWingme:

; 1980 : 	//Cobra 
; 1981 : 	for (int i = 0; i < 4/*platform->GetCampaignObject()->NumberOfComponents()*/; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@DrawWingme
$LN5@DrawWingme:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN6@DrawWingme:
	cmp	DWORD PTR _i$2[ebp], 4
	jge	SHORT $LN11@DrawWingme

; 1982 : 		if (i == platform->vehicleInUnit) continue; // this is us

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	DWORD PTR _i$2[ebp], edx
	jne	SHORT $LN3@DrawWingme
	jmp	SHORT $LN5@DrawWingme
$LN3@DrawWingme:

; 1983 : 		AircraftClass *wingman = (AircraftClass *)platform->GetCampaignObject()->GetComponentNumber(i);

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _wingman$1[ebp], eax

; 1984 : 		if (wingman && !IsHsdState(HSDNOADLNK) ){

	cmp	DWORD PTR _wingman$1[ebp], 0
	je	SHORT $LN2@DrawWingme
	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN2@DrawWingme

; 1985 : 			Draw1Wingman(wingman);//Cobra added HSDNOADLINK here

	mov	edx, DWORD PTR _wingman$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Draw1Wingman@FireControlComputer@@AAEXPAVAircraftClass@@@Z ; FireControlComputer::Draw1Wingman
$LN2@DrawWingme:

; 1986 : 		}
; 1987 : 		if (wingman && !IsHsdState(HSDNOGNDLNK) ){

	cmp	DWORD PTR _wingman$1[ebp], 0
	je	SHORT $LN1@DrawWingme
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN1@DrawWingme

; 1988 : 			Draw1WingmanGnd(wingman);//Cobra

	mov	eax, DWORD PTR _wingman$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Draw1WingmanGnd@FireControlComputer@@AAEXPAVAircraftClass@@@Z ; FireControlComputer::Draw1WingmanGnd
$LN1@DrawWingme:

; 1989 : 		}
; 1990 : 	}

	jmp	$LN5@DrawWingme
$LN11@DrawWingme:

; 1991 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawWingmen@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawWingmen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_trig$ = -100						; size = 8
_speed$ = -92						; size = 4
tv533 = -88						; size = 4
tv525 = -84						; size = 4
tv517 = -80						; size = 4
_dir$ = -76						; size = 4
tv472 = -72						; size = 4
tv465 = -68						; size = 4
tv457 = -64						; size = 4
tv449 = -60						; size = 4
tv442 = -56						; size = 4
tv435 = -52						; size = 4
tv428 = -48						; size = 4
tv423 = -44						; size = 4
_theRadar$ = -40					; size = 4
_y$1 = -36						; size = 4
_x$2 = -32						; size = 4
_yPos$ = -28						; size = 4
_xPos$ = -24						; size = 4
_playerAC$ = -20					; size = 4
_displayX$3 = -16					; size = 4
_displayY$4 = -12					; size = 4
_ang$5 = -8						; size = 4
_this$ = -4						; size = 4
?DrawBuggedTarget@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::DrawBuggedTarget
; _this$ = ecx

; 1887 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 1888 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1889 : 	//MI
; 1890 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN11@DrawBugged
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN11@DrawBugged

; 1891 : 	{
; 1892 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN11@DrawBugged
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN11@DrawBugged

; 1893 : 			return;

	jmp	$LN13@DrawBugged
$LN11@DrawBugged:

; 1894 : 	}
; 1895 : 	
; 1896 :     float xPos, yPos, dir, speed;
; 1897 :     mlTrig trig;
; 1898 : 	
; 1899 : 	// MD -- 20040113: need RadarDopplerClass ptr to check flags for STT
; 1900 :     RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 1901 :     if (theRadar && theRadar->GetBuggedData(&xPos, &yPos, &dir, &speed)) 

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	$LN10@DrawBugged
	lea	ecx, DWORD PTR _speed$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	lea	eax, DWORD PTR _yPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+208]
	call	edx
	test	eax, eax
	je	$LN10@DrawBugged

; 1902 : 	{
; 1903 : 		//MI add in INS Drift
; 1904 : 		if(g_bINS && g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN8@DrawBugged
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN8@DrawBugged

; 1905 : 		{
; 1906 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@DrawBugged

; 1907 : 			{
; 1908 : 				xPos += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv423[ebp]
	movss	xmm0, DWORD PTR tv423[ebp]
	addss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1909 : 				yPos += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv428[ebp]
	movss	xmm0, DWORD PTR tv428[ebp]
	addss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR _yPos$[ebp], xmm0
$LN8@DrawBugged:

; 1910 : 			}
; 1911 : 		}
; 1912 : 		float x, y;
; 1913 : 		//MI changed
; 1914 : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN7@DrawBugged

; 1915 : 		{
; 1916 : 			if(HSDZoom == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	jne	SHORT $LN6@DrawBugged

; 1917 : 			{
; 1918 : 				y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv435[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv435[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y$1[ebp], xmm0

; 1919 : 				x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv442[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv442[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x$2[ebp], xmm0

; 1920 : 			}
; 1921 : 			else

	jmp	$LN5@DrawBugged
$LN6@DrawBugged:

; 1922 : 			{
; 1923 : 				y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv449[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv449[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _y$1[ebp], xmm0

; 1924 : 				x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv457[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv457[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _x$2[ebp], xmm0
$LN5@DrawBugged:

; 1925 : 			}
; 1926 : 		}
; 1927 : 		else

	jmp	SHORT $LN4@DrawBugged
$LN7@DrawBugged:

; 1928 : 		{
; 1929 : 			y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv465[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv465[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y$1[ebp], xmm0

; 1930 : 			x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv472[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv472[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x$2[ebp], xmm0
$LN4@DrawBugged:

; 1931 : 		}
; 1932 : 		
; 1933 : 		mlSinCos (&trig, platform->Yaw());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1934 : 		float displayX = trig.cos * x - trig.sin * y;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x$2[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y$1[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$3[ebp], xmm0

; 1935 : 		float displayY = trig.sin * x + trig.cos * y;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x$2[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y$1[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$4[ebp], xmm0

; 1936 : 
; 1937 : 		// MD -- 20040113: Draw cursor at bugged target if the radar is in STT mode
; 1938 : 		if (theRadar->IsSet(RadarDopplerClass::STTingTarget))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN3@DrawBugged

; 1939 : 		{
; 1940 : 			static const float GCURS_LEN = 0.05f;
; 1941 : 			static const float GCURS_OFF = 0.05f;
; 1942 : 
; 1943 : 			display->Line (displayX - GCURS_OFF, displayY - GCURS_LEN, 
; 1944 : 				displayX - GCURS_OFF, displayY + GCURS_LEN);

	movss	xmm0, DWORD PTR _displayY$4[ebp]
	addss	xmm0, DWORD PTR ?GCURS_LEN@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$3[ebp]
	subss	xmm0, DWORD PTR ?GCURS_OFF@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$4[ebp]
	subss	xmm0, DWORD PTR ?GCURS_LEN@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$3[ebp]
	subss	xmm0, DWORD PTR ?GCURS_OFF@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1945 : 			display->Line (displayX + GCURS_OFF, displayY - GCURS_LEN, 
; 1946 : 				displayX + GCURS_OFF, displayY + GCURS_LEN);		

	movss	xmm0, DWORD PTR _displayY$4[ebp]
	addss	xmm0, DWORD PTR ?GCURS_LEN@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$3[ebp]
	addss	xmm0, DWORD PTR ?GCURS_OFF@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$4[ebp]
	subss	xmm0, DWORD PTR ?GCURS_LEN@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$3[ebp]
	addss	xmm0, DWORD PTR ?GCURS_OFF@?BN@??DrawBuggedTarget@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawBugged:

; 1947 : 		}
; 1948 : 
; 1949 : 		display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$3[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1950 : 		
; 1951 : 		float ang = dir - platform->Yaw();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv517[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp]
	subss	xmm0, DWORD PTR tv517[ebp]
	movss	DWORD PTR _ang$5[ebp], xmm0

; 1952 : 		if (ang >= 0.0)

	cvtss2sd xmm0, DWORD PTR _ang$5[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN2@DrawBugged

; 1953 : 			ang = SCH_ANG_INC*(float)floor(ang/(SCH_ANG_INC * DTR));

	movss	xmm0, DWORD PTR _SCH_ANG_INC
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _ang$5[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?floor@@YAMM@Z				; floor
	add	esp, 4
	fstp	DWORD PTR tv525[ebp]
	movss	xmm0, DWORD PTR tv525[ebp]
	mulss	xmm0, DWORD PTR _SCH_ANG_INC
	movss	DWORD PTR _ang$5[ebp], xmm0

; 1954 : 		else

	jmp	SHORT $LN1@DrawBugged
$LN2@DrawBugged:

; 1955 : 			ang = SCH_ANG_INC*(float)ceil(ang/(SCH_ANG_INC * DTR));

	movss	xmm0, DWORD PTR _SCH_ANG_INC
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _ang$5[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?ceil@@YAMM@Z				; ceil
	add	esp, 4
	fstp	DWORD PTR tv533[ebp]
	movss	xmm0, DWORD PTR tv533[ebp]
	mulss	xmm0, DWORD PTR _SCH_ANG_INC
	movss	DWORD PTR _ang$5[ebp], xmm0
$LN1@DrawBugged:

; 1956 : 		display->AdjustRotationAboutOrigin (ang * DTR);

	movss	xmm0, DWORD PTR _ang$5[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1957 : 		
; 1958 : 		display->Circle(0.0F, 0.0F, trackScale);

	push	ecx
	movss	xmm0, DWORD PTR _trackScale
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1959 : 		display->Tri (0.0f, trackScale, trackTriH, -trackTriV, -trackTriH, -trackTriV);

	movss	xmm0, DWORD PTR _trackTriV
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _trackTriH
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _trackTriV
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _trackTriH
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _trackScale
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1960 : 		display->Line (0.0f, trackScale, 0.0f, trackScale + DD_LENGTH*speed/SCH_FACT);

	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR _speed$[ebp]
	divss	xmm0, DWORD PTR _SCH_FACT
	addss	xmm0, DWORD PTR _trackScale
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _trackScale
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1961 : 		display->AdjustRotationAboutOrigin (-ang * DTR);

	movss	xmm0, DWORD PTR _ang$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1962 : 		display->AdjustOriginInViewport (-displayX, -displayY);

	movss	xmm0, DWORD PTR _displayY$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$3[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN10@DrawBugged:
$LN13@DrawBugged:

; 1963 : 	}
; 1964 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawBuggedTarget@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::DrawBuggedTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_trig$1 = -32						; size = 8
tv259 = -24						; size = 4
_playerAC$ = -20					; size = 4
_cone$2 = -16						; size = 4
_scale$3 = -12						; size = 4
_theRadar$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawScanVolume@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::DrawScanVolume
; _this$ = ecx

; 1849 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1850 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1851 : 	//MI
; 1852 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN2@DrawScanVo
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN2@DrawScanVo

; 1853 : 	{
; 1854 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN2@DrawScanVo
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN2@DrawScanVo

; 1855 : 			return;

	jmp	$LN4@DrawScanVo
$LN2@DrawScanVo:

; 1856 : 	}
; 1857 : 
; 1858 : 	RadarClass* theRadar = (RadarClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 1859 : 
; 1860 :    if (theRadar && theRadar->IsOn())

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	$LN1@DrawScanVo
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	test	eax, eax
	je	$LN1@DrawScanVo

; 1861 :    {
; 1862 :       float cone = theRadar->GetVolume();

	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+200]
	call	eax
	fstp	DWORD PTR _cone$2[ebp]

; 1863 :       float scale = theRadar->GetRange() / HSDRange;

	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+196]
	call	eax
	fstp	DWORD PTR tv259[ebp]
	movss	xmm0, DWORD PTR tv259[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _scale$3[ebp], xmm0

; 1864 :       mlTrig trig;
; 1865 :       mlSinCos (&trig, cone);

	push	ecx
	movss	xmm0, DWORD PTR _cone$2[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trig$1[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1866 :       display->AdjustRotationAboutOrigin(theRadar->SeekerAz());

	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?SeekerAz@SensorClass@@QAEMXZ		; SensorClass::SeekerAz
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1867 :       display->Line (0.0F,  0.0F,  trig.sin * scale, trig.cos * scale);

	movss	xmm0, DWORD PTR _trig$1[ebp+4]
	mulss	xmm0, DWORD PTR _scale$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _trig$1[ebp]
	mulss	xmm0, DWORD PTR _scale$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1868 :       display->Line (0.0F,  0.0F, -trig.sin * scale, trig.cos * scale);

	movss	xmm0, DWORD PTR _trig$1[ebp+4]
	mulss	xmm0, DWORD PTR _scale$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _trig$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1869 :       //display->AdjustRotationAboutOrigin(270*DTR);
; 1870 : 	  display->AdjustRotationAboutOrigin(272*DTR);			//Wombat778 11-13-2003 make the arc appear centered.  This is a hack to fix a bug in the arc code, but at least it is symmetrical

	push	ecx
	movss	xmm0, DWORD PTR __real@4097e9d7
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1871 :       display->Arc(0.0f, 0.0f, scale, 2*PI - cone, 2*PI);

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@40c90fdb
	subss	xmm0, DWORD PTR _cone$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$3[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 1872 :       display->Arc(0.0f, 0.0f, scale, 0.0f, cone);

	push	ecx
	movss	xmm0, DWORD PTR _cone$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$3[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 1873 : // 2002-03-08 MN This was missing (was present in V1.071) and messed up FLOT and Bullseye on HSD
; 1874 : 	  display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin
$LN1@DrawScanVo:
$LN4@DrawScanVo:

; 1875 :    }
; 1876 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawScanVolume@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::DrawScanVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -20					; size = 4
_cursorX$ = -16						; size = 4
_cursorY$ = -12						; size = 4
_this$ = -8						; size = 4
_theRadar$ = -4						; size = 4
?DrawGhostCursor@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::DrawGhostCursor
; _this$ = ecx

; 1804 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1805 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1806 : 	RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 1807 : 	//MI
; 1808 : 	if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN3@DrawGhostC

; 1809 : 	{
; 1810 : 		if(g_bINS)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN4@DrawGhostC

; 1811 : 		{
; 1812 : 			if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN4@DrawGhostC
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN4@DrawGhostC

; 1813 : 				return;

	jmp	$LN7@DrawGhostC
$LN4@DrawGhostC:

; 1814 : 		}
; 1815 : 		// MD -- 20040113: supress ghost cursors with STT mode; we'll draw the cursor latched on to the bugged target instead
; 1816 : 		if(theRadar && ((theRadar->GetRadarMode() == RadarClass::STBY) || theRadar->IsSet(RadarDopplerClass::STTingTarget)))

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN3@DrawGhostC
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 1
	je	SHORT $LN2@DrawGhostC
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN3@DrawGhostC
$LN2@DrawGhostC:

; 1817 : 			return;

	jmp	$LN7@DrawGhostC
$LN3@DrawGhostC:

; 1818 : 	}
; 1819 : 
; 1820 : float cursorX, cursorY;
; 1821 : static const float GCURS_LEN = 0.05f;
; 1822 : static const float GCURS_OFF = 0.05f;
; 1823 : 	
; 1824 : 	
; 1825 :    if (theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	$LN1@DrawGhostC

; 1826 :    {
; 1827 :       theRadar->GetCursorPosition (&cursorY, &cursorX);

	lea	ecx, DWORD PTR _cursorX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cursorY$[ebp]
	push	edx
	mov	eax, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax

; 1828 : 	  cursorX /= HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _cursorX$[ebp], xmm0

; 1829 : 	  cursorY /= HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _cursorY$[ebp], xmm0

; 1830 : 	  
; 1831 : 	  //MI add in INS Drift
; 1832 : 	  /*if(g_bINS && g_bRealisticAvionics)
; 1833 : 	  {
; 1834 : 		  if(playerAC)
; 1835 : 		  {
; 1836 : 			  cursorX += playerAC->GetINSLatDrift();
; 1837 : 			  cursorY += playerAC->GetINSLongDrift();
; 1838 : 		  }
; 1839 : 	  }*/
; 1840 : 
; 1841 :       display->Line (cursorX - GCURS_OFF, cursorY - GCURS_LEN, 
; 1842 : 		    cursorX - GCURS_OFF, cursorY + GCURS_LEN);

	movss	xmm0, DWORD PTR _cursorY$[ebp]
	addss	xmm0, DWORD PTR ?GCURS_LEN@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	subss	xmm0, DWORD PTR ?GCURS_OFF@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	subss	xmm0, DWORD PTR ?GCURS_LEN@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	subss	xmm0, DWORD PTR ?GCURS_OFF@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1843 :       display->Line (cursorX + GCURS_OFF, cursorY - GCURS_LEN, 
; 1844 : 		    cursorX + GCURS_OFF, cursorY + GCURS_LEN);

	movss	xmm0, DWORD PTR _cursorY$[ebp]
	addss	xmm0, DWORD PTR ?GCURS_LEN@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	addss	xmm0, DWORD PTR ?GCURS_OFF@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	subss	xmm0, DWORD PTR ?GCURS_LEN@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	addss	xmm0, DWORD PTR ?GCURS_OFF@?M@??DrawGhostCursor@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN1@DrawGhostC:
$LN7@DrawGhostC:

; 1845 :    }
; 1846 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawGhostCursor@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::DrawGhostCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -24					; size = 4
_theRadar$ = -20					; size = 4
_cursorX$ = -16						; size = 4
_cursorY$ = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?DrawBullseye@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawBullseye
; _this$ = ecx

; 1624 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1625 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1626 : 	//MI
; 1627 : 	/*if(g_bRealisticAvionics && g_bINS)
; 1628 : 	{
; 1629 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))
; 1630 : 			return;
; 1631 : 	}*/
; 1632 : 
; 1633 : 	RadarClass* theRadar = (RadarClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 1634 : 	float cursorX, cursorY;
; 1635 : 
; 1636 :     display->SetColor(GetMfdColor(MFD_BULLSEYE));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1637 :    if (theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	$LN2@DrawBullse

; 1638 :    {
; 1639 :       theRadar->GetCursorPosition (&cursorX, &cursorY);

	lea	ecx, DWORD PTR _cursorY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cursorX$[ebp]
	push	edx
	mov	eax, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax

; 1640 : 	  //MI
; 1641 : 	  if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN9@DrawBullse

; 1642 : 		DrawBullseyeData(display, cursorX, cursorY);

	push	ecx
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?DrawBullseyeData@@YAXPAVVirtualDisplay@@MM@Z ; DrawBullseyeData
	add	esp, 12					; 0000000cH

; 1643 : 	  else

	jmp	$LN2@DrawBullse
$LN9@DrawBullse:

; 1644 : 	  {
; 1645 : 		  if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&
; 1646 : 			  OTWDriver.pCockpitManager->mpIcp->ShowBullseyeInfo)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN7@DrawBullse
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN7@DrawBullse
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	movzx	ecx, BYTE PTR [eax+300]
	test	ecx, ecx
	je	SHORT $LN7@DrawBullse

; 1647 : 		  {
; 1648 : 			  DrawBullseyeCircle(display, cursorX, cursorY);

	push	ecx
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?DrawBullseyeCircle@@YAXPAVVirtualDisplay@@MM@Z ; DrawBullseyeCircle

; 1649 : 			  DrawCursorBullseyeData(display, cursorX, cursorY);

	add	esp, 8
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?DrawCursorBullseyeData@@YAXPAVVirtualDisplay@@MM@Z ; DrawCursorBullseyeData
	add	esp, 12					; 0000000cH

; 1650 : 		  }
; 1651 : 		  else

	jmp	SHORT $LN6@DrawBullse
$LN7@DrawBullse:

; 1652 : 		  {
; 1653 : 			  DrawReference(playerAC);

	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawReference@MfdDrawable@@QAEXPAVAircraftClass@@@Z ; MfdDrawable::DrawReference

; 1654 : 			  DrawSteerPointCursorData(display, platform, cursorX, cursorY);

	push	ecx
	movss	xmm0, DWORD PTR _cursorY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cursorX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?DrawSteerPointCursorData@@YAXPAVVirtualDisplay@@PAVFalconEntity@@MM@Z ; DrawSteerPointCursorData
	add	esp, 16					; 00000010H
$LN6@DrawBullse:

; 1655 : 		  }
; 1656 : 		  //Booster 15/09/2004 - Draw Pull Up cross on MFD-SMS if ground Collision
; 1657 :    		  if (playerAC->mFaults->GetFault(alt_low))

	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN5@DrawBullse

; 1658 : 			 DrawRedBreak(display);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRedBreak@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z ; MfdDrawable::DrawRedBreak
$LN5@DrawBullse:

; 1659 : 
; 1660 : 		  // RV - I-Hawk
; 1661 : 		  // Check, if 1 of the MFDs is showing TGP and the attitude warning is set, show it... 
; 1662 : 		  // (works on all MFDs and not only here)
; 1663 : 		  for ( int i = 0; i < 4; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@DrawBullse
$LN3@DrawBullse:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@DrawBullse:
	cmp	DWORD PTR _i$1[ebp], 4
	jge	SHORT $LN2@DrawBullse

; 1664 : 		  {
; 1665 : 			  if ( (MfdDisplay[i])->GetTGPWarning() && (MfdDisplay[i])->CurMode() == MFDClass::TGPMode )

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax*4]
	call	?GetTGPWarning@MFDClass@@QAEHXZ		; MFDClass::GetTGPWarning
	test	eax, eax
	je	SHORT $LN1@DrawBullse
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx*4]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 8
	jne	SHORT $LN1@DrawBullse

; 1666 : 			  { 
; 1667 : 				  TGPAttitudeWarning(display);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TGPAttitudeWarning@MfdDrawable@@QAEXPAVVirtualDisplay@@@Z ; MfdDrawable::TGPAttitudeWarning

; 1668 : 				  break;

	jmp	SHORT $LN2@DrawBullse
$LN1@DrawBullse:

; 1669 : 			  }
; 1670 : 		  }

	jmp	SHORT $LN3@DrawBullse
$LN2@DrawBullse:

; 1671 : 	  }
; 1672 :    }
; 1673 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawBullseye@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawBullseye
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
tv387 = -116						; size = 4
tv416 = -112						; size = 4
_myX$ = -108						; size = 4
tv392 = -104						; size = 4
tv461 = -100						; size = 4
_myZ$ = -96						; size = 4
tv454 = -92						; size = 4
_myY$ = -88						; size = 4
tv421 = -84						; size = 4
tv382 = -80						; size = 4
_trig$ = -76						; size = 8
_z2$ = -68						; size = 4
_targetdist$1 = -64					; size = 4
_displayX$ = -60					; size = 4
_displayY$ = -56					; size = 4
_rr$2 = -52						; size = 4
_playerAC$ = -48					; size = 4
_y2$ = -44						; size = 4
_x2$ = -40						; size = 4
_gp$ = -36						; size = 4
_this$ = -32						; size = 4
_savem$3 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?DrawPPThreats@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawPPThreats
; _this$ = ecx

; 1677 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1679 : 	//MI
; 1680 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN18@DrawPPThre
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN18@DrawPPThre

; 1681 : 	{
; 1682 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN18@DrawPPThre
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN18@DrawPPThre

; 1683 : 			return;

	jmp	$LN20@DrawPPThre
$LN18@DrawPPThre:

; 1684 : 	}
; 1685 : 
; 1686 :     mlTrig trig;
; 1687 :     float x2, y2, z2;
; 1688 :     float displayX, displayY;
; 1689 :     // we now use our own list of preplanned targets.
; 1690 :     // will consolidate with HTS soon.
; 1691 :     GroundListElement *gp;
; 1692 :     mlSinCos (&trig, platform->Yaw());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1693 :     float myX, myY, myZ;
; 1694 :     myX = platform->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _myX$[ebp]

; 1695 :     myY = platform->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _myY$[ebp]

; 1696 :     myZ = platform->ZPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _myZ$[ebp]

; 1697 :     UpdatePlanned();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlanned@FireControlComputer@@QAEXXZ ; FireControlComputer::UpdatePlanned

; 1698 :     // Draw all known emmitters
; 1699 :     for (gp = GetFirstGroundElement(); gp; gp = gp->GetNext()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ; FireControlComputer::GetFirstGroundElement
	mov	DWORD PTR _gp$[ebp], eax
	jmp	SHORT $LN17@DrawPPThre
$LN16@DrawPPThre:
	mov	ecx, DWORD PTR _gp$[ebp]
	call	?GetNext@GroundListElement@@QAEPAV1@XZ	; GroundListElement::GetNext
	mov	DWORD PTR _gp$[ebp], eax
$LN17@DrawPPThre:
	cmp	DWORD PTR _gp$[ebp], 0
	je	$LN15@DrawPPThre

; 1700 : 	gp->HandoffBaseObject();

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?HandoffBaseObject@GroundListElement@@QAEXXZ ; GroundListElement::HandoffBaseObject

; 1701 : 	if (gp->BaseObject() == NULL) continue; // probably dead.

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	test	eax, eax
	jne	SHORT $LN14@DrawPPThre
	jmp	SHORT $LN16@DrawPPThre
$LN14@DrawPPThre:

; 1702 : 	y2 = (gp->BaseObject()->XPos() - myX) * FT_TO_NM;

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv382[ebp]
	movss	xmm0, DWORD PTR tv382[ebp]
	subss	xmm0, DWORD PTR _myX$[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _y2$[ebp], xmm0

; 1703 : 	x2 = (gp->BaseObject()->YPos() - myY) * FT_TO_NM;

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv387[ebp]
	movss	xmm0, DWORD PTR tv387[ebp]
	subss	xmm0, DWORD PTR _myY$[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _x2$[ebp], xmm0

; 1704 : 	z2 = (gp->BaseObject()->ZPos() - myZ) * FT_TO_NM;

	mov	ecx, DWORD PTR _gp$[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv392[ebp]
	movss	xmm0, DWORD PTR tv392[ebp]
	subss	xmm0, DWORD PTR _myZ$[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _z2$[ebp], xmm0

; 1705 : 
; 1706 : 	float targetdist = sqrt(x2*x2 + y2*y2 + z2*z2);

	movss	xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _z2$[ebp]
	mulss	xmm1, DWORD PTR _z2$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _targetdist$1[ebp]

; 1707 : 	if (targetdist > gp->range + HSDRange) // JPO - optimise for those too far away.

	mov	ecx, DWORD PTR _gp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR [edx+160]
	movss	xmm1, DWORD PTR _targetdist$1[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN13@DrawPPThre

; 1708 : 		continue;

	jmp	$LN16@DrawPPThre
$LN13@DrawPPThre:

; 1709 : 
; 1710 : 	if (targetdist < gp->range)

	mov	eax, DWORD PTR _gp$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _targetdist$1[ebp]
	jbe	SHORT $LN12@DrawPPThre

; 1711 : 	    display->SetColor(GetMfdColor(MFD_PREPLAN_INRANGE));

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1712 : 	else

	jmp	SHORT $LN11@DrawPPThre
$LN12@DrawPPThre:

; 1713 : 	    display->SetColor(GetMfdColor(MFD_PREPLAN));

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN11@DrawPPThre:

; 1714 : 
; 1715 : 	//MI changed
; 1716 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN10@DrawPPThre

; 1717 : 	{
; 1718 : 		//MI add in INS Drift
; 1719 : 		if(g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	SHORT $LN8@DrawPPThre

; 1720 : 		{
; 1721 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@DrawPPThre

; 1722 : 			{
; 1723 : 				y2 += (playerAC->GetINSLatDrift() * FT_TO_NM);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv416[ebp]
	movss	xmm0, DWORD PTR tv416[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	addss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1724 : 				x2 += (playerAC->GetINSLongDrift() * FT_TO_NM);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv421[ebp]
	movss	xmm0, DWORD PTR tv421[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	addss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN8@DrawPPThre:

; 1725 : 			}
; 1726 : 		}
; 1727 : 		if(HSDZoom == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	jne	SHORT $LN7@DrawPPThre

; 1728 : 		{
; 1729 : 			y2 /= HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1730 : 			x2 /= HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1731 : 		}
; 1732 : 		else

	jmp	SHORT $LN6@DrawPPThre
$LN7@DrawPPThre:

; 1733 : 		{
; 1734 : 			y2 /= HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1735 : 			x2 /= HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1736 : 			y2 *= HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+468]
	mulss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1737 : 			x2 *= HSDZoom;

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+468]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN6@DrawPPThre:

; 1738 : 		}
; 1739 : 	}
; 1740 : 	else

	jmp	SHORT $LN5@DrawPPThre
$LN10@DrawPPThre:

; 1741 : 	{
; 1742 : 		y2 /= HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1743 : 		x2 /= HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x2$[ebp], xmm0
$LN5@DrawPPThre:

; 1744 : 	}
; 1745 : 	displayX = trig.cos * x2 - trig.sin * y2;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _displayX$[ebp], xmm0

; 1746 : 	displayY = trig.sin * x2 + trig.cos * y2;

	movss	xmm0, DWORD PTR _trig$[ebp]
	mulss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR _y2$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _displayY$[ebp], xmm0

; 1747 : 	display->AdjustOriginInViewport (displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1748 : 	if (fabs(displayY) < 1 && fabs(displayX) < 1) { // JPO - don't bother if its off screen

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv454[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv454[ebp]
	jbe	SHORT $LN4@DrawPPThre
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv461[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv461[ebp]
	jbe	SHORT $LN4@DrawPPThre

; 1749 : 		DisplayMatrix savem;
; 1750 : 		display->SaveDisplayMatrix(&savem);

	lea	ecx, DWORD PTR _savem$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?SaveDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z ; VirtualDisplay::SaveDisplayMatrix

; 1751 : 		// JB 010730 Advanced and basic symbols are drawn sometimes on the HSD. This is an attempt to fix that.
; 1752 : 		if (gp->symbol != RWRSYM_ADVANCED_INTERCEPTOR && gp->symbol != RWRSYM_BASIC_INTERCEPTOR)

	mov	eax, DWORD PTR _gp$[ebp]
	cmp	DWORD PTR [eax+8], 2
	je	SHORT $LN3@DrawPPThre
	mov	ecx, DWORD PTR _gp$[ebp]
	cmp	DWORD PTR [ecx+8], 3
	je	SHORT $LN3@DrawPPThre

; 1753 : 			RwrClass::DrawSymbol (display, gp->symbol); // This zeros display rotation, caused bad FLOT and bullseye drawing (now fixed I hope JPO)

	push	0
	mov	edx, DWORD PTR _gp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?DrawSymbol@RwrClass@@SAXPAVVirtualDisplay@@HH@Z ; RwrClass::DrawSymbol
	add	esp, 12					; 0000000cH
$LN3@DrawPPThre:

; 1754 : 		display->RestoreDisplayMatrix(&savem);

	lea	eax, DWORD PTR _savem$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?RestoreDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z ; VirtualDisplay::RestoreDisplayMatrix
$LN4@DrawPPThre:

; 1755 : 	}
; 1756 : 
; 1757 : 	float rr = gp->range/HSDRange;

	mov	edx, DWORD PTR _gp$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _rr$2[ebp], xmm0

; 1758 : 	if (HSDZoom > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jle	SHORT $LN2@DrawPPThre

; 1759 : 		rr *= HSDZoom;

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+468]
	mulss	xmm0, DWORD PTR _rr$2[ebp]
	movss	DWORD PTR _rr$2[ebp], xmm0
$LN2@DrawPPThre:

; 1760 : 	if (gp->IsSet(GroundListElement::RangeRing))

	push	2
	mov	ecx, DWORD PTR _gp$[ebp]
	call	?IsSet@GroundListElement@@QAEHH@Z	; GroundListElement::IsSet
	test	eax, eax
	je	SHORT $LN1@DrawPPThre

; 1761 : 	{
; 1762 : 		display->Circle(0.0f, 0.0f, rr);

	push	ecx
	movss	xmm0, DWORD PTR _rr$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+48]
	call	edx
$LN1@DrawPPThre:

; 1763 : 	}
; 1764 : 	display->AdjustOriginInViewport (-displayX, -displayY);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1765 :     }

	jmp	$LN16@DrawPPThre
$LN15@DrawPPThre:
$LN20@DrawPPThre:

; 1766 : 
; 1767 : #if 0
; 1768 : 
; 1769 : 	// TODO:  Consolidate the HTS and HSD displays.
; 1770 : 	// FORNOW:  Don't show preplanned emitters on the HSD
; 1771 : /*
; 1772 : HarmTargetingPod* theHarm = (HarmTargetingPod*)FindSensor (platform, SensorClass::HTS);
; 1773 : HarmTargetingPod::ListElement* tmpElement;
; 1774 : mlTrig trig;
; 1775 : float x2, y2;
; 1776 : float displayX, displayY;
; 1777 : 
; 1778 :    if (theHarm)
; 1779 :    {
; 1780 :       tmpElement = theHarm->EmmitterList();
; 1781 :       mlSinCos (&trig, platform->Yaw());
; 1782 : 
; 1783 :       // Draw all known emmitters
; 1784 :       while (tmpElement)
; 1785 : 	   {
; 1786 : 		  // TODO:  Consider filtering based on RWR settings here...
; 1787 :          
; 1788 :             y2 = (tmpElement->BaseObject()->XPos() - platform->XPos()) * FT_TO_NM / HSDRange;
; 1789 :             x2 = (tmpElement->BaseObject()->YPos() - platform->YPos()) * FT_TO_NM / HSDRange;
; 1790 :             displayX = trig.cos * x2 - trig.sin * y2;
; 1791 :             displayY = trig.sin * x2 + trig.cos * y2;
; 1792 :             display->AdjustOriginInViewport (displayX, displayY);
; 1793 :             theHarm->DrawSymbol (display, tmpElement->major, tmpElement->minor, tmpElement->flags);
; 1794 :             display->AdjustOriginInViewport (-displayX, -displayY);
; 1795 :             tmpElement = tmpElement->next;
; 1796 :          }
; 1797 :       }
; 1798 :    }
; 1799 : */
; 1800 : #endif
; 1801 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawPPThreats@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawPPThreats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
tv863 = -188						; size = 4
tv616 = -184						; size = 4
tv850 = -180						; size = 4
tv726 = -176						; size = 4
tv894 = -172						; size = 4
tv755 = -168						; size = 4
tv845 = -164						; size = 4
tv645 = -160						; size = 4
tv838 = -156						; size = 4
tv770 = -152						; size = 4
tv892 = -148						; size = 4
tv611 = -144						; size = 4
tv833 = -140						; size = 4
tv660 = -136						; size = 4
tv825 = -132						; size = 4
tv630 = -128						; size = 4
tv890 = -124						; size = 4
tv783 = -120						; size = 4
tv820 = -116						; size = 4
tv763 = -112						; size = 4
tv812 = -108						; size = 4
tv747 = -104						; size = 4
tv888 = -100						; size = 4
tv733 = -96						; size = 4
tv807 = -92						; size = 4
tv721 = -88						; size = 4
tv800 = -84						; size = 4
tv653 = -80						; size = 4
tv886 = -76						; size = 4
tv637 = -72						; size = 4
tv795 = -68						; size = 4
tv623 = -64						; size = 4
tv788 = -60						; size = 4
tv884 = -56						; size = 4
tv740 = -52						; size = 4
_tmpColor$ = -48					; size = 4
_FlotX$1 = -44						; size = 4
_FlotY$2 = -40						; size = 4
_curElement$ = -36					; size = 4
_playerAC$ = -32					; size = 4
_yPos$ = -28						; size = 4
_flotX$ = -24						; size = 2
_flotY$ = -20						; size = 2
_xPos$ = -16						; size = 4
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawFLOT@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawFLOT
; _this$ = ecx

; 1491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	DWORD PTR _this$[ebp], ecx

; 1492 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1493 : 	//MI
; 1494 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN24@DrawFLOT
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN24@DrawFLOT

; 1495 : 	{
; 1496 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN24@DrawFLOT
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN24@DrawFLOT

; 1497 : 			return;

	jmp	$LN26@DrawFLOT
$LN24@DrawFLOT:

; 1498 : 	}
; 1499 : 
; 1500 : 	float xPos, yPos;
; 1501 : 	float x = 0, y = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y$[ebp], xmm0

; 1502 : 	class ListElementClass* curElement;
; 1503 : 	GridIndex flotX, flotY;
; 1504 : 	int tmpColor = display->Color();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _tmpColor$[ebp], eax

; 1505 : 
; 1506 :    // Add the bullseye
; 1507 :    TheCampaign.GetBullseyeSimLocation (&xPos, &yPos);

	lea	ecx, DWORD PTR _yPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _xPos$[ebp]
	push	edx
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?GetBullseyeSimLocation@CampaignClass@@QAEXPAM0@Z ; CampaignClass::GetBullseyeSimLocation

; 1508 : 
; 1509 :    //MI changed
; 1510 :    if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN23@DrawFLOT

; 1511 :    {
; 1512 : 	   //MI add in INS Drift
; 1513 : 	   if(g_bINS)

	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN21@DrawFLOT

; 1514 : 	   {
; 1515 : 		   if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN21@DrawFLOT

; 1516 : 		   {
; 1517 : 			   xPos += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv611[ebp]
	movss	xmm0, DWORD PTR tv611[ebp]
	addss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1518 : 			   yPos += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv616[ebp]
	movss	xmm0, DWORD PTR tv616[ebp]
	addss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR _yPos$[ebp], xmm0
$LN21@DrawFLOT:

; 1519 : 		   }
; 1520 : 	   }
; 1521 : 	   if(HSDZoom == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jne	SHORT $LN20@DrawFLOT

; 1522 : 	   {
; 1523 : 		   y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv623[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv623[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 1524 : 		   x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv630[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv630[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _x$[ebp], xmm0

; 1525 : 	   }
; 1526 : 	   else

	jmp	$LN19@DrawFLOT
$LN20@DrawFLOT:

; 1527 : 	   {
; 1528 : 		   y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv637[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv637[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _y$[ebp], xmm0

; 1529 : 		   x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv645[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv645[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _x$[ebp], xmm0
$LN19@DrawFLOT:

; 1530 : 	   }
; 1531 :    }
; 1532 :    else

	jmp	SHORT $LN18@DrawFLOT
$LN23@DrawFLOT:

; 1533 :    {
; 1534 : 	   y = (xPos - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv653[ebp]
	movss	xmm0, DWORD PTR _xPos$[ebp]
	subss	xmm0, DWORD PTR tv653[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 1535 : 	   x = (yPos - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv660[ebp]
	movss	xmm0, DWORD PTR _yPos$[ebp]
	subss	xmm0, DWORD PTR tv660[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _x$[ebp], xmm0
$LN18@DrawFLOT:

; 1536 :    }
; 1537 :    
; 1538 :    display->SetColor(GetMfdColor(MFD_BULLSEYE));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1539 :    display->Circle (x, y, 0.07F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d8f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1540 :    display->Circle (x, y, 0.04F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1541 :    display->Circle (x, y, 0.01F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1542 : 
; 1543 :    // Draw the Flot
; 1544 :    if (FLOTList)

	cmp	DWORD PTR ?FLOTList@@3PAVListClass@@A, 0 ; FLOTList
	je	$LN16@DrawFLOT

; 1545 :    {
; 1546 :       curElement = FLOTList->GetFirstElement();

	mov	ecx, DWORD PTR ?FLOTList@@3PAVListClass@@A ; FLOTList
	call	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
	mov	DWORD PTR _curElement$[ebp], eax

; 1547 : 	  if (curElement)

	cmp	DWORD PTR _curElement$[ebp], 0
	je	$LN16@DrawFLOT

; 1548 : 	  {
; 1549 : 		  tmpColor = display->Color();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _tmpColor$[ebp], eax

; 1550 : 		  if (!g_bEnableColorMfd)

	movzx	ecx, BYTE PTR ?g_bEnableColorMfd@@3_NA	; g_bEnableColorMfd
	test	ecx, ecx
	jne	SHORT $LN15@DrawFLOT

; 1551 : 		    display->SetColor( 0xFF008000 );

	push	-16744448				; ff008000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1552 : 		  else

	jmp	SHORT $LN14@DrawFLOT
$LN15@DrawFLOT:

; 1553 : 		      display->SetColor(GetMfdColor(MFD_GREY));

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN14@DrawFLOT:

; 1554 : 
; 1555 : 		  UnpackXY (curElement->GetUserData(), &flotX, &flotY);

	lea	ecx, DWORD PTR _flotY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _flotX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _curElement$[ebp]
	call	?GetUserData@ListElementClass@@QAEPAXXZ	; ListElementClass::GetUserData
	push	eax
	call	?UnpackXY@@YAXPAXPAF1@Z			; UnpackXY
	add	esp, 12					; 0000000cH

; 1556 : 		  curElement = curElement->GetNext();

	mov	ecx, DWORD PTR _curElement$[ebp]
	call	?GetNext@ListElementClass@@QAEPAV1@XZ	; ListElementClass::GetNext
	mov	DWORD PTR _curElement$[ebp], eax

; 1557 : 
; 1558 : 		  float FlotX = GridToSim (flotX);

	movzx	eax, WORD PTR _flotX$[ebp]
	push	eax
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR _FlotX$1[ebp]

; 1559 : 		  float FlotY = GridToSim(flotY);

	movzx	ecx, WORD PTR _flotY$[ebp]
	push	ecx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR _FlotY$2[ebp]

; 1560 : 		  //MI changed
; 1561 : 		  if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN13@DrawFLOT

; 1562 : 		  {
; 1563 : 			  //MI add in INS Drift
; 1564 : 			  if(g_bINS)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN11@DrawFLOT

; 1565 : 			  {
; 1566 : 				  if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN11@DrawFLOT

; 1567 : 				  {
; 1568 : 					  FlotX += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv721[ebp]
	movss	xmm0, DWORD PTR tv721[ebp]
	addss	xmm0, DWORD PTR _FlotX$1[ebp]
	movss	DWORD PTR _FlotX$1[ebp], xmm0

; 1569 : 					  FlotY += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv726[ebp]
	movss	xmm0, DWORD PTR tv726[ebp]
	addss	xmm0, DWORD PTR _FlotY$2[ebp]
	movss	DWORD PTR _FlotY$2[ebp], xmm0
$LN11@DrawFLOT:

; 1570 : 				  }
; 1571 : 			  }
; 1572 : 			  if(HSDZoom == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jne	SHORT $LN10@DrawFLOT

; 1573 : 			  {
; 1574 : 				  y = (FlotY - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv733[ebp]
	movss	xmm0, DWORD PTR _FlotY$2[ebp]
	subss	xmm0, DWORD PTR tv733[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 1575 : 				  x = (FlotX - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv740[ebp]
	movss	xmm0, DWORD PTR _FlotX$1[ebp]
	subss	xmm0, DWORD PTR tv740[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x$[ebp], xmm0

; 1576 : 			  }
; 1577 : 			  else

	jmp	$LN9@DrawFLOT
$LN10@DrawFLOT:

; 1578 : 			  {
; 1579 : 				  y = (FlotY - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv747[ebp]
	movss	xmm0, DWORD PTR _FlotY$2[ebp]
	subss	xmm0, DWORD PTR tv747[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _y$[ebp], xmm0

; 1580 : 				  x = (FlotX - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv755[ebp]
	movss	xmm0, DWORD PTR _FlotX$1[ebp]
	subss	xmm0, DWORD PTR tv755[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _x$[ebp], xmm0
$LN9@DrawFLOT:

; 1581 : 			  }
; 1582 : 		  }
; 1583 : 		  else

	jmp	SHORT $LN8@DrawFLOT
$LN13@DrawFLOT:

; 1584 : 		  {
; 1585 : 			  y = (FlotY - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv763[ebp]
	movss	xmm0, DWORD PTR _FlotY$2[ebp]
	subss	xmm0, DWORD PTR tv763[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _y$[ebp], xmm0

; 1586 : 			  x = (FlotX - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv770[ebp]
	movss	xmm0, DWORD PTR _FlotX$1[ebp]
	subss	xmm0, DWORD PTR tv770[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _x$[ebp], xmm0
$LN8@DrawFLOT:

; 1587 : 		  }
; 1588 : 		  while (curElement)

	cmp	DWORD PTR _curElement$[ebp], 0
	je	$LN6@DrawFLOT

; 1589 : 		  {
; 1590 : 			 UnpackXY (curElement->GetUserData(), &flotX, &flotY);

	lea	ecx, DWORD PTR _flotY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _flotX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _curElement$[ebp]
	call	?GetUserData@ListElementClass@@QAEPAXXZ	; ListElementClass::GetUserData
	push	eax
	call	?UnpackXY@@YAXPAXPAF1@Z			; UnpackXY
	add	esp, 12					; 0000000cH

; 1591 : 			 curElement = curElement->GetNext();

	mov	ecx, DWORD PTR _curElement$[ebp]
	call	?GetNext@ListElementClass@@QAEPAV1@XZ	; ListElementClass::GetNext
	mov	DWORD PTR _curElement$[ebp], eax

; 1592 : 
; 1593 : 			 //MI changed
; 1594 : 			 if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN5@DrawFLOT

; 1595 : 			 {
; 1596 : 				 if(HSDZoom == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jne	$LN4@DrawFLOT

; 1597 : 				 {
; 1598 : 					 yPos = (GridToSim (flotY) - platform->XPos()) * FT_TO_NM / HSDRange;

	movzx	edx, WORD PTR _flotY$[ebp]
	push	edx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR tv783[ebp]
	movss	xmm0, DWORD PTR tv783[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv884[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv788[ebp]
	movss	xmm0, DWORD PTR tv884[ebp]
	subss	xmm0, DWORD PTR tv788[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1599 : 					 xPos = (GridToSim (flotX) - platform->YPos()) * FT_TO_NM / HSDRange;

	movzx	edx, WORD PTR _flotX$[ebp]
	push	edx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR tv795[ebp]
	movss	xmm0, DWORD PTR tv795[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv886[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv800[ebp]
	movss	xmm0, DWORD PTR tv886[ebp]
	subss	xmm0, DWORD PTR tv800[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1600 : 				 }
; 1601 : 				 else

	jmp	$LN3@DrawFLOT
$LN4@DrawFLOT:

; 1602 : 				 {
; 1603 : 					 yPos = (GridToSim (flotY) - platform->XPos()) * FT_TO_NM / HSDRange * HSDZoom;

	movzx	edx, WORD PTR _flotY$[ebp]
	push	edx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR tv807[ebp]
	movss	xmm0, DWORD PTR tv807[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv888[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv812[ebp]
	movss	xmm0, DWORD PTR tv888[ebp]
	subss	xmm0, DWORD PTR tv812[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1604 : 					 xPos = (GridToSim (flotX) - platform->YPos()) * FT_TO_NM / HSDRange * HSDZoom;

	movzx	eax, WORD PTR _flotX$[ebp]
	push	eax
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR tv820[ebp]
	movss	xmm0, DWORD PTR tv820[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	movss	DWORD PTR tv890[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv825[ebp]
	movss	xmm0, DWORD PTR tv890[ebp]
	subss	xmm0, DWORD PTR tv825[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	movss	DWORD PTR _xPos$[ebp], xmm0
$LN3@DrawFLOT:

; 1605 : 				 }
; 1606 : 			 }
; 1607 : 			 else

	jmp	$LN2@DrawFLOT
$LN5@DrawFLOT:

; 1608 : 			 {
; 1609 : 				 yPos = (GridToSim (flotY) - platform->XPos()) * FT_TO_NM / HSDRange;

	movzx	ecx, WORD PTR _flotY$[ebp]
	push	ecx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR tv833[ebp]
	movss	xmm0, DWORD PTR tv833[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv892[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv838[ebp]
	movss	xmm0, DWORD PTR tv892[ebp]
	subss	xmm0, DWORD PTR tv838[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1610 : 				 xPos = (GridToSim (flotX) - platform->YPos()) * FT_TO_NM / HSDRange;

	movzx	ecx, WORD PTR _flotX$[ebp]
	push	ecx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR tv845[ebp]
	movss	xmm0, DWORD PTR tv845[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv894[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv850[ebp]
	movss	xmm0, DWORD PTR tv894[ebp]
	subss	xmm0, DWORD PTR tv850[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR _xPos$[ebp], xmm0
$LN2@DrawFLOT:

; 1611 : 			 }
; 1612 : 			
; 1613 : 			 if (DistSqu(x,y,xPos,yPos) < FLOTDrawDistance)	// when FLOT points are too far away from each other, don't draw a line

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?DistSqu@@YAMMMMM@Z			; DistSqu
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv863[ebp]
	movss	xmm0, DWORD PTR ?FLOTDrawDistance@@3MA
	comiss	xmm0, DWORD PTR tv863[ebp]
	jbe	SHORT $LN1@DrawFLOT

; 1614 : 				display->Line (x, y, xPos, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN1@DrawFLOT:

; 1615 : 			 x = xPos;

	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 1616 : 			 y = yPos;

	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 1617 : 		  }

	jmp	$LN8@DrawFLOT
$LN6@DrawFLOT:

; 1618 : 		  display->SetColor( tmpColor );

	mov	ecx, DWORD PTR _tmpColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN16@DrawFLOT:
$LN26@DrawFLOT:

; 1619 : 	  }
; 1620 :    }
; 1621 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawFLOT@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawFLOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_SMDELTA$ = -20						; size = 4
tv76 = -16						; size = 4
_playerAC$ = -12					; size = 4
_this$ = -8						; size = 4
_dist$ = -4						; size = 4
_displayX$ = 8						; size = 4
_displayY$ = 12						; size = 4
_type$ = 16						; size = 4
?DrawMarkSymbol@FireControlComputer@@AAEXMMH@Z PROC	; FireControlComputer::DrawMarkSymbol
; _this$ = ecx

; 1428 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1429 : 	float SMDELTA = g_fHSDSymbolSize;		//Wombat778 11-13-2003		Set SMDELTA to the external variable

	movss	xmm0, DWORD PTR ?g_fHSDSymbolSize@@3MA
	movss	DWORD PTR _SMDELTA$[ebp], xmm0

; 1430 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1431 : 
; 1432 : 	//MI
; 1433 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawMarkSy
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN1@DrawMarkSy

; 1434 : 	{
; 1435 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@DrawMarkSy
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawMarkSy

; 1436 : 			return;

	jmp	$LN3@DrawMarkSy
$LN1@DrawMarkSy:

; 1437 : 	}
; 1438 : 
; 1439 :     float dist = type == 0 ? SMDELTA : LGDELTA;

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN5@DrawMarkSy
	movss	xmm0, DWORD PTR _SMDELTA$[ebp]
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN6@DrawMarkSy
$LN5@DrawMarkSy:
	movss	xmm0, DWORD PTR _LGDELTA
	movss	DWORD PTR tv76[ebp], xmm0
$LN6@DrawMarkSy:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR _dist$[ebp], xmm0

; 1440 :     display->Line (displayX - dist, displayY - dist, displayX + dist, displayY + dist);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1441 :     display->Line (displayX - dist, displayY + dist, displayX + dist, displayY - dist);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawMarkSy:

; 1442 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DrawMarkSymbol@FireControlComputer@@AAEXMMH@Z ENDP	; FireControlComputer::DrawMarkSymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_this$ = -8						; size = 4
_SMDELTA$ = -4						; size = 4
_displayX$ = 8						; size = 4
_displayY$ = 12						; size = 4
?DrawIPSymbol@FireControlComputer@@AAEXMM@Z PROC	; FireControlComputer::DrawIPSymbol
; _this$ = ecx

; 1404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1405 : 	float SMDELTA = g_fHSDSymbolSize;		//Wombat778 11-13-2003		Set SMDELTA to the external variable

	movss	xmm0, DWORD PTR ?g_fHSDSymbolSize@@3MA
	movss	DWORD PTR _SMDELTA$[ebp], xmm0

; 1406 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1407 : 
; 1408 : 	//MI
; 1409 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawIPSymb
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN1@DrawIPSymb

; 1410 : 	{
; 1411 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@DrawIPSymb
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawIPSymb

; 1412 : 			return;

	jmp	$LN3@DrawIPSymb
$LN1@DrawIPSymb:

; 1413 : 	}
; 1414 : 
; 1415 : 	display->Line (displayX + SMDELTA, displayY + SMDELTA, displayX + SMDELTA, displayY - SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1416 : 	display->Line (displayX - SMDELTA, displayY + SMDELTA, displayX - SMDELTA, displayY - SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1417 : 	display->Line (displayX + SMDELTA, displayY + SMDELTA, displayX - SMDELTA, displayY + SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1418 : 	display->Line (displayX + SMDELTA, displayY - SMDELTA, displayX - SMDELTA, displayY - SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawIPSymb:

; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawIPSymbol@FireControlComputer@@AAEXMM@Z ENDP	; FireControlComputer::DrawIPSymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_this$ = -8						; size = 4
_SMDELTA$ = -4						; size = 4
_displayX$ = 8						; size = 4
_displayY$ = 12						; size = 4
?DrawTGTSymbol@FireControlComputer@@AAEXMM@Z PROC	; FireControlComputer::DrawTGTSymbol
; _this$ = ecx

; 1380 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1381 : 	float SMDELTA = g_fHSDSymbolSize;		//Wombat778 11-13-2003		Set SMDELTA to the external variable

	movss	xmm0, DWORD PTR ?g_fHSDSymbolSize@@3MA
	movss	DWORD PTR _SMDELTA$[ebp], xmm0

; 1382 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1383 : 	//MI
; 1384 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@DrawTGTSym
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN1@DrawTGTSym

; 1385 : 	{
; 1386 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@DrawTGTSym
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN1@DrawTGTSym

; 1387 : 			return;

	jmp	$LN3@DrawTGTSym
$LN1@DrawTGTSym:

; 1388 : 	}
; 1389 : 
; 1390 : 	display->Line (displayX + SMDELTA, displayY - SMDELTA, displayX, displayY + SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1391 : 	display->Line (displayX - SMDELTA, displayY - SMDELTA, displayX, displayY + SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1392 : 	display->Line (displayX + SMDELTA, displayY - SMDELTA, displayX - SMDELTA, displayY - SMDELTA);

	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayY$[ebp]
	subss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _displayX$[ebp]
	addss	xmm0, DWORD PTR _SMDELTA$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN3@DrawTGTSym:

; 1393 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawTGTSymbol@FireControlComputer@@AAEXMM@Z ENDP	; FireControlComputer::DrawTGTSymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_wpFlags$ = -16						; size = 4
_theWaypt$ = -12					; size = 4
_theRadar$ = -8						; size = 4
_this$ = -4						; size = 4
_curWaypoint$ = 8					; size = 4
_displayX$ = 12						; size = 4
_displayY$ = 16						; size = 4
?DrawPointSymbol@FireControlComputer@@AAEXPAVWayPointClass@@MM@Z PROC ; FireControlComputer::DrawPointSymbol
; _this$ = ecx

; 1340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1341 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN9@DrawPointS

; 1342 : 		return;

	jmp	$LN10@DrawPointS
$LN9@DrawPointS:

; 1343 : 
; 1344 : 	int wpFlags;
; 1345 : 	WayPointClass* theWaypt;
; 1346 : 
; 1347 : 	RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 1348 : 
; 1349 : 	if (theRadar && theRadar->IsSet(RadarDopplerClass::SP) && theRadar->IsSet(RadarDopplerClass::SP_STAB))

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN8@DrawPointS
	push	64					; 00000040H
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN8@DrawPointS
	push	128					; 00000080H
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN8@DrawPointS

; 1350 : 		theWaypt = mpSavedWaypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR _theWaypt$[ebp], ecx

; 1351 : 	else

	jmp	SHORT $LN7@DrawPointS
$LN8@DrawPointS:

; 1352 : 		theWaypt = ((SimVehicleClass*)platform)->curWaypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+728]
	mov	DWORD PTR _theWaypt$[ebp], ecx
$LN7@DrawPointS:

; 1353 : 
; 1354 : 	if ((curWaypoint != theWaypt) || (vuxRealTime & 0x200)) {

	mov	edx, DWORD PTR _curWaypoint$[ebp]
	cmp	edx, DWORD PTR _theWaypt$[ebp]
	jne	SHORT $LN5@DrawPointS
	mov	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	eax, 512				; 00000200H
	je	$LN1@DrawPointS
$LN5@DrawPointS:

; 1355 : 
; 1356 : 		wpFlags = curWaypoint->GetWPFlags();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	mov	DWORD PTR _wpFlags$[ebp], eax

; 1357 : 
; 1358 : 		if (wpFlags & WPF_TARGET) {

	mov	ecx, DWORD PTR _wpFlags$[ebp]
	and	ecx, 1
	je	SHORT $LN4@DrawPointS

; 1359 : 			DrawTGTSymbol(displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTGTSymbol@FireControlComputer@@AAEXMM@Z ; FireControlComputer::DrawTGTSymbol
	jmp	SHORT $LN1@DrawPointS
$LN4@DrawPointS:

; 1360 : 		}
; 1361 : 		else if (wpFlags & WPF_IP) {

	mov	edx, DWORD PTR _wpFlags$[ebp]
	and	edx, 8
	je	SHORT $LN2@DrawPointS

; 1362 : 			DrawIPSymbol(displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawIPSymbol@FireControlComputer@@AAEXMM@Z ; FireControlComputer::DrawIPSymbol

; 1363 : 		}
; 1364 : 		else {			

	jmp	SHORT $LN1@DrawPointS
$LN2@DrawPointS:

; 1365 : 			display->Circle (displayX, displayY, g_fHSDSymbolSize);  //Wombat778 11-13-2003 Make the symbol size configurable

	push	ecx
	movss	xmm0, DWORD PTR ?g_fHSDSymbolSize@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+48]
	call	edx
$LN1@DrawPointS:
$LN10@DrawPointS:

; 1366 : 		}
; 1367 : 	}
; 1368 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DrawPointSymbol@FireControlComputer@@AAEXPAVWayPointClass@@MM@Z ENDP ; FireControlComputer::DrawPointSymbol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_curWaypoint$ = 8					; size = 4
_x2$ = 12						; size = 4
_y2$ = 16						; size = 4
_displayX$ = 20						; size = 4
_displayY$ = 24						; size = 4
?DrawPointPair@FireControlComputer@@AAEXPAVWayPointClass@@MMMM@Z PROC ; FireControlComputer::DrawPointPair
; _this$ = ecx

; 1324 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 :    if (!(curWaypoint->GetWPFlags() & WPF_ALTERNATE))

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1024				; 00000400H
	jne	SHORT $LN1@DrawPointP

; 1326 : 	   display->Line (x2, y2, displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN1@DrawPointP:

; 1327 : 
; 1328 : 	DrawPointSymbol(curWaypoint, displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _curWaypoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPointSymbol@FireControlComputer@@AAEXPAVWayPointClass@@MM@Z ; FireControlComputer::DrawPointSymbol

; 1329 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?DrawPointPair@FireControlComputer@@AAEXPAVWayPointClass@@MMMM@Z ENDP ; FireControlComputer::DrawPointPair
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_wpZ$ = -52						; size = 4
tv263 = -48						; size = 4
tv255 = -44						; size = 4
tv246 = -40						; size = 4
tv237 = -36						; size = 4
tv230 = -32						; size = 4
tv225 = -28						; size = 4
tv218 = -24						; size = 4
tv210 = -20						; size = 4
_playerAC$ = -16					; size = 4
_wpY$ = -12						; size = 4
_wpX$ = -8						; size = 4
_this$ = -4						; size = 4
_pwaypoint$ = 8						; size = 4
_h$ = 12						; size = 4
_v$ = 16						; size = 4
?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z PROC ; FireControlComputer::MapWaypointToDisplay
; _this$ = ecx

; 1279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1280 : 	float wpX;
; 1281 : 	float wpY;
; 1282 : 	float wpZ;
; 1283 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1284 : 	pwaypoint->GetLocation (&wpX, &wpY, &wpZ);

	lea	eax, DWORD PTR _wpZ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wpY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wpX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pwaypoint$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1285 : 	//MI
; 1286 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@MapWaypoin

; 1287 : 	{
; 1288 : 		*v = (wpX - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv210[ebp]
	movss	xmm0, DWORD PTR _wpX$[ebp]
	subss	xmm0, DWORD PTR tv210[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _v$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1289 : 		*h = (wpY - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv218[ebp]
	movss	xmm0, DWORD PTR _wpY$[ebp]
	subss	xmm0, DWORD PTR tv218[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _h$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1290 : 	}
; 1291 : 	else

	jmp	$LN1@MapWaypoin
$LN6@MapWaypoin:

; 1292 : 	{
; 1293 : 		//MI add in INS Drift
; 1294 : 		if(g_bINS)

	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN3@MapWaypoin

; 1295 : 		{
; 1296 : 			if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN3@MapWaypoin

; 1297 : 			{
; 1298 : 				wpX += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv225[ebp]
	movss	xmm0, DWORD PTR tv225[ebp]
	addss	xmm0, DWORD PTR _wpX$[ebp]
	movss	DWORD PTR _wpX$[ebp], xmm0

; 1299 : 				wpY += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv230[ebp]
	movss	xmm0, DWORD PTR tv230[ebp]
	addss	xmm0, DWORD PTR _wpY$[ebp]
	movss	DWORD PTR _wpY$[ebp], xmm0
$LN3@MapWaypoin:

; 1300 : 			}
; 1301 : 		}
; 1302 : 		if(HSDZoom > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jle	$LN2@MapWaypoin

; 1303 : 		{
; 1304 : 			*v = ((wpX - platform->XPos()) * FT_TO_NM / HSDRange) * HSDZoom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv237[ebp]
	movss	xmm0, DWORD PTR _wpX$[ebp]
	subss	xmm0, DWORD PTR tv237[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _v$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1305 : 			*h = ((wpY - platform->YPos()) * FT_TO_NM / HSDRange) * HSDZoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv246[ebp]
	movss	xmm0, DWORD PTR _wpY$[ebp]
	subss	xmm0, DWORD PTR tv246[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+468]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 1306 : 		}
; 1307 : 		else

	jmp	SHORT $LN1@MapWaypoin
$LN2@MapWaypoin:

; 1308 : 		{
; 1309 : 			*v = (wpX - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv255[ebp]
	movss	xmm0, DWORD PTR _wpX$[ebp]
	subss	xmm0, DWORD PTR tv255[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 1310 : 			*h = (wpY - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv263[ebp]
	movss	xmm0, DWORD PTR _wpY$[ebp]
	subss	xmm0, DWORD PTR tv263[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN1@MapWaypoin:

; 1311 : 		}
; 1312 : 	}
; 1313 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ENDP ; FireControlComputer::MapWaypointToDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_playerAC$ = -36					; size = 4
_y2$ = -32						; size = 4
_x2$ = -28						; size = 4
_displayY$ = -24					; size = 4
_displayX$ = -20					; size = 4
_this$ = -16						; size = 4
_prevWaypoint$ = -12					; size = 4
_i$ = -8						; size = 4
_curWaypoint$ = -4					; size = 4
?DrawLinkPoints@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::DrawLinkPoints
; _this$ = ecx

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1141 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1142 : 	//MI
; 1143 : 	if(g_bRealisticAvionics && g_bINS){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN8@DrawLinkPo
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN8@DrawLinkPo

; 1144 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@DrawLinkPo
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN8@DrawLinkPo

; 1145 : 			return;

	jmp	$LN10@DrawLinkPo
$LN8@DrawLinkPo:

; 1146 : 	}
; 1147 : 
; 1148 : 	WayPointClass* prevWaypoint = NULL;

	mov	DWORD PTR _prevWaypoint$[ebp], 0

; 1149 : 	WayPointClass* curWaypoint = NULL;

	mov	DWORD PTR _curWaypoint$[ebp], 0

; 1150 : 	int				i=0;

	mov	DWORD PTR _i$[ebp], 0

; 1151 : 	float				x2=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x2$[ebp], xmm0

; 1152 : 	float				y2=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y2$[ebp], xmm0

; 1153 : 	float				displayX=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _displayX$[ebp], xmm0

; 1154 : 	float				displayY=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _displayY$[ebp], xmm0

; 1155 : 
; 1156 : 	gNavigationSys->GetDLinkWayPoint(0, &prevWaypoint);

	lea	edx, DWORD PTR _prevWaypoint$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDLinkWayPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetDLinkWayPoint

; 1157 : 
; 1158 : 	if(prevWaypoint) {

	cmp	DWORD PTR _prevWaypoint$[ebp], 0
	je	$LN4@DrawLinkPo

; 1159 : 		MapWaypointToDisplay(prevWaypoint, &x2, &y2);

	lea	eax, DWORD PTR _y2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prevWaypoint$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1160 : 		
; 1161 : 		for(i = 1; i < MAX_DLINKPOINTS; i++) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN6@DrawLinkPo
$LN5@DrawLinkPo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@DrawLinkPo:
	cmp	DWORD PTR _i$[ebp], 5
	jge	$LN4@DrawLinkPo

; 1162 : 			gNavigationSys->GetDLinkWayPoint(i, &curWaypoint);

	lea	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDLinkWayPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetDLinkWayPoint

; 1163 : 			if(curWaypoint) {

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN1@DrawLinkPo

; 1164 : 				MapWaypointToDisplay(curWaypoint, &displayX, &displayY);

	lea	eax, DWORD PTR _displayY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _displayX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curWaypoint$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1165 : 			
; 1166 : 				if(prevWaypoint) {

	cmp	DWORD PTR _prevWaypoint$[ebp], 0
	je	SHORT $LN2@DrawLinkPo

; 1167 : 					DrawPointPair(curWaypoint, x2, y2, displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _curWaypoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPointPair@FireControlComputer@@AAEXPAVWayPointClass@@MMMM@Z ; FireControlComputer::DrawPointPair

; 1168 : 				}
; 1169 : 				else {

	jmp	SHORT $LN1@DrawLinkPo
$LN2@DrawLinkPo:

; 1170 : 					DrawPointSymbol(curWaypoint, displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPointSymbol@FireControlComputer@@AAEXPAVWayPointClass@@MM@Z ; FireControlComputer::DrawPointSymbol
$LN1@DrawLinkPo:

; 1171 : 				}
; 1172 : 			}
; 1173 : 
; 1174 : 			x2				= displayX;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1175 : 			y2				= displayY;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1176 : 			prevWaypoint	= curWaypoint;

	mov	edx, DWORD PTR _curWaypoint$[ebp]
	mov	DWORD PTR _prevWaypoint$[ebp], edx

; 1177 : 		}

	jmp	$LN5@DrawLinkPo
$LN4@DrawLinkPo:
$LN10@DrawLinkPo:

; 1178 : 	}
; 1179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawLinkPoints@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::DrawLinkPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_displayX$ = -24					; size = 4
_displayY$ = -20					; size = 4
_playerAC$ = -16					; size = 4
_this$ = -12						; size = 4
_curWaypoint$ = -8					; size = 4
_i$ = -4						; size = 4
?DrawMarkPoints@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::DrawMarkPoints
; _this$ = ecx

; 1105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1106 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1107 : 	//MI
; 1108 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN7@DrawMarkPo
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN7@DrawMarkPo

; 1109 : 	{
; 1110 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN7@DrawMarkPo
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN7@DrawMarkPo

; 1111 : 			return;

	jmp	$LN9@DrawMarkPo
$LN7@DrawMarkPo:

; 1112 : 	}
; 1113 : 
; 1114 : 	WayPointClass* curWaypoint = NULL;

	mov	DWORD PTR _curWaypoint$[ebp], 0

; 1115 : 	int				i;
; 1116 : 	float				displayX;
; 1117 : 	float				displayY;
; 1118 : 
; 1119 : 	for(i = 0; i < MAX_MARKPOINTS; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@DrawMarkPo
$LN5@DrawMarkPo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@DrawMarkPo:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	$LN4@DrawMarkPo

; 1120 : 		gNavigationSys->GetMarkWayPoint(i, &curWaypoint);

	lea	eax, DWORD PTR _curWaypoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetMarkWayPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetMarkWayPoint

; 1121 : 		if(curWaypoint) {

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN1@DrawMarkPo

; 1122 : 			MapWaypointToDisplay(curWaypoint, &displayX, &displayY);

	lea	edx, DWORD PTR _displayY$[ebp]
	push	edx
	lea	eax, DWORD PTR _displayX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1123 : 			if (g_bRealisticAvionics) 

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN2@DrawMarkPo

; 1124 : 			    DrawMarkSymbol(displayX, displayY, 0);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMarkSymbol@FireControlComputer@@AAEXMMH@Z ; FireControlComputer::DrawMarkSymbol

; 1125 : 			else

	jmp	SHORT $LN1@DrawMarkPo
$LN2@DrawMarkPo:

; 1126 : 			    DrawPointSymbol(curWaypoint, displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _curWaypoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPointSymbol@FireControlComputer@@AAEXPAVWayPointClass@@MM@Z ; FireControlComputer::DrawPointSymbol
$LN1@DrawMarkPo:

; 1127 : 		}
; 1128 : 	}

	jmp	$LN5@DrawMarkPo
$LN4@DrawMarkPo:
$LN9@DrawMarkPo:

; 1129 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawMarkPoints@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::DrawMarkPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_y2$ = -28						; size = 4
_displayY$ = -24					; size = 4
_x2$ = -20						; size = 4
_displayX$ = -16					; size = 4
_playerAC$ = -12					; size = 4
_this$ = -8						; size = 4
_curWaypoint$ = -4					; size = 4
?DrawWayPoints@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawWayPoints
; _this$ = ecx

; 1063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1064 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1065 : 	//MI
; 1066 : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN4@DrawWayPoi
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN4@DrawWayPoi

; 1067 : 	{
; 1068 : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN4@DrawWayPoi
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN4@DrawWayPoi

; 1069 : 			return;

	jmp	$LN6@DrawWayPoi
$LN4@DrawWayPoi:

; 1070 : 	}
; 1071 : 
; 1072 : 	float x2;
; 1073 : 	float y2;
; 1074 : 	float displayX;
; 1075 : 	float displayY;
; 1076 : 	WayPointClass* curWaypoint;
; 1077 : 
; 1078 : 	curWaypoint = platform->waypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+732]
	mov	DWORD PTR _curWaypoint$[ebp], ecx

; 1079 : 
; 1080 :    if (curWaypoint) {

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	$LN1@DrawWayPoi

; 1081 : 
; 1082 : 		MapWaypointToDisplay(curWaypoint, &x2, &y2);

	lea	edx, DWORD PTR _y2$[ebp]
	push	edx
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1083 : 		curWaypoint = curWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _curWaypoint$[ebp], eax
$LN2@DrawWayPoi:

; 1084 : 
; 1085 :       while (curWaypoint) {

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN1@DrawWayPoi

; 1086 : 
; 1087 : 			MapWaypointToDisplay(curWaypoint, &displayX, &displayY);

	lea	edx, DWORD PTR _displayY$[ebp]
	push	edx
	lea	eax, DWORD PTR _displayX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MapWaypointToDisplay@FireControlComputer@@AAEXPAVWayPointClass@@PAM1@Z ; FireControlComputer::MapWaypointToDisplay

; 1088 : 			DrawPointPair(curWaypoint, x2, y2, displayX, displayY);

	push	ecx
	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _curWaypoint$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPointPair@FireControlComputer@@AAEXPAVWayPointClass@@MMMM@Z ; FireControlComputer::DrawPointPair

; 1089 : 
; 1090 :          x2				= displayX;

	movss	xmm0, DWORD PTR _displayX$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1091 :          y2				= displayY;

	movss	xmm0, DWORD PTR _displayY$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1092 :          curWaypoint = curWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _curWaypoint$[ebp], eax

; 1093 :       }

	jmp	SHORT $LN2@DrawWayPoi
$LN1@DrawWayPoi:
$LN6@DrawWayPoi:

; 1094 :    }
; 1095 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawWayPoints@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawWayPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_tmpColor$1 = -24					; size = 4
_tmpColor$2 = -20					; size = 4
tv199 = -16						; size = 4
_playerAC$ = -12					; size = 4
_tmpColor$3 = -8					; size = 4
_this$ = -4						; size = 4
?DrawNavPoints@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::DrawNavPoints
; _this$ = ecx

; 991  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 993  : 
; 994  : 	//MI
; 995  : 	if(g_bRealisticAvionics && g_bINS)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN9@DrawNavPoi
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN9@DrawNavPoi

; 996  : 	{
; 997  : 		if(playerAC && !playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN9@DrawNavPoi
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN9@DrawNavPoi

; 998  : 			return;

	jmp	$LN10@DrawNavPoi
$LN9@DrawNavPoi:

; 999  : 	}
; 1000 : 
; 1001 : 	if (g_bHsdStptFix) {

	movzx	edx, BYTE PTR ?g_bHsdStptFix@@3_NA	; g_bHsdStptFix
	test	edx, edx
	je	$LN7@DrawNavPoi

; 1002 : 		// start with STPTs
; 1003 : 		DrawWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWayPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawWayPoints

; 1004 : 
; 1005 : 		// ...then do DL point(s)
; 1006 : 		int tmpColor = display->Color();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+108]
	call	edx
	mov	DWORD PTR _tmpColor$3[ebp], eax

; 1007 : 		display->SetColor(GetMfdColor(MFD_DATALINK));

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 1008 : 		DrawLinkPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLinkPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawLinkPoints

; 1009 : 		display->SetColor(tmpColor);

	mov	eax, DWORD PTR _tmpColor$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1010 : 
; 1011 : 		// ...and MARKs if there are any.
; 1012 : 		tmpColor = display->Color();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _tmpColor$3[ebp], eax

; 1013 : 		display->SetColor(GetMfdColor(MFD_DATALINK));

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1014 : 		DrawMarkPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMarkPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawMarkPoints

; 1015 : 		display->SetColor(tmpColor);

	mov	ecx, DWORD PTR _tmpColor$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1016 : 	}
; 1017 : 	else {

	jmp	$LN10@DrawNavPoi
$LN7@DrawNavPoi:

; 1018 : 
; 1019 : 		switch(mStptMode) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR tv199[ebp], edx
	cmp	DWORD PTR tv199[ebp], 3
	ja	$LN10@DrawNavPoi
	mov	eax, DWORD PTR tv199[ebp]
	jmp	DWORD PTR $LN12@DrawNavPoi[eax*4]
$LN3@DrawNavPoi:

; 1020 : 			// MD -- 20040228: do this when you are ground stabilized in GM SP as well
; 1021 : 	case FCCGMPseudoPoint:  
; 1022 : 	case FCCWaypoint:
; 1023 : 		DrawWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWayPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawWayPoints

; 1024 : 		//MI OA stuff
; 1025 : 		//MI 08/27/01 disabled. this stuff doesn't get displayed on the HSD AFAIK now
; 1026 : 		/*if(g_bRealisticAvionics)
; 1027 : 		{
; 1028 : 		DrawDESTOAPoints();
; 1029 : 		DrawVIPOAPoints();
; 1030 : 		DrawVRPOAPoints();
; 1031 : 		}*/
; 1032 : 		break;

	jmp	$LN10@DrawNavPoi
$LN2@DrawNavPoi:

; 1033 : 
; 1034 : 	case FCCDLinkpoint:
; 1035 : 		{
; 1036 : 			int tmpColor = display->Color();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _tmpColor$2[ebp], eax

; 1037 : 			display->SetColor(GetMfdColor(MFD_DATALINK));

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1038 : 			DrawLinkPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLinkPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawLinkPoints

; 1039 : 			display->SetColor(tmpColor);

	mov	ecx, DWORD PTR _tmpColor$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1040 : 		}
; 1041 : 		break;

	jmp	SHORT $LN10@DrawNavPoi
$LN1@DrawNavPoi:

; 1042 : 
; 1043 : 	case FCCMarkpoint:
; 1044 : 		{
; 1045 : 			int tmpColor = display->Color();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _tmpColor$1[ebp], eax

; 1046 : 			display->SetColor(GetMfdColor(MFD_DATALINK));

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1047 : 			DrawMarkPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMarkPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawMarkPoints

; 1048 : 			display->SetColor(tmpColor);

	mov	ecx, DWORD PTR _tmpColor$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN10@DrawNavPoi:

; 1049 : 		}
; 1050 : 		break;
; 1051 : 		}
; 1052 : 	}
; 1053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@DrawNavPoi:
	DD	$LN3@DrawNavPoi
	DD	$LN2@DrawNavPoi
	DD	$LN1@DrawNavPoi
	DD	$LN3@DrawNavPoi
?DrawNavPoints@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::DrawNavPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
tv1442 = -112						; size = 4
tv1541 = -108						; size = 4
_x19$ = -104						; size = 4
tv1434 = -100						; size = 4
_ymid$ = -96						; size = 4
tv1457 = -92						; size = 4
_OldScaleY$ = -88					; size = 4
_OldScaleX$ = -84					; size = 4
_x$1 = -80						; size = 4
tv1111 = -76						; size = 4
tv1078 = -72						; size = 4
_x18$ = -68						; size = 4
tv1097 = -64						; size = 4
_y19$ = -60						; size = 4
_tmpColor$ = -56					; size = 4
_y18$ = -52						; size = 4
_y$2 = -48						; size = 4
_playerAC$ = -44					; size = 4
_basedir$ = -40						; size = 4
_maxrings$3 = -36					; size = 4
_maxrings$4 = -32					; size = 4
_radius$ = -28						; size = 4
_i$ = -24						; size = 4
_this$ = -20						; size = 4
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?NavDisplay@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::NavDisplay
; _this$ = ecx

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 683  : 	//MI SOI
; 684  : 	CouldBeSOI = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+465], 1

; 685  : 	if(IsSOI)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN59@NavDisplay

; 686  : 	{
; 687  : 		display->SetColor(GetMfdColor(MFD_GREEN));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 688  : 		DrawBorder(); // JPO SOI

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawBorder@DrawableClass@@QAEXXZ	; DrawableClass::DrawBorder
$LN59@NavDisplay:

; 689  : 	}
; 690  :     int i;
; 691  :     char tmpStr[12];
; 692  :     static const float arrowH = 0.0375f;
; 693  :     static const float arrowW = 0.0433f;
; 694  :     float radius;
; 695  :     int tmpColor = display->Color();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+108]
	call	edx
	mov	DWORD PTR _tmpColor$[ebp], eax

; 696  :     float basedir = 0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _basedir$[ebp], xmm0

; 697  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 698  :     
; 699  :     //if (g_bEnableColorMfd)	DrawBorder();
; 700  :     if (IsHsdState(HSDFRZ)) 

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	$LN58@NavDisplay

; 701  : 	{
; 702  : 		float x, y;
; 703  : 		y = (frz_x - platform->XPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1434[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+104]
	subss	xmm0, DWORD PTR tv1434[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _y$2[ebp], xmm0

; 704  : 		x = (frz_y - platform->YPos()) * FT_TO_NM / HSDRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1442[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+108]
	subss	xmm0, DWORD PTR tv1442[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+160]
	movss	DWORD PTR _x$1[ebp], xmm0

; 705  : 		if (!IsHsdState(HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN57@NavDisplay

; 706  : 			y -= 0.4f;

	movss	xmm0, DWORD PTR _y$2[ebp]
	subss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR _y$2[ebp], xmm0
$LN57@NavDisplay:

; 707  : 		display->AdjustOriginInViewport(x, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 708  : 		basedir = platform->Yaw() - frz_dir;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv1457[ebp]
	movss	xmm0, DWORD PTR tv1457[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+112]
	movss	DWORD PTR _basedir$[ebp], xmm0

; 709  : 		display->AdjustRotationAboutOrigin(basedir);

	push	ecx
	movss	xmm0, DWORD PTR _basedir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin
	jmp	SHORT $LN55@NavDisplay
$LN58@NavDisplay:

; 710  :     }
; 711  :     else if (!IsHsdState(HSDCEN)) // JPO depressed view

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN55@NavDisplay

; 712  : 		display->AdjustOriginInViewport(0.0F, -0.4F);

	push	ecx
	movss	xmm0, DWORD PTR __real@becccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN55@NavDisplay:

; 713  : 
; 714  : 	//Wombat778 11-10-2003		Added to center on cursor in EXP modes
; 715  : 
; 716  : 	if ((HSDZoom > 0)	&& IsSOI )		

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jle	$LN50@NavDisplay
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+464]
	test	ecx, ecx
	je	$LN50@NavDisplay

; 717  : 	{
; 718  : 		if (!IsHsdState(HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN53@NavDisplay

; 719  : 		{
; 720  : 			if (HSDZoom == 2) 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 2
	jne	SHORT $LN52@NavDisplay

; 721  : 				display->AdjustOriginInViewport(-HSDXPos, (-HSDYPos)-0.4F);			//Adjust to the previously set HSDXPos and HSDYPos (set when zooming)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3ecccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+496]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 722  : 			else

	jmp	SHORT $LN51@NavDisplay
$LN52@NavDisplay:

; 723  : 				display->AdjustOriginInViewport(-HSDXPos, (-HSDYPos)-1.2F);			//Should only get here if the HSDZoom is 4

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+496]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN51@NavDisplay:

; 724  : 		}
; 725  : 		else

	jmp	SHORT $LN50@NavDisplay
$LN53@NavDisplay:

; 726  : 			display->AdjustOriginInViewport(-HSDXPos, -HSDYPos);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+496]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN50@NavDisplay:

; 727  : 	}
; 728  : 
; 729  : 	//Wombat778 11-10-2003		End of added code
; 730  : 
; 731  : 
; 732  : 	// RV - RED - WARNING...!!!!				
; 733  : 	// THIS IS KINDA A HACK - The 2D MFDs may be stretched by pit scaling
; 734  : 	// Rings would became ovals ( as it should be ) but later they r turned by AC Yaw...
; 735  : 	// This make the Oval to physically turn...
; 736  : 	// To avoid this, we remove ANY ASPECT RATION SCALING in the NAV MODE MFD making Scale X = Scale Y
; 737  : 	// saving it and restoring after gfx Draw
; 738  : 	// This is the fastest and more harmless way to fix till new code
; 739  : 	// and works fine, as the draw is then stretched by Texture drawing...
; 740  : 	float	OldScaleX=display->scaleX, OldScaleY=display->scaleY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR _OldScaleX$[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR _OldScaleY$[ebp], xmm0

; 741  : 	display->scaleY=display->scaleX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+36], edx

; 742  : 
; 743  :     // Add ownship marker
; 744  :     display->SetColor(GetMfdColor(MFD_OWNSHIP));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 745  :     display->Line (0.0F, 0.0F, 0.0F, -0.15F); // main fuselage

	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 746  :     display->Line (0.05F, -0.05F, -0.05F, -0.05F); // wings

	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 747  :     display->Line (0.02F, -0.12F, -0.02F, -0.12F); // tail

	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bca3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ca3d70a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 748  : 
; 749  : 
; 750  :     // Rotate for heading
; 751  :     display->AdjustRotationAboutOrigin(-platform->Yaw());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv1541[ebp]
	movss	xmm0, DWORD PTR tv1541[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 752  : 
; 753  : 	//MI changed for Zoom
; 754  : 	if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	$LN49@NavDisplay

; 755  : 	{
; 756  : 		if (!IsHsdState (HSDNORINGS) && !IsHsdState(HSDFRZ)) 

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN41@NavDisplay
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN41@NavDisplay

; 757  : 		{
; 758  : 			display->SetColor(GetMfdColor(MFD_LINES));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 759  : 			// Add Cardinal Headings
; 760  : 			int maxrings = NUM_RANGE_RINGS;

	mov	DWORD PTR _maxrings$3[ebp], 3

; 761  : 			if (IsHsdState(HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN47@NavDisplay

; 762  : 				maxrings --;

	mov	eax, DWORD PTR _maxrings$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _maxrings$3[ebp], eax
$LN47@NavDisplay:

; 763  : 			for (i=0; i<maxrings; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN46@NavDisplay
$LN45@NavDisplay:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN46@NavDisplay:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _maxrings$3[ebp]
	jge	$LN44@NavDisplay

; 764  : 			{
; 765  : 				radius = (float)(i+1) / maxrings;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _maxrings$3[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _radius$[ebp], xmm0

; 766  : 				display->Circle(0.0F, 0.0F, radius);

	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 767  : 				display->Line (0.0F,  radius + 0.05F,
; 768  : 					0.0F,  radius - 0.05F);

	movss	xmm0, DWORD PTR _radius$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 769  : 				display->Line (0.0F, -radius + 0.05F,
; 770  : 					0.0F, -radius - 0.05F);

	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 771  : 				display->Line (radius + 0.05F,
; 772  : 					0.0F,  radius - 0.05F,  0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 773  : 				display->Line (-radius + 0.05F,
; 774  : 					0.0F, -radius - 0.05F, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 775  : 			}

	jmp	$LN45@NavDisplay
$LN44@NavDisplay:

; 776  : 			// Add North Arrow
; 777  : 			//MI
; 778  : 			if(g_bRealisticAvionics && g_bINS)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN43@NavDisplay
	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	$LN43@NavDisplay

; 779  : 			{
; 780  : 				if(playerAC && playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN42@NavDisplay
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	$LN42@NavDisplay

; 781  : 					display->Tri (-0.05F, 1.0f/maxrings, 0.05F, 1.0f/maxrings, 0.0F, 1.0f/maxrings +0.1f);

	cvtsi2ss xmm0, DWORD PTR _maxrings$3[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$3[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$3[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN42@NavDisplay:

; 782  : 			}
; 783  : 			else

	jmp	$LN41@NavDisplay
$LN43@NavDisplay:

; 784  : 				display->Tri (-0.05F, 1.0f/maxrings, 0.05F, 1.0f/maxrings, 0.0F, 1.0f/maxrings +0.1f);

	cvtsi2ss xmm0, DWORD PTR _maxrings$3[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$3[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$3[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN41@NavDisplay:

; 785  : 		} 
; 786  : 	}
; 787  :    else

	jmp	$LN32@NavDisplay
$LN49@NavDisplay:

; 788  :    {
; 789  : 	   //MI this is not here if we have it expanded
; 790  : 	   if(!IsHsdState (HSDNORINGS) && !IsHsdState(HSDFRZ) && HSDZoom == 0) 

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN32@NavDisplay
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN32@NavDisplay
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	jne	$LN32@NavDisplay

; 791  : 	   {
; 792  : 		   display->SetColor(GetMfdColor(MFD_LINES));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 793  : 		   // Add Cardinal Headings
; 794  : 		   int maxrings = NUM_RANGE_RINGS;

	mov	DWORD PTR _maxrings$4[ebp], 3

; 795  : 		   if (IsHsdState(HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN38@NavDisplay

; 796  : 			   maxrings --;

	mov	ecx, DWORD PTR _maxrings$4[ebp]
	sub	ecx, 1
	mov	DWORD PTR _maxrings$4[ebp], ecx
$LN38@NavDisplay:

; 797  : 		   for (i=0; i<maxrings; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN37@NavDisplay
$LN36@NavDisplay:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN37@NavDisplay:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _maxrings$4[ebp]
	jge	$LN35@NavDisplay

; 798  : 		   {
; 799  : 			   radius = (float)(i+1) / maxrings;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _maxrings$4[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _radius$[ebp], xmm0

; 800  : 			   display->Circle(0.0F, 0.0F, radius);

	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 801  : 			   display->Line (0.0F,  radius + 0.05F,
; 802  : 				   0.0F,  radius - 0.05F);

	movss	xmm0, DWORD PTR _radius$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 803  : 			   display->Line (0.0F, -radius + 0.05F,
; 804  : 				   0.0F, -radius - 0.05F);

	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 805  : 			   display->Line (radius + 0.05F,
; 806  : 				   0.0F,  radius - 0.05F,  0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 807  : 			   display->Line (-radius + 0.05F,
; 808  : 				   0.0F, -radius - 0.05F, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 809  : 		   }

	jmp	$LN36@NavDisplay
$LN35@NavDisplay:

; 810  : 		   // Add North Arrow
; 811  : 		   //MI
; 812  : 			if(g_bRealisticAvionics && g_bINS)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN34@NavDisplay
	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	$LN34@NavDisplay

; 813  : 			{
; 814  : 				if(playerAC && playerAC->INSState(AircraftClass::INS_HSD_STUFF))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN33@NavDisplay
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	$LN33@NavDisplay

; 815  : 					display->Tri (-0.05F, 1.0f/maxrings, 0.05F, 1.0f/maxrings, 0.0F, 1.0f/maxrings +0.1f);

	cvtsi2ss xmm0, DWORD PTR _maxrings$4[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$4[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$4[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN33@NavDisplay:

; 816  : 			}
; 817  : 			else

	jmp	$LN32@NavDisplay
$LN34@NavDisplay:

; 818  : 				display->Tri (-0.05F, 1.0f/maxrings, 0.05F, 1.0f/maxrings, 0.0F, 1.0f/maxrings +0.1f);

	cvtsi2ss xmm0, DWORD PTR _maxrings$4[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$4[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _maxrings$4[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN32@NavDisplay:

; 819  : 	   }
; 820  :    }
; 821  :    display->SetColor(GetMfdColor(MFD_ROUTES));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 822  :    if (!IsHsdState(HSDNONAV1))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN31@NavDisplay

; 823  :        DrawNavPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawNavPoints@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawNavPoints
$LN31@NavDisplay:

; 824  :    if (!IsHsdState(HSDNOPRE) && g_bRealisticAvionics)

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN30@NavDisplay
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN30@NavDisplay

; 825  :        DrawPPThreats();   

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPPThreats@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawPPThreats
$LN30@NavDisplay:

; 826  : 
; 827  :    if (PlayerOptions.GetAvionicsType() != ATEasy) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	$LN29@NavDisplay

; 828  : 	   display->SetColor(GetMfdColor(MFD_LINES));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 829  : 	   if (!IsHsdState(HSDNOLINE2))

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN28@NavDisplay

; 830  : 	       DrawFLOT();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawFLOT@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawFLOT
$LN28@NavDisplay:

; 831  : 
; 832  : 	   // Draw additional data
; 833  : 	   if (!IsHsdState(HSDNOFCR)) {

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN24@NavDisplay

; 834  : 	       display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 835  : 	       display->AdjustRotationAboutOrigin(basedir);

	push	ecx
	movss	xmm0, DWORD PTR _basedir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 836  : 	       display->SetColor(GetMfdColor(MFD_CURSOR));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 837  : 		   if(g_bRealisticAvionics)	//MI changed

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN26@NavDisplay

; 838  : 		   {
; 839  : 			   if(HSDZoom == 0 && !IsSOI)	

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jne	SHORT $LN25@NavDisplay
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	jne	SHORT $LN25@NavDisplay

; 840  : 			   {
; 841  : 				   DrawGhostCursor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGhostCursor@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawGhostCursor

; 842  : 				   display->SetColor(GetMfdColor(MFD_SWEEP));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 843  : 				   DrawScanVolume();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawScanVolume@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawScanVolume
$LN25@NavDisplay:

; 844  : 			   }
; 845  : 		   }
; 846  : 		   else

	jmp	SHORT $LN24@NavDisplay
$LN26@NavDisplay:

; 847  : 		   {
; 848  : 			   DrawGhostCursor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGhostCursor@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawGhostCursor

; 849  : 			   display->SetColor(GetMfdColor(MFD_SWEEP));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 850  : 			   DrawScanVolume();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawScanVolume@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawScanVolume
$LN24@NavDisplay:

; 851  : 		   }
; 852  : 	   }
; 853  : 	   if (g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN22@NavDisplay

; 854  : 		   {
; 855  : 	       display->SetColor(GetMfdColor(MFD_UNKNOWN));

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 856  : 	       display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 857  : 	       display->AdjustRotationAboutOrigin(basedir);

	push	ecx
	movss	xmm0, DWORD PTR _basedir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 858  : 	       
; 859  : 	       DrawBuggedTarget ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawBuggedTarget@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawBuggedTarget

; 860  : 	       //if (!IsHsdState(HSDNOADLNK)) Cobra not needed we do this below in DrawWingmen
; 861  : 			  // {
; 862  : 				display->ZeroRotationAboutOrigin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 863  : 				display->AdjustRotationAboutOrigin(basedir);

	push	ecx
	movss	xmm0, DWORD PTR _basedir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 864  : 				DrawWingmen ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWingmen@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawWingmen

; 865  : 			   //}
; 866  : 
; 867  : 			//Cobra 11/27/04 AIFF
; 868  : 			if (!IsHsdState(HSDNOAIFF))

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN22@NavDisplay

; 869  : 				{
; 870  : 				display->SetColor(GetMfdColor(MFD_IFFFREIENDLY));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 871  : 				display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 872  : 				display->AdjustRotationAboutOrigin(basedir);

	push	ecx
	movss	xmm0, DWORD PTR _basedir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 873  : 				DrawAIFF();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAIFF@FireControlComputer@@AAEXXZ	; FireControlComputer::DrawAIFF
$LN22@NavDisplay:

; 874  : 				}
; 875  : 		   }
; 876  : 
; 877  : 	   display->ZeroRotationAboutOrigin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 878  : 	   display->CenterOriginInViewport ();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport

; 879  : 	   display->SetColor(GetMfdColor(MFD_BULLSEYE));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 880  : 	   DrawBullseye();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawBullseye@FireControlComputer@@AAEXXZ ; FireControlComputer::DrawBullseye

; 881  :    } else {

	jmp	SHORT $LN21@NavDisplay
$LN29@NavDisplay:

; 882  : 	   display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 883  : 	   display->CenterOriginInViewport ();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport
$LN21@NavDisplay:

; 884  :    }
; 885  : 
; 886  : 	// RV - RED - WARNING...!!!!				
; 887  : 	// THIS IS KINDA A HACK - The 2D MFDs may be stretched by pit scaling
; 888  : 	// Restore here the ORIGINAL MFDs Scaling
; 889  : 	display->scaleX=OldScaleX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR _OldScaleX$[ebp]
	movss	DWORD PTR [ecx+32], xmm0

; 890  : 	display->scaleY=OldScaleY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR _OldScaleY$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 891  :     
; 892  :     if (g_bRealisticAvionics) 

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN20@NavDisplay

; 893  : 	{ // JPO Extras for MLU MFD
; 894  : 		display->SetColor (GetMfdColor(MFD_LABELS));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 895  : 		BottomRow ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@MfdDrawable@@QAEXXZ		; MfdDrawable::BottomRow

; 896  : 		if (IsHsdState(HSDCNTL)) 

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	$LN19@NavDisplay

; 897  : 		{
; 898  : 			for (i = 0; i < 20; i ++) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@NavDisplay
$LN17@NavDisplay:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN18@NavDisplay:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	$LN16@NavDisplay

; 899  : 			{
; 900  : 				if (hsdcntlcfg[i].mode != HSDNONE) 

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[edx*8+4], 0
	je	SHORT $LN13@NavDisplay

; 901  : 				{
; 902  : 					if (hsdcntlcfg[i].mode == HSDCNTL) 

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[eax*8+4], 16 ; 00000010H
	jne	SHORT $LN14@NavDisplay

; 903  : 					LabelButton(i, hsdcntlcfg[i].label, NULL, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[ecx*8]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 904  : 					else

	jmp	SHORT $LN13@NavDisplay
$LN14@NavDisplay:

; 905  : 					LabelButton(i, hsdcntlcfg[i].label, NULL, !IsHsdState(hsdcntlcfg[i].mode));

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[ecx*8+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN62@NavDisplay
	mov	DWORD PTR tv1078[ebp], 1
	jmp	SHORT $LN63@NavDisplay
$LN62@NavDisplay:
	mov	DWORD PTR tv1078[ebp], 0
$LN63@NavDisplay:
	mov	eax, DWORD PTR tv1078[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[ecx*8]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN13@NavDisplay:

; 906  : 				}
; 907  : 			}

	jmp	$LN17@NavDisplay
$LN16@NavDisplay:

; 908  : 		}
; 909  : 		else 

	jmp	$LN12@NavDisplay
$LN19@NavDisplay:

; 910  : 		{
; 911  : 			LabelButton (0, IsHsdState(HSDCEN) ? "CEN" : "DEP");

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN64@NavDisplay
	mov	DWORD PTR tv1097[ebp], OFFSET ??_C@_03EPLBPKJA@CEN?$AA@
	jmp	SHORT $LN65@NavDisplay
$LN64@NavDisplay:
	mov	DWORD PTR tv1097[ebp], OFFSET ??_C@_03GCHPNPG@DEP?$AA@
$LN65@NavDisplay:
	push	0
	push	0
	mov	ecx, DWORD PTR tv1097[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 912  : 			LabelButton (1, IsHsdState(HSDCPL) ? "CPL" : "DCPL");

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN66@NavDisplay
	mov	DWORD PTR tv1111[ebp], OFFSET ??_C@_03GHGKPJIJ@CPL?$AA@
	jmp	SHORT $LN67@NavDisplay
$LN66@NavDisplay:
	mov	DWORD PTR tv1111[ebp], OFFSET ??_C@_04CNHPCPAB@DCPL?$AA@
$LN67@NavDisplay:
	push	0
	push	0
	mov	edx, DWORD PTR tv1111[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 913  : 			//MI
; 914  : 			if(HSDZoom == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+468], 0
	jne	SHORT $LN11@NavDisplay

; 915  : 				LabelButton (2, "NORM");

	push	0
	push	0
	push	OFFSET ??_C@_04DHIGGNDH@NORM?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
	jmp	SHORT $LN8@NavDisplay
$LN11@NavDisplay:

; 916  : 			else if(HSDZoom == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 2
	jne	SHORT $LN9@NavDisplay

; 917  : 				LabelButton(2,"EXP1");

	push	0
	push	0
	push	OFFSET ??_C@_04NJGNBJE@EXP1?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 918  : 			else

	jmp	SHORT $LN8@NavDisplay
$LN9@NavDisplay:

; 919  : 				LabelButton(2,"EXP2");

	push	0
	push	0
	push	OFFSET ??_C@_04CGLLICFH@EXP2?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN8@NavDisplay:

; 920  : 			LabelButton (4, "CNTL");

	push	0
	push	0
	push	OFFSET ??_C@_04GKDMIDBA@CNTL?$AA@
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 921  : 			LabelButton (6, "FRZ", NULL, IsHsdState(HSDFRZ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	push	eax
	push	0
	push	OFFSET ??_C@_03EPKIGIAC@FRZ?$AA@
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN12@NavDisplay:

; 922  : 		}
; 923  :         display->SetColor(tmpColor);

	mov	edx, DWORD PTR _tmpColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 924  :     }
; 925  :     else {

	jmp	SHORT $LN7@NavDisplay
$LN20@NavDisplay:

; 926  : 	display->SetColor(tmpColor);

	mov	eax, DWORD PTR _tmpColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 927  : 	LabelButton (2,  "NORM");

	push	0
	push	0
	push	OFFSET ??_C@_04DHIGGNDH@NORM?$AA@
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 928  : 	LabelButton (4,  "CNTL");

	push	0
	push	0
	push	OFFSET ??_C@_04GKDMIDBA@CNTL?$AA@
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 929  : 	LabelButton (11, "SMS");

	push	0
	push	0
	push	OFFSET ??_C@_03OONHJAKL@SMS?$AA@
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 930  : 	LabelButton (13, "HSD", NULL, 1);

	push	1
	push	0
	push	OFFSET ??_C@_03HKPEEKNJ@HSD?$AA@
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 931  : 	LabelButton (14, "SWAP");

	push	0
	push	0
	push	OFFSET ??_C@_04NLFHDAEB@SWAP?$AA@
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN7@NavDisplay:

; 932  :     }
; 933  : 
; 934  : 	/*--------*/
; 935  :     /* arrows */
; 936  :     /*--------*/
; 937  : 
; 938  :     // Add range and arrows - text is always present
; 939  : 	//MI this is not here if we have it expanded
; 940  : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN4@NavDisplay

; 941  : 	{
; 942  : 		if(IsSOI)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	je	SHORT $LN5@NavDisplay

; 943  : 		{
; 944  : 			//draw the cursor here
; 945  : 			HSDDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HSDDisplay@FireControlComputer@@QAEXXZ	; FireControlComputer::HSDDisplay
$LN5@NavDisplay:

; 946  : 		}
; 947  : 		if(HSDZoom != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	je	SHORT $LN4@NavDisplay

; 948  : 			return;

	jmp	$LN60@NavDisplay
$LN4@NavDisplay:

; 949  : 	}
; 950  : 
; 951  :     sprintf(tmpStr,"%.0f",HSDRange);

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+160]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 952  :     ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 953  :     float x18, y18;
; 954  :     float x19, y19;
; 955  :     GetButtonPos(18, &x18, &y18);

	lea	ecx, DWORD PTR _y18$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x18$[ebp]
	push	edx
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z ; DrawableClass::GetButtonPos

; 956  :     GetButtonPos(19, &x19, &y19);

	lea	eax, DWORD PTR _y19$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x19$[ebp]
	push	ecx
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetButtonPos@DrawableClass@@QAEXHPAM0@Z ; DrawableClass::GetButtonPos

; 957  :     float ymid = y18 + (y19-y18)/2;

	movss	xmm0, DWORD PTR _y19$[ebp]
	subss	xmm0, DWORD PTR _y18$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _y18$[ebp]
	movss	DWORD PTR _ymid$[ebp], xmm0

; 958  :     display->TextLeftVertical(x18, ymid, tmpStr);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _ymid$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x18$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+64]
	call	edx

; 959  : 
; 960  :     if (!IsHsdState(HSDCPL) && !IsHsdState(HSDCNTL) && !IsHsdState(HSDFRZ)) {

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN1@NavDisplay
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN1@NavDisplay
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN1@NavDisplay

; 961  : 	/*----------*/
; 962  : 	/* up arrow */
; 963  : 	/*----------*/
; 964  : 	display->AdjustOriginInViewport( x19 + arrowW, y19 + arrowH/2);

	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _y19$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x19$[ebp]
	addss	xmm0, DWORD PTR ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 965  : 	if (HsdRangeIndex < HSDRANGESIZE-1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+164], 4
	jge	SHORT $LN2@NavDisplay

; 966  : 	    display->Tri (0.0F, arrowH, arrowW, -arrowH, -arrowW, -arrowH);

	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN2@NavDisplay:

; 967  : 	
; 968  : 	/*------------*/
; 969  : 	/* down arrow */
; 970  : 	/*------------*/
; 971  : 	display->CenterOriginInViewport ();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport

; 972  : 	display->AdjustOriginInViewport( x18 + arrowW, y18 - arrowH/2);

	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _y18$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _x18$[ebp]
	addss	xmm0, DWORD PTR ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 973  : 	if (HsdRangeIndex > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+164], 0
	jle	SHORT $LN1@NavDisplay

; 974  : 	    display->Tri (0.0F, -arrowH, arrowW, arrowH, -arrowW, arrowH);

	push	ecx
	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?arrowW@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?arrowH@?4??NavDisplay@FireControlComputer@@AAEXXZ@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN1@NavDisplay:

; 975  :     }
; 976  :     display->CenterOriginInViewport ();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport
$LN60@NavDisplay:

; 977  : 
; 978  : 	
; 979  : 
; 980  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?NavDisplay@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::NavDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_curWaypoint$ = -12					; size = 4
_this$ = -8						; size = 4
_nextWaypoint$ = -4					; size = 4
?StepPrevWayPoint@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::StepPrevWayPoint
; _this$ = ecx

; 561  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 	WayPointClass* nextWaypoint;
; 563  :    WayPointClass* curWaypoint;
; 564  : 	
; 565  : 	curWaypoint		= platform->curWaypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR [ecx+728]
	mov	DWORD PTR _curWaypoint$[ebp], edx

; 566  : 
; 567  :    if (curWaypoint)

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	$LN6@StepPrevWa

; 568  :    {
; 569  :       nextWaypoint	= curWaypoint->GetPrevWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _nextWaypoint$[ebp], eax

; 570  : 
; 571  :       if (nextWaypoint)

	cmp	DWORD PTR _nextWaypoint$[ebp], 0
	je	SHORT $LN5@StepPrevWa

; 572  :       {
; 573  :          platform->curWaypoint = nextWaypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _nextWaypoint$[ebp]
	mov	DWORD PTR [ecx+728], edx

; 574  :          TheHud->waypointNum --;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	ecx, DWORD PTR [eax+4948]
	sub	ecx, 1
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4948], ecx

; 575  :       }
; 576  :       else

	jmp	SHORT $LN4@StepPrevWa
$LN5@StepPrevWa:

; 577  :       {
; 578  :          nextWaypoint = platform->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _nextWaypoint$[ebp], edx

; 579  :          TheHud->waypointNum = 0;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+4948], 0
$LN3@StepPrevWa:

; 580  :          while (nextWaypoint && nextWaypoint->GetNextWP())

	cmp	DWORD PTR _nextWaypoint$[ebp], 0
	je	SHORT $LN2@StepPrevWa
	mov	ecx, DWORD PTR _nextWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN2@StepPrevWa

; 581  :          {
; 582  :             nextWaypoint = nextWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _nextWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nextWaypoint$[ebp], eax

; 583  :             TheHud->waypointNum ++;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+4948]
	add	edx, 1
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+4948], edx

; 584  :          }

	jmp	SHORT $LN3@StepPrevWa
$LN2@StepPrevWa:

; 585  :          platform->curWaypoint = nextWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _nextWaypoint$[ebp]
	mov	DWORD PTR [edx+728], eax
$LN4@StepPrevWa:

; 586  :       }
; 587  :    }
; 588  :    else

	jmp	SHORT $LN1@StepPrevWa
$LN6@StepPrevWa:

; 589  :    {
; 590  :       TheHud->waypointNum = 0;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4948], 0
$LN1@StepPrevWa:

; 591  :    }
; 592  : 
; 593  :    OTWDriver.pCockpitManager->mpIcp->SetICPWPIndex(TheHud->waypointNum);

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	eax, DWORD PTR [edx+4948]
	push	eax
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPWPIndex@ICPClass@@QAEXH@Z	; ICPClass::SetICPWPIndex

; 594  :    OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(STPT_UPDATE);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 595  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepPrevWayPoint@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::StepPrevWayPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_curWaypoint$ = -16					; size = 4
_nextWaypoint$ = -12					; size = 4
_pntNum$ = -8						; size = 4
_this$ = -4						; size = 4
?StepNextWayPoint@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::StepNextWayPoint
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 496  : WayPointClass* nextWaypoint;
; 497  : WayPointClass* curWaypoint;
; 498  : int pntNum = TheHud->waypointNum;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	ecx, DWORD PTR [eax+4948]
	mov	DWORD PTR _pntNum$[ebp], ecx

; 499  : 	
; 500  : 	curWaypoint		= platform->curWaypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+728]
	mov	DWORD PTR _curWaypoint$[ebp], ecx

; 501  : 
; 502  : #if 1
; 503  : 	if(curWaypoint)	// OW 

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	SHORT $LN4@StepNextWa

; 504  : 	   nextWaypoint	= curWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nextWaypoint$[ebp], eax

; 505  : 	else

	jmp	SHORT $LN3@StepNextWa
$LN4@StepNextWa:

; 506  : 		nextWaypoint	= NULL;

	mov	DWORD PTR _nextWaypoint$[ebp], 0
$LN3@StepNextWa:

; 507  : #else
; 508  : 	   nextWaypoint	= curWaypoint->GetNextWP();
; 509  : #endif
; 510  : 
; 511  :    if (nextWaypoint)

	cmp	DWORD PTR _nextWaypoint$[ebp], 0
	je	SHORT $LN2@StepNextWa

; 512  :    {
; 513  :       platform->curWaypoint = nextWaypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _nextWaypoint$[ebp]
	mov	DWORD PTR [eax+728], ecx

; 514  :       pntNum ++;

	mov	edx, DWORD PTR _pntNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _pntNum$[ebp], edx

; 515  :    }
; 516  :    else

	jmp	SHORT $LN1@StepNextWa
$LN2@StepNextWa:

; 517  :    {
; 518  :       platform->curWaypoint = platform->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [ecx+732]
	mov	DWORD PTR [eax+728], ecx

; 519  :       pntNum = 0;

	mov	DWORD PTR _pntNum$[ebp], 0
$LN1@StepNextWa:

; 520  :    }
; 521  : 
; 522  :    SetWaypointNum (pntNum);

	mov	edx, DWORD PTR _pntNum$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWaypointNum@FireControlComputer@@QAEXH@Z ; FireControlComputer::SetWaypointNum

; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepNextWayPoint@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::StepNextWayPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_theRadar$1 = -20					; size = 4
_playerAC$ = -16					; size = 4
tv148 = -12						; size = 4
_theRadar$2 = -8					; size = 4
_this$ = -4						; size = 4
?InitNewStptMode@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::InitNewStptMode
; _this$ = ecx

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 	AircraftClass *playerAC =SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 430  : 	if(platform == (SimVehicleClass*) playerAC) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	cmp	ecx, DWORD PTR _playerAC$[ebp]
	jne	$LN14@InitNewStp

; 431  : 	
; 432  : 		if(mNewStptMode != mStptMode) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+128]
	cmp	ecx, DWORD PTR [eax+124]
	je	$LN14@InitNewStp

; 433  : 			// Save the current
; 434  : 			if(mStptMode == FCCWaypoint) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN11@InitNewStp

; 435  : 				mpSavedWaypoint		= platform->curWaypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+728]
	mov	DWORD PTR [edx+116], eax

; 436  : 				mSavedWayNumber		= TheHud->waypointNum;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	eax, DWORD PTR [edx+4948]
	mov	DWORD PTR [ecx+120], eax
$LN11@InitNewStp:

; 437  : 			}
; 438  : 
; 439  : 			// MD -- 20040228: on mode change, cancel any GM SP ground stabilization
; 440  : 			if (mStptMode == FCCGMPseudoPoint) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 3
	jne	SHORT $LN10@InitNewStp

; 441  : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$2[ebp], eax

; 442  : 				if (theRadar->IsSet(RadarDopplerClass::SP) && theRadar->IsSet(RadarDopplerClass::SP_STAB)) {

	push	64					; 00000040H
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN10@InitNewStp
	push	128					; 00000080H
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN10@InitNewStp

; 443  : 					theRadar->SetGMSPWaypt(NULL);  // clear any existing point data

	push	0
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	call	?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z ; RadarDopplerClass::SetGMSPWaypt

; 444  : 					theRadar->ClearFlagBit(RadarDopplerClass::SP_STAB);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 445  : 					theRadar->ToggleAGcursorZero();

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+180]
	call	eax
$LN10@InitNewStp:

; 446  : 				}
; 447  : 			}
; 448  : 
; 449  : 			// Restore the old
; 450  : 			switch(mNewStptMode) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR tv148[ebp], edx
	cmp	DWORD PTR tv148[ebp], 3
	ja	$LN14@InitNewStp
	mov	eax, DWORD PTR tv148[ebp]
	jmp	DWORD PTR $LN16@InitNewStp[eax*4]
$LN6@InitNewStp:

; 451  : 
; 452  : 			case FCCWaypoint:
; 453  : 
; 454  : 				if(!mpSavedWaypoint) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 0
	jne	SHORT $LN5@InitNewStp

; 455  : 					platform->curWaypoint = platform->waypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [eax+732]
	mov	DWORD PTR [edx+728], eax

; 456  : 				}
; 457  : 				else {

	jmp	SHORT $LN4@InitNewStp
$LN5@InitNewStp:

; 458  : 					platform->curWaypoint	= mpSavedWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR [edx+728], ecx
$LN4@InitNewStp:

; 459  : 				}
; 460  : 
; 461  : 				TheHud->waypointNum	= mSavedWayNumber;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR [edx+4948], ecx

; 462  : 				mStptMode = mNewStptMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR [edx+124], ecx

; 463  : 				break;

	jmp	$LN14@InitNewStp
$LN3@InitNewStp:

; 464  : 
; 465  : 			case FCCMarkpoint:
; 466  : 				gNavigationSys->GetMarkWayPoint(&platform->curWaypoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	add	eax, 728				; 000002d8H
	push	eax
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetMarkWayPoint@NavigationSystem@@QAEXPAPAVWayPointClass@@@Z ; NavigationSystem::GetMarkWayPoint

; 467  : 				TheHud->waypointNum	= gNavigationSys->GetMarkIndex() + 20;

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetMarkIndex@NavigationSystem@@QAEHXZ	; NavigationSystem::GetMarkIndex
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4948], eax

; 468  : 				mStptMode = mNewStptMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR [edx+124], ecx

; 469  : 				break;

	jmp	$LN14@InitNewStp
$LN2@InitNewStp:

; 470  : 
; 471  : 			case FCCDLinkpoint:
; 472  : 				gNavigationSys->GetDLinkWayPoint(&platform->curWaypoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	add	eax, 728				; 000002d8H
	push	eax
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDLinkWayPoint@NavigationSystem@@QAEXPAPAVWayPointClass@@@Z ; NavigationSystem::GetDLinkWayPoint

; 473  : 				TheHud->waypointNum	= gNavigationSys->GetDLinkIndex() + 30;

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDLinkIndex@NavigationSystem@@QAEHXZ	; NavigationSystem::GetDLinkIndex
	add	eax, 30					; 0000001eH
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4948], eax

; 474  : 				//mStptMode = FCCWaypoint;	//MI outcommented. Causes our STPT to not be restored correctly.
; 475  : 				mStptMode = FCCDLinkpoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 1

; 476  : 				break;

	jmp	SHORT $LN14@InitNewStp
$LN1@InitNewStp:

; 477  : 			case FCCGMPseudoPoint:
; 478  : 				{
; 479  : 					RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 480  : 					mpSavedWaypoint	= platform->curWaypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+728]
	mov	DWORD PTR [ecx+116], edx

; 481  : 					mSavedWayNumber	= TheHud->waypointNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+4948]
	mov	DWORD PTR [eax+120], edx

; 482  : 					platform->curWaypoint = theRadar->GMSPWaypt();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ; RadarDopplerClass::GMSPWaypt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [edx+728], eax

; 483  : 					mStptMode = mNewStptMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+124], edx
$LN14@InitNewStp:

; 484  : 				}
; 485  : 				break;
; 486  : 			}
; 487  : 		}
; 488  : 
; 489  : //		mStptMode = mNewStptMode;
; 490  : 	}
; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@InitNewStp:
	DD	$LN6@InitNewStp
	DD	$LN2@InitNewStp
	DD	$LN3@InitNewStp
	DD	$LN1@InitNewStp
?InitNewStptMode@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::InitNewStptMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
_rx$ = -24						; size = 4
_ry$ = -20						; size = 4
_rz$ = -16						; size = 4
_theRadar$ = -12					; size = 4
tv74 = -8						; size = 4
_this$ = -4						; size = 4
?StepPoint@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::StepPoint
; _this$ = ecx

; 600  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 	RadarClass* theRadar;
; 602  : 	float			rx, ry, rz;
; 603  : 
; 604  : 	if (waypointStepCmd == 1 || waypointStepCmd == -1 || waypointStepCmd == 127) {

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+194]
	cmp	ecx, 1
	je	SHORT $LN17@StepPoint
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	cmp	eax, -1
	je	SHORT $LN17@StepPoint
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+194]
	cmp	edx, 127				; 0000007fH
	jne	$LN18@StepPoint
$LN17@StepPoint:

; 605  : 
; 606  : 		switch(mStptMode) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR tv74[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 0
	je	SHORT $LN14@StepPoint
	cmp	DWORD PTR tv74[ebp], 1
	je	$LN6@StepPoint
	cmp	DWORD PTR tv74[ebp], 2
	je	SHORT $LN10@StepPoint
	jmp	$LN15@StepPoint
$LN14@StepPoint:

; 607  : 
; 608  : 		case FCCWaypoint:
; 609  : 
; 610  : 			//MI 10/02/02 Why?
; 611  :          //if (!platform->OnGround())
; 612  :          {
; 613  : 			   if (waypointStepCmd == 1) {

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	cmp	eax, 1
	jne	SHORT $LN13@StepPoint

; 614  : 				   StepNextWayPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepNextWayPoint@FireControlComputer@@AAEXXZ ; FireControlComputer::StepNextWayPoint
	jmp	SHORT $LN11@StepPoint
$LN13@StepPoint:

; 615  : 			   }
; 616  : 			   else if (waypointStepCmd == -1){

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+194]
	cmp	edx, -1
	jne	SHORT $LN11@StepPoint

; 617  : 				   StepPrevWayPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepPrevWayPoint@FireControlComputer@@AAEXXZ ; FireControlComputer::StepPrevWayPoint
$LN11@StepPoint:

; 618  : 			   }
; 619  :          }
; 620  :          /*else
; 621  :          {
; 622  :             waypointStepCmd = 0;
; 623  :          }*/
; 624  : 			OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(STPT_UPDATE);

	push	1
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 625  : 			OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(CNI_UPDATE);

	push	256					; 00000100H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 626  : 			break;

	jmp	$LN15@StepPoint
$LN10@StepPoint:

; 627  : 
; 628  : 		case FCCMarkpoint:
; 629  : 
; 630  : 			if (waypointStepCmd == 1) {

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	cmp	eax, 1
	jne	SHORT $LN9@StepPoint

; 631  : 				gNavigationSys->GotoNextMark();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GotoNextMark@NavigationSystem@@QAEXXZ	; NavigationSystem::GotoNextMark
	jmp	SHORT $LN7@StepPoint
$LN9@StepPoint:

; 632  : 			}
; 633  : 			else if (waypointStepCmd == -1){

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+194]
	cmp	edx, -1
	jne	SHORT $LN7@StepPoint

; 634  : 				gNavigationSys->GotoPrevMark();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GotoPrevMark@NavigationSystem@@QAEXXZ	; NavigationSystem::GotoPrevMark
$LN7@StepPoint:

; 635  : 			}
; 636  : 
; 637  : 			gNavigationSys->GetMarkWayPoint(&platform->curWaypoint);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	add	ecx, 728				; 000002d8H
	push	ecx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetMarkWayPoint@NavigationSystem@@QAEXPAPAVWayPointClass@@@Z ; NavigationSystem::GetMarkWayPoint

; 638  : 			TheHud->waypointNum	= gNavigationSys->GetMarkIndex() + 20;

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetMarkIndex@NavigationSystem@@QAEHXZ	; NavigationSystem::GetMarkIndex
	add	eax, 20					; 00000014H
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4948], eax

; 639  : 			OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(MARK_UPDATE);

	push	4
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 640  : 			OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(CNI_UPDATE);

	push	256					; 00000100H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 641  : 			break;

	jmp	$LN15@StepPoint
$LN6@StepPoint:

; 642  : 
; 643  : 		case FCCDLinkpoint:
; 644  : 
; 645  : 			if (waypointStepCmd == 1) {

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	cmp	eax, 1
	jne	SHORT $LN5@StepPoint

; 646  : 				gNavigationSys->GotoNextDLink();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GotoNextDLink@NavigationSystem@@QAEXXZ	; NavigationSystem::GotoNextDLink
	jmp	SHORT $LN3@StepPoint
$LN5@StepPoint:

; 647  : 			}
; 648  : 			else if (waypointStepCmd == -1){

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+194]
	cmp	edx, -1
	jne	SHORT $LN3@StepPoint

; 649  : 				gNavigationSys->GotoPrevDLink();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GotoPrevDLink@NavigationSystem@@QAEXXZ	; NavigationSystem::GotoPrevDLink
$LN3@StepPoint:

; 650  : 			}
; 651  : 
; 652  : 			gNavigationSys->GetDLinkWayPoint(&platform->curWaypoint);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	add	ecx, 728				; 000002d8H
	push	ecx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDLinkWayPoint@NavigationSystem@@QAEXPAPAVWayPointClass@@@Z ; NavigationSystem::GetDLinkWayPoint

; 653  : 			TheHud->waypointNum	= gNavigationSys->GetDLinkIndex() + 30;

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDLinkIndex@NavigationSystem@@QAEHXZ	; NavigationSystem::GetDLinkIndex
	add	eax, 30					; 0000001eH
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4948], eax

; 654  : 			OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(DLINK_UPDATE);

	push	2
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag

; 655  : 			OTWDriver.pCockpitManager->mpIcp->SetICPUpdateFlag(CNI_UPDATE);

	push	256					; 00000100H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPUpdateFlag@ICPClass@@QAEXH@Z	; ICPClass::SetICPUpdateFlag
$LN15@StepPoint:

; 656  : 			break;
; 657  : 		}
; 658  : 
; 659  : 		if(platform->curWaypoint) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	cmp	DWORD PTR [eax+728], 0
	je	SHORT $LN1@StepPoint

; 660  : 			theRadar = (RadarClass*) FindSensor (platform, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 661  : 			if (theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN1@StepPoint

; 662  : 			{
; 663  : 				platform->curWaypoint->GetLocation (&rx, &ry, &rz);

	lea	eax, DWORD PTR _rz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ry$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rx$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 664  : 				theRadar->SetGroundPoint(rx, ry, rz);

	push	ecx
	movss	xmm0, DWORD PTR _rz$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+184]
	call	edx
$LN1@StepPoint:

; 665  : 			}
; 666  : 		}
; 667  : 
; 668  : 		OTWDriver.pCockpitManager->mpIcp-> SetICPWPIndex(TheHud->waypointNum);

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	ecx, DWORD PTR [eax+4948]
	push	ecx
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?SetICPWPIndex@ICPClass@@QAEXH@Z	; ICPClass::SetICPWPIndex

; 669  : 
; 670  : 
; 671  : 		waypointStepCmd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+194], 0
$LN18@StepPoint:

; 672  : 	}
; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepPoint@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::StepPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\navfcc.cpp
_TEXT	SEGMENT
tv1730 = -524						; size = 8
tv1617 = -516						; size = 8
tv1681 = -508						; size = 8
tv1672 = -500						; size = 8
_z$1 = -492						; size = 4
tv2254 = -488						; size = 4
tv1593 = -484						; size = 4
tv1764 = -480						; size = 4
tv1660 = -476						; size = 4
tv1872 = -472						; size = 4
tv2231 = -468						; size = 4
tv1709 = -464						; size = 4
tv2268 = -460						; size = 4
_x$2 = -456						; size = 4
_rz$3 = -452						; size = 4
tv1573 = -448						; size = 4
tv2180 = -444						; size = 4
tv1901 = -440						; size = 4
tv2266 = -436						; size = 4
_rz$ = -432						; size = 4
tv2175 = -428						; size = 4
tv1740 = -424						; size = 4
tv2166 = -420						; size = 4
tv1666 = -416						; size = 4
tv2160 = -412						; size = 4
_y$4 = -408						; size = 4
tv2143 = -404						; size = 4
tv2246 = -400						; size = 4
tv2264 = -396						; size = 4
tv1588 = -392						; size = 4
_rz$5 = -388						; size = 4
tv1556 = -384						; size = 4
tv2092 = -380						; size = 4
tv1910 = -376						; size = 4
tv2262 = -372						; size = 4
tv1895 = -368						; size = 4
tv2087 = -364						; size = 4
tv2252 = -360						; size = 4
tv2078 = -356						; size = 4
tv1804 = -352						; size = 4
tv2072 = -348						; size = 4
tv2250 = -344						; size = 4
tv2055 = -340						; size = 4
tv1721 = -336						; size = 4
tv2260 = -332						; size = 4
tv1702 = -328						; size = 4
_rz$6 = -324						; size = 4
tv2248 = -320						; size = 4
tv2004 = -316						; size = 4
tv1651 = -312						; size = 4
tv2258 = -308						; size = 4
tv1646 = -304						; size = 4
tv1999 = -300						; size = 4
tv1622 = -296						; size = 4
tv1990 = -292						; size = 4
tv1597 = -288						; size = 4
tv1984 = -284						; size = 4
tv2244 = -280						; size = 4
tv1966 = -276						; size = 4
tv1579 = -272						; size = 4
tv2256 = -268						; size = 4
_wpZ$ = -264						; size = 4
_rz$7 = -260						; size = 4
tv1915 = -256						; size = 4
tv1561 = -252						; size = 4
tv655 = -248						; size = 4
tv135 = -244						; size = 4
tv516 = -240						; size = 4
_dy$8 = -236						; size = 4
tv515 = -232						; size = 4
tv1677 = -228						; size = 4
tv508 = -224						; size = 4
tv141 = -220						; size = 4
tv483 = -216						; size = 4
tv129 = -212						; size = 4
tv482 = -208						; size = 4
tv1669 = -204						; size = 4
tv475 = -200						; size = 4
_dx$9 = -196						; size = 4
tv468 = -192						; size = 4
tv140 = -188						; size = 4
tv467 = -184						; size = 4
tv130 = -180						; size = 4
tv460 = -176						; size = 4
tv1727 = -172						; size = 4
tv92 = -168						; size = 4
_ry$10 = -164						; size = 4
_rx$ = -160						; size = 4
_rx$11 = -156						; size = 4
_rx$12 = -152						; size = 4
_dy$13 = -148						; size = 4
_dx$14 = -144						; size = 4
_dx$15 = -140						; size = 4
_dx$16 = -136						; size = 4
_ry$17 = -132						; size = 4
_theRadar$18 = -128					; size = 4
_rx$19 = -124						; size = 4
_ry$20 = -120						; size = 4
_dy$21 = -116						; size = 4
_dy$22 = -112						; size = 4
_dx$23 = -108						; size = 4
_ry$ = -104						; size = 4
_ry$24 = -100						; size = 4
_curWaypoint$ = -96					; size = 4
_rx$25 = -92						; size = 4
_dy$26 = -88						; size = 4
_curVRP$27 = -84					; size = 4
_curVIP$28 = -80					; size = 4
tv361 = -76						; size = 4
_wpY$ = -72						; size = 4
_theRadar$29 = -68					; size = 4
_dz$30 = -64						; size = 4
_dz$31 = -60						; size = 4
_wpX$ = -56						; size = 4
_dz$32 = -52						; size = 4
_dz$33 = -48						; size = 4
_i$34 = -44						; size = 4
_OAZPos$35 = -40					; size = 4
_dz$ = -36						; size = 4
_dx$ = -32						; size = 4
_curOA$36 = -28						; size = 4
_dy$ = -24						; size = 4
_ttg$ = -20						; size = 4
_OAYPos$37 = -16					; size = 4
_OAXPos$38 = -12					; size = 4
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?NavMode@FireControlComputer@@AAEXXZ PROC		; FireControlComputer::NavMode
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	DWORD PTR _this$[ebp], ecx

; 88   :     float wpX, wpY, wpZ;
; 89   :     float dx, dy, dz;
; 90   :     float rx, ry, rz;
; 91   :     float ttg = 0.0f;//Cobra 11/12/04

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ttg$[ebp], xmm0

; 92   :     WayPointClass* curWaypoint = platform->curWaypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR [ecx+728]
	mov	DWORD PTR _curWaypoint$[ebp], edx

; 93   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 94   : 	
; 95   : 	if (!IsHsdState(HSDCPL)) {

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	$LN68@NavMode

; 96   : 		if (HSDRangeStepCmd > 0)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+195]
	test	ecx, ecx
	jle	SHORT $LN67@NavMode

; 97   : 			HsdRangeIndex ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], eax
	jmp	SHORT $LN65@NavMode
$LN67@NavMode:

; 98   : 		else if (HSDRangeStepCmd < 0)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+195]
	test	eax, eax
	jge	SHORT $LN65@NavMode

; 99   : 			HsdRangeIndex --;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], edx
$LN65@NavMode:

; 100  : 		
; 101  : 		if (g_bRealisticAvionics) // lock values

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN64@NavMode

; 102  : 			HsdRangeIndex = max (min (HsdRangeIndex, HSDRANGESIZE-1), 0);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 4
	jge	SHORT $LN71@NavMode
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR tv92[ebp], ecx
	jmp	SHORT $LN72@NavMode
$LN71@NavMode:
	mov	DWORD PTR tv92[ebp], 4
$LN72@NavMode:
	cmp	DWORD PTR tv92[ebp], 0
	jle	SHORT $LN75@NavMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 4
	jge	SHORT $LN73@NavMode
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR tv129[ebp], ecx
	jmp	SHORT $LN74@NavMode
$LN73@NavMode:
	mov	DWORD PTR tv129[ebp], 4
$LN74@NavMode:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv130[ebp], edx
	jmp	SHORT $LN76@NavMode
$LN75@NavMode:
	mov	DWORD PTR tv130[ebp], 0
$LN76@NavMode:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR [eax+164], ecx

; 103  : 		else 

	jmp	SHORT $LN63@NavMode
$LN64@NavMode:

; 104  : 			HsdRangeIndex = max (min (HsdRangeIndex, HSDRANGESIZE-2), 0);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 3
	jge	SHORT $LN77@NavMode
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN78@NavMode
$LN77@NavMode:
	mov	DWORD PTR tv135[ebp], 3
$LN78@NavMode:
	cmp	DWORD PTR tv135[ebp], 0
	jle	SHORT $LN81@NavMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 3
	jge	SHORT $LN79@NavMode
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR tv140[ebp], ecx
	jmp	SHORT $LN80@NavMode
$LN79@NavMode:
	mov	DWORD PTR tv140[ebp], 3
$LN80@NavMode:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], edx
	jmp	SHORT $LN82@NavMode
$LN81@NavMode:
	mov	DWORD PTR tv141[ebp], 0
$LN82@NavMode:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv141[ebp]
	mov	DWORD PTR [eax+164], ecx
$LN63@NavMode:

; 105  : 		
; 106  : 		HSDRange = (float)HsdRangeTbl[HsdRangeIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	cvtsi2ss xmm0, DWORD PTR ?HsdRangeTbl@FireControlComputer@@0PAHA[eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+160], xmm0

; 107  : 		if (IsHsdState (HSDCEN))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN62@NavMode

; 108  : 			HSDRange /= 1.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+160]
	divss	xmm0, DWORD PTR __real@3fc00000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+160], xmm0
$LN62@NavMode:

; 109  :     }
; 110  :     else {

	jmp	SHORT $LN58@NavMode
$LN68@NavMode:

; 111  : 		RadarClass* theRadar = (RadarClass*)FindSensor (platform, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$18[ebp], eax

; 112  : 		if (theRadar) {

	cmp	DWORD PTR _theRadar$18[ebp], 0
	je	SHORT $LN60@NavMode

; 113  : 			HSDRange = theRadar->GetRange();

	mov	eax, DWORD PTR _theRadar$18[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$18[ebp]
	mov	eax, DWORD PTR [edx+196]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+160]

; 114  : 			if (!IsHsdState (HSDCEN)) {

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	jne	SHORT $LN59@NavMode

; 115  : 				HSDRange *= 1.5;

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+160]
	mulsd	xmm0, QWORD PTR __real@3ff8000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+160], xmm0
$LN59@NavMode:

; 116  : 			}
; 117  : 		}
; 118  : 		else {

	jmp	SHORT $LN58@NavMode
$LN60@NavMode:

; 119  : 			ToggleHsdState(HSDCPL);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN58@NavMode:

; 120  : 		}
; 121  :     }
; 122  :     HSDRangeStepCmd = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+195], 0

; 123  : 	
; 124  :     if (platform == (SimBaseClass*)(playerAC) && TheHud)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	cmp	eax, DWORD PTR _playerAC$[ebp]
	jne	$LN57@NavMode
	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN57@NavMode

; 125  :     {
; 126  : 		//evaluate_flight_vc (platform->curWaypoint, platform->XPos (), platform->YPos (), platform->ZPos (), 0); // need speed at the end of here...
; 127  : 		
; 128  : 		if (curWaypoint)

	cmp	DWORD PTR _curWaypoint$[ebp], 0
	je	$LN56@NavMode

; 129  : 		{
; 130  : 			// Current waypoint
; 131  : 			curWaypoint->GetLocation (&wpX, &wpY, &wpZ);

	lea	ecx, DWORD PTR _wpZ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wpY$[ebp]
	push	edx
	lea	eax, DWORD PTR _wpX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 132  : 			//MI add in INS Drift
; 133  : 			if(g_bINS && g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN54@NavMode
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN54@NavMode

; 134  : 			{
; 135  : 				if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN54@NavMode

; 136  : 				{
; 137  : 					wpX += playerAC->GetINSLatDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLatDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLatDrift
	fstp	DWORD PTR tv1556[ebp]
	movss	xmm0, DWORD PTR tv1556[ebp]
	addss	xmm0, DWORD PTR _wpX$[ebp]
	movss	DWORD PTR _wpX$[ebp], xmm0

; 138  : 					wpY += playerAC->GetINSLongDrift();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSLongDrift@AircraftClass@@QAEMXZ	; AircraftClass::GetINSLongDrift
	fstp	DWORD PTR tv1561[ebp]
	movss	xmm0, DWORD PTR tv1561[ebp]
	addss	xmm0, DWORD PTR _wpY$[ebp]
	movss	DWORD PTR _wpY$[ebp], xmm0
$LN54@NavMode:

; 139  : 				}
; 140  : 			}
; 141  : 			TheHud->waypointX = wpX;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR _wpX$[ebp]
	movss	DWORD PTR [eax+4908], xmm0

; 142  : 			TheHud->waypointY = wpY;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR _wpY$[ebp]
	movss	DWORD PTR [ecx+4912], xmm0

; 143  : 			TheHud->waypointZ = wpZ;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR _wpZ$[ebp]
	movss	DWORD PTR [edx+4916], xmm0

; 144  : 			
; 145  : 			dx = wpX - platform->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1573[ebp]
	movss	xmm0, DWORD PTR _wpX$[ebp]
	subss	xmm0, DWORD PTR tv1573[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 146  : 			dy = wpY - platform->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1579[ebp]
	movss	xmm0, DWORD PTR _wpY$[ebp]
	subss	xmm0, DWORD PTR tv1579[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 147  : 			dz = OTWDriver.GetApproxGroundLevel(wpX, wpY) - platform->ZPos();

	push	ecx
	movss	xmm0, DWORD PTR _wpY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wpX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR tv1588[ebp]
	movss	xmm0, DWORD PTR tv1588[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv2244[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1593[ebp]
	movss	xmm0, DWORD PTR tv2244[ebp]
	subss	xmm0, DWORD PTR tv1593[ebp]
	movss	DWORD PTR _dz$[ebp], xmm0

; 148  : 			//MI add in INS Offset
; 149  : 			if(g_bINS && g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN52@NavMode
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN52@NavMode

; 150  : 			{
; 151  : 				if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN52@NavMode

; 152  : 					dz -= playerAC->GetINSAltOffset();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetINSAltOffset@AircraftClass@@QAEMXZ	; AircraftClass::GetINSAltOffset
	fstp	DWORD PTR tv1597[ebp]
	movss	xmm0, DWORD PTR _dz$[ebp]
	subss	xmm0, DWORD PTR tv1597[ebp]
	movss	DWORD PTR _dz$[ebp], xmm0
$LN52@NavMode:

; 153  : 			}
; 154  : 			
; 155  : 			// Range to current waypoint
; 156  : 			TheHud->waypointRange = (float)sqrt(dx*dx + dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [edx+4944]

; 157  : 			
; 158  : 			//MI
; 159  : 			if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN51@NavMode

; 160  : 				TheHud->SlantRange = (float)sqrt(dx*dx + dy*dy + dz*dz);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [ecx+5132]
$LN51@NavMode:

; 161  : 			
; 162  : 			// Heading error for current waypoint
; 163  : 			TheHud->waypointBearing = (float)atan2(dy, dx) - platform->Yaw();

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv1617[ebp]
	movsd	xmm0, QWORD PTR tv1617[ebp]
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv2246[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv1622[ebp]
	movss	xmm0, DWORD PTR tv2246[ebp]
	subss	xmm0, DWORD PTR tv1622[ebp]
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [eax+4940], xmm0

; 164  : 			
; 165  : 			if (TheHud->waypointBearing > 180.0F * DTR)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4940]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN50@NavMode

; 166  : 				TheHud->waypointBearing -= 360.0F * DTR;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4940]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [eax+4940], xmm0
	jmp	SHORT $LN48@NavMode
$LN50@NavMode:

; 167  : 			else if (TheHud->waypointBearing < -180.0F * DTR)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [ecx+4940]
	jbe	SHORT $LN48@NavMode

; 168  : 				TheHud->waypointBearing += 360.0F * DTR;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4940]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [eax+4940], xmm0
$LN48@NavMode:

; 169  : 			
; 170  : 			// Time to go
; 171  : 			
; 172  : 			// MD -- 20040219: add concept of pseudo waypoint tracking for GM SP ground stabilized
; 173  : 			if (playerAC && g_bRealisticAvionics)  // MLR 7/17/2004 - Added realistic check

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN47@NavMode
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN47@NavMode

; 174  : 			{
; 175  : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _playerAC$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$29[ebp], eax

; 176  : 				if (theRadar && theRadar->IsSet(RadarDopplerClass::SP) && theRadar->IsSet(RadarDopplerClass::SP_STAB) && theRadar->GMSPWaypt())

	cmp	DWORD PTR _theRadar$29[ebp], 0
	je	$LN46@NavMode
	push	64					; 00000040H
	mov	ecx, DWORD PTR _theRadar$29[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN46@NavMode
	push	128					; 00000080H
	mov	ecx, DWORD PTR _theRadar$29[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN46@NavMode
	mov	ecx, DWORD PTR _theRadar$29[ebp]
	call	?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ; RadarDopplerClass::GMSPWaypt
	test	eax, eax
	je	$LN46@NavMode

; 177  : 				{
; 178  : 					float x, y, z, dx, dy;
; 179  : 					theRadar->GMSPWaypt()->GetLocation(&x, &y, &z);

	lea	eax, DWORD PTR _z$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _theRadar$29[ebp]
	call	?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ; RadarDopplerClass::GMSPWaypt
	mov	ecx, eax
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 180  : 					dx = x - playerAC->XPos();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1646[ebp]
	movss	xmm0, DWORD PTR _x$2[ebp]
	subss	xmm0, DWORD PTR tv1646[ebp]
	movss	DWORD PTR _dx$9[ebp], xmm0

; 181  : 					dy = y - playerAC->YPos();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1651[ebp]
	movss	xmm0, DWORD PTR _y$4[ebp]
	subss	xmm0, DWORD PTR tv1651[ebp]
	movss	DWORD PTR _dy$8[ebp], xmm0

; 182  : 					ttg = ((float)sqrt(dx*dx + dy*dy)) / playerAC->GetVt();

	movss	xmm0, DWORD PTR _dx$9[ebp]
	mulss	xmm0, DWORD PTR _dx$9[ebp]
	movss	xmm1, DWORD PTR _dy$8[ebp]
	mulss	xmm1, DWORD PTR _dy$8[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv1660[ebp]
	movss	xmm0, DWORD PTR tv1660[ebp]
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+220]
	movss	DWORD PTR tv2248[ebp], xmm0
	call	eax
	fstp	DWORD PTR tv1666[ebp]
	movss	xmm0, DWORD PTR tv2248[ebp]
	divss	xmm0, DWORD PTR tv1666[ebp]
	movss	DWORD PTR _ttg$[ebp], xmm0

; 183  : 				}
; 184  : 				else

	jmp	SHORT $LN45@NavMode
$LN46@NavMode:

; 185  : 					ttg = ((float)curWaypoint->GetWPArrivalTime() -	SimLibElapsedTime) / SEC_TO_MSEC;

	mov	ecx, DWORD PTR _curWaypoint$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR tv1669[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1669[ebp]
	mov	ecx, DWORD PTR tv1669[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1672[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1672[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv1677[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv1677[ebp]
	mov	eax, DWORD PTR tv1677[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1681[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv1681[ebp]
	subss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _ttg$[ebp], xmm0
$LN45@NavMode:

; 186  : 			}
; 187  : 			else

	jmp	SHORT $LN44@NavMode
$LN47@NavMode:

; 188  : 				ttg = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ttg$[ebp], xmm0
$LN44@NavMode:

; 189  : 			
; 190  : 			switch (subMode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR tv361[ebp], edx
	mov	eax, DWORD PTR tv361[ebp]
	sub	eax, 5
	mov	DWORD PTR tv361[ebp], eax
	cmp	DWORD PTR tv361[ebp], 15		; 0000000fH
	ja	$LN32@NavMode
	mov	ecx, DWORD PTR tv361[ebp]
	movzx	edx, BYTE PTR $LN101@NavMode[ecx]
	jmp	DWORD PTR $LN102@NavMode[edx*4]
$LN41@NavMode:

; 191  : 			{
; 192  :             case TimeToGo:
; 193  : 				if (ttg > 0.0F)

	movss	xmm0, DWORD PTR _ttg$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN40@NavMode

; 194  : 					TheHud->waypointArrival = ttg;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR _ttg$[ebp]
	movss	DWORD PTR [eax+4936], xmm0

; 195  : 				else

	jmp	SHORT $LN39@NavMode
$LN40@NavMode:

; 196  : 					TheHud->waypointArrival = 0.0F;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4936], xmm0
$LN39@NavMode:

; 197  : 				break;

	jmp	$LN42@NavMode
$LN38@NavMode:

; 198  : 				
; 199  : 				//MI so CCIP and DTOS displays ETE
; 200  : 			case CCIP:
; 201  : 			case DTOSS:
; 202  : 			case ETE:
; 203  : 			case STRAF:
; 204  : 			case Aim120:
; 205  : 			case Aim9:
; 206  : 				//case Gun: // MLR 2/8/2004 - this is not a valid submode!
; 207  : 				// ETE - delta Time to reach waypoint at current speed
; 208  : 				if (platform->GetVt() > 2.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv1702[ebp]
	movss	xmm0, DWORD PTR tv1702[ebp]
	comiss	xmm0, DWORD PTR __real@40000000
	jbe	SHORT $LN37@NavMode

; 209  : 					TheHud->waypointArrival = TheHud->waypointRange / platform->GetVt();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv1709[ebp]
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4944]
	divss	xmm0, DWORD PTR tv1709[ebp]
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [edx+4936], xmm0

; 210  : 				else

	jmp	SHORT $LN36@NavMode
$LN37@NavMode:

; 211  : 					TheHud->waypointArrival = -1.0F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+4936], xmm0
$LN36@NavMode:

; 212  : 				break;

	jmp	$LN42@NavMode
$LN35@NavMode:

; 213  : 				
; 214  :             case ETA:
; 215  : 				if (platform->GetVt() > 2.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv1721[ebp]
	movss	xmm0, DWORD PTR tv1721[ebp]
	comiss	xmm0, DWORD PTR __real@40000000
	jbe	$LN34@NavMode

; 216  : 					TheHud->waypointArrival = SimLibElapsedTime / SEC_TO_MSEC + TheHud->waypointRange / platform->GetVt();

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR tv1727[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1727[ebp]
	mov	edx, DWORD PTR tv1727[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1730[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1730[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+140]
	mov	edx, DWORD PTR [eax+220]
	movss	DWORD PTR tv2250[ebp], xmm0
	call	edx
	fstp	DWORD PTR tv1740[ebp]
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4944]
	divss	xmm0, DWORD PTR tv1740[ebp]
	movss	xmm1, DWORD PTR tv2250[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+4936], xmm1

; 217  : 				else

	jmp	SHORT $LN33@NavMode
$LN34@NavMode:

; 218  : 					TheHud->waypointArrival = -1.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+4936], xmm0
$LN33@NavMode:

; 219  : 				break;

	jmp	SHORT $LN42@NavMode
$LN32@NavMode:

; 220  : 			default:
; 221  : 				if (ttg > 0.0F)

	movss	xmm0, DWORD PTR _ttg$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN31@NavMode

; 222  : 					TheHud->waypointArrival = ttg;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR _ttg$[ebp]
	movss	DWORD PTR [eax+4936], xmm0

; 223  : 				else

	jmp	SHORT $LN30@NavMode
$LN31@NavMode:

; 224  : 					TheHud->waypointArrival = 0.0F;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4936], xmm0
$LN30@NavMode:
$LN42@NavMode:

; 225  : 				break;
; 226  : 				
; 227  : 			}
; 228  : 			
; 229  : 			
; 230  : 			if (g_bRQDFix)

	movzx	edx, BYTE PTR ?g_bRQDFix@@3_NA		; g_bRQDFix
	test	edx, edx
	je	$LN29@NavMode

; 231  : 			{		
; 232  : 				
; 233  : 				// Desired Speed
; 234  : 				if (ttg > 0.0f)

	movss	xmm0, DWORD PTR _ttg$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN28@NavMode

; 235  : 				{
; 236  : 					TheHud->waypointSpeed = TheHud->waypointRange / ttg;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4944]
	divss	xmm0, DWORD PTR _ttg$[ebp]
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+4928], xmm0

; 237  : 				}
; 238  : 				else

	jmp	SHORT $LN27@NavMode
$LN28@NavMode:

; 239  : 				{
; 240  : 					TheHud->waypointSpeed = 1700.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@44d48000
	movss	DWORD PTR [edx+4928], xmm0
$LN27@NavMode:

; 241  : 				}
; 242  : 				//dpc RQD G/S fix - store waypointSpeed as GND relative value before conversion to CAS
; 243  : 				TheHud->waypointGNDSpeed = TheHud->waypointSpeed * FTPSEC_TO_KNOTS;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4928]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+4932], xmm0

; 244  : 				TheHud->waypointSpeed = CalcKIAS(TheHud->waypointSpeed, -platform->ZPos());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1764[ebp]
	movss	xmm0, DWORD PTR tv1764[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	push	ecx
	movss	xmm0, DWORD PTR [eax+4928]
	movss	DWORD PTR [esp], xmm0
	call	?CalcKIAS@@YAMMM@Z			; CalcKIAS
	add	esp, 8
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [ecx+4928]

; 245  : 				
; 246  : 				// Clamp as per -34
; 247  : 				TheHud->waypointSpeed = min ( max (TheHud->waypointSpeed, 80.0F), 1700.0F);

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4928]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN83@NavMode
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4928]
	movss	DWORD PTR tv460[ebp], xmm0
	jmp	SHORT $LN84@NavMode
$LN83@NavMode:
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv460[ebp], xmm0
$LN84@NavMode:
	movss	xmm0, DWORD PTR __real@44d48000
	comiss	xmm0, DWORD PTR tv460[ebp]
	jbe	SHORT $LN87@NavMode
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4928]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN85@NavMode
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4928]
	movss	DWORD PTR tv467[ebp], xmm0
	jmp	SHORT $LN86@NavMode
$LN85@NavMode:
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv467[ebp], xmm0
$LN86@NavMode:
	movss	xmm0, DWORD PTR tv467[ebp]
	movss	DWORD PTR tv468[ebp], xmm0
	jmp	SHORT $LN88@NavMode
$LN87@NavMode:
	movss	xmm0, DWORD PTR __real@44d48000
	movss	DWORD PTR tv468[ebp], xmm0
$LN88@NavMode:
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv468[ebp]
	movss	DWORD PTR [eax+4928], xmm0

; 248  : 				//dpc RQD G/S fix - clamp waypointGNDSpeed also
; 249  : 				TheHud->waypointGNDSpeed = min ( max (TheHud->waypointGNDSpeed, 80.0F), 1700.0F);

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4932]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN89@NavMode
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4932]
	movss	DWORD PTR tv475[ebp], xmm0
	jmp	SHORT $LN90@NavMode
$LN89@NavMode:
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv475[ebp], xmm0
$LN90@NavMode:
	movss	xmm0, DWORD PTR __real@44d48000
	comiss	xmm0, DWORD PTR tv475[ebp]
	jbe	SHORT $LN93@NavMode
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4932]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN91@NavMode
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4932]
	movss	DWORD PTR tv482[ebp], xmm0
	jmp	SHORT $LN92@NavMode
$LN91@NavMode:
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv482[ebp], xmm0
$LN92@NavMode:
	movss	xmm0, DWORD PTR tv482[ebp]
	movss	DWORD PTR tv483[ebp], xmm0
	jmp	SHORT $LN94@NavMode
$LN93@NavMode:
	movss	xmm0, DWORD PTR __real@44d48000
	movss	DWORD PTR tv483[ebp], xmm0
$LN94@NavMode:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv483[ebp]
	movss	DWORD PTR [edx+4932], xmm0

; 250  : 				
; 251  : 			}		
; 252  : 			else

	jmp	$LN26@NavMode
$LN29@NavMode:

; 253  : 			{
; 254  : 				// Desired Speed
; 255  : 				if (ttg > 0.0f)

	movss	xmm0, DWORD PTR _ttg$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN25@NavMode

; 256  : 				{
; 257  : 					TheHud->waypointSpeed = TheHud->waypointRange / ttg;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4944]
	divss	xmm0, DWORD PTR _ttg$[ebp]
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+4928], xmm0

; 258  : 				}
; 259  : 				else

	jmp	SHORT $LN24@NavMode
$LN25@NavMode:

; 260  : 				{
; 261  : 					TheHud->waypointSpeed = 1700.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@44d48000
	movss	DWORD PTR [edx+4928], xmm0
$LN24@NavMode:

; 262  : 				}
; 263  : 				
; 264  : 				TheHud->waypointSpeed = CalcKIAS(TheHud->waypointSpeed, -platform->ZPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1804[ebp]
	movss	xmm0, DWORD PTR tv1804[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4928]
	movss	DWORD PTR [esp], xmm0
	call	?CalcKIAS@@YAMMM@Z			; CalcKIAS
	add	esp, 8
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [edx+4928]

; 265  : 				
; 266  : 				// Clamp as per -34
; 267  : 				TheHud->waypointSpeed = min ( max (TheHud->waypointSpeed, 80.0F), 1700.0F);

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4928]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN95@NavMode
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4928]
	movss	DWORD PTR tv508[ebp], xmm0
	jmp	SHORT $LN96@NavMode
$LN95@NavMode:
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv508[ebp], xmm0
$LN96@NavMode:
	movss	xmm0, DWORD PTR __real@44d48000
	comiss	xmm0, DWORD PTR tv508[ebp]
	jbe	SHORT $LN99@NavMode
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4928]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN97@NavMode
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4928]
	movss	DWORD PTR tv515[ebp], xmm0
	jmp	SHORT $LN98@NavMode
$LN97@NavMode:
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv515[ebp], xmm0
$LN98@NavMode:
	movss	xmm0, DWORD PTR tv515[ebp]
	movss	DWORD PTR tv516[ebp], xmm0
	jmp	SHORT $LN100@NavMode
$LN99@NavMode:
	movss	xmm0, DWORD PTR __real@44d48000
	movss	DWORD PTR tv516[ebp], xmm0
$LN100@NavMode:
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv516[ebp]
	movss	DWORD PTR [ecx+4928], xmm0
$LN26@NavMode:

; 268  : 			}
; 269  : 			
; 270  : 			rx = platform->dmx[0][0]*dx + platform->dmx[0][1]*dy + platform->dmx[0][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 271  : 			ry = platform->dmx[1][0]*dx + platform->dmx[1][1]*dy + platform->dmx[1][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 272  : 			rz = platform->dmx[2][0]*dx + platform->dmx[2][1]*dy + platform->dmx[2][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rz$[ebp], xmm0

; 273  : 			
; 274  : 			TheHud->waypointAz  = (float)atan2 (ry,rx);

	cvtss2sd xmm0, DWORD PTR _rx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [edx+4920]

; 275  : 			TheHud->waypointEl  = (float)atan (-rz/(float)sqrt(rx*rx+ry*ry+.1f));

	movss	xmm0, DWORD PTR _rz$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _rx$[ebp]
	mulss	xmm1, DWORD PTR _rx$[ebp]
	movss	xmm2, DWORD PTR _ry$[ebp]
	mulss	xmm2, DWORD PTR _ry$[ebp]
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2252[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv1872[ebp]
	movss	xmm0, DWORD PTR tv2252[ebp]
	divss	xmm0, DWORD PTR tv1872[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [eax+4924]

; 276  : 			
; 277  : 			
; 278  : 			TheHud->waypointValid = TRUE;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [ecx+4952], 1

; 279  : 	}
; 280  : 	else

	jmp	SHORT $LN23@NavMode
$LN56@NavMode:

; 281  : 	{
; 282  : 		TheHud->waypointValid = FALSE;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [edx+4952], 0
$LN23@NavMode:

; 283  : 	}
; 284  : 	//MI send our OA's to the HUD
; 285  : 	if(g_bRealisticAvionics && platform->curWaypoint && platform->curWaypoint->GetWPFlags() & WPF_TARGET)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN22@NavMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	cmp	DWORD PTR [edx+728], 0
	je	$LN22@NavMode
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	$LN22@NavMode

; 286  : 	{
; 287  : 		WayPointClass* curOA = NULL;

	mov	DWORD PTR _curOA$36[ebp], 0

; 288  : 		WayPointClass* curVIP = NULL;

	mov	DWORD PTR _curVIP$28[ebp], 0

; 289  : 		WayPointClass* curVRP = NULL;

	mov	DWORD PTR _curVRP$27[ebp], 0

; 290  : 		int				i;
; 291  : 		float			OAXPos;
; 292  : 		float			OAYPos;
; 293  : 		float			OAZPos;
; 294  : 		
; 295  : 		ShiAssert(platform->curWaypoint != NULL || !F4IsBadReadPtr(platform->curWaypoint, sizeof (WayPointClass)));
; 296  : 		
; 297  : 		for(i = 0; i < MAX_DESTOA; i++) 

	mov	DWORD PTR _i$34[ebp], 0
	jmp	SHORT $LN21@NavMode
$LN20@NavMode:
	mov	edx, DWORD PTR _i$34[ebp]
	add	edx, 1
	mov	DWORD PTR _i$34[ebp], edx
$LN21@NavMode:
	cmp	DWORD PTR _i$34[ebp], 3
	jge	$LN19@NavMode

; 298  : 		{
; 299  : 			switch (i)

	mov	eax, DWORD PTR _i$34[ebp]
	mov	DWORD PTR tv655[ebp], eax
	cmp	DWORD PTR tv655[ebp], 1
	je	SHORT $LN16@NavMode
	cmp	DWORD PTR tv655[ebp], 2
	je	$LN12@NavMode
	jmp	$LN8@NavMode
$LN16@NavMode:

; 300  : 			{
; 301  : 			case 1:
; 302  : 				gNavigationSys->GetDESTOAPoint(i, &curOA);

	lea	ecx, DWORD PTR _curOA$36[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$34[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDESTOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetDESTOAPoint

; 303  : 				if(curOA) 

	cmp	DWORD PTR _curOA$36[ebp], 0
	je	$LN13@NavMode

; 304  : 				{
; 305  : 					//Limit it to the TargetWP for the moment
; 306  : 					if(!F4IsBadReadPtr(curOA,sizeof(WayPointClass)))

	push	60					; 0000003cH
	mov	eax, DWORD PTR _curOA$36[ebp]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN14@NavMode

; 307  : 					{
; 308  : 						curOA->GetLocation(&OAXPos,&OAYPos,&OAZPos);

	lea	edx, DWORD PTR _OAZPos$35[ebp]
	push	edx
	lea	eax, DWORD PTR _OAYPos$37[ebp]
	push	eax
	lea	ecx, DWORD PTR _OAXPos$38[ebp]
	push	ecx
	mov	ecx, DWORD PTR _curOA$36[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 309  : 						float dx, dy, dz;
; 310  : 						dx = OAXPos - platform->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1895[ebp]
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	subss	xmm0, DWORD PTR tv1895[ebp]
	movss	DWORD PTR _dx$16[ebp], xmm0

; 311  : 						dy = OAYPos - platform->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1901[ebp]
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	subss	xmm0, DWORD PTR tv1901[ebp]
	movss	DWORD PTR _dy$22[ebp], xmm0

; 312  : 						dz = OTWDriver.GetApproxGroundLevel(OAXPos, OAYPos) - platform->ZPos();

	push	ecx
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR tv1910[ebp]
	movss	xmm0, DWORD PTR tv1910[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	movss	DWORD PTR tv2254[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1915[ebp]
	movss	xmm0, DWORD PTR tv2254[ebp]
	subss	xmm0, DWORD PTR tv1915[ebp]
	movss	DWORD PTR _dz$30[ebp], xmm0

; 313  : 						dz -= OAZPos;

	movss	xmm0, DWORD PTR _dz$30[ebp]
	subss	xmm0, DWORD PTR _OAZPos$35[ebp]
	movss	DWORD PTR _dz$30[ebp], xmm0

; 314  : 						
; 315  : 						float rx = platform->dmx[0][0]*dx + platform->dmx[0][1]*dy + platform->dmx[0][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$16[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$22[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$30[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$12[ebp], xmm0

; 316  : 						float ry = platform->dmx[1][0]*dx + platform->dmx[1][1]*dy + platform->dmx[1][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$16[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$22[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$30[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$20[ebp], xmm0

; 317  : 						float rz = platform->dmx[2][0]*dx + platform->dmx[2][1]*dy + platform->dmx[2][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$16[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$22[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$30[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rz$7[ebp], xmm0

; 318  : 						
; 319  : 						TheHud->OA1Az  = (float)atan2 (ry,rx);

	cvtss2sd xmm0, DWORD PTR _rx$12[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$20[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [edx+5024]

; 320  : 						TheHud->OA1Elev  = (float)atan (-rz/(float)sqrt(rx*rx+ry*ry+.1f));

	movss	xmm0, DWORD PTR _rz$7[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _rx$12[ebp]
	mulss	xmm1, DWORD PTR _rx$12[ebp]
	movss	xmm2, DWORD PTR _ry$20[ebp]
	mulss	xmm2, DWORD PTR _ry$20[ebp]
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2256[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv1966[ebp]
	movss	xmm0, DWORD PTR tv2256[ebp]
	divss	xmm0, DWORD PTR tv1966[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [eax+5028]

; 321  : 						TheHud->OA1Valid = TRUE;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [ecx+5040], 1

; 322  : 					}
; 323  : 					else

	jmp	SHORT $LN13@NavMode
$LN14@NavMode:

; 324  : 						TheHud->OA1Valid = FALSE;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [edx+5040], 0
$LN13@NavMode:

; 325  : 				}
; 326  : 				break;

	jmp	$LN17@NavMode
$LN12@NavMode:

; 327  : 			case 2:
; 328  : 				gNavigationSys->GetDESTOAPoint(i, &curOA);

	lea	eax, DWORD PTR _curOA$36[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$34[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDESTOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetDESTOAPoint

; 329  : 				if(curOA) 

	cmp	DWORD PTR _curOA$36[ebp], 0
	je	$LN9@NavMode

; 330  : 				{
; 331  : 					//Limit it to the TargetWP for the moment
; 332  : 					if(!F4IsBadReadPtr(curOA,sizeof(WayPointClass)))

	push	60					; 0000003cH
	mov	edx, DWORD PTR _curOA$36[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	$LN10@NavMode

; 333  : 					{
; 334  : 						curOA->GetLocation(&OAXPos,&OAYPos,&OAZPos);

	lea	ecx, DWORD PTR _OAZPos$35[ebp]
	push	ecx
	lea	edx, DWORD PTR _OAYPos$37[ebp]
	push	edx
	lea	eax, DWORD PTR _OAXPos$38[ebp]
	push	eax
	mov	ecx, DWORD PTR _curOA$36[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 335  : 						float dx, dy, dz;
; 336  : 						dx = OAXPos - platform->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1984[ebp]
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	subss	xmm0, DWORD PTR tv1984[ebp]
	movss	DWORD PTR _dx$14[ebp], xmm0

; 337  : 						dy = OAYPos - platform->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1990[ebp]
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	subss	xmm0, DWORD PTR tv1990[ebp]
	movss	DWORD PTR _dy$26[ebp], xmm0

; 338  : 						dz = OTWDriver.GetApproxGroundLevel(OAXPos, OAYPos) - platform->ZPos();

	push	ecx
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR tv1999[ebp]
	movss	xmm0, DWORD PTR tv1999[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv2258[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv2004[ebp]
	movss	xmm0, DWORD PTR tv2258[ebp]
	subss	xmm0, DWORD PTR tv2004[ebp]
	movss	DWORD PTR _dz$33[ebp], xmm0

; 339  : 						dz -= OAZPos;

	movss	xmm0, DWORD PTR _dz$33[ebp]
	subss	xmm0, DWORD PTR _OAZPos$35[ebp]
	movss	DWORD PTR _dz$33[ebp], xmm0

; 340  : 						
; 341  : 						float rx = platform->dmx[0][0]*dx + platform->dmx[0][1]*dy + platform->dmx[0][2]*dz;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _dx$14[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dy$26[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _dz$33[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$25[ebp], xmm0

; 342  : 						float ry = platform->dmx[1][0]*dx + platform->dmx[1][1]*dy + platform->dmx[1][2]*dz;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _dx$14[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dy$26[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _dz$33[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$24[ebp], xmm0

; 343  : 						float rz = platform->dmx[2][0]*dx + platform->dmx[2][1]*dy + platform->dmx[2][2]*dz;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _dx$14[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dy$26[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _dz$33[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rz$6[ebp], xmm0

; 344  : 						
; 345  : 						TheHud->OA2Az  = (float)atan2 (ry,rx);

	cvtss2sd xmm0, DWORD PTR _rx$25[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$24[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [ecx+5032]

; 346  : 						TheHud->OA2Elev  = (float)atan (-rz/(float)sqrt(rx*rx+ry*ry+.1f));

	movss	xmm0, DWORD PTR _rz$6[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _rx$25[ebp]
	mulss	xmm1, DWORD PTR _rx$25[ebp]
	movss	xmm2, DWORD PTR _ry$24[ebp]
	mulss	xmm2, DWORD PTR _ry$24[ebp]
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2260[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv2055[ebp]
	movss	xmm0, DWORD PTR tv2260[ebp]
	divss	xmm0, DWORD PTR tv2055[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [edx+5036]

; 347  : 						TheHud->OA2Valid = TRUE;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [eax+5041], 1

; 348  : 					}
; 349  : 					else

	jmp	SHORT $LN9@NavMode
$LN10@NavMode:

; 350  : 						TheHud->OA2Valid = FALSE;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [ecx+5041], 0
$LN9@NavMode:
$LN8@NavMode:
$LN17@NavMode:

; 351  : 				}
; 352  : 				break;
; 353  : 			default:
; 354  : 				break;
; 355  : 			}
; 356  : 		}

	jmp	$LN20@NavMode
$LN19@NavMode:

; 357  : 		gNavigationSys->GetVIPOAPoint(0, &curVIP);

	lea	edx, DWORD PTR _curVIP$28[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetVIPOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetVIPOAPoint

; 358  : 		if(curVIP)

	cmp	DWORD PTR _curVIP$28[ebp], 0
	je	$LN5@NavMode

; 359  : 		{
; 360  : 			if(!F4IsBadReadPtr(curVIP,sizeof(WayPointClass)))

	push	60					; 0000003cH
	mov	eax, DWORD PTR _curVIP$28[ebp]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@NavMode

; 361  : 			{
; 362  : 				//valid, draw VIP
; 363  : 				curVIP->GetLocation(&OAXPos,&OAYPos,&OAZPos);

	lea	edx, DWORD PTR _OAZPos$35[ebp]
	push	edx
	lea	eax, DWORD PTR _OAYPos$37[ebp]
	push	eax
	lea	ecx, DWORD PTR _OAXPos$38[ebp]
	push	ecx
	mov	ecx, DWORD PTR _curVIP$28[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 364  : 				float dx, dy, dz;
; 365  : 				dx = OAXPos - platform->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv2072[ebp]
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	subss	xmm0, DWORD PTR tv2072[ebp]
	movss	DWORD PTR _dx$23[ebp], xmm0

; 366  : 				dy = OAYPos - platform->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv2078[ebp]
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	subss	xmm0, DWORD PTR tv2078[ebp]
	movss	DWORD PTR _dy$21[ebp], xmm0

; 367  : 				dz = OTWDriver.GetApproxGroundLevel(OAXPos, OAYPos) - platform->ZPos();

	push	ecx
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR tv2087[ebp]
	movss	xmm0, DWORD PTR tv2087[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	movss	DWORD PTR tv2262[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv2092[ebp]
	movss	xmm0, DWORD PTR tv2262[ebp]
	subss	xmm0, DWORD PTR tv2092[ebp]
	movss	DWORD PTR _dz$32[ebp], xmm0

; 368  : 				dz -= OAZPos;

	movss	xmm0, DWORD PTR _dz$32[ebp]
	subss	xmm0, DWORD PTR _OAZPos$35[ebp]
	movss	DWORD PTR _dz$32[ebp], xmm0

; 369  : 				
; 370  : 				float rx = platform->dmx[0][0]*dx + platform->dmx[0][1]*dy + platform->dmx[0][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$23[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$21[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$32[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$19[ebp], xmm0

; 371  : 				float ry = platform->dmx[1][0]*dx + platform->dmx[1][1]*dy + platform->dmx[1][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$23[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$21[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$32[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$17[ebp], xmm0

; 372  : 				float rz = platform->dmx[2][0]*dx + platform->dmx[2][1]*dy + platform->dmx[2][2]*dz;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _dx$23[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dy$21[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dz$32[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rz$5[ebp], xmm0

; 373  : 				
; 374  : 				TheHud->VIPAz  = (float)atan2 (ry,rx);

	cvtss2sd xmm0, DWORD PTR _rx$19[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$17[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [edx+5044]

; 375  : 				TheHud->VIPElev  = (float)atan (-rz/(float)sqrt(rx*rx+ry*ry+.1f));

	movss	xmm0, DWORD PTR _rz$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _rx$19[ebp]
	mulss	xmm1, DWORD PTR _rx$19[ebp]
	movss	xmm2, DWORD PTR _ry$17[ebp]
	mulss	xmm2, DWORD PTR _ry$17[ebp]
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2264[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv2143[ebp]
	movss	xmm0, DWORD PTR tv2264[ebp]
	divss	xmm0, DWORD PTR tv2143[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [eax+5048]

; 376  : 				TheHud->VIPValid = TRUE;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [ecx+5052], 1

; 377  : 			}
; 378  : 			else

	jmp	SHORT $LN5@NavMode
$LN6@NavMode:

; 379  : 				TheHud->VIPValid = FALSE;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [edx+5052], 0
$LN5@NavMode:

; 380  : 		}
; 381  : 		gNavigationSys->GetVRPOAPoint(0, &curVRP);

	lea	eax, DWORD PTR _curVRP$27[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetVRPOAPoint@NavigationSystem@@QAEXHPAPAVWayPointClass@@@Z ; NavigationSystem::GetVRPOAPoint

; 382  : 		if(curVRP)

	cmp	DWORD PTR _curVRP$27[ebp], 0
	je	$LN2@NavMode

; 383  : 		{
; 384  : 			if(!F4IsBadReadPtr(curVRP,sizeof(WayPointClass)))

	push	60					; 0000003cH
	mov	ecx, DWORD PTR _curVRP$27[ebp]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	$LN3@NavMode

; 385  : 			{
; 386  : 				//valid, draw VRP
; 387  : 				curVRP->GetLocation(&OAXPos,&OAYPos,&OAZPos);

	lea	eax, DWORD PTR _OAZPos$35[ebp]
	push	eax
	lea	ecx, DWORD PTR _OAYPos$37[ebp]
	push	ecx
	lea	edx, DWORD PTR _OAXPos$38[ebp]
	push	edx
	mov	ecx, DWORD PTR _curVRP$27[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 388  : 				float dx, dy, dz;
; 389  : 				dx = OAXPos - platform->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv2160[ebp]
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	subss	xmm0, DWORD PTR tv2160[ebp]
	movss	DWORD PTR _dx$15[ebp], xmm0

; 390  : 				dy = OAYPos - platform->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv2166[ebp]
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	subss	xmm0, DWORD PTR tv2166[ebp]
	movss	DWORD PTR _dy$13[ebp], xmm0

; 391  : 				dz = OTWDriver.GetApproxGroundLevel(OAXPos, OAYPos) - platform->ZPos();

	push	ecx
	movss	xmm0, DWORD PTR _OAYPos$37[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _OAXPos$38[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR tv2175[ebp]
	movss	xmm0, DWORD PTR tv2175[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv2266[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv2180[ebp]
	movss	xmm0, DWORD PTR tv2266[ebp]
	subss	xmm0, DWORD PTR tv2180[ebp]
	movss	DWORD PTR _dz$31[ebp], xmm0

; 392  : 				dz -= OAZPos;

	movss	xmm0, DWORD PTR _dz$31[ebp]
	subss	xmm0, DWORD PTR _OAZPos$35[ebp]
	movss	DWORD PTR _dz$31[ebp], xmm0

; 393  : 				
; 394  : 				float rx = platform->dmx[0][0]*dx + platform->dmx[0][1]*dy + platform->dmx[0][2]*dz;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _dx$15[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _dy$13[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dz$31[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$11[ebp], xmm0

; 395  : 				float ry = platform->dmx[1][0]*dx + platform->dmx[1][1]*dy + platform->dmx[1][2]*dz;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _dx$15[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _dy$13[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dz$31[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$10[ebp], xmm0

; 396  : 				float rz = platform->dmx[2][0]*dx + platform->dmx[2][1]*dy + platform->dmx[2][2]*dz;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _dx$15[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _dy$13[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _dz$31[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rz$3[ebp], xmm0

; 397  : 				
; 398  : 				TheHud->VRPAz  = (float)atan2 (ry,rx);

	cvtss2sd xmm0, DWORD PTR _rx$11[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$10[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [eax+5056]

; 399  : 				TheHud->VRPElev  = (float)atan (-rz/(float)sqrt(rx*rx+ry*ry+.1f));

	movss	xmm0, DWORD PTR _rz$3[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _rx$11[ebp]
	mulss	xmm1, DWORD PTR _rx$11[ebp]
	movss	xmm2, DWORD PTR _ry$10[ebp]
	mulss	xmm2, DWORD PTR _ry$10[ebp]
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2268[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv2231[ebp]
	movss	xmm0, DWORD PTR tv2268[ebp]
	divss	xmm0, DWORD PTR tv2231[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	fstp	DWORD PTR [ecx+5060]

; 400  : 				TheHud->VRPValid = TRUE;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [edx+5064], 1

; 401  : 			}
; 402  : 			else

	jmp	SHORT $LN2@NavMode
$LN3@NavMode:

; 403  : 				TheHud->VRPValid = FALSE;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [eax+5064], 0
$LN2@NavMode:

; 404  : 		}
; 405  : 	}
; 406  : 	else

	jmp	SHORT $LN1@NavMode
$LN22@NavMode:

; 407  : 	{
; 408  : 		TheHud->VIPValid = FALSE;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [ecx+5052], 0

; 409  : 		TheHud->VRPValid = FALSE;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [edx+5064], 0

; 410  : 		TheHud->OA1Valid = FALSE;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [eax+5040], 0

; 411  : 		TheHud->OA2Valid = FALSE;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	BYTE PTR [ecx+5041], 0
$LN1@NavMode:

; 412  : 	}
; 413  : 	
; 414  : 	InitNewStptMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitNewStptMode@FireControlComputer@@AAEXXZ ; FireControlComputer::InitNewStptMode

; 415  : 	StepPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepPoint@FireControlComputer@@AAEXXZ	; FireControlComputer::StepPoint
$LN57@NavMode:

; 416  :     }
; 417  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN102@NavMode:
	DD	$LN38@NavMode
	DD	$LN41@NavMode
	DD	$LN35@NavMode
	DD	$LN32@NavMode
$LN101@NavMode:
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	0
	DB	3
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	0
	DB	2
?NavMode@FireControlComputer@@AAEXXZ ENDP		; FireControlComputer::NavMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?ClearFlag@GroundListElement@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearFlag@GroundListElement@@QAEXH@Z PROC		; GroundListElement::ClearFlag, COMDAT
; _this$ = ecx

; 46   :     void ClearFlag (int flag) { flags &= ~flag; } ;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@GroundListElement@@QAEXH@Z ENDP		; GroundListElement::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsSet@GroundListElement@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSet@GroundListElement@@QAEHH@Z PROC			; GroundListElement::IsSet, COMDAT
; _this$ = ecx

; 45   :     int IsSet (int flag) { return (flags & flag) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@GroundListElement@@QAEHH@Z ENDP			; GroundListElement::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetFlag@GroundListElement@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFlag@GroundListElement@@QAEXH@Z PROC		; GroundListElement::SetFlag, COMDAT
; _this$ = ecx

; 44   :     void SetFlag(int flag) { flags |= flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@GroundListElement@@QAEXH@Z ENDP		; GroundListElement::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetNext@GroundListElement@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNext@GroundListElement@@QAEPAV1@XZ PROC		; GroundListElement::GetNext, COMDAT
; _this$ = ecx

; 30   :     GroundListElement *GetNext () { return next; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNext@GroundListElement@@QAEPAV1@XZ ENDP		; GroundListElement::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ PROC ; GroundListElement::BaseObject, COMDAT
; _this$ = ecx

; 29   :     FalconEntity*	BaseObject(void) {return baseObject;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ENDP ; GroundListElement::BaseObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?SetICPUpdateFlag@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetICPUpdateFlag@ICPClass@@QAEXH@Z PROC		; ICPClass::SetICPUpdateFlag, COMDAT
; _this$ = ecx

; 573  :    void SetICPUpdateFlag (int newFlag) {mUpdateFlags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetICPUpdateFlag@ICPClass@@QAEXH@Z ENDP		; ICPClass::SetICPUpdateFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?SetICPWPIndex@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newWp$ = 8						; size = 4
?SetICPWPIndex@ICPClass@@QAEXH@Z PROC			; ICPClass::SetICPWPIndex, COMDAT
; _this$ = ecx

; 572  :    void SetICPWPIndex (int newWp) {mWPIndex = newWp;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newWp$[ebp]
	mov	DWORD PTR [eax+256], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetICPWPIndex@ICPClass@@QAEXH@Z ENDP			; ICPClass::SetICPWPIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SeekerAz@SensorClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SeekerAz@SensorClass@@QAEMXZ PROC			; SensorClass::SeekerAz, COMDAT
; _this$ = ecx

; 56   : 	float			SeekerAz(void)                          { return seekerAzCenter; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?SeekerAz@SensorClass@@QAEMXZ ENDP			; SensorClass::SeekerAz
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ PROC ; SensorClass::CurrentTarget, COMDAT
; _this$ = ecx

; 46   : 	SimObjectType* CurrentTarget(void)	{ return lockedTarget; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ENDP ; SensorClass::CurrentTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?GetTGPWarning@MFDClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTGPWarning@MFDClass@@QAEHXZ PROC			; MFDClass::GetTGPWarning, COMDAT
; _this$ = ecx

; 94   : 	int GetTGPWarning() { return TGPWarning; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTGPWarning@MFDClass@@QAEHXZ ENDP			; MFDClass::GetTGPWarning
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ PROC		; MFDClass::CurMode, COMDAT
; _this$ = ecx

; 71   : 	MfdMode CurMode() { return mode == MfdMenu ? restoreMode : mode; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN3@CurMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN4@CurMode
$LN3@CurMode:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv68[ebp], ecx
$LN4@CurMode:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ ENDP		; MFDClass::CurMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ PROC ; ListClass::GetFirstElement, COMDAT
; _this$ = ecx

; 82   : 		ListElementClass* GetFirstElement(void)		{ return front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ENDP ; ListClass::GetFirstElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetNext@ListElementClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNext@ListElementClass@@QAEPAV1@XZ PROC		; ListElementClass::GetNext, COMDAT
; _this$ = ecx

; 45   : 		ListElementClass* GetNext(void)				{ return next; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNext@ListElementClass@@QAEPAV1@XZ ENDP		; ListElementClass::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetUserData@ListElementClass@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUserData@ListElementClass@@QAEPAXXZ PROC		; ListElementClass::GetUserData, COMDAT
; _this$ = ecx

; 39   : 		void* GetUserData(void)						{ return user_data; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUserData@ListElementClass@@QAEPAXXZ ENDP		; ListElementClass::GetUserData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetINSAltOffset@AircraftClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetINSAltOffset@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetINSAltOffset, COMDAT
; _this$ = ecx

; 223  : 	float GetINSAltOffset(void)	{return INSAltOffset;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+812]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetINSAltOffset@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetINSAltOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetINSLongDrift@AircraftClass@@QAEMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?GetINSLongDrift@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetINSLongDrift, COMDAT
; _this$ = ecx

; 222  : 	float GetINSLongDrift(void)	{return (INSLongDrift + INSLongOffset);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+792]
	addss	xmm0, DWORD PTR [ecx+808]
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetINSLongDrift@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetINSLongDrift
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetINSLatDrift@AircraftClass@@QAEMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?GetINSLatDrift@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetINSLatDrift, COMDAT
; _this$ = ecx

; 221  : 	float GetINSLatDrift(void)	{return (INSLatDrift + INSLatOffset);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+788]
	addss	xmm0, DWORD PTR [ecx+804]
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetINSLatDrift@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetINSLatDrift
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPArrivalTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPArrivalTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPArrivalTime, COMDAT
; _this$ = ecx

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPArrivalTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPArrivalTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::ZeroRotationAboutOrigin, COMDAT
; _this$ = ecx

; 144  :     void ZeroRotationAboutOrigin( void ) { dmatrix.rotation01 = dmatrix.rotation10 = 0.0f, dmatrix.rotation00 = dmatrix.rotation11 = 1.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+84], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+80], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+88], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+76], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::ZeroRotationAboutOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CenterOriginInViewport@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::CenterOriginInViewport, COMDAT
; _this$ = ecx

; 143  : 	void CenterOriginInViewport( void )  { dmatrix.translationX = 0.0f; dmatrix.translationY = 0.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+68], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+72], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::CenterOriginInViewport
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 519  :         {return (floorf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	pop	ebp
	ret	0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?ceil@@YAMM@Z PROC					; ceil, COMDAT

; 509  :         {return (ceilf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	pop	ebp
	ret	0
?ceil@@YAMM@Z ENDP					; ceil
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 416  :         {return ((float)floor((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 408  :         {return ((float)ceil((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ceil
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
