; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\FCC\Fccmain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?DATALINK_CYCLE@FireControlComputer@@2HB	; FireControlComputer::DATALINK_CYCLE
PUBLIC	?MAXJSTARRANGESQ@FireControlComputer@@2MB	; FireControlComputer::MAXJSTARRANGESQ
PUBLIC	?EMITTERRANGE@FireControlComputer@@2MB		; FireControlComputer::EMITTERRANGE
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?CursorRate@FireControlComputer@@2MB		; FireControlComputer::CursorRate
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
?DATALINK_CYCLE@FireControlComputer@@2HB DD 014H	; FireControlComputer::DATALINK_CYCLE
?MAXJSTARRANGESQ@FireControlComputer@@2MB DD 0471c4000r ; 40000 ; FireControlComputer::MAXJSTARRANGESQ
?EMITTERRANGE@FireControlComputer@@2MB DD 042700000r ; 60 ; FireControlComputer::EMITTERRANGE
?CursorRate@FireControlComputer@@2MB DD 03e19999ar ; 0.15 ; FireControlComputer::CursorRate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?CurrentForegroundColor@ContextMPR@@QAEHXZ	; ContextMPR::CurrentForegroundColor
PUBLIC	??0VirtualDisplay@@QAE@XZ			; VirtualDisplay::VirtualDisplay
PUBLIC	??1VirtualDisplay@@UAE@XZ			; VirtualDisplay::~VirtualDisplay
PUBLIC	?Circle@VirtualDisplay@@UAEXMMM@Z		; VirtualDisplay::Circle
PUBLIC	?Arc@VirtualDisplay@@UAEXMMMMM@Z		; VirtualDisplay::Arc
PUBLIC	?TextWidth@VirtualDisplay@@UAEMPAD@Z		; VirtualDisplay::TextWidth
PUBLIC	?TextHeight@VirtualDisplay@@UAEMXZ		; VirtualDisplay::TextHeight
PUBLIC	?CurFont@VirtualDisplay@@SAHXZ			; VirtualDisplay::CurFont
PUBLIC	?SetLineStyle@VirtualDisplay@@UAEXH@Z		; VirtualDisplay::SetLineStyle
PUBLIC	?Color@VirtualDisplay@@UAEKXZ			; VirtualDisplay::Color
PUBLIC	??_GVirtualDisplay@@UAEPAXI@Z			; VirtualDisplay::`scalar deleting destructor'
PUBLIC	??0Render2D@@QAE@XZ				; Render2D::Render2D
PUBLIC	??1Render2D@@UAE@XZ				; Render2D::~Render2D
PUBLIC	?ClearDraw@Render2D@@UAEXXZ			; Render2D::ClearDraw
PUBLIC	?ClearZBuffer@Render2D@@UAEXXZ			; Render2D::ClearZBuffer
PUBLIC	?Color@Render2D@@UAEKXZ				; Render2D::Color
PUBLIC	?SetColor@Render2D@@UAEXK@Z			; Render2D::SetColor
PUBLIC	?SetBackground@Render2D@@UAEXK@Z		; Render2D::SetBackground
PUBLIC	?SetLineStyle@Render2D@@UAEXH@Z			; Render2D::SetLineStyle
PUBLIC	??_GRender2D@@UAEPAXI@Z				; Render2D::`scalar deleting destructor'
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsCampaign@FalconEntity@@QAEHXZ		; FalconEntity::IsCampaign
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
PUBLIC	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
PUBLIC	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
PUBLIC	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset
PUBLIC	??0DrawableClass@@IAE@XZ			; DrawableClass::DrawableClass
PUBLIC	??1DrawableClass@@UAE@XZ			; DrawableClass::~DrawableClass
PUBLIC	?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z ; DrawableClass::Display
PUBLIC	?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z ; DrawableClass::DisplayInit
PUBLIC	?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ ; DrawableClass::GetDisplay
PUBLIC	?PushButton@DrawableClass@@UAEXHH@Z		; DrawableClass::PushButton
PUBLIC	??_GDrawableClass@@UAEPAXI@Z			; DrawableClass::`scalar deleting destructor'
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	??0MfdDrawable@@QAE@XZ				; MfdDrawable::MfdDrawable
PUBLIC	?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z	; MfdDrawable::Display
PUBLIC	??_GMfdDrawable@@UAEPAXI@Z			; MfdDrawable::`scalar deleting destructor'
PUBLIC	?IsSetBombFlag@BombClass@@QAEHH@Z		; BombClass::IsSetBombFlag
PUBLIC	??0GroundListElement@@QAE@PAVFalconEntity@@@Z	; GroundListElement::GroundListElement
PUBLIC	??1GroundListElement@@QAE@XZ			; GroundListElement::~GroundListElement
PUBLIC	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
PUBLIC	?GetNext@GroundListElement@@QAEPAV1@XZ		; GroundListElement::GetNext
PUBLIC	?HandoffBaseObject@GroundListElement@@QAEXXZ	; GroundListElement::HandoffBaseObject
PUBLIC	?SetFlag@GroundListElement@@QAEXH@Z		; GroundListElement::SetFlag
PUBLIC	??_GGroundListElement@@QAEPAXI@Z		; GroundListElement::`scalar deleting destructor'
PUBLIC	?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z ; FireControlComputer::TargetStep
PUBLIC	?Display@FireControlComputer@@EAEXPAVVirtualDisplay@@@Z ; FireControlComputer::Display
PUBLIC	?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z ; FireControlComputer::DisplayInit
PUBLIC	??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z ; FireControlComputer::FireControlComputer
PUBLIC	??1FireControlComputer@@UAE@XZ			; FireControlComputer::~FireControlComputer
PUBLIC	?LastMissileWillMiss@FireControlComputer@@QAEHM@Z ; FireControlComputer::LastMissileWillMiss
PUBLIC	?SetSms@FireControlComputer@@QAEXPAVSMSClass@@@Z ; FireControlComputer::SetSms
PUBLIC	?ClearOverrideMode@FireControlComputer@@QAEXXZ	; FireControlComputer::ClearOverrideMode
PUBLIC	?NextSubMode@FireControlComputer@@QAEXXZ	; FireControlComputer::NextSubMode
PUBLIC	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
PUBLIC	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
PUBLIC	?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetDgftSubMode
PUBLIC	?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetMrmSubMode
PUBLIC	?WeaponStep@FireControlComputer@@QAEXXZ		; FireControlComputer::WeaponStep
PUBLIC	?Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV2@0PAVPilotInputs@@@Z ; FireControlComputer::Exec
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
PUBLIC	?SetPlayerFCC@FireControlComputer@@QAEXH@Z	; FireControlComputer::SetPlayerFCC
PUBLIC	?ClearCurrentTarget@FireControlComputer@@QAEXXZ	; FireControlComputer::ClearCurrentTarget
PUBLIC	?SetTarget@FireControlComputer@@QAEXPAVSimObjectType@@@Z ; FireControlComputer::SetTarget
PUBLIC	?Aim120ASECRadius@FireControlComputer@@QAEMM@Z	; FireControlComputer::Aim120ASECRadius
PUBLIC	?PushButton@FireControlComputer@@UAEXHH@Z	; FireControlComputer::PushButton
PUBLIC	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
PUBLIC	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
PUBLIC	?MissileLaunch@FireControlComputer@@QAEXXZ	; FireControlComputer::MissileLaunch
PUBLIC	?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ; FireControlComputer::GetFirstGroundElement
PUBLIC	?AddGroundElement@FireControlComputer@@QAEXPAVGroundListElement@@@Z ; FireControlComputer::AddGroundElement
PUBLIC	?BuildPrePlanned@FireControlComputer@@QAEXXZ	; FireControlComputer::BuildPrePlanned
PUBLIC	?UpdatePlanned@FireControlComputer@@QAEXXZ	; FireControlComputer::UpdatePlanned
PUBLIC	?ClearPlanned@FireControlComputer@@QAEXXZ	; FireControlComputer::ClearPlanned
PUBLIC	?PruneList@FireControlComputer@@QAEXXZ		; FireControlComputer::PruneList
PUBLIC	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
PUBLIC	?CanStepToWeaponClass@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::CanStepToWeaponClass
PUBLIC	?SetAAMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ ; FireControlComputer::SetAAMasterModeForCurrentWeapon
PUBLIC	?SetAGMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ ; FireControlComputer::SetAGMasterModeForCurrentWeapon
PUBLIC	?IsInAAMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsInAAMasterMode
PUBLIC	?IsInAGMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsInAGMasterMode
PUBLIC	?EnterAAMasterMode@FireControlComputer@@QAEXXZ	; FireControlComputer::EnterAAMasterMode
PUBLIC	?EnterAGMasterMode@FireControlComputer@@QAEXXZ	; FireControlComputer::EnterAGMasterMode
PUBLIC	?EnterMissileOverrideMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterMissileOverrideMode
PUBLIC	?EnterDogfightMode@FireControlComputer@@QAEXXZ	; FireControlComputer::EnterDogfightMode
PUBLIC	?ToggleAAGunMode@FireControlComputer@@QAEXXZ	; FireControlComputer::ToggleAAGunMode
PUBLIC	?ToggleAGGunMode@FireControlComputer@@QAEXXZ	; FireControlComputer::ToggleAGGunMode
PUBLIC	?AllowMaddog@FireControlComputer@@QAE_NXZ	; FireControlComputer::AllowMaddog
PUBLIC	?UpdateWeaponPtr@FireControlComputer@@AAEXXZ	; FireControlComputer::UpdateWeaponPtr
PUBLIC	?UpdateLastData@FireControlComputer@@AAEXXZ	; FireControlComputer::UpdateLastData
PUBLIC	??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z ; VuBin<MissileClass>::VuBin<MissileClass>
PUBLIC	??1?$VuBin@VMissileClass@@@@QAE@XZ		; VuBin<MissileClass>::~VuBin<MissileClass>
PUBLIC	?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ; VuBin<MissileClass>::reset
PUBLIC	??_GFireControlComputer@@UAEPAXI@Z		; FireControlComputer::`scalar deleting destructor'
PUBLIC	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::GetCurrentWeaponHardpoint
PUBLIC	?CurHardpoint@SMSBaseClass@@QAEHXZ		; SMSBaseClass::CurHardpoint
PUBLIC	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ	; SMSClass::GetCoolState
PUBLIC	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z	; SMSClass::SetCoolState
PUBLIC	?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ; SMSClass::GetAGBSubMode
PUBLIC	?SetAGBSubMode@SMSClass@@QAEXW4FCCSubMode@FireControlComputer@@@Z ; SMSClass::SetAGBSubMode
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	?RunningTactical@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningTactical
PUBLIC	?RunningCampaign@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningCampaign
PUBLIC	?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaignOrTactical
PUBLIC	?MotionOn@SimulationDriver@@QAEHXZ		; SimulationDriver::MotionOn
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	?SetScanDir@RadarDopplerClass@@QAEXM@Z		; RadarDopplerClass::SetScanDir
PUBLIC	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
PUBLIC	?SetSubMode@HarmTargetingPod@@QAEXW4Submode@1@@Z ; HarmTargetingPod::SetSubMode
PUBLIC	?SetHandedoff@HarmTargetingPod@@QAEX_N@Z	; HarmTargetingPod::SetHandedoff
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_7VirtualDisplay@@6B@				; VirtualDisplay::`vftable'
PUBLIC	??_7Render2D@@6B@				; Render2D::`vftable'
PUBLIC	??_7DrawableClass@@6B@				; DrawableClass::`vftable'
PUBLIC	??_7MfdDrawable@@6B@				; MfdDrawable::`vftable'
PUBLIC	??_7FireControlComputer@@6B@			; FireControlComputer::`vftable'
PUBLIC	??_C@_03DDIMFGBA@SAM?$AA@			; `string'
PUBLIC	??_C@_03CNOMELDJ@SRM?$AA@			; `string'
PUBLIC	??_C@_03JNCKGLJF@MRM?$AA@			; `string'
PUBLIC	??_C@_04OBEHOCAG@EEGS?$AA@			; `string'
PUBLIC	??_C@_04DNACHFNH@SSLC?$AA@			; `string'
PUBLIC	??_C@_04MHCPIOBD@LCOS?$AA@			; `string'
PUBLIC	??_C@_04PGEGCIFE@SNAP?$AA@			; `string'
PUBLIC	??_C@_04GKNPDGLD@CCIP?$AA@			; `string'
PUBLIC	??_C@_04HKKMHKCC@CCRP?$AA@			; `string'
PUBLIC	??_C@_04DKJBKKPE@DTOS?$AA@			; `string'
PUBLIC	??_C@_04GEPACNOP@LADD?$AA@			; `string'
PUBLIC	??_C@_03KIGHCFHP@MAN?$AA@			; `string'
PUBLIC	??_C@_04FALHJJOL@RCKT?$AA@			; `string'
PUBLIC	??_C@_04MLBKDHFB@STRF?$AA@			; `string'
PUBLIC	??_C@_04GJFEKAJC@BSGT?$AA@			; `string'
PUBLIC	??_C@_04KBFEHFJ@SLAV?$AA@			; `string'
PUBLIC	??_C@_03HKDINIMK@HTS?$AA@			; `string'
PUBLIC	??_C@_04FIBJOPKE@HARM?$AA@			; `string'
PUBLIC	??_C@_03GMKKLANI@GBU?$AA@			; `string'
PUBLIC	??_C@_03MJEMAIFN@FCC?$AA@			; `string'
PUBLIC	??_C@_03MPPIHBHJ@OFF?$AA@			; `string'
PUBLIC	??_C@_03DIMJBCMI@NAV?$AA@			; `string'
PUBLIC	??_C@_04FPNANLBH@RPOD?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Render2D@@8			; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRender2D@@@8				; Render2D `RTTI Type Descriptor'
PUBLIC	??_R3Render2D@@8				; Render2D::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Render2D@@8				; Render2D::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VirtualDisplay@@8			; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVirtualDisplay@@@8			; VirtualDisplay `RTTI Type Descriptor'
PUBLIC	??_R3VirtualDisplay@@8				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VirtualDisplay@@8				; VirtualDisplay::`RTTI Base Class Array'
PUBLIC	??_R4VirtualDisplay@@6B@			; VirtualDisplay::`RTTI Complete Object Locator'
PUBLIC	??_R4Render2D@@6B@				; Render2D::`RTTI Complete Object Locator'
PUBLIC	??_R4FireControlComputer@@6B@			; FireControlComputer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFireControlComputer@@@8			; FireControlComputer `RTTI Type Descriptor'
PUBLIC	??_R3FireControlComputer@@8			; FireControlComputer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FireControlComputer@@8			; FireControlComputer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FireControlComputer@@8		; FireControlComputer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@MfdDrawable@@8			; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMfdDrawable@@@8				; MfdDrawable `RTTI Type Descriptor'
PUBLIC	??_R3MfdDrawable@@8				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MfdDrawable@@8				; MfdDrawable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DrawableClass@@8			; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDrawableClass@@@8			; DrawableClass `RTTI Type Descriptor'
PUBLIC	??_R3DrawableClass@@8				; DrawableClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DrawableClass@@8				; DrawableClass::`RTTI Base Class Array'
PUBLIC	??_R4DrawableClass@@6B@				; DrawableClass::`RTTI Complete Object Locator'
PUBLIC	??_R4MfdDrawable@@6B@				; MfdDrawable::`RTTI Complete Object Locator'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@392c987a
PUBLIC	__real@3d8f5c29
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f19999a
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40490fd9
PUBLIC	__real@41700000
PUBLIC	__real@42a00000
PUBLIC	__real@43160000
PUBLIC	__real@437a0000
PUBLIC	__real@447a0000
PUBLIC	__real@45bde1b0
PUBLIC	__real@476d5a1c
PUBLIC	__real@47ed5a1c
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0a00000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??0ContextMPR@@QAE@XZ:PROC			; ContextMPR::ContextMPR
EXTRN	??1ContextMPR@@UAE@XZ:PROC			; ContextMPR::~ContextMPR
EXTRN	?SetState@ContextMPR@@QAEXGK@Z:PROC		; ContextMPR::SetState
EXTRN	?ClearBuffers@ContextMPR@@QAEXG@Z:PROC		; ContextMPR::ClearBuffers
EXTRN	?SelectForegroundColor@ContextMPR@@QAEXH@Z:PROC	; ContextMPR::SelectForegroundColor
EXTRN	?RestoreState@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::RestoreState
EXTRN	?Setup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Setup
EXTRN	?Cleanup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Cleanup
EXTRN	?Point@VirtualDisplay@@UAEXMM@Z:PROC		; VirtualDisplay::Point
EXTRN	?Line@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Line@VirtualDisplay@@UAEXMMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Tri@VirtualDisplay@@UAEXMMMMMM@Z:PROC		; VirtualDisplay::Tri
EXTRN	?Oval@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Oval
EXTRN	?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z:PROC	; VirtualDisplay::OvalArc
EXTRN	?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextLeft
EXTRN	?TextRight@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextRight
EXTRN	?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextLeftVertical
EXTRN	?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextRightVertical
EXTRN	?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextCenter
EXTRN	?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextCenterVertical
EXTRN	?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z:PROC	; VirtualDisplay::TextWrap
EXTRN	?ScreenTextHeight@VirtualDisplay@@SAHXZ:PROC	; VirtualDisplay::ScreenTextHeight
EXTRN	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z:PROC	; VirtualDisplay::ScreenTextWidth
EXTRN	?SetFont@VirtualDisplay@@SAXH@Z:PROC		; VirtualDisplay::SetFont
EXTRN	?SetViewport@VirtualDisplay@@UAEXMMMM@Z:PROC	; VirtualDisplay::SetViewport
EXTRN	?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z:PROC ; VirtualDisplay::SetViewportRelative
EXTRN	?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z:PROC	; VirtualDisplay::Render2DTri
EXTRN	??_EVirtualDisplay@@UAEPAXI@Z:PROC		; VirtualDisplay::`vector deleting destructor'
EXTRN	?Setup@Render2D@@UAEXPAVImageBuffer@@@Z:PROC	; Render2D::Setup
EXTRN	?Cleanup@Render2D@@UAEXXZ:PROC			; Render2D::Cleanup
EXTRN	?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z:PROC ; Render2D::SetImageBuffer
EXTRN	?StartDraw@Render2D@@UAEXXZ:PROC		; Render2D::StartDraw
EXTRN	?EndDraw@Render2D@@UAEXXZ:PROC			; Render2D::EndDraw
EXTRN	?SetViewport@Render2D@@UAEXMMMM@Z:PROC		; Render2D::SetViewport
EXTRN	?Render2DPoint@Render2D@@UAEXMM@Z:PROC		; Render2D::Render2DPoint
EXTRN	?Render2DLine@Render2D@@UAEXMMMM@Z:PROC		; Render2D::Render2DLine
EXTRN	?Render2DTri@Render2D@@UAEXMMMMMM@Z:PROC	; Render2D::Render2DTri
EXTRN	?ScreenText@Render2D@@UAEXMMPBDH@Z:PROC		; Render2D::ScreenText
EXTRN	??_ERender2D@@UAEPAXI@Z:PROC			; Render2D::`vector deleting destructor'
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?Unregister@VuCollection@@QAEXXZ:PROC		; VuCollection::Unregister
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z:PROC ; SimMoverClass::SetTarget
EXTRN	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z:PROC ; SimVehicleClass::SOIManager
EXTRN	?StepSOI@SimVehicleClass@@QAEXH@Z:PROC		; SimVehicleClass::StepSOI
EXTRN	?DisplayExit@DrawableClass@@UAEXXZ:PROC		; DrawableClass::DisplayExit
EXTRN	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z:PROC ; DrawableClass::GetMfdColor
EXTRN	??_EDrawableClass@@UAEPAXI@Z:PROC		; DrawableClass::`vector deleting destructor'
EXTRN	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z:PROC	; MFDClass::SetNewMode
EXTRN	??1MfdDrawable@@UAE@XZ:PROC			; MfdDrawable::~MfdDrawable
EXTRN	?DisplayInit@MfdDrawable@@UAEXPAVImageBuffer@@@Z:PROC ; MfdDrawable::DisplayInit
EXTRN	?PushButton@MfdDrawable@@UAEXHH@Z:PROC		; MfdDrawable::PushButton
EXTRN	?BottomRow@MfdDrawable@@QAEXXZ:PROC		; MfdDrawable::BottomRow
EXTRN	??_EMfdDrawable@@UAEPAXI@Z:PROC			; MfdDrawable::`vector deleting destructor'
EXTRN	?MFDSwapDisplays@@YAXXZ:PROC			; MFDSwapDisplays
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?LauGetWeaponId@BombClass@@QAEHXZ:PROC		; BombClass::LauGetWeaponId
EXTRN	?GetTheBomb@FireControlComputer@@QAEPAVBombClass@@XZ:PROC ; FireControlComputer::GetTheBomb
EXTRN	?AirGroundMode@FireControlComputer@@AAEXXZ:PROC	; FireControlComputer::AirGroundMode
EXTRN	?AirGroundMissileMode@FireControlComputer@@AAEXXZ:PROC ; FireControlComputer::AirGroundMissileMode
EXTRN	?TargetingPodMode@FireControlComputer@@AAEXXZ:PROC ; FireControlComputer::TargetingPodMode
EXTRN	?NavMode@FireControlComputer@@AAEXXZ:PROC	; FireControlComputer::NavMode
EXTRN	?AirAirMode@FireControlComputer@@AAEXXZ:PROC	; FireControlComputer::AirAirMode
EXTRN	?NavDisplay@FireControlComputer@@AAEXXZ:PROC	; FireControlComputer::NavDisplay
EXTRN	?ToggleHSDZoom@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::ToggleHSDZoom
EXTRN	??_EFireControlComputer@@UAEPAXI@Z:PROC		; FireControlComputer::`vector deleting destructor'
EXTRN	?GetCurrentWeaponType@SMSBaseClass@@QAE?AW4WeaponType@@XZ:PROC ; SMSBaseClass::GetCurrentWeaponType
EXTRN	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z:PROC	; SMSBaseClass::StepMavSubMode
EXTRN	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z:PROC ; SMSClass::SetWeaponType
EXTRN	?WeaponStep@SMSClass@@QAEHH@Z:PROC		; SMSClass::WeaponStep
EXTRN	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z:PROC ; SMSClass::FindWeaponClass
EXTRN	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z:PROC ; SMSClass::FindWeaponType
EXTRN	?SetPlayerSMS@SMSClass@@QAEXH@Z:PROC		; SMSClass::SetPlayerSMS
EXTRN	?GetCurrentWeaponId@SMSClass@@QAEHXZ:PROC	; SMSClass::GetCurrentWeaponId
EXTRN	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z:PROC	; SMSClass::SetCurrentHardPoint
EXTRN	??0SimObjectType@@QAE@PAVFalconEntity@@@Z:PROC	; SimObjectType::SimObjectType
EXTRN	?Reference@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Reference
EXTRN	?Release@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Release
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?SimHSDRangeStepUp@@YAXKHPAX@Z:PROC		; SimHSDRangeStepUp
EXTRN	?SimHSDRangeStepDown@@YAXKHPAX@Z:PROC		; SimHSDRangeStepDown
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z:PROC ; SmsDrawable::SetDisplayMode
EXTRN	?Distance@@YAMMMMM@Z:PROC			; Distance
EXTRN	?GetJSTARFlight@FlightClass@@QAEPAV1@XZ:PROC	; FlightClass::GetJSTARFlight
EXTRN	?SimCampHandoff@@YAPAVFalconEntity@@PAV1@W4HandOffType@@@Z:PROC ; SimCampHandoff
EXTRN	?InitAMissile@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z:PROC ; InitAMissile
EXTRN	?GetWeaponF4CT@@YAPAUFalcon4EntityClassType@@H@Z:PROC ; GetWeaponF4CT
EXTRN	?InitABomb@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z:PROC ; InitABomb
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?pFontSet@VirtualDisplay@@2PAUFontSet@@A:DWORD	; VirtualDisplay::pFontSet
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SimLibMajorFrameRate@@3MA:DWORD		; SimLibMajorFrameRate
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A:BYTE ; FireControlComputer::hsdcntlcfg
EXTRN	?AllAirList@@3PAVVuLinkedList@@A:DWORD		; AllAirList
EXTRN	?EmitterList@@3PAVFalconPrivateList@@A:DWORD	; EmitterList
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?RadarDataTable@@3PAURadarDataType@@A:DWORD	; RadarDataTable
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?g_bUseRC135@@3_NA:BYTE				; g_bUseRC135
EXTRN	?g_bEnableFCCSubNavCycle@@3_NA:BYTE		; g_bEnableFCCSubNavCycle
EXTRN	?g_bWeaponStepToGun@@3_NA:BYTE			; g_bWeaponStepToGun
EXTRN	?g_bGreyMFD@@3_NA:BYTE				; g_bGreyMFD
EXTRN	?bNVGmode@@3_NA:BYTE				; bNVGmode
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@47ed5a1c
CONST	SEGMENT
__real@47ed5a1c DD 047ed5a1cr			; 121524
CONST	ENDS
;	COMDAT __real@476d5a1c
CONST	SEGMENT
__real@476d5a1c DD 0476d5a1cr			; 60762.1
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d8f5c29
CONST	SEGMENT
__real@3d8f5c29 DD 03d8f5c29r			; 0.07
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R4MfdDrawable@@6B@
rdata$r	SEGMENT
??_R4MfdDrawable@@6B@ DD 00H				; MfdDrawable::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMfdDrawable@@@8
	DD	FLAT:??_R3MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R4DrawableClass@@6B@
rdata$r	SEGMENT
??_R4DrawableClass@@6B@ DD 00H				; DrawableClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDrawableClass@@@8
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R2DrawableClass@@8
rdata$r	SEGMENT
??_R2DrawableClass@@8 DD FLAT:??_R1A@?0A@EA@DrawableClass@@8 ; DrawableClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DrawableClass@@8
rdata$r	SEGMENT
??_R3DrawableClass@@8 DD 00H				; DrawableClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawableClass@@@8
_DATA	SEGMENT
??_R0?AVDrawableClass@@@8 DD FLAT:??_7type_info@@6B@	; DrawableClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawableClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@DrawableClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DrawableClass@@8 DD FLAT:??_R0?AVDrawableClass@@@8 ; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R2MfdDrawable@@8
rdata$r	SEGMENT
??_R2MfdDrawable@@8 DD FLAT:??_R1A@?0A@EA@MfdDrawable@@8 ; MfdDrawable::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3MfdDrawable@@8
rdata$r	SEGMENT
??_R3MfdDrawable@@8 DD 00H				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMfdDrawable@@@8
_DATA	SEGMENT
??_R0?AVMfdDrawable@@@8 DD FLAT:??_7type_info@@6B@	; MfdDrawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMfdDrawable@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@MfdDrawable@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MfdDrawable@@8 DD FLAT:??_R0?AVMfdDrawable@@@8 ; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FireControlComputer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FireControlComputer@@8 DD FLAT:??_R0?AVFireControlComputer@@@8 ; FireControlComputer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FireControlComputer@@8
rdata$r	ENDS
;	COMDAT ??_R2FireControlComputer@@8
rdata$r	SEGMENT
??_R2FireControlComputer@@8 DD FLAT:??_R1A@?0A@EA@FireControlComputer@@8 ; FireControlComputer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3FireControlComputer@@8
rdata$r	SEGMENT
??_R3FireControlComputer@@8 DD 00H			; FireControlComputer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2FireControlComputer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFireControlComputer@@@8
_DATA	SEGMENT
??_R0?AVFireControlComputer@@@8 DD FLAT:??_7type_info@@6B@ ; FireControlComputer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFireControlComputer@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FireControlComputer@@6B@
rdata$r	SEGMENT
??_R4FireControlComputer@@6B@ DD 00H			; FireControlComputer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFireControlComputer@@@8
	DD	FLAT:??_R3FireControlComputer@@8
rdata$r	ENDS
;	COMDAT ??_R4Render2D@@6B@
rdata$r	SEGMENT
??_R4Render2D@@6B@ DD 00H				; Render2D::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRender2D@@@8
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R4VirtualDisplay@@6B@
rdata$r	SEGMENT
??_R4VirtualDisplay@@6B@ DD 00H				; VirtualDisplay::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVirtualDisplay@@@8
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2VirtualDisplay@@8
rdata$r	SEGMENT
??_R2VirtualDisplay@@8 DD FLAT:??_R1A@?0A@EA@VirtualDisplay@@8 ; VirtualDisplay::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VirtualDisplay@@8
rdata$r	SEGMENT
??_R3VirtualDisplay@@8 DD 00H				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVirtualDisplay@@@8
_DATA	SEGMENT
??_R0?AVVirtualDisplay@@@8 DD FLAT:??_7type_info@@6B@	; VirtualDisplay `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVirtualDisplay@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VirtualDisplay@@8 DD FLAT:??_R0?AVVirtualDisplay@@@8 ; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2Render2D@@8
rdata$r	SEGMENT
??_R2Render2D@@8 DD FLAT:??_R1A@?0A@EA@Render2D@@8	; Render2D::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R3Render2D@@8
rdata$r	SEGMENT
??_R3Render2D@@8 DD 00H					; Render2D::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRender2D@@@8
_DATA	SEGMENT
??_R0?AVRender2D@@@8 DD FLAT:??_7type_info@@6B@		; Render2D `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRender2D@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Render2D@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Render2D@@8 DD FLAT:??_R0?AVRender2D@@@8	; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPNANLBH@RPOD?$AA@
CONST	SEGMENT
??_C@_04FPNANLBH@RPOD?$AA@ DB 'RPOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DIMJBCMI@NAV?$AA@
CONST	SEGMENT
??_C@_03DIMJBCMI@NAV?$AA@ DB 'NAV', 00H			; `string'
CONST	ENDS
;	COMDAT ?bestmaxrange@?1??Aim120ASECRadius@FireControlComputer@@QAEMM@Z@4MB
CONST	SEGMENT
?bestmaxrange@?1??Aim120ASECRadius@FireControlComputer@@QAEMM@Z@4MB DD 03f4ccccdr ; 0.8 ; `FireControlComputer::Aim120ASECRadius'::`2'::bestmaxrange
CONST	ENDS
;	COMDAT ??_C@_03MPPIHBHJ@OFF?$AA@
CONST	SEGMENT
??_C@_03MPPIHBHJ@OFF?$AA@ DB 'OFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJEMAIFN@FCC?$AA@
CONST	SEGMENT
??_C@_03MJEMAIFN@FCC?$AA@ DB 'FCC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMKKLANI@GBU?$AA@
CONST	SEGMENT
??_C@_03GMKKLANI@GBU?$AA@ DB 'GBU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FIBJOPKE@HARM?$AA@
CONST	SEGMENT
??_C@_04FIBJOPKE@HARM?$AA@ DB 'HARM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKDINIMK@HTS?$AA@
CONST	SEGMENT
??_C@_03HKDINIMK@HTS?$AA@ DB 'HTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEHFJ@SLAV?$AA@
CONST	SEGMENT
??_C@_04KBFEHFJ@SLAV?$AA@ DB 'SLAV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJFEKAJC@BSGT?$AA@
CONST	SEGMENT
??_C@_04GJFEKAJC@BSGT?$AA@ DB 'BSGT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLBKDHFB@STRF?$AA@
CONST	SEGMENT
??_C@_04MLBKDHFB@STRF?$AA@ DB 'STRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FALHJJOL@RCKT?$AA@
CONST	SEGMENT
??_C@_04FALHJJOL@RCKT?$AA@ DB 'RCKT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KIGHCFHP@MAN?$AA@
CONST	SEGMENT
??_C@_03KIGHCFHP@MAN?$AA@ DB 'MAN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEPACNOP@LADD?$AA@
CONST	SEGMENT
??_C@_04GEPACNOP@LADD?$AA@ DB 'LADD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKJBKKPE@DTOS?$AA@
CONST	SEGMENT
??_C@_04DKJBKKPE@DTOS?$AA@ DB 'DTOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HKKMHKCC@CCRP?$AA@
CONST	SEGMENT
??_C@_04HKKMHKCC@CCRP?$AA@ DB 'CCRP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKNPDGLD@CCIP?$AA@
CONST	SEGMENT
??_C@_04GKNPDGLD@CCIP?$AA@ DB 'CCIP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGEGCIFE@SNAP?$AA@
CONST	SEGMENT
??_C@_04PGEGCIFE@SNAP?$AA@ DB 'SNAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHCPIOBD@LCOS?$AA@
CONST	SEGMENT
??_C@_04MHCPIOBD@LCOS?$AA@ DB 'LCOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNACHFNH@SSLC?$AA@
CONST	SEGMENT
??_C@_04DNACHFNH@SSLC?$AA@ DB 'SSLC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OBEHOCAG@EEGS?$AA@
CONST	SEGMENT
??_C@_04OBEHOCAG@EEGS?$AA@ DB 'EEGS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JNCKGLJF@MRM?$AA@
CONST	SEGMENT
??_C@_03JNCKGLJF@MRM?$AA@ DB 'MRM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNOMELDJ@SRM?$AA@
CONST	SEGMENT
??_C@_03CNOMELDJ@SRM?$AA@ DB 'SRM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DDIMFGBA@SAM?$AA@
CONST	SEGMENT
??_C@_03DDIMFGBA@SAM?$AA@ DB 'SAM', 00H			; `string'
CONST	ENDS
;	COMDAT ?MISSILE_SPEED@?1??Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV3@0PAVPilotInputs@@@Z@4MB
CONST	SEGMENT
?MISSILE_SPEED@?1??Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV3@0PAVPilotInputs@@@Z@4MB DD 044bb8000r ; 1500 ; `FireControlComputer::Exec'::`2'::MISSILE_SPEED
CONST	ENDS
;	COMDAT ?MISSILE_ALTITUDE_BONUS@?1??Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV3@0PAVPilotInputs@@@Z@4MB
CONST	SEGMENT
?MISSILE_ALTITUDE_BONUS@?1??Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV3@0PAVPilotInputs@@@Z@4MB DD 041b80000r ; 23 ; `FireControlComputer::Exec'::`2'::MISSILE_ALTITUDE_BONUS
CONST	ENDS
;	COMDAT ??_7FireControlComputer@@6B@
CONST	SEGMENT
??_7FireControlComputer@@6B@ DD FLAT:??_R4FireControlComputer@@6B@ ; FireControlComputer::`vftable'
	DD	FLAT:??_EFireControlComputer@@UAEPAXI@Z
	DD	FLAT:?Display@FireControlComputer@@EAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@FireControlComputer@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_7MfdDrawable@@6B@
CONST	SEGMENT
??_7MfdDrawable@@6B@ DD FLAT:??_R4MfdDrawable@@6B@	; MfdDrawable::`vftable'
	DD	FLAT:??_EMfdDrawable@@UAEPAXI@Z
	DD	FLAT:?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@MfdDrawable@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@MfdDrawable@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_7DrawableClass@@6B@
CONST	SEGMENT
??_7DrawableClass@@6B@ DD FLAT:??_R4DrawableClass@@6B@	; DrawableClass::`vftable'
	DD	FLAT:??_EDrawableClass@@UAEPAXI@Z
	DD	FLAT:?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@DrawableClass@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_7Render2D@@6B@
CONST	SEGMENT
??_7Render2D@@6B@ DD FLAT:??_R4Render2D@@6B@		; Render2D::`vftable'
	DD	FLAT:??_ERender2D@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@Render2D@@UAEXXZ
	DD	FLAT:?StartDraw@Render2D@@UAEXXZ
	DD	FLAT:?ClearDraw@Render2D@@UAEXXZ
	DD	FLAT:?EndDraw@Render2D@@UAEXXZ
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:?SetColor@Render2D@@UAEXK@Z
	DD	FLAT:?SetBackground@Render2D@@UAEXK@Z
	DD	FLAT:?ScreenText@Render2D@@UAEXMMPBDH@Z
	DD	FLAT:?SetLineStyle@Render2D@@UAEXH@Z
	DD	FLAT:?Color@Render2D@@UAEKXZ
	DD	FLAT:?SetViewport@Render2D@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Render2DPoint@Render2D@@UAEXMM@Z
	DD	FLAT:?Render2DLine@Render2D@@UAEXMMMM@Z
	DD	FLAT:?Render2DTri@Render2D@@UAEXMMMMMM@Z
	DD	FLAT:?Setup@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?ClearZBuffer@Render2D@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7VirtualDisplay@@6B@
CONST	SEGMENT
??_7VirtualDisplay@@6B@ DD FLAT:??_R4VirtualDisplay@@6B@ ; VirtualDisplay::`vftable'
	DD	FLAT:??_EVirtualDisplay@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@VirtualDisplay@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?SetLineStyle@VirtualDisplay@@UAEXH@Z
	DD	FLAT:?Color@VirtualDisplay@@UAEKXZ
	DD	FLAT:?SetViewport@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z$0
__unwindtable$?BuildPrePlanned@FireControlComputer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildPrePlanned@FireControlComputer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?BuildPrePlanned@FireControlComputer@@QAEXXZ$1
__unwindtable$??1FireControlComputer@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FireControlComputer@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1FireControlComputer@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1FireControlComputer@@UAE@XZ$2
__unwindtable$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z$2
__unwindtable$?UpdatePlanned@FireControlComputer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$3
__unwindtable$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$3
__ehfuncinfo$?UpdatePlanned@FireControlComputer@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?UpdatePlanned@FireControlComputer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildPrePlanned@FireControlComputer@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?BuildPrePlanned@FireControlComputer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1FireControlComputer@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1FireControlComputer@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\harmpod.h
;	COMDAT ?SetHandedoff@HarmTargetingPod@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 1
?SetHandedoff@HarmTargetingPod@@QAEX_N@Z PROC		; HarmTargetingPod::SetHandedoff, COMDAT
; _this$ = ecx

; 111  : 	void			SetHandedoff ( bool value ) { handedoff = value; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [eax+112], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHandedoff@HarmTargetingPod@@QAEX_N@Z ENDP		; HarmTargetingPod::SetHandedoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\harmpod.h
;	COMDAT ?SetSubMode@HarmTargetingPod@@QAEXW4Submode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_HarmMode$ = 8						; size = 4
?SetSubMode@HarmTargetingPod@@QAEXW4Submode@1@@Z PROC	; HarmTargetingPod::SetSubMode, COMDAT
; _this$ = ecx

; 85   : 	void			SetSubMode ( Submode HarmMode ) { submode = HarmMode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _HarmMode$[ebp]
	mov	DWORD PTR [eax+168], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSubMode@HarmTargetingPod@@QAEXW4Submode@1@@Z ENDP	; HarmTargetingPod::SetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\harmpod.h
;	COMDAT ?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ PROC	; HarmTargetingPod::GetSubMode, COMDAT
; _this$ = ecx

; 83   : 	Submode			GetSubMode ( void ) { return submode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+168]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ENDP	; HarmTargetingPod::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetScanDir@RadarDopplerClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dir$ = 8						; size = 4
?SetScanDir@RadarDopplerClass@@QAEXM@Z PROC		; RadarDopplerClass::SetScanDir, COMDAT
; _this$ = ecx

; 247  : 	void SetScanDir(float dir)	{scanDir = dir;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp]
	movss	DWORD PTR [eax+252], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScanDir@RadarDopplerClass@@QAEXM@Z ENDP		; RadarDopplerClass::SetScanDir
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?MotionOn@SimulationDriver@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MotionOn@SimulationDriver@@QAEHXZ PROC			; SimulationDriver::MotionOn, COMDAT
; _this$ = ecx

; 98   : 	int MotionOn(void) {return motionOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+352]
	mov	esp, ebp
	pop	ebp
	ret	0
?MotionOn@SimulationDriver@@QAEHXZ ENDP			; SimulationDriver::MotionOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ PROC ; SimulationDriver::RunningCampaignOrTactical, COMDAT
; _this$ = ecx

; 61   : 	bool RunningCampaignOrTactical() const   { return RunningCampaign() || RunningTactical(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunningCampaign@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaign
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@RunningCam
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunningTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningTactical
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@RunningCam
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@RunningCam
$LN3@RunningCam:
	mov	DWORD PTR tv72[ebp], 1
$LN4@RunningCam:
	mov	al, BYTE PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ENDP ; SimulationDriver::RunningCampaignOrTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningCampaign@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningCampaign@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningCampaign, COMDAT
; _this$ = ecx

; 59   : 	bool RunningCampaign() const             { return FalconLocalGame->GetGameType() == game_Campaign; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningCam
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningCam
$LN3@RunningCam:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningCam:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	SHORT $LN5@RunningCam
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningCam
$LN5@RunningCam:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningCam:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningCampaign@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningTactical@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningTactical, COMDAT
; _this$ = ecx

; 57   : 	bool RunningTactical() const             { return FalconLocalGame->GetGameType() == game_TacticalEngagement; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningTac
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningTac
$LN3@RunningTac:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningTac:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN5@RunningTac
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningTac
$LN5@RunningTac:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningTac:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningTactical@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBSubMode@SMSClass@@QAEXW4FCCSubMode@FireControlComputer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_SubMode$ = 8						; size = 4
?SetAGBSubMode@SMSClass@@QAEXW4FCCSubMode@FireControlComputer@@@Z PROC ; SMSClass::SetAGBSubMode, COMDAT
; _this$ = ecx

; 327  : 									{ agbProfile[curProfile].subMode = SubMode;   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _SubMode$[ebp]
	mov	DWORD PTR [edx+ecx+236], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBSubMode@SMSClass@@QAEXW4FCCSubMode@FireControlComputer@@@Z ENDP ; SMSClass::SetAGBSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ PROC ; SMSClass::GetAGBSubMode, COMDAT
; _this$ = ecx

; 315  : 	FireControlComputer::FCCSubMode  GetAGBSubMode(void)        { return agbProfile[curProfile].subMode;         }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+236]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ENDP ; SMSClass::GetAGBSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z PROC	; SMSClass::SetCoolState, COMDAT
; _this$ = ecx

; 271  : 	void SetCoolState (Aim9Mode state) { aim9mode = state; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+180], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ENDP	; SMSClass::SetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ PROC	; SMSClass::GetCoolState, COMDAT
; _this$ = ecx

; 270  : 	Aim9Mode GetCoolState() { return aim9mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ENDP	; SMSClass::GetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ PROC	; SMSBaseClass::Ownship, COMDAT
; _this$ = ecx

; 91   : 	SimVehicleClass* Ownship(void) {return ownship;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ENDP	; SMSBaseClass::Ownship
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?CurHardpoint@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurHardpoint@SMSBaseClass@@QAEHXZ PROC			; SMSBaseClass::CurHardpoint, COMDAT
; _this$ = ecx

; 88   : 	int CurHardpoint (void) {return curHardpoint;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurHardpoint@SMSBaseClass@@QAEHXZ ENDP			; SMSBaseClass::CurHardpoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ PROC	; SMSBaseClass::GetCurrentWeaponHardpoint, COMDAT
; _this$ = ecx

; 79   : 	int GetCurrentWeaponHardpoint (void)			{ return curHardpoint; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ENDP	; SMSBaseClass::GetCurrentWeaponHardpoint
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GFireControlComputer@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFireControlComputer@@UAEPAXI@Z PROC			; FireControlComputer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FireControlComputer@@UAE@XZ		; FireControlComputer::~FireControlComputer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFireControlComputer@@UAEPAXI@Z ENDP			; FireControlComputer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newe$ = 8						; size = 4
?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z PROC ; VuBin<MissileClass>::reset, COMDAT
; _this$ = ecx

; 60   : 	void reset(E *newe = NULL){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if (newe == e){ return; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newe$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@reset
	jmp	SHORT $LN2@reset
$LN1@reset:

; 62   : 		VuReferenceEntity(newe); // ref new pointer

	mov	edx, DWORD PTR _newe$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 63   : 		VuDeReferenceEntity(e);  // unref old pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 64   : 		e = newe;                // get new pointer

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@reset:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ENDP ; VuBin<MissileClass>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??1?$VuBin@VMissileClass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$VuBin@VMissileClass@@@@QAE@XZ PROC			; VuBin<MissileClass>::~VuBin<MissileClass>, COMDAT
; _this$ = ecx

; 19   : 	~VuBin(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 		VuDeReferenceEntity((VuEntity *)e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 21   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$VuBin@VMissileClass@@@@QAE@XZ ENDP			; VuBin<MissileClass>::~VuBin<MissileClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z PROC ; VuBin<MissileClass>::VuBin<MissileClass>, COMDAT
; _this$ = ecx

; 11   : 	explicit VuBin(E *e = NULL) : e(e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], ecx

; 12   : 		VuReferenceEntity(e);

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z ENDP ; VuBin<MissileClass>::VuBin<MissileClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?UpdateLastData@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::UpdateLastData
; _this$ = ecx

; 2111 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2112 :    switch(masterMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv65[ebp], ecx
	mov	edx, DWORD PTR tv65[ebp]
	sub	edx, 2
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	$LN10@UpdateLast
	mov	eax, DWORD PTR tv65[ebp]
	movzx	ecx, BYTE PTR $LN12@UpdateLast[eax]
	jmp	DWORD PTR $LN13@UpdateLast[ecx*4]
$LN7@UpdateLast:

; 2113 :    {
; 2114 :    case ILS:
; 2115 :    case Nav:
; 2116 : 	   lastNavMasterMode = masterMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR [edx+76], ecx

; 2117 : 	   break;

	jmp	SHORT $LN10@UpdateLast
$LN6@UpdateLast:

; 2118 : 	   
; 2119 :    case Dogfight:
; 2120 : 	   lastDogfightHp        = Sms->GetCurrentWeaponHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2121 : 	   break;

	jmp	SHORT $LN10@UpdateLast
$LN5@UpdateLast:

; 2122 : 	   
; 2123 :    case MissileOverride:
; 2124 : 	   lastMissileOverrideHp = Sms->GetCurrentWeaponHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2125 : 	   break;

	jmp	SHORT $LN10@UpdateLast

; 2126 : 	   
; 2127 :    case AAGun:
; 2128 : 	   break;

	jmp	SHORT $LN10@UpdateLast
$LN3@UpdateLast:

; 2129 : 	   //if(!g_bWeaponStepToGun)
; 2130 : 	   //{
; 2131 : 	   //	break;
; 2132 : 	   //}
; 2133 : 	   // intentionally fall thru
; 2134 :    case Missile:
; 2135 : 	   //lastAaMasterMode	= masterMode;
; 2136 : 	   lastAirAirHp		= Sms->GetCurrentWeaponHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2137 : 	   break;

	jmp	SHORT $LN10@UpdateLast

; 2138 : 	   
; 2139 :    case AGGun:
; 2140 : 	   break;

	jmp	SHORT $LN10@UpdateLast
$LN1@UpdateLast:

; 2141 : 	   //if(!g_bWeaponStepToGun)
; 2142 : 	   //{
; 2143 : 	   //	break;
; 2144 : 	   //}
; 2145 : 	   // intentionally fall thru
; 2146 :    case AirGroundBomb:
; 2147 :    case AirGroundRocket:
; 2148 :    case AirGroundMissile:
; 2149 :    case AirGroundHARM:
; 2150 :    case AirGroundLaser:
; 2151 :    case AirGroundCamera:
; 2152 : 	   lastAgMasterMode	= masterMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR [edx+80], ecx

; 2153 : 	   lastAirGroundHp		= Sms->GetCurrentWeaponHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN10@UpdateLast:

; 2154 : 	   break;
; 2155 :    }
; 2156 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@UpdateLast:
	DD	$LN3@UpdateLast
	DD	$LN7@UpdateLast
	DD	$LN1@UpdateLast
	DD	$LN6@UpdateLast
	DD	$LN5@UpdateLast
	DD	$LN10@UpdateLast
$LN12@UpdateLast:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	4
	DB	2
	DB	5
	DB	2
?UpdateLastData@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::UpdateLastData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv228 = -16						; size = 4
_wid$ = -12						; size = 4
_classPtr$1 = -8					; size = 4
_this$ = -4						; size = 4
?UpdateWeaponPtr@FireControlComputer@@AAEXXZ PROC	; FireControlComputer::UpdateWeaponPtr
; _this$ = ecx

; 2451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2452 : 	// the fccWeaponPointer is ONLY used to access weapon data, impact prediction etc, it is NEVER fired.
; 2453 : 	int wid;
; 2454 : 
; 2455 : 	wid = Sms->GetCurrentWeaponId();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponId@SMSClass@@QAEHXZ	; SMSClass::GetCurrentWeaponId
	mov	DWORD PTR _wid$[ebp], eax

; 2456 : 	if(wid != fccWeaponId)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _wid$[ebp]
	cmp	edx, DWORD PTR [ecx+504]
	je	$LN16@UpdateWeap

; 2457 : 	{
; 2458 : 		fccWeaponPtr.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 2459 : 		fccWeaponId = wid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wid$[ebp]
	mov	DWORD PTR [eax+504], ecx

; 2460 : 		if(fccWeaponId)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+504], 0
	je	$LN16@UpdateWeap

; 2461 : 		{
; 2462 : 			Falcon4EntityClassType	*classPtr = GetWeaponF4CT(fccWeaponId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+504]
	push	ecx
	call	?GetWeaponF4CT@@YAPAUFalcon4EntityClassType@@H@Z ; GetWeaponF4CT
	add	esp, 4
	mov	DWORD PTR _classPtr$1[ebp], eax

; 2463 : 
; 2464 : 			if(classPtr)

	cmp	DWORD PTR _classPtr$1[ebp], 0
	je	$LN13@UpdateWeap

; 2465 : 			{
; 2466 : 				if (
; 2467 : 					classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_MISSILE || 
; 2468 : 					classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_ROCKET
; 2469 : 				){

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 6
	je	SHORT $LN11@UpdateWeap
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 8
	jne	SHORT $LN12@UpdateWeap
$LN11@UpdateWeap:

; 2470 : 					fccWeaponPtr.reset(InitAMissile(Sms->Ownship(), fccWeaponId, 0));

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	push	eax
	call	?InitAMissile@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z ; InitAMissile
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 2471 : 				}
; 2472 : 				else {

	jmp	$LN13@UpdateWeap
$LN12@UpdateWeap:

; 2473 : 					if (
; 2474 : 						classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BOMB ||
; 2475 : 						(
; 2476 : 							classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_ELECTRONICS && 
; 2477 : 							classPtr->vuClassData.classInfo_[VU_CLASS] == CLASS_VEHICLE
; 2478 : 						) ||
; 2479 : 						(
; 2480 : 							classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_FUEL_TANK	&& 
; 2481 : 							classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_FUEL_TANK
; 2482 : 						) ||
; 2483 : 						(
; 2484 : 							classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_RECON	&& 
; 2485 : 							classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_CAMERA
; 2486 : 						) ||
; 2487 : 						(
; 2488 : 							classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_LAUNCHER &&
; 2489 : 							classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_ROCKET
; 2490 : 						) 
; 2491 : 					){

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	je	$LN8@UpdateWeap
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 3
	jne	SHORT $LN7@UpdateWeap
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 7
	je	SHORT $LN8@UpdateWeap
$LN7@UpdateWeap:
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 4
	jne	SHORT $LN6@UpdateWeap
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 1
	je	SHORT $LN8@UpdateWeap
$LN6@UpdateWeap:
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 7
	jne	SHORT $LN5@UpdateWeap
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 1
	je	SHORT $LN8@UpdateWeap
$LN5@UpdateWeap:
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 5
	jne	SHORT $LN13@UpdateWeap
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _classPtr$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	jne	SHORT $LN13@UpdateWeap
$LN8@UpdateWeap:

; 2492 : 						fccWeaponPtr.reset(InitABomb(Sms->Ownship(), fccWeaponId, 0));

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	push	eax
	call	?InitABomb@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z ; InitABomb
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset
$LN13@UpdateWeap:

; 2493 : 					}
; 2494 : 				}
; 2495 : 			}
; 2496 : 
; 2497 : 			if (fccWeaponPtr && fccWeaponPtr->IsLauncher()){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	$LN16@UpdateWeap
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv228[ebp], eax
	mov	eax, DWORD PTR tv228[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv228[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
	test	eax, eax
	je	SHORT $LN16@UpdateWeap

; 2498 : 				wid = ((BombClass *)fccWeaponPtr.get())->LauGetWeaponId();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	ecx, eax
	call	?LauGetWeaponId@BombClass@@QAEHXZ	; BombClass::LauGetWeaponId
	mov	DWORD PTR _wid$[ebp], eax

; 2499 : 				if(wid != rocketWeaponId){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _wid$[ebp]
	cmp	edx, DWORD PTR [ecx+516]
	je	SHORT $LN16@UpdateWeap

; 2500 : 					if(wid){

	cmp	DWORD PTR _wid$[ebp], 0
	je	SHORT $LN2@UpdateWeap

; 2501 : 						rocketPointer.reset((MissileClass *)InitAMissile(Sms->Ownship(), wid, 0));

	push	0
	movzx	eax, WORD PTR _wid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	push	eax
	call	?InitAMissile@@YAPAVSimWeaponClass@@PAVFalconEntity@@GH@Z ; InitAMissile
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 512				; 00000200H
	call	?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ; VuBin<MissileClass>::reset

; 2502 : 					}
; 2503 : 					else{

	jmp	SHORT $LN1@UpdateWeap
$LN2@UpdateWeap:

; 2504 : 						rocketPointer.reset(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 512				; 00000200H
	call	?reset@?$VuBin@VMissileClass@@@@QAEXPAVMissileClass@@@Z ; VuBin<MissileClass>::reset
$LN1@UpdateWeap:

; 2505 : 					}
; 2506 : 					rocketWeaponId = wid;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _wid$[ebp]
	mov	DWORD PTR [edx+516], eax
$LN16@UpdateWeap:

; 2507 : 				}
; 2508 : 			}
; 2509 : 		}
; 2510 : 	}
; 2511 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateWeaponPtr@FireControlComputer@@AAEXXZ ENDP	; FireControlComputer::UpdateWeaponPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_currMissile$1 = -8					; size = 4
_this$ = -4						; size = 4
?AllowMaddog@FireControlComputer@@QAE_NXZ PROC		; FireControlComputer::AllowMaddog
; _this$ = ecx

; 2592 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2593 : 	if ( Sms && Sms->GetCurrentWeaponType() == wtAim120 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+408], 0
	je	SHORT $LN2@AllowMaddo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?GetCurrentWeaponType@SMSBaseClass@@QAE?AW4WeaponType@@XZ ; SMSBaseClass::GetCurrentWeaponType
	cmp	eax, 2
	jne	SHORT $LN2@AllowMaddo

; 2594 : 	{
; 2595 : 		MissileClass* currMissile = (MissileClass*)Sms->GetCurrentWeapon();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _currMissile$1[ebp], eax

; 2596 : 		if ( !targetPtr && currMissile && currMissile->isSlave )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	jne	SHORT $LN2@AllowMaddo
	cmp	DWORD PTR _currMissile$1[ebp], 0
	je	SHORT $LN2@AllowMaddo
	mov	edx, DWORD PTR _currMissile$1[ebp]
	cmp	DWORD PTR [edx+736], 0
	je	SHORT $LN2@AllowMaddo

; 2597 : 		{
; 2598 : 			return false;

	xor	al, al
	jmp	SHORT $LN3@AllowMaddo
$LN2@AllowMaddo:

; 2599 : 		}
; 2600 : 	}
; 2601 : 
; 2602 : 	return true;	

	mov	al, 1
$LN3@AllowMaddo:

; 2603 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AllowMaddog@FireControlComputer@@QAE_NXZ ENDP		; FireControlComputer::AllowMaddog
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?ToggleAGGunMode@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::ToggleAGGunMode
; _this$ = ecx

; 2444 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2445 : 	inAGGunMode = !inAGGunMode;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	jne	SHORT $LN3@ToggleAGGu
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@ToggleAGGu
$LN3@ToggleAGGu:
	mov	DWORD PTR tv68[ebp], 0
$LN4@ToggleAGGu:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv68[ebp]
	mov	BYTE PTR [edx+69], al

; 2446 : 	EnterAGMasterMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnterAGMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAGMasterMode

; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGGunMode@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::ToggleAGGunMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?ToggleAAGunMode@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::ToggleAAGunMode
; _this$ = ecx

; 2438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2439 : 	inAAGunMode = !inAAGunMode;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	test	ecx, ecx
	jne	SHORT $LN3@ToggleAAGu
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@ToggleAAGu
$LN3@ToggleAAGu:
	mov	DWORD PTR tv68[ebp], 0
$LN4@ToggleAAGu:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv68[ebp]
	mov	BYTE PTR [edx+68], al

; 2440 : 	EnterAAMasterMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnterAAMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAAMasterMode

; 2441 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAAGunMode@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::ToggleAAGunMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnterDogfightMode@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::EnterDogfightMode
; _this$ = ecx

; 2430 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2431 : 	Sms->SetCurrentHardPoint(lastDogfightHp);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z	; SMSClass::SetCurrentHardPoint

; 2432 : 	SetMasterMode(Dogfight);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2433 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EnterDogfightMode@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::EnterDogfightMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnterMissileOverrideMode@FireControlComputer@@QAEXXZ PROC ; FireControlComputer::EnterMissileOverrideMode
; _this$ = ecx

; 2424 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2425 : 	Sms->SetCurrentHardPoint(lastMissileOverrideHp);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z	; SMSClass::SetCurrentHardPoint

; 2426 : 	SetMasterMode(MissileOverride);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2427 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EnterMissileOverrideMode@FireControlComputer@@QAEXXZ ENDP ; FireControlComputer::EnterMissileOverrideMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnterAGMasterMode@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::EnterAGMasterMode
; _this$ = ecx

; 2410 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2411 : 	if(inAGGunMode)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+69]
	test	ecx, ecx
	je	SHORT $LN3@EnterAGMas

; 2412 : 	{   // go to gun mode
; 2413 : 		if( Sms->FindWeaponClass(wcGunWpn, TRUE) )

	push	1
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
	test	eax, eax
	je	SHORT $LN2@EnterAGMas

; 2414 : 			SetMasterMode(AGGun);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN2@EnterAGMas:

; 2415 : 	}
; 2416 : 	else

	jmp	SHORT $LN4@EnterAGMas
$LN3@EnterAGMas:

; 2417 : 	{
; 2418 : 		Sms->SetCurrentHardPoint(lastAirGroundHp);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z	; SMSClass::SetCurrentHardPoint

; 2419 : 		SetMasterMode(lastAgMasterMode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN4@EnterAGMas:

; 2420 : 	}
; 2421 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EnterAGMasterMode@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::EnterAGMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnterAAMasterMode@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::EnterAAMasterMode
; _this$ = ecx

; 2395 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2396 : 	if(inAAGunMode)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+68]
	test	ecx, ecx
	je	SHORT $LN3@EnterAAMas

; 2397 : 	{	// go to gun mode
; 2398 : 		if( Sms->FindWeaponClass(wcGunWpn, TRUE) )

	push	1
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
	test	eax, eax
	je	SHORT $LN2@EnterAAMas

; 2399 : 			SetMasterMode(AAGun);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN2@EnterAAMas:

; 2400 : 	}
; 2401 : 	else

	jmp	SHORT $LN4@EnterAAMas
$LN3@EnterAAMas:

; 2402 : 	{	
; 2403 : 		Sms->SetCurrentHardPoint(lastAirAirHp);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z	; SMSClass::SetCurrentHardPoint

; 2404 : 		//SetMasterMode(lastAaMasterMode);
; 2405 : 		SetMasterMode(Missile);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN4@EnterAAMas:

; 2406 : 	}
; 2407 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EnterAAMasterMode@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::EnterAAMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsInAGMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsInAGMasterMode
; _this$ = ecx

; 2390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2391 : 	return(GetMainMasterMode()==MM_AG);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	test	eax, eax
	jne	SHORT $LN3@IsInAGMast
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsInAGMast
$LN3@IsInAGMast:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsInAGMast:
	mov	eax, DWORD PTR tv67[ebp]

; 2392 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsInAGMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsInAGMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsInAAMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsInAAMasterMode
; _this$ = ecx

; 2385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2386 : 	return(GetMainMasterMode()==MM_AA);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 1
	jne	SHORT $LN3@IsInAAMast
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsInAAMast
$LN3@IsInAAMast:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsInAAMast:
	mov	eax, DWORD PTR tv67[ebp]

; 2387 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsInAAMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsInAAMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv154 = -16						; size = 4
tv158 = -12						; size = 4
_newmode$ = -8						; size = 4
_this$ = -4						; size = 4
?SetAGMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ PROC ; FireControlComputer::SetAGMasterModeForCurrentWeapon
; _this$ = ecx

; 2322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2323 : 	if(Sms->GetCurrentWeaponHardpoint() == -1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	cmp	eax, -1
	jne	SHORT $LN14@SetAGMaste

; 2324 : 	{	// maybe we've jetted the weapons, and the Sms curHardpoint is -1
; 2325 : 		// anyhow, find what we were using before
; 2326 : 		Sms->SetCurrentHardPoint(lastAirGroundHp,1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z	; SMSClass::SetCurrentHardPoint
$LN14@SetAGMaste:

; 2327 : 	}
; 2328 : 
; 2329 : 	//UpdateWeaponPtr();
; 2330 : 
; 2331 : 	if( Sms->CurHardpoint()<0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jge	SHORT $LN13@SetAGMaste

; 2332 : 	{ // whoops
; 2333 : 		return;

	jmp	$LN15@SetAGMaste

; 2334 : 	}
; 2335 : 	else

	jmp	SHORT $LN12@SetAGMaste
$LN13@SetAGMaste:

; 2336 : 		if(!Sms->hardPoint[Sms->CurHardpoint()])

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR [esi+4]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN12@SetAGMaste

; 2337 : 			return;

	jmp	$LN15@SetAGMaste
$LN12@SetAGMaste:

; 2338 : 
; 2339 : 	FCCMasterMode newmode = masterMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _newmode$[ebp], eax

; 2340 : 
; 2341 : 	inAGGunMode = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+69], 0

; 2342 : 
; 2343 : 	switch(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponClass())

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv154[ebp], edx
	mov	eax, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR tv158[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv158[ebp], ecx
	cmp	DWORD PTR tv158[ebp], 9
	ja	SHORT $LN1@SetAGMaste
	mov	edx, DWORD PTR tv158[ebp]
	jmp	DWORD PTR $LN17@SetAGMaste[edx*4]
$LN8@SetAGMaste:

; 2344 : 	{
; 2345 : 	case wcRocketWpn:
; 2346 : 		newmode = AirGroundRocket;

	mov	DWORD PTR _newmode$[ebp], 13		; 0000000dH

; 2347 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN7@SetAGMaste:

; 2348 : 	case wcBombWpn:
; 2349 : 		newmode = AirGroundBomb;

	mov	DWORD PTR _newmode$[ebp], 5

; 2350 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN6@SetAGMaste:

; 2351 : 	case wcGunWpn:
; 2352 : 		inAGGunMode = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+69], 1

; 2353 : 		newmode = AGGun;

	mov	DWORD PTR _newmode$[ebp], 1

; 2354 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN5@SetAGMaste:

; 2355 : 	case wcAgmWpn:
; 2356 : 		newmode = AirGroundMissile;

	mov	DWORD PTR _newmode$[ebp], 6

; 2357 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN4@SetAGMaste:

; 2358 : 	case wcHARMWpn:
; 2359 : 		newmode = AirGroundHARM;

	mov	DWORD PTR _newmode$[ebp], 7

; 2360 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN3@SetAGMaste:

; 2361 : 	case wcGbuWpn:
; 2362 : 		newmode = AirGroundLaser;

	mov	DWORD PTR _newmode$[ebp], 8

; 2363 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN2@SetAGMaste:

; 2364 : 	case wcCamera:
; 2365 : 		newmode = AirGroundCamera;

	mov	DWORD PTR _newmode$[ebp], 11		; 0000000bH

; 2366 : 		break;

	jmp	SHORT $LN9@SetAGMaste
$LN1@SetAGMaste:

; 2367 : 	default:
; 2368 : 		newmode = AirGroundBomb;

	mov	DWORD PTR _newmode$[ebp], 5
$LN9@SetAGMaste:

; 2369 : 	/*
; 2370 : 	case wcSamWpn:
; 2371 : 		break;
; 2372 : 	case wcNoWpn:
; 2373 : 		break;
; 2374 : 	case wcECM:
; 2375 : 		break;
; 2376 : 	case wcTank:
; 2377 : 		break;
; 2378 : 		*/
; 2379 : 	}
; 2380 : 	SetMasterMode(newmode);

	mov	ecx, DWORD PTR _newmode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN15@SetAGMaste:

; 2381 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@SetAGMaste:
	DD	$LN8@SetAGMaste
	DD	$LN7@SetAGMaste
	DD	$LN6@SetAGMaste
	DD	$LN1@SetAGMaste
	DD	$LN1@SetAGMaste
	DD	$LN5@SetAGMaste
	DD	$LN4@SetAGMaste
	DD	$LN1@SetAGMaste
	DD	$LN3@SetAGMaste
	DD	$LN2@SetAGMaste
?SetAGMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ ENDP ; FireControlComputer::SetAGMasterModeForCurrentWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv81 = -12						; size = 4
_newmode$ = -8						; size = 4
_this$ = -4						; size = 4
?SetAAMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ PROC ; FireControlComputer::SetAAMasterModeForCurrentWeapon
; _this$ = ecx

; 2295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2296 : 	//UpdateWeaponPtr();
; 2297 : 	
; 2298 : 	FCCMasterMode newmode = masterMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _newmode$[ebp], ecx

; 2299 : 
; 2300 : 	if(Sms->GetCurrentWeaponHardpoint() == -1)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	cmp	eax, -1
	jne	SHORT $LN5@SetAAMaste

; 2301 : 	{	// maybe we've jetted the weapons, and the Sms curHardpoint is -1
; 2302 : 		// anyhow, find what we were using before
; 2303 : 		Sms->SetCurrentHardPoint(lastAirAirHp,1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetCurrentHardPoint@SMSClass@@QAEHHH@Z	; SMSClass::SetCurrentHardPoint
$LN5@SetAAMaste:

; 2304 : 	}
; 2305 : 
; 2306 : 	inAAGunMode = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+68], 0

; 2307 : 
; 2308 : 	switch(Sms->curWeaponClass)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN2@SetAAMaste
	cmp	DWORD PTR tv81[ebp], 3
	je	SHORT $LN1@SetAAMaste
	jmp	SHORT $LN3@SetAAMaste
$LN2@SetAAMaste:

; 2309 : 	{
; 2310 : 	case wcAimWpn:
; 2311 : 		newmode = Missile;

	mov	DWORD PTR _newmode$[ebp], 2

; 2312 : 		break;

	jmp	SHORT $LN3@SetAAMaste
$LN1@SetAAMaste:

; 2313 : 	case wcGunWpn:
; 2314 : 		inAAGunMode = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+68], 1

; 2315 : 		newmode = AAGun;

	mov	DWORD PTR _newmode$[ebp], 0
$LN3@SetAAMaste:

; 2316 : 		break;
; 2317 : 	}
; 2318 : 	SetMasterMode(newmode);

	mov	edx, DWORD PTR _newmode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 2319 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetAAMasterModeForCurrentWeapon@FireControlComputer@@QAEXXZ ENDP ; FireControlComputer::SetAAMasterModeForCurrentWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
_wc$ = 8						; size = 4
?CanStepToWeaponClass@FireControlComputer@@QAEHW4WeaponClass@@@Z PROC ; FireControlComputer::CanStepToWeaponClass
; _this$ = ecx

; 2219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2220 : 	switch(masterMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 13			; 0000000dH
	ja	$LN18@CanStepToW
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN22@CanStepToW[edx]
	jmp	DWORD PTR $LN23@CanStepToW[eax*4]
$LN17@CanStepToW:

; 2221 : 	{
; 2222 : 	case AAGun:
; 2223 : 		if( ( wc==wcAimWpn && g_bWeaponStepToGun) || 
; 2224 : 			  wc==wcGunWpn )				

	cmp	DWORD PTR _wc$[ebp], 0
	jne	SHORT $LN14@CanStepToW
	movzx	ecx, BYTE PTR ?g_bWeaponStepToGun@@3_NA	; g_bWeaponStepToGun
	test	ecx, ecx
	jne	SHORT $LN15@CanStepToW
$LN14@CanStepToW:
	cmp	DWORD PTR _wc$[ebp], 3
	jne	SHORT $LN16@CanStepToW
$LN15@CanStepToW:

; 2225 : 			return 1;			

	mov	eax, 1
	jmp	$LN20@CanStepToW
$LN16@CanStepToW:

; 2226 : 		return 0;

	xor	eax, eax
	jmp	$LN20@CanStepToW
$LN13@CanStepToW:

; 2227 : 
; 2228 : 	case Missile:
; 2229 : 		if( wc==wcAimWpn || 
; 2230 : 			(wc==wcGunWpn && g_bWeaponStepToGun) )				

	cmp	DWORD PTR _wc$[ebp], 0
	je	SHORT $LN11@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 3
	jne	SHORT $LN12@CanStepToW
	movzx	edx, BYTE PTR ?g_bWeaponStepToGun@@3_NA	; g_bWeaponStepToGun
	test	edx, edx
	je	SHORT $LN12@CanStepToW
$LN11@CanStepToW:

; 2231 : 			return 1;			

	mov	eax, 1
	jmp	$LN20@CanStepToW
$LN12@CanStepToW:

; 2232 : 		return 0;

	xor	eax, eax
	jmp	$LN20@CanStepToW
$LN10@CanStepToW:

; 2233 : 
; 2234 : 	case MissileOverride:
; 2235 : 	case Dogfight:
; 2236 : 		if(wc==wcAimWpn )

	cmp	DWORD PTR _wc$[ebp], 0
	jne	SHORT $LN9@CanStepToW

; 2237 : 			return 1;

	mov	eax, 1
	jmp	$LN20@CanStepToW
$LN9@CanStepToW:

; 2238 : 		return 0;

	xor	eax, eax
	jmp	$LN20@CanStepToW
$LN8@CanStepToW:

; 2239 : 
; 2240 : 	case AGGun:
; 2241 : 		if( ( ( wc==wcAgmWpn	|| wc==wcBombWpn || 
; 2242 : 			    wc==wcRocketWpn || wc==wcHARMWpn || 
; 2243 : 			    wc==wcGbuWpn	|| wc==wcCamera ) && g_bWeaponStepToGun) ||
; 2244 : 			wc==wcGunWpn )				

	cmp	DWORD PTR _wc$[ebp], 6
	je	SHORT $LN4@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 2
	je	SHORT $LN4@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 1
	je	SHORT $LN4@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 7
	je	SHORT $LN4@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 9
	je	SHORT $LN4@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 10			; 0000000aH
	jne	SHORT $LN5@CanStepToW
$LN4@CanStepToW:
	movzx	eax, BYTE PTR ?g_bWeaponStepToGun@@3_NA	; g_bWeaponStepToGun
	test	eax, eax
	jne	SHORT $LN6@CanStepToW
$LN5@CanStepToW:
	cmp	DWORD PTR _wc$[ebp], 3
	jne	SHORT $LN7@CanStepToW
$LN6@CanStepToW:

; 2245 : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN20@CanStepToW
$LN7@CanStepToW:

; 2246 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN20@CanStepToW
$LN3@CanStepToW:

; 2247 : 
; 2248 :     case AirGroundBomb:
; 2249 : 	case AirGroundRocket:
; 2250 :     case AirGroundMissile:
; 2251 :     case AirGroundHARM:
; 2252 :     case AirGroundLaser:
; 2253 :     case AirGroundCamera:
; 2254 : 		if( wc==wcAgmWpn	|| wc==wcBombWpn || 
; 2255 : 			wc==wcRocketWpn || wc==wcHARMWpn || 
; 2256 : 			wc==wcGbuWpn	|| wc==wcCamera  ||
; 2257 : 			( wc==wcGunWpn && g_bWeaponStepToGun ) )				

	cmp	DWORD PTR _wc$[ebp], 6
	je	SHORT $LN1@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 2
	je	SHORT $LN1@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 1
	je	SHORT $LN1@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 7
	je	SHORT $LN1@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 9
	je	SHORT $LN1@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 10			; 0000000aH
	je	SHORT $LN1@CanStepToW
	cmp	DWORD PTR _wc$[ebp], 3
	jne	SHORT $LN2@CanStepToW
	movzx	ecx, BYTE PTR ?g_bWeaponStepToGun@@3_NA	; g_bWeaponStepToGun
	test	ecx, ecx
	je	SHORT $LN2@CanStepToW
$LN1@CanStepToW:

; 2258 : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN20@CanStepToW
$LN2@CanStepToW:

; 2259 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN20@CanStepToW
$LN18@CanStepToW:

; 2260 : 	}
; 2261 : 	return 0;

	xor	eax, eax
$LN20@CanStepToW:

; 2262 : 
; 2263 : 	/*
; 2264 : 		switch(GetMainMasterMode())
; 2265 : 	{
; 2266 : 	case MM_AA:
; 2267 : 		if(g_bWeaponStepToGun)
; 2268 : 		{
; 2269 : 			if( wc==wcAimWpn || wc==wcGunWpn )				
; 2270 : 				return 1;
; 2271 : 		}
; 2272 : 		else
; 2273 : 		{
; 2274 : 
; 2275 : 		}
; 2276 : 		return 0;
; 2277 : 	case MM_DGFT:
; 2278 : 	case MM_MSL:
; 2279 : 		if(wc==wcAimWpn )
; 2280 : 			return 1;
; 2281 : 		return 0;
; 2282 : 	case MM_AG:
; 2283 : 		if( wc==wcAgmWpn	|| wc==wcBombWpn || 
; 2284 : 			wc==wcRocketWpn || wc==wcHARMWpn || 
; 2285 : 			wc==wcGbuWpn	|| wc==wcCamera  ||
; 2286 : 			( wc==wcGunWpn && g_bWeaponStepToGun ) )				
; 2287 : 				return 1;
; 2288 : 		return 0;
; 2289 : 	}
; 2290 : 	return 0;
; 2291 : 	*/
; 2292 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN23@CanStepToW:
	DD	$LN17@CanStepToW
	DD	$LN8@CanStepToW
	DD	$LN13@CanStepToW
	DD	$LN3@CanStepToW
	DD	$LN10@CanStepToW
	DD	$LN18@CanStepToW
$LN22@CanStepToW:
	DB	0
	DB	1
	DB	2
	DB	5
	DB	5
	DB	3
	DB	3
	DB	3
	DB	3
	DB	4
	DB	4
	DB	3
	DB	5
	DB	3
?CanStepToWeaponClass@FireControlComputer@@QAEHW4WeaponClass@@@Z ENDP ; FireControlComputer::CanStepToWeaponClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
_wc$ = 8						; size = 4
?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z PROC ; FireControlComputer::WeaponClassMatchesMaster
; _this$ = ecx

; 2160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2161 : 	switch(masterMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 13			; 0000000dH
	ja	$LN20@WeaponClas
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN24@WeaponClas[edx*4]
$LN19@WeaponClas:

; 2162 : 	{
; 2163 : 	case Missile:
; 2164 : 		if(wc==wcAimWpn || wc==wcGunWpn)

	cmp	DWORD PTR _wc$[ebp], 0
	je	SHORT $LN17@WeaponClas
	cmp	DWORD PTR _wc$[ebp], 3
	jne	SHORT $LN18@WeaponClas
$LN17@WeaponClas:

; 2165 : 			return 1;

	mov	eax, 1
	jmp	$LN22@WeaponClas
$LN18@WeaponClas:

; 2166 : 		return 0;

	xor	eax, eax
	jmp	$LN22@WeaponClas
$LN16@WeaponClas:

; 2167 : 	case Dogfight:
; 2168 : 	case MissileOverride:
; 2169 : 		if(wc==wcAimWpn )

	cmp	DWORD PTR _wc$[ebp], 0
	jne	SHORT $LN15@WeaponClas

; 2170 : 			return 1;

	mov	eax, 1
	jmp	$LN22@WeaponClas
$LN15@WeaponClas:

; 2171 : 		return 0;

	xor	eax, eax
	jmp	$LN22@WeaponClas
$LN14@WeaponClas:

; 2172 : 	case AAGun:
; 2173 : 	case AGGun:
; 2174 : 		if(wc==wcGunWpn)

	cmp	DWORD PTR _wc$[ebp], 3
	jne	SHORT $LN13@WeaponClas

; 2175 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN13@WeaponClas:

; 2176 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas
$LN12@WeaponClas:

; 2177 : 	case AirGroundMissile:
; 2178 : 		if(wc==wcAgmWpn)

	cmp	DWORD PTR _wc$[ebp], 6
	jne	SHORT $LN11@WeaponClas

; 2179 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN11@WeaponClas:

; 2180 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas

; 2181 : 		break;

	jmp	SHORT $LN20@WeaponClas
$LN10@WeaponClas:

; 2182 : 	case AirGroundBomb:
; 2183 : 		if(wc==wcBombWpn)// || wc==wcRocketWpn)

	cmp	DWORD PTR _wc$[ebp], 2
	jne	SHORT $LN9@WeaponClas

; 2184 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN9@WeaponClas:

; 2185 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas

; 2186 : 		break;

	jmp	SHORT $LN20@WeaponClas
$LN8@WeaponClas:

; 2187 : 	case AirGroundRocket:
; 2188 : 		if(wc==wcRocketWpn)// || wc==wcRocketWpn)

	cmp	DWORD PTR _wc$[ebp], 1
	jne	SHORT $LN7@WeaponClas

; 2189 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN7@WeaponClas:

; 2190 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas

; 2191 : 		break;

	jmp	SHORT $LN20@WeaponClas
$LN6@WeaponClas:

; 2192 : 	case AirGroundHARM:
; 2193 : 		if(wc==wcHARMWpn)

	cmp	DWORD PTR _wc$[ebp], 7
	jne	SHORT $LN5@WeaponClas

; 2194 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN5@WeaponClas:

; 2195 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas

; 2196 : 		break;

	jmp	SHORT $LN20@WeaponClas
$LN4@WeaponClas:

; 2197 : 	case AirGroundLaser:
; 2198 : 		if(wc==wcGbuWpn)

	cmp	DWORD PTR _wc$[ebp], 9
	jne	SHORT $LN3@WeaponClas

; 2199 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN3@WeaponClas:

; 2200 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas

; 2201 : 		break;

	jmp	SHORT $LN20@WeaponClas
$LN2@WeaponClas:

; 2202 : 	case AirGroundCamera:
; 2203 : 		if(wc==wcCamera)

	cmp	DWORD PTR _wc$[ebp], 10			; 0000000aH
	jne	SHORT $LN1@WeaponClas

; 2204 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN22@WeaponClas
$LN1@WeaponClas:

; 2205 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN22@WeaponClas
$LN20@WeaponClas:

; 2206 : 		break;
; 2207 : 		/*
; 2208 : 	case ClearOveride:
; 2209 : 		if(wc==)
; 2210 : 			return 1;
; 2211 : 		return 0;
; 2212 : 		break;
; 2213 : 	*/
; 2214 : 	}
; 2215 : 	return 0;

	xor	eax, eax
$LN22@WeaponClas:

; 2216 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN24@WeaponClas:
	DD	$LN14@WeaponClas
	DD	$LN14@WeaponClas
	DD	$LN19@WeaponClas
	DD	$LN20@WeaponClas
	DD	$LN20@WeaponClas
	DD	$LN10@WeaponClas
	DD	$LN12@WeaponClas
	DD	$LN6@WeaponClas
	DD	$LN4@WeaponClas
	DD	$LN16@WeaponClas
	DD	$LN16@WeaponClas
	DD	$LN2@WeaponClas
	DD	$LN20@WeaponClas
	DD	$LN8@WeaponClas
?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ENDP ; FireControlComputer::WeaponClassMatchesMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T1 = -20						; size = 4
_this$ = -16						; size = 4
$T2 = -12						; size = 4
_gp$3 = -8						; size = 4
_gpp$ = -4						; size = 4
?PruneList@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::PruneList
; _this$ = ecx

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1401 :     GroundListElement  **gpp;
; 1402 : 
; 1403 :     for (gpp = &grndlist; *gpp; ) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 412				; 0000019cH
	mov	DWORD PTR _gpp$[ebp], eax
$LN4@PruneList:
	mov	ecx, DWORD PTR _gpp$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN5@PruneList

; 1404 : 	if ((*gpp)->BaseObject() == NULL) { // delete this one

	mov	edx, DWORD PTR _gpp$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	test	eax, eax
	jne	SHORT $LN2@PruneList

; 1405 : 	    GroundListElement *gp = *gpp;

	mov	eax, DWORD PTR _gpp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gp$3[ebp], ecx

; 1406 : 	    *gpp = gp -> next;

	mov	edx, DWORD PTR _gpp$[ebp]
	mov	eax, DWORD PTR _gp$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 1407 : 	    delete gp;

	mov	edx, DWORD PTR _gp$3[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN7@PruneList
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GGroundListElement@@QAEPAXI@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN8@PruneList
$LN7@PruneList:
	mov	DWORD PTR tv74[ebp], 0
$LN8@PruneList:

; 1408 : 	}
; 1409 : 	else gpp = &(*gpp)->next;

	jmp	SHORT $LN1@PruneList
$LN2@PruneList:
	mov	ecx, DWORD PTR _gpp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _gpp$[ebp], edx
$LN1@PruneList:

; 1410 :     }

	jmp	SHORT $LN4@PruneList
$LN5@PruneList:

; 1411 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PruneList@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::PruneList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv73 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_tmpElement$ = -8					; size = 4
_this$ = -4						; size = 4
?ClearPlanned@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::ClearPlanned
; _this$ = ecx

; 1453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
$LN2@ClearPlann:

; 1454 :     GroundListElement* tmpElement;
; 1455 :     
; 1456 :     while (grndlist)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+412], 0
	je	SHORT $LN3@ClearPlann

; 1457 :     {
; 1458 : 	tmpElement = grndlist;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+412]
	mov	DWORD PTR _tmpElement$[ebp], edx

; 1459 : 	grndlist = tmpElement->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpElement$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+412], edx

; 1460 : 	delete tmpElement;

	mov	eax, DWORD PTR _tmpElement$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@ClearPlann
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GGroundListElement@@QAEPAXI@Z
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN6@ClearPlann
$LN5@ClearPlann:
	mov	DWORD PTR tv73[ebp], 0
$LN6@ClearPlann:

; 1461 :     }

	jmp	SHORT $LN2@ClearPlann
$LN3@ClearPlann:

; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearPlanned@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::ClearPlanned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_new_myit$2 = -128					; size = 12
_myit$ = -116						; size = 12
$T3 = -104						; size = 4
$T4 = -100						; size = 4
tv501 = -96						; size = 4
_ex$5 = -92						; size = 4
_ey$6 = -88						; size = 4
_myx$7 = -84						; size = 4
_myy$8 = -80						; size = 4
tv472 = -76						; size = 4
tv394 = -72						; size = 4
$T9 = -68						; size = 4
_curElement$10 = -64					; size = 4
tv307 = -60						; size = 4
$T11 = -56						; size = 4
_nu$12 = -52						; size = 4
_jstarDetectionChance$ = -48				; size = 4
_theFlight$ = -44					; size = 4
_tmpElement$13 = -40					; size = 4
_jstar$ = -36						; size = 4
_tmpElement$14 = -32					; size = 4
_this$ = -28						; size = 4
_cf$15 = -24						; size = 4
_e$ = -20						; size = 4
_us$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
?UpdatePlanned@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::UpdatePlanned
; _this$ = ecx

; 1274 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdatePlanned@FireControlComputer@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1275 :     if (nextDlUpdate > SimLibElapsedTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+416]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jbe	SHORT $LN32@UpdatePlan

; 1276 : 	return;

	jmp	$LN33@UpdatePlan
$LN32@UpdatePlan:

; 1277 : 	//Cobra This function was killing SAMs and threat rings on HSD
; 1278 : 	//without it, everything is appearing as normal on the HSD.  
; 1279 :     nextDlUpdate = SimLibElapsedTime + 5000/*CampaignSeconds * DATALINK_CYCLE*/;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 5000				; 00001388H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+416], edx

; 1280 :     /*if (((AircraftClass*)platform)->mFaults->GetFault(FaultClass::dlnk_fault) ||
; 1281 : 	!((AircraftClass*)platform)->HasPower(AircraftClass::DLPower))
; 1282 : 	return;*/
; 1283 : 
; 1284 : 	// RV version
; 1285 : 	// nextDlUpdate = SimLibElapsedTime + CampaignSeconds * DATALINK_CYCLE;
; 1286 : 	//if (((AircraftClass*)platform)->mFaults->GetFault(FaultClass::dlnk_fault) || !((AircraftClass*)platform)->HasPower(AircraftClass::DLPower))
; 1287 : 	//	return;
; 1288 : 
; 1289 :   FlightClass* theFlight = (FlightClass*)(platform->GetCampaignObject());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _theFlight$[ebp], eax

; 1290 :   if (!theFlight)

	cmp	DWORD PTR _theFlight$[ebp], 0
	jne	SHORT $LN31@UpdatePlan

; 1291 : 	return;

	jmp	$LN33@UpdatePlan
$LN31@UpdatePlan:

; 1292 : 
; 1293 :   CampEntity		e;
; 1294 : 	VuListIterator myit(EmitterList);

	mov	edx, DWORD PTR ?EmitterList@@3PAVFalconPrivateList@@A ; EmitterList
	push	edx
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1295 : 
; 1296 :   // see if we have a jstar.
; 1297 :   Flight jstar = theFlight->GetJSTARFlight();

	mov	ecx, DWORD PTR _theFlight$[ebp]
	call	?GetJSTARFlight@FlightClass@@QAEPAV1@XZ	; FlightClass::GetJSTARFlight
	mov	DWORD PTR _jstar$[ebp], eax

; 1298 : 
; 1299 : 	Team us = theFlight->GetTeam();

	mov	eax, DWORD PTR _theFlight$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theFlight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _us$[ebp], al

; 1300 : 
; 1301 : 	// If we didn't find JSTAR do other search
; 1302 : 	if (!jstar) {

	cmp	DWORD PTR _jstar$[ebp], 0
	jne	$LN30@UpdatePlan

; 1303 : 		Unit nu, cf;
; 1304 : 		VuListIterator new_myit(AllAirList);

	mov	ecx, DWORD PTR ?AllAirList@@3PAVVuLinkedList@@A ; AllAirList
	push	ecx
	lea	ecx, DWORD PTR _new_myit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1305 : 		nu = (Unit) new_myit.GetFirst();

	lea	ecx, DWORD PTR _new_myit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _nu$12[ebp], eax
$LN43@UpdatePlan:

; 1306 : 		while (nu && !jstar) {

	cmp	DWORD PTR _nu$12[ebp], 0
	je	$LN28@UpdatePlan
	cmp	DWORD PTR _jstar$[ebp], 0
	jne	$LN28@UpdatePlan

; 1307 : 			cf = nu;

	mov	edx, DWORD PTR _nu$12[ebp]
	mov	DWORD PTR _cf$15[ebp], edx

; 1308 : 			nu = (Unit) new_myit.GetNext();

	lea	ecx, DWORD PTR _new_myit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _nu$12[ebp], eax

; 1309 : 			if (!cf->IsFlight() || cf->IsDead())

	mov	eax, DWORD PTR _cf$15[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN26@UpdatePlan
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	je	SHORT $LN27@UpdatePlan
$LN26@UpdatePlan:

; 1310 : 				continue;

	jmp	SHORT $LN43@UpdatePlan
$LN27@UpdatePlan:

; 1311 : 
; 1312 : 			if (cf->GetUnitMission() == AMIS_JSTAR && cf->GetTeam() == us && cf->GetUnitTOT()+5*CampaignMinutes < Camp_GetCurrentTime() && cf->GetUnitTOT()+95*CampaignMinutes > Camp_GetCurrentTime()) {

	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 27					; 0000001bH
	jne	$LN24@UpdatePlan
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _us$[ebp]
	cmp	ecx, edx
	jne	$LN24@UpdatePlan
	mov	eax, DWORD PTR _cf$15[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	eax, DWORD PTR [edx+692]
	call	eax
	mov	esi, eax
	add	esi, 300000				; 000493e0H
	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	cmp	esi, eax
	jae	$LN24@UpdatePlan
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cf$15[ebp]
	mov	eax, DWORD PTR [edx+692]
	call	eax
	mov	esi, eax
	add	esi, 5700000				; 0056f9a0H
	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	cmp	esi, eax
	jbe	SHORT $LN24@UpdatePlan

; 1313 :     			// Check if JSTAR is in range for communication
; 1314 : 				if (Distance(platform->XPos(), platform->YPos(), cf->XPos(), cf->YPos()) * FT_TO_NM <= 250.0f) {

	mov	ecx, DWORD PTR _cf$15[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _cf$15[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Distance@@YAMMMMM@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv472[ebp]
	movss	xmm0, DWORD PTR tv472[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	xmm1, DWORD PTR __real@437a0000
	comiss	xmm1, xmm0
	jb	SHORT $LN24@UpdatePlan

; 1315 : 					jstar = (Flight)cf;

	mov	eax, DWORD PTR _cf$15[ebp]
	mov	DWORD PTR _jstar$[ebp], eax
$LN24@UpdatePlan:

; 1316 : 				}
; 1317 : 			}
; 1318 : 		}

	jmp	$LN43@UpdatePlan
$LN28@UpdatePlan:

; 1319 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _new_myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN30@UpdatePlan:

; 1320 : 
; 1321 : 	if ((!jstar)||(!g_bUseRC135))

	cmp	DWORD PTR _jstar$[ebp], 0
	je	SHORT $LN22@UpdatePlan
	movzx	ecx, BYTE PTR ?g_bUseRC135@@3_NA	; g_bUseRC135
	test	ecx, ecx
	jne	$LN23@UpdatePlan
$LN22@UpdatePlan:

; 1322 : 	{
; 1323 : 
; 1324 : 		// completely new list please
; 1325 : 		//cobra added here
; 1326 : 		float myx = platform->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _myx$7[ebp]

; 1327 : 		float myy = platform->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _myy$8[ebp]

; 1328 : 		ClearPlanned();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPlanned@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearPlanned

; 1329 : 
; 1330 : 		GroundListElement* tmpElement;
; 1331 : 		GroundListElement* curElement = NULL;

	mov	DWORD PTR _curElement$10[ebp], 0

; 1332 : 
; 1333 : 		for (e = (CampEntity) myit.GetFirst(); e; e = (Unit) myit.GetNext()) 

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _e$[ebp], eax
	jmp	SHORT $LN21@UpdatePlan
$LN20@UpdatePlan:
	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax
$LN21@UpdatePlan:
	cmp	DWORD PTR _e$[ebp], 0
	je	$LN19@UpdatePlan

; 1334 : 		{
; 1335 : 			if (e->GetTeam() != us /*&& e->GetSpotted(us) && 
; 1336 : 				(!e->IsUnit() || !((Unit)e)->Moving())  && e->GetElectronicDetectionRange(Air)*/)

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _us$[ebp]
	cmp	ecx, edx
	je	$LN17@UpdatePlan

; 1337 : 			{
; 1338 : 				float ex = e -> XPos();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _ex$5[ebp]

; 1339 : 				float ey = e -> YPos();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _ey$6[ebp]

; 1340 : 				if (Distance(ex,ey,myx,myy) * FT_TO_NM < 150/*EMITTERRANGE*/)

	push	ecx
	movss	xmm0, DWORD PTR _myy$8[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _myx$7[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ey$6[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ex$5[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?Distance@@YAMMMMM@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv501[ebp]
	movss	xmm0, DWORD PTR tv501[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	xmm1, DWORD PTR __real@43160000
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@UpdatePlan

; 1341 : 				{
; 1342 : 					tmpElement = new GroundListElement(e);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN35@UpdatePlan
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0GroundListElement@@QAE@PAVFalconEntity@@@Z ; GroundListElement::GroundListElement
	mov	DWORD PTR tv307[ebp], eax
	jmp	SHORT $LN36@UpdatePlan
$LN35@UpdatePlan:
	mov	DWORD PTR tv307[ebp], 0
$LN36@UpdatePlan:
	mov	ecx, DWORD PTR tv307[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _tmpElement$13[ebp], edx

; 1343 : 					tmpElement->SetFlag(GroundListElement::DataLink);//Cobra nothing is using this...

	push	1
	mov	ecx, DWORD PTR _tmpElement$13[ebp]
	call	?SetFlag@GroundListElement@@QAEXH@Z	; GroundListElement::SetFlag

; 1344 : 					tmpElement->SetFlag(GroundListElement::RangeRing);//Cobra set the ring???

	push	2
	mov	ecx, DWORD PTR _tmpElement$13[ebp]
	call	?SetFlag@GroundListElement@@QAEXH@Z	; GroundListElement::SetFlag

; 1345 : 					if (grndlist == NULL){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+412], 0
	jne	SHORT $LN16@UpdatePlan

; 1346 : 						grndlist = tmpElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpElement$13[ebp]
	mov	DWORD PTR [ecx+412], edx

; 1347 : 					}
; 1348 : 					else {

	jmp	SHORT $LN15@UpdatePlan
$LN16@UpdatePlan:

; 1349 : 						curElement->next = tmpElement;

	mov	eax, DWORD PTR _curElement$10[ebp]
	mov	ecx, DWORD PTR _tmpElement$13[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@UpdatePlan:

; 1350 : 					}
; 1351 : 					curElement = tmpElement;

	mov	edx, DWORD PTR _tmpElement$13[ebp]
	mov	DWORD PTR _curElement$10[ebp], edx
$LN17@UpdatePlan:

; 1352 : 				}
; 1353 : 			}
; 1354 : 		}

	jmp	$LN20@UpdatePlan
$LN19@UpdatePlan:

; 1355 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	jmp	$LN33@UpdatePlan
$LN23@UpdatePlan:

; 1356 :   }
; 1357 : 	//cobra added here
; 1358 : 
; 1359 : 	int jstarDetectionChance = 0;

	mov	DWORD PTR _jstarDetectionChance$[ebp], 0

; 1360 : 
; 1361 : 	if (jstar) {

	cmp	DWORD PTR _jstar$[ebp], 0
	je	SHORT $LN10@UpdatePlan

; 1362 : 		// This is a ELINT flight (e.g. RC-135)
; 1363 : 		if (jstar->class_data->Role == ROLE_ELINT)

	mov	eax, DWORD PTR _jstar$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movzx	edx, BYTE PTR [ecx+284]
	cmp	edx, 25					; 00000019H
	jne	SHORT $LN13@UpdatePlan

; 1364 : 			jstarDetectionChance = 75;

	mov	DWORD PTR _jstarDetectionChance$[ebp], 75 ; 0000004bH

; 1365 : 		else

	jmp	SHORT $LN10@UpdatePlan
$LN13@UpdatePlan:

; 1366 : 			// FRB - Give JSTAR SAM finder capabilities
; 1367 : 		if (!g_bUseRC135)

	movzx	eax, BYTE PTR ?g_bUseRC135@@3_NA	; g_bUseRC135
	test	eax, eax
	jne	SHORT $LN11@UpdatePlan

; 1368 : 			jstarDetectionChance = 75;

	mov	DWORD PTR _jstarDetectionChance$[ebp], 75 ; 0000004bH

; 1369 : 		else

	jmp	SHORT $LN10@UpdatePlan
$LN11@UpdatePlan:

; 1370 : 			jstarDetectionChance = 25;

	mov	DWORD PTR _jstarDetectionChance$[ebp], 25 ; 00000019H
$LN10@UpdatePlan:

; 1371 : 	}
; 1372 : 	
; 1373 : 	//CampEntity e;
; 1374 :  //   VuListIterator myit(EmitterList);
; 1375 : 
; 1376 : 	for (e = (CampEntity) myit.GetFirst(); e; e = (CampEntity) myit.GetNext()) 

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _e$[ebp], eax
	jmp	SHORT $LN9@UpdatePlan
$LN8@UpdatePlan:
	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax
$LN9@UpdatePlan:
	cmp	DWORD PTR _e$[ebp], 0
	je	$LN7@UpdatePlan

; 1377 : 	{
; 1378 : 		if (e->IsUnit() && e->IsBattalion() && rand()%100 > jstarDetectionChance)

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN6@UpdatePlan
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN6@UpdatePlan
	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, DWORD PTR _jstarDetectionChance$[ebp]
	jle	SHORT $LN6@UpdatePlan

; 1379 : 			continue;

	jmp	SHORT $LN8@UpdatePlan
$LN6@UpdatePlan:

; 1380 : 		
; 1381 : 		if (e->IsGroundVehicle()) {

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+196]
	call	edx
	test	eax, eax
	je	SHORT $LN1@UpdatePlan

; 1382 : 			GroundListElement* tmpElement = GetFirstGroundElement();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ; FireControlComputer::GetFirstGroundElement
	mov	DWORD PTR _tmpElement$14[ebp], eax
$LN4@UpdatePlan:

; 1383 : 	
; 1384 : 			while (tmpElement) {

	cmp	DWORD PTR _tmpElement$14[ebp], 0
	je	SHORT $LN3@UpdatePlan

; 1385 : 				if (tmpElement->BaseObject() == e)

	mov	ecx, DWORD PTR _tmpElement$14[ebp]
	call	?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ; GroundListElement::BaseObject
	cmp	eax, DWORD PTR _e$[ebp]
	jne	SHORT $LN2@UpdatePlan

; 1386 : 					break;

	jmp	SHORT $LN3@UpdatePlan
$LN2@UpdatePlan:

; 1387 : 				tmpElement = tmpElement->GetNext();

	mov	ecx, DWORD PTR _tmpElement$14[ebp]
	call	?GetNext@GroundListElement@@QAEPAV1@XZ	; GroundListElement::GetNext
	mov	DWORD PTR _tmpElement$14[ebp], eax

; 1388 : 			}

	jmp	SHORT $LN4@UpdatePlan
$LN3@UpdatePlan:

; 1389 : 
; 1390 : 			if (!tmpElement) {

	cmp	DWORD PTR _tmpElement$14[ebp], 0
	jne	SHORT $LN1@UpdatePlan

; 1391 : 				tmpElement = new GroundListElement(e);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN37@UpdatePlan
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0GroundListElement@@QAE@PAVFalconEntity@@@Z ; GroundListElement::GroundListElement
	mov	DWORD PTR tv394[ebp], eax
	jmp	SHORT $LN38@UpdatePlan
$LN37@UpdatePlan:
	mov	DWORD PTR tv394[ebp], 0
$LN38@UpdatePlan:
	mov	ecx, DWORD PTR tv394[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _tmpElement$14[ebp], edx

; 1392 : 				AddGroundElement(tmpElement);

	mov	eax, DWORD PTR _tmpElement$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddGroundElement@FireControlComputer@@QAEXPAVGroundListElement@@@Z ; FireControlComputer::AddGroundElement
$LN1@UpdatePlan:

; 1393 : 			}
; 1394 : 		}
; 1395 : 	}

	jmp	$LN8@UpdatePlan
$LN7@UpdatePlan:

; 1396 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN33@UpdatePlan:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$1:
	lea	ecx, DWORD PTR _new_myit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$2:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?UpdatePlanned@FireControlComputer@@QAEXXZ$3:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?UpdatePlanned@FireControlComputer@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdatePlanned@FireControlComputer@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdatePlanned@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::UpdatePlanned
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_elementWalker$2 = -72					; size = 12
tv169 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
_curElement$ = -48					; size = 4
tv144 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
_eHeader$ = -32						; size = 4
_tmpElement$ = -28					; size = 4
_theFlight$ = -24					; size = 4
_this$ = -20						; size = 4
_knownEmmitters$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?BuildPrePlanned@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::BuildPrePlanned
; _this$ = ecx

; 1238 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildPrePlanned@FireControlComputer@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1239 :     FlightClass* theFlight = (FlightClass*)(platform->GetCampaignObject());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _theFlight$[ebp], eax

; 1240 :     FalconPrivateList* knownEmmitters = NULL;

	mov	DWORD PTR _knownEmmitters$[ebp], 0

; 1241 :     GroundListElement* tmpElement;
; 1242 :     GroundListElement* curElement = NULL;

	mov	DWORD PTR _curElement$[ebp], 0

; 1243 :     FalconEntity* eHeader;
; 1244 :     
; 1245 :     // this is all based around waypoints.
; 1246 :     if (SimDriver.RunningCampaignOrTactical() && theFlight)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaignOrTactical
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@BuildPrePl
	cmp	DWORD PTR _theFlight$[ebp], 0
	je	SHORT $LN6@BuildPrePl

; 1247 : 			knownEmmitters = theFlight->GetKnownEmitters();

	mov	edx, DWORD PTR _theFlight$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theFlight$[ebp]
	mov	edx, DWORD PTR [eax+724]
	call	edx
	mov	DWORD PTR _knownEmmitters$[ebp], eax
$LN6@BuildPrePl:

; 1248 :     
; 1249 :     if (knownEmmitters)

	cmp	DWORD PTR _knownEmmitters$[ebp], 0
	je	$LN5@BuildPrePl

; 1250 :     {
; 1251 : 		{
; 1252 : 			VuListIterator elementWalker (knownEmmitters);	

	mov	eax, DWORD PTR _knownEmmitters$[ebp]
	push	eax
	lea	ecx, DWORD PTR _elementWalker$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1253 : 			eHeader = (FalconEntity*)elementWalker.GetFirst();

	lea	ecx, DWORD PTR _elementWalker$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _eHeader$[ebp], eax
$LN4@BuildPrePl:

; 1254 : 			while (eHeader)

	cmp	DWORD PTR _eHeader$[ebp], 0
	je	SHORT $LN3@BuildPrePl

; 1255 : 			{
; 1256 : 				tmpElement = new GroundListElement (eHeader);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN9@BuildPrePl
	mov	ecx, DWORD PTR _eHeader$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0GroundListElement@@QAE@PAVFalconEntity@@@Z ; GroundListElement::GroundListElement
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN10@BuildPrePl
$LN9@BuildPrePl:
	mov	DWORD PTR tv144[ebp], 0
$LN10@BuildPrePl:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _tmpElement$[ebp], eax

; 1257 : 			    
; 1258 : 				if (grndlist == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+412], 0
	jne	SHORT $LN2@BuildPrePl

; 1259 : 				grndlist = tmpElement;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpElement$[ebp]
	mov	DWORD PTR [edx+412], eax

; 1260 : 				else

	jmp	SHORT $LN1@BuildPrePl
$LN2@BuildPrePl:

; 1261 : 				curElement->next = tmpElement;

	mov	ecx, DWORD PTR _curElement$[ebp]
	mov	edx, DWORD PTR _tmpElement$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@BuildPrePl:

; 1262 : 				curElement = tmpElement;

	mov	eax, DWORD PTR _tmpElement$[ebp]
	mov	DWORD PTR _curElement$[ebp], eax

; 1263 : 				eHeader = (FalconEntity*)elementWalker.GetNext();

	lea	ecx, DWORD PTR _elementWalker$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _eHeader$[ebp], eax

; 1264 : 			}

	jmp	SHORT $LN4@BuildPrePl
$LN3@BuildPrePl:

; 1265 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _elementWalker$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1266 : 		knownEmmitters->Unregister();

	mov	ecx, DWORD PTR _knownEmmitters$[ebp]
	call	?Unregister@VuCollection@@QAEXXZ	; VuCollection::Unregister

; 1267 : 		delete knownEmmitters;

	mov	ecx, DWORD PTR _knownEmmitters$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T6[ebp], edx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN11@BuildPrePl
	push	1
	mov	eax, DWORD PTR $T6[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN5@BuildPrePl
$LN11@BuildPrePl:
	mov	DWORD PTR tv169[ebp], 0
$LN5@BuildPrePl:

; 1268 :     }
; 1269 :     nextDlUpdate = SimLibElapsedTime + CampaignSeconds * DATALINK_CYCLE;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 20000				; 00004e20H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+416], ecx

; 1270 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildPrePlanned@FireControlComputer@@QAEXXZ$0:
	lea	ecx, DWORD PTR _elementWalker$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?BuildPrePlanned@FireControlComputer@@QAEXXZ$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildPrePlanned@FireControlComputer@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildPrePlanned@FireControlComputer@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildPrePlanned@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::BuildPrePlanned
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?AddGroundElement@FireControlComputer@@QAEXPAVGroundListElement@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_add$ = 8						; size = 4
?AddGroundElement@FireControlComputer@@QAEXPAVGroundListElement@@@Z PROC ; FireControlComputer::AddGroundElement, COMDAT
; _this$ = ecx

; 306  : 	void AddGroundElement(GroundListElement *add) { add->next = grndlist; grndlist = add; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _add$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+412]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _add$[ebp]
	mov	DWORD PTR [eax+412], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddGroundElement@FireControlComputer@@QAEXPAVGroundListElement@@@Z ENDP ; FireControlComputer::AddGroundElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ PROC ; FireControlComputer::GetFirstGroundElement, COMDAT
; _this$ = ecx

; 305  : 	GroundListElement *GetFirstGroundElement() { return grndlist; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstGroundElement@FireControlComputer@@QAEPAVGroundListElement@@XZ ENDP ; FireControlComputer::GetFirstGroundElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
?MissileLaunch@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::MissileLaunch
; _this$ = ecx

; 194  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 	if(subMode == Aim120)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+148], 6
	jne	SHORT $LN8@MissileLau

; 196  : 	{
; 197  : 		missileLaunched = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 1

; 198  : 		lastMissileShootTime = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+240], eax
$LN8@MissileLau:

; 199  : 	}
; 200  : 
; 201  : 	if(!Sms->GetCurrentWeapon())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+408]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	jne	$LN7@MissileLau

; 202  : 	{
; 203  : 		switch(masterMode) // MLR 4/12/2004 - Even though this function only appears to be called in AA modes

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR tv82[ebp], edx
	cmp	DWORD PTR tv82[ebp], 2
	je	SHORT $LN4@MissileLau
	cmp	DWORD PTR tv82[ebp], 9
	je	SHORT $LN2@MissileLau
	cmp	DWORD PTR tv82[ebp], 10			; 0000000aH
	je	SHORT $LN4@MissileLau
	jmp	SHORT $LN7@MissileLau
$LN4@MissileLau:

; 204  : 		{
; 205  : 			case Missile:
; 206  : 			case MissileOverride:
; 207  : 				if(!Sms->FindWeaponType (wtAim120))

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN3@MissileLau

; 208  : 					Sms->FindWeaponType (wtAim9);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN3@MissileLau:

; 209  : 				SetMasterMode(masterMode);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 210  : 			break;

	jmp	SHORT $LN7@MissileLau
$LN2@MissileLau:

; 211  : 
; 212  : 			case Dogfight:
; 213  : 				if(!Sms->FindWeaponType (wtAim9))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN1@MissileLau

; 214  : 					Sms->FindWeaponType (wtAim120);				

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN1@MissileLau:

; 215  : 				SetMasterMode(masterMode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN7@MissileLau:

; 216  : 			break;
; 217  : 		}
; 218  : 	}
; 219  : 	UpdateLastData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateLastData@FireControlComputer@@AAEXXZ ; FireControlComputer::UpdateLastData

; 220  : //	UpdateWeaponPtr();
; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MissileLaunch@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::MissileLaunch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_st$ = 8						; size = 4
?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z PROC ; FireControlComputer::IsHsdState, COMDAT
; _this$ = ecx

; 300  :    BOOL IsHsdState (HsdStates st) { return (hsdstates & st) == (unsigned int) st ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	and	ecx, DWORD PTR _st$[ebp]
	cmp	ecx, DWORD PTR _st$[ebp]
	jne	SHORT $LN3@IsHsdState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsHsdState
$LN3@IsHsdState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsHsdState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ENDP ; FireControlComputer::IsHsdState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_st$ = 8						; size = 4
?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z PROC ; FireControlComputer::ToggleHsdState, COMDAT
; _this$ = ecx

; 299  :    void ToggleHsdState (HsdStates st) { hsdstates ^= st; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	xor	ecx, DWORD PTR _st$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ENDP ; FireControlComputer::ToggleHsdState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
tv90 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?PushButton@FireControlComputer@@UAEXHH@Z PROC		; FireControlComputer::PushButton
; _this$ = ecx

; 1126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1127 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1128 :     ShiAssert(whichButton < 20);
; 1129 :     ShiAssert(whichMFD < 4);
; 1130 : 
; 1131 :     if (IsHsdState(HSDCNTL)) 

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHsdState@FireControlComputer@@QAEHW4HsdStates@1@@Z ; FireControlComputer::IsHsdState
	test	eax, eax
	je	SHORT $LN37@PushButton

; 1132 : 	{
; 1133 : 		if (hsdcntlcfg[whichButton].mode != HSDNONE) 

	mov	eax, DWORD PTR _whichButton$[ebp]
	cmp	DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[eax*8+4], 0
	je	SHORT $LN37@PushButton

; 1134 : 		{
; 1135 : 			ToggleHsdState(hsdcntlcfg[whichButton].mode);

	mov	ecx, DWORD PTR _whichButton$[ebp]
	mov	edx, DWORD PTR ?hsdcntlcfg@FireControlComputer@@0PAUHsdCnfgStates@1@A[ecx*8+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState

; 1136 : 			return;

	jmp	$LN39@PushButton
$LN37@PushButton:

; 1137 : 		}
; 1138 : 	}
; 1139 : 
; 1140 : 	//MI
; 1141 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN34@PushButton

; 1142 : 	{
; 1143 : 		if(playerAC)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN34@PushButton

; 1144 : 		{
; 1145 : 			if(IsSOI && (whichButton >=11 && whichButton <= 13))

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN34@PushButton
	cmp	DWORD PTR _whichButton$[ebp], 11	; 0000000bH
	jl	SHORT $LN34@PushButton
	cmp	DWORD PTR _whichButton$[ebp], 13	; 0000000dH
	jg	SHORT $LN34@PushButton

; 1146 : 				platform->StepSOI(2);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN34@PushButton:

; 1147 : 		}
; 1148 : 	}
; 1149 :     switch (whichButton)

	mov	ecx, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	cmp	DWORD PTR tv90[ebp], 19			; 00000013H
	ja	$LN32@PushButton
	mov	edx, DWORD PTR tv90[ebp]
	jmp	DWORD PTR $LN41@PushButton[edx*4]
$LN31@PushButton:

; 1150 :     {
; 1151 :     case 0: // DEP - JPO
; 1152 : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN30@PushButton

; 1153 : 	    ToggleHsdState (HSDCEN);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN30@PushButton:

; 1154 : 	}
; 1155 : 	break;

	jmp	$LN32@PushButton
$LN29@PushButton:

; 1156 :     case 1: // DCPL - JPO
; 1157 : 	if (g_bRealisticAvionics) {

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN28@PushButton

; 1158 : 	    ToggleHsdState (HSDCPL);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN28@PushButton:

; 1159 : 	}
; 1160 : 	break;

	jmp	$LN32@PushButton
$LN27@PushButton:

; 1161 : 	//MI
; 1162 : 	case 2:
; 1163 : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN26@PushButton

; 1164 : 			ToggleHSDZoom();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHSDZoom@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleHSDZoom
$LN26@PushButton:

; 1165 : 	break;

	jmp	$LN32@PushButton
$LN25@PushButton:

; 1166 :     case 4: // CTRL
; 1167 : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN24@PushButton

; 1168 : 	    ToggleHsdState (HSDCNTL);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN24@PushButton:

; 1169 : 	}
; 1170 : 	break;

	jmp	$LN32@PushButton
$LN23@PushButton:

; 1171 :     case 6: // FRZ - JPO
; 1172 : 	if (g_bRealisticAvionics) {

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN22@PushButton

; 1173 : 	    frz_x = platform->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+104]

; 1174 : 	    frz_y = platform->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+108]

; 1175 : 	    frz_dir = platform->Yaw();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+112]

; 1176 : 	    ToggleHsdState(HSDFRZ);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleHsdState@FireControlComputer@@QAEXW4HsdStates@1@@Z ; FireControlComputer::ToggleHsdState
$LN22@PushButton:

; 1177 : 	}
; 1178 : 	break;

	jmp	$LN32@PushButton
$LN21@PushButton:

; 1179 :     case 10: 
; 1180 : 	if (g_bRealisticAvionics) {

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN20@PushButton

; 1181 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
$LN20@PushButton:

; 1182 : 	}
; 1183 : 	break;

	jmp	$LN32@PushButton
$LN19@PushButton:

; 1184 :     case 11: // SMS
; 1185 : 	if (g_bRealisticAvionics) 

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN18@PushButton

; 1186 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 1187 : 	else

	jmp	SHORT $LN17@PushButton
$LN18@PushButton:

; 1188 : 	    MfdDisplay[whichMFD]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	edx, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN17@PushButton:

; 1189 : 	break;

	jmp	$LN32@PushButton
$LN16@PushButton:

; 1190 :     case 12: // jpo 
; 1191 : 	if (g_bRealisticAvionics) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN15@PushButton

; 1192 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
$LN15@PushButton:

; 1193 : 	break;

	jmp	$LN32@PushButton
$LN14@PushButton:

; 1194 : 
; 1195 :     case 13: // HSD
; 1196 : 	if (g_bRealisticAvionics) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN13@PushButton

; 1197 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 1198 : 	else

	jmp	SHORT $LN12@PushButton
$LN13@PushButton:

; 1199 : 	    MfdDisplay[whichMFD]->SetNewMode(MFDClass::MfdMenu);

	push	1
	mov	eax, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN12@PushButton:

; 1200 : 	break;

	jmp	$LN32@PushButton
$LN11@PushButton:

; 1201 : 	
; 1202 :     case 14: // SWAP
; 1203 : 	if (g_bRealisticAvionics) 

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN10@PushButton

; 1204 : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton

; 1205 : 	else

	jmp	SHORT $LN9@PushButton
$LN10@PushButton:

; 1206 : 	    MFDSwapDisplays();

	call	?MFDSwapDisplays@@YAXXZ			; MFDSwapDisplays
$LN9@PushButton:

; 1207 : 	break;

	jmp	SHORT $LN32@PushButton
$LN8@PushButton:

; 1208 : 	
; 1209 :     case 18: // Down
; 1210 : 		if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN7@PushButton

; 1211 : 			SimHSDRangeStepDown (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHSDRangeStepDown@@YAXKHPAX@Z	; SimHSDRangeStepDown
	add	esp, 12					; 0000000cH

; 1212 : 		else

	jmp	SHORT $LN5@PushButton
$LN7@PushButton:

; 1213 : 		{
; 1214 : 			//MI
; 1215 : 			if(HSDZoom == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+468], 0
	jne	SHORT $LN5@PushButton

; 1216 : 				SimHSDRangeStepDown (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHSDRangeStepDown@@YAXKHPAX@Z	; SimHSDRangeStepDown
	add	esp, 12					; 0000000cH
$LN5@PushButton:

; 1217 : 		}		
; 1218 : 	break;

	jmp	SHORT $LN32@PushButton
$LN4@PushButton:

; 1219 : 	
; 1220 :     case 19: // UP
; 1221 : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@PushButton

; 1222 : 			SimHSDRangeStepUp (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHSDRangeStepUp@@YAXKHPAX@Z		; SimHSDRangeStepUp
	add	esp, 12					; 0000000cH

; 1223 : 		else

	jmp	SHORT $LN1@PushButton
$LN3@PushButton:

; 1224 : 		{
; 1225 : 			//MI
; 1226 : 			if(HSDZoom == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+468], 0
	jne	SHORT $LN1@PushButton

; 1227 : 				SimHSDRangeStepUp (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHSDRangeStepUp@@YAXKHPAX@Z		; SimHSDRangeStepUp
	add	esp, 12					; 0000000cH
$LN1@PushButton:
$LN32@PushButton:
$LN39@PushButton:

; 1228 : 		}	
; 1229 : 	break;
; 1230 :     }
; 1231 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN41@PushButton:
	DD	$LN31@PushButton
	DD	$LN29@PushButton
	DD	$LN27@PushButton
	DD	$LN32@PushButton
	DD	$LN25@PushButton
	DD	$LN32@PushButton
	DD	$LN23@PushButton
	DD	$LN32@PushButton
	DD	$LN32@PushButton
	DD	$LN32@PushButton
	DD	$LN21@PushButton
	DD	$LN19@PushButton
	DD	$LN16@PushButton
	DD	$LN14@PushButton
	DD	$LN11@PushButton
	DD	$LN32@PushButton
	DD	$LN32@PushButton
	DD	$LN32@PushButton
	DD	$LN8@PushButton
	DD	$LN4@PushButton
?PushButton@FireControlComputer@@UAEXHH@Z ENDP		; FireControlComputer::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv166 = -40						; size = 4
tv165 = -36						; size = 4
tv162 = -32						; size = 4
tv160 = -28						; size = 4
tv159 = -24						; size = 4
tv156 = -20						; size = 4
_dr$1 = -16						; size = 4
_dr$2 = -12						; size = 4
_this$ = -8						; size = 4
_asecradius$ = -4					; size = 4
_range$ = 8						; size = 4
?Aim120ASECRadius@FireControlComputer@@QAEMM@Z PROC	; FireControlComputer::Aim120ASECRadius
; _this$ = ecx

; 1509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1510 :     float asecradius = 0.6f;

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR _asecradius$[ebp], xmm0

; 1511 :     static const float bestmaxrange = 0.8f; // upper bound
; 1512 :     if (!g_bRealisticAvionics) return asecradius;

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@Aim120ASEC
	fld	DWORD PTR _asecradius$[ebp]
	jmp	$LN7@Aim120ASEC
$LN6@Aim120ASEC:

; 1513 : 
; 1514 :     if (range > bestmaxrange*missileRMax) 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?bestmaxrange@?1??Aim120ASECRadius@FireControlComputer@@QAEMM@Z@4MB
	mulss	xmm0, DWORD PTR [ecx+288]
	movss	xmm1, DWORD PTR _range$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@Aim120ASEC

; 1515 : 	{ // above best range
; 1516 : 	float dr = (range - bestmaxrange*missileRMax) / (0.2f*missileRMax);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?bestmaxrange@?1??Aim120ASECRadius@FireControlComputer@@QAEMM@Z@4MB
	mulss	xmm0, DWORD PTR [edx+288]
	movss	xmm1, DWORD PTR _range$[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR [eax+288]
	divss	xmm1, xmm0
	movss	DWORD PTR _dr$2[ebp], xmm1

; 1517 : 	dr = 1.0f - dr;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dr$2[ebp]
	movss	DWORD PTR _dr$2[ebp], xmm0

; 1518 : 	asecradius *= dr;

	movss	xmm0, DWORD PTR _asecradius$[ebp]
	mulss	xmm0, DWORD PTR _dr$2[ebp]
	movss	DWORD PTR _asecradius$[ebp], xmm0
	jmp	SHORT $LN3@Aim120ASEC
$LN5@Aim120ASEC:

; 1519 :     }
; 1520 :     else if (range < (missileRneMax - missileRneMin)/2.0f) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+296]
	subss	xmm0, DWORD PTR [edx+300]
	divss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _range$[ebp]
	jbe	SHORT $LN3@Aim120ASEC

; 1521 : 	{
; 1522 : 	float dr = (range - missileRMin);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _range$[ebp]
	subss	xmm0, DWORD PTR [eax+292]
	movss	DWORD PTR _dr$1[ebp], xmm0

; 1523 : 	dr /= (missileRneMax - missileRneMin)/2.0f - missileRMin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+296]
	subss	xmm0, DWORD PTR [edx+300]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+292]
	movss	xmm1, DWORD PTR _dr$1[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _dr$1[ebp], xmm1

; 1524 : 	asecradius *= dr;

	movss	xmm0, DWORD PTR _asecradius$[ebp]
	mulss	xmm0, DWORD PTR _dr$1[ebp]
	movss	DWORD PTR _asecradius$[ebp], xmm0
$LN3@Aim120ASEC:

; 1525 :     }
; 1526 : 	//MI make the size dependant on missile mode
; 1527 : 	if(Sms && Sms->curWeapon && ((MissileClass*)Sms->GetCurrentWeapon())->isSlave)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+408], 0
	je	$LN2@Aim120ASEC
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN2@Aim120ASEC
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+408]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	DWORD PTR [eax+736], 0
	je	$LN2@Aim120ASEC

; 1528 : 		asecradius = max(min(0.3f, asecradius), 0.1f);

	movss	xmm0, DWORD PTR _asecradius$[ebp]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	SHORT $LN9@Aim120ASEC
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR tv156[ebp], xmm0
	jmp	SHORT $LN10@Aim120ASEC
$LN9@Aim120ASEC:
	movss	xmm0, DWORD PTR _asecradius$[ebp]
	movss	DWORD PTR tv156[ebp], xmm0
$LN10@Aim120ASEC:
	movss	xmm0, DWORD PTR tv156[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN13@Aim120ASEC
	movss	xmm0, DWORD PTR _asecradius$[ebp]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	SHORT $LN11@Aim120ASEC
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR tv159[ebp], xmm0
	jmp	SHORT $LN12@Aim120ASEC
$LN11@Aim120ASEC:
	movss	xmm0, DWORD PTR _asecradius$[ebp]
	movss	DWORD PTR tv159[ebp], xmm0
$LN12@Aim120ASEC:
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR tv160[ebp], xmm0
	jmp	SHORT $LN14@Aim120ASEC
$LN13@Aim120ASEC:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv160[ebp], xmm0
$LN14@Aim120ASEC:
	movss	xmm0, DWORD PTR tv160[ebp]
	movss	DWORD PTR _asecradius$[ebp], xmm0

; 1529 : 	else

	jmp	SHORT $LN1@Aim120ASEC
$LN2@Aim120ASEC:

; 1530 : 		asecradius = max(min(0.6f, asecradius), 0.1f);

	movss	xmm0, DWORD PTR _asecradius$[ebp]
	comiss	xmm0, DWORD PTR __real@3f19999a
	jbe	SHORT $LN15@Aim120ASEC
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN16@Aim120ASEC
$LN15@Aim120ASEC:
	movss	xmm0, DWORD PTR _asecradius$[ebp]
	movss	DWORD PTR tv162[ebp], xmm0
$LN16@Aim120ASEC:
	movss	xmm0, DWORD PTR tv162[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN19@Aim120ASEC
	movss	xmm0, DWORD PTR _asecradius$[ebp]
	comiss	xmm0, DWORD PTR __real@3f19999a
	jbe	SHORT $LN17@Aim120ASEC
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN18@Aim120ASEC
$LN17@Aim120ASEC:
	movss	xmm0, DWORD PTR _asecradius$[ebp]
	movss	DWORD PTR tv165[ebp], xmm0
$LN18@Aim120ASEC:
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR tv166[ebp], xmm0
	jmp	SHORT $LN20@Aim120ASEC
$LN19@Aim120ASEC:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv166[ebp], xmm0
$LN20@Aim120ASEC:
	movss	xmm0, DWORD PTR tv166[ebp]
	movss	DWORD PTR _asecradius$[ebp], xmm0
$LN1@Aim120ASEC:

; 1531 :     return asecradius;

	fld	DWORD PTR _asecradius$[ebp]
$LN7@Aim120ASEC:

; 1532 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Aim120ASECRadius@FireControlComputer@@QAEMM@Z ENDP	; FireControlComputer::Aim120ASECRadius
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTarget$ = 8						; size = 4
?SetTarget@FireControlComputer@@QAEXPAVSimObjectType@@@Z PROC ; FireControlComputer::SetTarget
; _this$ = ecx

; 1073 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1074 : 	if (newTarget == targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTarget$[ebp]
	cmp	ecx, DWORD PTR [eax+132]
	jne	SHORT $LN2@SetTarget

; 1075 : 		return;

	jmp	SHORT $LN3@SetTarget
$LN2@SetTarget:

; 1076 : 
; 1077 : 	/* MLR debugging stuff
; 1078 : 	MonoPrint("  FCC::SetTarget - prev:%08x/%08x, new: %08x/%08x\n",
; 1079 : 		targetPtr,(targetPtr?targetPtr->BaseData():0),
; 1080 : 		newTarget,(newTarget?newTarget->BaseData():0));
; 1081 : 
; 1082 : 	if(!newTarget) 
; 1083 : 		int stop=0;
; 1084 : 	*/
; 1085 : 	ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1086 : 	if (newTarget)

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	SHORT $LN1@SetTarget

; 1087 : 	{
; 1088 :         ShiAssert( newTarget->BaseData() != (FalconEntity*)0xDDDDDDDD );
; 1089 : 		newTarget->Reference(  );

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference
$LN1@SetTarget:

; 1090 : 	}
; 1091 : 
; 1092 : 	targetPtr = newTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTarget$[ebp]
	mov	DWORD PTR [edx+132], eax
$LN3@SetTarget:

; 1093 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@FireControlComputer@@QAEXPAVSimObjectType@@@Z ENDP ; FireControlComputer::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearCurrentTarget@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::ClearCurrentTarget
; _this$ = ecx

; 1066 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 	if (targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN1@ClearCurre

; 1068 : 		targetPtr->Release(  );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+132]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release
$LN1@ClearCurre:

; 1069 : 	targetPtr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 0

; 1070 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearCurrentTarget@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::ClearCurrentTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_tmpWaypoint$ = -8					; size = 4
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetPlayerFCC@FireControlComputer@@QAEXH@Z PROC		; FireControlComputer::SetPlayerFCC
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 	WayPointClass* tmpWaypoint;
; 180  : 
; 181  : 	playerFCC = flag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flag$[ebp]
	mov	DWORD PTR [eax+92], ecx

; 182  : 	Sms->SetPlayerSMS(flag);

	mov	edx, DWORD PTR _flag$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?SetPlayerSMS@SMSClass@@QAEXH@Z		; SMSClass::SetPlayerSMS

; 183  : 	tmpWaypoint = platform->waypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 184  : 	TheHud->waypointNum = 0;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4948], 0
$LN2@SetPlayerF:

; 185  : 	while (tmpWaypoint && tmpWaypoint != platform->curWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN3@SetPlayerF
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	cmp	ecx, DWORD PTR [eax+728]
	je	SHORT $LN3@SetPlayerF

; 186  : 	{
; 187  : 		tmpWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 188  : 		TheHud->waypointNum ++;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	eax, DWORD PTR [edx+4948]
	add	eax, 1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4948], eax

; 189  : 	}

	jmp	SHORT $LN2@SetPlayerF
$LN3@SetPlayerF:

; 190  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayerFCC@FireControlComputer@@QAEXH@Z ENDP		; FireControlComputer::SetPlayerFCC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ PROC ; FireControlComputer::GetMainMasterMode
; _this$ = ecx

; 1465 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1466 :     switch (masterMode) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 13			; 0000000dH
	ja	SHORT $LN4@GetMainMas
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN10@GetMainMas[edx]
	jmp	DWORD PTR $LN11@GetMainMas[eax*4]
$LN5@GetMainMas:

; 1467 : 	case AAGun:
; 1468 :     case Missile:
; 1469 : 		return MM_AA;

	mov	eax, 1
	jmp	SHORT $LN8@GetMainMas
$LN4@GetMainMas:

; 1470 :     case ILS:
; 1471 :     case Nav:
; 1472 :     default:
; 1473 : 		return MM_NAV;

	mov	eax, 2
	jmp	SHORT $LN8@GetMainMas
$LN3@GetMainMas:

; 1474 :     case AirGroundBomb:
; 1475 : 	case AirGroundRocket:
; 1476 :     case AirGroundMissile:
; 1477 :     case AirGroundHARM:
; 1478 :     case AirGroundLaser:
; 1479 :     case AirGroundCamera:
; 1480 : 	case AGGun:
; 1481 : 		return MM_AG;

	xor	eax, eax
	jmp	SHORT $LN8@GetMainMas
$LN2@GetMainMas:

; 1482 : 	//case Gun:
; 1483 : 		//if (subMode == STRAF)
; 1484 : 		//    return MM_AG;
; 1485 : 		//else return MM_AA;
; 1486 :     case Dogfight:
; 1487 : 		return MM_DGFT;

	mov	eax, 4
	jmp	SHORT $LN8@GetMainMas
$LN1@GetMainMas:

; 1488 :     case MissileOverride:
; 1489 : 		return MM_MSL;

	mov	eax, 3
$LN8@GetMainMas:

; 1490 :     }
; 1491 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN11@GetMainMas:
	DD	$LN5@GetMainMas
	DD	$LN3@GetMainMas
	DD	$LN2@GetMainMas
	DD	$LN1@GetMainMas
	DD	$LN4@GetMainMas
$LN10@GetMainMas:
	DB	0
	DB	1
	DB	0
	DB	4
	DB	4
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	3
	DB	1
	DB	4
	DB	1
?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ENDP ; FireControlComputer::GetMainMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv289 = -32						; size = 4
tv319 = -28						; size = 4
tv268 = -24						; size = 4
tv252 = -20						; size = 4
tv180 = -16						; size = 4
_overtake$1 = -12					; size = 4
tv200 = -8						; size = 4
_this$ = -4						; size = 4
_curTarget$ = 8						; size = 4
_newList$ = 12						; size = 4
_theInputs$ = 16					; size = 4
?Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV2@0PAVPilotInputs@@@Z PROC ; FireControlComputer::Exec
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 226  : #ifdef Prof_ENABLED
; 227  : 	Prof(FireControlComputer_Exec);
; 228  : #endif
; 229  : 
; 230  : 
; 231  : //me123 overtake needs to be calgulated the same way in MissileClass::GetTOF
; 232  : static const float	MISSILE_ALTITUDE_BONUS = 23.0f;	//me123 addet here and in // JB 010215 changed from 24 to 23
; 233  : static const float	MISSILE_SPEED = 1500.0f; // JB 010215 changed from 1300 to 1500
; 234  :    if (playerFCC &&
; 235  :       ((AircraftClass*)platform)->mFaults->GetFault(FaultClass::fcc_fault))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN17@Exec
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN17@Exec

; 236  :    {
; 237  :       SetTarget (NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@FireControlComputer@@QAEXPAVSimObjectType@@@Z ; FireControlComputer::SetTarget

; 238  :    }
; 239  :    else

	jmp	$LN16@Exec
$LN17@Exec:

; 240  :    {
; 241  :        if (SimDriver.MotionOn())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?MotionOn@SimulationDriver@@QAEHXZ	; SimulationDriver::MotionOn
	test	eax, eax
	je	$LN10@Exec

; 242  :        {
; 243  : 					if (!targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jne	SHORT $LN14@Exec

; 244  : 					{
; 245  : 						MissileImpactTimeFlash = 0; // cancel flashing

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+396], 0

; 246  : 						lastMissileImpactTime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+268], xmm0

; 247  : 						lastmissileActiveTime = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+276], xmm0
$LN14@Exec:

; 248  : 					}
; 249  : 					if (targetPtr && missileLaunched) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	$LN13@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+236], 0
	je	$LN13@Exec

; 250  : 					{
; 251  : 						lastMissileShootRng = targetPtr->localData->range;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+248], ecx

; 252  : 						lastMissileImpactTime = nextMissileImpactTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	DWORD PTR [edx+268], ecx

; 253  : 						lastMissileShootHeight = Height;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+252]
	mov	DWORD PTR [edx+256], ecx

; 254  : 						lastMissileShootEnergy = (platform->GetVt() * FTPSEC_TO_KNOTS - 150.0f)/2 ; // JB 010215 changed from 250 to 150

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv252[ebp]
	movss	xmm0, DWORD PTR tv252[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	subss	xmm0, DWORD PTR __real@43160000
	divss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+260], xmm0
$LN13@Exec:

; 255  : 					}
; 256  : 					missileLaunched = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 257  : 					if (lastMissileImpactTime > 0.0F  && targetPtr )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+268]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN10@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	$LN10@Exec

; 258  : 					{ //me123 addet this stuff
; 259  : 
; 260  : 						//this is the missiles approximate overtake
; 261  : 						//missilespeed + altitude bonus + target closure
; 262  : 			       
; 263  : 						float overtake = lastMissileShootEnergy + MISSILE_SPEED +(lastMissileShootHeight/1000.0f * MISSILE_ALTITUDE_BONUS) + targetspeed  * (float)cos(targetPtr->localData->ataFrom);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	addss	xmm0, DWORD PTR ?MISSILE_SPEED@?1??Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV3@0PAVPilotInputs@@@Z@4MB
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+256]
	divss	xmm1, DWORD PTR __real@447a0000
	mulss	xmm1, DWORD PTR ?MISSILE_ALTITUDE_BONUS@?1??Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV3@0PAVPilotInputs@@@Z@4MB
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	mov	eax, DWORD PTR [edx+12]
	push	ecx
	movss	xmm1, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv319[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv268[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv268[ebp]
	mulss	xmm0, DWORD PTR [ecx+244]
	movss	xmm1, DWORD PTR tv319[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _overtake$1[ebp], xmm1

; 264  : 			       
; 265  : 						//this is the predicted range from the missile to the target
; 266  : 						lastMissileShootRng = lastMissileShootRng - (overtake / SimLibMajorFrameRate);

	movss	xmm0, DWORD PTR _overtake$1[ebp]
	divss	xmm0, DWORD PTR ?SimLibMajorFrameRate@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+248]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+248], xmm1

; 267  : 			       
; 268  : 						lastMissileImpactTime =	max (0.0F, lastMissileShootRng/overtake);	// this is TOF.  Counting on silent failure of divid by 0.0 here...

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+248]
	divss	xmm0, DWORD PTR _overtake$1[ebp]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@Exec
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv180[ebp], xmm0
	jmp	SHORT $LN21@Exec
$LN20@Exec:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+248]
	divss	xmm0, DWORD PTR _overtake$1[ebp]
	movss	DWORD PTR tv180[ebp], xmm0
$LN21@Exec:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv180[ebp]
	movss	DWORD PTR [eax+268], xmm0

; 269  : 						lastMissileImpactTime += -5.0f * (float) sin(.07f * lastMissileImpactTime); // JB 010215

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3d8f5c29
	mulss	xmm0, DWORD PTR [ecx+268]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv289[ebp]
	movss	xmm0, DWORD PTR tv289[ebp]
	mulss	xmm0, DWORD PTR __real@c0a00000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+268]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+268], xmm0

; 270  : 						if (lastMissileImpactTime == 0.0f) 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+268]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Exec

; 271  : 						{ // JPO - trigger flashing X
; 272  : 							// 8 seconds steady, 5 seconds flash
; 273  : 							MissileImpactTimeFlash = SimLibElapsedTime + (5+8) * CampaignSeconds;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 13000				; 000032c8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+396], edx

; 274  : 							lastMissileShootRng = -1.0f; // reset for next

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+248], xmm0

; 275  : 						}
; 276  : 						else 

	jmp	SHORT $LN10@Exec
$LN11@Exec:

; 277  : 							MissileImpactTimeFlash = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 0
$LN10@Exec:

; 278  : 				 }
; 279  :        }
; 280  : 
; 281  :       SetTarget(curTarget);

	mov	eax, DWORD PTR _curTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@FireControlComputer@@QAEXPAVSimObjectType@@@Z ; FireControlComputer::SetTarget

; 282  :       targetList = newList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newList$[ebp]
	mov	DWORD PTR [ecx+136], edx

; 283  : 
; 284  :       NavMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NavMode@FireControlComputer@@AAEXXZ	; FireControlComputer::NavMode

; 285  :       switch (masterMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv200[ebp], ecx
	mov	edx, DWORD PTR tv200[ebp]
	sub	edx, 1
	mov	DWORD PTR tv200[ebp], edx
	cmp	DWORD PTR tv200[ebp], 12		; 0000000cH
	ja	SHORT $LN8@Exec
	mov	eax, DWORD PTR tv200[ebp]
	movzx	ecx, BYTE PTR $LN22@Exec[eax]
	jmp	DWORD PTR $LN23@Exec[ecx*4]
$LN7@Exec:

; 286  :       {
; 287  :          case AGGun:
; 288  : 						//if (GetSubMode() == STRAF) {
; 289  : 						AirGroundMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AirGroundMode@FireControlComputer@@AAEXXZ ; FireControlComputer::AirGroundMode

; 290  : 				 break;

	jmp	SHORT $LN8@Exec

; 291  :          case ILS:
; 292  :          case Nav:
; 293  :          break;

	jmp	SHORT $LN8@Exec
$LN5@Exec:

; 294  : 
; 295  :          case Dogfight:
; 296  :          case MissileOverride:
; 297  :          case Missile:
; 298  :             AirAirMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AirAirMode@FireControlComputer@@AAEXXZ	; FireControlComputer::AirAirMode

; 299  :             lastCage = missileCageCmd;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+187]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 300  :          break;

	jmp	SHORT $LN8@Exec
$LN4@Exec:

; 301  : 
; 302  :          case AirGroundBomb:
; 303  :             AirGroundMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AirGroundMode@FireControlComputer@@AAEXXZ ; FireControlComputer::AirGroundMode

; 304  :          break;

	jmp	SHORT $LN8@Exec
$LN3@Exec:

; 305  : 
; 306  : 				 case AirGroundRocket:
; 307  :             AirGroundMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AirGroundMode@FireControlComputer@@AAEXXZ ; FireControlComputer::AirGroundMode

; 308  : 				 break;

	jmp	SHORT $LN8@Exec
$LN2@Exec:

; 309  : 
; 310  :          case AirGroundMissile:
; 311  :          case AirGroundHARM:
; 312  :             AirGroundMissileMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AirGroundMissileMode@FireControlComputer@@AAEXXZ ; FireControlComputer::AirGroundMissileMode

; 313  :          break;

	jmp	SHORT $LN8@Exec
$LN1@Exec:

; 314  : 
; 315  :          case AirGroundLaser:
; 316  :            //if(!playerFCC) 
; 317  : 						TargetingPodMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TargetingPodMode@FireControlComputer@@AAEXXZ ; FireControlComputer::TargetingPodMode
$LN8@Exec:

; 318  :          break;
; 319  :       }
; 320  : 
; 321  : 	  // always run targeting pod for player
; 322  : 	  // FRB - always run targeting pod for All
; 323  : 			//TargetingPodMode();
; 324  : 	  //if(playerFCC) TargetingPodMode();
; 325  : 	  // COBRA - RED - CCIP HUD FIX - make the Time To target equal to 0, targeting Pod mode is assigning a time to target
; 326  : 	  // messing up the CCIP pipper in HudClas::DrawCCIP call
; 327  : 	  //if(subMode==CCIP) airGroundDelayTime=0.0F;
; 328  : 
; 329  :       lastDesignate = designateCmd;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+184]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], eax
$LN16@Exec:

; 330  :    }
; 331  : 
; 332  :    return (targetPtr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN23@Exec:
	DD	$LN7@Exec
	DD	$LN5@Exec
	DD	$LN4@Exec
	DD	$LN2@Exec
	DD	$LN1@Exec
	DD	$LN3@Exec
	DD	$LN8@Exec
$LN22@Exec:
	DB	0
	DB	1
	DB	6
	DB	6
	DB	2
	DB	3
	DB	3
	DB	4
	DB	1
	DB	1
	DB	6
	DB	6
	DB	5
?Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV2@0PAVPilotInputs@@@Z ENDP ; FireControlComputer::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv143 = -20						; size = 4
_TheBomb$ = -16						; size = 4
_pradar$ = -12						; size = 4
tv79 = -8						; size = 4
_this$ = -4						; size = 4
?WeaponStep@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::WeaponStep
; _this$ = ecx

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 829  : 	RadarDopplerClass* pradar = (RadarDopplerClass*) FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$[ebp], eax

; 830  : 	BombClass *TheBomb=GetTheBomb();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTheBomb@FireControlComputer@@QAEPAVBombClass@@XZ ; FireControlComputer::GetTheBomb
	mov	DWORD PTR _TheBomb$[ebp], eax

; 831  : 	switch (masterMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 9
	ja	$LN17@WeaponStep
	mov	edx, DWORD PTR tv79[ebp]
	movzx	eax, BYTE PTR $LN21@WeaponStep[edx]
	jmp	DWORD PTR $LN22@WeaponStep[eax*4]
$LN16@WeaponStep:

; 832  : 	{
; 833  : 	case Dogfight:
; 834  : 	case MissileOverride:
; 835  : 	case Missile:
; 836  : 	case AirGroundMissile:
; 837  : 	case AirGroundHARM:
; 838  :         Sms->WeaponStep();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?WeaponStep@SMSClass@@QAEHH@Z		; SMSClass::WeaponStep

; 839  : 		if(pradar && (masterMode == AirGroundMissile || masterMode == AirGroundHARM))	//MI fix

	cmp	DWORD PTR _pradar$[ebp], 0
	je	SHORT $LN15@WeaponStep
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 6
	je	SHORT $LN14@WeaponStep
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 7
	jne	SHORT $LN15@WeaponStep
$LN14@WeaponStep:

; 840  : 		{
; 841  : 			pradar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pradar$[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir

; 842  : 			pradar->SelectLastAGMode();

	mov	ecx, DWORD PTR _pradar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pradar$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
$LN15@WeaponStep:

; 843  : 		}
; 844  : 		break;

	jmp	$LN17@WeaponStep
$LN13@WeaponStep:

; 845  : 		
; 846  : 	case AGGun:
; 847  : 		if(lastAgMasterMode==AirGroundBomb)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 5
	jne	SHORT $LN12@WeaponStep

; 848  : 		{
; 849  : 			ToggleAGGunMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleAGGunMode@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleAGGunMode

; 850  : 			SetSubMode(CCRP);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN12@WeaponStep:

; 851  : 		}
; 852  : 		break;

	jmp	$LN17@WeaponStep
$LN11@WeaponStep:

; 853  : 		
; 854  : 	case AirGroundBomb:
; 855  : 		// COBRA - RED - FIXING POSSIBLE CTDs
; 856  : 		// CCIP -> DTOS -> STRAF -> CCRP
; 857  : 		/*if ((Sms->GetCurrentHardpoint() > 0) && (Sms->hardPoint[Sms->GetCurrentHardpoint()]->GetWeaponType()==wtGPS ||  // Cobra - no rippling GPS
; 858  : 					(((BombClass*)Sms->hardPoint[Sms->GetCurrentHardpoint()]->weaponPointer) && 
; 859  : 					((BombClass*)Sms->hardPoint[Sms->GetCurrentHardpoint()]->weaponPointer)->IsSetBombFlag(BombClass::IsJSOW))))*/
; 860  : 			{
; 861  : 		if( TheBomb &&	( TheBomb->IsSetBombFlag(BombClass::IsGPS) || TheBomb->IsSetBombFlag(BombClass::IsJSOW)))

	cmp	DWORD PTR _TheBomb$[ebp], 0
	je	SHORT $LN10@WeaponStep
	push	256					; 00000100H
	mov	ecx, DWORD PTR _TheBomb$[ebp]
	call	?IsSetBombFlag@BombClass@@QAEHH@Z	; BombClass::IsSetBombFlag
	test	eax, eax
	jne	SHORT $LN9@WeaponStep
	push	512					; 00000200H
	mov	ecx, DWORD PTR _TheBomb$[ebp]
	call	?IsSetBombFlag@BombClass@@QAEHH@Z	; BombClass::IsSetBombFlag
	test	eax, eax
	je	SHORT $LN10@WeaponStep
$LN9@WeaponStep:

; 862  : 			Sms->WeaponStep();

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?WeaponStep@SMSClass@@QAEHH@Z		; SMSClass::WeaponStep
$LN10@WeaponStep:

; 863  : 			break;

	jmp	SHORT $LN17@WeaponStep

; 864  : 			}
; 865  : 		switch (subMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR tv143[ebp], ecx
	cmp	DWORD PTR tv143[ebp], 7
	je	SHORT $LN6@WeaponStep
	cmp	DWORD PTR tv143[ebp], 8
	je	SHORT $LN2@WeaponStep
	cmp	DWORD PTR tv143[ebp], 10		; 0000000aH
	je	SHORT $LN5@WeaponStep
	jmp	SHORT $LN1@WeaponStep
$LN6@WeaponStep:

; 866  : 		{
; 867  : 		case CCIP:
; 868  : 			SetSubMode (DTOSS);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 869  : 			break;

	jmp	SHORT $LN7@WeaponStep
$LN5@WeaponStep:

; 870  : 			
; 871  : 		case DTOSS:
; 872  : 			//Cobra TJL 11/17/04 Aircraft w/o guns get stuck in DTOSS
; 873  : 			//with missile step
; 874  : 			//ToggleAGGunMode();
; 875  : 			if( Sms->FindWeaponClass(wcGunWpn, TRUE) )

	push	1
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
	test	eax, eax
	je	SHORT $LN4@WeaponStep

; 876  : 				ToggleAGGunMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleAGGunMode@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleAGGunMode

; 877  : 			else

	jmp	SHORT $LN3@WeaponStep
$LN4@WeaponStep:

; 878  : 				SetSubMode(CCRP);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN3@WeaponStep:

; 879  : 			break;

	jmp	SHORT $LN7@WeaponStep
$LN2@WeaponStep:

; 880  : 			
; 881  : 		case CCRP:
; 882  : 			SetSubMode (CCIP);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 883  : 			break;

	jmp	SHORT $LN7@WeaponStep
$LN1@WeaponStep:

; 884  : 			
; 885  : 		default: // catch LADD MAN etc
; 886  : 			SetSubMode(CCRP);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN7@WeaponStep:
$LN17@WeaponStep:

; 887  : 			break;
; 888  : 		}
; 889  : 		break;
; 890  : 	}
; 891  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@WeaponStep:
	DD	$LN13@WeaponStep
	DD	$LN16@WeaponStep
	DD	$LN11@WeaponStep
	DD	$LN17@WeaponStep
$LN21@WeaponStep:
	DB	0
	DB	1
	DB	3
	DB	3
	DB	2
	DB	1
	DB	1
	DB	3
	DB	1
	DB	1
?WeaponStep@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::WeaponStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msm$ = 8						; size = 4
?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z PROC ; FireControlComputer::SetMrmSubMode, COMDAT
; _this$ = ecx

; 273  : 	void SetMrmSubMode (FCCSubMode msm) { mrmSubMode = msm;}; // ASSOCIATOR 04/12/03: for remembering MRM mode missiles

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _msm$[ebp]
	mov	DWORD PTR [eax+156], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ENDP ; FireControlComputer::SetMrmSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dsm$ = 8						; size = 4
?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z PROC ; FireControlComputer::SetDgftSubMode, COMDAT
; _this$ = ecx

; 272  : 	void SetDgftSubMode (FCCSubMode dsm) {dgftSubMode = dsm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dsm$[ebp]
	mov	DWORD PTR [eax+152], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ENDP ; FireControlComputer::SetDgftSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv576 = -40						; size = 4
_pradar$1 = -36						; size = 4
tv591 = -32						; size = 4
tv559 = -28						; size = 4
tv445 = -24						; size = 4
tv211 = -20						; size = 4
tv87 = -16						; size = 4
_harmPod$2 = -12					; size = 4
_pradar$3 = -8						; size = 4
_this$ = -4						; size = 4
_newSubMode$ = 8					; size = 4
?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z PROC ; FireControlComputer::SetSubMode
; _this$ = ecx

; 337  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 	if (newSubMode == CCRP && 
; 339  : 		Sms && 
; 340  : 		Sms->Ownship() && 
; 341  : 		Sms->Ownship()->IsAirplane() && // MLR not always owned by a/c
; 342  : 		((AircraftClass *)(Sms->Ownship()))->af &&
; 343  : 		(!((AircraftClass *)Sms->Ownship())->af->IsSet(AirframeClass::IsDigital) || 
; 344  : 		(!(((AircraftClass *)(Sms->Ownship()))->AutopilotType() == AircraftClass::CombatAP))) && 
; 345  : 		platform && RadarDataTable[platform->GetRadarType()].NominalRange == 0.0) // JB 011018

	cmp	DWORD PTR _newSubMode$[ebp], 8
	jne	$LN63@SetSubMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+408], 0
	je	$LN63@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	test	eax, eax
	je	$LN63@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	mov	DWORD PTR tv87[ebp], eax
	mov	eax, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN63@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	cmp	DWORD PTR [eax+932], 0
	je	$LN63@SetSubMode
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN62@SetSubMode
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN63@SetSubMode
$LN62@SetSubMode:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+140], 0
	je	SHORT $LN63@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	imul	eax, 58					; 0000003aH
	mov	ecx, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	cvtss2sd xmm0, DWORD PTR [ecx+eax+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN63@SetSubMode

; 346  : 	{
; 347  : 		newSubMode = CCIP;

	mov	DWORD PTR _newSubMode$[ebp], 7
$LN63@SetSubMode:

; 348  : 	}
; 349  : 	
; 350  : 	// It has been stated (by Leon R) that changing modes while releasing weapons is bad, so...
; 351  : 	if (bombPickle) 

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+191]
	test	eax, eax
	je	SHORT $LN61@SetSubMode

; 352  : 	{
; 353  : 		return;

	jmp	$LN64@SetSubMode
$LN61@SetSubMode:

; 354  : 	}
; 355  : 	
; 356  : 	if (masterMode != Dogfight &&
; 357  : 		masterMode != MissileOverride)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 9
	je	SHORT $LN60@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 10			; 0000000aH
	je	SHORT $LN60@SetSubMode

; 358  : 	{
; 359  : 		lastSubMode = subMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+84], edx
$LN60@SetSubMode:

; 360  : 	}
; 361  : 	
; 362  : 	if (lastSubMode == BSGT ||
; 363  : 		lastSubMode == SLAVE || 
; 364  : 		lastSubMode == HARM ||
; 365  : 		lastSubMode == HTS )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 14			; 0000000eH
	je	SHORT $LN58@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+84], 15			; 0000000fH
	je	SHORT $LN58@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+84], 23			; 00000017H
	je	SHORT $LN58@SetSubMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 16			; 00000010H
	jne	SHORT $LN59@SetSubMode
$LN58@SetSubMode:

; 366  : 	{
; 367  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager
$LN59@SetSubMode:

; 368  : 	}
; 369  : 	
; 370  : 	subMode = newSubMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newSubMode$[ebp]
	mov	DWORD PTR [edx+148], eax

; 371  : 	// COBRA - RED - Default to immediate release Pickle Time
; 372  : 	PICKLE(DEFAULT_PICKLE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+520], 0

; 373  : 	switch (subMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR tv211[ebp], eax
	cmp	DWORD PTR tv211[ebp], 23		; 00000017H
	ja	$LN56@SetSubMode
	mov	ecx, DWORD PTR tv211[ebp]
	jmp	DWORD PTR $LN66@SetSubMode[ecx*4]
$LN55@SetSubMode:

; 374  : 	{
; 375  : 	case SAM:
; 376  : 		strcpy (subModeString, "SAM");

	push	OFFSET ??_C@_03DDIMFGBA@SAM?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 377  : 		Sms->SetWeaponType (wtNone);

	push	11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType

; 378  : 		Sms->FindWeaponClass (wcSamWpn);

	push	1
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass

; 379  : 		break;

	jmp	$LN56@SetSubMode
$LN54@SetSubMode:

; 380  : 		
; 381  : 	case Aim9:
; 382  : 		strcpy (subModeString, "SRM");

	push	OFFSET ??_C@_03CNOMELDJ@SRM?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 383  : 		if(Sms && Sms->Ownship() && ((AircraftClass *)Sms->Ownship())->AutopilotType() == AircraftClass::CombatAP  ) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+408], 0
	je	SHORT $LN52@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	test	eax, eax
	je	SHORT $LN52@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	jne	SHORT $LN52@SetSubMode

; 384  : 		{
; 385  : 			if(Sms->GetCoolState() == SMSClass::WARM && Sms->MasterArm() == SMSClass::Arm)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	test	eax, eax
	jne	SHORT $LN52@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 2
	jne	SHORT $LN52@SetSubMode

; 386  : 			{ // JPO aim9 cooling
; 387  : 				Sms->SetCoolState(SMSClass::COOLING);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState
$LN52@SetSubMode:

; 388  : 			}
; 389  : 		}
; 390  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 391  : 		break;

	jmp	$LN56@SetSubMode
$LN51@SetSubMode:

; 392  : 		
; 393  : 	case Aim120:
; 394  : 		strcpy (subModeString, "MRM");

	push	OFFSET ??_C@_03JNCKGLJF@MRM?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 395  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR); 

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 396  : 		// COBRA - RED - 1 Second Pickle for AIM 120
; 397  : 		PICKLE(SEC_1_PICKLE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 1000		; 000003e8H

; 398  : 		break;

	jmp	$LN56@SetSubMode
$LN50@SetSubMode:

; 399  : 		
; 400  : 	case EEGS:
; 401  : 		strcpy (subModeString, "EEGS");

	push	OFFSET ??_C@_04OBEHOCAG@EEGS?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 402  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 403  : 		break;

	jmp	$LN56@SetSubMode
$LN49@SetSubMode:

; 404  : 		
; 405  : 		// ASSOCIATOR 03/12/03: Added the combined SnapShot LCOS Gunmode SSLC 
; 406  : 	case SSLC:
; 407  : 		strcpy (subModeString, "SSLC");

	push	OFFSET ??_C@_04DNACHFNH@SSLC?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 400				; 00000190H
	push	eax
	call	_strcpy
	add	esp, 8

; 408  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 409  : 		break;

	jmp	$LN56@SetSubMode
$LN48@SetSubMode:

; 410  : 		
; 411  : 	case LCOS:
; 412  : 		strcpy (subModeString, "LCOS");

	push	OFFSET ??_C@_04MHCPIOBD@LCOS?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 413  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 414  : 		break;

	jmp	$LN56@SetSubMode
$LN47@SetSubMode:

; 415  : 		
; 416  : 	case Snapshot:
; 417  : 		strcpy (subModeString, "SNAP");

	push	OFFSET ??_C@_04PGEGCIFE@SNAP?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 418  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 419  : 		break;

	jmp	$LN56@SetSubMode
$LN46@SetSubMode:

; 420  : 		
; 421  : 	case CCIP:
; 422  : 		// MLR 4/1/2004 - rewrite based on Mirv's info.
; 423  : 		preDesignate = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 1

; 424  : 		strcpy (subModeString, "CCIP");

	push	OFFSET ??_C@_04GKNPDGLD@CCIP?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 425  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 426  : 		break;

	jmp	$LN56@SetSubMode
$LN45@SetSubMode:

; 427  : 		
; 428  : 	case CCRP:
; 429  : 		// MLR 4/1/2004 - rewrite based on Mirv's info.
; 430  : 		preDesignate = FALSE;		

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 0

; 431  : 		strcpy (subModeString, "CCRP");//me123 moved so we don't write this with no bombs

	push	OFFSET ??_C@_04HKKMHKCC@CCRP?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 432  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 433  : 		// 2001-04-18 ADDED BY S.G. I'LL SET MY RANDOM NUMBER FOR CCRP BOMBING INNACURACY NOW
; 434  : 		// Since autoTarget is a byte :-(  I'm limiting to just use the same value for both x and y offset :-(
; 435  : 		//		 autoTarget = (rand() & 0x3f) - 32; // In RP5, I'm limited to the variables I can use
; 436  : 		xBombAccuracy = (rand() & 0x3f) - 32;

	call	_rand
	and	eax, 63					; 0000003fH
	sub	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 437  : 		yBombAccuracy = (rand() & 0x3f) - 32;

	call	_rand
	and	eax, 63					; 0000003fH
	sub	eax, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+176], eax

; 438  : 		// COBRA - RED - 1 Second Pickle for CCRP
; 439  : 		PICKLE(SEC_1_PICKLE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 1000		; 000003e8H

; 440  : 		break;

	jmp	$LN56@SetSubMode
$LN44@SetSubMode:

; 441  : 		
; 442  : 	case DTOSS:
; 443  : 		preDesignate = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 1

; 444  : 		groundPipperAz = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+388], xmm0

; 445  : 		groundPipperEl = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+392], xmm0

; 446  : 		
; 447  : 		platform->SOIManager (SimVehicleClass::SOI_HUD);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 448  : 
; 449  : 		// MLR 4/1/2004 - rewrite based on Mirv's info.
; 450  : 		strcpy (subModeString, "DTOS");

	push	OFFSET ??_C@_04DKJBKKPE@DTOS?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 451  : 		// COBRA - RED - 1 Second Pickle for DTOSS
; 452  : 		PICKLE(SEC_1_PICKLE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 1000		; 000003e8H

; 453  : 		break;

	jmp	$LN56@SetSubMode
$LN43@SetSubMode:

; 454  : 		
; 455  : 	case LADD:
; 456  : 		preDesignate = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 0

; 457  : 		groundPipperAz = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+388], xmm0

; 458  : 		groundPipperEl = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+392], xmm0

; 459  : 		
; 460  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 461  : 
; 462  : 		// MLR 4/1/2004 - rewrite based on Mirv's info.
; 463  : 		strcpy (subModeString, "LADD");

	push	OFFSET ??_C@_04GEPACNOP@LADD?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 464  : 		break;

	jmp	$LN56@SetSubMode
$LN42@SetSubMode:

; 465  : 		
; 466  : 	case MAN: // JPO
; 467  : 		preDesignate = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 1

; 468  : 		strcpy (subModeString, "MAN");

	push	OFFSET ??_C@_03KIGHCFHP@MAN?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 469  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 470  : 		// COBRA - RED - 1 Second Pickle for MAN
; 471  : 		PICKLE(SEC_1_PICKLE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 1000		; 000003e8H

; 472  : 		break;

	jmp	$LN56@SetSubMode
$LN41@SetSubMode:

; 473  : 		
; 474  : 	case OBSOLETERCKT:
; 475  : 		preDesignate = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 1

; 476  : 		strcpy (subModeString, "RCKT");

	push	OFFSET ??_C@_04FALHJJOL@RCKT?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 477  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 478  : 		break;

	jmp	$LN56@SetSubMode
$LN40@SetSubMode:

; 479  : 		
; 480  : 	case STRAF:
; 481  : 		preDesignate = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 1

; 482  : 		strcpy (subModeString, "STRF");

	push	OFFSET ??_C@_04MLBKDHFB@STRF?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 483  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 484  : 		break;

	jmp	$LN56@SetSubMode
$LN39@SetSubMode:

; 485  : 		
; 486  : 	case BSGT:
; 487  : 		preDesignate = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 1

; 488  : 		groundPipperAz = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+388], xmm0

; 489  : 		groundPipperEl = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+392], xmm0

; 490  : 		strcpy (subModeString, "BSGT");

	push	OFFSET ??_C@_04GJFEKAJC@BSGT?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 491  : 		platform->SOIManager (SimVehicleClass::SOI_HUD);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 492  : 		break;

	jmp	$LN56@SetSubMode
$LN38@SetSubMode:

; 493  : 		
; 494  : 	case SLAVE:
; 495  : 		preDesignate = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 1

; 496  : 		groundPipperAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+388], xmm0

; 497  : 		groundPipperEl = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+392], xmm0

; 498  : 		strcpy (subModeString, "SLAV");

	push	OFFSET ??_C@_04KBFEHFJ@SLAV?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 400				; 00000190H
	push	eax
	call	_strcpy
	add	esp, 8

; 499  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 500  : 		// COBRA - RED - 1 Second Pickle for SLAVE
; 501  : 		PICKLE(SEC_1_PICKLE);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+520], 1000		; 000003e8H

; 502  : 		break;

	jmp	$LN56@SetSubMode
$LN37@SetSubMode:

; 503  : 		
; 504  : 	case HARM:
; 505  : 	case HTS:
; 506  : 		preDesignate = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 1

; 507  : 		groundPipperAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+388], xmm0

; 508  : 		groundPipperEl = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+392], xmm0

; 509  : 
; 510  : 		// RV - I-Hawk - on HUD it should read "HTS" for HTS and "HARM" for the HARM WPN mode usage
; 511  : 		if ( subMode == HTS )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+148], 16			; 00000010H
	jne	SHORT $LN36@SetSubMode

; 512  : 		{
; 513  :             strcpy (subModeString, "HTS");

	push	OFFSET ??_C@_03HKDINIMK@HTS?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8

; 514  : 		}
; 515  : 
; 516  : 		else 

	jmp	SHORT $LN35@SetSubMode
$LN36@SetSubMode:

; 517  : 		{
; 518  : 			strcpy (subModeString, "HARM");

	push	OFFSET ??_C@_04FIBJOPKE@HARM?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8
$LN35@SetSubMode:

; 519  : 		}
; 520  : 
; 521  : 		if (Sms->GetCurrentWeaponHardpoint() >= 0  && // JPO CTD fix
; 522  : 			Sms->CurHardpoint() >= 0 && // JB 010805 Possible CTD check curhardpoint
; 523  : 			Sms->hardPoint[Sms->CurHardpoint()] != NULL) // Cobra - Sms->GetCurrentWeaponHardpoint() was causing a CTD (returned with a very large number)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	test	eax, eax
	jl	$LN34@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	$LN34@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR [esi+4]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	$LN34@SetSubMode

; 524  : 		{
; 525  : 			Sms->SetWeaponType(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv445[ebp], edx
	mov	eax, DWORD PTR tv445[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv445[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType

; 526  : 
; 527  : 			// RV - I-Hawk - Don't auto pass SOI to HARM if we are using the advanced HARM systems
; 528  : 			HarmTargetingPod* harmPod = (HarmTargetingPod*)FindSensor(platform, SensorClass::HTS);

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _harmPod$2[ebp], eax

; 529  : 
; 530  : 			if ( harmPod && (harmPod->GetSubMode() == HarmTargetingPod::HAS ||
; 531  : 				 harmPod->GetSubMode() == HarmTargetingPod::HAD) )

	cmp	DWORD PTR _harmPod$2[ebp], 0
	je	SHORT $LN33@SetSubMode
	mov	ecx, DWORD PTR _harmPod$2[ebp]
	call	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
	cmp	eax, 1
	je	SHORT $LN32@SetSubMode
	mov	ecx, DWORD PTR _harmPod$2[ebp]
	call	?GetSubMode@HarmTargetingPod@@QAE?AW4Submode@1@XZ ; HarmTargetingPod::GetSubMode
	cmp	eax, 5
	jne	SHORT $LN33@SetSubMode
$LN32@SetSubMode:

; 532  : 			{
; 533  : 				platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 534  : 			}
; 535  : 
; 536  : 			else 

	jmp	SHORT $LN31@SetSubMode
$LN33@SetSubMode:

; 537  : 			{
; 538  : 				platform->SOIManager (SimVehicleClass::SOI_WEAPON); 

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager
$LN31@SetSubMode:

; 539  : 			}
; 540  : 		}
; 541  : 
; 542  : 		else

	jmp	SHORT $LN30@SetSubMode
$LN34@SetSubMode:

; 543  : 			Sms->SetWeaponType (wtNone);

	push	11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType
$LN30@SetSubMode:

; 544  : 		// COBRA - RED - 1 Second Pickle for HTS
; 545  : 		PICKLE(SEC_1_PICKLE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+520], 1000		; 000003e8H

; 546  : 		break;

	jmp	$LN56@SetSubMode
$LN29@SetSubMode:

; 547  : 		
; 548  : 	case TargetingPod:
; 549  : 		preDesignate = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+182], 1

; 550  : 		groundPipperAz = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+388], xmm0

; 551  : 		groundPipperEl = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+392], xmm0

; 552  : 		strcpy (subModeString, "GBU");

	push	OFFSET ??_C@_03GMKKLANI@GBU?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 553  : 		if (Sms->GetCurrentWeaponHardpoint() >= 0  && // JPO CTD fix
; 554  : 			Sms->CurHardpoint() >= 0 && // JB 010805 Possible CTD check curhardpoint
; 555  : 			Sms->hardPoint[Sms->GetCurrentWeaponHardpoint()] != NULL &&
; 556  : 			Sms->hardPoint[Sms->GetCurrentWeaponHardpoint()]->weaponPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	test	eax, eax
	jl	$LN28@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jl	$LN28@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	mov	ecx, DWORD PTR [esi+4]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN28@SetSubMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponHardpoint@SMSBaseClass@@QAEHXZ ; SMSBaseClass::GetCurrentWeaponHardpoint
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@SetSubMode

; 557  :             Sms->SetWeaponType(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponType());

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+408]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv559[ebp], eax
	mov	ecx, DWORD PTR tv559[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv559[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType

; 558  : 		else

	jmp	SHORT $LN27@SetSubMode
$LN28@SetSubMode:

; 559  :             Sms->SetWeaponType (wtNone);

	push	11					; 0000000bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType
$LN27@SetSubMode:

; 560  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 561  : 		// COBRA - RED - 1 Second Pickle for TGP
; 562  : 		PICKLE(SEC_1_PICKLE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+520], 1000		; 000003e8H

; 563  : 		break;

	jmp	SHORT $LN56@SetSubMode
$LN26@SetSubMode:

; 564  : 		
; 565  : 	case TimeToGo:
; 566  : 	case ETE:
; 567  : 	case ETA:
; 568  : 		platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager
$LN56@SetSubMode:

; 569  : 		break;
; 570  :    }
; 571  :    
; 572  :    // Make sure string is correct in override modes
; 573  :    switch (masterMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv576[ebp], ecx
	cmp	DWORD PTR tv576[ebp], 10		; 0000000aH
	je	SHORT $LN22@SetSubMode
	jmp	SHORT $LN24@SetSubMode

; 574  :    {
; 575  :    case Dogfight:
; 576  : 	   //strcpy (subModeString, "DGFT"); //JPG 29 Apr 04 - This is no longer displayed in new software tapes
; 577  : 	   break;

	jmp	SHORT $LN24@SetSubMode
$LN22@SetSubMode:

; 578  : 	   
; 579  :    case MissileOverride:
; 580  : 	   if (Sms->curWeaponType == Aim9)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	cmp	DWORD PTR [eax+148], 5
	jne	SHORT $LN21@SetSubMode

; 581  : 	   {
; 582  : 			strcpy (subModeString, "SRM");

	push	OFFSET ??_C@_03CNOMELDJ@SRM?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN21@SetSubMode:

; 583  : 	   }
; 584  : 	   if (Sms->curWeaponType == Aim120)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	cmp	DWORD PTR [eax+148], 6
	jne	SHORT $LN20@SetSubMode

; 585  : 	   {
; 586  : 			strcpy (subModeString, "MRM");

	push	OFFSET ??_C@_03JNCKGLJF@MRM?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN20@SetSubMode:
$LN24@SetSubMode:

; 587  : 	   }
; 588  : 	   break;
; 589  :    }
; 590  :    
; 591  :    // MLR 4/1/2004 - Memorize SubMode 
; 592  :    switch(masterMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR tv591[ebp], eax
	cmp	DWORD PTR tv591[ebp], 10		; 0000000aH
	ja	$LN18@SetSubMode
	mov	ecx, DWORD PTR tv591[ebp]
	jmp	DWORD PTR $LN67@SetSubMode[ecx*4]

; 593  :    {
; 594  :    case ILS:
; 595  :    case Nav:
; 596  : 	   break;

	jmp	$LN18@SetSubMode
$LN16@SetSubMode:

; 597  : 	   
; 598  :    case Dogfight:
; 599  : 	   lastDogfightGunSubMode = subMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+64], ecx

; 600  : 	   break;

	jmp	$LN18@SetSubMode
$LN15@SetSubMode:

; 601  : 	   
; 602  :    case MissileOverride:
; 603  : 	   lastMissileOverrideSubMode = subMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+60], ecx

; 604  : 	   break;

	jmp	$LN18@SetSubMode
$LN14@SetSubMode:

; 605  : 	   
; 606  :    case AAGun:
; 607  : 	   lastAirAirGunSubMode = subMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+52], ecx

; 608  : 	   break;

	jmp	$LN18@SetSubMode
$LN13@SetSubMode:

; 609  : 	   
; 610  :    case Missile:
; 611  : 	   lastAirAirSubMode = subMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+44], ecx

; 612  : 	   break;

	jmp	$LN18@SetSubMode
$LN12@SetSubMode:

; 613  : 	   
; 614  :    case AGGun:
; 615  : 	   lastAirGroundGunSubMode = subMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+56], ecx

; 616  : 	   break;

	jmp	$LN18@SetSubMode
$LN11@SetSubMode:

; 617  : 	   
; 618  :    case AirGroundBomb:
; 619  : 	    Sms->SetAGBSubMode(subMode);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?SetAGBSubMode@SMSClass@@QAEXW4FCCSubMode@FireControlComputer@@@Z ; SMSClass::SetAGBSubMode

; 620  : 		{
; 621  : 			if (playerFCC && SimDriver.GetPlayerAircraft()->AutopilotType() != AircraftClass::CombatAP)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	$LN10@SetSubMode
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN10@SetSubMode

; 622  : 			{
; 623  :  				RadarDopplerClass* pradar = (RadarDopplerClass*) FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$3[ebp], eax

; 624  : 				if(g_bRealisticAvionics && pradar)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN9@SetSubMode
	cmp	DWORD PTR _pradar$3[ebp], 0
	je	SHORT $LN9@SetSubMode

; 625  : 				{
; 626  : 					if(subMode == CCRP || subMode == MAN)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+148], 8
	je	SHORT $LN7@SetSubMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+148], 21			; 00000015H
	jne	SHORT $LN8@SetSubMode
$LN7@SetSubMode:

; 627  : 					{
; 628  : 						pradar->SelectLastAGMode();

	mov	edx, DWORD PTR _pradar$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pradar$3[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx

; 629  : 					}
; 630  : 					else

	jmp	SHORT $LN6@SetSubMode
$LN8@SetSubMode:

; 631  : 					{
; 632  : 						pradar->DefaultAGMode();

	mov	eax, DWORD PTR _pradar$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$3[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
$LN6@SetSubMode:

; 633  : 					}
; 634  : 					pradar->SetScanDir(1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pradar$3[ebp]
	call	?SetScanDir@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::SetScanDir
$LN9@SetSubMode:

; 635  : 				}
; 636  : 			}
; 637  : 			else

	jmp	SHORT $LN5@SetSubMode
$LN10@SetSubMode:

; 638  : 			{
; 639  :  				RadarClass* pradar = (RadarClass*) FindSensor (platform, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 640  : 				pradar->DefaultAGMode();

	mov	eax, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
$LN5@SetSubMode:

; 641  : 			}
; 642  : 		}
; 643  : 	   break;

	jmp	SHORT $LN18@SetSubMode

; 644  :    case AirGroundMissile:
; 645  : 	   //lastAirGroundMissileSubMode = subMode;
; 646  : 	   break;

	jmp	SHORT $LN18@SetSubMode

; 647  :    case AirGroundHARM:
; 648  : 	   //lastAirGroundHARMSubMode    = subMode;
; 649  : 	   break;

	jmp	SHORT $LN18@SetSubMode
$LN2@SetSubMode:

; 650  :    case AirGroundLaser:
; 651  : 	   lastAirGroundLaserSubMode   = subMode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR [ecx+48], eax
$LN18@SetSubMode:
$LN64@SetSubMode:

; 652  : 	   break;
; 653  :    case AirGroundCamera:
; 654  : 	   //lastAirGroundCameraSubMode  = subMode;
; 655  : 	   break;
; 656  :    }
; 657  :    
; 658  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN66@SetSubMode:
	DD	$LN50@SetSubMode
	DD	$LN49@SetSubMode
	DD	$LN48@SetSubMode
	DD	$LN47@SetSubMode
	DD	$LN55@SetSubMode
	DD	$LN54@SetSubMode
	DD	$LN51@SetSubMode
	DD	$LN46@SetSubMode
	DD	$LN45@SetSubMode
	DD	$LN43@SetSubMode
	DD	$LN44@SetSubMode
	DD	$LN41@SetSubMode
	DD	$LN40@SetSubMode
	DD	$LN56@SetSubMode
	DD	$LN39@SetSubMode
	DD	$LN38@SetSubMode
	DD	$LN37@SetSubMode
	DD	$LN29@SetSubMode
	DD	$LN26@SetSubMode
	DD	$LN26@SetSubMode
	DD	$LN26@SetSubMode
	DD	$LN42@SetSubMode
	DD	$LN56@SetSubMode
	DD	$LN37@SetSubMode
$LN67@SetSubMode:
	DD	$LN14@SetSubMode
	DD	$LN12@SetSubMode
	DD	$LN13@SetSubMode
	DD	$LN18@SetSubMode
	DD	$LN18@SetSubMode
	DD	$LN11@SetSubMode
	DD	$LN18@SetSubMode
	DD	$LN18@SetSubMode
	DD	$LN2@SetSubMode
	DD	$LN16@SetSubMode
	DD	$LN15@SetSubMode
?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ENDP ; FireControlComputer::SetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv602 = -48						; size = 4
tv314 = -44						; size = 4
tv269 = -40						; size = 4
tv231 = -36						; size = 4
tv199 = -32						; size = 4
tv157 = -28						; size = 4
_harmPod$ = -24						; size = 4
tv201 = -20						; size = 4
_oldMode$ = -16						; size = 4
_theRadar$ = -12					; size = 4
_isAI$ = -8						; size = 4
_this$ = -4						; size = 4
_newMode$ = 8						; size = 4
?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z PROC ; FireControlComputer::SetMasterMode
; _this$ = ecx

; 1538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1539 : 	RadarClass* theRadar = (RadarClass*) FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 1540 : 	FCCMasterMode oldMode;
; 1541 : 	HarmTargetingPod* harmPod = (HarmTargetingPod*) FindSensor (platform, SensorClass::HTS); 

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _harmPod$[ebp], eax

; 1542 : 	
; 1543 : 	/* appears to not be needed anymore
; 1544 : 	if( playerFCC                                                  && 
; 1545 : 		(masterMode == Dogfight || masterMode == MissileOverride)  &&
; 1546 : 		newMode != MissileOverride                                 && 
; 1547 : 		newMode != Dogfight                                        &&
; 1548 : 		(Sms->curWeaponType == wtAim9 || Sms->curWeaponType == wtAim120 ))  // MLR 1/19/2004 - put these two in parenthesis
; 1549 : 		
; 1550 : 	{
; 1551 : 		if ( masterMode == MissileOverride ) 
; 1552 : 			weaponMisOvrdMode = Sms->curWeaponType;
; 1553 : 		else 
; 1554 : 			if ( masterMode == Dogfight ) 
; 1555 : 				weaponDogOvrdMode = Sms->curWeaponType;
; 1556 : 			else 
; 1557 : 				weaponNoOvrdMode = Sms->curWeaponType;
; 1558 : 	}
; 1559 : 	*/
; 1560 : 	
; 1561 : 	
; 1562 : 	// Nav only if Amux and Bmux failed, no change if FCC fail
; 1563 : 	if(playerFCC &&
; 1564 : 		(
; 1565 : 		(
; 1566 :         ((AircraftClass*)platform)->mFaults->GetFault(FaultClass::fcc_fault)
; 1567 : 		)
; 1568 : 		||
; 1569 : 		(
; 1570 :         ((AircraftClass*)platform)->mFaults->GetFault(FaultClass::amux_fault) &&
; 1571 :         ((AircraftClass*)platform)->mFaults->GetFault(FaultClass::bmux_fault) &&
; 1572 :         newMode != Nav
; 1573 : 		)
; 1574 : 		)
; 1575 : 		)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN95@SetMasterM
	push	11					; 0000000bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN94@SetMasterM
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN95@SetMasterM
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN95@SetMasterM
	cmp	DWORD PTR _newMode$[ebp], 4
	je	SHORT $LN95@SetMasterM
$LN94@SetMasterM:

; 1576 : 		return;

	jmp	$LN96@SetMasterM
$LN95@SetMasterM:

; 1577 : 	
; 1578 : 	// It has been stated (by Leon R) that changing modes while releasing weapons is bad, so...
; 1579 : 	if (bombPickle) 

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+191]
	test	eax, eax
	je	SHORT $LN93@SetMasterM

; 1580 : 	{
; 1581 : 		return;

	jmp	$LN96@SetMasterM
$LN93@SetMasterM:

; 1582 : 	}
; 1583 : 
; 1584 : 	switch (masterMode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR tv157[ebp], edx
	cmp	DWORD PTR tv157[ebp], 7
	je	SHORT $LN88@SetMasterM
	cmp	DWORD PTR tv157[ebp], 12		; 0000000cH
	je	SHORT $LN90@SetMasterM
	jmp	SHORT $LN91@SetMasterM
$LN90@SetMasterM:

; 1585 : 	{
; 1586 : 	case ClearOveride:		
; 1587 : 		if (theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN89@SetMasterM

; 1588 : 			theRadar->ClearOverride();

	mov	eax, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
$LN89@SetMasterM:

; 1589 : 		break;	

	jmp	SHORT $LN91@SetMasterM
$LN88@SetMasterM:

; 1590 : 	// Clear any holdouts from previous modes
; 1591 : 	case AirGroundHARM:
; 1592 : 		((AircraftClass*)platform)->SetTarget (NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
$LN91@SetMasterM:

; 1593 : 		break;
; 1594 : 	}
; 1595 : 	
; 1596 : 	oldMode = masterMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _oldMode$[ebp], eax

; 1597 : 	if (masterMode != Dogfight && masterMode != MissileOverride) masterMode = newMode;//me123

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 9
	je	SHORT $LN87@SetMasterM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 10			; 0000000aH
	je	SHORT $LN87@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newMode$[ebp]
	mov	DWORD PTR [eax+144], ecx
$LN87@SetMasterM:

; 1598 : 
; 1599 : 	int isAI = !playerFCC ||
; 1600 : 		( playerFCC && ((AircraftClass *)Sms->Ownship())->AutopilotType() == AircraftClass::CombatAP) ;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN99@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN98@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?Ownship@SMSBaseClass@@QAEPAVSimVehicleClass@@XZ ; SMSBaseClass::Ownship
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN99@SetMasterM
$LN98@SetMasterM:
	mov	DWORD PTR tv199[ebp], 0
	jmp	SHORT $LN100@SetMasterM
$LN99@SetMasterM:
	mov	DWORD PTR tv199[ebp], 1
$LN100@SetMasterM:
	mov	edx, DWORD PTR tv199[ebp]
	mov	DWORD PTR _isAI$[ebp], edx

; 1601 : 
; 1602 : 	
; 1603 : 	switch (masterMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR tv201[ebp], ecx
	mov	edx, DWORD PTR tv201[ebp]
	sub	edx, 2
	mov	DWORD PTR tv201[ebp], edx
	cmp	DWORD PTR tv201[ebp], 11		; 0000000bH
	ja	$LN85@SetMasterM
	mov	eax, DWORD PTR tv201[ebp]
	jmp	DWORD PTR $LN101@SetMasterM[eax*4]
$LN84@SetMasterM:

; 1604 : 	{
; 1605 : 	case Dogfight:
; 1606 : 		// Clear out any non-air-to-air targets we had locked.
; 1607 : 		if (oldMode != Dogfight && oldMode != Missile && oldMode != MissileOverride)

	cmp	DWORD PTR _oldMode$[ebp], 9
	je	SHORT $LN83@SetMasterM
	cmp	DWORD PTR _oldMode$[ebp], 2
	je	SHORT $LN83@SetMasterM
	cmp	DWORD PTR _oldMode$[ebp], 10		; 0000000aH
	je	SHORT $LN83@SetMasterM

; 1608 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget
$LN83@SetMasterM:

; 1609 : 
; 1610 : 		//if (oldMode != Dogfight)// MLR 4/11/2004 -  I'ld like to remove these, but the AI still calls SMM() directly
; 1611 : 			//Sms->SetCurrentHpByWeaponId(lastDogfightWId);
; 1612 : 		//	Sms->SetCurrentHardPoint(lastDogfightHp);
; 1613 : 		
; 1614 : 		postDrop = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+183], 0

; 1615 : 		//MI changed so it remembers last gun submode too
; 1616 : 		if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN82@SetMasterM

; 1617 : 			SetSubMode (EEGS);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1618 : 		else

	jmp	SHORT $LN81@SetMasterM
$LN82@SetMasterM:

; 1619 : 			SetSubMode(lastDogfightGunSubMode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN81@SetMasterM:

; 1620 : 
; 1621 : 		if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN80@SetMasterM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN80@SetMasterM

; 1622 : 			if(!Sms->FindWeaponType (wtAim9))

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN80@SetMasterM

; 1623 : 				Sms->FindWeaponType(wtAim120);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN80@SetMasterM:

; 1624 : 
; 1625 : 		switch(Sms->curWeaponType)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR tv231[ebp], eax
	cmp	DWORD PTR tv231[ebp], 1
	je	SHORT $LN76@SetMasterM
	cmp	DWORD PTR tv231[ebp], 2
	je	SHORT $LN75@SetMasterM
	jmp	SHORT $LN77@SetMasterM
$LN76@SetMasterM:

; 1626 : 		{
; 1627 : 		case wtAim9:
; 1628 : 			SetDgftSubMode(Aim9);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetDgftSubMode

; 1629 : 			break;

	jmp	SHORT $LN77@SetMasterM
$LN75@SetMasterM:

; 1630 : 		case wtAim120:
; 1631 : 			SetDgftSubMode(Aim120);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDgftSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetDgftSubMode
$LN77@SetMasterM:

; 1632 : 			break;
; 1633 : 		}
; 1634 : 
; 1635 : 		if (theRadar && oldMode != Dogfight)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN74@SetMasterM
	cmp	DWORD PTR _oldMode$[ebp], 9
	je	SHORT $LN74@SetMasterM

; 1636 : 		{ 
; 1637 : 			theRadar->SetSRMOverride();

	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN74@SetMasterM:

; 1638 : 		} 
; 1639 : 		if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN73@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN73@SetMasterM

; 1640 : 		{ 
; 1641 : 			TheHud->headingPos = HudClass::Low;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4964], 1
$LN73@SetMasterM:

; 1642 : 		} 
; 1643 : 		break;

	jmp	$LN85@SetMasterM
$LN72@SetMasterM:

; 1644 : 	case MissileOverride://me123 multi changes here 
; 1645 : 		//strcpy (subModeString, "MSL");  // JPG 20 Jan 04
; 1646 : 		// Clear out any non-air-to-air targets we had locked.
; 1647 : 		if (oldMode != Dogfight && oldMode != Missile && oldMode != MissileOverride)

	cmp	DWORD PTR _oldMode$[ebp], 9
	je	SHORT $LN71@SetMasterM
	cmp	DWORD PTR _oldMode$[ebp], 2
	je	SHORT $LN71@SetMasterM
	cmp	DWORD PTR _oldMode$[ebp], 10		; 0000000aH
	je	SHORT $LN71@SetMasterM

; 1648 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget
$LN71@SetMasterM:

; 1649 : 		postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 1650 : 
; 1651 : 		//if (oldMode != MissileOverride)// MLR 4/11/2004 -  I'ld like to remove these, but the AI still calls SMM() directly
; 1652 : 		//	Sms->SetCurrentHardPoint(lastMissileOverrideHp);
; 1653 : //			Sms->SetCurrentHpByWeaponId(lastMissileOverrideWId);
; 1654 : 
; 1655 : 
; 1656 : 		if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN70@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN70@SetMasterM

; 1657 : 			if(!Sms->FindWeaponType (wtAim120))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN70@SetMasterM

; 1658 : 				Sms->FindWeaponType (wtAim9);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN70@SetMasterM:

; 1659 : 
; 1660 : 		switch(Sms->curWeaponType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR tv269[ebp], edx
	cmp	DWORD PTR tv269[ebp], 1
	je	SHORT $LN66@SetMasterM
	cmp	DWORD PTR tv269[ebp], 2
	je	SHORT $LN65@SetMasterM
	jmp	SHORT $LN67@SetMasterM
$LN66@SetMasterM:

; 1661 : 		{
; 1662 : 		case wtAim9:
; 1663 : 			SetSubMode(Aim9);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1664 : 			SetMrmSubMode(Aim9);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetMrmSubMode

; 1665 : 			break;

	jmp	SHORT $LN67@SetMasterM
$LN65@SetMasterM:

; 1666 : 		case wtAim120:
; 1667 : 			SetSubMode(Aim120);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1668 : 			SetMrmSubMode(Aim120);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMrmSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetMrmSubMode
$LN67@SetMasterM:

; 1669 : 			break;
; 1670 : 		}
; 1671 : 			
; 1672 : 		if (theRadar )

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN64@SetMasterM

; 1673 : 		{
; 1674 :             theRadar->SetMRMOverride();

	mov	eax, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
$LN64@SetMasterM:

; 1675 : 		}
; 1676 : 		if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN63@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN63@SetMasterM

; 1677 :             TheHud->headingPos = HudClass::Low;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4964], 1
$LN63@SetMasterM:

; 1678 : 		break;

	jmp	$LN85@SetMasterM
$LN62@SetMasterM:

; 1679 : 		
; 1680 : 	case Missile:
; 1681 : 		// Clear out any non-air-to-air targets we had locked.
; 1682 : 		if (oldMode != Dogfight && oldMode != MissileOverride)

	cmp	DWORD PTR _oldMode$[ebp], 9
	je	SHORT $LN61@SetMasterM
	cmp	DWORD PTR _oldMode$[ebp], 10		; 0000000aH
	je	SHORT $LN61@SetMasterM

; 1683 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget
$LN61@SetMasterM:

; 1684 : 		postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 1685 : 		
; 1686 : 		//if(oldMode != masterMode) // MLR 4/11/2004 -  I'ld like to remove these, but the AI still calls SMM() directly
; 1687 : 		//	Sms->SetCurrentHardPoint(lastAirAirHp);
; 1688 : 		
; 1689 : 		//MonoPrint("FCC:SetMasterMode - 1. CurrentWeaponType=%d\n",Sms->GetCurrentWeaponType());
; 1690 : 		
; 1691 : 		// make sure the AI get a proper weapon
; 1692 : 		if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN60@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN60@SetMasterM

; 1693 : 			if(!Sms->FindWeaponType (wtAim120))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN60@SetMasterM

; 1694 : 				Sms->FindWeaponType (wtAim9);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN60@SetMasterM:

; 1695 : 					
; 1696 : 		
; 1697 : 		switch(Sms->GetCurrentWeaponType())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?GetCurrentWeaponType@SMSBaseClass@@QAE?AW4WeaponType@@XZ ; SMSBaseClass::GetCurrentWeaponType
	mov	DWORD PTR tv314[ebp], eax
	cmp	DWORD PTR tv314[ebp], 1
	je	SHORT $LN55@SetMasterM
	cmp	DWORD PTR tv314[ebp], 2
	je	SHORT $LN56@SetMasterM
	jmp	SHORT $LN57@SetMasterM
$LN56@SetMasterM:

; 1698 : 		{
; 1699 : 		case wtAim120:
; 1700 : 			SetSubMode(Aim120);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1701 : 			break;

	jmp	SHORT $LN57@SetMasterM
$LN55@SetMasterM:

; 1702 : 		case wtAim9:
; 1703 : 			SetSubMode(Aim9);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN57@SetMasterM:

; 1704 : 			break;
; 1705 : 		}
; 1706 : 		
; 1707 : 		if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN54@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN54@SetMasterM

; 1708 :             TheHud->headingPos = HudClass::Low;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4964], 1
$LN54@SetMasterM:

; 1709 : 		break;

	jmp	$LN85@SetMasterM
$LN53@SetMasterM:

; 1710 : 		
; 1711 : 	case ILS:
; 1712 : 			// Clear out any previous targets we had locked.
; 1713 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1714 : 			Sms->SetWeaponType (wtNone);

	push	11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType

; 1715 : 			Sms->FindWeaponClass (wcNoWpn);

	push	1
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass

; 1716 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN52@SetMasterM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN52@SetMasterM

; 1717 : 				TheHud->headingPos = HudClass::High;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+4964], 0
$LN52@SetMasterM:

; 1718 : 			platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 1719 : 			break;

	jmp	$LN85@SetMasterM
$LN51@SetMasterM:

; 1720 : 			
; 1721 : 		case Nav:
; 1722 : 			// Clear out any previous targets we had locked.
; 1723 : 			strcpy (subModeString, "NAV");

	push	OFFSET ??_C@_03DIMJBCMI@NAV?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 400				; 00000190H
	push	edx
	call	_strcpy
	add	esp, 8

; 1724 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1725 : 			Sms->SetWeaponType (wtNone);

	push	11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?SetWeaponType@SMSClass@@QAEXW4WeaponType@@@Z ; SMSClass::SetWeaponType

; 1726 : 			Sms->FindWeaponClass (wcNoWpn);

	push	1
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass

; 1727 : 			SetSubMode (ETE);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1728 : 			releaseConsent = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+181], 0

; 1729 : 			postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 1730 : 			preDesignate = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 1

; 1731 : 			postDrop = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+183], 0

; 1732 : 			bombPickle = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+191], 0

; 1733 : 			// Find currentwaypoint
; 1734 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN50@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN50@SetMasterM

; 1735 : 			{
; 1736 : 				TheHud->headingPos = HudClass::Low;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4964], 1
$LN50@SetMasterM:

; 1737 : 			}
; 1738 : 			
; 1739 : 			// SOI is RADAR in NAV
; 1740 : 		//Cobra test Double here since ETE above sets SOI_RADAR
; 1741 : 			//platform->SOIManager (SimVehicleClass::SOI_RADAR);
; 1742 : 			break;

	jmp	$LN85@SetMasterM
$LN49@SetMasterM:

; 1743 : 			
; 1744 : 		case AirGroundBomb:
; 1745 : 			// Clear out any previous targets we had locked.
; 1746 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1747 : 			preDesignate = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 1

; 1748 : 			postDrop = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+183], 0

; 1749 : 			inRange = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+216], 1

; 1750 : 
; 1751 : 			if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN48@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN48@SetMasterM

; 1752 : 				Sms->FindWeaponClass (wcBombWpn);

	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
$LN48@SetMasterM:

; 1753 : 			
; 1754 : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN47@SetMasterM

; 1755 : 			{
; 1756 : 				SetSubMode(Sms->GetAGBSubMode());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?GetAGBSubMode@SMSClass@@QAE?AW4FCCSubMode@FireControlComputer@@XZ ; SMSClass::GetAGBSubMode
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1757 : 			}
; 1758 : 			else

	jmp	SHORT $LN46@SetMasterM
$LN47@SetMasterM:

; 1759 : 			{
; 1760 : 				SetSubMode(CCIP);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN46@SetMasterM:

; 1761 : 			}
; 1762 : 
; 1763 : 			//if(playerFCC) 
; 1764 : 			//{
; 1765 : 			//	Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);
; 1766 : 			///}
; 1767 : 
; 1768 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN45@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN45@SetMasterM

; 1769 : 				TheHud->headingPos = HudClass::High;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4964], 0
$LN45@SetMasterM:

; 1770 : 			break;

	jmp	$LN85@SetMasterM
$LN44@SetMasterM:

; 1771 : 
; 1772 : 		case AirGroundRocket:
; 1773 : 			// Clear out any previous targets we had locked.
; 1774 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1775 : 			preDesignate = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+182], 1

; 1776 : 			postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 1777 : 			inRange = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], 1

; 1778 : 
; 1779 : 			if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN43@SetMasterM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN43@SetMasterM

; 1780 : 				Sms->FindWeaponClass (wcRocketWpn);

	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
$LN43@SetMasterM:

; 1781 : 	
; 1782 : 			SetSubMode (OBSOLETERCKT);

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1783 : 			/*
; 1784 : 			if(!playerFCC)
; 1785 : 			{
; 1786 : 				SetSubMode (OBSOLETERCKT);
; 1787 : 			}
; 1788 : 			else
; 1789 : 			{
; 1790 : 				if(g_bRealisticAvionics)
; 1791 : 				{
; 1792 : 					SetSubMode (Sms->GetAGBSubMode());
; 1793 : 				}
; 1794 : 				else
; 1795 : 				{
; 1796 : 					SetSubMode (OBSOLETERCKT);
; 1797 : 				}
; 1798 : 			}
; 1799 : 			*/
; 1800 : 
; 1801 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN42@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN42@SetMasterM

; 1802 : 				TheHud->headingPos = HudClass::High;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4964], 0
$LN42@SetMasterM:

; 1803 : 			break;

	jmp	$LN85@SetMasterM
$LN41@SetMasterM:

; 1804 : 			
; 1805 : 		case AirGroundMissile:
; 1806 : 			// Clear out any previous targets we had locked.
; 1807 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1808 : 			preDesignate = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+182], 1

; 1809 : 			postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 1810 : 			inRange = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], 1

; 1811 : 			missileTarget = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+192], 0

; 1812 : 
; 1813 : 			if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN40@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN40@SetMasterM

; 1814 : 				Sms->FindWeaponType (wtAgm65);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN40@SetMasterM:

; 1815 : 
; 1816 : 			if(WeaponClassMatchesMaster(Sms->curWeaponClass))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	je	SHORT $LN39@SetMasterM

; 1817 : 			{
; 1818 : 
; 1819 : 				if(playerFCC)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN38@SetMasterM

; 1820 : 				{
; 1821 : 					this->
; 1822 : 					Sms->StepMavSubMode(TRUE); // TRUE means initial step

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z	; SMSBaseClass::StepMavSubMode
$LN38@SetMasterM:

; 1823 : 				}
; 1824 : 				/*
; 1825 : 				if (PlayerOptions.GetAvionicsType() == ATRealistic || 
; 1826 : 					PlayerOptions.GetAvionicsType() == ATRealisticAV)
; 1827 : 					SetSubMode (BSGT);
; 1828 : 				else
; 1829 : 					SetSubMode (SLAVE);
; 1830 : 				*/
; 1831 : 			}
; 1832 : 			else

	jmp	SHORT $LN37@SetMasterM
$LN39@SetMasterM:

; 1833 : 			{
; 1834 : 				if(playerFCC) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN37@SetMasterM

; 1835 : 				{
; 1836 : 					Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	ecx, DWORD PTR [edx+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN37@SetMasterM:

; 1837 : 				}
; 1838 : 			}
; 1839 : 
; 1840 : 
; 1841 : 			/*
; 1842 : 			if (Sms->curWeaponClass != wcAgmWpn)
; 1843 : 			{
; 1844 : 				if (Sms->FindWeaponClass (wcAgmWpn) && Sms->CurHardpoint() >= 0) // JB 010805 Possible CTD check curhardpoint
; 1845 : 				{
; 1846 : 					Sms->SetWeaponType(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponType());
; 1847 : 					switch (Sms->curWeaponType)
; 1848 : 					{
; 1849 : 					case wtAgm65:
; 1850 : 						// M.N. added full realism mode
; 1851 : 						if (PlayerOptions.GetAvionicsType() == ATRealistic || PlayerOptions.GetAvionicsType() == ATRealisticAV)
; 1852 : 							SetSubMode (BSGT);
; 1853 : 						else
; 1854 : 							SetSubMode (SLAVE);
; 1855 : 						break;
; 1856 : 					}
; 1857 : 				}
; 1858 : 				else
; 1859 : 				{
; 1860 : 					Sms->SetWeaponType (wtNone);
; 1861 : 					
; 1862 : 					if( playerFCC )
; 1863 : 					{
; 1864 : 						Sms->GetNextWeapon(wdGround);
; 1865 : 						Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);
; 1866 : 					}
; 1867 : 				}
; 1868 : 			}
; 1869 : 			*/
; 1870 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN35@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN35@SetMasterM

; 1871 : 				TheHud->headingPos = HudClass::High;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4964], 0
$LN35@SetMasterM:

; 1872 : 			break;

	jmp	$LN85@SetMasterM
$LN34@SetMasterM:

; 1873 : 			
; 1874 : 		case AirGroundHARM:
; 1875 : 			// Clear out any previous targets we had locked.
; 1876 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1877 : 			preDesignate = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+182], 1

; 1878 : 			postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 1879 : 
; 1880 : 			// RV - I-Hawk - Get into the right HARM modes
; 1881 : 			if( isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass) )

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN33@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN33@SetMasterM

; 1882 : 			{
; 1883 : 				Sms->FindWeaponType (wtAgm88);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN33@SetMasterM:

; 1884 : 			}
; 1885 : 
; 1886 : 			if ( isAI )

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN32@SetMasterM

; 1887 : 			{
; 1888 : 				harmPod->SetSubMode ( HarmTargetingPod::HAS );

	push	1
	mov	ecx, DWORD PTR _harmPod$[ebp]
	call	?SetSubMode@HarmTargetingPod@@QAEXW4Submode@1@@Z ; HarmTargetingPod::SetSubMode

; 1889 : 				harmPod->SetHandedoff ( true ); // AI doesn't need any target hadnoff delay

	push	1
	mov	ecx, DWORD PTR _harmPod$[ebp]
	call	?SetHandedoff@HarmTargetingPod@@QAEX_N@Z ; HarmTargetingPod::SetHandedoff

; 1890 : 			}
; 1891 : 
; 1892 : 			else

	jmp	SHORT $LN31@SetMasterM
$LN32@SetMasterM:

; 1893 : 			{
; 1894 : 				harmPod->SetSubMode( HarmTargetingPod::HarmModeChooser );

	push	0
	mov	ecx, DWORD PTR _harmPod$[ebp]
	call	?SetSubMode@HarmTargetingPod@@QAEXW4Submode@1@@Z ; HarmTargetingPod::SetSubMode
$LN31@SetMasterM:

; 1895 : 			}
; 1896 : 
; 1897 : 			/*
; 1898 : 			if (Sms->curWeaponClass != wcHARMWpn)
; 1899 : 			{
; 1900 : 				if (Sms->FindWeaponClass (wcHARMWpn, FALSE) && Sms->CurHardpoint() >= 0) // JB 010805 Possible CTD check curhardpoint
; 1901 : 				{
; 1902 : 					Sms->SetWeaponType(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponType());
; 1903 : 					switch (Sms->curWeaponType)
; 1904 : 					{
; 1905 : 					case wtAgm88:
; 1906 : 						SetSubMode (HTS);
; 1907 : 						break;
; 1908 : 					}
; 1909 : 				}
; 1910 : 				else
; 1911 : 				{
; 1912 : 					Sms->SetWeaponType (wtNone);
; 1913 : 					
; 1914 : 					if( playerFCC )
; 1915 : 					{
; 1916 : 						Sms->GetNextWeapon(wdGround);
; 1917 : 						Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);
; 1918 : 					}
; 1919 : 				}
; 1920 : 			}
; 1921 : 			*/
; 1922 : 
; 1923 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN30@SetMasterM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN30@SetMasterM

; 1924 : 			{
; 1925 : 				TheHud->headingPos = HudClass::High;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+4964], 0
$LN30@SetMasterM:

; 1926 : 			}
; 1927 : 
; 1928 : 			break;

	jmp	$LN85@SetMasterM
$LN29@SetMasterM:

; 1929 : 			
; 1930 : 		case AirGroundLaser:
; 1931 : 			// Clear out any previous targets we had locked.
; 1932 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 1933 : 			preDesignate = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+182], 1

; 1934 : 			postDrop = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+183], 0

; 1935 : 
; 1936 : 			if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN28@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN28@SetMasterM

; 1937 : 				Sms->FindWeaponType (wtGBU);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN28@SetMasterM:

; 1938 : 
; 1939 : 			if(WeaponClassMatchesMaster(Sms->curWeaponClass))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	je	SHORT $LN27@SetMasterM

; 1940 : 			{
; 1941 : 				if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN26@SetMasterM

; 1942 : 				{
; 1943 : 					//Mi this isn't true... doc states you start off in SLAVE
; 1944 : 					if (PlayerOptions.GetAvionicsType() == ATRealistic)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	jne	SHORT $LN25@SetMasterM

; 1945 : 						SetSubMode (BSGT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1946 : 					else

	jmp	SHORT $LN24@SetMasterM
$LN25@SetMasterM:

; 1947 : 						SetSubMode (SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN24@SetMasterM:

; 1948 : 				}
; 1949 : 				else

	jmp	SHORT $LN23@SetMasterM
$LN26@SetMasterM:

; 1950 : 				{
; 1951 : 					InhibitFire = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+425], 0

; 1952 : 					// M.N. added full realism mode
; 1953 : 					if( PlayerOptions.GetAvionicsType() != ATRealistic && 
; 1954 : 						PlayerOptions.GetAvionicsType() != ATRealisticAV)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	je	SHORT $LN22@SetMasterM
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 3
	je	SHORT $LN22@SetMasterM

; 1955 : 						SetSubMode (BSGT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 1956 : 					else

	jmp	SHORT $LN23@SetMasterM
$LN22@SetMasterM:

; 1957 : 						SetSubMode (SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN23@SetMasterM:

; 1958 : 				} 
; 1959 : 			}
; 1960 : 			else

	jmp	SHORT $LN20@SetMasterM
$LN27@SetMasterM:

; 1961 : 			{			
; 1962 : 				if( playerFCC )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN20@SetMasterM

; 1963 : 				{
; 1964 : 					Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	ecx, DWORD PTR [edx+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN20@SetMasterM:

; 1965 : 				}
; 1966 : 			}
; 1967 : 
; 1968 : 
; 1969 : 			/*
; 1970 : 			if (Sms->curWeaponClass != wcGbuWpn)
; 1971 : 			{
; 1972 : 				if (Sms->FindWeaponClass (wcGbuWpn, FALSE) && Sms->CurHardpoint() >= 0) // JB 010805 Possible CTD check curhardpoint
; 1973 : 				{
; 1974 : 					Sms->SetWeaponType(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponType());
; 1975 : 					switch (Sms->curWeaponType)
; 1976 : 					{
; 1977 : 					case wtGBU:
; 1978 : 						//Mi this isn't true... doc states you start off in SLAVE
; 1979 : 						if(!g_bRealisticAvionics)
; 1980 : 						{
; 1981 : 							if (PlayerOptions.GetAvionicsType() == ATRealistic)
; 1982 : 								SetSubMode (BSGT);
; 1983 : 							else
; 1984 : 								SetSubMode (SLAVE);
; 1985 : 						}
; 1986 : 						else
; 1987 : 						{
; 1988 : 							InhibitFire = FALSE;
; 1989 : 							// M.N. added full realism mode
; 1990 : 							if(PlayerOptions.GetAvionicsType() != ATRealistic && PlayerOptions.GetAvionicsType() != ATRealisticAV)
; 1991 : 								SetSubMode (BSGT);
; 1992 : 							else
; 1993 : 								SetSubMode (SLAVE);
; 1994 : 						} 
; 1995 : 						break;
; 1996 : 					}
; 1997 : 				}
; 1998 : 				else
; 1999 : 				{
; 2000 : 					Sms->SetWeaponType (wtNone);
; 2001 : 					
; 2002 : 					if( playerFCC )
; 2003 : 					{
; 2004 : 						Sms->GetNextWeapon(wdGround);
; 2005 : 						Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);
; 2006 : 					}
; 2007 : 				}
; 2008 : 			}
; 2009 : 			*/
; 2010 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN18@SetMasterM
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN18@SetMasterM

; 2011 : 				TheHud->headingPos = HudClass::High;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+4964], 0
$LN18@SetMasterM:

; 2012 : 			break;

	jmp	$LN85@SetMasterM
$LN17@SetMasterM:

; 2013 : 			
; 2014 : 		case AirGroundCamera:
; 2015 : 			// Clear out any previous targets we had locked.
; 2016 : 			ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 2017 : 			preDesignate = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+182], 1

; 2018 : 			postDrop = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+183], 0

; 2019 : 
; 2020 : 			if(isAI && !WeaponClassMatchesMaster(Sms->curWeaponClass))

	cmp	DWORD PTR _isAI$[ebp], 0
	je	SHORT $LN16@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN16@SetMasterM

; 2021 : 				Sms->FindWeaponClass (wcCamera);

	push	1
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
$LN16@SetMasterM:

; 2022 : 
; 2023 : 			if(WeaponClassMatchesMaster(Sms->curWeaponClass))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	je	SHORT $LN15@SetMasterM

; 2024 : 			{
; 2025 : 				SetSubMode(PRE); // MLR 2/14/2004 - who knows if this it correct

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2026 : 			}
; 2027 : 			else

	jmp	SHORT $LN14@SetMasterM
$LN15@SetMasterM:

; 2028 : 			{
; 2029 : 				Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	mov	ecx, DWORD PTR [eax+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN14@SetMasterM:

; 2030 : 			}
; 2031 : 
; 2032 : 			/*
; 2033 : 			if (Sms->curWeaponClass != wcCamera)
; 2034 : 			{
; 2035 : 				if (Sms->FindWeaponClass (wcCamera, FALSE) && Sms->CurHardpoint() >= 0) // JB 010805 Possible CTD check curhardpoint
; 2036 : 				{
; 2037 : 					Sms->SetWeaponType(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponType());
; 2038 : 				}
; 2039 : 				else
; 2040 : 				{
; 2041 : 					Sms->SetWeaponType (wtNone);
; 2042 : 					
; 2043 : 					if( playerFCC )
; 2044 : 					{
; 2045 : 						Sms->GetNextWeapon(wdGround);
; 2046 : 						Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);
; 2047 : 					}
; 2048 : 				}
; 2049 : 			}
; 2050 : 			*/
; 2051 : 			if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN13@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN13@SetMasterM

; 2052 : 				TheHud->headingPos = HudClass::High;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4964], 0
$LN13@SetMasterM:

; 2053 : 			strcpy (subModeString, "RPOD");

	push	OFFSET ??_C@_04FPNANLBH@RPOD?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 400				; 00000190H
	push	eax
	call	_strcpy
	add	esp, 8

; 2054 : 			platform->SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager
$LN85@SetMasterM:

; 2055 : 			break;
; 2056 :    }
; 2057 :    
; 2058 :    // MLR 2/1/2004 - we check this last, because sometimes we fall back to gun mode in the switch above
; 2059 :    if(masterMode==AAGun)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 0
	jne	SHORT $LN12@SetMasterM

; 2060 :    {
; 2061 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN11@SetMasterM

; 2062 : 			SetSubMode(lastAirAirGunSubMode);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2063 : 		else

	jmp	SHORT $LN10@SetMasterM
$LN11@SetMasterM:

; 2064 : 			SetSubMode(EEGS);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN10@SetMasterM:

; 2065 : 
; 2066 : 		if(!WeaponClassMatchesMaster(Sms->curWeaponClass))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN9@SetMasterM

; 2067 : 			Sms->FindWeaponType (wtGuns);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN9@SetMasterM:

; 2068 : 	   
; 2069 : 		// we only want to store this as the previous weapon if g_bWeaponStepToGun is TRUE
; 2070 : 		//if(g_bWeaponStepToGun)
; 2071 : 		//	lastAirAirHp = Sms->GetCurrentWeaponHardpoint();
; 2072 : 	   //lastAirAirWId=Sms->GetCurrentWeaponId();
; 2073 : 
; 2074 : 	   if (TheHud && playerFCC)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN12@SetMasterM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN12@SetMasterM

; 2075 : 		   TheHud->headingPos = HudClass::Low;	

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+4964], 1
$LN12@SetMasterM:

; 2076 :    }
; 2077 : 
; 2078 :    if(masterMode==AGGun)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 1
	jne	SHORT $LN7@SetMasterM

; 2079 :    {
; 2080 : 	   {
; 2081 : 		   SetSubMode(STRAF);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 2082 : 	   }
; 2083 : 
; 2084 : 		if(!WeaponClassMatchesMaster(Sms->curWeaponClass))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeaponClassMatchesMaster@FireControlComputer@@QAEHW4WeaponClass@@@Z ; FireControlComputer::WeaponClassMatchesMaster
	test	eax, eax
	jne	SHORT $LN6@SetMasterM

; 2085 : 			Sms->FindWeaponType (wtGuns);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN6@SetMasterM:

; 2086 : 	   
; 2087 : 		// we only want to store this as the previous weapon if g_bWeaponStepToGun is TRUE
; 2088 : 		//if(g_bWeaponStepToGun)
; 2089 : 		//	lastAirGroundHp = Sms->GetCurrentWeaponHardpoint();
; 2090 : 	   //lastAirGroundWId=Sms->GetCurrentWeaponId(); //>GetCurrentWeaponHardpoint();
; 2091 : 
; 2092 : 	   if (TheHud && playerFCC)	

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN7@SetMasterM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN7@SetMasterM

; 2093 : 		   TheHud->headingPos = HudClass::High;	   

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+4964], 0
$LN7@SetMasterM:

; 2094 :    }
; 2095 : 
; 2096 :    // store master mode, used when leaving DF or MO.
; 2097 :    switch(masterMode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR tv602[ebp], edx
	cmp	DWORD PTR tv602[ebp], 9
	jl	SHORT $LN1@SetMasterM
	cmp	DWORD PTR tv602[ebp], 10		; 0000000aH
	jle	SHORT $LN2@SetMasterM
	jmp	SHORT $LN1@SetMasterM
$LN2@SetMasterM:

; 2098 :    {
; 2099 :    case Dogfight:
; 2100 :    case MissileOverride:
; 2101 : 	   break;

	jmp	SHORT $LN3@SetMasterM
$LN1@SetMasterM:

; 2102 :    default: 
; 2103 : 	   lastMasterMode = masterMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+72], edx
$LN3@SetMasterM:

; 2104 :    }
; 2105 : 
; 2106 :    UpdateWeaponPtr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateWeaponPtr@FireControlComputer@@AAEXXZ ; FireControlComputer::UpdateWeaponPtr

; 2107 :    UpdateLastData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateLastData@FireControlComputer@@AAEXXZ ; FireControlComputer::UpdateLastData
$LN96@SetMasterM:

; 2108 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN101@SetMasterM:
	DD	$LN62@SetMasterM
	DD	$LN53@SetMasterM
	DD	$LN51@SetMasterM
	DD	$LN49@SetMasterM
	DD	$LN41@SetMasterM
	DD	$LN34@SetMasterM
	DD	$LN29@SetMasterM
	DD	$LN84@SetMasterM
	DD	$LN72@SetMasterM
	DD	$LN17@SetMasterM
	DD	$LN85@SetMasterM
	DD	$LN44@SetMasterM
?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ENDP ; FireControlComputer::SetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_pradar$ = -36						; size = 4
tv182 = -32						; size = 4
tv141 = -28						; size = 4
tv93 = -24						; size = 4
tv79 = -20						; size = 4
tv77 = -16						; size = 4
tv159 = -12						; size = 4
tv145 = -8						; size = 4
_this$ = -4						; size = 4
?NextSubMode@FireControlComputer@@QAEXXZ PROC		; FireControlComputer::NextSubMode
; _this$ = ecx

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 	// MLR 4/3/2004 - Added calls to SetSubMode instead of doing 'stuff' for ourselves.
; 690  : 	//MI
; 691  : 	RadarDopplerClass* pradar = (RadarDopplerClass*) FindSensor (platform, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$[ebp], eax

; 692  : 	switch (masterMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 9
	ja	$LN44@NextSubMod
	mov	ecx, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN48@NextSubMod[ecx*4]
$LN41@NextSubMod:

; 693  : 	{ 
; 694  : 		// ASSOCIATOR 02/12/03: Now we can use the Cycle FCC Submodes key when in Dogfight Mode
; 695  : 		// ASSOCIATOR 03/12/03: Added the combined SnapShot LCOS Gunmode SSLC 
; 696  : 	case Dogfight: 
; 697  : 		switch (subMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR tv79[ebp], eax
	cmp	DWORD PTR tv79[ebp], 3
	ja	SHORT $LN39@NextSubMod
	mov	ecx, DWORD PTR tv79[ebp]
	jmp	DWORD PTR $LN49@NextSubMod[ecx*4]
$LN38@NextSubMod:

; 698  : 		{
; 699  : 		case EEGS:
; 700  : 			if (PlayerOptions.GetAvionicsType() != ATEasy) 

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	SHORT $LN37@NextSubMod

; 701  : 			{
; 702  : 	               SetSubMode (SSLC);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN37@NextSubMod:

; 703  : 			}
; 704  :             break;

	jmp	SHORT $LN39@NextSubMod
$LN36@NextSubMod:

; 705  : 			
; 706  : 		case SSLC:
; 707  : 			SetSubMode (LCOS);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 708  :             break;

	jmp	SHORT $LN39@NextSubMod
$LN35@NextSubMod:

; 709  : 			
; 710  : 		case LCOS:
; 711  : 			SetSubMode (Snapshot);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 712  :             break;

	jmp	SHORT $LN39@NextSubMod
$LN34@NextSubMod:

; 713  : 			
; 714  : 		case Snapshot:
; 715  : 			SetSubMode (EEGS);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN39@NextSubMod:

; 716  :             break;
; 717  : 		}
; 718  : 		break;

	jmp	$LN44@NextSubMod
$LN33@NextSubMod:

; 719  : 		
; 720  : 		// ASSOCIATOR 02/12/03: Now we can use the Cycle FCC Submodes key when in MissileOverride
; 721  : 		// ASSOCIATOR 03/12/03: Added the combined SnapShot LCOS Gunmode SSLC 
; 722  : 	case AAGun:
; 723  : 		switch (subMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR tv93[ebp], eax
	cmp	DWORD PTR tv93[ebp], 3
	ja	SHORT $LN31@NextSubMod
	mov	ecx, DWORD PTR tv93[ebp]
	jmp	DWORD PTR $LN50@NextSubMod[ecx*4]
$LN30@NextSubMod:

; 724  : 		{
; 725  :         case EEGS:
; 726  : 			if (PlayerOptions.GetAvionicsType() != ATEasy) 

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	SHORT $LN29@NextSubMod

; 727  : 			{
; 728  : 				SetSubMode (SSLC);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN29@NextSubMod:

; 729  : 			}
; 730  : 			break;

	jmp	SHORT $LN31@NextSubMod
$LN28@NextSubMod:

; 731  : 			
; 732  : 		case SSLC:
; 733  : 			SetSubMode (LCOS);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 734  : 			break;

	jmp	SHORT $LN31@NextSubMod
$LN27@NextSubMod:

; 735  : 			
; 736  :         case LCOS:
; 737  : 			SetSubMode (Snapshot);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 738  : 			break;

	jmp	SHORT $LN31@NextSubMod
$LN26@NextSubMod:

; 739  : 			
; 740  :         case Snapshot:
; 741  : 			SetSubMode (EEGS);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN31@NextSubMod:

; 742  : 			break;
; 743  : 		}
; 744  : 		break;

	jmp	$LN44@NextSubMod
$LN25@NextSubMod:

; 745  : 		
; 746  : 		
; 747  : 	case Nav:
; 748  : 		// MD -- 20031203: removed this since sources seem to indicate that there is no such function in the real jet.
; 749  : 		//  ASSOCIATOR Added g_bEnableFCCSubNavCycle as an option and !g_bRealisticAvionics to not break the other modes
; 750  : 		if( g_bEnableFCCSubNavCycle | !g_bRealisticAvionics )

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN46@NextSubMod
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN47@NextSubMod
$LN46@NextSubMod:
	mov	DWORD PTR tv141[ebp], 0
$LN47@NextSubMod:
	movzx	eax, BYTE PTR ?g_bEnableFCCSubNavCycle@@3_NA ; g_bEnableFCCSubNavCycle
	or	eax, DWORD PTR tv141[ebp]
	je	SHORT $LN24@NextSubMod

; 751  : 		{
; 752  : 			switch (subMode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR tv145[ebp], edx
	cmp	DWORD PTR tv145[ebp], 18		; 00000012H
	je	SHORT $LN19@NextSubMod
	cmp	DWORD PTR tv145[ebp], 19		; 00000013H
	je	SHORT $LN21@NextSubMod
	cmp	DWORD PTR tv145[ebp], 20		; 00000014H
	je	SHORT $LN18@NextSubMod
	jmp	SHORT $LN22@NextSubMod
$LN21@NextSubMod:

; 753  : 			{
; 754  : 			case ETE:
; 755  : 				if (PlayerOptions.GetAvionicsType() != ATEasy)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	SHORT $LN20@NextSubMod

; 756  : 				{
; 757  : 					SetSubMode (TimeToGo);

	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN20@NextSubMod:

; 758  : 				}
; 759  : 				break;

	jmp	SHORT $LN22@NextSubMod
$LN19@NextSubMod:

; 760  : 				
; 761  : 			case TimeToGo:
; 762  : 				SetSubMode (ETA);

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 763  : 				break;

	jmp	SHORT $LN22@NextSubMod
$LN18@NextSubMod:

; 764  : 				
; 765  : 			case ETA:
; 766  : 				SetSubMode (ETE);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN22@NextSubMod:

; 767  : 				break;
; 768  : 			}
; 769  : 			break;

	jmp	$LN44@NextSubMod

; 770  : 		}
; 771  : 		else

	jmp	SHORT $LN16@NextSubMod
$LN24@NextSubMod:

; 772  : 			break;

	jmp	$LN44@NextSubMod
$LN16@NextSubMod:

; 773  : 		
; 774  : 	case AirGroundBomb:
; 775  : 		switch (subMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR tv159[ebp], ecx
	cmp	DWORD PTR tv159[ebp], 7
	je	SHORT $LN13@NextSubMod
	cmp	DWORD PTR tv159[ebp], 8
	je	SHORT $LN11@NextSubMod
	cmp	DWORD PTR tv159[ebp], 10		; 0000000aH
	je	SHORT $LN10@NextSubMod
	jmp	SHORT $LN9@NextSubMod
$LN13@NextSubMod:

; 776  : 		{
; 777  : 		case CCIP:
; 778  : 			if (PlayerOptions.GetAvionicsType() != ATEasy) 

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	SHORT $LN12@NextSubMod

; 779  : 			{
; 780  : 				SetSubMode (DTOSS);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN12@NextSubMod:

; 781  : 			}
; 782  : 			break;

	jmp	SHORT $LN14@NextSubMod
$LN11@NextSubMod:

; 783  : 			
; 784  : 		case CCRP:
; 785  : 			SetSubMode (CCIP);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 786  : 			break;

	jmp	SHORT $LN14@NextSubMod
$LN10@NextSubMod:

; 787  : 			
; 788  : 		case DTOSS:
; 789  : 			SetSubMode (CCRP);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 790  : 			break;

	jmp	SHORT $LN14@NextSubMod
$LN9@NextSubMod:

; 791  : 			
; 792  : 		default: // catch LADD MAN etc
; 793  : 			SetSubMode(CCRP);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN14@NextSubMod:

; 794  : 			break;
; 795  : 		}
; 796  : 		break;

	jmp	SHORT $LN44@NextSubMod
$LN8@NextSubMod:

; 797  : 		
; 798  : 	case AirGroundLaser:
; 799  : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN6@NextSubMod

; 800  : 		{
; 801  : 			SetSubMode(lastAirGroundLaserSubMode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 802  : 			SetSubMode(SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode

; 803  : 			break;

	jmp	SHORT $LN44@NextSubMod
$LN6@NextSubMod:

; 804  : 		}
; 805  : 		// intentionally fall thru
; 806  : 	case AirGroundMissile:
; 807  : 		switch (subMode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR tv182[ebp], 14		; 0000000eH
	je	SHORT $LN1@NextSubMod
	cmp	DWORD PTR tv182[ebp], 15		; 0000000fH
	je	SHORT $LN3@NextSubMod
	jmp	SHORT $LN44@NextSubMod
$LN3@NextSubMod:

; 808  : 		{
; 809  : 		case SLAVE:
; 810  : 			if (PlayerOptions.GetAvionicsType() != ATEasy) 

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	SHORT $LN2@NextSubMod

; 811  : 			{
; 812  : 				SetSubMode (BSGT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN2@NextSubMod:

; 813  : 			}
; 814  : 			break;

	jmp	SHORT $LN44@NextSubMod
$LN1@NextSubMod:

; 815  : 			
; 816  : 		case BSGT:
; 817  : 			SetSubMode (SLAVE);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN44@NextSubMod:

; 818  : 			break;
; 819  : 		}
; 820  : 		break;
; 821  : 
; 822  : 
; 823  :    }
; 824  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN48@NextSubMod:
	DD	$LN33@NextSubMod
	DD	$LN44@NextSubMod
	DD	$LN44@NextSubMod
	DD	$LN44@NextSubMod
	DD	$LN25@NextSubMod
	DD	$LN16@NextSubMod
	DD	$LN6@NextSubMod
	DD	$LN44@NextSubMod
	DD	$LN8@NextSubMod
	DD	$LN41@NextSubMod
$LN49@NextSubMod:
	DD	$LN38@NextSubMod
	DD	$LN36@NextSubMod
	DD	$LN35@NextSubMod
	DD	$LN34@NextSubMod
$LN50@NextSubMod:
	DD	$LN30@NextSubMod
	DD	$LN28@NextSubMod
	DD	$LN27@NextSubMod
	DD	$LN26@NextSubMod
?NextSubMode@FireControlComputer@@QAEXXZ ENDP		; FireControlComputer::NextSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_mmm$1 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?ClearOverrideMode@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::ClearOverrideMode
; _this$ = ecx

; 661  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 662  : 	if ((GetMasterMode() == Dogfight) ||
; 663  : 		(GetMasterMode() == MissileOverride)) 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN6@ClearOverr
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN8@ClearOverr
$LN6@ClearOverr:

; 664  : 	{
; 665  : 		masterMode      = lastMasterMode; // MLR - little kludge so I can get the MM

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+144], edx

; 666  : 		MASTERMODES mmm = GetMainMasterMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	mov	DWORD PTR _mmm$1[ebp], eax

; 667  : 
; 668  : 		masterMode = ClearOveride;//me123 to allow leaving an overide mode

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 12			; 0000000cH

; 669  : 
; 670  : 		switch(mmm)

	mov	ecx, DWORD PTR _mmm$1[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN2@ClearOverr
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN3@ClearOverr
	jmp	SHORT $LN1@ClearOverr
$LN3@ClearOverr:

; 671  : 		{
; 672  : 		case MM_AA:
; 673  : 			EnterAAMasterMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnterAAMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAAMasterMode

; 674  : 			break;

	jmp	SHORT $LN8@ClearOverr
$LN2@ClearOverr:

; 675  : 		case MM_AG:
; 676  : 			EnterAGMasterMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnterAGMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAGMasterMode

; 677  : 			break;

	jmp	SHORT $LN8@ClearOverr
$LN1@ClearOverr:

; 678  : 		default:
; 679  : 			SetMasterMode (lastMasterMode);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN8@ClearOverr:

; 680  : 			break;
; 681  : 		}
; 682  : 		
; 683  : 	}
; 684  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearOverrideMode@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::ClearOverrideMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv203 = -12						; size = 4
tv207 = -8						; size = 4
_this$ = -4						; size = 4
_SMS$ = 8						; size = 4
?SetSms@FireControlComputer@@QAEXPAVSMSClass@@@Z PROC	; FireControlComputer::SetSms
; _this$ = ecx

; 2514 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2515 : 	Sms = SMS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _SMS$[ebp]
	mov	DWORD PTR [eax+408], ecx

; 2516 : 
; 2517 : 	// setup default HPs for MMs
; 2518 : 
; 2519 : 	// dogfight
; 2520 : 	if(!Sms->FindWeaponType (wtAim9))

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN21@SetSms

; 2521 : 		Sms->FindWeaponType(wtAim120);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN21@SetSms:

; 2522 : 	lastDogfightHp = Sms->CurHardpoint();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], eax

; 2523 : 
; 2524 : 	// missile override & aamm
; 2525 : 	if(!Sms->FindWeaponType (wtAim120))

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN20@SetSms

; 2526 : 		Sms->FindWeaponType(wtAim9);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
$LN20@SetSms:

; 2527 : 	lastMissileOverrideHp = Sms->CurHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2528 : 	lastAirAirHp		  = Sms->CurHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2529 : 
; 2530 : 	// agmm
; 2531 : 	/*if(!Sms->FindWeaponType (wtAgm88))
; 2532 : 		if(!Sms->FindWeaponType (wtAgm65))
; 2533 : 			if(!Sms->FindWeaponType (wtGBU))
; 2534 : 				if(!Sms->FindWeaponType (wtGPS))
; 2535 : 					if(!Sms->FindWeaponType (wtMk84))
; 2536 : 						if(!Sms->FindWeaponType (wtMk82))
; 2537 : 							Sms->FindWeaponClass (wcRocketWpn); // used to be: Sms->FindWeaponType (wtLAU); but jammers are marks as wtLAU :rolleyes:*/
; 2538 : 
; 2539 : 	//Cobra
; 2540 : 	if(!Sms->FindWeaponType (wtAgm88))

	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	$LN19@SetSms

; 2541 : 		if(!Sms->FindWeaponType (wtAgm65))

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN19@SetSms

; 2542 : 			if(!Sms->FindWeaponType (wtGBU))

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN19@SetSms

; 2543 : 				if(!Sms->FindWeaponType (wtGPS))

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN19@SetSms

; 2544 : 					if(!Sms->FindWeaponType (wtMk84))

	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN19@SetSms

; 2545 : 						if(!Sms->FindWeaponType (wtMk82))

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?FindWeaponType@SMSClass@@QAEHW4WeaponType@@@Z ; SMSClass::FindWeaponType
	test	eax, eax
	jne	SHORT $LN19@SetSms

; 2546 : 							if(!Sms->FindWeaponClass (wcRocketWpn))

	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
	test	eax, eax
	jne	SHORT $LN19@SetSms

; 2547 : 								Sms->FindWeaponClass (wcGunWpn);

	push	1
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?FindWeaponClass@SMSClass@@QAEHW4WeaponClass@@H@Z ; SMSClass::FindWeaponClass
$LN19@SetSms:

; 2548 : 	//end
; 2549 : 
; 2550 : 	if(Sms->CurHardpoint() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	test	eax, eax
	jle	$LN12@SetSms

; 2551 : 	{
; 2552 : 		switch(Sms->hardPoint[Sms->CurHardpoint()]->GetWeaponClass())

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv203[ebp], edx
	mov	eax, DWORD PTR tv203[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv203[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	mov	DWORD PTR tv207[ebp], eax
	mov	ecx, DWORD PTR tv207[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv207[ebp], ecx
	cmp	DWORD PTR tv207[ebp], 9
	ja	SHORT $LN3@SetSms
	mov	edx, DWORD PTR tv207[ebp]
	jmp	DWORD PTR $LN24@SetSms[edx*4]
$LN9@SetSms:

; 2553 : 		{
; 2554 : 		case wcRocketWpn:
; 2555 : 			lastAgMasterMode = AirGroundRocket;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 13			; 0000000dH

; 2556 : 			break;

	jmp	SHORT $LN12@SetSms
$LN8@SetSms:

; 2557 : 		case wcBombWpn:
; 2558 : 			lastAgMasterMode = AirGroundBomb;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 5

; 2559 : 			break;

	jmp	SHORT $LN12@SetSms
$LN7@SetSms:

; 2560 : 		case wcAgmWpn:
; 2561 : 			lastAgMasterMode = AirGroundMissile;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 6

; 2562 : 			break;

	jmp	SHORT $LN12@SetSms
$LN6@SetSms:

; 2563 : 		case wcHARMWpn:
; 2564 : 			lastAgMasterMode = AirGroundHARM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 7

; 2565 : 			break;

	jmp	SHORT $LN12@SetSms
$LN5@SetSms:

; 2566 : 		case wcGbuWpn:
; 2567 : 			lastAgMasterMode = AirGroundLaser;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 8

; 2568 : 			break;

	jmp	SHORT $LN12@SetSms
$LN4@SetSms:

; 2569 : 		case wcCamera:
; 2570 : 			lastAgMasterMode = AirGroundCamera;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 11			; 0000000bH

; 2571 : 			break;

	jmp	SHORT $LN12@SetSms
$LN3@SetSms:

; 2572 : 		default:
; 2573 : 			lastAgMasterMode = AirGroundBomb;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 5
$LN12@SetSms:

; 2574 : 		}
; 2575 : 	}
; 2576 : 	lastAirGroundHp =  Sms->CurHardpoint();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+408]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax

; 2577 : 
; 2578 : 	// Set us up in Gun mode if we have no AA or AG stores
; 2579 : 	if(lastAirAirHp == -1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], -1
	jne	SHORT $LN2@SetSms

; 2580 : 	{
; 2581 : 		inAAGunMode = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+68], 1
$LN2@SetSms:

; 2582 : 	}
; 2583 : //Cobra change to HP 0 for Gun from -1
; 2584 : 	if(lastAirGroundHp == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN22@SetSms

; 2585 : 	{
; 2586 : 		inAGGunMode = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+69], 1
$LN22@SetSms:

; 2587 : 	}
; 2588 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN24@SetSms:
	DD	$LN9@SetSms
	DD	$LN8@SetSms
	DD	$LN3@SetSms
	DD	$LN3@SetSms
	DD	$LN3@SetSms
	DD	$LN7@SetSms
	DD	$LN6@SetSms
	DD	$LN3@SetSms
	DD	$LN5@SetSms
	DD	$LN4@SetSms
?SetSms@FireControlComputer@@QAEXPAVSMSClass@@@Z ENDP	; FireControlComputer::SetSms
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv84 = -16						; size = 8
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_range$ = 8						; size = 4
?LastMissileWillMiss@FireControlComputer@@QAEHM@Z PROC	; FireControlComputer::LastMissileWillMiss
; _this$ = ecx

; 1494 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : /*	if (lastMissileImpactTime >0 && range > missileRMax )
; 1496 :    {
; 1497 :         return 1;
; 1498 :    }
; 1499 : 	else return 0;
; 1500 :   */  //me123 if the predicted total TOF is over xx seconds the missile is considered out of energy
; 1501 : 
; 1502 :    if (lastMissileImpactTime >0 && //me123 let's make sure there is a missile in the air
; 1503 :        lastMissileImpactTime - ((lastMissileShootTime - SimLibElapsedTime) /1000)  >= 80)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+268]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@LastMissil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+240]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR tv81[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv81[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv84[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv84[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+268]
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@42a00000
	jb	SHORT $LN1@LastMissil

; 1504 :        return 1;

	mov	eax, 1
	jmp	SHORT $LN2@LastMissil
$LN1@LastMissil:

; 1505 :    return 0;

	xor	eax, eax
$LN2@LastMissil:

; 1506 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LastMissileWillMiss@FireControlComputer@@QAEHM@Z ENDP	; FireControlComputer::LastMissileWillMiss
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1FireControlComputer@@UAE@XZ PROC			; FireControlComputer::~FireControlComputer
; _this$ = ecx

; 172  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1FireControlComputer@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7FireControlComputer@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 173  : 	ClearCurrentTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCurrentTarget@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearCurrentTarget

; 174  : 	ClearPlanned(); // JPO

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPlanned@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearPlanned

; 175  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 512				; 00000200H
	call	??1?$VuBin@VMissileClass@@@@QAE@XZ	; VuBin<MissileClass>::~VuBin<MissileClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1FireControlComputer@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
__unwindfunclet$??1FireControlComputer@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$??1FireControlComputer@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 512				; 00000200H
	jmp	??1?$VuBin@VMissileClass@@@@QAE@XZ	; VuBin<MissileClass>::~VuBin<MissileClass>
__ehhandler$??1FireControlComputer@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1FireControlComputer@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1FireControlComputer@@UAE@XZ ENDP			; FireControlComputer::~FireControlComputer
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_vehicle$ = 8						; size = 4
_numHardpoints$ = 12					; size = 4
??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z PROC ; FireControlComputer::FireControlComputer
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MfdDrawable@@QAE@XZ			; MfdDrawable::MfdDrawable
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7FireControlComputer@@6B@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 512				; 00000200H
	call	??0?$VuBin@VMissileClass@@@@QAE@PAVMissileClass@@@Z ; VuBin<MissileClass>::VuBin<MissileClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 57   : 	// sfr: smartpointer
; 58   : 	//fccWeaponPtr = NULL; // MLR 3/16/2004 - simulated weapon
; 59   : 	fccWeaponId      = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+504], 0

; 60   : 	//rocketPointer  = NULL; // MLR 3/5/2004 - For impact prediction
; 61   : 	rocketWeaponId = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], 0

; 62   : 
; 63   : 	platform = vehicle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vehicle$[ebp]
	mov	DWORD PTR [eax+140], ecx

; 64   : 	airGroundDelayTime = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+328], xmm0

; 65   : 	airGroundRange     = 10.0F * NM_TO_FT;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@476d5a1c
	movss	DWORD PTR [eax+332], xmm0

; 66   : 	missileMaxTof = -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+264], xmm0

; 67   : 	missileActiveTime = -1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+280], xmm0

; 68   : 	lastmissileActiveTime = -1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+276], xmm0

; 69   : 	bombPickle = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+191], 0

; 70   : 	postDrop = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+183], 0

; 71   : 	preDesignate = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+182], 1

; 72   : 	tossAnticipationCue = NoCue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], 0

; 73   : 	laddAnticipationCue = NoLADDCue;	//MI

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+456], 0

; 74   : 	lastMasterMode = Nav;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 4

; 75   : 	// ASSOCIATOR
; 76   : 	lastNavMasterMode = Nav;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 4

; 77   : 	lastAgMasterMode = (FCCMasterMode)-1; // AirGroundBomb; // MLR 2/8/2004 - EnterAGMasterMode() will see this, and determine the default weapon

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], -1

; 78   : 
; 79   : 	// MLR 3/13/2004 - back to using hp ids
; 80   : 	lastAirAirHp          = -1; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], -1

; 81   : 	lastAirGroundHp       = -1; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], -1

; 82   : 	lastDogfightHp        = -1; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], -1

; 83   : 	lastMissileOverrideHp = -1; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], -1

; 84   : 
; 85   : 	lastAirAirGunSubMode      = EEGS;  // MLR 2/7/2004 - 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 86   : 	lastAirGroundGunSubMode   = STRAF; // MLR 2/7/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 12			; 0000000cH

; 87   : 	lastAirGroundLaserSubMode = SLAVE; // MLR 4/11/2004 - 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 15			; 0000000fH

; 88   : 
; 89   : 	inAAGunMode = 0; // MLR 3/14/2004 - 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+68], 0

; 90   : 	inAGGunMode = 0; // MLR 3/14/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+69], 0

; 91   : 
; 92   : 	lastSubMode = ETE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 19			; 00000013H

; 93   : 	//lastAirGroundSubMode = CCRP;//me123
; 94   : 	lastDogfightGunSubMode = EEGS;	//MI

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 95   : 	lastAirAirSubMode = Aim9; // ASSOCIATOR

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 5

; 96   : 	strcpy (subModeString, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 400				; 00000190H
	push	eax
	call	_strcpy
	add	esp, 8

; 97   : 	playerFCC = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 98   : 	targetList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], 0

; 99   : 	releaseConsent = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+181], 0

; 100  : 	designateCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+184], 0

; 101  : 	dropTrackCmd = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+185], 0

; 102  : 	targetPtr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], 0

; 103  : 	missileCageCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+187], 0

; 104  : 	missileTDBPCmd = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+190], 0

; 105  : 	missileSpotScanCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+188], 0

; 106  : 	missileSlaveCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+189], 0

; 107  : 	cursorXCmd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], 0

; 108  : 	cursorYCmd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+200], 0

; 109  : 	waypointStepCmd = 127;	// Force an intial update (GM radar, at least, needs this)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+194], 127			; 0000007fH

; 110  : 	HSDRangeStepCmd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+195], 0

; 111  : 	HSDRange = 15.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [eax+160], xmm0

; 112  : 	HsdRangeIndex = 0; // JPO

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], 0

; 113  : 	groundPipperAz = groundPipperEl = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+392], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+388], xmm0

; 114  : 	masterMode = Nav;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 4

; 115  : 	subMode = ETE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 19			; 00000013H

; 116  : 	dgftSubMode = Aim9; // JPO dogfight specific

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 5

; 117  : 	mrmSubMode = Aim120; // ASSOCIATOR 04/12/03: for remembering MRM mode missiles

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 6

; 118  : 	autoTarget = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+180], 0

; 119  : 	missileWEZDisplayRange = 20.0F * NM_TO_FT;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@47ed5a1c
	movss	DWORD PTR [eax+312], xmm0

; 120  : 
; 121  : 	mSavedWayNumber	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], 0

; 122  : 	mpSavedWaypoint	= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0

; 123  : 	mStptMode			= FCCWaypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 0

; 124  : 	mNewStptMode		= mStptMode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR [ecx+128], eax

; 125  : 	bombReleaseOverride = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 126  : 	lastMissileShootRng = -1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+248], xmm0

; 127  : 	missileLaunched = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 128  : 	lastMissileShootHeight = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+256], xmm0

; 129  : 	lastMissileShootEnergy = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+260], xmm0

; 130  : 	nextMissileImpactTime = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+272], xmm0

; 131  : 	lastMissileImpactTime = -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+268], xmm0

; 132  : 	Height = 0;//me123

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+252], xmm0

; 133  : 	targetspeed = 0;//me123

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+244], xmm0

; 134  : 	hsdstates = 0; // JPO

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+168], 0

; 135  : 	MissileImpactTimeFlash = 0; // JPO

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 0

; 136  : 	grndlist = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+412], 0

; 137  : 	BuildPrePlanned(); // JPO

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildPrePlanned@FireControlComputer@@QAEXXZ ; FireControlComputer::BuildPrePlanned

; 138  : 	//MI
; 139  : 	LaserArm = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+420], 0

; 140  : 	LaserFire = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+423], 0

; 141  : 	ManualFire = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+424], 0

; 142  : 	LaserWasFired = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+421], 0

; 143  : 	CheckForLaserFire = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+422], 0

; 144  : 	InhibitFire = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+425], 0

; 145  : 	Timer = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+428], xmm0

; 146  : 	ImpactTime = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+432], xmm0

; 147  : 	LaserRange = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+436], xmm0

; 148  : 	SafetyDistance = 1 * NM_TO_FT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45bde1b0
	movss	DWORD PTR [ecx+460], xmm0

; 149  : 	pitch = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+440], xmm0

; 150  : 	roll = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+444], xmm0

; 151  : 	yaw = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+448], xmm0

; 152  : 	time = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+452], 0

; 153  : 
; 154  : 	//MI SOI and HSD
; 155  : 	IsSOI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+464], 0

; 156  : 	CouldBeSOI = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+465], 0

; 157  : 	HSDZoom = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], 0

; 158  : 	HSDXPos = 0;		//Wombat778 11-10-2003

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+496], xmm0

; 159  : 	HSDYPos = 0;		//Wombat778 11-10-2003

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+500], xmm0

; 160  : 	HSDCursorXCmd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+204], 0

; 161  : 	HSDCursorYCmd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+208], 0

; 162  : 	xPos = 0;	//position of the curson on the scope

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+472], xmm0

; 163  : 	yPos = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+476], xmm0

; 164  : 	HSDDesignate = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], 0

; 165  : 	curCursorRate = CursorRate;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?CursorRate@FireControlComputer@@2MB
	movss	DWORD PTR [ecx+484], xmm0

; 166  : 	DispX = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+488], xmm0

; 167  : 	DispY = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+492], xmm0

; 168  : 	missileSeekerAz = missileSeekerEl = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+308], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+304], xmm0

; 169  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
__unwindfunclet$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 508				; 000001fcH
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 512				; 00000200H
	jmp	??1?$VuBin@VMissileClass@@@@QAE@XZ	; VuBin<MissileClass>::~VuBin<MissileClass>
__ehhandler$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z ENDP ; FireControlComputer::FireControlComputer
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv86 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_image$ = 8						; size = 4
?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z PROC ; FireControlComputer::DisplayInit
; _this$ = ecx

; 1096 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1097 :    DisplayExit();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1098 : 
; 1099 :    privateDisplay = new Render2D;

	push	262840					; 000402b8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@DisplayIni
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Render2D@@QAE@XZ			; Render2D::Render2D
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN6@DisplayIni
$LN5@DisplayIni:
	mov	DWORD PTR tv86[ebp], 0
$LN6@DisplayIni:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+24], eax

; 1100 :    ((Render2D*)privateDisplay)->Setup (image);

	mov	ecx, DWORD PTR _image$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1101 : 
; 1102 : 	if ((g_bGreyMFD) && (!bNVGmode))

	movzx	ecx, BYTE PTR ?g_bGreyMFD@@3_NA		; g_bGreyMFD
	test	ecx, ecx
	je	SHORT $LN2@DisplayIni
	movzx	edx, BYTE PTR ?bNVGmode@@3_NA		; bNVGmode
	test	edx, edx
	jne	SHORT $LN2@DisplayIni

; 1103 : 		privateDisplay->SetColor(GetMfdColor(MFD_WHITE));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMfdColor@DrawableClass@@QAEIW4MfdColor@@@Z ; DrawableClass::GetMfdColor
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 1104 : 	else

	jmp	SHORT $LN3@DisplayIni
$LN2@DisplayIni:

; 1105 : 		privateDisplay->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [eax+92]
	call	edx
$LN3@DisplayIni:

; 1106 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayInit@FireControlComputer@@EAEXPAVImageBuffer@@@Z ENDP ; FireControlComputer::DisplayInit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_ofont$1 = -8						; size = 4
_this$ = -4						; size = 4
_newDisplay$ = 8					; size = 4
?Display@FireControlComputer@@EAEXPAVVirtualDisplay@@@Z PROC ; FireControlComputer::Display
; _this$ = ecx

; 1109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1110 :    display = newDisplay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newDisplay$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1111 : 
; 1112 :    // JPO intercept for now FCC power...
; 1113 :    if (!((AircraftClass*)platform)->HasPower(AircraftClass::FCCPower)) {

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	$LN1@Display

; 1114 :        BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@MfdDrawable@@QAEXXZ		; MfdDrawable::BottomRow

; 1115 :        display->TextCenter(0.0f, 0.2f, "FCC");

	push	0
	push	OFFSET ??_C@_03MJEMAIFN@FCC?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+72]
	call	edx

; 1116 :        int ofont = display->CurFont();

	call	?CurFont@VirtualDisplay@@SAHXZ		; VirtualDisplay::CurFont
	mov	DWORD PTR _ofont$1[ebp], eax

; 1117 :        display->SetFont(2);

	push	2
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 1118 :        display->TextCenterVertical (0.0f, 0.0f, "OFF");

	push	0
	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [eax+76]
	call	edx

; 1119 :        display->SetFont(3);

	push	3
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 1120 :        return;

	jmp	SHORT $LN2@Display
$LN1@Display:

; 1121 :    }
; 1122 :    NavDisplay();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NavDisplay@FireControlComputer@@AAEXXZ	; FireControlComputer::NavDisplay
$LN2@Display:

; 1123 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Display@FireControlComputer@@EAEXPAVVirtualDisplay@@@Z ENDP ; FireControlComputer::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
tv486 = -216						; size = 8
tv544 = -208						; size = 8
tv420 = -200						; size = 8
_featureWalker$2 = -192					; size = 12
_featureWalker$3 = -180					; size = 12
tv581 = -168						; size = 4
_featureWalker$4 = -164					; size = 12
tv480 = -152						; size = 4
tv491 = -148						; size = 4
tv400 = -144						; size = 4
tv431 = -140						; size = 4
tv585 = -136						; size = 4
$T5 = -132						; size = 4
tv583 = -128						; size = 4
tv555 = -124						; size = 4
tv405 = -120						; size = 4
tv549 = -116						; size = 4
tv589 = -112						; size = 4
tv595 = -108						; size = 4
tv587 = -104						; size = 4
tv538 = -100						; size = 4
tv471 = -96						; size = 4
tv593 = -92						; size = 4
tv466 = -88						; size = 4
tv533 = -84						; size = 4
tv425 = -80						; size = 4
tv529 = -76						; size = 4
tv414 = -72						; size = 4
tv591 = -68						; size = 4
tv409 = -64						; size = 4
tv524 = -60						; size = 4
tv579 = -56						; size = 4
tv497 = -52						; size = 4
tv475 = -48						; size = 4
tv354 = -44						; size = 4
$T6 = -40						; size = 4
_angOff$ = -36						; size = 4
_groundTarget$ = -32					; size = 4
_retObject$ = -28					; size = 4
_curObject$ = -24					; size = 4
_this$ = -20						; size = 4
_testObject$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_startObject$ = 8					; size = 4
_checkFeature$ = 12					; size = 4
?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z PROC ; FireControlComputer::TargetStep
; _this$ = ecx

; 895  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 896  : 	VuEntity* testObject = NULL;

	mov	DWORD PTR _testObject$[ebp], 0

; 897  : 	VuEntity* groundTarget = NULL;

	mov	DWORD PTR _groundTarget$[ebp], 0

; 898  : 	SimObjectType* curObject = NULL;

	mov	DWORD PTR _curObject$[ebp], 0

; 899  : 	SimObjectType* retObject = NULL;

	mov	DWORD PTR _retObject$[ebp], 0

; 900  : 	float angOff;
; 901  : 
; 902  : 	// Starting in the object list
; 903  : 	if (startObject == NULL || startObject != targetPtr){

	cmp	DWORD PTR _startObject$[ebp], 0
	je	SHORT $LN37@TargetStep
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _startObject$[ebp]
	cmp	ecx, DWORD PTR [eax+132]
	je	$LN38@TargetStep
$LN37@TargetStep:

; 904  : 		// Start at next and go on
; 905  : 		if (startObject){

	cmp	DWORD PTR _startObject$[ebp], 0
	je	SHORT $LN34@TargetStep

; 906  : 			curObject = startObject->next;

	mov	edx, DWORD PTR _startObject$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _curObject$[ebp], eax
$LN35@TargetStep:

; 907  : 			while (curObject){

	cmp	DWORD PTR _curObject$[ebp], 0
	je	SHORT $LN34@TargetStep

; 908  : 				if (curObject->localData->ata < 60.0F * DTR){

	mov	ecx, DWORD PTR _curObject$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN33@TargetStep

; 909  : 					retObject = curObject;

	mov	eax, DWORD PTR _curObject$[ebp]
	mov	DWORD PTR _retObject$[ebp], eax

; 910  : 					break;

	jmp	SHORT $LN34@TargetStep
$LN33@TargetStep:

; 911  : 				}
; 912  : 				curObject = curObject->next;

	mov	ecx, DWORD PTR _curObject$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _curObject$[ebp], edx

; 913  : 			}

	jmp	SHORT $LN35@TargetStep
$LN34@TargetStep:

; 914  : 		}
; 915  : 
; 916  : 		// Did we go off the End of the objects?
; 917  : 		if (!retObject && checkFeature){

	cmp	DWORD PTR _retObject$[ebp], 0
	jne	$LN28@TargetStep
	cmp	DWORD PTR _checkFeature$[ebp], 0
	je	$LN28@TargetStep

; 918  : 			// Check features
; 919  : 			{
; 920  : 				VuListIterator featureWalker(SimDriver.featureList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+4
	push	eax
	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 921  : 				testObject = featureWalker.GetFirst();

	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN31@TargetStep:

; 922  : 				while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN30@TargetStep

; 923  : 				{
; 924  : 					angOff = (float)atan2 (testObject->YPos() - platform->YPos(),
; 925  : 					testObject->XPos() - platform->XPos()) - platform->Yaw();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv400[ebp]
	movss	xmm0, DWORD PTR tv400[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	movss	DWORD PTR tv579[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv405[ebp]
	movss	xmm0, DWORD PTR tv579[ebp]
	subss	xmm0, DWORD PTR tv405[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv409[ebp]
	movss	xmm0, DWORD PTR tv409[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv581[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv414[ebp]
	movss	xmm0, DWORD PTR tv581[ebp]
	subss	xmm0, DWORD PTR tv414[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv420[ebp]
	movsd	xmm0, QWORD PTR tv420[ebp]
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv583[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv425[ebp]
	movss	xmm0, DWORD PTR tv583[ebp]
	subss	xmm0, DWORD PTR tv425[ebp]
	movss	DWORD PTR _angOff$[ebp], xmm0

; 926  : 					if (fabs(angOff) < 60.0F * DTR)

	push	ecx
	movss	xmm0, DWORD PTR _angOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv431[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv431[ebp]
	jbe	SHORT $LN29@TargetStep

; 927  : 					{
; 928  : 					break;

	jmp	SHORT $LN30@TargetStep
$LN29@TargetStep:

; 929  : 					}
; 930  : 					testObject = featureWalker.GetNext();

	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 931  : 				}

	jmp	$LN31@TargetStep
$LN30@TargetStep:

; 932  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 933  : 
; 934  : 			if (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	SHORT $LN28@TargetStep

; 935  : 			{
; 936  : 				groundTarget = testObject;

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR _groundTarget$[ebp], ecx

; 937  : 				// KCK NOTE: Uh.. why are we doing this?
; 938  : 				//if (retObject)
; 939  : 				//{
; 940  : 				//Tpoint pos;
; 941  : 				//targetPtr->BaseData()->drawPointer->GetPosition (&pos);
; 942  : 				//targetPtr->BaseData()->SetPosition (pos.x, pos.y, pos.z);
; 943  : 				//}
; 944  : 				groundDesignateX = testObject->XPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+376]

; 945  : 				groundDesignateY = testObject->YPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+380]

; 946  : 				groundDesignateZ = testObject->ZPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+384]
$LN28@TargetStep:

; 947  : 			}
; 948  : 		}
; 949  : 
; 950  : 		// Did we go off the end of the Features?
; 951  : 		if (!retObject && !groundTarget){

	cmp	DWORD PTR _retObject$[ebp], 0
	jne	SHORT $LN22@TargetStep
	cmp	DWORD PTR _groundTarget$[ebp], 0
	jne	SHORT $LN22@TargetStep

; 952  : 			// Check the head of the object list
; 953  : 			curObject = targetList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR _curObject$[ebp], eax

; 954  : 			if (curObject){

	cmp	DWORD PTR _curObject$[ebp], 0
	je	SHORT $LN22@TargetStep

; 955  : 				if (curObject->localData->ata < 60.0F * DTR){

	mov	ecx, DWORD PTR _curObject$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN25@TargetStep

; 956  : 					retObject = curObject;

	mov	eax, DWORD PTR _curObject$[ebp]
	mov	DWORD PTR _retObject$[ebp], eax

; 957  : 				}
; 958  : 				else {

	jmp	SHORT $LN22@TargetStep
$LN25@TargetStep:

; 959  : 					while (curObject != startObject){

	mov	ecx, DWORD PTR _curObject$[ebp]
	cmp	ecx, DWORD PTR _startObject$[ebp]
	je	SHORT $LN22@TargetStep

; 960  : 						curObject = curObject->next;

	mov	edx, DWORD PTR _curObject$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _curObject$[ebp], eax

; 961  : 						if (curObject && curObject->localData->ata < 60.0F * DTR){

	cmp	DWORD PTR _curObject$[ebp], 0
	je	SHORT $LN21@TargetStep
	mov	ecx, DWORD PTR _curObject$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN21@TargetStep

; 962  : 							retObject = curObject;

	mov	eax, DWORD PTR _curObject$[ebp]
	mov	DWORD PTR _retObject$[ebp], eax

; 963  : 							break;

	jmp	SHORT $LN22@TargetStep
$LN21@TargetStep:

; 964  : 						}
; 965  : 					}

	jmp	SHORT $LN25@TargetStep
$LN22@TargetStep:

; 966  : 				}
; 967  : 			}
; 968  : 		}
; 969  : 	}

	jmp	$LN6@TargetStep
$LN38@TargetStep:

; 970  : 	else if (startObject == targetPtr)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _startObject$[ebp]
	cmp	edx, DWORD PTR [ecx+132]
	jne	$LN6@TargetStep

; 971  : 	{
; 972  : 		// Find the current object
; 973  : 		if (checkFeature)

	cmp	DWORD PTR _checkFeature$[ebp], 0
	je	$LN11@TargetStep

; 974  : 		{
; 975  : 			{
; 976  : 				VuListIterator featureWalker(SimDriver.featureList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+4
	push	eax
	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 977  : 				testObject = featureWalker.GetFirst();

	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN17@TargetStep:

; 978  : 				// Iterate up to our position in the list.
; 979  : 				while (testObject && testObject != targetPtr->BaseData())

	cmp	DWORD PTR _testObject$[ebp], 0
	je	SHORT $LN16@TargetStep
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+132]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	DWORD PTR _testObject$[ebp], eax
	je	SHORT $LN16@TargetStep

; 980  : 					testObject = featureWalker.GetNext();

	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax
	jmp	SHORT $LN17@TargetStep
$LN16@TargetStep:

; 981  : 				// And then get the next object
; 982  : 				if (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	SHORT $LN15@TargetStep

; 983  : 					testObject = featureWalker.GetNext();

	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax
$LN15@TargetStep:

; 984  : 				// Is there anything after the current object?
; 985  : 				while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN13@TargetStep

; 986  : 				{
; 987  : 					angOff = (float)atan2 (testObject->YPos() - platform->YPos(),
; 988  : 					testObject->XPos() - platform->XPos()) - platform->Yaw();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv466[ebp]
	movss	xmm0, DWORD PTR tv466[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv585[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv471[ebp]
	movss	xmm0, DWORD PTR tv585[ebp]
	subss	xmm0, DWORD PTR tv471[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv475[ebp]
	movss	xmm0, DWORD PTR tv475[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv587[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv480[ebp]
	movss	xmm0, DWORD PTR tv587[ebp]
	subss	xmm0, DWORD PTR tv480[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv486[ebp]
	movsd	xmm0, QWORD PTR tv486[ebp]
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	movss	DWORD PTR tv589[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv491[ebp]
	movss	xmm0, DWORD PTR tv589[ebp]
	subss	xmm0, DWORD PTR tv491[ebp]
	movss	DWORD PTR _angOff$[ebp], xmm0

; 989  : 					if (fabs(angOff) < 60.0F * DTR)

	push	ecx
	movss	xmm0, DWORD PTR _angOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv497[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv497[ebp]
	jbe	SHORT $LN12@TargetStep

; 990  : 					{
; 991  : 					break;

	jmp	SHORT $LN13@TargetStep
$LN12@TargetStep:

; 992  : 					}
; 993  : 					testObject = featureWalker.GetNext();

	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 994  : 				}

	jmp	$LN15@TargetStep
$LN13@TargetStep:

; 995  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 996  : 
; 997  : 			// Found one, so use it
; 998  : 			if (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	SHORT $LN11@TargetStep

; 999  : 			{
; 1000 : 							groundTarget = testObject;

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR _groundTarget$[ebp], edx

; 1001 : 				// KCK: Why are we doing this?
; 1002 : 	//			Tpoint pos;
; 1003 : 	//          targetPtr->BaseData()->drawPointer->GetPosition (&pos);
; 1004 : 	//          targetPtr->BaseData()->SetPosition (pos.x, pos.y, pos.z);
; 1005 : 				groundDesignateX = testObject->XPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+376]

; 1006 : 				groundDesignateY = testObject->YPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+380]

; 1007 : 				groundDesignateZ = testObject->ZPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+384]
$LN11@TargetStep:

; 1008 : 			}
; 1009 : 		}
; 1010 : 
; 1011 : 		// Off the end of the feature list?
; 1012 : 		if (!retObject && !groundTarget)

	cmp	DWORD PTR _retObject$[ebp], 0
	jne	SHORT $LN8@TargetStep
	cmp	DWORD PTR _groundTarget$[ebp], 0
	jne	SHORT $LN8@TargetStep

; 1013 : 		{
; 1014 : 			// Check the head of the object list
; 1015 : 			curObject = targetList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _curObject$[ebp], ecx
$LN9@TargetStep:

; 1016 : 			while (curObject)

	cmp	DWORD PTR _curObject$[ebp], 0
	je	SHORT $LN8@TargetStep

; 1017 : 			{
; 1018 : 				if (curObject->localData->ata < 60.0F * DTR)

	mov	edx, DWORD PTR _curObject$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN7@TargetStep

; 1019 : 				{
; 1020 : 				retObject = curObject;

	mov	ecx, DWORD PTR _curObject$[ebp]
	mov	DWORD PTR _retObject$[ebp], ecx

; 1021 : 				break;

	jmp	SHORT $LN8@TargetStep
$LN7@TargetStep:

; 1022 : 				}
; 1023 : 				curObject = curObject->next;

	mov	edx, DWORD PTR _curObject$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _curObject$[ebp], eax

; 1024 : 			}

	jmp	SHORT $LN9@TargetStep
$LN8@TargetStep:

; 1025 : 		}
; 1026 : 
; 1027 : 		// Of the End of the object list ?
; 1028 : 		if (!retObject && checkFeature && !groundTarget){

	cmp	DWORD PTR _retObject$[ebp], 0
	jne	$LN6@TargetStep
	cmp	DWORD PTR _checkFeature$[ebp], 0
	je	$LN6@TargetStep
	cmp	DWORD PTR _groundTarget$[ebp], 0
	jne	$LN6@TargetStep

; 1029 : 			// Check features
; 1030 : 			VuListIterator featureWalker(SimDriver.featureList);

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+4
	push	ecx
	lea	ecx, DWORD PTR _featureWalker$3[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 1031 : 			testObject = featureWalker.GetFirst();

	lea	ecx, DWORD PTR _featureWalker$3[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN5@TargetStep:

; 1032 : 			while (testObject && testObject != targetPtr->BaseData()){

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN4@TargetStep
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+132]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	DWORD PTR _testObject$[ebp], eax
	je	$LN4@TargetStep

; 1033 : 				angOff = (float)atan2 (testObject->YPos() - platform->YPos(),
; 1034 : 				testObject->XPos() - platform->XPos()) - platform->Yaw();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv524[ebp]
	movss	xmm0, DWORD PTR tv524[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	movss	DWORD PTR tv591[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv529[ebp]
	movss	xmm0, DWORD PTR tv591[ebp]
	subss	xmm0, DWORD PTR tv529[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv533[ebp]
	movss	xmm0, DWORD PTR tv533[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	movss	DWORD PTR tv593[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv538[ebp]
	movss	xmm0, DWORD PTR tv593[ebp]
	subss	xmm0, DWORD PTR tv538[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv544[ebp]
	movsd	xmm0, QWORD PTR tv544[ebp]
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+140]
	movss	DWORD PTR tv595[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv549[ebp]
	movss	xmm0, DWORD PTR tv595[ebp]
	subss	xmm0, DWORD PTR tv549[ebp]
	movss	DWORD PTR _angOff$[ebp], xmm0

; 1035 : 				if (fabs(angOff) < 60.0F * DTR){

	push	ecx
	movss	xmm0, DWORD PTR _angOff$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv555[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv555[ebp]
	jbe	SHORT $LN3@TargetStep

; 1036 : 					break;

	jmp	SHORT $LN4@TargetStep
$LN3@TargetStep:

; 1037 : 				}
; 1038 : 				testObject = featureWalker.GetNext();

	lea	ecx, DWORD PTR _featureWalker$3[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 1039 : 			}

	jmp	$LN5@TargetStep
$LN4@TargetStep:

; 1040 : 
; 1041 : 			if (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	SHORT $LN2@TargetStep

; 1042 : 			{
; 1043 : 				groundTarget = testObject;

	mov	eax, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR _groundTarget$[ebp], eax

; 1044 : 				groundDesignateX = testObject->XPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+376]

; 1045 : 				groundDesignateY = testObject->YPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+380]

; 1046 : 				groundDesignateZ = testObject->ZPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+384]
$LN2@TargetStep:

; 1047 : 			}
; 1048 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _featureWalker$3[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN6@TargetStep:

; 1049 : 	}
; 1050 : 
; 1051 : 	if (groundTarget){

	cmp	DWORD PTR _groundTarget$[ebp], 0
	je	SHORT $LN1@TargetStep

; 1052 : 	   // We're targeting a feature thing - make a new SimObjectType
; 1053 : 	   #ifdef DEBUG
; 1054 : 	   //retObject = new SimObjectType(OBJ_TAG, platform, (SimBaseClass*)groundTarget);
; 1055 : 	   #else
; 1056 : 	   retObject = new SimObjectType((SimBaseClass*)groundTarget);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN41@TargetStep
	mov	ecx, DWORD PTR _groundTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0SimObjectType@@QAE@PAVFalconEntity@@@Z ; SimObjectType::SimObjectType
	mov	DWORD PTR tv354[ebp], eax
	jmp	SHORT $LN42@TargetStep
$LN41@TargetStep:
	mov	DWORD PTR tv354[ebp], 0
$LN42@TargetStep:
	mov	edx, DWORD PTR tv354[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _retObject$[ebp], eax

; 1057 : 	   #endif
; 1058 :        retObject->localData->ataFrom = 180.0F * DTR;

	mov	ecx, DWORD PTR _retObject$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR [edx+4], xmm0
$LN1@TargetStep:

; 1059 : 	}
; 1060 : 	SetTarget(retObject);

	mov	eax, DWORD PTR _retObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@FireControlComputer@@QAEXPAVSimObjectType@@@Z ; FireControlComputer::SetTarget

; 1061 : 
; 1062 : 	return retObject;      

	mov	eax, DWORD PTR _retObject$[ebp]

; 1063 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$0:
	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$1:
	lea	ecx, DWORD PTR _featureWalker$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$2:
	lea	ecx, DWORD PTR _featureWalker$3[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z$3:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TargetStep@FireControlComputer@@AAEPAVSimObjectType@@PAV2@H@Z ENDP ; FireControlComputer::TargetStep
; Function compile flags: /Odtp
;	COMDAT ??_GGroundListElement@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GGroundListElement@@QAEPAXI@Z PROC			; GroundListElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1GroundListElement@@QAE@XZ		; GroundListElement::~GroundListElement
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GGroundListElement@@QAEPAXI@Z ENDP			; GroundListElement::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetFlag@GroundListElement@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFlag@GroundListElement@@QAEXH@Z PROC		; GroundListElement::SetFlag, COMDAT
; _this$ = ecx

; 44   :     void SetFlag(int flag) { flags |= flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@GroundListElement@@QAEXH@Z ENDP		; GroundListElement::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_newBase$ = -8						; size = 4
_this$ = -4						; size = 4
?HandoffBaseObject@GroundListElement@@QAEXXZ PROC	; GroundListElement::HandoffBaseObject
; _this$ = ecx

; 1434 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1435 :     FalconEntity	*newBase;
; 1436 :     
; 1437 :     if (baseObject == NULL) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN3@HandoffBas
	jmp	SHORT $LN4@HandoffBas
$LN3@HandoffBas:

; 1438 : 
; 1439 :     newBase = SimCampHandoff( baseObject, HANDOFF_RADAR);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?SimCampHandoff@@YAPAVFalconEntity@@PAV1@W4HandOffType@@@Z ; SimCampHandoff
	add	esp, 8
	mov	DWORD PTR _newBase$[ebp], eax

; 1440 :     
; 1441 :     if (newBase != baseObject) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newBase$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	je	SHORT $LN4@HandoffBas

; 1442 : 	VuDeReferenceEntity(baseObject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 1443 : 	
; 1444 : 	baseObject = newBase;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newBase$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 1445 : 	
; 1446 : 	if (baseObject) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN4@HandoffBas

; 1447 : 	    VuReferenceEntity(baseObject);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4
$LN4@HandoffBas:

; 1448 : 	}
; 1449 :     }
; 1450 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HandoffBaseObject@GroundListElement@@QAEXXZ ENDP	; GroundListElement::HandoffBaseObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetNext@GroundListElement@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNext@GroundListElement@@QAEPAV1@XZ PROC		; GroundListElement::GetNext, COMDAT
; _this$ = ecx

; 30   :     GroundListElement *GetNext () { return next; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNext@GroundListElement@@QAEPAV1@XZ ENDP		; GroundListElement::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ PROC ; GroundListElement::BaseObject, COMDAT
; _this$ = ecx

; 29   :     FalconEntity*	BaseObject(void) {return baseObject;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseObject@GroundListElement@@QAEPAVFalconEntity@@XZ ENDP ; GroundListElement::BaseObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1GroundListElement@@QAE@XZ PROC			; GroundListElement::~GroundListElement
; _this$ = ecx

; 1429 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1430 :     VuDeReferenceEntity(baseObject);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 1431 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1GroundListElement@@QAE@XZ ENDP			; GroundListElement::~GroundListElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\fcc\fccmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newEntity$ = 8						; size = 4
??0GroundListElement@@QAE@PAVFalconEntity@@@Z PROC	; GroundListElement::GroundListElement
; _this$ = ecx

; 1414 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1415 : 	F4Assert (newEntity);
; 1416 : 
; 1417 : 	baseObject	= newEntity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newEntity$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1418 : 	VuReferenceEntity(newEntity);

	mov	edx, DWORD PTR _newEntity$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1419 : 	symbol		= RadarDataTable[newEntity->GetRadarType()].RWRsymbol;

	mov	eax, DWORD PTR _newEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _newEntity$[ebp]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	imul	eax, 58					; 0000003aH
	mov	ecx, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	movsx	edx, WORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1420 : 	if (newEntity->IsCampaign())

	mov	ecx, DWORD PTR _newEntity$[ebp]
	call	?IsCampaign@FalconEntity@@QAEHXZ	; FalconEntity::IsCampaign
	test	eax, eax
	je	SHORT $LN2@GroundList

; 1421 : 	    range	= (float)((CampBaseClass*)newEntity)->GetAproxWeaponRange(Air);

	push	5
	mov	ecx, DWORD PTR _newEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _newEntity$[ebp]
	mov	eax, DWORD PTR [edx+412]
	call	eax
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	jmp	SHORT $LN1@GroundList
$LN2@GroundList:

; 1422 : 	else range	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+12], xmm0
$LN1@GroundList:

; 1423 : 	flags		= RangeRing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 2

; 1424 : 	next		= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 1425 : 	lastHit		= SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 1426 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0GroundListElement@@QAE@PAVFalconEntity@@@Z ENDP	; GroundListElement::GroundListElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\bomb.h
;	COMDAT ?IsSetBombFlag@BombClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSetBombFlag@BombClass@@QAEHH@Z PROC			; BombClass::IsSetBombFlag, COMDAT
; _this$ = ecx

; 102  : 	int IsSetBombFlag (int newFlag) {return flags & newFlag ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	and	ecx, DWORD PTR _newFlag$[ebp]
	je	SHORT $LN3@IsSetBombF
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSetBombF
$LN3@IsSetBombF:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSetBombF:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetBombFlag@BombClass@@QAEHH@Z ENDP			; BombClass::IsSetBombFlag
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GMfdDrawable@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMfdDrawable@@UAEPAXI@Z PROC				; MfdDrawable::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MfdDrawable@@UAE@XZ			; MfdDrawable::~MfdDrawable
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMfdDrawable@@UAEPAXI@Z ENDP				; MfdDrawable::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vd$ = 8						; size = 4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z PROC	; MfdDrawable::Display, COMDAT
; _this$ = ecx

; 138  :       virtual void Display (VirtualDisplay*vd) { display = vd; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vd$[ebp]
	mov	DWORD PTR [eax+20], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z ENDP	; MfdDrawable::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ??0MfdDrawable@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MfdDrawable@@QAE@XZ PROC				; MfdDrawable::MfdDrawable, COMDAT
; _this$ = ecx

; 135  :       MfdDrawable () {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DrawableClass@@IAE@XZ		; DrawableClass::DrawableClass
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MfdDrawable@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0MfdDrawable@@QAE@XZ ENDP				; MfdDrawable::MfdDrawable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GDrawableClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDrawableClass@@UAEPAXI@Z PROC			; DrawableClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DrawableClass@@UAE@XZ		; DrawableClass::~DrawableClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDrawableClass@@UAEPAXI@Z ENDP			; DrawableClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?PushButton@DrawableClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?PushButton@DrawableClass@@UAEXHH@Z PROC		; DrawableClass::PushButton, COMDAT
; _this$ = ecx

; 152  :       virtual void PushButton (int, int)	{};								// Override to get button messages in subclasses

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?PushButton@DrawableClass@@UAEXHH@Z ENDP		; DrawableClass::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ PROC ; DrawableClass::GetDisplay, COMDAT
; _this$ = ecx

; 139  :       virtual VirtualDisplay* GetDisplay (void)	{return privateDisplay;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ ENDP ; DrawableClass::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z PROC	; DrawableClass::DisplayInit, COMDAT
; _this$ = ecx

; 137  :       virtual void DisplayInit (ImageBuffer*)	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z ENDP	; DrawableClass::DisplayInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z PROC	; DrawableClass::Display, COMDAT
; _this$ = ecx

; 136  :       virtual void Display(VirtualDisplay*)		{ ShiWarning( "No Display!" ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z ENDP	; DrawableClass::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ??1DrawableClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DrawableClass@@UAE@XZ PROC				; DrawableClass::~DrawableClass, COMDAT
; _this$ = ecx

; 132  :       virtual ~DrawableClass (void)				{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DrawableClass@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DrawableClass@@UAE@XZ ENDP				; DrawableClass::~DrawableClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ??0DrawableClass@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DrawableClass@@IAE@XZ PROC				; DrawableClass::DrawableClass, COMDAT
; _this$ = ecx

; 126  :       DrawableClass(void) {privateDisplay = display = NULL; viewPoint = NULL; drawFlags = 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DrawableClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DrawableClass@@IAE@XZ ENDP				; DrawableClass::DrawableClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newe$ = 8						; size = 4
?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z PROC ; VuBin<SimWeaponClass>::reset, COMDAT
; _this$ = ecx

; 60   : 	void reset(E *newe = NULL){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if (newe == e){ return; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newe$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@reset
	jmp	SHORT $LN2@reset
$LN1@reset:

; 62   : 		VuReferenceEntity(newe); // ref new pointer

	mov	edx, DWORD PTR _newe$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 63   : 		VuDeReferenceEntity(e);  // unref old pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 64   : 		e = newe;                // get new pointer

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@reset:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ENDP ; VuBin<SimWeaponClass>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??1?$VuBin@VSimWeaponClass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$VuBin@VSimWeaponClass@@@@QAE@XZ PROC		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 19   : 	~VuBin(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 		VuDeReferenceEntity((VuEntity *)e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 21   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$VuBin@VSimWeaponClass@@@@QAE@XZ ENDP		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z PROC ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 11   : 	explicit VuBin(E *e = NULL) : e(e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], ecx

; 12   : 		VuReferenceEntity(e);

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ENDP ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampaign@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsCampaign@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsCampaign, COMDAT
; _this$ = ecx

; 101  : 		{return (falconType & FalconCampaignEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 1
	je	SHORT $LN3@IsCampaign
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsCampaign
$LN3@IsCampaign:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsCampaign:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampaign@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRender2D@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRender2D@@UAEPAXI@Z PROC				; Render2D::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Render2D@@UAE@XZ			; Render2D::~Render2D
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRender2D@@UAEPAXI@Z ENDP				; Render2D::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetLineStyle@Render2D@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@Render2D@@UAEXH@Z PROC			; Render2D::SetLineStyle, COMDAT
; _this$ = ecx

; 60   : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@Render2D@@UAEXH@Z ENDP			; Render2D::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetBackground@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetBackground@Render2D@@UAEXK@Z PROC			; Render2D::SetBackground, COMDAT
; _this$ = ecx

; 50   : 	virtual void SetBackground(DWORD packedRGBA){ context.SetState(MPR_STA_BG_COLOR,packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBackground@Render2D@@UAEXK@Z ENDP			; Render2D::SetBackground
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetColor@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetColor@Render2D@@UAEXK@Z PROC			; Render2D::SetColor, COMDAT
; _this$ = ecx

; 49   : 	virtual void SetColor(DWORD packedRGBA)	{ context.RestoreState(STATE_SOLID); context.SelectForegroundColor(packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SelectForegroundColor@ContextMPR@@QAEXH@Z ; ContextMPR::SelectForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	4
?SetColor@Render2D@@UAEXK@Z ENDP			; Render2D::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?Color@Render2D@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@Render2D@@UAEKXZ PROC				; Render2D::Color, COMDAT
; _this$ = ecx

; 48   : 	virtual DWORD Color(void) { return context.CurrentForegroundColor(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?CurrentForegroundColor@ContextMPR@@QAEHXZ ; ContextMPR::CurrentForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@Render2D@@UAEKXZ ENDP				; Render2D::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearZBuffer@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearZBuffer@Render2D@@UAEXXZ PROC			; Render2D::ClearZBuffer, COMDAT
; _this$ = ecx

; 42   : 	virtual void ClearZBuffer( void )	{ context.ClearBuffers( MPR_CI_ZBUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearZBuffer@Render2D@@UAEXXZ ENDP			; Render2D::ClearZBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearDraw@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDraw@Render2D@@UAEXXZ PROC			; Render2D::ClearDraw, COMDAT
; _this$ = ecx

; 41   : 	virtual void ClearDraw( void )		{ context.ClearBuffers( MPR_CI_DRAW_BUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDraw@Render2D@@UAEXXZ ENDP			; Render2D::ClearDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??1Render2D@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Render2D@@UAE@XZ PROC				; Render2D::~Render2D, COMDAT
; _this$ = ecx

; 32   : 	virtual ~Render2D()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	esp, ebp
	pop	ebp
	ret	0
??1Render2D@@UAE@XZ ENDP				; Render2D::~Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??0Render2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Render2D@@QAE@XZ PROC				; Render2D::Render2D, COMDAT
; _this$ = ecx

; 31   : 	Render2D()			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VirtualDisplay@@QAE@XZ		; VirtualDisplay::VirtualDisplay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Render2D@@QAE@XZ ENDP				; Render2D::Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVirtualDisplay@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVirtualDisplay@@UAEPAXI@Z PROC			; VirtualDisplay::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVirtualDisplay@@UAEPAXI@Z ENDP			; VirtualDisplay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Color@VirtualDisplay@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@VirtualDisplay@@UAEKXZ PROC			; VirtualDisplay::Color, COMDAT
; _this$ = ecx

; 136  : 	virtual DWORD Color( void )	{return 0x0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@VirtualDisplay@@UAEKXZ ENDP			; VirtualDisplay::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?SetLineStyle@VirtualDisplay@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@VirtualDisplay@@UAEXH@Z PROC		; VirtualDisplay::SetLineStyle, COMDAT
; _this$ = ecx

; 135  : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@VirtualDisplay@@UAEXH@Z ENDP		; VirtualDisplay::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CurFont@VirtualDisplay@@SAHXZ
_TEXT	SEGMENT
?CurFont@VirtualDisplay@@SAHXZ PROC			; VirtualDisplay::CurFont, COMDAT

; 132  : 	static int CurFont(void) { return pFontSet->fontNum; };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	eax, DWORD PTR [eax+24672]
	pop	ebp
	ret	0
?CurFont@VirtualDisplay@@SAHXZ ENDP			; VirtualDisplay::CurFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextHeight@VirtualDisplay@@UAEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?TextHeight@VirtualDisplay@@UAEMXZ PROC			; VirtualDisplay::TextHeight, COMDAT
; _this$ = ecx

; 121  : 	virtual float TextHeight(void)			{ return ScreenTextHeight()/scaleY; };		// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR tv71[ebp], xmm0
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TextHeight@VirtualDisplay@@UAEMXZ ENDP			; VirtualDisplay::TextHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextWidth@VirtualDisplay@@UAEMPAD@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_string$ = 8						; size = 4
?TextWidth@VirtualDisplay@@UAEMPAD@Z PROC		; VirtualDisplay::TextWidth, COMDAT
; _this$ = ecx

; 120  : 	virtual float TextWidth(char *string)	{ return ScreenTextWidth(string)/scaleX; };	// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?TextWidth@VirtualDisplay@@UAEMPAD@Z ENDP		; VirtualDisplay::TextWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Arc@VirtualDisplay@@UAEXMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
_start$ = 20						; size = 4
_stop$ = 24						; size = 4
?Arc@VirtualDisplay@@UAEXMMMMM@Z PROC			; VirtualDisplay::Arc, COMDAT
; _this$ = ecx

; 109  : 		{ OvalArc(x, y, xRadius, xRadius*scaleX/scaleY, start, stop); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _stop$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Arc@VirtualDisplay@@UAEXMMMMM@Z ENDP			; VirtualDisplay::Arc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Circle@VirtualDisplay@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
?Circle@VirtualDisplay@@UAEXMMM@Z PROC			; VirtualDisplay::Circle, COMDAT
; _this$ = ecx

; 107  : 		{ Oval(x, y, xRadius, xRadius*scaleX/scaleY); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Circle@VirtualDisplay@@UAEXMMM@Z ENDP			; VirtualDisplay::Circle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??1VirtualDisplay@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VirtualDisplay@@UAE@XZ PROC				; VirtualDisplay::~VirtualDisplay, COMDAT
; _this$ = ecx

; 86   :     virtual ~VirtualDisplay()	{ ShiAssert( ready == FALSE ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??1ContextMPR@@UAE@XZ			; ContextMPR::~ContextMPR
	mov	esp, ebp
	pop	ebp
	ret	0
??1VirtualDisplay@@UAE@XZ ENDP				; VirtualDisplay::~VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??0VirtualDisplay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VirtualDisplay@@QAE@XZ PROC				; VirtualDisplay::VirtualDisplay, COMDAT
; _this$ = ecx

; 85   :     VirtualDisplay()			{ ready = FALSE; tLeft = tTop = tRight = tBottom = txRes = tyRes = 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0ContextMPR@@QAE@XZ			; ContextMPR::ContextMPR
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262776], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262772], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262768], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262764], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262760], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262756], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VirtualDisplay@@QAE@XZ ENDP				; VirtualDisplay::VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\context.h
;	COMDAT ?CurrentForegroundColor@ContextMPR@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentForegroundColor@ContextMPR@@QAEHXZ PROC		; ContextMPR::CurrentForegroundColor, COMDAT
; _this$ = ecx

; 708  : 	int CurrentForegroundColor(void) {return m_colFG_Raw;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentForegroundColor@ContextMPR@@QAEHXZ ENDP		; ContextMPR::CurrentForegroundColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
