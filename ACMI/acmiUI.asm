; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\ACMI\src\acmiUI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?TESTBUTTONPUSH@@3HA				; TESTBUTTONPUSH
PUBLIC	?gUICriticalSection@@3PAUF4CSECTIONHANDLE@@A	; gUICriticalSection
PUBLIC	?acmiDraw@@3HA					; acmiDraw
PUBLIC	?renderACMI@@3HA				; renderACMI
PUBLIC	?acmiRenderWin@@3PAVC_Window@@A			; acmiRenderWin
PUBLIC	?acmiView@@3PAVACMIView@@A			; acmiView
PUBLIC	?lastHorz@@3MA					; lastHorz
PUBLIC	?lastVert@@3MA					; lastVert
PUBLIC	?drawTimer@@3PAVC_TimerHook@@A			; drawTimer
PUBLIC	?gFrameMarker@@3PAVC_Slider@@A			; gFrameMarker
PUBLIC	?gFrameMarkerMin@@3HA				; gFrameMarkerMin
PUBLIC	?gFrameMarkerMax@@3HA				; gFrameMarkerMax
PUBLIC	?gFrameMarkerLen@@3HA				; gFrameMarkerLen
PUBLIC	?gCounter@@3PAVC_Text@@A			; gCounter
PUBLIC	?gTrailLen@@3HA					; gTrailLen
PUBLIC	?gDoWingTrails@@3HA				; gDoWingTrails
PUBLIC	?gDoPoles@@3HA					; gDoPoles
PUBLIC	?gDoLockLines@@3HA				; gDoLockLines
PUBLIC	?gDoWireFrame@@3HA				; gDoWireFrame
PUBLIC	?gObjScale@@3MA					; gObjScale
PUBLIC	?gCameraMode@@3HA				; gCameraMode
PUBLIC	?gCountText@@3PADA				; gCountText
PUBLIC	?gAdjustingFrameMarker@@3HA			; gAdjustingFrameMarker
PUBLIC	?loadedfname@@3PADA				; loadedfname
PUBLIC	?globalcheck@@3HA				; globalcheck
PUBLIC	?globaloffsetmsecs3@@3HA			; globaloffsetmsecs3
PUBLIC	?ACMIIDTable@@3PAVACMI_Hash@@A			; ACMIIDTable
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
_BSS	SEGMENT
?TESTBUTTONPUSH@@3HA DD 01H DUP (?)			; TESTBUTTONPUSH
?gUICriticalSection@@3PAUF4CSECTIONHANDLE@@A DD 01H DUP (?) ; gUICriticalSection
?acmiDraw@@3HA DD 01H DUP (?)				; acmiDraw
?renderACMI@@3HA DD 01H DUP (?)				; renderACMI
?acmiRenderWin@@3PAVC_Window@@A DD 01H DUP (?)		; acmiRenderWin
?acmiView@@3PAVACMIView@@A DD 01H DUP (?)		; acmiView
?lastHorz@@3MA DD 01H DUP (?)				; lastHorz
?lastVert@@3MA DD 01H DUP (?)				; lastVert
?drawTimer@@3PAVC_TimerHook@@A DD 01H DUP (?)		; drawTimer
?gFrameMarker@@3PAVC_Slider@@A DD 01H DUP (?)		; gFrameMarker
?gFrameMarkerMin@@3HA DD 01H DUP (?)			; gFrameMarkerMin
?gFrameMarkerMax@@3HA DD 01H DUP (?)			; gFrameMarkerMax
?gFrameMarkerLen@@3HA DD 01H DUP (?)			; gFrameMarkerLen
?gCounter@@3PAVC_Text@@A DD 01H DUP (?)			; gCounter
?gTrailLen@@3HA DD 01H DUP (?)				; gTrailLen
?gDoWingTrails@@3HA DD 01H DUP (?)			; gDoWingTrails
?gDoLockLines@@3HA DD 01H DUP (?)			; gDoLockLines
?gDoWireFrame@@3HA DD 01H DUP (?)			; gDoWireFrame
?gCountText@@3PADA DB 040H DUP (?)			; gCountText
?gAdjustingFrameMarker@@3HA DD 01H DUP (?)		; gAdjustingFrameMarker
?loadedfname@@3PADA DB 0104H DUP (?)			; loadedfname
?globalcheck@@3HA DD 01H DUP (?)			; globalcheck
?globaloffsetmsecs3@@3HA DD 01H DUP (?)			; globaloffsetmsecs3
?ACMIIDTable@@3PAVACMI_Hash@@A DD 01H DUP (?)		; ACMIIDTable
_BSS	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
_DATA	SEGMENT
?gDoPoles@@3HA DD 01H					; gDoPoles
?gObjScale@@3MA DD 03f800000r			; 1	; gObjScale
?gCameraMode@@3HA DD 030dbbH				; gCameraMode
_DATA	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_fmodf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?fmod@@YAMMM@Z					; fmod
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?SetCluster@C_Base@@QAEXJ@Z			; C_Base::SetCluster
PUBLIC	?SetReady@C_Base@@QAEXF@Z			; C_Base::SetReady
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetType@C_Base@@QAEFXZ				; C_Base::GetType
PUBLIC	?GetGroup@C_Base@@QAEJXZ			; C_Base::GetGroup
PUBLIC	?GetY@C_Base@@QAEJXZ				; C_Base::GetY
PUBLIC	?GetParent@C_Base@@QAEPAVC_Window@@XZ		; C_Base::GetParent
PUBLIC	?GetTextID@C_ListBox@@QAEJXZ			; C_ListBox::GetTextID
PUBLIC	?SetVirtualH@C_ScrollBar@@QAEXJ@Z		; C_ScrollBar::SetVirtualH
PUBLIC	?GetSliderMax@C_Slider@@QAEJXZ			; C_Slider::GetSliderMax
PUBLIC	?GetSliderMin@C_Slider@@QAEJXZ			; C_Slider::GetSliderMin
PUBLIC	?GetSliderPos@C_Slider@@QAEJXZ			; C_Slider::GetSliderPos
PUBLIC	?GetHRange@C_Panner@@QAEJXZ			; C_Panner::GetHRange
PUBLIC	?GetVRange@C_Panner@@QAEJXZ			; C_Panner::GetVRange
PUBLIC	?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetUpdateCallback
PUBLIC	?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetDrawCallback
PUBLIC	?GetFirstWindowLoaded@C_Parser@@QAEJXZ		; C_Parser::GetFirstWindowLoaded
PUBLIC	?GetNextWindowLoaded@C_Parser@@QAEJXZ		; C_Parser::GetNextWindowLoaded
PUBLIC	?SetVirtualY@C_Window@@QAEXJJ@Z			; C_Window::SetVirtualY
PUBLIC	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
PUBLIC	?LoadACMIWindows@@YAXXZ				; LoadACMIWindows
PUBLIC	??_GACMI_Hash@@QAEPAXI@Z			; ACMI_Hash::`scalar deleting destructor'
PUBLIC	?NumEntities@ACMITape@@QAEHXZ			; ACMITape::NumEntities
PUBLIC	?IsLoaded@ACMITape@@QAEHXZ			; ACMITape::IsLoaded
PUBLIC	?IsPaused@ACMITape@@QAEHXZ			; ACMITape::IsPaused
PUBLIC	?Play@ACMITape@@QAEXXZ				; ACMITape::Play
PUBLIC	?Pause@ACMITape@@QAEXXZ				; ACMITape::Pause
PUBLIC	?StepTime@ACMITape@@QAEXM@Z			; ACMITape::StepTime
PUBLIC	?SetPlayVelocity@ACMITape@@QAEXM@Z		; ACMITape::SetPlayVelocity
PUBLIC	?SetPlayAcceleration@ACMITape@@QAEXM@Z		; ACMITape::SetPlayAcceleration
PUBLIC	?SetMaxPlaySpeed@ACMITape@@QAEXM@Z		; ACMITape::SetMaxPlaySpeed
PUBLIC	?SimTime@ACMITape@@QAEMXZ			; ACMITape::SimTime
PUBLIC	?GetTapePercent@ACMITape@@QAEMXZ		; ACMITape::GetTapePercent
PUBLIC	?SetObjScale@ACMITape@@QAEXM@Z			; ACMITape::SetObjScale
PUBLIC	?SetWingTrailLength@ACMITape@@QAEXH@Z		; ACMITape::SetWingTrailLength
PUBLIC	?GetTodOffset@ACMITape@@QAEMXZ			; ACMITape::GetTodOffset
PUBLIC	?Tape@ACMIView@@QAEPAVACMITape@@XZ		; ACMIView::Tape
PUBLIC	?IncrementCameraObject@ACMIView@@QAEXH@Z	; ACMIView::IncrementCameraObject
PUBLIC	?CameraObject@ACMIView@@QAEHXZ			; ACMIView::CameraObject
PUBLIC	?IncrementTrackingObject@ACMIView@@QAEXH@Z	; ACMIView::IncrementTrackingObject
PUBLIC	?TrackingObject@ACMIView@@QAEHXZ		; ACMIView::TrackingObject
PUBLIC	?TapeHasLoaded@ACMIView@@QAEHXZ			; ACMIView::TapeHasLoaded
PUBLIC	?ToggleTracking@ACMIView@@QAEXXZ		; ACMIView::ToggleTracking
PUBLIC	??_GACMIView@@QAEPAXI@Z				; ACMIView::`scalar deleting destructor'
PUBLIC	?FindACMIFLTFiles@@YAXXZ			; FindACMIFLTFiles
PUBLIC	?HookupACMIControls@@YAXJ@Z			; HookupACMIControls
PUBLIC	?MoveACMIViewTimerCB@@YAXJFPAVC_Base@@@Z	; MoveACMIViewTimerCB
PUBLIC	?ACMIDrawCB@@YAXJFPAVC_Base@@@Z			; ACMIDrawCB
PUBLIC	?ACMIButtonCB@@YAXJFPAVC_Base@@@Z		; ACMIButtonCB
PUBLIC	?ACMICloseCB@@YAXJFPAVC_Base@@@Z		; ACMICloseCB
PUBLIC	?ACMILoadCB@@YAXJFPAVC_Base@@@Z			; ACMILoadCB
PUBLIC	?ACMIFrameMarkerCB@@YAXJFPAVC_Base@@@Z		; ACMIFrameMarkerCB
PUBLIC	?ACMIStopCB@@YAXJFPAVC_Base@@@Z			; ACMIStopCB
PUBLIC	?ACMIPlayCB@@YAXJFPAVC_Base@@@Z			; ACMIPlayCB
PUBLIC	?ACMIPlayBackwardsCB@@YAXJFPAVC_Base@@@Z	; ACMIPlayBackwardsCB
PUBLIC	?ACMIStepFowardCB@@YAXJFPAVC_Base@@@Z		; ACMIStepFowardCB
PUBLIC	?ACMIStepReverseCB@@YAXJFPAVC_Base@@@Z		; ACMIStepReverseCB
PUBLIC	?ACMIRewindCB@@YAXJFPAVC_Base@@@Z		; ACMIRewindCB
PUBLIC	?ACMIFastForwardCB@@YAXJFPAVC_Base@@@Z		; ACMIFastForwardCB
PUBLIC	?ACMIRotateCameraUpCB@@YAXJFPAVC_Base@@@Z	; ACMIRotateCameraUpCB
PUBLIC	?ACMIRotateCameraDownCB@@YAXJFPAVC_Base@@@Z	; ACMIRotateCameraDownCB
PUBLIC	?ACMIRotateCameraLeftCB@@YAXJFPAVC_Base@@@Z	; ACMIRotateCameraLeftCB
PUBLIC	?ACMIRotateCameraRightCB@@YAXJFPAVC_Base@@@Z	; ACMIRotateCameraRightCB
PUBLIC	?ACMIZoomInCameraCB@@YAXJFPAVC_Base@@@Z		; ACMIZoomInCameraCB
PUBLIC	?ACMIZoomOutCameraCB@@YAXJFPAVC_Base@@@Z	; ACMIZoomOutCameraCB
PUBLIC	?ACMITrackingCB@@YAXJFPAVC_Base@@@Z		; ACMITrackingCB
PUBLIC	?ACMIPannerCB@@YAXJFPAVC_Base@@@Z		; ACMIPannerCB
PUBLIC	?ACMIHArrowsCB@@YAXJFPAVC_Base@@@Z		; ACMIHArrowsCB
PUBLIC	?ACMIVArrowsCB@@YAXJFPAVC_Base@@@Z		; ACMIVArrowsCB
PUBLIC	?ACMICameraCB@@YAXJFPAVC_Base@@@Z		; ACMICameraCB
PUBLIC	?ACMICamTrackingCB@@YAXJFPAVC_Base@@@Z		; ACMICamTrackingCB
PUBLIC	?ACMICamTrackingPrevCB@@YAXJFPAVC_Base@@@Z	; ACMICamTrackingPrevCB
PUBLIC	?ACMICamTrackingNextCB@@YAXJFPAVC_Base@@@Z	; ACMICamTrackingNextCB
PUBLIC	?ACMISubCameraCB@@YAXJFPAVC_Base@@@Z		; ACMISubCameraCB
PUBLIC	?ACMISubCameraPrevCB@@YAXJFPAVC_Base@@@Z	; ACMISubCameraPrevCB
PUBLIC	?ACMISubCameraNextCB@@YAXJFPAVC_Base@@@Z	; ACMISubCameraNextCB
PUBLIC	?ACMIPickAFileCB@@YAXJFPAVC_Base@@@Z		; ACMIPickAFileCB
PUBLIC	?ACMIUpdate@@YAXJFPAVC_Base@@@Z			; ACMIUpdate
PUBLIC	?ACMIScreenCaptureCB@@YAXJFPAVC_Base@@@Z	; ACMIScreenCaptureCB
PUBLIC	?ACMICutPOVCB@@YAXJFPAVC_Base@@@Z		; ACMICutPOVCB
PUBLIC	?ACMIUpdateModelMenu@@YAXXZ			; ACMIUpdateModelMenu
PUBLIC	?InitACMIIDTable@@YAXXZ				; InitACMIIDTable
PUBLIC	?CleanupACMIIDTable@@YAXXZ			; CleanupACMIIDTable
PUBLIC	?InitACMIMenus@@YAXXZ				; InitACMIMenus
PUBLIC	?CloseACMI@@YAXXZ				; CloseACMI
PUBLIC	?FindUITextEvent@@YAPAVC_Base@@PAVC_Window@@JJ@Z ; FindUITextEvent
PUBLIC	?TogglePoleCB@@YAXJFPAVC_Base@@@Z		; TogglePoleCB
PUBLIC	?ToggleLockLineCB@@YAXJFPAVC_Base@@@Z		; ToggleLockLineCB
PUBLIC	?ToggleWireFrameCB@@YAXJFPAVC_Base@@@Z		; ToggleWireFrameCB
PUBLIC	?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z		; ToggleWingTrailsCB
PUBLIC	?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
PUBLIC	?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z		; ToggleObjScaleCB
PUBLIC	?ACMItoggleLABELSCB@@YAXJFPAVC_Base@@@Z		; ACMItoggleLABELSCB
PUBLIC	?ACMI_ImportFile@@YAXXZ				; ACMI_ImportFile
PUBLIC	?ACMI_LoadACMICB@@YAXJFPAVC_Base@@@Z		; ACMI_LoadACMICB
PUBLIC	?ACMI_SaveItCB@@YAXJFPAVC_Base@@@Z		; ACMI_SaveItCB
PUBLIC	?ACMI_VerifySaveItCB@@YAXJFPAVC_Base@@@Z	; ACMI_VerifySaveItCB
PUBLIC	?ACMIViewIsReady@@YAHXZ				; ACMIViewIsReady
PUBLIC	?ACMICamTrackingCB@@YAXJHPAVC_Control@@@Z	; ACMICamTrackingCB
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0BD@ELLGBKDE@WingTrails?5Short?5?6?$AA@	; `string'
PUBLIC	??_C@_0BE@COMFOKND@WingTrails?5Medium?5?6?$AA@	; `string'
PUBLIC	??_C@_0BC@IAPBICPN@WingTrails?5Long?5?6?$AA@	; `string'
PUBLIC	??_C@_0BB@GPJAONGB@WingTrails?5Max?5?6?$AA@	; `string'
PUBLIC	??_C@_0BC@CBEJELDD@acmibin?2acmi?$CK?4flt?$AA@	; `string'
PUBLIC	??_C@_08DIILMCIP@acmibin?2?$AA@			; `string'
PUBLIC	??_C@_0BF@PCNDMELA@acmibin?2TAPE?$CF04d?4vhs?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_06NDJHFN@?$CFs?4vhs?$AA@			; `string'
PUBLIC	??_C@_04ELKONGGK@?4vhs?$AA@			; `string'
PUBLIC	??_C@_0P@OFDCPHI@acmibin?2?$CFs?4vhs?$AA@	; `string'
PUBLIC	??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@	; `string'
PUBLIC	??_C@_0L@HHPJKLOK@ac_art?4lst?$AA@		; `string'
PUBLIC	??_C@_0L@OKMPGJJN@ac_snd?4lst?$AA@		; `string'
PUBLIC	??_C@_0L@MGNAKJFG@ac_scf?4lst?$AA@		; `string'
PUBLIC	??_C@_0BE@FEAMKGAE@?$CF02d?3?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0M@DAELODFB@lastflt?4vhs?$AA@		; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3b449ba6
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@bdcccccd
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__CopyFileA@12:PROC
EXTRN	__findfirst64i32:PROC
EXTRN	__findnext64i32:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_sprintf:PROC
EXTRN	_fabs:PROC
EXTRN	_fmod:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?GetHeight@C_Font@@QAEHJ@Z:PROC			; C_Font::GetHeight
EXTRN	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z:PROC ; UI_Enter
EXTRN	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z:PROC	; UI_Leave
EXTRN	?SetUserNumber@C_Base@@QAEXJJ@Z:PROC		; C_Base::SetUserNumber
EXTRN	?GetUserNumber@C_Base@@QAEJJ@Z:PROC		; C_Base::GetUserNumber
EXTRN	??0C_Button@@QAE@XZ:PROC			; C_Button::C_Button
EXTRN	?Setup@C_Button@@QAEXJFJJ@Z:PROC		; C_Button::Setup
EXTRN	?SetText@C_Button@@QAEXFPBD@Z:PROC		; C_Button::SetText
EXTRN	?GetText@C_Button@@QAEPADF@Z:PROC		; C_Button::GetText
EXTRN	?SetFgColor@C_Button@@QAEXFK@Z:PROC		; C_Button::SetFgColor
EXTRN	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z:PROC	; C_ListBox::AddItem
EXTRN	?RemoveAllItems@C_ListBox@@QAEXXZ:PROC		; C_ListBox::RemoveAllItems
EXTRN	?GetItem@C_ListBox@@QAEPAVC_Button@@J@Z:PROC	; C_ListBox::GetItem
EXTRN	?SetValue@C_ListBox@@QAEXJ@Z:PROC		; C_ListBox::SetValue
EXTRN	?CalcRanges@C_ScrollBar@@AAEXXZ:PROC		; C_ScrollBar::CalcRanges
EXTRN	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z:PROC ; C_PopupList::SetCallback
EXTRN	?SetItemState@C_PopupList@@QAEXJF@Z:PROC	; C_PopupList::SetItemState
EXTRN	?GetItemState@C_PopupList@@QAEFJ@Z:PROC		; C_PopupList::GetItemState
EXTRN	?GetWindowSize@C_PopupList@@QAEXPAF0@Z:PROC	; C_PopupList::GetWindowSize
EXTRN	?GetText@C_EditBox@@QAEPADXZ:PROC		; C_EditBox::GetText
EXTRN	?SetSliderPos@C_Slider@@QAEXJ@Z:PROC		; C_Slider::SetSliderPos
EXTRN	??0C_TimerHook@@QAE@XZ:PROC			; C_TimerHook::C_TimerHook
EXTRN	?Setup@C_TimerHook@@QAEXJF@Z:PROC		; C_TimerHook::Setup
EXTRN	?GetMenu@C_PopupMgr@@QAEPAVC_PopupList@@J@Z:PROC ; C_PopupMgr::GetMenu
EXTRN	?OpenMenu@C_PopupMgr@@QAEHJJJPAVC_Base@@@Z:PROC	; C_PopupMgr::OpenMenu
EXTRN	?LoadWindowList@C_Parser@@QAEHPAD@Z:PROC	; C_Parser::LoadWindowList
EXTRN	?LoadSoundList@C_Parser@@QAEHPAD@Z:PROC		; C_Parser::LoadSoundList
EXTRN	?LoadImageList@C_Parser@@QAEHPAD@Z:PROC		; C_Parser::LoadImageList
EXTRN	?AdjustScrollbar@C_Window@@QAEXJ@Z:PROC		; C_Window::AdjustScrollbar
EXTRN	?AddControl@C_Window@@QAEXPAVC_Base@@@Z:PROC	; C_Window::AddControl
EXTRN	?AddControlTop@C_Window@@QAEXPAVC_Base@@@Z:PROC	; C_Window::AddControlTop
EXTRN	?UnHideCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::UnHideCluster
EXTRN	?HideCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::HideCluster
EXTRN	?SetGroupState@C_Window@@QAEXJF@Z:PROC		; C_Window::SetGroupState
EXTRN	?RefreshWindow@C_Window@@QAEXXZ:PROC		; C_Window::RefreshWindow
EXTRN	?RefreshClient@C_Window@@QAEXJ@Z:PROC		; C_Window::RefreshClient
EXTRN	?FindControl@C_Window@@QAEPAVC_Base@@J@Z:PROC	; C_Window::FindControl
EXTRN	?ShowWindow@C_Handler@@QAEHPAVC_Window@@@Z:PROC	; C_Handler::ShowWindow
EXTRN	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z:PROC	; C_Handler::HideWindow
EXTRN	?EnableWindowGroup@C_Handler@@QAEXJ@Z:PROC	; C_Handler::EnableWindowGroup
EXTRN	?DisableWindowGroup@C_Handler@@QAEXJ@Z:PROC	; C_Handler::DisableWindowGroup
EXTRN	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z:PROC ; C_Handler::WindowToFront
EXTRN	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z:PROC ; C_Handler::FindWindowA
EXTRN	?WaitForLoader@Loader@@QAEXXZ:PROC		; Loader::WaitForLoader
EXTRN	??0ACMI_Hash@@QAE@XZ:PROC			; ACMI_Hash::ACMI_Hash
EXTRN	??1ACMI_Hash@@QAE@XZ:PROC			; ACMI_Hash::~ACMI_Hash
EXTRN	?Setup@ACMI_Hash@@QAEXK@Z:PROC			; ACMI_Hash::Setup
EXTRN	?Cleanup@ACMI_Hash@@QAEXXZ:PROC			; ACMI_Hash::Cleanup
EXTRN	?Import@ACMITape@@SAHPAD0@Z:PROC		; ACMITape::Import
EXTRN	?GetNewSimTime@ACMITape@@QAEMM@Z:PROC		; ACMITape::GetNewSimTime
EXTRN	?SetHeadPosition@ACMITape@@QAEXM@Z:PROC		; ACMITape::SetHeadPosition
EXTRN	?SetWingTrails@ACMITape@@QAEXH@Z:PROC		; ACMITape::SetWingTrails
EXTRN	?GetTextEvents@ACMITape@@QAEPAXPAH@Z:PROC	; ACMITape::GetTextEvents
EXTRN	?AdvanceAllHeads@ACMITape@@AAEXXZ:PROC		; ACMITape::AdvanceAllHeads
EXTRN	??0ACMIView@@QAE@XZ:PROC			; ACMIView::ACMIView
EXTRN	??1ACMIView@@QAE@XZ:PROC			; ACMIView::~ACMIView
EXTRN	?ToggleScreenShot@ACMIView@@QAEXXZ:PROC		; ACMIView::ToggleScreenShot
EXTRN	?ToggleLabel@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleLabel
EXTRN	?ToggleHeading@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleHeading
EXTRN	?ToggleAirSpeed@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleAirSpeed
EXTRN	?ToggleAltitude@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleAltitude
EXTRN	?ToggleTurnRate@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleTurnRate
EXTRN	?ToggleTurnRadius@ACMIView@@QAEXH@Z:PROC	; ACMIView::ToggleTurnRadius
EXTRN	?ToggleWireFrame@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleWireFrame
EXTRN	?TogglePoles@ACMIView@@QAEXH@Z:PROC		; ACMIView::TogglePoles
EXTRN	?ToggleLockLines@ACMIView@@QAEXH@Z:PROC		; ACMIView::ToggleLockLines
EXTRN	?Togglelockrange@ACMIView@@QAEXH@Z:PROC		; ACMIView::Togglelockrange
EXTRN	?InitGraphics@ACMIView@@QAEXPAVC_Window@@@Z:PROC ; ACMIView::InitGraphics
EXTRN	?ExitGraphics@ACMIView@@QAEHXZ:PROC		; ACMIView::ExitGraphics
EXTRN	?Exec@ACMIView@@QAEXXZ:PROC			; ACMIView::Exec
EXTRN	?Draw@ACMIView@@QAEXXZ:PROC			; ACMIView::Draw
EXTRN	?InitUIVector@ACMIView@@QAEXXZ:PROC		; ACMIView::InitUIVector
EXTRN	?SetListBoxID@ACMIView@@QAEPADHJ@Z:PROC		; ACMIView::SetListBoxID
EXTRN	?ListBoxID@ACMIView@@QAEJHJ@Z:PROC		; ACMIView::ListBoxID
EXTRN	?SelectCamera@ACMIView@@QAEXJ@Z:PROC		; ACMIView::SelectCamera
EXTRN	?SwitchCameraObject@ACMIView@@QAEXJ@Z:PROC	; ACMIView::SwitchCameraObject
EXTRN	?SwitchTrackingObject@ACMIView@@QAEXJ@Z:PROC	; ACMIView::SwitchTrackingObject
EXTRN	?LoadTape@ACMIView@@QAEHPADH@Z:PROC		; ACMIView::LoadTape
EXTRN	?UnloadTape@ACMIView@@QAEXH@Z:PROC		; ACMIView::UnloadTape
EXTRN	?SetPannerXYZ@ACMIView@@QAEXMMM@Z:PROC		; ACMIView::SetPannerXYZ
EXTRN	?SetPannerAzEl@ACMIView@@QAEXMM@Z:PROC		; ACMIView::SetPannerAzEl
EXTRN	?Release@CDXVbManager@@QAEXXZ:PROC		; CDXVbManager::Release
EXTRN	?DelVHSFileCB@@YAXJFPAVC_Base@@@Z:PROC		; DelVHSFileCB
EXTRN	?SetDeleteCallback@@YAXP6AXJFPAVC_Base@@@Z@Z:PROC ; SetDeleteCallback
EXTRN	?AreYouSure@@YAXJJP6AXJFPAVC_Base@@@Z1@Z:PROC	; AreYouSure
EXTRN	?CloseAllRenderers@@YAXJ@Z:PROC			; CloseAllRenderers
EXTRN	?ProcessEventArray@@YAXPAVC_Window@@PAXH@Z:PROC	; ProcessEventArray
EXTRN	?CloseWindowCB@@YAXJFPAVC_Base@@@Z:PROC		; CloseWindowCB
EXTRN	?LoadAFile@@YAXJPADQAPADP6AXJFPAVC_Base@@@Z3@Z:PROC ; LoadAFile
EXTRN	?SaveAFile@@YAXJPADQAPADP6AXJFPAVC_Base@@@Z30@Z:PROC ; SaveAFile
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?gFontList@@3PAVC_Font@@A:DWORD			; gFontList
EXTRN	?gPopupMgr@@3PAVC_PopupMgr@@A:DWORD		; gPopupMgr
EXTRN	?TheLoader@@3VLoader@@A:BYTE			; TheLoader
EXTRN	?drawLabels@DrawableBSP@@2HA:DWORD		; DrawableBSP::drawLabels
EXTRN	?drawHeading@DrawablePoled@@2HA:DWORD		; DrawablePoled::drawHeading
EXTRN	?drawAlt@DrawablePoled@@2HA:DWORD		; DrawablePoled::drawAlt
EXTRN	?drawSpeed@DrawablePoled@@2HA:DWORD		; DrawablePoled::drawSpeed
EXTRN	?drawTurnRadius@DrawablePoled@@2HA:DWORD	; DrawablePoled::drawTurnRadius
EXTRN	?drawTurnRate@DrawablePoled@@2HA:DWORD		; DrawablePoled::drawTurnRate
EXTRN	?drawPole@DrawablePoled@@2HA:DWORD		; DrawablePoled::drawPole
EXTRN	?drawlockrange@DrawablePoled@@2HA:DWORD		; DrawablePoled::drawlockrange
EXTRN	?TheVbManager@@3VCDXVbManager@@A:BYTE		; TheVbManager
EXTRN	?g_bHiResUI@@3_NA:BYTE				; g_bHiResUI
EXTRN	?g_nACMIOptionsPopupHiResX@@3HA:DWORD		; g_nACMIOptionsPopupHiResX
EXTRN	?g_nACMIOptionsPopupHiResY@@3HA:DWORD		; g_nACMIOptionsPopupHiResY
EXTRN	?g_nACMIOptionsPopupLowResX@@3HA:DWORD		; g_nACMIOptionsPopupLowResX
EXTRN	?g_nACMIOptionsPopupLowResY@@3HA:DWORD		; g_nACMIOptionsPopupLowResY
EXTRN	?g_bEmptyFilenameFix@@3_NA:BYTE			; g_bEmptyFilenameFix
EXTRN	?ACMILoaded@@3HA:DWORD				; ACMILoaded
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?gMainParser@@3PAVC_Parser@@A:DWORD		; gMainParser
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3b449ba6
CONST	SEGMENT
__real@3b449ba6 DD 03b449ba6r			; 0.003
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DAELODFB@lastflt?4vhs?$AA@
CONST	SEGMENT
??_C@_0M@DAELODFB@lastflt?4vhs?$AA@ DB 'lastflt.vhs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FEAMKGAE@?$CF02d?3?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BE@FEAMKGAE@?$CF02d?3?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%02d:%02d:'
	DB	'%02d:%02d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MGNAKJFG@ac_scf?4lst?$AA@
CONST	SEGMENT
??_C@_0L@MGNAKJFG@ac_scf?4lst?$AA@ DB 'ac_scf.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OKMPGJJN@ac_snd?4lst?$AA@
CONST	SEGMENT
??_C@_0L@OKMPGJJN@ac_snd?4lst?$AA@ DB 'ac_snd.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HHPJKLOK@ac_art?4lst?$AA@
CONST	SEGMENT
??_C@_0L@HHPJKLOK@ac_art?4lst?$AA@ DB 'ac_art.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@
CONST	SEGMENT
??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@ DB 'acmibin\*.vhs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OFDCPHI@acmibin?2?$CFs?4vhs?$AA@
CONST	SEGMENT
??_C@_0P@OFDCPHI@acmibin?2?$CFs?4vhs?$AA@ DB 'acmibin\%s.vhs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELKONGGK@?4vhs?$AA@
CONST	SEGMENT
??_C@_04ELKONGGK@?4vhs?$AA@ DB '.vhs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDJHFN@?$CFs?4vhs?$AA@
CONST	SEGMENT
??_C@_06NDJHFN@?$CFs?4vhs?$AA@ DB '%s.vhs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PCNDMELA@acmibin?2TAPE?$CF04d?4vhs?$AA@
CONST	SEGMENT
??_C@_0BF@PCNDMELA@acmibin?2TAPE?$CF04d?4vhs?$AA@ DB 'acmibin\TAPE%04d.vh'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIILMCIP@acmibin?2?$AA@
CONST	SEGMENT
??_C@_08DIILMCIP@acmibin?2?$AA@ DB 'acmibin\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBEJELDD@acmibin?2acmi?$CK?4flt?$AA@
CONST	SEGMENT
??_C@_0BC@CBEJELDD@acmibin?2acmi?$CK?4flt?$AA@ DB 'acmibin\acmi*.flt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GPJAONGB@WingTrails?5Max?5?6?$AA@
CONST	SEGMENT
??_C@_0BB@GPJAONGB@WingTrails?5Max?5?6?$AA@ DB 'WingTrails Max ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IAPBICPN@WingTrails?5Long?5?6?$AA@
CONST	SEGMENT
??_C@_0BC@IAPBICPN@WingTrails?5Long?5?6?$AA@ DB 'WingTrails Long ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@COMFOKND@WingTrails?5Medium?5?6?$AA@
CONST	SEGMENT
??_C@_0BE@COMFOKND@WingTrails?5Medium?5?6?$AA@ DB 'WingTrails Medium ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ELLGBKDE@WingTrails?5Short?5?6?$AA@
CONST	SEGMENT
??_C@_0BD@ELLGBKDE@WingTrails?5Short?5?6?$AA@ DB 'WingTrails Short ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?InitACMIIDTable@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitACMIIDTable@@YAXXZ$0
__unwindtable$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z$0
__unwindtable$?HookupACMIControls@@YAXJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HookupACMIControls@@YAXJ@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HookupACMIControls@@YAXJ@Z$1
__unwindtable$?FindACMIFLTFiles@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindACMIFLTFiles@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindACMIFLTFiles@@YAXXZ$1
__ehfuncinfo$?InitACMIIDTable@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitACMIIDTable@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?HookupACMIControls@@YAXJ@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?HookupACMIControls@@YAXJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?FindACMIFLTFiles@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindACMIFLTFiles@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_itemSel$ = -8						; size = 4
_ACMIListBox$ = -4					; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 4
_control$ = 16						; size = 4
?ACMICamTrackingCB@@YAXJHPAVC_Control@@@Z PROC		; ACMICamTrackingCB

; 2281 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2282 : 	C_ListBox
; 2283 : 		*ACMIListBox;
; 2284 : 
; 2285 : 	long
; 2286 : 		itemSel;
; 2287 : 
; 2288 : 	ACMIListBox = (C_ListBox *)control;

	mov	eax, DWORD PTR _control$[ebp]
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2289 : 
; 2290 : 	if
; 2291 : 	(
; 2292 : 		hittype == C_TYPE_SELECT &&
; 2293 : 		ACMIViewIsReady() &&
; 2294 : 		ACMIListBox != NULL
; 2295 : 	)

	cmp	DWORD PTR _hittype$[ebp], 28		; 0000001cH
	jne	SHORT $LN2@ACMICamTra
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMICamTra
	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN2@ACMICamTra

; 2296 : 	{
; 2297 : 		itemSel = ACMIListBox->GetTextID();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _itemSel$[ebp], eax

; 2298 : 
; 2299 : 		acmiView->SwitchTrackingObject(itemSel);

	mov	ecx, DWORD PTR _itemSel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SwitchTrackingObject@ACMIView@@QAEXJ@Z	; ACMIView::SwitchTrackingObject
$LN2@ACMICamTra:

; 2300 : 	}
; 2301 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMICamTrackingCB@@YAXJHPAVC_Control@@@Z ENDP		; ACMICamTrackingCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
;	COMDAT ?ACMIViewIsReady@@YAHXZ
_TEXT	SEGMENT
tv76 = -4						; size = 4
?ACMIViewIsReady@@YAHXZ PROC				; ACMIViewIsReady, COMDAT

; 1179 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1180 : 	return
; 1181 : 	(
; 1182 : 		(
; 1183 : 			acmiView != NULL &&
; 1184 : 			acmiView->Tape() != NULL &&
; 1185 : 			acmiView->Tape()->IsLoaded() &&
; 1186 : 			acmiView->TapeHasLoaded()
; 1187 : 		) ?
; 1188 : 		TRUE :
; 1189 : 		FALSE
; 1190 : 	);

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN3@ACMIViewIs
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	test	eax, eax
	je	SHORT $LN3@ACMIViewIs
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?IsLoaded@ACMITape@@QAEHXZ		; ACMITape::IsLoaded
	test	eax, eax
	je	SHORT $LN3@ACMIViewIs
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?TapeHasLoaded@ACMIView@@QAEHXZ		; ACMIView::TapeHasLoaded
	test	eax, eax
	je	SHORT $LN3@ACMIViewIs
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@ACMIViewIs
$LN3@ACMIViewIs:
	mov	DWORD PTR tv76[ebp], 0
$LN4@ACMIViewIs:
	mov	eax, DWORD PTR tv76[ebp]

; 1191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIViewIsReady@@YAHXZ ENDP				; ACMIViewIsReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?SaveACMIFileCB@@YAXJFPAVC_Base@@@Z PROC		; SaveACMIFileCB

; 1162 : {

	push	ebp
	mov	ebp, esp

; 1163 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN1@SaveACMIFi

; 1164 : 		return;

	jmp	SHORT $LN2@SaveACMIFi
$LN1@SaveACMIFi:

; 1165 : 
; 1166 : 	SetDeleteCallback(DelVHSFileCB);

	push	OFFSET ?DelVHSFileCB@@YAXJFPAVC_Base@@@Z ; DelVHSFileCB
	call	?SetDeleteCallback@@YAXP6AXJFPAVC_Base@@@Z@Z ; SetDeleteCallback
	add	esp, 4

; 1167 : 	SaveAFile(TXT_SAVE_ACMI,"acmibin\\*.vhs",NULL,ACMI_VerifySaveItCB,CloseWindowCB, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	push	OFFSET ?ACMI_VerifySaveItCB@@YAXJFPAVC_Base@@@Z ; ACMI_VerifySaveItCB
	push	0
	push	OFFSET ??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@
	push	240					; 000000f0H
	call	?SaveAFile@@YAXJPADQAPADP6AXJFPAVC_Base@@@Z30@Z ; SaveAFile
	add	esp, 24					; 00000018H
$LN2@SaveACMIFi:

; 1168 : }

	pop	ebp
	ret	0
?SaveACMIFileCB@@YAXJFPAVC_Base@@@Z ENDP		; SaveACMIFileCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?LoadACMIFileCB@@YAXJFPAVC_Base@@@Z PROC		; LoadACMIFileCB

; 1146 : {

	push	ebp
	mov	ebp, esp

; 1147 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN1@LoadACMIFi

; 1148 : 		return;

	jmp	SHORT $LN2@LoadACMIFi
$LN1@LoadACMIFi:

; 1149 : 
; 1150 : 	SetDeleteCallback(DelVHSFileCB);

	push	OFFSET ?DelVHSFileCB@@YAXJFPAVC_Base@@@Z ; DelVHSFileCB
	call	?SetDeleteCallback@@YAXP6AXJFPAVC_Base@@@Z@Z ; SetDeleteCallback
	add	esp, 4

; 1151 : 	LoadAFile(TXT_LOAD_ACMI,"acmibin\\*.vhs",NULL,ACMI_LoadACMICB,CloseWindowCB);

	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	push	OFFSET ?ACMI_LoadACMICB@@YAXJFPAVC_Base@@@Z ; ACMI_LoadACMICB
	push	0
	push	OFFSET ??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@
	push	239					; 000000efH
	call	?LoadAFile@@YAXJPADQAPADP6AXJFPAVC_Base@@@Z3@Z ; LoadAFile
	add	esp, 20					; 00000014H
$LN2@LoadACMIFi:

; 1152 : }

	pop	ebp
	ret	0
?LoadACMIFileCB@@YAXJFPAVC_Base@@@Z ENDP		; LoadACMIFileCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_fp$ = -272						; size = 4
_ebox$ = -268						; size = 4
_fname$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMI_VerifySaveItCB@@YAXJFPAVC_Base@@@Z PROC		; ACMI_VerifySaveItCB

; 1097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1098 : 	C_EditBox *ebox;
; 1099 : 	_TCHAR fname[MAX_PATH];
; 1100 : 	FILE *fp;
; 1101 : 
; 1102 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN6@ACMI_Verif

; 1103 : 		return;

	jmp	$LN7@ACMI_Verif
$LN6@ACMI_Verif:

; 1104 : 
; 1105 : 	ebox=(C_EditBox*)control->Parent_->FindControl(FILE_NAME);

	push	501					; 000001f5H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 1106 : 	if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	$LN7@ACMI_Verif

; 1107 : 	{
; 1108 : 		//dpc EmptyFilenameSaveFix, modified by MN - added a warning to enter a filename
; 1109 : 		if (g_bEmptyFilenameFix)

	movzx	edx, BYTE PTR ?g_bEmptyFilenameFix@@3_NA ; g_bEmptyFilenameFix
	test	edx, edx
	je	SHORT $LN4@ACMI_Verif

; 1110 : 		{
; 1111 : 			if (_tcslen(ebox->GetText()) == 0)

	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetText@C_EditBox@@QAEPADXZ		; C_EditBox::GetText
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@ACMI_Verif

; 1112 : 			{
; 1113 : 				AreYouSure(TXT_WARNING, TXT_ENTER_FILENAME,CloseWindowCB,CloseWindowCB);

	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	push	467					; 000001d3H
	push	243					; 000000f3H
	call	?AreYouSure@@YAXJJP6AXJFPAVC_Base@@@Z1@Z ; AreYouSure
	add	esp, 16					; 00000010H

; 1114 : 				return;

	jmp	$LN7@ACMI_Verif
$LN4@ACMI_Verif:

; 1115 : 			}
; 1116 : 		}
; 1117 : 		//end EmptyFilenameSaveFix
; 1118 : 
; 1119 : 		_stprintf(fname,"acmibin\\%s.vhs",ebox->GetText());

	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetText@C_EditBox@@QAEPADXZ		; C_EditBox::GetText
	push	eax
	push	OFFSET ??_C@_0P@OFDCPHI@acmibin?2?$CFs?4vhs?$AA@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1120 : 		fp=fopen(fname,"r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1121 : 		if(fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN2@ACMI_Verif

; 1122 : 		{
; 1123 : 			fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 1124 : 			AreYouSure(TXT_WARNING,TXT_FILE_EXISTS,ACMI_SaveItCB,CloseWindowCB);

	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	push	OFFSET ?ACMI_SaveItCB@@YAXJFPAVC_Base@@@Z ; ACMI_SaveItCB
	push	241					; 000000f1H
	push	243					; 000000f3H
	call	?AreYouSure@@YAXJJP6AXJFPAVC_Base@@@Z1@Z ; AreYouSure
	add	esp, 16					; 00000010H

; 1125 : 		}
; 1126 : 		else

	jmp	SHORT $LN7@ACMI_Verif
$LN2@ACMI_Verif:

; 1127 : 			ACMI_SaveItCB(ID,hittype,control);

	mov	eax, DWORD PTR _control$[ebp]
	push	eax
	movzx	ecx, WORD PTR _hittype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	call	?ACMI_SaveItCB@@YAXJFPAVC_Base@@@Z	; ACMI_SaveItCB
	add	esp, 12					; 0000000cH
$LN7@ACMI_Verif:

; 1128 : 	}
; 1129 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ACMI_VerifySaveItCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMI_VerifySaveItCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_renwin$ = -820						; size = 4
_pct$1 = -816						; size = 4
_currpos$2 = -812					; size = 4
_ebox$ = -808						; size = 4
$T3 = -804						; size = 4
_win$4 = -800						; size = 4
_win$ = -796						; size = 4
_text$5 = -792						; size = 4
_i$ = -788						; size = 4
_fnamedir$ = -784					; size = 260
_oldpath$ = -524					; size = 260
_fname$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMI_SaveItCB@@YAXJFPAVC_Base@@@Z PROC			; ACMI_SaveItCB

; 1012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 820				; 00000334H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1013 : 	C_EditBox *ebox;
; 1014 : 	unsigned int i;
; 1015 : 	_TCHAR fname[MAX_PATH];
; 1016 : 	_TCHAR fnamedir[MAX_PATH];
; 1017 : 	_TCHAR oldpath[MAX_PATH];
; 1018 : 	C_Window *renwin;
; 1019 : 	C_Window *win;
; 1020 : 
; 1021 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN12@ACMI_SaveI

; 1022 : 		return;

	jmp	$LN13@ACMI_SaveI
$LN12@ACMI_SaveI:

; 1023 : 
; 1024 : 	renwin=gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _renwin$[ebp], eax

; 1025 : 	if(renwin == NULL)

	cmp	DWORD PTR _renwin$[ebp], 0
	jne	SHORT $LN11@ACMI_SaveI

; 1026 : 			return;

	jmp	$LN13@ACMI_SaveI
$LN11@ACMI_SaveI:

; 1027 : 
; 1028 : 	win=gMainHandler->FindWindow(SAVE_WIN);

	push	500					; 000001f4H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1029 : 	if(!win)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN10@ACMI_SaveI

; 1030 : 		return;

	jmp	$LN13@ACMI_SaveI
$LN10@ACMI_SaveI:

; 1031 : 
; 1032 : 	acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 1033 : 
; 1034 : 	sprintf(fnamedir,"acmibin\\");

	push	OFFSET ??_C@_08DIILMCIP@acmibin?2?$AA@
	lea	ecx, DWORD PTR _fnamedir$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 1035 : 				
; 1036 : 	gMainHandler->HideWindow(win);

	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::HideWindow

; 1037 : 	gMainHandler->HideWindow(control->Parent_);

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::HideWindow

; 1038 : 
; 1039 : 	ebox=(C_EditBox*)win->FindControl(FILE_NAME);

	push	501					; 000001f5H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 1040 : 	if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	$LN1@ACMI_SaveI

; 1041 : 	{
; 1042 : 		_tcscpy(fname,ebox->GetText());

	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetText@C_EditBox@@QAEPADXZ		; C_EditBox::GetText
	push	eax
	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1043 : 		for(i=0;i<_tcslen(fname);i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@ACMI_SaveI
$LN7@ACMI_SaveI:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@ACMI_SaveI:
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN6@ACMI_SaveI

; 1044 : 			if(fname[i] == '.')

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _fname$[ebp+edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN5@ACMI_SaveI

; 1045 : 				fname[i]=0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 260			; 00000104H
	jae	SHORT $LN15@ACMI_SaveI
	jmp	SHORT $LN16@ACMI_SaveI
$LN15@ACMI_SaveI:
	call	___report_rangecheckfailure
$LN16@ACMI_SaveI:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _fname$[ebp+edx], 0
$LN5@ACMI_SaveI:

; 1046 : 
; 1047 : 		if(fname[0] == 0)

	jmp	SHORT $LN7@ACMI_SaveI
$LN6@ACMI_SaveI:
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _fname$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN4@ACMI_SaveI

; 1048 : 			return;

	jmp	$LN13@ACMI_SaveI
$LN4@ACMI_SaveI:

; 1049 : 
; 1050 : 		_tcscat(fname,".vhs");

	push	OFFSET ??_C@_04ELKONGGK@?4vhs?$AA@
	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1051 : 
; 1052 : 		strcpy( oldpath,"acmibin\\" );

	push	OFFSET ??_C@_08DIILMCIP@acmibin?2?$AA@
	lea	eax, DWORD PTR _oldpath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1053 : 		strcat( oldpath, loadedfname );

	push	OFFSET ?loadedfname@@3PADA		; loadedfname
	lea	ecx, DWORD PTR _oldpath$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1054 : 		_tcscat(fnamedir,fname);

	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	lea	eax, DWORD PTR _fnamedir$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1055 : 
; 1056 : 		// get the tape head position
; 1057 : 		int currpos = gFrameMarker->GetSliderPos();

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?GetSliderPos@C_Slider@@QAEJXZ		; C_Slider::GetSliderPos
	mov	DWORD PTR _currpos$2[ebp], eax

; 1058 : 		float pct = (float)(currpos-gFrameMarkerMin)/(float)gFrameMarkerLen;

	mov	ecx, DWORD PTR _currpos$2[ebp]
	sub	ecx, DWORD PTR ?gFrameMarkerMin@@3HA	; gFrameMarkerMin
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR ?gFrameMarkerLen@@3HA	; gFrameMarkerLen
	divss	xmm0, xmm1
	movss	DWORD PTR _pct$1[ebp], xmm0

; 1059 : 
; 1060 : 		// stop the tape
; 1061 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 1062 : 
; 1063 : 		// rename won't work unless the tape file is close so unload it
; 1064 : 		acmiView->UnloadTape( TRUE );

	push	1
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape

; 1065 : 
; 1066 : 		// rename/copy file to new name
; 1067 : 		CopyFile( oldpath, fnamedir, FALSE );

	push	0
	lea	edx, DWORD PTR _fnamedir$[ebp]
	push	edx
	lea	eax, DWORD PTR _oldpath$[ebp]
	push	eax
	call	DWORD PTR __imp__CopyFileA@12

; 1068 : 
; 1069 : 		// reload the tape
; 1070 : 		if(!acmiView->LoadTape(fname , TRUE))

	push	1
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?LoadTape@ACMIView@@QAEHPADH@Z		; ACMIView::LoadTape

; 1071 : 		{
; 1072 : 			// something's fucked
; 1073 : 		}
; 1074 : 
; 1075 : 		// restore setting for wing trails on tape
; 1076 : 		// restore tape head positiion
; 1077 : 		acmiView->Tape()->SetHeadPosition( pct );

	push	ecx
	movss	xmm0, DWORD PTR _pct$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetHeadPosition@ACMITape@@QAEXM@Z	; ACMITape::SetHeadPosition

; 1078 : 		acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	edx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 1079 : 		acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	eax, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 1080 : 		acmiView->Tape()->SetObjScale(gObjScale);

	push	ecx
	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 1081 : 
; 1082 : 		C_Window *win=gMainHandler->FindWindow(ACMI_RIGHT_WIN);

	push	200100					; 00030da4H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$4[ebp], eax

; 1083 : 		if(win)

	cmp	DWORD PTR _win$4[ebp], 0
	je	SHORT $LN1@ACMI_SaveI

; 1084 : 		{
; 1085 : 			C_Text *text = (C_Text *)win->FindControl(ACMI_TAPE_NAME);

	push	200148					; 00030dd4H
	mov	ecx, DWORD PTR _win$4[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _text$5[ebp], eax

; 1086 : 			if(text!=NULL)

	cmp	DWORD PTR _text$5[ebp], 0
	je	SHORT $LN1@ACMI_SaveI

; 1087 : 			{
; 1088 : 				text->SetText(fname);

	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _text$5[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1089 : 				text->Refresh();

	mov	eax, DWORD PTR _text$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _text$5[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@ACMI_SaveI:

; 1090 : 			}
; 1091 : 		}
; 1092 : 	}
; 1093 : 	acmiDraw = TRUE;

	mov	DWORD PTR ?acmiDraw@@3HA, 1		; acmiDraw
$LN13@ACMI_SaveI:

; 1094 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ACMI_SaveItCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMI_SaveItCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_count$1 = -580						; size = 4
_events$2 = -576					; size = 4
$T3 = -572						; size = 4
_ebox$ = -568						; size = 4
_numEntities$ = -564					; size = 4
_camFilter$ = -560					; size = 4
_i$4 = -556						; size = 4
_text$ = -552						; size = 4
_objectName$ = -548					; size = 4
_renwin$ = -544						; size = 4
_ACMIListBox$ = -540					; size = 4
_listBoxIds$ = -536					; size = 4
_objectNum$ = -532					; size = 4
_win$ = -528						; size = 4
_buf$5 = -524						; size = 260
_fname$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMI_LoadACMICB@@YAXJFPAVC_Base@@@Z PROC		; ACMI_LoadACMICB

; 835  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 836  : 	C_Window *win;
; 837  :    	C_Text   *text;
; 838  : 	C_ListBox *ACMIListBox, *camFilter;
; 839  : 	char *objectName;
; 840  : 	long objectNum,numEntities,listBoxIds = listBoxBaseID;

	mov	DWORD PTR _listBoxIds$[ebp], 1

; 841  : 	C_EditBox * ebox;
; 842  : 	_TCHAR fname[MAX_PATH];
; 843  : 	C_Window *renwin;
; 844  : 
; 845  : 	if(!acmiView)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	jne	SHORT $LN28@ACMI_LoadA

; 846  : 		return;

	jmp	$LN29@ACMI_LoadA
$LN28@ACMI_LoadA:

; 847  : 
; 848  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN27@ACMI_LoadA

; 849  : 		return;

	jmp	$LN29@ACMI_LoadA
$LN27@ACMI_LoadA:

; 850  : 
; 851  : 	renwin=gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _renwin$[ebp], eax

; 852  : 	if(renwin == NULL)

	cmp	DWORD PTR _renwin$[ebp], 0
	jne	SHORT $LN26@ACMI_LoadA

; 853  : 		return;

	jmp	$LN29@ACMI_LoadA
$LN26@ACMI_LoadA:

; 854  : 
; 855  : 	acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 856  : 	
; 857  : 
; 858  : 	ebox=(C_EditBox*)control->Parent_->FindControl(FILE_NAME);

	push	501					; 000001f5H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 859  : 	if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	$LN16@ACMI_LoadA

; 860  : 	{
; 861  : 		_tcscpy(fname,ebox->GetText());

	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetText@C_EditBox@@QAEPADXZ		; C_EditBox::GetText
	push	eax
	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 862  : 		for(unsigned int i=0;i<_tcslen(fname);i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN24@ACMI_LoadA
$LN23@ACMI_LoadA:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN24@ACMI_LoadA:
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _i$4[ebp], eax
	jae	SHORT $LN22@ACMI_LoadA

; 863  : 		{
; 864  : 			if(fname[i] == '.')

	mov	edx, DWORD PTR _i$4[ebp]
	movsx	eax, BYTE PTR _fname$[ebp+edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN21@ACMI_LoadA

; 865  : 			{
; 866  : 				fname[i]=0;

	mov	ecx, DWORD PTR _i$4[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 260			; 00000104H
	jae	SHORT $LN31@ACMI_LoadA
	jmp	SHORT $LN32@ACMI_LoadA
$LN31@ACMI_LoadA:
	call	___report_rangecheckfailure
$LN32@ACMI_LoadA:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _fname$[ebp+edx], 0
$LN21@ACMI_LoadA:

; 867  : 			}
; 868  : 		}

	jmp	SHORT $LN23@ACMI_LoadA
$LN22@ACMI_LoadA:

; 869  : 		
; 870  : 		if(fname[0] == 0)

	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _fname$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN20@ACMI_LoadA

; 871  : 				return;

	jmp	$LN29@ACMI_LoadA
$LN20@ACMI_LoadA:

; 872  : 		
; 873  : 		_TCHAR buf[MAX_PATH];
; 874  : 		_stprintf(buf,_T("%s.vhs"),fname);

	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	push	OFFSET ??_C@_06NDJHFN@?$CFs?4vhs?$AA@
	lea	eax, DWORD PTR _buf$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 875  : 
; 876  : 		sprintf(fname,buf);

	lea	ecx, DWORD PTR _buf$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 877  : 
; 878  : 		// make sure no tape is now loaded
; 879  : 		acmiView->UnloadTape(FALSE);

	push	0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape

; 880  : 
; 881  : 		// Load the tape.
; 882  : 		if(!acmiView->LoadTape(fname,FALSE))

	push	0
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?LoadTape@ACMIView@@QAEHPADH@Z		; ACMIView::LoadTape
	test	eax, eax
	jne	SHORT $LN19@ACMI_LoadA

; 883  : 		{
; 884  : 			acmiView->UnloadTape(FALSE);

	push	0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape

; 885  : 			return;

	jmp	$LN29@ACMI_LoadA
$LN19@ACMI_LoadA:

; 886  : 		}
; 887  : 		acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	ecx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 888  : 		acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	edx, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 889  : 		acmiView->Tape()->SetObjScale(gObjScale);

	push	ecx
	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 890  : 
; 891  : 		//save the filename for future reference.
; 892  : 		sprintf(loadedfname,fname);

	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	push	OFFSET ?loadedfname@@3PADA		; loadedfname
	call	_sprintf
	add	esp, 8

; 893  : 
; 894  : 
; 895  : 		win=gMainHandler->FindWindow(ACMI_RIGHT_WIN);

	push	200100					; 00030da4H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 896  : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN17@ACMI_LoadA

; 897  : 		{
; 898  : 			text = (C_Text *)win->FindControl(ACMI_TAPE_NAME);

	push	200148					; 00030dd4H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _text$[ebp], eax

; 899  : 			if(text!=NULL)

	cmp	DWORD PTR _text$[ebp], 0
	je	SHORT $LN17@ACMI_LoadA

; 900  : 			{
; 901  : 				text->SetText(fname);

	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _text$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 902  : 				text->Refresh();

	mov	eax, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN17@ACMI_LoadA:

; 903  : 			}
; 904  : 		}
; 905  : 
; 906  : 		acmiView->InitUIVector();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?InitUIVector@ACMIView@@QAEXXZ		; ACMIView::InitUIVector

; 907  : 
; 908  : 		win = gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 909  : 	
; 910  : 		if (win != NULL)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN16@ACMI_LoadA

; 911  : 		{
; 912  : 			camFilter = (C_ListBox *)win->FindControl(ACMI_CAMERA); 

	push	200024					; 00030d58H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _camFilter$[ebp], eax

; 913  : 			if (camFilter != NULL)

	cmp	DWORD PTR _camFilter$[ebp], 0
	je	SHORT $LN15@ACMI_LoadA

; 914  : 			{ // Init camera view stuff to inside cockpit view
; 915  : 				camFilter->SetValue(gCameraMode);

	mov	ecx, DWORD PTR ?gCameraMode@@3HA	; gCameraMode
	push	ecx
	mov	ecx, DWORD PTR _camFilter$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 916  : 				ACMICameraCB(camFilter->GetID(),C_TYPE_SELECT,camFilter);

	mov	edx, DWORD PTR _camFilter$[ebp]
	push	edx
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _camFilter$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	call	?ACMICameraCB@@YAXJFPAVC_Base@@@Z	; ACMICameraCB
	add	esp, 12					; 0000000cH
$LN15@ACMI_LoadA:

; 917  : 			}
; 918  : 		
; 919  : 			numEntities = acmiView->Tape()->NumEntities();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?NumEntities@ACMITape@@QAEHXZ		; ACMITape::NumEntities
	mov	DWORD PTR _numEntities$[ebp], eax

; 920  : 
; 921  : 			listBoxIds = listBoxBaseID;

	mov	DWORD PTR _listBoxIds$[ebp], 1

; 922  : 
; 923  : 			ACMIListBox = (C_ListBox *)win->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 924  : 			if (ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	$LN11@ACMI_LoadA

; 925  : 			{
; 926  : 				ACMIListBox->RemoveAllItems();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 927  : 		
; 928  : 				for (objectNum = 0; objectNum < numEntities; objectNum ++) 

	mov	DWORD PTR _objectNum$[ebp], 0
	jmp	SHORT $LN13@ACMI_LoadA
$LN12@ACMI_LoadA:
	mov	eax, DWORD PTR _objectNum$[ebp]
	add	eax, 1
	mov	DWORD PTR _objectNum$[ebp], eax
$LN13@ACMI_LoadA:
	mov	ecx, DWORD PTR _objectNum$[ebp]
	cmp	ecx, DWORD PTR _numEntities$[ebp]
	jge	SHORT $LN11@ACMI_LoadA

; 929  : 				{
; 930  : 					objectName = acmiView->SetListBoxID(objectNum, listBoxIds);

	mov	edx, DWORD PTR _listBoxIds$[ebp]
	push	edx
	mov	eax, DWORD PTR _objectNum$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
	mov	DWORD PTR _objectName$[ebp], eax

; 931  : 
; 932  : 					if ( *objectName )

	mov	ecx, DWORD PTR _objectName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN10@ACMI_LoadA

; 933  : 					{
; 934  : 						ACMIListBox = ACMIListBox->AddItem(listBoxIds, C_TYPE_ITEM , objectName);

	mov	eax, DWORD PTR _objectName$[ebp]
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _listBoxIds$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 935  : 						listBoxIds++;

	mov	edx, DWORD PTR _listBoxIds$[ebp]
	add	edx, 1
	mov	DWORD PTR _listBoxIds$[ebp], edx

; 936  : 					}
; 937  : 					else

	jmp	SHORT $LN9@ACMI_LoadA
$LN10@ACMI_LoadA:

; 938  : 					{
; 939  : 						acmiView->SetListBoxID(objectNum, -1);

	push	-1
	mov	eax, DWORD PTR _objectNum$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
$LN9@ACMI_LoadA:

; 940  : 					}
; 941  : 				}

	jmp	$LN12@ACMI_LoadA
$LN11@ACMI_LoadA:

; 942  : 			}
; 943  : 
; 944  : 			listBoxIds = listBoxBaseID;

	mov	DWORD PTR _listBoxIds$[ebp], 1

; 945  : 
; 946  : 			ACMIListBox = (C_ListBox *)win->FindControl(TRACKED_OBJECT_FIELD);

	push	200011					; 00030d4bH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 947  : 			if (ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	$LN5@ACMI_LoadA

; 948  : 			{
; 949  : 				ACMIListBox->RemoveAllItems();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 950  : 
; 951  : 				for (objectNum = 0; objectNum < numEntities; objectNum ++) 

	mov	DWORD PTR _objectNum$[ebp], 0
	jmp	SHORT $LN7@ACMI_LoadA
$LN6@ACMI_LoadA:
	mov	ecx, DWORD PTR _objectNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _objectNum$[ebp], ecx
$LN7@ACMI_LoadA:
	mov	edx, DWORD PTR _objectNum$[ebp]
	cmp	edx, DWORD PTR _numEntities$[ebp]
	jge	SHORT $LN5@ACMI_LoadA

; 952  : 				{
; 953  : 					objectName = acmiView->SetListBoxID(objectNum, listBoxIds);

	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _objectNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
	mov	DWORD PTR _objectName$[ebp], eax

; 954  : 					if ( *objectName )

	mov	edx, DWORD PTR _objectName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN4@ACMI_LoadA

; 955  : 					{
; 956  : 						ACMIListBox = ACMIListBox->AddItem(listBoxIds, C_TYPE_ITEM , objectName);

	mov	ecx, DWORD PTR _objectName$[ebp]
	push	ecx
	push	50					; 00000032H
	mov	edx, DWORD PTR _listBoxIds$[ebp]
	push	edx
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 957  : 						listBoxIds++;

	mov	eax, DWORD PTR _listBoxIds$[ebp]
	add	eax, 1
	mov	DWORD PTR _listBoxIds$[ebp], eax

; 958  : 					}
; 959  : 					else

	jmp	SHORT $LN3@ACMI_LoadA
$LN4@ACMI_LoadA:

; 960  : 					{
; 961  : 						acmiView->SetListBoxID(objectNum, -1);

	push	-1
	mov	ecx, DWORD PTR _objectNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
$LN3@ACMI_LoadA:

; 962  : 					}
; 963  : 
; 964  : 				}

	jmp	$LN6@ACMI_LoadA
$LN5@ACMI_LoadA:

; 965  : 			}
; 966  : 
; 967  : 			// edg
; 968  : 			// this call puts the event strings into the
; 969  : 			// event list window -- seems to be broken now...
; 970  : 			void *events;
; 971  : 			int count;
; 972  : 			events = acmiView->Tape()->GetTextEvents( &count );

	lea	edx, DWORD PTR _count$1[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetTextEvents@ACMITape@@QAEPAXPAH@Z	; ACMITape::GetTextEvents
	mov	DWORD PTR _events$2[ebp], eax

; 973  : 			ProcessEventArray(win, events, count);

	mov	eax, DWORD PTR _count$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _events$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	call	?ProcessEventArray@@YAXPAVC_Window@@PAXH@Z ; ProcessEventArray
	add	esp, 12					; 0000000cH
$LN16@ACMI_LoadA:

; 974  : 	
; 975  : 		}// if win != null
; 976  : 	} // end listbox
; 977  : 
; 978  : 	gMainHandler->HideWindow(control->Parent_);

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::HideWindow

; 979  : 
; 980  : 	win=gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 981  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN2@ACMI_LoadA

; 982  : 	{
; 983  : 		gMainHandler->ShowWindow(win);

	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?ShowWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::ShowWindow

; 984  : 		gMainHandler->WindowToFront(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::WindowToFront
$LN2@ACMI_LoadA:

; 985  : 	}
; 986  : 	win=gMainHandler->FindWindow(ACMI_RIGHT_WIN);

	push	200100					; 00030da4H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 987  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN1@ACMI_LoadA

; 988  : 	{
; 989  : 		gMainHandler->ShowWindow(win);

	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?ShowWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::ShowWindow

; 990  : 		gMainHandler->WindowToFront(win);

	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::WindowToFront
$LN1@ACMI_LoadA:

; 991  : 	}
; 992  : 	renwin->UnHideCluster(100);

	push	100					; 00000064H
	mov	ecx, DWORD PTR _renwin$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster

; 993  : 	renwin->HideCluster(200);

	push	200					; 000000c8H
	mov	ecx, DWORD PTR _renwin$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 994  : 	gMainHandler->ShowWindow(renwin);

	mov	eax, DWORD PTR _renwin$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?ShowWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::ShowWindow

; 995  : 	gMainHandler->WindowToFront(renwin);

	mov	ecx, DWORD PTR _renwin$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::WindowToFront

; 996  : 
; 997  : 	acmiDraw = TRUE;

	mov	DWORD PTR ?acmiDraw@@3HA, 1		; acmiDraw

; 998  : 	renderACMI = TRUE;

	mov	DWORD PTR ?renderACMI@@3HA, 1		; renderACMI

; 999  : 
; 1000 : 	renwin->HideCluster(100);

	push	100					; 00000064H
	mov	ecx, DWORD PTR _renwin$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 1001 : 	renwin->UnHideCluster(200);

	push	200					; 000000c8H
	mov	ecx, DWORD PTR _renwin$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster
$LN29@ACMI_LoadA:

; 1002 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ACMI_LoadACMICB@@YAXJFPAVC_Base@@@Z ENDP		; ACMI_LoadACMICB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_fp$ = -700						; size = 4
_foundAFile$ = -696					; size = 4
_findHand$ = -692					; size = 4
_y$ = -688						; size = 4
_fData$ = -684						; size = 320
_fltname$ = -364					; size = 260
_fname$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
?ACMI_ImportFile@@YAXXZ PROC				; ACMI_ImportFile

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 700				; 000002bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 782  : 	FILE *fp;
; 783  : 	int y;
; 784  : 	char fname[100];
; 785  : 	char fltname[MAX_PATH];
; 786  : 	HANDLE findHand;
; 787  : 	WIN32_FIND_DATA fData;
; 788  : 	BOOL foundAFile = TRUE;

	mov	DWORD PTR _foundAFile$[ebp], 1

; 789  : 
; 790  : 	// look for *.flt files to import
; 791  : 	findHand = FindFirstFile ("acmibin\\acmi*.flt", &fData );

	lea	eax, DWORD PTR _fData$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@CBEJELDD@acmibin?2acmi?$CK?4flt?$AA@
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	DWORD PTR _findHand$[ebp], eax

; 792  : 
; 793  : 	// find anything?
; 794  : 	if ( findHand == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _findHand$[ebp], -1
	jne	SHORT $LN7@ACMI_Impor

; 795  : 		return;

	jmp	$LN9@ACMI_Impor
$LN7@ACMI_Impor:

; 796  : 
; 797  : 	while( foundAFile )

	cmp	DWORD PTR _foundAFile$[ebp], 0
	je	$LN6@ACMI_Impor

; 798  : 	{
; 799  : 		strcpy( fltname, "acmibin\\" );

	push	OFFSET ??_C@_08DIILMCIP@acmibin?2?$AA@
	lea	ecx, DWORD PTR _fltname$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 800  : 		strcat( fltname, fData.cFileName );

	lea	edx, DWORD PTR _fData$[ebp+44]
	push	edx
	lea	eax, DWORD PTR _fltname$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 801  : 	
; 802  : 		// find a suitable name to import to
; 803  : 		for ( y = 1; y < 10000; y++ )

	mov	DWORD PTR _y$[ebp], 1
	jmp	SHORT $LN5@ACMI_Impor
$LN4@ACMI_Impor:
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx
$LN5@ACMI_Impor:
	cmp	DWORD PTR _y$[ebp], 10000		; 00002710H
	jge	SHORT $LN3@ACMI_Impor

; 804  : 		{
; 805  : 			sprintf( fname, "acmibin\\TAPE%04d.vhs", y );

	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@PCNDMELA@acmibin?2TAPE?$CF04d?4vhs?$AA@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 806  : 
; 807  : 			fp = fopen( fname, "r" );

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 808  : 			if ( !fp )

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN2@ACMI_Impor

; 809  : 			{
; 810  : 				ACMITape::Import( fltname, fname );

	lea	edx, DWORD PTR _fname$[ebp]
	push	edx
	lea	eax, DWORD PTR _fltname$[ebp]
	push	eax
	call	?Import@ACMITape@@SAHPAD0@Z		; ACMITape::Import
	add	esp, 8

; 811  : 				break;

	jmp	SHORT $LN3@ACMI_Impor

; 812  : 			}
; 813  : 			else

	jmp	SHORT $LN1@ACMI_Impor
$LN2@ACMI_Impor:

; 814  : 			{
; 815  : 				fclose( fp );

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN1@ACMI_Impor:

; 816  : 			}
; 817  : 		}

	jmp	SHORT $LN4@ACMI_Impor
$LN3@ACMI_Impor:

; 818  : 
; 819  : 		// get next file
; 820  : 		foundAFile = FindNextFile( findHand, &fData );

	lea	edx, DWORD PTR _fData$[ebp]
	push	edx
	mov	eax, DWORD PTR _findHand$[ebp]
	push	eax
	call	DWORD PTR __imp__FindNextFileA@8
	mov	DWORD PTR _foundAFile$[ebp], eax

; 821  : 	}

	jmp	$LN7@ACMI_Impor
$LN6@ACMI_Impor:

; 822  : 
; 823  : 	FindClose( findHand );

	mov	ecx, DWORD PTR _findHand$[ebp]
	push	ecx
	call	DWORD PTR __imp__FindClose@4
$LN9@ACMI_Impor:

; 824  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ACMI_ImportFile@@YAXXZ ENDP				; ACMI_ImportFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_menu$ = -20						; size = 4
_w$ = -16						; size = 2
_h$ = -12						; size = 2
_x$ = -8						; size = 2
_y$ = -4						; size = 2
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMItoggleLABELSCB@@YAXJFPAVC_Base@@@Z PROC		; ACMItoggleLABELSCB

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 682  : 
; 683  : 	C_PopupList *menu;
; 684  : 	short x,y;
; 685  : 	short w,h;
; 686  : 
; 687  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN4@ACMItoggle

; 688  : 		return;

	jmp	$LN5@ACMItoggle
$LN4@ACMItoggle:

; 689  : 	
; 690  : 	menu=gPopupMgr->GetMenu(ACMI_OPTION_POPUP);

	push	200151					; 00030dd7H
	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?GetMenu@C_PopupMgr@@QAEPAVC_PopupList@@J@Z ; C_PopupMgr::GetMenu
	mov	DWORD PTR _menu$[ebp], eax

; 691  : 						
; 692  : 	menu->GetWindowSize(&w,&h);

	lea	ecx, DWORD PTR _h$[ebp]
	push	ecx
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?GetWindowSize@C_PopupList@@QAEXPAF0@Z	; C_PopupList::GetWindowSize

; 693  : 
; 694  : 	if (g_bHiResUI)

	movzx	eax, BYTE PTR ?g_bHiResUI@@3_NA		; g_bHiResUI
	test	eax, eax
	je	SHORT $LN3@ACMItoggle

; 695  : 	{
; 696  : 		x = g_nACMIOptionsPopupHiResX;

	mov	cx, WORD PTR ?g_nACMIOptionsPopupHiResX@@3HA
	mov	WORD PTR _x$[ebp], cx

; 697  : 		y = g_nACMIOptionsPopupHiResY;

	mov	dx, WORD PTR ?g_nACMIOptionsPopupHiResY@@3HA
	mov	WORD PTR _y$[ebp], dx

; 698  : 	}
; 699  : 	else

	jmp	SHORT $LN2@ACMItoggle
$LN3@ACMItoggle:

; 700  : 	{
; 701  : 		x = g_nACMIOptionsPopupLowResX;

	mov	ax, WORD PTR ?g_nACMIOptionsPopupLowResX@@3HA
	mov	WORD PTR _x$[ebp], ax

; 702  : 		y = g_nACMIOptionsPopupLowResY;

	mov	cx, WORD PTR ?g_nACMIOptionsPopupLowResY@@3HA
	mov	WORD PTR _y$[ebp], cx
$LN2@ACMItoggle:

; 703  : 	}
; 704  : 
; 705  : //	x = 500; // btn->GetX()-w+20;
; 706  : //	y = 500; //btn->GetY()-h+5;
; 707  : //	x = btn->GetX()-w+20;
; 708  : //	y = btn->GetY()-h+5;
; 709  : 	
; 710  : 	gPopupMgr->OpenMenu(ACMI_OPTION_POPUP,x,y,control);

	mov	edx, DWORD PTR _control$[ebp]
	push	edx
	movsx	eax, WORD PTR _y$[ebp]
	push	eax
	movsx	ecx, WORD PTR _x$[ebp]
	push	ecx
	push	200151					; 00030dd7H
	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?OpenMenu@C_PopupMgr@@QAEHJJJPAVC_Base@@@Z ; C_PopupMgr::OpenMenu

; 711  : 							
; 712  : 	if(menu)

	cmp	DWORD PTR _menu$[ebp], 0
	je	$LN5@ACMItoggle

; 713  : 	{
; 714  : 		menu->SetCallback(LABEL_NAME,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200161					; 00030de1H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 715  : 		menu->SetCallback(LABEL_ALTITUDE,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200163					; 00030de3H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 716  : 		menu->SetCallback(LABEL_HEADING,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200164					; 00030de4H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 717  : 		menu->SetCallback(LABEL_AIRSPEED,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200162					; 00030de2H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 718  : 		menu->SetCallback(LABEL_TURN_RATE,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200166					; 00030de6H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 719  : 		menu->SetCallback(LABEL_TURN_RADIUS,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200167					; 00030de7H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 720  : 		menu->SetCallback(LABEL_LOCK_RANGE,ToggleFirstSelectionOfOptionsCB);

	push	OFFSET ?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ; ToggleFirstSelectionOfOptionsCB
	push	200202					; 00030e0aH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 721  : 
; 722  : 		menu->SetCallback(OPT_ALT_POLE,TogglePoleCB);

	push	OFFSET ?TogglePoleCB@@YAXJFPAVC_Base@@@Z ; TogglePoleCB
	push	200153					; 00030dd9H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 723  : 		menu->SetCallback(OPT_LOCK_LINE,ToggleLockLineCB);

	push	OFFSET ?ToggleLockLineCB@@YAXJFPAVC_Base@@@Z ; ToggleLockLineCB
	push	200168					; 00030de8H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 724  : 		menu->SetCallback(OPT_WIRE_TERRAIN,ToggleWireFrameCB);

	push	OFFSET ?ToggleWireFrameCB@@YAXJFPAVC_Base@@@Z ; ToggleWireFrameCB
	push	200154					; 00030ddaH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 725  : 		menu->SetCallback(WING_TRAILS_NONE,ToggleWingTrailsCB);

	push	OFFSET ?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z ; ToggleWingTrailsCB
	push	200156					; 00030ddcH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 726  : 		menu->SetCallback(WING_TRAILS_SHORT,ToggleWingTrailsCB);

	push	OFFSET ?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z ; ToggleWingTrailsCB
	push	200157					; 00030dddH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 727  : 		menu->SetCallback(WING_TRAILS_MEDIUM,ToggleWingTrailsCB);

	push	OFFSET ?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z ; ToggleWingTrailsCB
	push	200158					; 00030ddeH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 728  : 		menu->SetCallback(WING_TRAILS_LONG,ToggleWingTrailsCB);

	push	OFFSET ?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z ; ToggleWingTrailsCB
	push	200159					; 00030ddfH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 729  : 		menu->SetCallback(WING_TRAILS_MAX,ToggleWingTrailsCB);

	push	OFFSET ?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z ; ToggleWingTrailsCB
	push	200160					; 00030de0H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 730  : 
; 731  : 		menu->SetCallback(VEH_SIZE_1,ToggleObjScaleCB);

	push	OFFSET ?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z ; ToggleObjScaleCB
	push	200170					; 00030deaH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 732  : 		menu->SetCallback(VEH_SIZE_2,ToggleObjScaleCB);

	push	OFFSET ?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z ; ToggleObjScaleCB
	push	200171					; 00030debH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 733  : 		menu->SetCallback(VEH_SIZE_3,ToggleObjScaleCB);

	push	OFFSET ?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z ; ToggleObjScaleCB
	push	200172					; 00030decH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 734  : 		menu->SetCallback(VEH_SIZE_4,ToggleObjScaleCB);

	push	OFFSET ?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z ; ToggleObjScaleCB
	push	200173					; 00030dedH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 735  : 		menu->SetCallback(VEH_SIZE_5,ToggleObjScaleCB);

	push	OFFSET ?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z ; ToggleObjScaleCB
	push	200174					; 00030deeH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 736  : 							
; 737  : 		InitACMIMenus();	

	call	?InitACMIMenus@@YAXXZ			; InitACMIMenus
$LN5@ACMItoggle:

; 738  : 	}						
; 739  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMItoggleLABELSCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMItoggleLABELSCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
tv70 = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z PROC		; ToggleObjScaleCB

; 640  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 641  : 
; 642  : 	if(!acmiView || !acmiView->Tape() || hittype != C_TYPE_LMOUSEUP)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN8@ToggleObjS
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	test	eax, eax
	je	SHORT $LN8@ToggleObjS
	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN9@ToggleObjS
$LN8@ToggleObjS:

; 643  : 		return;

	jmp	$LN10@ToggleObjS
$LN9@ToggleObjS:

; 644  : 
; 645  : 	switch(ID)

	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	mov	edx, DWORD PTR tv70[ebp]
	sub	edx, 200171				; 00030debH
	mov	DWORD PTR tv70[ebp], edx
	cmp	DWORD PTR tv70[ebp], 3
	ja	$LN1@ToggleObjS
	mov	eax, DWORD PTR tv70[ebp]
	jmp	DWORD PTR $LN12@ToggleObjS[eax*4]
$LN5@ToggleObjS:

; 646  : 	{
; 647  : 		case VEH_SIZE_2:
; 648  : 			gObjScale = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR ?gObjScale@@3MA, xmm0

; 649  : 			acmiView->Tape()->SetObjScale(2.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 650  : 			break;

	jmp	$LN6@ToggleObjS
$LN4@ToggleObjS:

; 651  : 		case VEH_SIZE_3:
; 652  : 			gObjScale = 4.0f;

	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR ?gObjScale@@3MA, xmm0

; 653  : 			acmiView->Tape()->SetObjScale(4.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 654  : 			break;

	jmp	$LN6@ToggleObjS
$LN3@ToggleObjS:

; 655  : 		case VEH_SIZE_4:
; 656  : 			gObjScale = 8.0f;

	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR ?gObjScale@@3MA, xmm0

; 657  : 			acmiView->Tape()->SetObjScale(8.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 658  : 			break;

	jmp	SHORT $LN6@ToggleObjS
$LN2@ToggleObjS:

; 659  : 		case VEH_SIZE_5:
; 660  : 			gObjScale = 16.0f;

	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR ?gObjScale@@3MA, xmm0

; 661  : 			acmiView->Tape()->SetObjScale(16.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 662  : 			break;

	jmp	SHORT $LN6@ToggleObjS
$LN1@ToggleObjS:

; 663  : 		default:
; 664  : 		case VEH_SIZE_1:
; 665  : 			gObjScale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR ?gObjScale@@3MA, xmm0

; 666  : 			acmiView->Tape()->SetObjScale(1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale
$LN6@ToggleObjS:
$LN10@ToggleObjS:

; 667  : 			break;
; 668  : 	}
; 669  : 
; 670  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@ToggleObjS:
	DD	$LN5@ToggleObjS
	DD	$LN4@ToggleObjS
	DD	$LN3@ToggleObjS
	DD	$LN2@ToggleObjS
?ToggleObjScaleCB@@YAXJFPAVC_Base@@@Z ENDP		; ToggleObjScaleCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_win$ = -12						; size = 4
tv67 = -8						; size = 4
_temp$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z PROC ; ToggleFirstSelectionOfOptionsCB

; 532  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 533  : 
; 534  : //	C_Button *btn;
; 535  : 	C_Window *win;
; 536  : 
; 537  : 	win=control->Parent_;

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _win$[ebp], ecx

; 538  : //	int buttonstate=0;
; 539  : 	int temp=0;

	mov	DWORD PTR _temp$[ebp], 0

; 540  : 
; 541  : 
; 542  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 52					; 00000034H
	je	SHORT $LN17@ToggleFirs

; 543  : 		return;

	jmp	$LN18@ToggleFirs
$LN17@ToggleFirs:

; 544  : 
; 545  : 	switch(ID)

	mov	eax, DWORD PTR _ID$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	sub	ecx, 200161				; 00030de1H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 41			; 00000029H
	ja	$LN18@ToggleFirs
	mov	edx, DWORD PTR tv67[ebp]
	movzx	eax, BYTE PTR $LN20@ToggleFirs[edx]
	jmp	DWORD PTR $LN21@ToggleFirs[eax*4]
$LN14@ToggleFirs:

; 546  : 	{
; 547  : 		case LABEL_NAME:
; 548  : 		{
; 549  : 			// TOGGLE NAME LABELS HERE	
; 550  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 551  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN13@ToggleFirs

; 552  : 			{
; 553  : 				acmiView->ToggleLabel(temp);	

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleLabel@ACMIView@@QAEXH@Z		; ACMIView::ToggleLabel
$LN13@ToggleFirs:

; 554  : 			}
; 555  : 	
; 556  : 			break;

	jmp	$LN18@ToggleFirs
$LN12@ToggleFirs:

; 557  : 		}
; 558  : 		case LABEL_AIRSPEED:
; 559  : 		{
; 560  : 			// TOGGLE AIRSPEED HERE
; 561  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 562  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN11@ToggleFirs

; 563  : 			{
; 564  : 				acmiView->ToggleAirSpeed(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleAirSpeed@ACMIView@@QAEXH@Z	; ACMIView::ToggleAirSpeed
$LN11@ToggleFirs:

; 565  : 			}
; 566  : 	
; 567  : 			break;

	jmp	$LN18@ToggleFirs
$LN10@ToggleFirs:

; 568  : 		}
; 569  : 		case LABEL_ALTITUDE:
; 570  : 		{
; 571  : 			// TOGGLE ALTITUDE HERE
; 572  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 573  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN9@ToggleFirs

; 574  : 			{
; 575  : 				acmiView->ToggleAltitude(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleAltitude@ACMIView@@QAEXH@Z	; ACMIView::ToggleAltitude
$LN9@ToggleFirs:

; 576  : 			}
; 577  : 
; 578  : 			break;

	jmp	$LN18@ToggleFirs
$LN8@ToggleFirs:

; 579  : 		}
; 580  : 		
; 581  : 		case LABEL_HEADING:
; 582  : 		{
; 583  : 			// TOGGLE HEADING HERE
; 584  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 585  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN7@ToggleFirs

; 586  : 			{
; 587  : 				acmiView->ToggleHeading(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleHeading@ACMIView@@QAEXH@Z	; ACMIView::ToggleHeading
$LN7@ToggleFirs:

; 588  : 			}
; 589  : 					
; 590  : 			break;

	jmp	$LN18@ToggleFirs
$LN6@ToggleFirs:

; 591  : 		}
; 592  : 		case LABEL_TURN_RATE:
; 593  : 		{
; 594  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 595  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN5@ToggleFirs

; 596  : 			{
; 597  : 				acmiView->ToggleTurnRate(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleTurnRate@ACMIView@@QAEXH@Z	; ACMIView::ToggleTurnRate
$LN5@ToggleFirs:

; 598  : 			}
; 599  : 
; 600  : 			
; 601  : 			break;

	jmp	SHORT $LN18@ToggleFirs
$LN4@ToggleFirs:

; 602  : 		}
; 603  : 		
; 604  : 		
; 605  : 		case LABEL_TURN_RADIUS:
; 606  : 		{
; 607  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 608  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN3@ToggleFirs

; 609  : 			{
; 610  : 				acmiView->ToggleTurnRadius(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleTurnRadius@ACMIView@@QAEXH@Z	; ACMIView::ToggleTurnRadius
$LN3@ToggleFirs:

; 611  : 			}
; 612  : 			
; 613  : 			
; 614  : 			break;

	jmp	SHORT $LN18@ToggleFirs
$LN2@ToggleFirs:

; 615  : 		}
; 616  : 		case LABEL_LOCK_RANGE:
; 617  : 		{
; 618  : 			// TOGGLE HEADING HERE
; 619  : 			temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 620  : 			if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN18@ToggleFirs

; 621  : 			{
; 622  : 				acmiView->Togglelockrange(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Togglelockrange@ACMIView@@QAEXH@Z	; ACMIView::Togglelockrange
$LN18@ToggleFirs:

; 623  : 			}
; 624  : 					
; 625  : 			break;
; 626  : 		}
; 627  : 	}
; 628  : 
; 629  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@ToggleFirs:
	DD	$LN14@ToggleFirs
	DD	$LN12@ToggleFirs
	DD	$LN10@ToggleFirs
	DD	$LN8@ToggleFirs
	DD	$LN6@ToggleFirs
	DD	$LN4@ToggleFirs
	DD	$LN2@ToggleFirs
	DD	$LN18@ToggleFirs
$LN20@ToggleFirs:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	7
	DB	4
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
?ToggleFirstSelectionOfOptionsCB@@YAXJFPAVC_Base@@@Z ENDP ; ToggleFirstSelectionOfOptionsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_ID$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z PROC		; ToggleWingTrailsCB

; 453  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 454  : 
; 455  : 
; 456  : 	switch(ID)

	mov	eax, DWORD PTR _ID$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 200156				; 00030ddcH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 4
	ja	$LN12@ToggleWing
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@ToggleWing[edx*4]
$LN9@ToggleWing:

; 457  : 	{
; 458  : 		case WING_TRAILS_NONE:
; 459  : 		{
; 460  : 			gDoWingTrails = 0;

	mov	DWORD PTR ?gDoWingTrails@@3HA, 0	; gDoWingTrails

; 461  : 			acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	eax, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 462  : 			break;

	jmp	$LN12@ToggleWing
$LN8@ToggleWing:

; 463  : 
; 464  : 		}
; 465  : 		case WING_TRAILS_SHORT:
; 466  : 		{
; 467  : 			if(!gDoWingTrails)

	cmp	DWORD PTR ?gDoWingTrails@@3HA, 0	; gDoWingTrails
	jne	SHORT $LN7@ToggleWing

; 468  : 			{
; 469  : 				gDoWingTrails = TRUE;

	mov	DWORD PTR ?gDoWingTrails@@3HA, 1	; gDoWingTrails

; 470  : 				acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	ecx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails
$LN7@ToggleWing:

; 471  : 			}
; 472  : 			gTrailLen = ACMI_TRAILS_SHORT;  // MLR 12/22/2003 - now in seconds

	mov	DWORD PTR ?gTrailLen@@3HA, 15		; gTrailLen, 0000000fH

; 473  : 			acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	edx, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 474  : 			MonoPrint("WingTrails Short \n");

	push	OFFSET ??_C@_0BD@ELLGBKDE@WingTrails?5Short?5?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 475  : 			break;

	jmp	$LN12@ToggleWing
$LN6@ToggleWing:

; 476  : 		}
; 477  : 		case WING_TRAILS_MEDIUM:
; 478  : 		{
; 479  : 			if(!gDoWingTrails)

	cmp	DWORD PTR ?gDoWingTrails@@3HA, 0	; gDoWingTrails
	jne	SHORT $LN5@ToggleWing

; 480  : 			{
; 481  : 				gDoWingTrails = TRUE;

	mov	DWORD PTR ?gDoWingTrails@@3HA, 1	; gDoWingTrails

; 482  : 				acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	eax, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails
$LN5@ToggleWing:

; 483  : 			}
; 484  : 			gTrailLen = ACMI_TRAILS_MEDIUM;  // MLR 12/22/2003 - now in seconds

	mov	DWORD PTR ?gTrailLen@@3HA, 30		; gTrailLen, 0000001eH

; 485  : 			acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	ecx, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 486  : 			MonoPrint("WingTrails Medium \n");

	push	OFFSET ??_C@_0BE@COMFOKND@WingTrails?5Medium?5?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 487  : 			break;

	jmp	$LN12@ToggleWing
$LN4@ToggleWing:

; 488  : 		}
; 489  : 		case WING_TRAILS_LONG:
; 490  : 		{
; 491  : 			if(!gDoWingTrails)

	cmp	DWORD PTR ?gDoWingTrails@@3HA, 0	; gDoWingTrails
	jne	SHORT $LN3@ToggleWing

; 492  : 			{
; 493  : 				gDoWingTrails = TRUE;

	mov	DWORD PTR ?gDoWingTrails@@3HA, 1	; gDoWingTrails

; 494  : 				acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	edx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails
$LN3@ToggleWing:

; 495  : 			}
; 496  : 			gTrailLen = ACMI_TRAILS_LONG;  // MLR 12/22/2003 - now in seconds

	mov	DWORD PTR ?gTrailLen@@3HA, 60		; gTrailLen, 0000003cH

; 497  : 			acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	eax, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 498  : 			MonoPrint("WingTrails Long \n");

	push	OFFSET ??_C@_0BC@IAPBICPN@WingTrails?5Long?5?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 499  : 			break;

	jmp	SHORT $LN12@ToggleWing
$LN2@ToggleWing:

; 500  : 		}
; 501  : 		case WING_TRAILS_MAX:
; 502  : 		{
; 503  : 			if(!gDoWingTrails)

	cmp	DWORD PTR ?gDoWingTrails@@3HA, 0	; gDoWingTrails
	jne	SHORT $LN1@ToggleWing

; 504  : 			{
; 505  : 				gDoWingTrails = TRUE;

	mov	DWORD PTR ?gDoWingTrails@@3HA, 1	; gDoWingTrails

; 506  : 				acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	ecx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails
$LN1@ToggleWing:

; 507  : 			}
; 508  : 			//gTrailLen = 2000; // MN I want to have them even a bit longer !!! ;-) (1000 before...)
; 509  : 			gTrailLen = ACMI_TRAILS_MAX;  // MLR 12/22/2003 - now in seconds			

	mov	DWORD PTR ?gTrailLen@@3HA, 120		; gTrailLen, 00000078H

; 510  : 			acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	edx, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 511  : 			MonoPrint("WingTrails Max \n");

	push	OFFSET ??_C@_0BB@GPJAONGB@WingTrails?5Max?5?6?$AA@
	call	_MonoPrint
	add	esp, 4
$LN12@ToggleWing:

; 512  : 			break;
; 513  : 		}
; 514  : 	
; 515  : 	
; 516  : 	}	
; 517  : 
; 518  : 
; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@ToggleWing:
	DD	$LN9@ToggleWing
	DD	$LN8@ToggleWing
	DD	$LN6@ToggleWing
	DD	$LN4@ToggleWing
	DD	$LN2@ToggleWing
?ToggleWingTrailsCB@@YAXJFPAVC_Base@@@Z ENDP		; ToggleWingTrailsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_pct$1 = -12						; size = 4
_currpos$2 = -8						; size = 4
_win$ = -4						; size = 4
_ID$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?ToggleWireFrameCB@@YAXJFPAVC_Base@@@Z PROC		; ToggleWireFrameCB

; 388  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 389  : 	C_Window *win;
; 390  : 	F4CSECTIONHANDLE *Leave;
; 391  : 
; 392  : 	// TOGGLE NAME LABELS HERE	
; 393  : 	gDoWireFrame =((C_PopupList *)control)->GetItemState(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	ecx, ax
	mov	DWORD PTR ?gDoWireFrame@@3HA, ecx	; gDoWireFrame

; 394  : 	if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	$LN3@ToggleWire

; 395  : 	{
; 396  : 		win=gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 397  : 		if(win == NULL)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN2@ToggleWire

; 398  : 			return;

	jmp	$LN4@ToggleWire
$LN2@ToggleWire:

; 399  : 
; 400  : 		// order here is significant
; 401  : 		// we must unload the tape, shut down graphics, restart
; 402  : 		// graphics and reload tape to do the toggle...
; 403  : 
; 404  : 		// edg: this is bad.  However we must not do this during an
; 405  : 		// acmiView->Exec() cycle.  Question for Peter: how do we handle
; 406  : 		// the timer callback to do a mutex properly?
; 407  : 		Leave=UI_Enter(win);

	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 408  : 		acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 409  : 		//Sleep( 200 );
; 410  : 
; 411  : 		// get the tape head position
; 412  : 		int currpos = gFrameMarker->GetSliderPos();

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?GetSliderPos@C_Slider@@QAEJXZ		; C_Slider::GetSliderPos
	mov	DWORD PTR _currpos$2[ebp], eax

; 413  : 		float pct = (float)(currpos-gFrameMarkerMin)/(float)gFrameMarkerLen;

	mov	eax, DWORD PTR _currpos$2[ebp]
	sub	eax, DWORD PTR ?gFrameMarkerMin@@3HA	; gFrameMarkerMin
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR ?gFrameMarkerLen@@3HA	; gFrameMarkerLen
	divss	xmm0, xmm1
	movss	DWORD PTR _pct$1[ebp], xmm0

; 414  : 
; 415  : 		// stop the tape
; 416  : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 417  : //		ACMITransportButton( STOP_BUTTON );
; 418  : 
; 419  : 		acmiView->UnloadTape( TRUE );

	push	1
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape

; 420  : 		acmiView->ExitGraphics();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ExitGraphics@ACMIView@@QAEHXZ		; ACMIView::ExitGraphics

; 421  : 		acmiView->ToggleWireFrame(gDoWireFrame);

	mov	ecx, DWORD PTR ?gDoWireFrame@@3HA	; gDoWireFrame
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleWireFrame@ACMIView@@QAEXH@Z	; ACMIView::ToggleWireFrame

; 422  : 		acmiView->InitGraphics( win );

	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?InitGraphics@ACMIView@@QAEXPAVC_Window@@@Z ; ACMIView::InitGraphics

; 423  : 
; 424  : 		if(!acmiView->LoadTape("", TRUE))

	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?LoadTape@ACMIView@@QAEHPADH@Z		; ACMIView::LoadTape

; 425  : 		{
; 426  : 			// something's fucked
; 427  : 		}
; 428  : 
; 429  : 		// restore setting for wing trails on tape
; 430  : 		// restore tape head positiion
; 431  : 		acmiView->Tape()->SetHeadPosition( pct );

	push	ecx
	movss	xmm0, DWORD PTR _pct$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetHeadPosition@ACMITape@@QAEXM@Z	; ACMITape::SetHeadPosition

; 432  : 		acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	eax, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 433  : 		acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	ecx, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 434  : 		acmiView->Tape()->SetObjScale(gObjScale);

	push	ecx
	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 435  : 
; 436  : 		// restore drawing
; 437  : 		acmiDraw = TRUE;

	mov	DWORD PTR ?acmiDraw@@3HA, 1		; acmiDraw

; 438  : 		UI_Leave(Leave);

	mov	edx, DWORD PTR _Leave$[ebp]
	push	edx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN3@ToggleWire:

; 439  : 
; 440  : 	}
; 441  : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState
$LN4@ToggleWire:

; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleWireFrameCB@@YAXJFPAVC_Base@@@Z ENDP		; ToggleWireFrameCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ToggleLockLineCB@@YAXJFPAVC_Base@@@Z PROC		; ToggleLockLineCB

; 367  : {

	push	ebp
	mov	ebp, esp

; 368  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN2@ToggleLock

; 369  : 		return;

	jmp	SHORT $LN3@ToggleLock
$LN2@ToggleLock:

; 370  : 
; 371  : 	gDoLockLines =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR ?gDoLockLines@@3HA, edx	; gDoLockLines

; 372  : 	if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN3@ToggleLock

; 373  : 	{
; 374  : 		acmiView->ToggleLockLines(gDoLockLines);

	mov	eax, DWORD PTR ?gDoLockLines@@3HA	; gDoLockLines
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleLockLines@ACMIView@@QAEXH@Z	; ACMIView::ToggleLockLines
$LN3@ToggleLock:

; 375  : 	}
; 376  : 		
; 377  : }

	pop	ebp
	ret	0
?ToggleLockLineCB@@YAXJFPAVC_Base@@@Z ENDP		; ToggleLockLineCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_temp$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?TogglePoleCB@@YAXJFPAVC_Base@@@Z PROC			; TogglePoleCB

; 345  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 346  : 	int temp;
; 347  : 
; 348  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN2@TogglePole

; 349  : 		return;

	jmp	SHORT $LN3@TogglePole
$LN2@TogglePole:

; 350  : 
; 351  : 	temp =((C_PopupList *)control)->GetItemState(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetItemState@C_PopupList@@QAEFJ@Z	; C_PopupList::GetItemState
	movsx	edx, ax
	mov	DWORD PTR _temp$[ebp], edx

; 352  : 	if(acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN3@TogglePole

; 353  : 	{
; 354  : 		acmiView->TogglePoles(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?TogglePoles@ACMIView@@QAEXH@Z		; ACMIView::TogglePoles
$LN3@TogglePole:

; 355  : 	}
; 356  : 
; 357  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TogglePoleCB@@YAXJFPAVC_Base@@@Z ENDP			; TogglePoleCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_found$ = -8						; size = 4
_cur$ = -4						; size = 4
_win$ = 8						; size = 4
_slot$ = 12						; size = 4
_time$ = 16						; size = 4
?FindUITextEvent@@YAPAVC_Base@@PAVC_Window@@JJ@Z PROC	; FindUITextEvent

; 314  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 315  : 	CONTROLLIST *cur;
; 316  : 	C_Base *found=NULL;

	mov	DWORD PTR _found$[ebp], 0

; 317  : 
; 318  : 	if(!win || !time)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN5@FindUIText
	cmp	DWORD PTR _time$[ebp], 0
	jne	SHORT $LN6@FindUIText
$LN5@FindUIText:

; 319  : 		return(NULL);

	xor	eax, eax
	jmp	SHORT $LN7@FindUIText
$LN6@FindUIText:

; 320  : 
; 321  : 	cur=win->GetControlList();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
	mov	DWORD PTR _cur$[ebp], eax
$LN4@FindUIText:

; 322  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@FindUIText

; 323  : 	{
; 324  : 		if(cur->Control_)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FindUIText

; 325  : 		{
; 326  : 			if(cur->Control_->GetUserNumber(slot) >= time)

	mov	ecx, DWORD PTR _slot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	cmp	eax, DWORD PTR _time$[ebp]
	jl	SHORT $LN2@FindUIText

; 327  : 			{
; 328  : 				return cur->Control_;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN7@FindUIText
$LN2@FindUIText:

; 329  : 				//found=cur->Control_;
; 330  : 			}
; 331  : 		}
; 332  : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 333  : 	}

	jmp	SHORT $LN4@FindUIText
$LN3@FindUIText:

; 334  : 	return(found);

	mov	eax, DWORD PTR _found$[ebp]
$LN7@FindUIText:

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindUITextEvent@@YAPAVC_Base@@PAVC_Window@@JJ@Z ENDP	; FindUITextEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_btn$ = -8						; size = 4
_win$ = -4						; size = 4
?CloseACMI@@YAXXZ PROC					; CloseACMI

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 282  : 	C_Window *win;
; 283  : 	C_Button *btn;
; 284  : 
; 285  : 	if(acmiView)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN4@CloseACMI

; 286  : 	{
; 287  : 		// RED - Loader must be released after Objects release
; 288  : 		//TheLoader.Cleanup();
; 289  : 		TheVbManager.Release();

	mov	ecx, OFFSET ?TheVbManager@@3VCDXVbManager@@A ; TheVbManager
	call	?Release@CDXVbManager@@QAEXXZ		; CDXVbManager::Release

; 290  : 
; 291  : 		win=gMainHandler->FindWindow(ACMI_RIGHT_WIN);

	push	200100					; 00030da4H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 292  : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN4@CloseACMI

; 293  : 		{
; 294  : 			btn=(C_Button*)win->FindControl(ACMI_CLOSE);

	push	200122					; 00030dbaH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 295  : 			if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN4@CloseACMI

; 296  : 				ACMICloseCB(CLOSE_WINDOW,C_TYPE_LMOUSEUP,btn);

	mov	eax, DWORD PTR _btn$[ebp]
	push	eax
	push	52					; 00000034H
	push	80001					; 00013881H
	call	?ACMICloseCB@@YAXJFPAVC_Base@@@Z	; ACMICloseCB
	add	esp, 12					; 0000000cH
$LN4@CloseACMI:

; 297  : 		}
; 298  : 	}
; 299  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseACMI@@YAXXZ ENDP					; CloseACMI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_menu$ = -4						; size = 4
?InitACMIMenus@@YAXXZ PROC				; InitACMIMenus

; 222  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 223  : 	C_PopupList *menu;
; 224  : 
; 225  : 	menu=gPopupMgr->GetMenu(ACMI_OPTION_POPUP);

	push	200151					; 00030dd7H
	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?GetMenu@C_PopupMgr@@QAEPAVC_PopupList@@J@Z ; C_PopupMgr::GetMenu
	mov	DWORD PTR _menu$[ebp], eax

; 226  : 	if(menu)

	cmp	DWORD PTR _menu$[ebp], 0
	je	$LN1@InitACMIMe

; 227  : 	{
; 228  : 		menu->SetItemState(OPT_ALT_POLE,	(short)DrawablePoled::drawPole);

	movzx	eax, WORD PTR ?drawPole@DrawablePoled@@2HA
	push	eax
	push	200153					; 00030dd9H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 229  : 		menu->SetItemState(OPT_LOCK_LINE,	(short)gDoLockLines);

	movzx	ecx, WORD PTR ?gDoLockLines@@3HA
	push	ecx
	push	200168					; 00030de8H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 230  : 		menu->SetItemState(OPT_WIRE_TERRAIN,(short)gDoWireFrame);

	movzx	edx, WORD PTR ?gDoWireFrame@@3HA
	push	edx
	push	200154					; 00030ddaH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 231  : 
; 232  : 		menu->SetItemState(WING_TRAILS_NONE,0);

	push	0
	push	200156					; 00030ddcH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 233  : 		menu->SetItemState(WING_TRAILS_SHORT,0);

	push	0
	push	200157					; 00030dddH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 234  : 		menu->SetItemState(WING_TRAILS_MEDIUM,0);

	push	0
	push	200158					; 00030ddeH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 235  : 		menu->SetItemState(WING_TRAILS_LONG,0);

	push	0
	push	200159					; 00030ddfH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 236  : 		menu->SetItemState(WING_TRAILS_MAX,0);

	push	0
	push	200160					; 00030de0H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 237  : 		if(!gDoWingTrails)

	cmp	DWORD PTR ?gDoWingTrails@@3HA, 0	; gDoWingTrails
	jne	SHORT $LN11@InitACMIMe

; 238  : 			menu->SetItemState(WING_TRAILS_NONE,1);

	push	1
	push	200156					; 00030ddcH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 239  : 		else

	jmp	SHORT $LN6@InitACMIMe
$LN11@InitACMIMe:

; 240  : 		{
; 241  : 			if(gTrailLen == ACMI_TRAILS_SHORT)

	cmp	DWORD PTR ?gTrailLen@@3HA, 15		; gTrailLen, 0000000fH
	jne	SHORT $LN9@InitACMIMe

; 242  : 				menu->SetItemState(WING_TRAILS_SHORT,1);

	push	1
	push	200157					; 00030dddH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN9@InitACMIMe:

; 243  : 			if(gTrailLen == ACMI_TRAILS_MEDIUM)

	cmp	DWORD PTR ?gTrailLen@@3HA, 30		; gTrailLen, 0000001eH
	jne	SHORT $LN8@InitACMIMe

; 244  : 				menu->SetItemState(WING_TRAILS_MEDIUM,1);

	push	1
	push	200158					; 00030ddeH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN8@InitACMIMe:

; 245  : 			if(gTrailLen == ACMI_TRAILS_LONG)

	cmp	DWORD PTR ?gTrailLen@@3HA, 60		; gTrailLen, 0000003cH
	jne	SHORT $LN7@InitACMIMe

; 246  : 				menu->SetItemState(WING_TRAILS_LONG,1);

	push	1
	push	200159					; 00030ddfH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN7@InitACMIMe:

; 247  : 			if(gTrailLen == ACMI_TRAILS_MAX)

	cmp	DWORD PTR ?gTrailLen@@3HA, 120		; gTrailLen, 00000078H
	jne	SHORT $LN6@InitACMIMe

; 248  : 				menu->SetItemState(WING_TRAILS_MAX,1);

	push	1
	push	200160					; 00030de0H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN6@InitACMIMe:

; 249  : 		}
; 250  : 
; 251  : 		menu->SetItemState(LABEL_NAME,			(short)DrawableBSP::drawLabels);

	movzx	eax, WORD PTR ?drawLabels@DrawableBSP@@2HA
	push	eax
	push	200161					; 00030de1H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 252  : 		menu->SetItemState(LABEL_AIRSPEED,		(short)DrawablePoled::drawSpeed);

	movzx	ecx, WORD PTR ?drawSpeed@DrawablePoled@@2HA
	push	ecx
	push	200162					; 00030de2H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 253  : 		menu->SetItemState(LABEL_ALTITUDE,		(short)DrawablePoled::drawAlt);

	movzx	edx, WORD PTR ?drawAlt@DrawablePoled@@2HA
	push	edx
	push	200163					; 00030de3H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 254  : 		menu->SetItemState(LABEL_HEADING,		(short)DrawablePoled::drawHeading);

	movzx	eax, WORD PTR ?drawHeading@DrawablePoled@@2HA
	push	eax
	push	200164					; 00030de4H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 255  : 		menu->SetItemState(LABEL_LOCK_RANGE,	(short)DrawablePoled::drawlockrange);

	movzx	ecx, WORD PTR ?drawlockrange@DrawablePoled@@2HA
	push	ecx
	push	200202					; 00030e0aH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 256  : //		menu->SetItemState(LABEL_PITCH,0);
; 257  : //		menu->SetItemState(LABEL_G,0);
; 258  : 		menu->SetItemState(LABEL_TURN_RATE,		(short)DrawablePoled::drawTurnRate);

	movzx	edx, WORD PTR ?drawTurnRate@DrawablePoled@@2HA
	push	edx
	push	200166					; 00030de6H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 259  : 		menu->SetItemState(LABEL_TURN_RADIUS,	(short)DrawablePoled::drawTurnRadius);

	movzx	eax, WORD PTR ?drawTurnRadius@DrawablePoled@@2HA
	push	eax
	push	200167					; 00030de7H
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 260  : 
; 261  : 		menu->SetItemState(VEH_SIZE_1,0);

	push	0
	push	200170					; 00030deaH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 262  : 		menu->SetItemState(VEH_SIZE_2,0);

	push	0
	push	200171					; 00030debH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 263  : 		menu->SetItemState(VEH_SIZE_3,0);

	push	0
	push	200172					; 00030decH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 264  : 		menu->SetItemState(VEH_SIZE_4,0);

	push	0
	push	200173					; 00030dedH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 265  : 		menu->SetItemState(VEH_SIZE_5,0);

	push	0
	push	200174					; 00030deeH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState

; 266  : 
; 267  : 		if(gObjScale == 1.0f)

	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@InitACMIMe

; 268  : 			menu->SetItemState(VEH_SIZE_1,1);

	push	1
	push	200170					; 00030deaH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN5@InitACMIMe:

; 269  : 		if(gObjScale == 2.0f)

	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@InitACMIMe

; 270  : 			menu->SetItemState(VEH_SIZE_2,1);

	push	1
	push	200171					; 00030debH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN4@InitACMIMe:

; 271  : 		if(gObjScale == 4.0f)

	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@InitACMIMe

; 272  : 			menu->SetItemState(VEH_SIZE_3,1);

	push	1
	push	200172					; 00030decH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN3@InitACMIMe:

; 273  : 		if(gObjScale == 8.0f)

	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	ucomiss	xmm0, DWORD PTR __real@41000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@InitACMIMe

; 274  : 			menu->SetItemState(VEH_SIZE_4,1);

	push	1
	push	200173					; 00030dedH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN2@InitACMIMe:

; 275  : 		if(gObjScale == 16.0f)

	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	ucomiss	xmm0, DWORD PTR __real@41800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@InitACMIMe

; 276  : 			menu->SetItemState(VEH_SIZE_5,1);

	push	1
	push	200174					; 00030deeH
	mov	ecx, DWORD PTR _menu$[ebp]
	call	?SetItemState@C_PopupList@@QAEXJF@Z	; C_PopupList::SetItemState
$LN1@InitACMIMe:

; 277  : 	}
; 278  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitACMIMenus@@YAXXZ ENDP				; InitACMIMenus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
tv70 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?CleanupACMIIDTable@@YAXXZ PROC				; CleanupACMIIDTable

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 213  : 	if(ACMIIDTable)

	cmp	DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A, 0 ; ACMIIDTable
	je	SHORT $LN2@CleanupACM

; 214  : 	{
; 215  : 		ACMIIDTable->Cleanup();

	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Cleanup@ACMI_Hash@@QAEXXZ		; ACMI_Hash::Cleanup

; 216  : 		delete ACMIIDTable;

	mov	eax, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@CleanupACM
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GACMI_Hash@@QAEPAXI@Z
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN5@CleanupACM
$LN4@CleanupACM:
	mov	DWORD PTR tv70[ebp], 0
$LN5@CleanupACM:

; 217  : 		ACMIIDTable=NULL;

	mov	DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A, 0 ; ACMIIDTable
$LN2@CleanupACM:

; 218  : 	}
; 219  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupACMIIDTable@@YAXXZ ENDP				; CleanupACMIIDTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 4
tv70 = -32						; size = 4
$T3 = -28						; size = 4
tv78 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?InitACMIIDTable@@YAXXZ PROC				; InitACMIIDTable

; 200  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitACMIIDTable@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 201  : 	if(ACMIIDTable)

	cmp	DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A, 0 ; ACMIIDTable
	je	SHORT $LN1@InitACMIID

; 202  : 	{
; 203  : 		ACMIIDTable->Cleanup();

	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Cleanup@ACMI_Hash@@QAEXXZ		; ACMI_Hash::Cleanup

; 204  : 		delete ACMIIDTable;

	mov	eax, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN4@InitACMIID
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GACMI_Hash@@QAEPAXI@Z
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN5@InitACMIID
$LN4@InitACMIID:
	mov	DWORD PTR tv70[ebp], 0
$LN5@InitACMIID:

; 205  : 		ACMIIDTable=NULL;

	mov	DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A, 0 ; ACMIIDTable
$LN1@InitACMIID:

; 206  : 	}
; 207  : 	ACMIIDTable=new ACMI_Hash;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@InitACMIID
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0ACMI_Hash@@QAE@XZ			; ACMI_Hash::ACMI_Hash
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN7@InitACMIID
$LN6@InitACMIID:
	mov	DWORD PTR tv78[ebp], 0
$LN7@InitACMIID:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A, eax ; ACMIIDTable

; 208  : 	ACMIIDTable->Setup(100);

	push	100					; 00000064H
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Setup@ACMI_Hash@@QAEXK@Z		; ACMI_Hash::Setup

; 209  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InitACMIIDTable@@YAXXZ$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InitACMIIDTable@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitACMIIDTable@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitACMIIDTable@@YAXXZ ENDP				; InitACMIIDTable
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_camFilter$ = -32					; size = 4
_objectName$ = -28					; size = 4
_camSel$ = -24						; size = 4
_numEntities$ = -20					; size = 4
_winme$ = -16						; size = 4
_listBoxIds$ = -12					; size = 4
_ACMIListBox$ = -8					; size = 4
_objectNum$ = -4					; size = 4
?ACMIUpdateModelMenu@@YAXXZ PROC			; ACMIUpdateModelMenu

; 2655 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2656 : 	C_Window
; 2657 : 		*winme;
; 2658 : 
; 2659 : 	C_ListBox
; 2660 : 		*ACMIListBox,
; 2661 : 		*camFilter;
; 2662 : 
; 2663 : 	char
; 2664 : 		*objectName;
; 2665 : 
; 2666 : 	int
; 2667 : 		objectNum,
; 2668 : 		numEntities,
; 2669 : 		listBoxIds;
; 2670 : 
; 2671 : 	long
; 2672 : 		camSel = EXTERNAL_CAM;

	mov	DWORD PTR _camSel$[ebp], 200124		; 00030dbcH

; 2673 : 
; 2674 : 	winme = gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 2675 : 
; 2676 : 	if (winme != NULL)

	cmp	DWORD PTR _winme$[ebp], 0
	je	$LN15@ACMIUpdate

; 2677 : 	{
; 2678 : 		camFilter = (C_ListBox *)winme->FindControl(ACMI_CAMERA); 

	push	200024					; 00030d58H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _camFilter$[ebp], eax

; 2679 : 		if (camFilter != NULL)

	cmp	DWORD PTR _camFilter$[ebp], 0
	je	SHORT $LN13@ACMIUpdate

; 2680 : 		{
; 2681 : 			camSel = camFilter->GetTextID();

	mov	ecx, DWORD PTR _camFilter$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _camSel$[ebp], eax
$LN13@ACMIUpdate:

; 2682 : 		}
; 2683 : 
; 2684 : 		ACMIListBox = (C_ListBox *)winme->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2685 : 		if (ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	$LN12@ACMIUpdate

; 2686 : 		{
; 2687 : 			ACMIListBox->RemoveAllItems();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 2688 : 
; 2689 : 			if (ACMIViewIsReady())

	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN12@ACMIUpdate

; 2690 : 			{
; 2691 : 				numEntities = acmiView->Tape()->NumEntities();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?NumEntities@ACMITape@@QAEHXZ		; ACMITape::NumEntities
	mov	DWORD PTR _numEntities$[ebp], eax

; 2692 : 				for (objectNum = 0; objectNum < numEntities; objectNum ++) 

	mov	DWORD PTR _objectNum$[ebp], 0
	jmp	SHORT $LN10@ACMIUpdate
$LN9@ACMIUpdate:
	mov	eax, DWORD PTR _objectNum$[ebp]
	add	eax, 1
	mov	DWORD PTR _objectNum$[ebp], eax
$LN10@ACMIUpdate:
	mov	ecx, DWORD PTR _objectNum$[ebp]
	cmp	ecx, DWORD PTR _numEntities$[ebp]
	jge	SHORT $LN12@ACMIUpdate

; 2693 : 				{
; 2694 : 					listBoxIds = acmiView->ListBoxID(objectNum, camSel);

	mov	edx, DWORD PTR _camSel$[ebp]
	push	edx
	mov	eax, DWORD PTR _objectNum$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	mov	DWORD PTR _listBoxIds$[ebp], eax

; 2695 : 					if (listBoxIds > -1)

	cmp	DWORD PTR _listBoxIds$[ebp], -1
	jle	SHORT $LN7@ACMIUpdate

; 2696 : 					{
; 2697 : 						objectName = acmiView->SetListBoxID(objectNum, listBoxIds);

	mov	ecx, DWORD PTR _listBoxIds$[ebp]
	push	ecx
	mov	edx, DWORD PTR _objectNum$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
	mov	DWORD PTR _objectName$[ebp], eax

; 2698 : 						ACMIListBox = ACMIListBox->AddItem(listBoxIds, C_TYPE_ITEM , objectName);

	mov	eax, DWORD PTR _objectName$[ebp]
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _listBoxIds$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
	mov	DWORD PTR _ACMIListBox$[ebp], eax
$LN7@ACMIUpdate:

; 2699 : 					}
; 2700 : 				}

	jmp	SHORT $LN9@ACMIUpdate
$LN12@ACMIUpdate:

; 2701 : 			}
; 2702 : 		}
; 2703 : 
; 2704 : 		ACMIListBox = (C_ListBox *)winme->FindControl(TRACKED_OBJECT_FIELD);

	push	200011					; 00030d4bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2705 : 		if (ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	$LN15@ACMIUpdate

; 2706 : 		{
; 2707 : 			ACMIListBox->RemoveAllItems();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 2708 : 
; 2709 : 			if (ACMIViewIsReady())

	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN15@ACMIUpdate

; 2710 : 			{
; 2711 : 				numEntities = acmiView->Tape()->NumEntities();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?NumEntities@ACMITape@@QAEHXZ		; ACMITape::NumEntities
	mov	DWORD PTR _numEntities$[ebp], eax

; 2712 : 				for (objectNum = 0; objectNum < numEntities; objectNum ++) 

	mov	DWORD PTR _objectNum$[ebp], 0
	jmp	SHORT $LN4@ACMIUpdate
$LN3@ACMIUpdate:
	mov	edx, DWORD PTR _objectNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _objectNum$[ebp], edx
$LN4@ACMIUpdate:
	mov	eax, DWORD PTR _objectNum$[ebp]
	cmp	eax, DWORD PTR _numEntities$[ebp]
	jge	SHORT $LN15@ACMIUpdate

; 2713 : 				{
; 2714 : 					listBoxIds = acmiView->ListBoxID(objectNum, camSel);

	mov	ecx, DWORD PTR _camSel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _objectNum$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	mov	DWORD PTR _listBoxIds$[ebp], eax

; 2715 : 					if (listBoxIds > -1)

	cmp	DWORD PTR _listBoxIds$[ebp], -1
	jle	SHORT $LN1@ACMIUpdate

; 2716 : 					{
; 2717 : 						objectName = acmiView->SetListBoxID(objectNum, listBoxIds);

	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _objectNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
	mov	DWORD PTR _objectName$[ebp], eax

; 2718 : 						ACMIListBox = ACMIListBox->AddItem(listBoxIds, C_TYPE_ITEM , objectName);

	mov	edx, DWORD PTR _objectName$[ebp]
	push	edx
	push	50					; 00000032H
	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
	mov	DWORD PTR _ACMIListBox$[ebp], eax
$LN1@ACMIUpdate:

; 2719 : 					}
; 2720 : 				}

	jmp	SHORT $LN3@ACMIUpdate
$LN15@ACMIUpdate:

; 2721 : 			}
; 2722 : 		}
; 2723 : 	}
; 2724 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIUpdateModelMenu@@YAXXZ ENDP			; ACMIUpdateModelMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMICutPOVCB@@YAXJFPAVC_Base@@@Z PROC			; ACMICutPOVCB

; 2780 : {

	push	ebp
	mov	ebp, esp

; 2781 : }

	pop	ebp
	ret	0
?ACMICutPOVCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMICutPOVCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIScreenCaptureCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIScreenCaptureCB

; 2761 : {

	push	ebp
	mov	ebp, esp

; 2762 : 	if
; 2763 : 	(
; 2764 : 		hittype == C_TYPE_LMOUSEUP &&
; 2765 : 		ACMIViewIsReady()
; 2766 : 	)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	SHORT $LN2@ACMIScreen
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIScreen

; 2767 : 	{
; 2768 : 		acmiView->ToggleScreenShot();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleScreenShot@ACMIView@@QAEXXZ	; ACMIView::ToggleScreenShot
$LN2@ACMIScreen:

; 2769 : 	}
; 2770 : }

	pop	ebp
	ret	0
?ACMIScreenCaptureCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIScreenCaptureCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIUpdate@@YAXJFPAVC_Base@@@Z PROC			; ACMIUpdate

; 2734 : {

	push	ebp
	mov	ebp, esp

; 2735 : 	if(acmiDraw)

	cmp	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw
	je	SHORT $LN3@ACMIUpdate

; 2736 : 	{
; 2737 : 		control->SetReady(1);

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 2738 : 		
; 2739 : 		if(ACMIViewIsReady())

	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN3@ACMIUpdate

; 2740 : 		{
; 2741 : 			acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw
$LN3@ACMIUpdate:

; 2742 : 		}
; 2743 : 	}
; 2744 : }

	pop	ebp
	ret	0
?ACMIUpdate@@YAXJFPAVC_Base@@@Z ENDP			; ACMIUpdate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_Leave$ = -60						; size = 4
_events$1 = -56						; size = 4
_count$2 = -52						; size = 4
_camSel$ = -48						; size = 4
_numEntities$ = -44					; size = 4
_camFilter$ = -40					; size = 4
_renwin$ = -36						; size = 4
_objectName$ = -32					; size = 4
_tbtn$ = -28						; size = 4
_fname$ = -24						; size = 4
_text$ = -20						; size = 4
_listBoxIds$ = -16					; size = 4
_ACMIListBox$ = -12					; size = 4
_objectNum$ = -8					; size = 4
_winme$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIPickAFileCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIPickAFileCB

; 2481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2482 : 	C_Button
; 2483 : 		*tbtn;
; 2484 : 
; 2485 : 	// edg: big hack to note: this function doesn't actually
; 2486 : 	// seem to set fname to anything that's been loaded in
; 2487 : 	// the UI list.  So, for now, the only legal file will
; 2488 : 	// be default.  This file will be created automatically
; 2489 : 	// from acmi.flt
; 2490 : 	_TCHAR
; 2491 : 		*fname = "lastflt.vhs";

	mov	DWORD PTR _fname$[ebp], OFFSET ??_C@_0M@DAELODFB@lastflt?4vhs?$AA@

; 2492 : 
; 2493 : 	C_Window
; 2494 : 		*winme;
; 2495 : 
; 2496 : 	C_ListBox
; 2497 : 		*ACMIListBox,
; 2498 : 		*camFilter;
; 2499 : 
; 2500 : 
; 2501 : 	C_Text		*text;
; 2502 : 
; 2503 : 
; 2504 : 	char
; 2505 : 		*objectName;
; 2506 : 
; 2507 : 	int
; 2508 : 		objectNum,
; 2509 : 		numEntities,
; 2510 : 		listBoxIds = listBoxBaseID;

	mov	DWORD PTR _listBoxIds$[ebp], 1

; 2511 : 
; 2512 : 	long
; 2513 : 		camSel;
; 2514 : 
; 2515 : 	F4CSECTIONHANDLE *Leave;
; 2516 : 	C_Window *renwin;
; 2517 : 
; 2518 : 
; 2519 : 	if(hittype != C_TYPE_LMOUSEUP || acmiView == NULL)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	SHORT $LN16@ACMIPickAF
	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	jne	SHORT $LN17@ACMIPickAF
$LN16@ACMIPickAF:

; 2520 : 		return;

	jmp	$LN18@ACMIPickAF
$LN17@ACMIPickAF:

; 2521 : 
; 2522 : 	renwin=gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _renwin$[ebp], eax

; 2523 : 	if(renwin == NULL)

	cmp	DWORD PTR _renwin$[ebp], 0
	jne	SHORT $LN15@ACMIPickAF

; 2524 : 			return;

	jmp	$LN18@ACMIPickAF
$LN15@ACMIPickAF:

; 2525 : 
; 2526 : 	// critical section for drawing
; 2527 : 	Leave=UI_Enter(renwin);

	mov	ecx, DWORD PTR _renwin$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2528 : 	acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 2529 : 
; 2530 : 
; 2531 : 
; 2532 : 	tbtn = (C_Button *)control;

	mov	edx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _tbtn$[ebp], edx

; 2533 : 	tbtn->SetState(1);

	push	1
	mov	eax, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2534 : 	fname = tbtn->GetText(0);

	push	0
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?GetText@C_Button@@QAEPADF@Z		; C_Button::GetText
	mov	DWORD PTR _fname$[ebp], eax

; 2535 : 	gMainHandler->HideWindow(control->GetParent());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetParent@C_Base@@QAEPAVC_Window@@XZ	; C_Base::GetParent
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::HideWindow

; 2536 : 
; 2537 : 
; 2538 : 	gMainHandler->EnableWindowGroup(200149);

	push	200149					; 00030dd5H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup

; 2539 : 									
; 2540 : 	winme = gMainHandler->FindWindow(ACMI_LOAD_SCREEN);

	push	200149					; 00030dd5H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 2541 : 
; 2542 : 
; 2543 : 	// make sure no tape is now loaded
; 2544 : 	acmiView->UnloadTape(FALSE);

	push	0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape

; 2545 : 
; 2546 : 	// Load the tape.
; 2547 : 	if(!acmiView->LoadTape(fname,FALSE))

	push	0
	mov	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?LoadTape@ACMIView@@QAEHPADH@Z		; ACMIView::LoadTape
	test	eax, eax
	jne	SHORT $LN14@ACMIPickAF

; 2548 : 	{
; 2549 : 		acmiView->UnloadTape(FALSE);

	push	0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape

; 2550 : 		//F4LeaveCriticalSection( gUICriticalSection );
; 2551 : 		return;

	jmp	$LN18@ACMIPickAF
$LN14@ACMIPickAF:

; 2552 : 	}
; 2553 : 	acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	edx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 2554 : 	acmiView->Tape()->SetWingTrailLength( gTrailLen );

	mov	eax, DWORD PTR ?gTrailLen@@3HA		; gTrailLen
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrailLength@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrailLength

; 2555 : 	acmiView->Tape()->SetObjScale(gObjScale);

	push	ecx
	movss	xmm0, DWORD PTR ?gObjScale@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetObjScale@ACMITape@@QAEXM@Z		; ACMITape::SetObjScale

; 2556 : 
; 2557 : 	
; 2558 : 	//save the filename for future reference.
; 2559 : 	sprintf(loadedfname,fname);

	mov	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	push	OFFSET ?loadedfname@@3PADA		; loadedfname
	call	_sprintf
	add	esp, 8

; 2560 : 
; 2561 : 	acmiView->InitUIVector();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?InitUIVector@ACMIView@@QAEXXZ		; ACMIView::InitUIVector

; 2562 : 
; 2563 : 	winme = gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 2564 : 	
; 2565 : 	if (winme != NULL)

	cmp	DWORD PTR _winme$[ebp], 0
	je	$LN13@ACMIPickAF

; 2566 : 	{
; 2567 : 		camFilter = (C_ListBox *)winme->FindControl(ACMI_CAMERA); 

	push	200024					; 00030d58H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _camFilter$[ebp], eax

; 2568 : 		if (camFilter != NULL)

	cmp	DWORD PTR _camFilter$[ebp], 0
	je	SHORT $LN12@ACMIPickAF

; 2569 : 		{
; 2570 : 			camSel = camFilter->GetTextID();

	mov	ecx, DWORD PTR _camFilter$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _camSel$[ebp], eax

; 2571 : 			acmiView->SelectCamera(camSel);

	mov	edx, DWORD PTR _camSel$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SelectCamera@ACMIView@@QAEXJ@Z		; ACMIView::SelectCamera
$LN12@ACMIPickAF:

; 2572 : 		}
; 2573 : 
; 2574 : 		numEntities = acmiView->Tape()->NumEntities();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?NumEntities@ACMITape@@QAEHXZ		; ACMITape::NumEntities
	mov	DWORD PTR _numEntities$[ebp], eax

; 2575 : 
; 2576 : 		ACMIListBox = (C_ListBox *)winme->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2577 : 		if (ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN8@ACMIPickAF

; 2578 : 		{
; 2579 : 			ACMIListBox->RemoveAllItems();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 2580 : 		
; 2581 : 			for (objectNum = 0; objectNum < numEntities; objectNum ++) 

	mov	DWORD PTR _objectNum$[ebp], 0
	jmp	SHORT $LN10@ACMIPickAF
$LN9@ACMIPickAF:
	mov	eax, DWORD PTR _objectNum$[ebp]
	add	eax, 1
	mov	DWORD PTR _objectNum$[ebp], eax
$LN10@ACMIPickAF:
	mov	ecx, DWORD PTR _objectNum$[ebp]
	cmp	ecx, DWORD PTR _numEntities$[ebp]
	jge	SHORT $LN8@ACMIPickAF

; 2582 : 			{
; 2583 : 				listBoxIds = acmiView->ListBoxID(objectNum, EXTERNAL_CAM);

	push	200124					; 00030dbcH
	mov	edx, DWORD PTR _objectNum$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	mov	DWORD PTR _listBoxIds$[ebp], eax

; 2584 : 				if (listBoxIds > -1)

	cmp	DWORD PTR _listBoxIds$[ebp], -1
	jle	SHORT $LN7@ACMIPickAF

; 2585 : 				{
; 2586 : 					objectName = acmiView->SetListBoxID(objectNum, listBoxIds);

	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _objectNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
	mov	DWORD PTR _objectName$[ebp], eax

; 2587 : 					ACMIListBox = ACMIListBox->AddItem(listBoxIds, C_TYPE_ITEM , objectName);

	mov	edx, DWORD PTR _objectName$[ebp]
	push	edx
	push	50					; 00000032H
	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
	mov	DWORD PTR _ACMIListBox$[ebp], eax
$LN7@ACMIPickAF:

; 2588 : 				}
; 2589 : 			}

	jmp	SHORT $LN9@ACMIPickAF
$LN8@ACMIPickAF:

; 2590 : 		}
; 2591 : 
; 2592 : 		listBoxIds = listBoxBaseID;

	mov	DWORD PTR _listBoxIds$[ebp], 1

; 2593 : 
; 2594 : 		ACMIListBox = (C_ListBox *)winme->FindControl(TRACKED_OBJECT_FIELD);

	push	200011					; 00030d4bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2595 : 		if (ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN3@ACMIPickAF

; 2596 : 		{
; 2597 : 			ACMIListBox->RemoveAllItems();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 2598 : 
; 2599 : 			for (objectNum = 0; objectNum < numEntities; objectNum ++) 

	mov	DWORD PTR _objectNum$[ebp], 0
	jmp	SHORT $LN5@ACMIPickAF
$LN4@ACMIPickAF:
	mov	ecx, DWORD PTR _objectNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _objectNum$[ebp], ecx
$LN5@ACMIPickAF:
	mov	edx, DWORD PTR _objectNum$[ebp]
	cmp	edx, DWORD PTR _numEntities$[ebp]
	jge	SHORT $LN3@ACMIPickAF

; 2600 : 			{
; 2601 : 				objectName = acmiView->SetListBoxID(objectNum, listBoxIds);

	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _objectNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetListBoxID@ACMIView@@QAEPADHJ@Z	; ACMIView::SetListBoxID
	mov	DWORD PTR _objectName$[ebp], eax

; 2602 : 
; 2603 : 				ACMIListBox = ACMIListBox->AddItem(listBoxIds, C_TYPE_ITEM , objectName);

	mov	edx, DWORD PTR _objectName$[ebp]
	push	edx
	push	50					; 00000032H
	mov	eax, DWORD PTR _listBoxIds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2604 : 				listBoxIds++;

	mov	ecx, DWORD PTR _listBoxIds$[ebp]
	add	ecx, 1
	mov	DWORD PTR _listBoxIds$[ebp], ecx

; 2605 : 			}

	jmp	SHORT $LN4@ACMIPickAF
$LN3@ACMIPickAF:

; 2606 : 		}
; 2607 : 		// edg
; 2608 : 		// this call puts the event strings into the
; 2609 : 		// event list window -- seems to be broken now...
; 2610 : 		void *events;
; 2611 : 		int count;
; 2612 : 		events = acmiView->Tape()->GetTextEvents( &count );

	lea	edx, DWORD PTR _count$2[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetTextEvents@ACMITape@@QAEPAXPAH@Z	; ACMITape::GetTextEvents
	mov	DWORD PTR _events$1[ebp], eax

; 2613 : 		ProcessEventArray(winme, events, count);

	mov	eax, DWORD PTR _count$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _events$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _winme$[ebp]
	push	edx
	call	?ProcessEventArray@@YAXPAVC_Window@@PAXH@Z ; ProcessEventArray
	add	esp, 12					; 0000000cH
$LN13@ACMIPickAF:

; 2614 : 	}
; 2615 : 
; 2616 : 
; 2617 : 	gMainHandler->EnableWindowGroup(200000);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup

; 2618 : 	winme = gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 2619 : 	winme->HideCluster(100);

	push	100					; 00000064H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 2620 : 	winme->UnHideCluster(200);

	push	200					; 000000c8H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster

; 2621 : 
; 2622 : 	
; 2623 : 
; 2624 : 	// put the name of the vhs file into the window top.
; 2625 : 	winme = gMainHandler->FindWindow(ACMI_RIGHT_WIN);

	push	200100					; 00030da4H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 2626 :    if (winme != NULL)

	cmp	DWORD PTR _winme$[ebp], 0
	je	SHORT $LN1@ACMIPickAF

; 2627 :    {
; 2628 : 
; 2629 : 	   text=(C_Text *)winme->FindControl(ACMI_TAPE_NAME);

	push	200148					; 00030dd4H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _text$[ebp], eax

; 2630 : 	   if(text != NULL)

	cmp	DWORD PTR _text$[ebp], 0
	je	SHORT $LN1@ACMIPickAF

; 2631 : 	   {
; 2632 : 	     text->SetText(fname);

	mov	eax, DWORD PTR _fname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 2633 : 		 text->Refresh();

	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@ACMIPickAF:

; 2634 : 	   }
; 2635 : 
; 2636 :    }
; 2637 : 	
; 2638 :    
; 2639 : 
; 2640 : 	acmiDraw = TRUE;

	mov	DWORD PTR ?acmiDraw@@3HA, 1		; acmiDraw

; 2641 : 	renderACMI = TRUE;

	mov	DWORD PTR ?renderACMI@@3HA, 1		; renderACMI

; 2642 : 	UI_Leave( Leave );

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN18@ACMIPickAF:

; 2643 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIPickAFileCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIPickAFileCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_winme$ = -8						; size = 4
_lbox$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMISubCameraNextCB@@YAXJFPAVC_Base@@@Z PROC		; ACMISubCameraNextCB

; 2454 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2455 : 	C_ListBox *lbox;
; 2456 : 	C_Window *winme = control->Parent_;

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _winme$[ebp], ecx

; 2457 : 
; 2458 : 	lbox = (C_ListBox *)winme->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 2459 : 
; 2460 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 52					; 00000034H
	jne	SHORT $LN3@ACMISubCam
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN3@ACMISubCam

; 2461 : 	{
; 2462 : 		acmiView->IncrementCameraObject(1);

	push	1
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?IncrementCameraObject@ACMIView@@QAEXH@Z ; ACMIView::IncrementCameraObject

; 2463 : 
; 2464 : 		if ( lbox )

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN3@ACMISubCam

; 2465 : 		{
; 2466 : 			lbox->Refresh();

	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 2467 : 			lbox->SetValue( acmiView->ListBoxID (acmiView->CameraObject(), INTERNAL_CAM ) );

	push	200123					; 00030dbbH
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?CameraObject@ACMIView@@QAEHXZ		; ACMIView::CameraObject
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 2468 : 			lbox->Refresh();

	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@ACMISubCam:

; 2469 : 		}
; 2470 : 	}
; 2471 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMISubCameraNextCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMISubCameraNextCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_winme$ = -8						; size = 4
_lbox$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMISubCameraPrevCB@@YAXJFPAVC_Base@@@Z PROC		; ACMISubCameraPrevCB

; 2427 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2428 : 	C_ListBox *lbox;
; 2429 : 	C_Window *winme = control->Parent_;

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _winme$[ebp], ecx

; 2430 : 
; 2431 : 	lbox = (C_ListBox *)winme->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 2432 : 
; 2433 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 52					; 00000034H
	jne	SHORT $LN3@ACMISubCam
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN3@ACMISubCam

; 2434 : 	{
; 2435 : 		acmiView->IncrementCameraObject(-1);

	push	-1
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?IncrementCameraObject@ACMIView@@QAEXH@Z ; ACMIView::IncrementCameraObject

; 2436 : 
; 2437 : 		if ( lbox )

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN3@ACMISubCam

; 2438 : 		{
; 2439 : 			lbox->Refresh();

	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 2440 : 			lbox->SetValue( acmiView->ListBoxID (acmiView->CameraObject(), INTERNAL_CAM ) );

	push	200123					; 00030dbbH
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?CameraObject@ACMIView@@QAEHXZ		; ACMIView::CameraObject
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 2441 : 			lbox->Refresh();

	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@ACMISubCam:

; 2442 : 		}
; 2443 : 	}
; 2444 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMISubCameraPrevCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMISubCameraPrevCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_itemSel$ = -8						; size = 4
_ACMIListBox$ = -4					; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMISubCameraCB@@YAXJFPAVC_Base@@@Z PROC		; ACMISubCameraCB

; 2396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2397 : 	C_ListBox
; 2398 : 		*ACMIListBox;
; 2399 : 
; 2400 : 	long
; 2401 : 		itemSel;
; 2402 : 
; 2403 : 	ACMIListBox = (C_ListBox *)control;

	mov	eax, DWORD PTR _control$[ebp]
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2404 : 
; 2405 : 	if
; 2406 : 	(
; 2407 : 		hittype == C_TYPE_SELECT &&
; 2408 : 		ACMIViewIsReady() &&
; 2409 : 		ACMIListBox != NULL
; 2410 : 	)

	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 28					; 0000001cH
	jne	SHORT $LN2@ACMISubCam
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMISubCam
	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN2@ACMISubCam

; 2411 : 	{
; 2412 : 		itemSel = ACMIListBox->GetTextID();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _itemSel$[ebp], eax

; 2413 : 
; 2414 : 		acmiView->SwitchCameraObject(itemSel);

	mov	edx, DWORD PTR _itemSel$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SwitchCameraObject@ACMIView@@QAEXJ@Z	; ACMIView::SwitchCameraObject
$LN2@ACMISubCam:

; 2415 : 		// ACMIUpdateModelMenu();
; 2416 : 	}
; 2417 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMISubCameraCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMISubCameraCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_winme$ = -8						; size = 4
_lbox$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMICamTrackingNextCB@@YAXJFPAVC_Base@@@Z PROC		; ACMICamTrackingNextCB

; 2369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2370 : 	C_ListBox *lbox;
; 2371 : 	C_Window *winme = control->Parent_;

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _winme$[ebp], ecx

; 2372 : 
; 2373 : 	lbox = (C_ListBox *)winme->FindControl(TRACKED_OBJECT_FIELD);

	push	200011					; 00030d4bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 2374 : 
; 2375 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 52					; 00000034H
	jne	SHORT $LN3@ACMICamTra
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN3@ACMICamTra

; 2376 : 	{
; 2377 : 		acmiView->IncrementTrackingObject(1);

	push	1
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?IncrementTrackingObject@ACMIView@@QAEXH@Z ; ACMIView::IncrementTrackingObject

; 2378 : 
; 2379 : 		if ( lbox )

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN3@ACMICamTra

; 2380 : 		{
; 2381 : 			lbox->Refresh();

	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 2382 : 			lbox->SetValue( acmiView->ListBoxID (acmiView->TrackingObject(), INTERNAL_CAM ) );

	push	200123					; 00030dbbH
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?TrackingObject@ACMIView@@QAEHXZ	; ACMIView::TrackingObject
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 2383 : 			lbox->Refresh();

	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@ACMICamTra:

; 2384 : 		}
; 2385 : 	}
; 2386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMICamTrackingNextCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMICamTrackingNextCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_winme$ = -8						; size = 4
_lbox$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMICamTrackingPrevCB@@YAXJFPAVC_Base@@@Z PROC		; ACMICamTrackingPrevCB

; 2342 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2343 : 	// C_Window *winme = gMainHandler->FindWindow(ACMI_LEFT_WIN);
; 2344 : 	C_ListBox *lbox;
; 2345 : 	C_Window *winme = control->Parent_;

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _winme$[ebp], ecx

; 2346 : 
; 2347 : 	lbox = (C_ListBox *)winme->FindControl(TRACKED_OBJECT_FIELD);

	push	200011					; 00030d4bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 2348 : 
; 2349 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 52					; 00000034H
	jne	SHORT $LN3@ACMICamTra
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN3@ACMICamTra

; 2350 : 	{
; 2351 : 		acmiView->IncrementTrackingObject(-1);

	push	-1
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?IncrementTrackingObject@ACMIView@@QAEXH@Z ; ACMIView::IncrementTrackingObject

; 2352 : 		if ( lbox )

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN3@ACMICamTra

; 2353 : 		{
; 2354 : 			lbox->Refresh();

	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 2355 : 			lbox->SetValue( acmiView->ListBoxID (acmiView->TrackingObject(), INTERNAL_CAM ) );

	push	200123					; 00030dbbH
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?TrackingObject@ACMIView@@QAEHXZ	; ACMIView::TrackingObject
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ListBoxID@ACMIView@@QAEJHJ@Z		; ACMIView::ListBoxID
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 2356 : 			lbox->Refresh();

	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@ACMICamTra:

; 2357 : 		}
; 2358 : 	}
; 2359 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMICamTrackingPrevCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMICamTrackingPrevCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_itemSel$ = -8						; size = 4
_ACMIListBox$ = -4					; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMICamTrackingCB@@YAXJFPAVC_Base@@@Z PROC		; ACMICamTrackingCB

; 2312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2313 : 	C_ListBox
; 2314 : 		*ACMIListBox;
; 2315 : 
; 2316 : 	long
; 2317 : 		itemSel;
; 2318 : 
; 2319 : 	ACMIListBox = (C_ListBox *)control;

	mov	eax, DWORD PTR _control$[ebp]
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 2320 : 
; 2321 : 	if
; 2322 : 	(
; 2323 : 		hittype == C_TYPE_SELECT &&
; 2324 : 		ACMIViewIsReady() &&
; 2325 : 		ACMIListBox != NULL
; 2326 : 	)

	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 28					; 0000001cH
	jne	SHORT $LN2@ACMICamTra
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMICamTra
	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN2@ACMICamTra

; 2327 : 	{
; 2328 : 		itemSel = ACMIListBox->GetTextID();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _itemSel$[ebp], eax

; 2329 : 
; 2330 : 		acmiView->SwitchTrackingObject(itemSel);

	mov	edx, DWORD PTR _itemSel$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SwitchTrackingObject@ACMIView@@QAEXJ@Z	; ACMIView::SwitchTrackingObject
$LN2@ACMICamTra:

; 2331 : 	}
; 2332 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMICamTrackingCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMICamTrackingCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_ACMIListBox$ = -20					; size = 4
_win$ = -16						; size = 4
_item$ = -12						; size = 4
_cluster$ = -8						; size = 4
_i$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMICameraCB@@YAXJFPAVC_Base@@@Z PROC			; ACMICameraCB

; 2230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2231 : 	C_ListBox *ACMIListBox;
; 2232 : 	C_Button *item;
; 2233 : 	C_Window *win;
; 2234 : 	long i,cluster;
; 2235 : 
; 2236 : 	if(hittype == C_TYPE_SELECT && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 28					; 0000001cH
	jne	$LN8@ACMICamera
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	$LN8@ACMICamera

; 2237 : 	{
; 2238 : 		ACMIListBox = (C_ListBox *)control;

	mov	ecx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _ACMIListBox$[ebp], ecx

; 2239 : 		gCameraMode = ACMIListBox->GetTextID();

	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR ?gCameraMode@@3HA, eax	; gCameraMode

; 2240 : 
; 2241 : 		acmiView->SelectCamera(gCameraMode);

	mov	edx, DWORD PTR ?gCameraMode@@3HA	; gCameraMode
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SelectCamera@ACMIView@@QAEXJ@Z		; ACMIView::SelectCamera

; 2242 : 
; 2243 : 		item=ACMIListBox->GetItem(gCameraMode);

	mov	eax, DWORD PTR ?gCameraMode@@3HA	; gCameraMode
	push	eax
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	call	?GetItem@C_ListBox@@QAEPAVC_Button@@J@Z	; C_ListBox::GetItem
	mov	DWORD PTR _item$[ebp], eax

; 2244 : 		if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN8@ACMICamera

; 2245 : 		{
; 2246 : 			win=gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 2247 : 			if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN8@ACMICamera

; 2248 : 			{
; 2249 : 				i=10; // Joe's starting ID for stuff to hide

	mov	DWORD PTR _i$[ebp], 10			; 0000000aH

; 2250 : 				cluster=item->GetUserNumber(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _item$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _cluster$[ebp], eax
$LN4@ACMICamera:

; 2251 : 				while(cluster && i < 20)

	cmp	DWORD PTR _cluster$[ebp], 0
	je	SHORT $LN3@ACMICamera
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	SHORT $LN3@ACMICamera

; 2252 : 				{
; 2253 : 					win->HideCluster(cluster);

	mov	edx, DWORD PTR _cluster$[ebp]
	push	edx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 2254 : 					i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 2255 : 					cluster=item->GetUserNumber(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _item$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _cluster$[ebp], eax

; 2256 : 				}

	jmp	SHORT $LN4@ACMICamera
$LN3@ACMICamera:

; 2257 : 
; 2258 : 				i=0; // Joe's starting ID for stuff to enable

	mov	DWORD PTR _i$[ebp], 0

; 2259 : 				cluster=item->GetUserNumber(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _item$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _cluster$[ebp], eax
$LN2@ACMICamera:

; 2260 : 				while(cluster && i < 10)

	cmp	DWORD PTR _cluster$[ebp], 0
	je	SHORT $LN8@ACMICamera
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	SHORT $LN8@ACMICamera

; 2261 : 				{
; 2262 : 					win->UnHideCluster(cluster);

	mov	eax, DWORD PTR _cluster$[ebp]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster

; 2263 : 					i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 2264 : 					cluster=item->GetUserNumber(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _item$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _cluster$[ebp], eax

; 2265 : 				}

	jmp	SHORT $LN2@ACMICamera
$LN8@ACMICamera:

; 2266 : 			}
; 2267 : 		}
; 2268 : 		// ACMIUpdateModelMenu();
; 2269 : 	}
; 2270 : 
; 2271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMICameraCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMICameraCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_horz$ = -12						; size = 4
_vert$ = -8						; size = 4
_panner$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIVArrowsCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIVArrowsCB

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2205 : 	C_Panner	
; 2206 : 		*panner;
; 2207 : 
; 2208 : 	float
; 2209 : 		horz = 0.0F,

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _horz$[ebp], xmm0

; 2210 : 		vert = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vert$[ebp], xmm0

; 2211 : 
; 2212 : 
; 2213 : 	if((hittype == C_TYPE_LMOUSEDOWN || hittype == C_TYPE_REPEAT) && ACMIViewIsReady() )

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 51					; 00000033H
	je	SHORT $LN1@ACMIVArrow
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN2@ACMIVArrow
$LN1@ACMIVArrow:
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIVArrow

; 2214 : 	{
; 2215 : 		panner = (C_Panner *) control;

	mov	edx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _panner$[ebp], edx

; 2216 : 		horz = (float)panner->GetHRange();

	mov	ecx, DWORD PTR _panner$[ebp]
	call	?GetHRange@C_Panner@@QAEJXZ		; C_Panner::GetHRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _horz$[ebp], xmm0

; 2217 : 		vert = (float)panner->GetVRange();

	mov	ecx, DWORD PTR _panner$[ebp]
	call	?GetVRange@C_Panner@@QAEJXZ		; C_Panner::GetVRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vert$[ebp], xmm0

; 2218 : 		acmiView->SetPannerXYZ(  0.0F, 0.0f, vert );

	push	ecx
	movss	xmm0, DWORD PTR _vert$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetPannerXYZ@ACMIView@@QAEXMMM@Z	; ACMIView::SetPannerXYZ
$LN2@ACMIVArrow:

; 2219 : 	}
; 2220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIVArrowsCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIVArrowsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_vert$ = -12						; size = 4
_horz$ = -8						; size = 4
_panner$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIHArrowsCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIHArrowsCB

; 2176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2177 : 	C_Panner	
; 2178 : 		*panner;
; 2179 : 
; 2180 : 	float
; 2181 : 		horz = 0.0F,

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _horz$[ebp], xmm0

; 2182 : 		vert = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vert$[ebp], xmm0

; 2183 : 
; 2184 : 
; 2185 : 	if((hittype == C_TYPE_LMOUSEDOWN || hittype == C_TYPE_REPEAT) && ACMIViewIsReady() )

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 51					; 00000033H
	je	SHORT $LN1@ACMIHArrow
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN2@ACMIHArrow
$LN1@ACMIHArrow:
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIHArrow

; 2186 : 	{
; 2187 : 		panner = (C_Panner *) control;

	mov	edx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _panner$[ebp], edx

; 2188 : 		horz = (float)panner->GetHRange();

	mov	ecx, DWORD PTR _panner$[ebp]
	call	?GetHRange@C_Panner@@QAEJXZ		; C_Panner::GetHRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _horz$[ebp], xmm0

; 2189 : 		vert = (float)panner->GetVRange();

	mov	ecx, DWORD PTR _panner$[ebp]
	call	?GetVRange@C_Panner@@QAEJXZ		; C_Panner::GetVRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vert$[ebp], xmm0

; 2190 : 
; 2191 : 		// note vert = -X and horz = Y
; 2192 : 		acmiView->SetPannerXYZ( -vert, horz, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _horz$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _vert$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetPannerXYZ@ACMIView@@QAEXMMM@Z	; ACMIView::SetPannerXYZ
$LN2@ACMIHArrow:

; 2193 : 	}
; 2194 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIHArrowsCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIHArrowsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_horz$ = -12						; size = 4
_vert$ = -8						; size = 4
_panner$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIPannerCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIPannerCB

; 2148 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2149 : 	C_Panner	
; 2150 : 		*panner;
; 2151 : 
; 2152 : 	float
; 2153 : 		horz = 0.0F,

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _horz$[ebp], xmm0

; 2154 : 		vert = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vert$[ebp], xmm0

; 2155 : 
; 2156 : 
; 2157 : 	if((hittype == C_TYPE_LMOUSEDOWN || hittype == C_TYPE_REPEAT) && ACMIViewIsReady() )

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 51					; 00000033H
	je	SHORT $LN1@ACMIPanner
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN2@ACMIPanner
$LN1@ACMIPanner:
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIPanner

; 2158 : 	{
; 2159 : 		panner = (C_Panner *) control;

	mov	edx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _panner$[ebp], edx

; 2160 : 		horz = (float)panner->GetHRange();

	mov	ecx, DWORD PTR _panner$[ebp]
	call	?GetHRange@C_Panner@@QAEJXZ		; C_Panner::GetHRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _horz$[ebp], xmm0

; 2161 : 		vert = (float)panner->GetVRange();							

	mov	ecx, DWORD PTR _panner$[ebp]
	call	?GetVRange@C_Panner@@QAEJXZ		; C_Panner::GetVRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vert$[ebp], xmm0

; 2162 : 
; 2163 : 		//scale them so's we don't rotate too fast....
; 2164 : 		acmiView->SetPannerAzEl( horz * 0.003F, -vert * 0.003F);

	movss	xmm0, DWORD PTR _vert$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3b449ba6
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _horz$[ebp]
	mulss	xmm0, DWORD PTR __real@3b449ba6
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?SetPannerAzEl@ACMIView@@QAEXMM@Z	; ACMIView::SetPannerAzEl
$LN2@ACMIPanner:

; 2165 : 	}
; 2166 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIPannerCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIPannerCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMITrackingCB@@YAXJFPAVC_Base@@@Z PROC		; ACMITrackingCB

; 2129 : {

	push	ebp
	mov	ebp, esp

; 2130 : 	if
; 2131 : 	(
; 2132 : 		hittype == C_TYPE_LMOUSEUP &&
; 2133 : 		ACMIViewIsReady() 
; 2134 : 	)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	SHORT $LN2@ACMITracki
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMITracki

; 2135 : 	{
; 2136 : 		acmiView->ToggleTracking();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleTracking@ACMIView@@QAEXXZ	; ACMIView::ToggleTracking
$LN2@ACMITracki:

; 2137 : 	}
; 2138 : }

	pop	ebp
	ret	0
?ACMITrackingCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMITrackingCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIZoomOutCameraCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIZoomOutCameraCB

; 2118 : {

	push	ebp
	mov	ebp, esp

; 2119 : }

	pop	ebp
	ret	0
?ACMIZoomOutCameraCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIZoomOutCameraCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIZoomInCameraCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIZoomInCameraCB

; 2107 : {

	push	ebp
	mov	ebp, esp

; 2108 : }

	pop	ebp
	ret	0
?ACMIZoomInCameraCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIZoomInCameraCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIRotateCameraRightCB@@YAXJFPAVC_Base@@@Z PROC	; ACMIRotateCameraRightCB

; 2095 : {

	push	ebp
	mov	ebp, esp

; 2096 : }

	pop	ebp
	ret	0
?ACMIRotateCameraRightCB@@YAXJFPAVC_Base@@@Z ENDP	; ACMIRotateCameraRightCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIRotateCameraLeftCB@@YAXJFPAVC_Base@@@Z PROC	; ACMIRotateCameraLeftCB

; 2084 : {

	push	ebp
	mov	ebp, esp

; 2085 : }

	pop	ebp
	ret	0
?ACMIRotateCameraLeftCB@@YAXJFPAVC_Base@@@Z ENDP	; ACMIRotateCameraLeftCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIRotateCameraDownCB@@YAXJFPAVC_Base@@@Z PROC	; ACMIRotateCameraDownCB

; 2073 : {

	push	ebp
	mov	ebp, esp

; 2074 : }

	pop	ebp
	ret	0
?ACMIRotateCameraDownCB@@YAXJFPAVC_Base@@@Z ENDP	; ACMIRotateCameraDownCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIRotateCameraUpCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIRotateCameraUpCB

; 2062 : {

	push	ebp
	mov	ebp, esp

; 2063 : }

	pop	ebp
	ret	0
?ACMIRotateCameraUpCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIRotateCameraUpCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIFastForwardCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIFastForwardCB

; 2040 : {

	push	ebp
	mov	ebp, esp

; 2041 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	$LN1@ACMIFastFo
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	$LN1@ACMIFastFo

; 2042 : 	{
; 2043 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 2044 : 		acmiView->Tape()->SetPlayVelocity(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayVelocity@ACMITape@@QAEXM@Z	; ACMITape::SetPlayVelocity

; 2045 : 		acmiView->Tape()->SetPlayAcceleration(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayAcceleration@ACMITape@@QAEXM@Z	; ACMITape::SetPlayAcceleration

; 2046 : 		acmiView->Tape()->SetMaxPlaySpeed(8.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetMaxPlaySpeed@ACMITape@@QAEXM@Z	; ACMITape::SetMaxPlaySpeed

; 2047 : 		acmiView->Tape()->Play();		

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Play@ACMITape@@QAEXXZ			; ACMITape::Play
$LN1@ACMIFastFo:

; 2048 : //		ACMITransportButton( FF_BUTTON );
; 2049 : 	}
; 2050 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 2051 : 	control->SetState(1);

	push	1
	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2052 : }

	pop	ebp
	ret	0
?ACMIFastForwardCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIFastForwardCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIRewindCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIRewindCB

; 2018 : {

	push	ebp
	mov	ebp, esp

; 2019 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	$LN1@ACMIRewind
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	$LN1@ACMIRewind

; 2020 : 	{
; 2021 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 2022 : 		acmiView->Tape()->SetPlayVelocity(-1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayVelocity@ACMITape@@QAEXM@Z	; ACMITape::SetPlayVelocity

; 2023 : 		acmiView->Tape()->SetPlayAcceleration(-1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayAcceleration@ACMITape@@QAEXM@Z	; ACMITape::SetPlayAcceleration

; 2024 : 		acmiView->Tape()->SetMaxPlaySpeed(8.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetMaxPlaySpeed@ACMITape@@QAEXM@Z	; ACMITape::SetMaxPlaySpeed

; 2025 : 		acmiView->Tape()->Play();		

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Play@ACMITape@@QAEXXZ			; ACMITape::Play
$LN1@ACMIRewind:

; 2026 : //		ACMITransportButton( REV_BUTTON );
; 2027 : 	}
; 2028 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 2029 : 	control->SetState(1);

	push	1
	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2030 : }

	pop	ebp
	ret	0
?ACMIRewindCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIRewindCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_Leave$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIStepReverseCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIStepReverseCB

; 1997 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1998 : 	F4CSECTIONHANDLE *Leave;
; 1999 : 
; 2000 : 	if((hittype == C_TYPE_LMOUSEUP || hittype == C_TYPE_REPEAT) && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN1@ACMIStepRe
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN2@ACMIStepRe
$LN1@ACMIStepRe:
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIStepRe

; 2001 : 	{
; 2002 : 		Leave=UI_Enter(control->Parent_);

	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2003 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 2004 : 		acmiView->Tape()->StepTime(-0.1F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bdcccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?StepTime@ACMITape@@QAEXM@Z		; ACMITape::StepTime

; 2005 : 		UI_Leave( Leave );

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN2@ACMIStepRe:

; 2006 : 	}
; 2007 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	edx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 2008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIStepReverseCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIStepReverseCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_Leave$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIStepFowardCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIStepFowardCB

; 1976 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1977 : 	F4CSECTIONHANDLE *Leave;
; 1978 : 
; 1979 : 	if((hittype == C_TYPE_LMOUSEUP || hittype == C_TYPE_REPEAT) && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN1@ACMIStepFo
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN2@ACMIStepFo
$LN1@ACMIStepFo:
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIStepFo

; 1980 : 	{
; 1981 : 		Leave=UI_Enter(control->Parent_);

	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1982 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 1983 : 		acmiView->Tape()->StepTime(0.1F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?StepTime@ACMITape@@QAEXM@Z		; ACMITape::StepTime

; 1984 : 		UI_Leave( Leave );

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN2@ACMIStepFo:

; 1985 : 	}
; 1986 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	edx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 1987 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIStepFowardCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIStepFowardCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIPlayBackwardsCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIPlayBackwardsCB

; 1954 : {

	push	ebp
	mov	ebp, esp

; 1955 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	$LN1@ACMIPlayBa
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	$LN1@ACMIPlayBa

; 1956 : 	{
; 1957 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 1958 : 		acmiView->Tape()->SetPlayVelocity(-1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayVelocity@ACMITape@@QAEXM@Z	; ACMITape::SetPlayVelocity

; 1959 : 		acmiView->Tape()->SetPlayAcceleration(0.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayAcceleration@ACMITape@@QAEXM@Z	; ACMITape::SetPlayAcceleration

; 1960 : 		acmiView->Tape()->SetMaxPlaySpeed(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetMaxPlaySpeed@ACMITape@@QAEXM@Z	; ACMITape::SetMaxPlaySpeed

; 1961 : 		acmiView->Tape()->Play();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Play@ACMITape@@QAEXXZ			; ACMITape::Play
$LN1@ACMIPlayBa:

; 1962 : //		ACMITransportButton( REV_BUTTON );
; 1963 : 	}
; 1964 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 1965 : 	control->SetState(1);

	push	1
	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 1966 : }

	pop	ebp
	ret	0
?ACMIPlayBackwardsCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIPlayBackwardsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIPlayCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIPlayCB

; 1932 : {

	push	ebp
	mov	ebp, esp

; 1933 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	$LN1@ACMIPlayCB
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	$LN1@ACMIPlayCB

; 1934 : 	{
; 1935 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 1936 : 		acmiView->Tape()->SetPlayVelocity(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayVelocity@ACMITape@@QAEXM@Z	; ACMITape::SetPlayVelocity

; 1937 : 		acmiView->Tape()->SetPlayAcceleration(0.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetPlayAcceleration@ACMITape@@QAEXM@Z	; ACMITape::SetPlayAcceleration

; 1938 : 		acmiView->Tape()->SetMaxPlaySpeed(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetMaxPlaySpeed@ACMITape@@QAEXM@Z	; ACMITape::SetMaxPlaySpeed

; 1939 : 		acmiView->Tape()->Play();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Play@ACMITape@@QAEXXZ			; ACMITape::Play
$LN1@ACMIPlayCB:

; 1940 : //		ACMITransportButton( PLAY_BUTTON );
; 1941 : 	}
; 1942 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 1943 : 	control->SetState(1);

	push	1
	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 1944 : }

	pop	ebp
	ret	0
?ACMIPlayCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIPlayCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIStopCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIStopCB

; 1915 : {

	push	ebp
	mov	ebp, esp

; 1916 : 	if(hittype == C_TYPE_LMOUSEUP && ACMIViewIsReady())

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	SHORT $LN1@ACMIStopCB
	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN1@ACMIStopCB

; 1917 : 	{		
; 1918 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause
$LN1@ACMIStopCB:

; 1919 : //		ACMITransportButton( STOP_BUTTON );
; 1920 : 	}
; 1921 : 	control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState

; 1922 : }

	pop	ebp
	ret	0
?ACMIStopCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIStopCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_hrs$ = -44						; size = 4
_msecs$ = -40						; size = 4
tv226 = -36						; size = 4
tv279 = -32						; size = 4
tv221 = -28						; size = 4
_t$ = -24						; size = 4
_currpos$ = -20						; size = 4
_secs$ = -16						; size = 4
_mins$ = -12						; size = 4
_Leave$ = -8						; size = 4
_pct$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMIFrameMarkerCB@@YAXJFPAVC_Base@@@Z PROC		; ACMIFrameMarkerCB

; 2791 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2792 : 	float pct;
; 2793 : 	int currpos;
; 2794 : 	float t;
; 2795 : 	int secs, msecs, hrs, mins;
; 2796 : 
; 2797 : 
; 2798 : 	/*
; 2799 : 	** edg: leaving this here -- if we want to be able to update the
; 2800 : 	** tape while we're moving the slider, then I think we're going to need
; 2801 : 	** a critical section.
; 2802 : 	*/
; 2803 : 	F4CSECTIONHANDLE *Leave;
; 2804 : 
; 2805 : 
; 2806 : 
; 2807 : 	if ( !ACMIViewIsReady() )

	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	jne	SHORT $LN6@ACMIFrameM

; 2808 : 		return;

	jmp	$LN7@ACMIFrameM
$LN6@ACMIFrameM:

; 2809 : 
; 2810 : 	if(hittype == C_TYPE_MOUSEMOVE)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 61					; 0000003dH
	jne	$LN5@ACMIFrameM

; 2811 : 	{
; 2812 : 		Leave=UI_Enter(control->Parent_);

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2813 : 		// tell main draw function not to do frame marker update
; 2814 : 		gAdjustingFrameMarker = TRUE;

	mov	DWORD PTR ?gAdjustingFrameMarker@@3HA, 1 ; gAdjustingFrameMarker

; 2815 : 
; 2816 : 		// edg: no tape updating while moving slider....
; 2817 : 		// set the tape head position
; 2818 : 		currpos = gFrameMarker->GetSliderPos();

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?GetSliderPos@C_Slider@@QAEJXZ		; C_Slider::GetSliderPos
	mov	DWORD PTR _currpos$[ebp], eax

; 2819 : 		t = (float)(currpos-gFrameMarkerMin)/(float)gFrameMarkerLen;

	mov	eax, DWORD PTR _currpos$[ebp]
	sub	eax, DWORD PTR ?gFrameMarkerMin@@3HA	; gFrameMarkerMin
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR ?gFrameMarkerLen@@3HA	; gFrameMarkerLen
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 2820 : 		// acmiView->Tape()->SetHeadPosition( pct );
; 2821 : 
; 2822 : 		pct = acmiView->Tape()->GetNewSimTime(t) - acmiView->Tape()->GetTodOffset();

	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetNewSimTime@ACMITape@@QAEMM@Z	; ACMITape::GetNewSimTime
	fstp	DWORD PTR tv221[ebp]
	movss	xmm0, DWORD PTR tv221[ebp]
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	movss	DWORD PTR tv279[ebp], xmm0
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetTodOffset@ACMITape@@QAEMXZ		; ACMITape::GetTodOffset
	fstp	DWORD PTR tv226[ebp]
	movss	xmm0, DWORD PTR tv279[ebp]
	subss	xmm0, DWORD PTR tv226[ebp]
	movss	DWORD PTR _pct$[ebp], xmm0

; 2823 : 		secs = (int)(pct);

	cvttss2si ecx, DWORD PTR _pct$[ebp]
	mov	DWORD PTR _secs$[ebp], ecx

; 2824 : 		msecs = (int)(pct*100) - secs*100;

	movss	xmm0, DWORD PTR _pct$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _secs$[ebp]
	imul	eax, 100				; 00000064H
	sub	edx, eax
	mov	DWORD PTR _msecs$[ebp], edx

; 2825 : 
; 2826 : 		// edg: yuck!  I assume Bing did this....
; 2827 : 		// SimTime() (as now time stamped on tape) includes the
; 2828 : 		// time of day in seconds.  Assuming the Sim Starts at Noon gives
; 2829 : 		// 12 hrs * 60 secs/hr = 720 which is why the following subtraction is in.
; 2830 : 		// A bad assumption.  We'll need to record the todOffset in the raw data
; 2831 : 		// file so we can get it into tthe tape header
; 2832 : 		// mins = (int)(pct/60.0f)-720;
; 2833 : 
; 2834 : 		mins = (int)((pct)/60.0f);

	movss	xmm0, DWORD PTR _pct$[ebp]
	divss	xmm0, DWORD PTR __real@42700000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _mins$[ebp], ecx

; 2835 : 		hrs = (int)((mins)/60.0f);

	cvtsi2ss xmm0, DWORD PTR _mins$[ebp]
	divss	xmm0, DWORD PTR __real@42700000
	cvttss2si edx, xmm0
	mov	DWORD PTR _hrs$[ebp], edx

; 2836 : 		mins = (int)(fmod((float)mins,60.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _mins$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _mins$[ebp], eax

; 2837 : 
; 2838 : 		secs = (int)(fmod(pct,60.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pct$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _secs$[ebp], eax

; 2839 : 
; 2840 : 		sprintf( gCountText,
; 2841 : 				 "%02d:%02d:%02d:%02d",
; 2842 : 				 hrs,
; 2843 : 				 mins,
; 2844 : 				 secs,
; 2845 : 				 msecs );

	mov	eax, DWORD PTR _msecs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _secs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _hrs$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@FEAMKGAE@?$CF02d?3?$CF02d?3?$CF02d?3?$CF02d?$AA@
	push	OFFSET ?gCountText@@3PADA		; gCountText
	call	_sprintf
	add	esp, 24					; 00000018H

; 2846 : 
; 2847 : 		gCounter->Refresh( );

	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 2848 : 		gCounter->SetText( gCountText );

	push	OFFSET ?gCountText@@3PADA		; gCountText
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 2849 : 		gCounter->Refresh( );

	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 2850 : 		UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
	jmp	$LN1@ACMIFrameM
$LN5@ACMIFrameM:

; 2851 : 	}
; 2852 : 	else if(hittype == C_TYPE_LMOUSEDOWN)

	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 51					; 00000033H
	jne	SHORT $LN3@ACMIFrameM

; 2853 : 	{		
; 2854 : 		Leave=UI_Enter(control->Parent_);

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2855 : 		acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 2856 : 
; 2857 : 		acmiView->Tape()->Pause();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?Pause@ACMITape@@QAEXXZ			; ACMITape::Pause

; 2858 : 		acmiView->Tape()->SetWingTrails( 0 );

	push	0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 2859 : 
; 2860 : 		// restore drawing
; 2861 : 		acmiDraw = TRUE;

	mov	DWORD PTR ?acmiDraw@@3HA, 1		; acmiDraw

; 2862 : 		UI_Leave(Leave);

	mov	edx, DWORD PTR _Leave$[ebp]
	push	edx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2863 : 
; 2864 : 		control->Parent_->SetGroupState(200001,0);

	push	0
	push	200001					; 00030d41H
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState
	jmp	$LN1@ACMIFrameM
$LN3@ACMIFrameM:

; 2865 : 	}
; 2866 : 	else if(hittype == C_TYPE_LDROP)

	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 73					; 00000049H
	jne	$LN1@ACMIFrameM

; 2867 : 	{		
; 2868 : 		Leave=UI_Enter(control->Parent_);

	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2869 : 
; 2870 : 		currpos = gFrameMarker->GetSliderPos();

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?GetSliderPos@C_Slider@@QAEJXZ		; C_Slider::GetSliderPos
	mov	DWORD PTR _currpos$[ebp], eax

; 2871 : 		pct = (float)(currpos-gFrameMarkerMin)/(float)gFrameMarkerLen;

	mov	ecx, DWORD PTR _currpos$[ebp]
	sub	ecx, DWORD PTR ?gFrameMarkerMin@@3HA	; gFrameMarkerMin
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR ?gFrameMarkerLen@@3HA	; gFrameMarkerLen
	divss	xmm0, xmm1
	movss	DWORD PTR _pct$[ebp], xmm0

; 2872 : 		acmiView->Tape()->SetHeadPosition( pct );

	push	ecx
	movss	xmm0, DWORD PTR _pct$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetHeadPosition@ACMITape@@QAEXM@Z	; ACMITape::SetHeadPosition

; 2873 : 		acmiView->Tape()->SetWingTrails( gDoWingTrails );

	mov	edx, DWORD PTR ?gDoWingTrails@@3HA	; gDoWingTrails
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SetWingTrails@ACMITape@@QAEXH@Z	; ACMITape::SetWingTrails

; 2874 : 
; 2875 : 		// restore drawing
; 2876 : 		acmiDraw = TRUE;

	mov	DWORD PTR ?acmiDraw@@3HA, 1		; acmiDraw

; 2877 : 		UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2878 : 
; 2879 : 		// tell main draw function not to do frame marker update
; 2880 : 		gAdjustingFrameMarker = FALSE;

	mov	DWORD PTR ?gAdjustingFrameMarker@@3HA, 0 ; gAdjustingFrameMarker
$LN1@ACMIFrameM:
$LN7@ACMIFrameM:

; 2881 : 	}
; 2882 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMIFrameMarkerCB@@YAXJFPAVC_Base@@@Z ENDP		; ACMIFrameMarkerCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_win$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMILoadCB@@YAXJFPAVC_Base@@@Z PROC			; ACMILoadCB

; 1828 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1829 : 	C_Window 
; 1830 : 		*win;
; 1831 : 
; 1832 : //	F4EnterCriticalSection( gUICriticalSection );
; 1833 : 	if(hittype == C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	jne	SHORT $LN2@ACMILoadCB

; 1834 : 	{
; 1835 : 		acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 1836 : 		renderACMI = FALSE;

	mov	DWORD PTR ?renderACMI@@3HA, 0		; renderACMI

; 1837 : 
; 1838 : 		win = gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1839 : 		win->HideCluster(200);

	push	200					; 000000c8H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 1840 : 		win->UnHideCluster(100);

	push	100					; 00000064H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster

; 1841 : 
; 1842 : 		FindACMIFLTFiles();

	call	?FindACMIFLTFiles@@YAXXZ		; FindACMIFLTFiles

; 1843 : 
; 1844 : 		gMainHandler->EnableWindowGroup(control->GetGroup());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup
$LN2@ACMILoadCB:

; 1845 : 	}
; 1846 : //	F4LeaveCriticalSection( gUICriticalSection );
; 1847 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMILoadCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMILoadCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
tv94 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_renwin$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ACMICloseCB@@YAXJFPAVC_Base@@@Z PROC			; ACMICloseCB

; 1857 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1858 : 	F4CSECTIONHANDLE *Leave;
; 1859 : 	C_Window *renwin;
; 1860 : 
; 1861 : 
; 1862 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN5@ACMICloseC

; 1863 : 		return;

	jmp	$LN6@ACMICloseC
$LN5@ACMICloseC:

; 1864 : 
; 1865 : 	renwin=gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _renwin$[ebp], eax

; 1866 : 	if(renwin == NULL)

	cmp	DWORD PTR _renwin$[ebp], 0
	jne	SHORT $LN4@ACMICloseC

; 1867 : 			return;

	jmp	$LN6@ACMICloseC
$LN4@ACMICloseC:

; 1868 : 
; 1869 : 	// critical section for drawing
; 1870 : 	Leave=UI_Enter(renwin);

	mov	ecx, DWORD PTR _renwin$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1871 : 	acmiDraw = FALSE;

	mov	DWORD PTR ?acmiDraw@@3HA, 0		; acmiDraw

; 1872 : 	renderACMI = FALSE;

	mov	DWORD PTR ?renderACMI@@3HA, 0		; renderACMI

; 1873 : 
; 1874 : 	gMainHandler->HideWindow(control->Parent_);

	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::HideWindow

; 1875 : 
; 1876 : 	
; 1877 : 	drawTimer->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1878 : 
; 1879 : 	if (acmiView != NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	je	SHORT $LN3@ACMICloseC

; 1880 : 	{
; 1881 : 	
; 1882 : 		if(acmiView->TapeHasLoaded())

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?TapeHasLoaded@ACMIView@@QAEHXZ		; ACMIView::TapeHasLoaded
	test	eax, eax
	je	SHORT $LN2@ACMICloseC

; 1883 : 		{
; 1884 : 			acmiView->UnloadTape(FALSE);

	push	0
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?UnloadTape@ACMIView@@QAEXH@Z		; ACMIView::UnloadTape
$LN2@ACMICloseC:

; 1885 : 		}	
; 1886 : 		
; 1887 : 		CloseACMI();

	call	?CloseACMI@@YAXXZ			; CloseACMI

; 1888 : 		acmiView->ExitGraphics();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ExitGraphics@ACMIView@@QAEHXZ		; ACMIView::ExitGraphics

; 1889 : 		delete acmiView;

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN8@ACMICloseC
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GACMIView@@QAEPAXI@Z
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN9@ACMICloseC
$LN8@ACMICloseC:
	mov	DWORD PTR tv94[ebp], 0
$LN9@ACMICloseC:

; 1890 : 		acmiView = NULL;

	mov	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
$LN3@ACMICloseC:

; 1891 : 
; 1892 : 
; 1893 : 	}
; 1894 : 	if(control->GetGroup())

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	test	eax, eax
	je	SHORT $LN1@ACMICloseC

; 1895 : 	{
; 1896 : 		gMainHandler->DisableWindowGroup(control->GetGroup());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?DisableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::DisableWindowGroup
$LN1@ACMICloseC:

; 1897 : 	}
; 1898 : 
; 1899 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN6@ACMICloseC:

; 1900 : 
; 1901 : 	// RV - RED	- We r leaving ACMI... why still true?
; 1902 : //	acmiDraw = TRUE;
; 1903 : //	renderACMI = TRUE;
; 1904 : 
; 1905 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ACMICloseCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMICloseCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
_win$ = -24						; size = 4
tv80 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIButtonCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIButtonCB

; 1201 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1202 : 	C_Window
; 1203 : 		*win;
; 1204 : 
; 1205 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN4@ACMIButton

; 1206 : 		return;

	jmp	$LN5@ACMIButton
$LN4@ACMIButton:

; 1207 : 
; 1208 : 	CloseAllRenderers(ACMI_RIGHT_WIN);

	push	200100					; 00030da4H
	call	?CloseAllRenderers@@YAXJ@Z		; CloseAllRenderers
	add	esp, 4

; 1209 : 	// ACMI_ImportFile();
; 1210 : 
; 1211 : 	
; 1212 : 	/// make the following call load window shit...
; 1213 : 
; 1214 : 		
; 1215 : 	gTrailLen = ACMI_TRAILS_SHORT; // MLR 12/22/2003 - Was 100

	mov	DWORD PTR ?gTrailLen@@3HA, 15		; gTrailLen, 0000000fH

; 1216 : 	// sprintf( gTrailLenText, "%d", gTrailLen );
; 1217 : 	
; 1218 : 	// create the critical sect
; 1219 : 	/*
; 1220 : 	if ( gUICriticalSection == NULL )
; 1221 : 		gUICriticalSection = F4CreateCriticalSection();
; 1222 : 	*/
; 1223 : 
; 1224 : 	if(!ACMILoaded)

	cmp	DWORD PTR ?ACMILoaded@@3HA, 0		; ACMILoaded
	jne	SHORT $LN3@ACMIButton

; 1225 : 	{
; 1226 : 		LoadACMIWindows();

	call	?LoadACMIWindows@@YAXXZ			; LoadACMIWindows
$LN3@ACMIButton:

; 1227 : 	}
; 1228 : 
; 1229 : 	if (acmiView == NULL)

	cmp	DWORD PTR ?acmiView@@3PAVACMIView@@A, 0	; acmiView
	jne	$LN2@ACMIButton

; 1230 : 	{	
; 1231 : 		win=gMainHandler->FindWindow(ACMI_RENDER_WIN);

	push	200137					; 00030dc9H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1232 : 		if(win == NULL)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN1@ACMIButton

; 1233 : 			return;

	jmp	$LN5@ACMIButton
$LN1@ACMIButton:

; 1234 : 		
; 1235 : 		acmiView = new ACMIView;

	push	472					; 000001d8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@ACMIButton
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0ACMIView@@QAE@XZ			; ACMIView::ACMIView
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN8@ACMIButton
$LN7@ACMIButton:
	mov	DWORD PTR tv80[ebp], 0
$LN8@ACMIButton:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?acmiView@@3PAVACMIView@@A, edx ; acmiView

; 1236 : 		acmiView->ToggleWireFrame(gDoWireFrame);

	mov	eax, DWORD PTR ?gDoWireFrame@@3HA	; gDoWireFrame
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleWireFrame@ACMIView@@QAEXH@Z	; ACMIView::ToggleWireFrame

; 1237 : 		acmiView->TogglePoles( gDoPoles );

	mov	ecx, DWORD PTR ?gDoPoles@@3HA		; gDoPoles
	push	ecx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?TogglePoles@ACMIView@@QAEXH@Z		; ACMIView::TogglePoles

; 1238 : 		acmiView->ToggleLockLines( gDoLockLines );

	mov	edx, DWORD PTR ?gDoLockLines@@3HA	; gDoLockLines
	push	edx
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?ToggleLockLines@ACMIView@@QAEXH@Z	; ACMIView::ToggleLockLines

; 1239 : 		acmiView->InitGraphics(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?InitGraphics@ACMIView@@QAEXPAVC_Window@@@Z ; ACMIView::InitGraphics
$LN2@ACMIButton:

; 1240 : 	}
; 1241 : 
; 1242 : 	// LoadAFile("acmibin\\*.vhs",NULL,ACMI_LoadACMICB,CloseWindowCB);
; 1243 : 	SetDeleteCallback(DelVHSFileCB);

	push	OFFSET ?DelVHSFileCB@@YAXJFPAVC_Base@@@Z ; DelVHSFileCB
	call	?SetDeleteCallback@@YAXP6AXJFPAVC_Base@@@Z@Z ; SetDeleteCallback
	add	esp, 4

; 1244 : 	LoadAFile(TXT_LOAD_ACMI,"acmibin\\*.vhs",NULL,ACMI_LoadACMICB,ACMICloseCB);

	push	OFFSET ?ACMICloseCB@@YAXJFPAVC_Base@@@Z	; ACMICloseCB
	push	OFFSET ?ACMI_LoadACMICB@@YAXJFPAVC_Base@@@Z ; ACMI_LoadACMICB
	push	0
	push	OFFSET ??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@
	push	239					; 000000efH
	call	?LoadAFile@@YAXJPADQAPADP6AXJFPAVC_Base@@@Z3@Z ; LoadAFile
	add	esp, 20					; 00000014H
$LN5@ACMIButton:

; 1245 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ACMIButtonCB@@YAXJFPAVC_Base@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ACMIButtonCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIButtonCB
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?ACMIDrawCB@@YAXJFPAVC_Base@@@Z PROC			; ACMIDrawCB

; 1806 : {

	push	ebp
	mov	ebp, esp

; 1807 : 	/*
; 1808 : 	** EDG NOTE: There's really no reason (that I could descern) to have
; 1809 : 	** AcmiView->Exec() and ->Draw() done in 2 different callbacks.
; 1810 : 	** Therefore this callback is now commented out and Draw() is called
; 1811 : 	** directly from Exec().  This callback can be removed completely
; 1812 : 	*/
; 1813 : 
; 1814 : 	if(ACMIViewIsReady())

	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	SHORT $LN2@ACMIDrawCB

; 1815 : 	{
; 1816 : 		acmiView->Draw();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Draw@ACMIView@@QAEXXZ			; ACMIView::Draw
$LN2@ACMIDrawCB:

; 1817 : 	}
; 1818 : }

	pop	ebp
	ret	0
?ACMIDrawCB@@YAXJFPAVC_Base@@@Z ENDP			; ACMIDrawCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_intTime$1 = -64					; size = 4
tv346 = -60						; size = 4
tv363 = -56						; size = 4
tv341 = -52						; size = 4
_hrs$ = -48						; size = 4
_msecs$ = -44						; size = 4
tv293 = -40						; size = 4
tv361 = -36						; size = 4
tv288 = -32						; size = 4
_Simseconds$ = -28					; size = 4
_txt$2 = -24						; size = 4
_newpos$ = -20						; size = 4
_secs$ = -16						; size = 4
_mins$ = -12						; size = 4
_pct$ = -8						; size = 4
_win$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?MoveACMIViewTimerCB@@YAXJFPAVC_Base@@@Z PROC		; MoveACMIViewTimerCB

; 1703 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1704 : 	C_Window *win;
; 1705 : 	float pct;
; 1706 : 	int newpos;
; 1707 : 	int mins, secs, msecs, hrs;
; 1708 : 			
; 1709 : 	float Simseconds	= 0.0f;	

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Simseconds$[ebp], xmm0

; 1710 : 
; 1711 : 	// F4EnterCriticalSection( gUICriticalSection );
; 1712 : 
; 1713 : 	if(control->GetUserNumber(_UI95_TIMER_COUNTER_) < 100)

	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	cmp	eax, 100				; 00000064H
	jge	$LN8@MoveACMIVi

; 1714 : 	{
; 1715 : 	
; 1716 : 		// should probably check to see if the tape is loaded...
; 1717 : 
; 1718 : 		if (ACMIViewIsReady() )

	call	?ACMIViewIsReady@@YAHXZ			; ACMIViewIsReady
	test	eax, eax
	je	$LN1@MoveACMIVi

; 1719 : 		{
; 1720 : 				
; 1721 : 			Simseconds = acmiView->Tape()->SimTime();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SimTime@ACMITape@@QAEMXZ		; ACMITape::SimTime
	fstp	DWORD PTR _Simseconds$[ebp]

; 1722 : 
; 1723 : 			acmiView->Exec();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Exec@ACMIView@@QAEXXZ			; ACMIView::Exec

; 1724 : 			TheLoader.WaitForLoader();

	mov	ecx, OFFSET ?TheLoader@@3VLoader@@A	; TheLoader
	call	?WaitForLoader@Loader@@QAEXXZ		; Loader::WaitForLoader

; 1725 : 
; 1726 : 			pct = acmiView->Tape()->SimTime() - acmiView->Tape()->GetTodOffset();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SimTime@ACMITape@@QAEMXZ		; ACMITape::SimTime
	fstp	DWORD PTR tv288[ebp]
	movss	xmm0, DWORD PTR tv288[ebp]
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	movss	DWORD PTR tv361[ebp], xmm0
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetTodOffset@ACMITape@@QAEMXZ		; ACMITape::GetTodOffset
	fstp	DWORD PTR tv293[ebp]
	movss	xmm0, DWORD PTR tv361[ebp]
	subss	xmm0, DWORD PTR tv293[ebp]
	movss	DWORD PTR _pct$[ebp], xmm0

; 1727 : 			secs = (int)(pct);

	cvttss2si eax, DWORD PTR _pct$[ebp]
	mov	DWORD PTR _secs$[ebp], eax

; 1728 : 			msecs = (int)(pct*100) - secs*100;

	movss	xmm0, DWORD PTR _pct$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _secs$[ebp]
	imul	edx, 100				; 00000064H
	sub	ecx, edx
	mov	DWORD PTR _msecs$[ebp], ecx

; 1729 : 
; 1730 : 			// edg: yuck!  I assume Bing did this....
; 1731 : 			// SimTime() (as now time stamped on tape) includes the
; 1732 : 			// time of day in seconds.  Assuming the Sim Starts at Noon gives
; 1733 : 			// 12 hrs * 60 secs/hr = 720 which is why the following subtraction is in.
; 1734 : 			// A bad assumption.  We'll need to record the todOffset in the raw data
; 1735 : 			// file so we can get it into tthe tape header
; 1736 : 			// mins = (int)(pct/60.0f)-720;
; 1737 : 
; 1738 : 			mins = (int)((pct)/60.0f);

	movss	xmm0, DWORD PTR _pct$[ebp]
	divss	xmm0, DWORD PTR __real@42700000
	cvttss2si eax, xmm0
	mov	DWORD PTR _mins$[ebp], eax

; 1739 : 			hrs = (int)((mins)/60.0f);

	cvtsi2ss xmm0, DWORD PTR _mins$[ebp]
	divss	xmm0, DWORD PTR __real@42700000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _hrs$[ebp], ecx

; 1740 : 			mins = (int)(fmod((float)mins,60.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _mins$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _mins$[ebp], eax

; 1741 : 
; 1742 : 			secs = (int)(fmod(pct,60.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pct$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _secs$[ebp], eax

; 1743 : 
; 1744 : 			if ( gAdjustingFrameMarker == FALSE )

	cmp	DWORD PTR ?gAdjustingFrameMarker@@3HA, 0 ; gAdjustingFrameMarker
	jne	$LN4@MoveACMIVi

; 1745 : 			{
; 1746 : 				sprintf( gCountText,
; 1747 : 						 "%02d:%02d:%02d:%02d",
; 1748 : 						 hrs,
; 1749 : 						 mins,
; 1750 : 						 secs,
; 1751 : 						 msecs );

	mov	edx, DWORD PTR _msecs$[ebp]
	push	edx
	mov	eax, DWORD PTR _secs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hrs$[ebp]
	push	edx
	push	OFFSET ??_C@_0BE@FEAMKGAE@?$CF02d?3?$CF02d?3?$CF02d?3?$CF02d?$AA@
	push	OFFSET ?gCountText@@3PADA		; gCountText
	call	_sprintf
	add	esp, 24					; 00000018H

; 1752 : 	
; 1753 : 				gCounter->Refresh( );

	mov	eax, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1754 : 				gCounter->SetText( gCountText );

	push	OFFSET ?gCountText@@3PADA		; gCountText
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1755 : 				gCounter->Refresh( );

	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gCounter@@3PAVC_Text@@A	; gCounter
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1756 : 			
; 1757 : 
; 1758 : 				pct = acmiView->Tape()->GetTapePercent();

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetTapePercent@ACMITape@@QAEMXZ	; ACMITape::GetTapePercent
	fstp	DWORD PTR _pct$[ebp]

; 1759 : 				newpos = gFrameMarkerMin + (int)((float)gFrameMarkerLen * pct);

	cvtsi2ss xmm0, DWORD PTR ?gFrameMarkerLen@@3HA	; gFrameMarkerLen
	mulss	xmm0, DWORD PTR _pct$[ebp]
	cvttss2si ecx, xmm0
	add	ecx, DWORD PTR ?gFrameMarkerMin@@3HA	; gFrameMarkerMin
	mov	DWORD PTR _newpos$[ebp], ecx

; 1760 : 				gFrameMarker->Refresh( );

	mov	edx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 1761 : 				gFrameMarker->SetSliderPos((short)newpos );

	movsx	eax, WORD PTR _newpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?SetSliderPos@C_Slider@@QAEXJ@Z		; C_Slider::SetSliderPos

; 1762 : 				gFrameMarker->Refresh( );

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1763 : 		
; 1764 : 				if(newpos == gFrameMarkerMax)

	mov	ecx, DWORD PTR _newpos$[ebp]
	cmp	ecx, DWORD PTR ?gFrameMarkerMax@@3HA	; gFrameMarkerMax
	jne	SHORT $LN4@MoveACMIVi

; 1765 : 				{
; 1766 : 					win=gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1767 : 					if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN4@MoveACMIVi

; 1768 : 						win->SetGroupState(200001,0); // Turn off all VCR buttons

	push	0
	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?SetGroupState@C_Window@@QAEXJF@Z	; C_Window::SetGroupState
$LN4@MoveACMIVi:

; 1769 : 
; 1770 : 				}			
; 1771 : 			}
; 1772 : 			// handle moving the events list when tape running
; 1773 : 			if ( !acmiView->Tape()->IsPaused() )

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?IsPaused@ACMITape@@QAEHXZ		; ACMITape::IsPaused
	test	eax, eax
	jne	$LN1@MoveACMIVi

; 1774 : 			{
; 1775 : 				int intTime = (int)(acmiView->Tape()->SimTime() - acmiView->Tape()->GetTodOffset()) * 1000;

	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?SimTime@ACMITape@@QAEMXZ		; ACMITape::SimTime
	fstp	DWORD PTR tv341[ebp]
	movss	xmm0, DWORD PTR tv341[ebp]
	mov	ecx, DWORD PTR ?acmiView@@3PAVACMIView@@A ; acmiView
	movss	DWORD PTR tv363[ebp], xmm0
	call	?Tape@ACMIView@@QAEPAVACMITape@@XZ	; ACMIView::Tape
	mov	ecx, eax
	call	?GetTodOffset@ACMITape@@QAEMXZ		; ACMITape::GetTodOffset
	fstp	DWORD PTR tv346[ebp]
	movss	xmm0, DWORD PTR tv363[ebp]
	subss	xmm0, DWORD PTR tv346[ebp]
	cvttss2si edx, xmm0
	imul	edx, 1000				; 000003e8H
	mov	DWORD PTR _intTime$1[ebp], edx

; 1776 : 				win=gMainHandler->FindWindow(ACMI_LEFT_WIN);

	push	200000					; 00030d40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1777 : 				if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN1@MoveACMIVi

; 1778 : 				{
; 1779 : 					C_Text *txt = (C_Text *)FindUITextEvent( win, 0, intTime );

	mov	eax, DWORD PTR _intTime$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	call	?FindUITextEvent@@YAPAVC_Base@@PAVC_Window@@JJ@Z ; FindUITextEvent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _txt$2[ebp], eax

; 1780 : 					if ( txt )

	cmp	DWORD PTR _txt$2[ebp], 0
	je	SHORT $LN1@MoveACMIVi

; 1781 : 					{
; 1782 : 						win->SetVirtualY(txt->GetY()-win->ClientArea_[0].top,0);

	push	0
	mov	ecx, DWORD PTR _txt$2[ebp]
	call	?GetY@C_Base@@QAEJXZ			; C_Base::GetY
	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	ecx, DWORD PTR _win$[ebp]
	sub	eax, DWORD PTR [ecx+edx+172]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?SetVirtualY@C_Window@@QAEXJJ@Z		; C_Window::SetVirtualY

; 1783 : 						win->AdjustScrollbar(0);

	push	0
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AdjustScrollbar@C_Window@@QAEXJ@Z	; C_Window::AdjustScrollbar

; 1784 : 						win->RefreshClient(0);

	push	0
	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN1@MoveACMIVi:

; 1785 : 					}
; 1786 : 				}
; 1787 : 			}
; 1788 : 		}
; 1789 : 		
; 1790 : 		control->SetUserNumber(_UI95_TIMER_COUNTER_,control->GetUserNumber(_UI95_TIMER_DELAY_));

	push	4
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1791 : 		control->Parent_->update_ |= C_DRAW_REFRESHALL;

	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+104]
	or	ecx, 2
	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [eax+104], ecx

; 1792 : 		control->Parent_->RefreshWindow();

	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN8@MoveACMIVi:

; 1793 : 	}
; 1794 : 	control->SetUserNumber(_UI95_TIMER_COUNTER_,control->GetUserNumber(_UI95_TIMER_COUNTER_)-1);

	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	sub	eax, 1
	push	eax
	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1795 : 	// F4LeaveCriticalSection( gUICriticalSection );
; 1796 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MoveACMIViewTimerCB@@YAXJFPAVC_Base@@@Z ENDP		; MoveACMIViewTimerCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?ViewTimerCB@@YAXJFPAVC_Base@@@Z PROC			; ViewTimerCB

; 1687 : {

	push	ebp
	mov	ebp, esp

; 1688 : //	F4EnterCriticalSection( gUICriticalSection );
; 1689 : 	control->SetReady(1);

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 1690 : 	control->Parent_->update_ |= C_DRAW_REFRESHALL;

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+104]
	or	edx, 2
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+104], edx

; 1691 : 	control->Parent_->RefreshWindow();

	mov	edx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 1692 : //	F4LeaveCriticalSection( gUICriticalSection );
; 1693 : }

	pop	ebp
	ret	0
?ViewTimerCB@@YAXJFPAVC_Base@@@Z ENDP			; ViewTimerCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
$T2 = -64						; size = 4
$T3 = -60						; size = 4
tv657 = -56						; size = 4
$T4 = -52						; size = 4
tv601 = -48						; size = 4
$T5 = -44						; size = 4
_tctrl$ = -40						; size = 4
_sctrl$ = -36						; size = 4
_tmr$ = -32						; size = 4
_ACMIListBox$ = -28					; size = 4
_panner$ = -24						; size = 4
_winme$ = -20						; size = 4
_ctrl$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ID$ = 8						; size = 4
?HookupACMIControls@@YAXJ@Z PROC			; HookupACMIControls

; 1379 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?HookupACMIControls@@YAXJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1380 : 	C_Panner	
; 1381 : 		*panner;
; 1382 : 
; 1383 : 	C_Window	
; 1384 : 		*winme;
; 1385 : 
; 1386 : 	C_Button	
; 1387 : 		*ctrl;
; 1388 : 
; 1389 : 	C_TimerHook 
; 1390 : 		*tmr;
; 1391 : 
; 1392 : 	C_ListBox	
; 1393 : 		*ACMIListBox;
; 1394 : 
; 1395 : 	C_Slider *sctrl;
; 1396 : 	C_Text *tctrl;
; 1397 : 
; 1398 : ////////////////////////////////////////////////////////////////////////////
; 1399 : /*
; 1400 : 	C_PopupList *menu;
; 1401 : 	
; 1402 : 
; 1403 : //	caller=gPopupMgr->GetCallingControl();
; 1404 : //	if(menu == NULL)
; 1405 : //		return;
; 1406 : 
; 1407 : 	menu=gPopupMgr->GetMenu(ACMI_OPTION_POPUP);
; 1408 : 							
; 1409 : 	if(menu)
; 1410 : 	{
; 1411 : 		// Legend stuff
; 1412 : 		menu->SetCallback(OPT_LABELS,ToggleNamesCB);
; 1413 : 		//		menu->SetCallback(MID_LEG_CIRCLES,MenuToggleCirclesCB);
; 1414 : 		//		menu->SetCallback(MID_LEG_BOUND,MenuToggleTroupBoundariesCB);
; 1415 : 		//		menu->SetCallback(MID_LEG_MOVE,MenuToggleMovementArrowsCB);
; 1416 : 	}
; 1417 : */	
; 1418 : 	
; 1419 : ///////////////////////////////////////////////////////////////////////////////////	
; 1420 : 		
; 1421 : 		
; 1422 : 	winme = gMainHandler->FindWindow(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 1423 : 
; 1424 : 	if(winme == NULL)

	cmp	DWORD PTR _winme$[ebp], 0
	jne	SHORT $LN32@HookupACMI

; 1425 : 		return;

	jmp	$LN33@HookupACMI
$LN32@HookupACMI:

; 1426 : 
; 1427 : 	// Hook up IDs here...Hook up Main Buttons...
; 1428 : 	ctrl = (C_Button *)winme->FindControl(ACMI_CLOSE);

	push	200122					; 00030dbaH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1429 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN31@HookupACMI

; 1430 : 	{
; 1431 : 		ctrl->SetCallback(ACMICloseCB);

	push	OFFSET ?ACMICloseCB@@YAXJFPAVC_Base@@@Z	; ACMICloseCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN31@HookupACMI:

; 1432 : 	}
; 1433 : 
; 1434 : 	// Hook up Close Button
; 1435 : 	ctrl = (C_Button *)winme->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1436 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN30@HookupACMI

; 1437 : 	{
; 1438 : 		ctrl->SetCallback(CloseWindowCB);

	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN30@HookupACMI:

; 1439 : 	}
; 1440 : 
; 1441 : 	ctrl = (C_Button *)winme->FindControl(FILE_LOAD_BUTTON);

	push	200121					; 00030db9H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1442 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN29@HookupACMI

; 1443 : 	{
; 1444 : 		//ctrl->SetCallback(ACMILoadCB);
; 1445 : 		ctrl->SetCallback(LoadACMIFileCB);

	push	OFFSET ?LoadACMIFileCB@@YAXJFPAVC_Base@@@Z ; LoadACMIFileCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN29@HookupACMI:

; 1446 : 
; 1447 : 	}
; 1448 : 
; 1449 : 	ctrl = (C_Button *)winme->FindControl(STOP);

	push	200003					; 00030d43H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1450 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN28@HookupACMI

; 1451 : 	{
; 1452 : 		ctrl->SetCallback(ACMIStopCB);

	push	OFFSET ?ACMIStopCB@@YAXJFPAVC_Base@@@Z	; ACMIStopCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN28@HookupACMI:

; 1453 : 		//gTransport[ STOP_BUTTON ] = ctrl;
; 1454 : 	}
; 1455 : 
; 1456 : 	ctrl = (C_Button *)winme->FindControl(PLAY);

	push	200004					; 00030d44H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1457 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN27@HookupACMI

; 1458 : 	{
; 1459 : 		ctrl->SetCallback(ACMIPlayCB);

	push	OFFSET ?ACMIPlayCB@@YAXJFPAVC_Base@@@Z	; ACMIPlayCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN27@HookupACMI:

; 1460 : 		//gTransport[ PLAY_BUTTON ] = ctrl;
; 1461 : 	}
; 1462 : 
; 1463 : 	ctrl = (C_Button *)winme->FindControl(REVERSE);

	push	200142					; 00030dceH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1464 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN26@HookupACMI

; 1465 : 	{
; 1466 : 		ctrl->SetCallback(ACMIPlayBackwardsCB);

	push	OFFSET ?ACMIPlayBackwardsCB@@YAXJFPAVC_Base@@@Z ; ACMIPlayBackwardsCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN26@HookupACMI:

; 1467 : 		//gTransport[ REV_BUTTON ] = ctrl;
; 1468 : 	}
; 1469 : 
; 1470 : 	ctrl = (C_Button *)winme->FindControl(FRAME_STEP_FORWARD);

	push	200138					; 00030dcaH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1471 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN25@HookupACMI

; 1472 : 	{
; 1473 : 		ctrl->SetCallback(ACMIStepFowardCB);

	push	OFFSET ?ACMIStepFowardCB@@YAXJFPAVC_Base@@@Z ; ACMIStepFowardCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN25@HookupACMI:

; 1474 : 		//gTransport[ SPLAY_BUTTON ] = ctrl;
; 1475 : 	}
; 1476 : 
; 1477 : 	ctrl = (C_Button *)winme->FindControl(FRAME_STEP_BACK);

	push	200139					; 00030dcbH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1478 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN24@HookupACMI

; 1479 : 	{
; 1480 : 		ctrl->SetCallback(ACMIStepReverseCB);

	push	OFFSET ?ACMIStepReverseCB@@YAXJFPAVC_Base@@@Z ; ACMIStepReverseCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN24@HookupACMI:

; 1481 : 		//gTransport[ SREV_BUTTON ] = ctrl;
; 1482 : 	}
; 1483 : 	
; 1484 : 	ctrl = (C_Button *)winme->FindControl(FASTREVERSE);

	push	200005					; 00030d45H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1485 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN23@HookupACMI

; 1486 : 	{
; 1487 : 		ctrl->SetCallback(ACMIRewindCB);

	push	OFFSET ?ACMIRewindCB@@YAXJFPAVC_Base@@@Z ; ACMIRewindCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN23@HookupACMI:

; 1488 : 		//gTransport[ FF_BUTTON ] = ctrl;
; 1489 : 	}
; 1490 : 
; 1491 : 	ctrl = (C_Button *)winme->FindControl(FASTFORWARD);

	push	200006					; 00030d46H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1492 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN22@HookupACMI

; 1493 : 	{
; 1494 : 		ctrl->SetCallback(ACMIFastForwardCB);

	push	OFFSET ?ACMIFastForwardCB@@YAXJFPAVC_Base@@@Z ; ACMIFastForwardCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN22@HookupACMI:

; 1495 : 	}
; 1496 : 
; 1497 : 	ctrl = (C_Button *)winme->FindControl(TRACKING_CHECK_CTRL);

	push	200010					; 00030d4aH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1498 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN21@HookupACMI

; 1499 : 	{
; 1500 : 		ctrl->SetCallback(ACMITrackingCB);

	push	OFFSET ?ACMITrackingCB@@YAXJFPAVC_Base@@@Z ; ACMITrackingCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN21@HookupACMI:

; 1501 : 	}
; 1502 : 
; 1503 : //	ctrl = (C_Button *)winme->FindControl(TRAIL_CTRL);
; 1504 : //	if(ctrl != NULL)
; 1505 : //	{
; 1506 : //		ctrl->SetCallback(ACMIWingTrailCB);
; 1507 : //	}
; 1508 : //
; 1509 : //	ctrl = (C_Button *)winme->FindControl(TRAIL_INC);
; 1510 : //	if(ctrl != NULL)
; 1511 : //	{
; 1512 : //		ctrl->SetCallback(ACMIWingTrailIncCB);
; 1513 : //	}
; 1514 : 
; 1515 : //	ctrl = (C_Button *)winme->FindControl(TRAIL_DEC);
; 1516 : //	if(ctrl != NULL)
; 1517 : //	{
; 1518 : //		ctrl->SetCallback(ACMIWingTrailDecCB);
; 1519 : //	}
; 1520 : 
; 1521 : 	panner = (C_Panner *)winme->FindControl(YAW_PITCH_ARROWS);

	push	200016					; 00030d50H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1522 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN20@HookupACMI

; 1523 : 	{
; 1524 : 		panner->SetCallback(ACMIPannerCB);

	push	OFFSET ?ACMIPannerCB@@YAXJFPAVC_Base@@@Z ; ACMIPannerCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN20@HookupACMI:

; 1525 : 	}
; 1526 : 
; 1527 : 	panner = (C_Panner *)winme->FindControl(OTHER_YAW_PITCH_ARROWS);

	push	200175					; 00030defH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1528 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN19@HookupACMI

; 1529 : 	{
; 1530 : 		panner->SetCallback(ACMIPannerCB);

	push	OFFSET ?ACMIPannerCB@@YAXJFPAVC_Base@@@Z ; ACMIPannerCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN19@HookupACMI:

; 1531 : 	}
; 1532 : 
; 1533 : 	panner = (C_Panner *)winme->FindControl(H_ARROWS);

	push	200014					; 00030d4eH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1534 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN18@HookupACMI

; 1535 : 	{
; 1536 : 		panner->SetCallback(ACMIHArrowsCB);

	push	OFFSET ?ACMIHArrowsCB@@YAXJFPAVC_Base@@@Z ; ACMIHArrowsCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN18@HookupACMI:

; 1537 : 	}
; 1538 : 
; 1539 : 	panner = (C_Panner *)winme->FindControl(ACMI_ZOOMER);

	push	200176					; 00030df0H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1540 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN17@HookupACMI

; 1541 : 	{
; 1542 : 		panner->SetCallback(ACMIHArrowsCB);

	push	OFFSET ?ACMIHArrowsCB@@YAXJFPAVC_Base@@@Z ; ACMIHArrowsCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN17@HookupACMI:

; 1543 : 	}
; 1544 : 
; 1545 : 	panner = (C_Panner *)winme->FindControl(V_ARROWS);

	push	200015					; 00030d4fH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1546 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN16@HookupACMI

; 1547 : 	{
; 1548 : 		panner->SetCallback(ACMIVArrowsCB);

	push	OFFSET ?ACMIVArrowsCB@@YAXJFPAVC_Base@@@Z ; ACMIVArrowsCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN16@HookupACMI:

; 1549 : 	}
; 1550 : 	
; 1551 : 	ACMIListBox = (C_ListBox *)winme->FindControl(ACMI_CAMERA);

	push	200024					; 00030d58H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 1552 : 	if(ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN15@HookupACMI

; 1553 : 	{
; 1554 : 		ACMIListBox->SetCallback(ACMICameraCB);

	push	OFFSET ?ACMICameraCB@@YAXJFPAVC_Base@@@Z ; ACMICameraCB
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN15@HookupACMI:

; 1555 : 	}
; 1556 : 	
; 1557 : 	ACMIListBox = (C_ListBox *)winme->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 1558 : 	if(ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN14@HookupACMI

; 1559 : 	{
; 1560 : 		ACMIListBox->SetCallback(ACMISubCameraCB);

	push	OFFSET ?ACMISubCameraCB@@YAXJFPAVC_Base@@@Z ; ACMISubCameraCB
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN14@HookupACMI:

; 1561 : 	}
; 1562 : 
; 1563 : 	ctrl = (C_Button *)winme->FindControl(PREV_SUBCAMERA_CTRL);

	push	200008					; 00030d48H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1564 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN13@HookupACMI

; 1565 : 	{
; 1566 : 		ctrl->SetCallback(ACMISubCameraPrevCB);

	push	OFFSET ?ACMISubCameraPrevCB@@YAXJFPAVC_Base@@@Z ; ACMISubCameraPrevCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN13@HookupACMI:

; 1567 : 	}
; 1568 : 
; 1569 : 	ctrl = (C_Button *)winme->FindControl(NEXT_SUBCAMERA_CTRL);

	push	200009					; 00030d49H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1570 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN12@HookupACMI

; 1571 : 	{
; 1572 : 		ctrl->SetCallback(ACMISubCameraNextCB);

	push	OFFSET ?ACMISubCameraNextCB@@YAXJFPAVC_Base@@@Z ; ACMISubCameraNextCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN12@HookupACMI:

; 1573 : 	}
; 1574 : 
; 1575 : 	ACMIListBox = (C_ListBox *)winme->FindControl(TRACKED_OBJECT_FIELD);

	push	200011					; 00030d4bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 1576 : 	if(ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN11@HookupACMI

; 1577 : 	{
; 1578 : 		ACMIListBox->SetCallback(ACMICamTrackingCB );

	push	OFFSET ?ACMICamTrackingCB@@YAXJFPAVC_Base@@@Z ; ACMICamTrackingCB
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN11@HookupACMI:

; 1579 : 	}
; 1580 : 
; 1581 : 	ctrl = (C_Button *)winme->FindControl(PREV_TRACK_CTRL);

	push	200012					; 00030d4cH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1582 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN10@HookupACMI

; 1583 : 	{
; 1584 : 		ctrl->SetCallback(ACMICamTrackingPrevCB);

	push	OFFSET ?ACMICamTrackingPrevCB@@YAXJFPAVC_Base@@@Z ; ACMICamTrackingPrevCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN10@HookupACMI:

; 1585 : 	}
; 1586 : 
; 1587 : 	ctrl = (C_Button *)winme->FindControl(NEXT_TRACK_CTRL);

	push	200013					; 00030d4dH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1588 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN9@HookupACMI

; 1589 : 	{
; 1590 : 		ctrl->SetCallback(ACMICamTrackingNextCB);

	push	OFFSET ?ACMICamTrackingNextCB@@YAXJFPAVC_Base@@@Z ; ACMICamTrackingNextCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN9@HookupACMI:

; 1591 : 	}
; 1592 : 
; 1593 : 	ACMIListBox = (C_ListBox *)winme->FindControl(SUBCAMERA_FIELD);

	push	200007					; 00030d47H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ACMIListBox$[ebp], eax

; 1594 : 	if(ACMIListBox != NULL)

	cmp	DWORD PTR _ACMIListBox$[ebp], 0
	je	SHORT $LN8@HookupACMI

; 1595 : 	{
; 1596 : 		ACMIListBox->SetCallback(ACMISubCameraCB);

	push	OFFSET ?ACMISubCameraCB@@YAXJFPAVC_Base@@@Z ; ACMISubCameraCB
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ACMIListBox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN8@HookupACMI:

; 1597 : 	}
; 1598 : 
; 1599 : 	ctrl = (C_Button *)winme->FindControl(ADD_POV);

	push	200144					; 00030dd0H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1600 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN7@HookupACMI

; 1601 : 	{
; 1602 : 		ctrl->SetCallback(ACMIScreenCaptureCB);

	push	OFFSET ?ACMIScreenCaptureCB@@YAXJFPAVC_Base@@@Z ; ACMIScreenCaptureCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN7@HookupACMI:

; 1603 : 	}
; 1604 : 
; 1605 : 	ctrl = (C_Button *)winme->FindControl(CUT_POV);

	push	200145					; 00030dd1H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1606 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN6@HookupACMI

; 1607 : 	{
; 1608 : 		ctrl->SetCallback(ACMICutPOVCB);

	push	OFFSET ?ACMICutPOVCB@@YAXJFPAVC_Base@@@Z ; ACMICutPOVCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN6@HookupACMI:

; 1609 : 	}
; 1610 : 
; 1611 : 	sctrl = (C_Slider *)winme->FindControl(FRAME_MARKER);

	push	200022					; 00030d56H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _sctrl$[ebp], eax

; 1612 : 	if(sctrl != NULL)

	cmp	DWORD PTR _sctrl$[ebp], 0
	je	SHORT $LN5@HookupACMI

; 1613 : 	{
; 1614 : 		gFrameMarker = sctrl;

	mov	ecx, DWORD PTR _sctrl$[ebp]
	mov	DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A, ecx ; gFrameMarker

; 1615 : 		gFrameMarker->SetCallback(ACMIFrameMarkerCB);

	push	OFFSET ?ACMIFrameMarkerCB@@YAXJFPAVC_Base@@@Z ; ACMIFrameMarkerCB
	mov	edx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 1616 : 		gFrameMarkerMin = gFrameMarker->GetSliderMin();

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?GetSliderMin@C_Slider@@QAEJXZ		; C_Slider::GetSliderMin
	mov	DWORD PTR ?gFrameMarkerMin@@3HA, eax	; gFrameMarkerMin

; 1617 : 		gFrameMarkerMax = gFrameMarker->GetSliderMax();

	mov	ecx, DWORD PTR ?gFrameMarker@@3PAVC_Slider@@A ; gFrameMarker
	call	?GetSliderMax@C_Slider@@QAEJXZ		; C_Slider::GetSliderMax
	mov	DWORD PTR ?gFrameMarkerMax@@3HA, eax	; gFrameMarkerMax

; 1618 : 		gFrameMarkerLen = gFrameMarkerMax - gFrameMarkerMin;

	mov	eax, DWORD PTR ?gFrameMarkerMax@@3HA	; gFrameMarkerMax
	sub	eax, DWORD PTR ?gFrameMarkerMin@@3HA	; gFrameMarkerMin
	mov	DWORD PTR ?gFrameMarkerLen@@3HA, eax	; gFrameMarkerLen
$LN5@HookupACMI:

; 1619 : 	}
; 1620 : 
; 1621 : 	tctrl = (C_Text *)winme->FindControl(COUNTER);

	push	200002					; 00030d42H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _tctrl$[ebp], eax

; 1622 : 	if(tctrl != NULL)

	cmp	DWORD PTR _tctrl$[ebp], 0
	je	SHORT $LN4@HookupACMI

; 1623 : 	{
; 1624 : 		gCounter = tctrl;

	mov	ecx, DWORD PTR _tctrl$[ebp]
	mov	DWORD PTR ?gCounter@@3PAVC_Text@@A, ecx	; gCounter
$LN4@HookupACMI:

; 1625 : 	}
; 1626 : 
; 1627 : 	/*
; 1628 : 	tctrl = (C_Text *)winme->FindControl(TRAIL_FIELD);
; 1629 : 	if(tctrl != NULL)
; 1630 : 	{
; 1631 : 		gTrailLenCtrl = tctrl;
; 1632 : 	}
; 1633 : 	*/
; 1634 : 
; 1635 : 	
; 1636 : 	/// ACMI LABEL TOGGLE - GNU OPTIONS BUTTONS... LABELS ARE INSIDE THIS..
; 1637 : 	ctrl = (C_Button *)winme->FindControl(ACMI_LABELS);

	push	200150					; 00030dd6H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1638 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN3@HookupACMI

; 1639 : 	{					
; 1640 : 		ctrl->SetCallback(ACMItoggleLABELSCB);

	push	OFFSET ?ACMItoggleLABELSCB@@YAXJFPAVC_Base@@@Z ; ACMItoggleLABELSCB
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 1641 : 		ctrl->SetState(0);

	push	0
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN3@HookupACMI:

; 1642 : 	}
; 1643 : 
; 1644 : 
; 1645 : 	/// ACMI SAVE AS... 
; 1646 : 	ctrl = (C_Button *)winme->FindControl(FILE_SAVE_BUTTON);

	push	200147					; 00030dd3H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1647 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN2@HookupACMI

; 1648 : 	{													
; 1649 : 		ctrl->SetCallback(SaveACMIFileCB);

	push	OFFSET ?SaveACMIFileCB@@YAXJFPAVC_Base@@@Z ; SaveACMIFileCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1650 : 		ctrl->SetState(0);

	push	0
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN2@HookupACMI:

; 1651 : 	}
; 1652 : 
; 1653 : 
; 1654 : 	if(ID == ACMI_RENDER_WIN)

	cmp	DWORD PTR _ID$[ebp], 200137		; 00030dc9H
	jne	$LN33@HookupACMI

; 1655 : 	{
; 1656 : 		drawTimer = new C_TimerHook;

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN35@HookupACMI
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0C_TimerHook@@QAE@XZ			; C_TimerHook::C_TimerHook
	mov	DWORD PTR tv601[ebp], eax
	jmp	SHORT $LN36@HookupACMI
$LN35@HookupACMI:
	mov	DWORD PTR tv601[ebp], 0
$LN36@HookupACMI:
	mov	ecx, DWORD PTR tv601[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A, edx ; drawTimer

; 1657 : 		drawTimer->Setup(C_DONT_CARE,C_TYPE_NORMAL);

	push	25					; 00000019H
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	call	?Setup@C_TimerHook@@QAEXJF@Z		; C_TimerHook::Setup

; 1658 : 		drawTimer->SetUpdateCallback(ViewTimerCB);

	push	OFFSET ?ViewTimerCB@@YAXJFPAVC_Base@@@Z	; ViewTimerCB
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	call	?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetUpdateCallback

; 1659 : 		drawTimer->SetDrawCallback(ACMIDrawCB);

	push	OFFSET ?ACMIDrawCB@@YAXJFPAVC_Base@@@Z	; ACMIDrawCB
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	call	?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetDrawCallback

; 1660 : 		drawTimer->SetFlagBitOn(C_BIT_ABSOLUTE);

	push	262144					; 00040000H
	mov	eax, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1661 : 		drawTimer->SetFlagBitOff(C_BIT_TIMER);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1662 : 		drawTimer->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1663 : 		drawTimer->SetCluster(200);

	push	200					; 000000c8H
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	call	?SetCluster@C_Base@@QAEXJ@Z		; C_Base::SetCluster

; 1664 : 		drawTimer->SetReady(1);

	push	1
	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 1665 : 		winme->AddControlTop(drawTimer);

	mov	ecx, DWORD PTR ?drawTimer@@3PAVC_TimerHook@@A ; drawTimer
	push	ecx
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?AddControlTop@C_Window@@QAEXPAVC_Base@@@Z ; C_Window::AddControlTop

; 1666 : 		
; 1667 : 		tmr = new C_TimerHook;

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN37@HookupACMI
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0C_TimerHook@@QAE@XZ			; C_TimerHook::C_TimerHook
	mov	DWORD PTR tv657[ebp], eax
	jmp	SHORT $LN38@HookupACMI
$LN37@HookupACMI:
	mov	DWORD PTR tv657[ebp], 0
$LN38@HookupACMI:
	mov	edx, DWORD PTR tv657[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _tmr$[ebp], eax

; 1668 : 		tmr->Setup(C_DONT_CARE, C_TYPE_TIMER);

	push	67					; 00000043H
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _tmr$[ebp]
	call	?Setup@C_TimerHook@@QAEXJF@Z		; C_TimerHook::Setup

; 1669 : 		tmr->SetUpdateCallback(MoveACMIViewTimerCB);

	push	OFFSET ?MoveACMIViewTimerCB@@YAXJFPAVC_Base@@@Z ; MoveACMIViewTimerCB
	mov	ecx, DWORD PTR _tmr$[ebp]
	call	?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetUpdateCallback

; 1670 : 		tmr->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _tmr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tmr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1671 : 		tmr->SetCluster(200);

	push	200					; 000000c8H
	mov	ecx, DWORD PTR _tmr$[ebp]
	call	?SetCluster@C_Base@@QAEXJ@Z		; C_Base::SetCluster

; 1672 : 		tmr->SetUserNumber(_UI95_TIMER_DELAY_, 10);

	push	10					; 0000000aH
	push	4
	mov	ecx, DWORD PTR _tmr$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1673 : 		tmr->SetFlagBitOn(C_BIT_ABSOLUTE);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _tmr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tmr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1674 : 		winme->AddControlTop(tmr);

	mov	ecx, DWORD PTR _tmr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?AddControlTop@C_Window@@QAEXPAVC_Base@@@Z ; C_Window::AddControlTop
$LN33@HookupACMI:

; 1675 : 	}
; 1676 : 
; 1677 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?HookupACMIControls@@YAXJ@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?HookupACMIControls@@YAXJ@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?HookupACMIControls@@YAXJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?HookupACMIControls@@YAXJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HookupACMIControls@@YAXJ@Z ENDP			; HookupACMIControls
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
$T2 = -84						; size = 4
tv187 = -80						; size = 4
$T3 = -76						; size = 4
tv86 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
_scroll$ = -60						; size = 4
tv182 = -56						; size = 4
$T6 = -52						; size = 4
_handle$ = -48						; size = 4
tv81 = -44						; size = 4
$T7 = -40						; size = 4
_retVal$ = -36						; size = 4
_fileinfo$ = -32					; size = 4
_ui_id$ = -28						; size = 4
_y$ = -24						; size = 4
_win$ = -20						; size = 4
_tbtn$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?FindACMIFLTFiles@@YAXXZ PROC				; FindACMIFLTFiles

; 1286 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindACMIFLTFiles@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1287 : 	long		
; 1288 : 		handle;
; 1289 : 
; 1290 : 	int
; 1291 : 		retVal = 0;

	mov	DWORD PTR _retVal$[ebp], 0

; 1292 : 
; 1293 : 	_finddata_t 
; 1294 : 		*fileinfo;
; 1295 : 
; 1296 : 	C_Window 
; 1297 : 		*win;
; 1298 : 
; 1299 : 	C_Button 
; 1300 : 		*tbtn;
; 1301 : 
; 1302 : 	int 
; 1303 : 		y,
; 1304 : 		ui_id;
; 1305 : 
; 1306 : 	C_ScrollBar 
; 1307 : 		*scroll;
; 1308 : 
; 1309 : 	// first check to see if we should import any files.
; 1310 : 	// ACMI_ImportFile();
; 1311 : 	
; 1312 : 	win = gMainHandler->FindWindow(ACMI_LOAD_WIN);

	push	200143					; 00030dcfH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1313 : 	if(win == NULL)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN7@FindACMIFL

; 1314 : 		return;

	jmp	$LN8@FindACMIFL
$LN7@FindACMIFL:

; 1315 : 
; 1316 : 
; 1317 : 	fileinfo = new _finddata_t;

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _fileinfo$[ebp], eax

; 1318 : 	handle = _findfirst("acmibin\\*.vhs", fileinfo );

	mov	ecx, DWORD PTR _fileinfo$[ebp]
	push	ecx
	push	OFFSET ??_C@_0O@MBEJLBIM@acmibin?2?$CK?4vhs?$AA@
	call	__findfirst64i32
	add	esp, 8
	mov	DWORD PTR _handle$[ebp], eax

; 1319 :  	//handle = _findfirst("Campaign\\save\\fltfiles\\*.vhs", fileinfo );
; 1320 : 	//	handle = _findfirst("acmibin\\*.vhs", fileinfo );
; 1321 : 							
; 1322 : 	if (handle > 0)

	cmp	DWORD PTR _handle$[ebp], 0
	jle	$LN6@FindACMIFL

; 1323 : 	{
; 1324 : 		ui_id=700;

	mov	DWORD PTR _ui_id$[ebp], 700		; 000002bcH

; 1325 : 		y=2;

	mov	DWORD PTR _y$[ebp], 2

; 1326 : 
; 1327 : 		tbtn=new C_Button;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN10@FindACMIFL
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0C_Button@@QAE@XZ			; C_Button::C_Button
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN11@FindACMIFL
$LN10@FindACMIFL:
	mov	DWORD PTR tv81[ebp], 0
$LN11@FindACMIFL:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _tbtn$[ebp], eax

; 1328 : 		tbtn->Setup(ui_id++,C_TYPE_TOGGLE,10,y);

	mov	ecx, DWORD PTR _ui_id$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	push	10					; 0000000aH
	push	26					; 0000001aH
	mov	eax, DWORD PTR tv86[ebp]
	push	eax
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?Setup@C_Button@@QAEXJFJJ@Z		; C_Button::Setup
	mov	ecx, DWORD PTR _ui_id$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui_id$[ebp], ecx

; 1329 : 		tbtn->SetFlagBitOn(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	edx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1330 : 		tbtn->SetText(C_STATE_0,fileinfo->name);

	mov	eax, DWORD PTR _fileinfo$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	push	0
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 1331 : 		tbtn->SetText(C_STATE_1,fileinfo->name);

	mov	ecx, DWORD PTR _fileinfo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	push	1
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 1332 : 		tbtn->SetFont(win->Font_);

	mov	edx, DWORD PTR _win$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1333 : 		tbtn->SetFgColor(C_STATE_0,0x0f0f0f0);

	push	15790320				; 00f0f0f0H
	push	0
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetFgColor@C_Button@@QAEXFK@Z		; C_Button::SetFgColor

; 1334 : 		tbtn->SetFgColor(C_STATE_1,0x00fffff);

	push	1048575					; 000fffffH
	push	1
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetFgColor@C_Button@@QAEXFK@Z		; C_Button::SetFgColor

; 1335 : 		tbtn->SetCallback(ACMIPickAFileCB);

	push	OFFSET ?ACMIPickAFileCB@@YAXJFPAVC_Base@@@Z ; ACMIPickAFileCB
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1336 : 		y+=gFontList->GetHeight(win->Font_);

	mov	ecx, DWORD PTR _win$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR ?gFontList@@3PAVC_Font@@A ; gFontList
	call	?GetHeight@C_Font@@QAEHJ@Z		; C_Font::GetHeight
	add	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 1337 : 		win->AddControl(tbtn);

	mov	eax, DWORD PTR _tbtn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
$LN5@FindACMIFL:

; 1338 : 		while (retVal != -1)

	cmp	DWORD PTR _retVal$[ebp], -1
	je	$LN4@FindACMIFL

; 1339 : 		{
; 1340 : 			retVal = _findnext(handle, fileinfo);

	mov	ecx, DWORD PTR _fileinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _retVal$[ebp], eax

; 1341 : 			if (retVal != -1)

	cmp	DWORD PTR _retVal$[ebp], -1
	je	$LN3@FindACMIFL

; 1342 : 			{
; 1343 : 				tbtn=new C_Button;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN12@FindACMIFL
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0C_Button@@QAE@XZ			; C_Button::C_Button
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN13@FindACMIFL
$LN12@FindACMIFL:
	mov	DWORD PTR tv182[ebp], 0
$LN13@FindACMIFL:
	mov	eax, DWORD PTR tv182[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _tbtn$[ebp], ecx

; 1344 : 				tbtn->Setup(ui_id++,C_TYPE_TOGGLE,10,y);

	mov	edx, DWORD PTR _ui_id$[ebp]
	mov	DWORD PTR tv187[ebp], edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	10					; 0000000aH
	push	26					; 0000001aH
	mov	ecx, DWORD PTR tv187[ebp]
	push	ecx
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?Setup@C_Button@@QAEXJFJJ@Z		; C_Button::Setup
	mov	edx, DWORD PTR _ui_id$[ebp]
	add	edx, 1
	mov	DWORD PTR _ui_id$[ebp], edx

; 1345 : 				tbtn->SetFlagBitOn(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1346 : 				tbtn->SetText(C_STATE_0,fileinfo->name);

	mov	ecx, DWORD PTR _fileinfo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	push	0
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 1347 : 				tbtn->SetText(C_STATE_1,fileinfo->name);

	mov	edx, DWORD PTR _fileinfo$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	push	1
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 1348 : 				tbtn->SetFont(win->Font_);

	mov	eax, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1349 : 				tbtn->SetFgColor(C_STATE_0,0x0f0f0f0);

	push	15790320				; 00f0f0f0H
	push	0
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetFgColor@C_Button@@QAEXFK@Z		; C_Button::SetFgColor

; 1350 : 				tbtn->SetFgColor(C_STATE_1,0x0ffffff);

	push	16777215				; 00ffffffH
	push	1
	mov	ecx, DWORD PTR _tbtn$[ebp]
	call	?SetFgColor@C_Button@@QAEXFK@Z		; C_Button::SetFgColor

; 1351 : 				tbtn->SetCallback(ACMIPickAFileCB);

	push	OFFSET ?ACMIPickAFileCB@@YAXJFPAVC_Base@@@Z ; ACMIPickAFileCB
	mov	eax, DWORD PTR _tbtn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _tbtn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1352 : 				y+=gFontList->GetHeight(win->Font_);

	mov	ecx, DWORD PTR _win$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR ?gFontList@@3PAVC_Font@@A ; gFontList
	call	?GetHeight@C_Font@@QAEHJ@Z		; C_Font::GetHeight
	add	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 1353 : 				win->AddControl(tbtn);

	mov	eax, DWORD PTR _tbtn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
$LN3@FindACMIFL:

; 1354 : 			}
; 1355 : 		}

	jmp	$LN5@FindACMIFL
$LN4@FindACMIFL:

; 1356 : 
; 1357 : 		scroll= (C_ScrollBar *)win->FindControl(FILE_SCROLL);

	push	200120					; 00030db8H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _scroll$[ebp], eax

; 1358 : 		if(scroll != NULL)

	cmp	DWORD PTR _scroll$[ebp], 0
	je	SHORT $LN2@FindACMIFL

; 1359 : 		{
; 1360 : 			scroll->SetVirtualH(y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _scroll$[ebp]
	call	?SetVirtualH@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualH
$LN2@FindACMIFL:

; 1361 : 		}
; 1362 : 		if(ui_id > 700)

	cmp	DWORD PTR _ui_id$[ebp], 700		; 000002bcH
	jle	SHORT $LN6@FindACMIFL

; 1363 : 		{
; 1364 : 			win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN6@FindACMIFL:

; 1365 : 		}
; 1366 : 	}
; 1367 : 
; 1368 : 	delete fileinfo;

	mov	edx, DWORD PTR _fileinfo$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@FindACMIFL:

; 1369 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?FindACMIFLTFiles@@YAXXZ$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?FindACMIFLTFiles@@YAXXZ$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?FindACMIFLTFiles@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindACMIFLTFiles@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindACMIFLTFiles@@YAXXZ ENDP				; FindACMIFLTFiles
; Function compile flags: /Odtp
;	COMDAT ??_GACMIView@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GACMIView@@QAEPAXI@Z PROC				; ACMIView::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ACMIView@@QAE@XZ			; ACMIView::~ACMIView
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GACMIView@@QAEPAXI@Z ENDP				; ACMIView::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmiview.h
;	COMDAT ?ToggleTracking@ACMIView@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleTracking@ACMIView@@QAEXXZ PROC			; ACMIView::ToggleTracking, COMDAT
; _this$ = ecx

; 138  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 		_tracking ^= 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	xor	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], ecx

; 140  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleTracking@ACMIView@@QAEXXZ ENDP			; ACMIView::ToggleTracking
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmiview.h
;	COMDAT ?TapeHasLoaded@ACMIView@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TapeHasLoaded@ACMIView@@QAEHXZ PROC			; ACMIView::TapeHasLoaded, COMDAT
; _this$ = ecx

; 130  : 	BOOL TapeHasLoaded( void ) { return _tapeHasLoaded; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]
	mov	esp, ebp
	pop	ebp
	ret	0
?TapeHasLoaded@ACMIView@@QAEHXZ ENDP			; ACMIView::TapeHasLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmvwinl.cpp
;	COMDAT ?TrackingObject@ACMIView@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TrackingObject@ACMIView@@QAEHXZ PROC			; ACMIView::TrackingObject, COMDAT
; _this$ = ecx

; 169  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	return _currentEntityCam;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+312]

; 171  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TrackingObject@ACMIView@@QAEHXZ ENDP			; ACMIView::TrackingObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmvwinl.cpp
;	COMDAT ?IncrementTrackingObject@ACMIView@@QAEXH@Z
_TEXT	SEGMENT
_numEnt$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_inc$ = 8						; size = 4
?IncrementTrackingObject@ACMIView@@QAEXH@Z PROC		; ACMIView::IncrementTrackingObject, COMDAT
; _this$ = ecx

; 108  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	int numEnt = _tape->NumEntities();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	call	?NumEntities@ACMITape@@QAEHXZ		; ACMITape::NumEntities
	mov	DWORD PTR _numEnt$[ebp], eax

; 110  : 	int i;
; 111  : 
; 112  : 	if ( inc > 0 )

	cmp	DWORD PTR _inc$[ebp], 0
	jle	$LN18@IncrementT

; 113  : 	{
; 114  : 		for ( i = _currentEntityCam + 1; i < numEnt; i++ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN17@IncrementT
$LN16@IncrementT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@IncrementT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numEnt$[ebp]
	jge	SHORT $LN15@IncrementT

; 115  : 		{
; 116  : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+edx], -1
	je	SHORT $LN14@IncrementT

; 117  : 			{
; 118  : 				_currentEntityCam = i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+312], eax

; 119  : 				return;

	jmp	$LN19@IncrementT
$LN14@IncrementT:

; 120  : 			}
; 121  : 		}

	jmp	SHORT $LN16@IncrementT
$LN15@IncrementT:

; 122  : 		for ( i = 0; i < _currentEntityCam; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@IncrementT
$LN12@IncrementT:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@IncrementT:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+312]
	jge	SHORT $LN11@IncrementT

; 123  : 		{
; 124  : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx], -1
	je	SHORT $LN10@IncrementT

; 125  : 			{
; 126  : 				_currentEntityCam = i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+312], edx

; 127  : 				return;

	jmp	$LN19@IncrementT
$LN10@IncrementT:

; 128  : 			}
; 129  : 		}

	jmp	SHORT $LN12@IncrementT
$LN11@IncrementT:

; 130  : 	}
; 131  : 	else

	jmp	$LN19@IncrementT
$LN18@IncrementT:

; 132  : 	{
; 133  : 		for ( i = _currentEntityCam - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN8@IncrementT
$LN7@IncrementT:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@IncrementT:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN6@IncrementT

; 134  : 		{
; 135  : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax], -1
	je	SHORT $LN5@IncrementT

; 136  : 			{
; 137  : 				_currentEntityCam = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+312], ecx

; 138  : 				return;

	jmp	SHORT $LN19@IncrementT
$LN5@IncrementT:

; 139  : 			}
; 140  : 		}

	jmp	SHORT $LN7@IncrementT
$LN6@IncrementT:

; 141  : 		for ( i = numEnt - 1; i > _currentEntityCam; i-- )

	mov	edx, DWORD PTR _numEnt$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN4@IncrementT
$LN3@IncrementT:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@IncrementT:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+312]
	jle	SHORT $LN19@IncrementT

; 142  : 		{
; 143  : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax], -1
	je	SHORT $LN1@IncrementT

; 144  : 			{
; 145  : 				_currentEntityCam = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+312], ecx

; 146  : 				return;

	jmp	SHORT $LN19@IncrementT
$LN1@IncrementT:

; 147  : 			}
; 148  : 		}

	jmp	SHORT $LN3@IncrementT
$LN19@IncrementT:

; 149  : 	}
; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementTrackingObject@ACMIView@@QAEXH@Z ENDP		; ACMIView::IncrementTrackingObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmvwinl.cpp
;	COMDAT ?CameraObject@ACMIView@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CameraObject@ACMIView@@QAEHXZ PROC			; ACMIView::CameraObject, COMDAT
; _this$ = ecx

; 99   : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 	return _currentCam;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CameraObject@ACMIView@@QAEHXZ ENDP			; ACMIView::CameraObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmvwinl.cpp
;	COMDAT ?IncrementCameraObject@ACMIView@@QAEXH@Z
_TEXT	SEGMENT
_numEnt$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_inc$ = 8						; size = 4
?IncrementCameraObject@ACMIView@@QAEXH@Z PROC		; ACMIView::IncrementCameraObject, COMDAT
; _this$ = ecx

; 37   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	int numEnt = _tape->NumEntities();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	call	?NumEntities@ACMITape@@QAEHXZ		; ACMITape::NumEntities
	mov	DWORD PTR _numEnt$[ebp], eax

; 39   : 	int i;
; 40   : 
; 41   : 	if ( inc > 0 )

	cmp	DWORD PTR _inc$[ebp], 0
	jle	$LN18@IncrementC

; 42   : 	{
; 43   : 		for ( i = _currentCam + 1; i < numEnt; i++ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN17@IncrementC
$LN16@IncrementC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@IncrementC:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numEnt$[ebp]
	jge	SHORT $LN15@IncrementC

; 44   : 		{
; 45   : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+edx], -1
	je	SHORT $LN14@IncrementC

; 46   : 			{
; 47   : 				_currentCam = i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+308], eax

; 48   : 				return;

	jmp	$LN19@IncrementC
$LN14@IncrementC:

; 49   : 			}
; 50   : 		}

	jmp	SHORT $LN16@IncrementC
$LN15@IncrementC:

; 51   : 		for ( i = 0; i < _currentCam; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@IncrementC
$LN12@IncrementC:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@IncrementC:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+308]
	jge	SHORT $LN11@IncrementC

; 52   : 		{
; 53   : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx], -1
	je	SHORT $LN10@IncrementC

; 54   : 			{
; 55   : 				_currentCam = i;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+308], edx

; 56   : 				return;

	jmp	$LN19@IncrementC
$LN10@IncrementC:

; 57   : 			}
; 58   : 		}

	jmp	SHORT $LN12@IncrementC
$LN11@IncrementC:

; 59   : 	}
; 60   : 	else

	jmp	$LN19@IncrementC
$LN18@IncrementC:

; 61   : 	{
; 62   : 		for ( i = _currentCam - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN8@IncrementC
$LN7@IncrementC:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@IncrementC:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN6@IncrementC

; 63   : 		{
; 64   : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax], -1
	je	SHORT $LN5@IncrementC

; 65   : 			{
; 66   : 				_currentCam = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+308], ecx

; 67   : 				return;

	jmp	SHORT $LN19@IncrementC
$LN5@IncrementC:

; 68   : 			}
; 69   : 		}

	jmp	SHORT $LN7@IncrementC
$LN6@IncrementC:

; 70   : 		for ( i = numEnt - 1; i > _currentCam; i-- )

	mov	edx, DWORD PTR _numEnt$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN4@IncrementC
$LN3@IncrementC:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@IncrementC:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+308]
	jle	SHORT $LN19@IncrementC

; 71   : 		{
; 72   : 			if ( _entityUIMappings[ i ].listboxId != -1 )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax], -1
	je	SHORT $LN1@IncrementC

; 73   : 			{
; 74   : 				_currentCam = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+308], ecx

; 75   : 				return;

	jmp	SHORT $LN19@IncrementC
$LN1@IncrementC:

; 76   : 			}
; 77   : 		}

	jmp	SHORT $LN3@IncrementC
$LN19@IncrementC:

; 78   : 	}
; 79   : 
; 80   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementCameraObject@ACMIView@@QAEXH@Z ENDP		; ACMIView::IncrementCameraObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmvwinl.cpp
;	COMDAT ?Tape@ACMIView@@QAEPAVACMITape@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Tape@ACMIView@@QAEPAVACMITape@@XZ PROC			; ACMIView::Tape, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 	return _tape; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+348]

; 21   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Tape@ACMIView@@QAEPAVACMITape@@XZ ENDP			; ACMIView::Tape
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmitape.h
;	COMDAT ?GetTodOffset@ACMITape@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTodOffset@ACMITape@@QAEMXZ PROC			; ACMITape::GetTodOffset, COMDAT
; _this$ = ecx

; 569  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 		return _tapeHdr.todOffset;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+80]

; 571  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTodOffset@ACMITape@@QAEMXZ ENDP			; ACMITape::GetTodOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmitape.h
;	COMDAT ?SetWingTrailLength@ACMITape@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?SetWingTrailLength@ACMITape@@QAEXH@Z PROC		; ACMITape::SetWingTrailLength, COMDAT
; _this$ = ecx

; 556  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		_wtMaxLength = val;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+152], ecx

; 558  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetWingTrailLength@ACMITape@@QAEXH@Z ENDP		; ACMITape::SetWingTrailLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmitape.h
;	COMDAT ?SetObjScale@ACMITape@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?SetObjScale@ACMITape@@QAEXM@Z PROC			; ACMITape::SetObjScale, COMDAT
; _this$ = ecx

; 539  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 540  : 		_tapeObjScale = val;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [eax+212], xmm0

; 541  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetObjScale@ACMITape@@QAEXM@Z ENDP			; ACMITape::SetObjScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?GetTapePercent@ACMITape@@QAEMXZ
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
?GetTapePercent@ACMITape@@QAEMXZ PROC			; ACMITape::GetTapePercent, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	// F4Assert( _simTime >= _tapeHdr.startTime );
; 155  : 	// F4Assert( _tapeHdr.totPlayTime > 0.0f );
; 156  : 
; 157  : 	return (_simTime - _tapeHdr.startTime)/_tapeHdr.totPlayTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	subss	xmm0, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+76]
	movss	DWORD PTR tv77[ebp], xmm0
	fld	DWORD PTR tv77[ebp]

; 158  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTapePercent@ACMITape@@QAEMXZ ENDP			; ACMITape::GetTapePercent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?SimTime@ACMITape@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SimTime@ACMITape@@QAEMXZ PROC				; ACMITape::SimTime, COMDAT
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 	return _simTime;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+108]

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTime@ACMITape@@QAEMXZ ENDP				; ACMITape::SimTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?SetMaxPlaySpeed@ACMITape@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetMaxPlaySpeed@ACMITape@@QAEXM@Z PROC			; ACMITape::SetMaxPlaySpeed, COMDAT
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 	_maxPlaySpeed = (float)fabs(n);

	push	ecx
	movss	xmm0, DWORD PTR _n$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+104]

; 128  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxPlaySpeed@ACMITape@@QAEXM@Z ENDP			; ACMITape::SetMaxPlaySpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?SetPlayAcceleration@ACMITape@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetPlayAcceleration@ACMITape@@QAEXM@Z PROC		; ACMITape::SetPlayAcceleration, COMDAT
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	_playAcceleration = n;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _n$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayAcceleration@ACMITape@@QAEXM@Z ENDP		; ACMITape::SetPlayAcceleration
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?SetPlayVelocity@ACMITape@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetPlayVelocity@ACMITape@@QAEXM@Z PROC			; ACMITape::SetPlayVelocity, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	_playVelocity = n;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _n$[ebp]
	movss	DWORD PTR [eax+96], xmm0

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayVelocity@ACMITape@@QAEXM@Z ENDP			; ACMITape::SetPlayVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?StepTime@ACMITape@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_numSeconds$ = 8					; size = 4
?StepTime@ACMITape@@QAEXM@Z PROC			; ACMITape::StepTime, COMDAT
; _this$ = ecx

; 79   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 	_simTime += numSeconds;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	addss	xmm0, DWORD PTR _numSeconds$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+108], xmm0

; 81   : 	_stepTrail = numSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _numSeconds$[ebp]
	movss	DWORD PTR [edx+112], xmm0

; 82   : 	AdvanceAllHeads();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AdvanceAllHeads@ACMITape@@AAEXXZ	; ACMITape::AdvanceAllHeads

; 83   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StepTime@ACMITape@@QAEXM@Z ENDP			; ACMITape::StepTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?Pause@ACMITape@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pause@ACMITape@@QAEXXZ PROC				; ACMITape::Pause, COMDAT
; _this$ = ecx

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	_paused = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 1

; 71   : 	_unpause = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Pause@ACMITape@@QAEXXZ ENDP				; ACMITape::Pause
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?Play@ACMITape@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Play@ACMITape@@QAEXXZ PROC				; ACMITape::Play, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	_unpause = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 1

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Play@ACMITape@@QAEXXZ ENDP				; ACMITape::Play
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?IsPaused@ACMITape@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPaused@ACMITape@@QAEHXZ PROC				; ACMITape::IsPaused, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 	return _paused;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPaused@ACMITape@@QAEHXZ ENDP				; ACMITape::IsPaused
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?IsLoaded@ACMITape@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLoaded@ACMITape@@QAEHXZ PROC				; ACMITape::IsLoaded, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if ( _tape == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jne	SHORT $LN1@IsLoaded

; 42   : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN2@IsLoaded
$LN1@IsLoaded:

; 43   : 	return TRUE;

	mov	eax, 1
$LN2@IsLoaded:

; 44   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsLoaded@ACMITape@@QAEHXZ ENDP				; ACMITape::IsLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmtpinl.cpp
;	COMDAT ?NumEntities@ACMITape@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumEntities@ACMITape@@QAEHXZ PROC			; ACMITape::NumEntities, COMDAT
; _this$ = ecx

; 10   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11   : 	// F4Assert(_tape != NULL);
; 12   : 
; 13   : 	return _tapeHdr.numEntities;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 14   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumEntities@ACMITape@@QAEHXZ ENDP			; ACMITape::NumEntities
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GACMI_Hash@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GACMI_Hash@@QAEPAXI@Z PROC				; ACMI_Hash::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ACMI_Hash@@QAE@XZ			; ACMI_Hash::~ACMI_Hash
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GACMI_Hash@@QAEPAXI@Z ENDP				; ACMI_Hash::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmiui.cpp
_TEXT	SEGMENT
_id$ = -4						; size = 4
?LoadACMIWindows@@YAXXZ PROC				; LoadACMIWindows

; 1256 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1257 : 	long
; 1258 : 		id;
; 1259 : 
; 1260 : 	if(!ACMILoaded)

	cmp	DWORD PTR ?ACMILoaded@@3HA, 0		; ACMILoaded
	jne	SHORT $LN4@LoadACMIWi

; 1261 : 	{
; 1262 : 		gMainParser->LoadImageList("ac_art.lst");

	push	OFFSET ??_C@_0L@HHPJKLOK@ac_art?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadImageList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadImageList

; 1263 : //		gImageMgr->SetAllKeys(UI95_RGB24Bit(0x00ff00ff));
; 1264 : 		gMainParser->LoadSoundList("ac_snd.lst");

	push	OFFSET ??_C@_0L@OKMPGJJN@ac_snd?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadSoundList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadSoundList

; 1265 : 		gMainParser->LoadWindowList("ac_scf.lst");	// Modified by M.N. - add art/art1024 by LoadWindowList

	push	OFFSET ??_C@_0L@MGNAKJFG@ac_scf?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadWindowList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadWindowList

; 1266 : 
; 1267 : 		id = gMainParser->GetFirstWindowLoaded();

	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?GetFirstWindowLoaded@C_Parser@@QAEJXZ	; C_Parser::GetFirstWindowLoaded
	mov	DWORD PTR _id$[ebp], eax
$LN2@LoadACMIWi:

; 1268 : 		while(id)

	cmp	DWORD PTR _id$[ebp], 0
	je	SHORT $LN1@LoadACMIWi

; 1269 : 		{
; 1270 : 			HookupACMIControls(id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	?HookupACMIControls@@YAXJ@Z		; HookupACMIControls
	add	esp, 4

; 1271 : 			id = gMainParser->GetNextWindowLoaded();

	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?GetNextWindowLoaded@C_Parser@@QAEJXZ	; C_Parser::GetNextWindowLoaded
	mov	DWORD PTR _id$[ebp], eax

; 1272 : 		}

	jmp	SHORT $LN2@LoadACMIWi
$LN1@LoadACMIWi:

; 1273 : 
; 1274 : 		ACMILoaded++;

	mov	ecx, DWORD PTR ?ACMILoaded@@3HA		; ACMILoaded
	add	ecx, 1
	mov	DWORD PTR ?ACMILoaded@@3HA, ecx		; ACMILoaded
$LN4@LoadACMIWi:

; 1275 : 	}
; 1276 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadACMIWindows@@YAXXZ ENDP				; LoadACMIWindows
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetControlList@C_Window@@QAEPAUControlListStr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetControlList@C_Window@@QAEPAUControlListStr@@XZ PROC	; C_Window::GetControlList, COMDAT
; _this$ = ecx

; 285  : 		CONTROLLIST *GetControlList() { return(Controls_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4304]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ENDP	; C_Window::GetControlList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetVirtualY@C_Window@@QAEXJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_y$ = 8							; size = 4
_Client$ = 12						; size = 4
?SetVirtualY@C_Window@@QAEXJJ@Z PROC			; C_Window::SetVirtualY, COMDAT
; _this$ = ecx

; 255  : 		void SetVirtualY(long y,long Client) { if(Client >= WIN_MAX_CLIENTS) return; VY_[Client]=-y;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _Client$[ebp], 8
	jl	SHORT $LN1@SetVirtual
	jmp	SHORT $LN2@SetVirtual
$LN1@SetVirtual:
	mov	eax, DWORD PTR _y$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+512], eax
$LN2@SetVirtual:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetVirtualY@C_Window@@QAEXJJ@Z ENDP			; C_Window::SetVirtualY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cparser.h
;	COMDAT ?GetNextWindowLoaded@C_Parser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWindowLoaded@C_Parser@@QAEJXZ PROC		; C_Parser::GetNextWindowLoaded, COMDAT
; _this$ = ecx

; 99   : 		long GetNextWindowLoaded() { WinIndex_++; if(WinIndex_ < WinLoaded_) return(WindowList_[WinIndex_]); else return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+960]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+960], cx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+960]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+962]
	cmp	ecx, eax
	jge	SHORT $LN2@GetNextWin
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+960]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+104]
	jmp	SHORT $LN3@GetNextWin
	jmp	SHORT $LN3@GetNextWin
$LN2@GetNextWin:
	xor	eax, eax
$LN3@GetNextWin:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWindowLoaded@C_Parser@@QAEJXZ ENDP		; C_Parser::GetNextWindowLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cparser.h
;	COMDAT ?GetFirstWindowLoaded@C_Parser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstWindowLoaded@C_Parser@@QAEJXZ PROC		; C_Parser::GetFirstWindowLoaded, COMDAT
; _this$ = ecx

; 98   : 		long GetFirstWindowLoaded() { WinIndex_=0; if(WinIndex_ < WinLoaded_) return(WindowList_[WinIndex_]); else return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+960], ax
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+960]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+962]
	cmp	eax, edx
	jge	SHORT $LN2@GetFirstWi
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+960]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+104]
	jmp	SHORT $LN3@GetFirstWi
	jmp	SHORT $LN3@GetFirstWi
$LN2@GetFirstWi:
	xor	eax, eax
$LN3@GetFirstWi:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstWindowLoaded@C_Parser@@QAEJXZ ENDP		; C_Parser::GetFirstWindowLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cthook.h
;	COMDAT ?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_routine$ = 8						; size = 4
?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_TimerHook::SetDrawCallback, COMDAT
; _this$ = ecx

; 34   : 		void SetDrawCallback(void (*routine)(long ID,short hittype,C_Base *control)) { DrawCallback_=routine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _routine$[ebp]
	mov	DWORD PTR [eax+60], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_TimerHook::SetDrawCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cthook.h
;	COMDAT ?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_routine$ = 8						; size = 4
?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_TimerHook::SetUpdateCallback, COMDAT
; _this$ = ecx

; 32   : 		void SetUpdateCallback(void (*routine)(long ID,short hittype,C_Base *control)) { UpdateCallback_=routine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _routine$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_TimerHook::SetUpdateCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cpanner.h
;	COMDAT ?GetVRange@C_Panner@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVRange@C_Panner@@QAEJXZ PROC			; C_Panner::GetVRange, COMDAT
; _this$ = ecx

; 56   : 		long GetVRange() { return(SY_); }	  //! 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVRange@C_Panner@@QAEJXZ ENDP			; C_Panner::GetVRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cpanner.h
;	COMDAT ?GetHRange@C_Panner@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHRange@C_Panner@@QAEJXZ PROC			; C_Panner::GetHRange, COMDAT
; _this$ = ecx

; 55   : 		long GetHRange() { return(SX_); }	  //! 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHRange@C_Panner@@QAEJXZ ENDP			; C_Panner::GetHRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cslider.h
;	COMDAT ?GetSliderPos@C_Slider@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSliderPos@C_Slider@@QAEJXZ PROC			; C_Slider::GetSliderPos, COMDAT
; _this$ = ecx

; 56   : 		long GetSliderPos() { if(GetType() == C_TYPE_VERTICAL) return(SY_); return(SX_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@C_Base@@QAEFXZ			; C_Base::GetType
	cwde
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN1@GetSliderP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+116]
	jmp	SHORT $LN2@GetSliderP
$LN1@GetSliderP:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
$LN2@GetSliderP:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSliderPos@C_Slider@@QAEJXZ ENDP			; C_Slider::GetSliderPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cslider.h
;	COMDAT ?GetSliderMin@C_Slider@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSliderMin@C_Slider@@QAEJXZ PROC			; C_Slider::GetSliderMin, COMDAT
; _this$ = ecx

; 55   : 		long GetSliderMin() { return(MinPos_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSliderMin@C_Slider@@QAEJXZ ENDP			; C_Slider::GetSliderMin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cslider.h
;	COMDAT ?GetSliderMax@C_Slider@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSliderMax@C_Slider@@QAEJXZ PROC			; C_Slider::GetSliderMax, COMDAT
; _this$ = ecx

; 54   : 		long GetSliderMax() { return(MaxPos_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+124]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSliderMax@C_Slider@@QAEJXZ ENDP			; C_Slider::GetSliderMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cscroll.h
;	COMDAT ?SetVirtualH@C_ScrollBar@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
?SetVirtualH@C_ScrollBar@@QAEXJ@Z PROC			; C_ScrollBar::SetVirtualH, COMDAT
; _this$ = ecx

; 67   : 		void SetVirtualH(long h) { if(-h < VirtualH_) VirtualH_=-h; CalcRanges(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _h$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+124]
	jge	SHORT $LN1@SetVirtual
	mov	edx, DWORD PTR _h$[ebp]
	neg	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], edx
$LN1@SetVirtual:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcRanges@C_ScrollBar@@AAEXXZ		; C_ScrollBar::CalcRanges
	mov	esp, ebp
	pop	ebp
	ret	4
?SetVirtualH@C_ScrollBar@@QAEXJ@Z ENDP			; C_ScrollBar::SetVirtualH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?GetTextID@C_ListBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextID@C_ListBox@@QAEJXZ PROC			; C_ListBox::GetTextID, COMDAT
; _this$ = ecx

; 109  : 		long GetTextID() { return(LabelVal_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextID@C_ListBox@@QAEJXZ ENDP			; C_ListBox::GetTextID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetParent@C_Base@@QAEPAVC_Window@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetParent@C_Base@@QAEPAVC_Window@@XZ PROC		; C_Base::GetParent, COMDAT
; _this$ = ecx

; 149  : 		C_Window *GetParent()		{ return(Parent_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetParent@C_Base@@QAEPAVC_Window@@XZ ENDP		; C_Base::GetParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetY@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@C_Base@@QAEJXZ PROC				; C_Base::GetY, COMDAT
; _this$ = ecx

; 142  : 		long GetY()					{ return(y_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetY@C_Base@@QAEJXZ ENDP				; C_Base::GetY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetGroup@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroup@C_Base@@QAEJXZ PROC				; C_Base::GetGroup, COMDAT
; _this$ = ecx

; 137  : 		long  GetGroup()			{ return(Section_[_GROUP_]); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroup@C_Base@@QAEJXZ ENDP				; C_Base::GetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetType@C_Base@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@C_Base@@QAEFXZ PROC				; C_Base::GetType, COMDAT
; _this$ = ecx

; 135  : 		short GetType()				{ return(Type_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+22]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@C_Base@@QAEFXZ ENDP				; C_Base::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetReady@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 2
?SetReady@C_Base@@QAEXF@Z PROC				; C_Base::SetReady, COMDAT
; _this$ = ecx

; 116  : 		void SetReady(short r)									{ Ready_=r; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _r$[ebp]
	mov	WORD PTR [eax+42], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetReady@C_Base@@QAEXF@Z ENDP				; C_Base::SetReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetCluster@C_Base@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?SetCluster@C_Base@@QAEXJ@Z PROC			; C_Base::SetCluster, COMDAT
; _this$ = ecx

; 97   : 		void SetCluster(long id)								{ Section_[_CLUSTER_]=id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCluster@C_Base@@QAEXJ@Z ENDP			; C_Base::SetCluster
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 521  :         {return (fmodf(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fmodf
	add	esp, 8
	pop	ebp
	ret	0
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv77 = -12						; size = 8
tv79 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 418  :         {return ((float)fmod((double)_X, (double)_Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv77[ebp]
	movsd	xmm0, QWORD PTR tv77[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
