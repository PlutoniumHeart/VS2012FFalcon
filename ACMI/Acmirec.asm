; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\ACMI\src\Acmirec.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?gACMIRecError@@3HA				; gACMIRecError
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
_BSS	SEGMENT
?gACMIRecError@@3HA DD 01H DUP (?)			; gACMIRecError
_BSS	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
PUBLIC	?GetLastID@ACMI_Hash@@QAEJXZ			; ACMI_Hash::GetLastID
PUBLIC	??0ACMIRecorder@@QAE@XZ				; ACMIRecorder::ACMIRecorder
PUBLIC	??1ACMIRecorder@@QAE@XZ				; ACMIRecorder::~ACMIRecorder
PUBLIC	?StartRecording@ACMIRecorder@@QAEXXZ		; ACMIRecorder::StartRecording
PUBLIC	?StopRecording@ACMIRecorder@@QAEXXZ		; ACMIRecorder::StopRecording
PUBLIC	?ToggleRecording@ACMIRecorder@@QAEXXZ		; ACMIRecorder::ToggleRecording
PUBLIC	?IsRecording@ACMIRecorder@@QAEHXZ		; ACMIRecorder::IsRecording
PUBLIC	?TracerRecord@ACMIRecorder@@QAEXPAUACMITracerStartRecord@@@Z ; ACMIRecorder::TracerRecord
PUBLIC	?GenPositionRecord@ACMIRecorder@@QAEXPAUACMIGenPositionRecord@@@Z ; ACMIRecorder::GenPositionRecord
PUBLIC	?AircraftPositionRecord@ACMIRecorder@@QAEXPAUACMIAircraftPositionRecord@@@Z ; ACMIRecorder::AircraftPositionRecord
PUBLIC	?MissilePositionRecord@ACMIRecorder@@QAEXPAUACMIMissilePositionRecord@@@Z ; ACMIRecorder::MissilePositionRecord
PUBLIC	?ChaffPositionRecord@ACMIRecorder@@QAEXPAUACMIChaffPositionRecord@@@Z ; ACMIRecorder::ChaffPositionRecord
PUBLIC	?FlarePositionRecord@ACMIRecorder@@QAEXPAUACMIFlarePositionRecord@@@Z ; ACMIRecorder::FlarePositionRecord
PUBLIC	?FeaturePositionRecord@ACMIRecorder@@QAEXPAUACMIFeaturePositionRecord@@@Z ; ACMIRecorder::FeaturePositionRecord
PUBLIC	?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z ; ACMIRecorder::StationarySfxRecord
PUBLIC	?MovingSfxRecord@ACMIRecorder@@QAEXPAUACMIMovingSfxRecord@@@Z ; ACMIRecorder::MovingSfxRecord
PUBLIC	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
PUBLIC	?DOFRecord@ACMIRecorder@@QAEXPAUACMIDOFRecord@@@Z ; ACMIRecorder::DOFRecord
PUBLIC	?TodOffsetRecord@ACMIRecorder@@QAEXPAUACMITodOffsetRecord@@@Z ; ACMIRecorder::TodOffsetRecord
PUBLIC	?FeatureStatusRecord@ACMIRecorder@@QAEXPAUACMIFeatureStatusRecord@@@Z ; ACMIRecorder::FeatureStatusRecord
PUBLIC	?PercentTapeFull@ACMIRecorder@@QAEHXZ		; ACMIRecorder::PercentTapeFull
PUBLIC	?AcmiFileSize@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::AcmiFileSize
PUBLIC	?gACMIRec@@3VACMIRecorder@@A			; gACMIRec
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_04EACMIGGP@acmi?$AA@			; `string'
PUBLIC	??_C@_0O@NJBINIAI@acmibin?2?$CK?4flt?$AA@	; `string'
PUBLIC	??_C@_08DIILMCIP@acmibin?2?$AA@			; `string'
PUBLIC	??_C@_0L@BMPAELGO@?9?9?9?9?9?9?9?9?9?9?$AA@	; `string'
PUBLIC	??_C@_0BF@LCEBFDCK@acmibin?2acmi?$CF04d?4flt?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0CA@KKCEGHMH@ACMI?5Recording?0?5File?5Size?5?$DN?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@CNKPCEA@ACMI?5Stopped?5Recording?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@40a00000
PUBLIC	__real@41200000
PUBLIC	__real@41880000
PUBLIC	__real@41c80000
PUBLIC	__real@41e80000
PUBLIC	__real@42140000
PUBLIC	__real@42240000
PUBLIC	__real@42440000
PUBLIC	__real@44800000
PUBLIC	__real@49742400
EXTRN	_atexit:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fwrite:PROC
EXTRN	_sprintf:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_F4CreateCriticalSection:PROC
EXTRN	_F4DestroyCriticalSection:PROC
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	?GetFirst@ACMI_Hash@@QAEJPAPAVACMI_HASHNODE@@PAK@Z:PROC ; ACMI_Hash::GetFirst
EXTRN	?GetNext@ACMI_Hash@@QAEJPAPAVACMI_HASHNODE@@PAK@Z:PROC ; ACMI_Hash::GetNext
EXTRN	_MonoPrint:PROC
EXTRN	?InitACMIRecord@SimulationDriver@@QAEXXZ:PROC	; SimulationDriver::InitACMIRecord
EXTRN	?InitACMIIDTable@@YAXXZ:PROC			; InitACMIIDTable
EXTRN	?CleanupACMIIDTable@@YAXXZ:PROC			; CleanupACMIIDTable
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	?ACMIIDTable@@3PAVACMI_Hash@@A:DWORD		; ACMIIDTable
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?gAcmiStr@@3PADA:BYTE				; gAcmiStr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

?gACMIRec@@3VACMIRecorder@@A DB 014H DUP (?)		; gACMIRec
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+006
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@42440000
CONST	SEGMENT
__real@42440000 DD 042440000r			; 49
CONST	ENDS
;	COMDAT __real@42240000
CONST	SEGMENT
__real@42240000 DD 042240000r			; 41
CONST	ENDS
;	COMDAT __real@42140000
CONST	SEGMENT
__real@42140000 DD 042140000r			; 37
CONST	ENDS
;	COMDAT __real@41e80000
CONST	SEGMENT
__real@41e80000 DD 041e80000r			; 29
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
CONST	SEGMENT
??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@ DB 'ACMI Recordi'
	DB	'ng starting new tape', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNKPCEA@ACMI?5Stopped?5Recording?6?$AA@
CONST	SEGMENT
??_C@_0BI@CNKPCEA@ACMI?5Stopped?5Recording?6?$AA@ DB 'ACMI Stopped Record'
	DB	'ing', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KKCEGHMH@ACMI?5Recording?0?5File?5Size?5?$DN?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0CA@KKCEGHMH@ACMI?5Recording?0?5File?5Size?5?$DN?5?$CFf?6?$AA@ DB 'A'
	DB	'CMI Recording, File Size = %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LCEBFDCK@acmibin?2acmi?$CF04d?4flt?$AA@
CONST	SEGMENT
??_C@_0BF@LCEBFDCK@acmibin?2acmi?$CF04d?4flt?$AA@ DB 'acmibin\acmi%04d.fl'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BMPAELGO@?9?9?9?9?9?9?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_0L@BMPAELGO@?9?9?9?9?9?9?9?9?9?9?$AA@ DB '----------', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIILMCIP@acmibin?2?$AA@
CONST	SEGMENT
??_C@_08DIILMCIP@acmibin?2?$AA@ DB 'acmibin\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NJBINIAI@acmibin?2?$CK?4flt?$AA@
CONST	SEGMENT
??_C@_0O@NJBINIAI@acmibin?2?$CK?4flt?$AA@ DB 'acmibin\*.flt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EACMIGGP@acmi?$AA@
CONST	SEGMENT
??_C@_04EACMIGGP@acmi?$AA@ DB 'acmi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gACMIRec$initializer$ DD FLAT:??__EgACMIRec@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FgACMIRec@@YAXXZ
text$yd	SEGMENT
??__FgACMIRec@@YAXXZ PROC				; `dynamic atexit destructor for 'gACMIRec'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	??1ACMIRecorder@@QAE@XZ			; ACMIRecorder::~ACMIRecorder
	pop	ebp
	ret	0
??__FgACMIRec@@YAXXZ ENDP				; `dynamic atexit destructor for 'gACMIRec''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
;	COMDAT ??__EgACMIRec@@YAXXZ
text$yc	SEGMENT
??__EgACMIRec@@YAXXZ PROC				; `dynamic initializer for 'gACMIRec'', COMDAT

; 28   : ACMIRecorder		gACMIRec;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	??0ACMIRecorder@@QAE@XZ			; ACMIRecorder::ACMIRecorder
	push	OFFSET ??__FgACMIRec@@YAXXZ		; `dynamic atexit destructor for 'gACMIRec''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EgACMIRec@@YAXXZ ENDP				; `dynamic initializer for 'gACMIRec''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?AcmiFileSize@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AcmiFileSize@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::AcmiFileSize, COMDAT
; _this$ = ecx

; 138  : 	int AcmiFileSize (void)									{ return ACMIFileSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?AcmiFileSize@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::AcmiFileSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PercentTapeFull@ACMIRecorder@@QAEHXZ PROC		; ACMIRecorder::PercentTapeFull
; _this$ = ecx

; 598  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 	return (int)(10.0f * ( _bytesWritten/_maxBytesToWrite ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	divss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si eax, xmm0

; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PercentTapeFull@ACMIRecorder@@QAEHXZ ENDP		; ACMIRecorder::PercentTapeFull
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?FeatureStatusRecord@ACMIRecorder@@QAEXPAUACMIFeatureStatusRecord@@@Z PROC ; ACMIRecorder::FeatureStatusRecord
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 335  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@FeatureSta

; 336  : 	{
; 337  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 338  : 		return;

	jmp	$LN4@FeatureSta
$LN3@FeatureSta:

; 339  : 	}
; 340  : 
; 341  : 	recp->hdr.type = (BYTE)ACMIRecFeatureStatus;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 12			; 0000000cH

; 342  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 343  : 
; 344  : 	if (!fwrite( recp, sizeof( ACMIFeatureStatusRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	17					; 00000011H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@FeatureSta

; 345  : 	{
; 346  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 347  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@FeatureSta:

; 348  : 	}
; 349  : 
; 350  : 	_bytesWritten += (float)(sizeof( ACMIFeatureStatusRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@41880000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 351  : 	// check our file size and automaticly start a new recording
; 352  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@FeatureSta

; 353  : 	{
; 354  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 355  : 		// this tells simdrive to toggle recording at the appropriate time
; 356  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 357  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@FeatureSta:

; 358  : 	}
; 359  : 
; 360  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@FeatureSta:

; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FeatureStatusRecord@ACMIRecorder@@QAEXPAUACMIFeatureStatusRecord@@@Z ENDP ; ACMIRecorder::FeatureStatusRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?TodOffsetRecord@ACMIRecorder@@QAEXPAUACMITodOffsetRecord@@@Z PROC ; ACMIRecorder::TodOffsetRecord
; _this$ = ecx

; 683  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 684  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 685  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@TodOffsetR

; 686  : 	{
; 687  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 688  : 		return;

	jmp	$LN4@TodOffsetR
$LN3@TodOffsetR:

; 689  : 	}
; 690  : 
; 691  : 	recp->hdr.type = (BYTE)ACMIRecTodOffset;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 11			; 0000000bH

; 692  : 
; 693  : 	if (!fwrite( recp, sizeof( ACMITodOffsetRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	5
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@TodOffsetR

; 694  : 	{
; 695  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 696  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@TodOffsetR:

; 697  : 	}
; 698  : 
; 699  : 	_bytesWritten += (float)(sizeof( ACMITodOffsetRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@40a00000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 700  : 	// check our file size and automaticly start a new recording
; 701  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@TodOffsetR

; 702  : 	{
; 703  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 704  : 		// this tells simdrive to toggle recording at the appropriate time
; 705  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 706  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@TodOffsetR:

; 707  : 	}
; 708  : 
; 709  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@TodOffsetR:

; 710  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TodOffsetRecord@ACMIRecorder@@QAEXPAUACMITodOffsetRecord@@@Z ENDP ; ACMIRecorder::TodOffsetRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?DOFRecord@ACMIRecorder@@QAEXPAUACMIDOFRecord@@@Z PROC	; ACMIRecorder::DOFRecord
; _this$ = ecx

; 512  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 513  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 514  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@DOFRecord

; 515  : 	{
; 516  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 517  : 		return;

	jmp	$LN4@DOFRecord
$LN3@DOFRecord:

; 518  : 	}
; 519  : 
; 520  : 	recp->hdr.type = (BYTE)ACMIRecDOF;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 8

; 521  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 522  : 
; 523  : 	if (!fwrite( recp, sizeof( ACMIDOFRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	25					; 00000019H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@DOFRecord

; 524  : 	{
; 525  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 526  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@DOFRecord:

; 527  : 	}
; 528  : 
; 529  : 	_bytesWritten += (float)(sizeof( ACMIDOFRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@41c80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 530  : 	// check our file size and automaticly start a new recording
; 531  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@DOFRecord

; 532  : 	{
; 533  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 534  : 		// this tells simdrive to toggle recording at the appropriate time
; 535  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 536  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@DOFRecord:

; 537  : 	}
; 538  : 
; 539  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@DOFRecord:

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DOFRecord@ACMIRecorder@@QAEXPAUACMIDOFRecord@@@Z ENDP	; ACMIRecorder::DOFRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z PROC ; ACMIRecorder::SwitchRecord
; _this$ = ecx

; 477  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 478  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 479  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@SwitchReco

; 480  : 	{
; 481  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 482  : 		return;

	jmp	$LN4@SwitchReco
$LN3@SwitchReco:

; 483  : 	}
; 484  : 
; 485  : 	recp->hdr.type = (BYTE)ACMIRecSwitch;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 7

; 486  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 487  : 
; 488  : 	if (!fwrite( recp, sizeof( ACMISwitchRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	25					; 00000019H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@SwitchReco

; 489  : 	{
; 490  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 491  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@SwitchReco:

; 492  : 	}
; 493  : 
; 494  : 	_bytesWritten += (float)(sizeof( ACMISwitchRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@41c80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 495  : 	// check our file size and automaticly start a new recording
; 496  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@SwitchReco

; 497  : 	{
; 498  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 499  : 		// this tells simdrive to toggle recording at the appropriate time
; 500  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 501  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@SwitchReco:

; 502  : 	}
; 503  : 
; 504  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@SwitchReco:

; 505  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ENDP ; ACMIRecorder::SwitchRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?MovingSfxRecord@ACMIRecorder@@QAEXPAUACMIMovingSfxRecord@@@Z PROC ; ACMIRecorder::MovingSfxRecord
; _this$ = ecx

; 442  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 444  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@MovingSfxR

; 445  : 	{
; 446  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 447  : 		return;

	jmp	$LN4@MovingSfxR
$LN3@MovingSfxR:

; 448  : 	}
; 449  : 
; 450  : 	recp->hdr.type = (BYTE)ACMIRecMovingSfx;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 6

; 451  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 452  : 
; 453  : 	if (!fwrite( recp, sizeof( ACMIMovingSfxRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	49					; 00000031H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@MovingSfxR

; 454  : 	{
; 455  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 456  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@MovingSfxR:

; 457  : 	}
; 458  : 
; 459  : 	_bytesWritten += (float)(sizeof( ACMIMovingSfxRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42440000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 460  : 	// check our file size and automaticly start a new recording
; 461  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@MovingSfxR

; 462  : 	{
; 463  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 464  : 		// this tells simdrive to toggle recording at the appropriate time
; 465  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 466  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@MovingSfxR:

; 467  : 	}
; 468  : 
; 469  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@MovingSfxR:

; 470  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MovingSfxRecord@ACMIRecorder@@QAEXPAUACMIMovingSfxRecord@@@Z ENDP ; ACMIRecorder::MovingSfxRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z PROC ; ACMIRecorder::StationarySfxRecord
; _this$ = ecx

; 407  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 408  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 409  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@Stationary

; 410  : 	{
; 411  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 412  : 		return;

	jmp	$LN4@Stationary
$LN3@Stationary:

; 413  : 	}
; 414  : 
; 415  : 	recp->hdr.type = (BYTE)ACMIRecStationarySfx;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 5

; 416  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 417  : 
; 418  : 	if (!fwrite( recp, sizeof( ACMIStationarySfxRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	29					; 0000001dH
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@Stationary

; 419  : 	{
; 420  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 421  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@Stationary:

; 422  : 	}
; 423  : 
; 424  : 	_bytesWritten += (float)(sizeof( ACMIStationarySfxRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@41e80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 425  : 	// check our file size and automaticly start a new recording
; 426  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@Stationary

; 427  : 	{
; 428  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 429  : 		// this tells simdrive to toggle recording at the appropriate time
; 430  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 431  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@Stationary:

; 432  : 	}
; 433  : 
; 434  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@Stationary:

; 435  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z ENDP ; ACMIRecorder::StationarySfxRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?FeaturePositionRecord@ACMIRecorder@@QAEXPAUACMIFeaturePositionRecord@@@Z PROC ; ACMIRecorder::FeaturePositionRecord
; _this$ = ecx

; 298  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 299  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 300  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@FeaturePos

; 301  : 	{
; 302  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 303  : 		return;

	jmp	$LN4@FeaturePos
$LN3@FeaturePos:

; 304  : 	}
; 305  : 
; 306  : 	recp->hdr.type = (BYTE)ACMIRecFeaturePosition;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 2

; 307  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 308  : 
; 309  : 	if (!fwrite( recp, sizeof( ACMIFeaturePositionRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	49					; 00000031H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@FeaturePos

; 310  : 	{
; 311  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 312  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@FeaturePos:

; 313  : 	}
; 314  : 
; 315  : 	_bytesWritten += (float)(sizeof( ACMIFeaturePositionRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42440000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 316  : 	// check our file size and automaticly start a new recording
; 317  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@FeaturePos

; 318  : 	{
; 319  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 320  : 		// this tells simdrive to toggle recording at the appropriate time
; 321  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 322  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@FeaturePos:

; 323  : 	}
; 324  : 
; 325  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@FeaturePos:

; 326  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FeaturePositionRecord@ACMIRecorder@@QAEXPAUACMIFeaturePositionRecord@@@Z ENDP ; ACMIRecorder::FeaturePositionRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?FlarePositionRecord@ACMIRecorder@@QAEXPAUACMIFlarePositionRecord@@@Z PROC ; ACMIRecorder::FlarePositionRecord
; _this$ = ecx

; 645  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 647  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@FlarePosit

; 648  : 	{
; 649  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 650  : 		return;

	jmp	$LN4@FlarePosit
$LN3@FlarePosit:

; 651  : 	}
; 652  : 
; 653  : 	recp->hdr.type = (BYTE)ACMIRecFlarePosition;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 10			; 0000000aH

; 654  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 655  : 
; 656  : // FIX	*(recp->data.label) = NULL;
; 657  : // FIX	recp->data.teamColor = 0x0;
; 658  : 	
; 659  : 	if (!fwrite( recp, sizeof( ACMIFlarePositionRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	37					; 00000025H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@FlarePosit

; 660  : 	{
; 661  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 662  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@FlarePosit:

; 663  : 	}
; 664  : 
; 665  : 	_bytesWritten += (float)(sizeof( ACMIFlarePositionRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42140000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 666  : 	// check our file size and automaticly start a new recording
; 667  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@FlarePosit

; 668  : 	{
; 669  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 670  : 		// this tells simdrive to toggle recording at the appropriate time
; 671  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 672  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@FlarePosit:

; 673  : 	}
; 674  : 
; 675  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@FlarePosit:

; 676  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FlarePositionRecord@ACMIRecorder@@QAEXPAUACMIFlarePositionRecord@@@Z ENDP ; ACMIRecorder::FlarePositionRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?ChaffPositionRecord@ACMIRecorder@@QAEXPAUACMIChaffPositionRecord@@@Z PROC ; ACMIRecorder::ChaffPositionRecord
; _this$ = ecx

; 607  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 609  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@ChaffPosit

; 610  : 	{
; 611  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 612  : 		return;

	jmp	$LN4@ChaffPosit
$LN3@ChaffPosit:

; 613  : 	}
; 614  : 
; 615  : 	recp->hdr.type = (BYTE)ACMIRecChaffPosition;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 9

; 616  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 617  : 
; 618  : // FIX	*(recp->data.label) = NULL;
; 619  : // FIX	recp->data.teamColor = 0x0;
; 620  : 
; 621  : 	if (!fwrite( recp, sizeof( ACMIChaffPositionRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	37					; 00000025H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@ChaffPosit

; 622  : 	{
; 623  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 624  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@ChaffPosit:

; 625  : 	}
; 626  : 
; 627  : 	_bytesWritten += (float)(sizeof( ACMIChaffPositionRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42140000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 628  : 	// check our file size and automaticly start a new recording
; 629  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@ChaffPosit

; 630  : 	{
; 631  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 632  : 		// this tells simdrive to toggle recording at the appropriate time
; 633  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 634  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@ChaffPosit:

; 635  : 	}
; 636  : 
; 637  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@ChaffPosit:

; 638  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChaffPositionRecord@ACMIRecorder@@QAEXPAUACMIChaffPositionRecord@@@Z ENDP ; ACMIRecorder::ChaffPositionRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?MissilePositionRecord@ACMIRecorder@@QAEXPAUACMIMissilePositionRecord@@@Z PROC ; ACMIRecorder::MissilePositionRecord
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 371  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@MissilePos

; 372  : 	{
; 373  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 374  : 		return;

	jmp	$LN4@MissilePos
$LN3@MissilePos:

; 375  : 	}
; 376  : 
; 377  : 	recp->hdr.type = (BYTE)ACMIRecMissilePosition;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 1

; 378  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 379  : 
; 380  : // FIX	*(recp->data.label) = NULL;
; 381  : 
; 382  : 	if (!fwrite( recp, sizeof( ACMIMissilePositionRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	37					; 00000025H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@MissilePos

; 383  : 	{
; 384  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 385  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@MissilePos:

; 386  : 	}
; 387  : 
; 388  : 
; 389  : 	_bytesWritten += (float)(sizeof( ACMIMissilePositionRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42140000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 390  : 	// check our file size and automaticly start a new recording
; 391  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@MissilePos

; 392  : 	{
; 393  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 394  : 		// this tells simdrive to toggle recording at the appropriate time
; 395  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 396  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@MissilePos:

; 397  : 	}
; 398  : 
; 399  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@MissilePos:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MissilePositionRecord@ACMIRecorder@@QAEXPAUACMIMissilePositionRecord@@@Z ENDP ; ACMIRecorder::MissilePositionRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?AircraftPositionRecord@ACMIRecorder@@QAEXPAUACMIAircraftPositionRecord@@@Z PROC ; ACMIRecorder::AircraftPositionRecord
; _this$ = ecx

; 548  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 549  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 550  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@AircraftPo

; 551  : 	{
; 552  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 553  : 		return;

	jmp	$LN4@AircraftPo
$LN3@AircraftPo:

; 554  : 	}
; 555  : 
; 556  : 	recp->hdr.type = (BYTE)ACMIRecAircraftPosition;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 3

; 557  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 558  : 
; 559  : 	if (!fwrite( recp, sizeof( ACMIAircraftPositionRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	41					; 00000029H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@AircraftPo

; 560  : 	{
; 561  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 562  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@AircraftPo:

; 563  : 	}
; 564  : 
; 565  : 	_bytesWritten += (float)(sizeof( ACMIAircraftPositionRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42240000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 566  : 	// check our file size and automaticly start a new recording
; 567  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@AircraftPo

; 568  : 	{
; 569  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 570  : 		// this tells simdrive to toggle recording at the appropriate time
; 571  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 572  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@AircraftPo:

; 573  : 	}
; 574  : 
; 575  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@AircraftPo:

; 576  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AircraftPositionRecord@ACMIRecorder@@QAEXPAUACMIAircraftPositionRecord@@@Z ENDP ; ACMIRecorder::AircraftPositionRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?GenPositionRecord@ACMIRecorder@@QAEXPAUACMIGenPositionRecord@@@Z PROC ; ACMIRecorder::GenPositionRecord
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 263  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@GenPositio

; 264  : 	{
; 265  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 266  : 		return;

	jmp	$LN4@GenPositio
$LN3@GenPositio:

; 267  : 	}
; 268  : 
; 269  : 	recp->hdr.type = (BYTE)ACMIRecGenPosition;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 0

; 270  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 271  : 
; 272  : // FIX	*(recp->data.label) = NULL;
; 273  : 
; 274  : 	if (!fwrite( recp, sizeof( ACMIGenPositionRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	37					; 00000025H
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@GenPositio

; 275  : 	{
; 276  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 277  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@GenPositio:

; 278  : 	}
; 279  : 
; 280  : 	_bytesWritten += (float)(sizeof( ACMIGenPositionRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@42140000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 281  : 	// check our file size and automaticly start a new recording
; 282  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@GenPositio

; 283  : 	{
; 284  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 285  : 		// this tells simdrive to toggle recording at the appropriate time
; 286  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 287  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@GenPositio:

; 288  : 	}
; 289  : 
; 290  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@GenPositio:

; 291  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GenPositionRecord@ACMIRecorder@@QAEXPAUACMIGenPositionRecord@@@Z ENDP ; ACMIRecorder::GenPositionRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_recp$ = 8						; size = 4
?TracerRecord@ACMIRecorder@@QAEXPAUACMITracerStartRecord@@@Z PROC ; ACMIRecorder::TracerRecord
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 226  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@TracerReco

; 227  : 	{
; 228  : 		F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 229  : 		return;

	jmp	$LN4@TracerReco
$LN3@TracerReco:

; 230  : 	}
; 231  : 
; 232  : 	recp->hdr.type = (BYTE)ACMIRecTracerStart;

	mov	edx, DWORD PTR _recp$[ebp]
	mov	BYTE PTR [edx], 4

; 233  : 	// recp->hdr.time = (float)(vuxGameTime/1000) + OTWDriver.todOffset;
; 234  : 
; 235  : 
; 236  : 	if (!fwrite( recp, sizeof( ACMITracerStartRecord ), 1, _fd ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	29					; 0000001dH
	mov	edx, DWORD PTR _recp$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@TracerReco

; 237  : 	{
; 238  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 239  : 		gACMIRecError = TRUE;

	mov	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
$LN2@TracerReco:

; 240  : 	}
; 241  : 
; 242  : 	_bytesWritten += (float)(sizeof( ACMITracerStartRecord ));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@41e80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 243  : 
; 244  : 	// check our file size and automaticly start a new recording
; 245  : 	if ( _bytesWritten >= _maxBytesToWrite )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN1@TracerReco

; 246  : 	{
; 247  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 248  : 		// this tells simdrive to toggle recording at the appropriate time
; 249  : 		SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1

; 250  : 		MonoPrint( "ACMI Recording starting new tape\n" );

	push	OFFSET ??_C@_0CC@BPPLCJKO@ACMI?5Recording?5starting?5new?5tape@
	call	_MonoPrint
	add	esp, 4
$LN1@TracerReco:

; 251  : 	}
; 252  : 
; 253  : 	F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN4@TracerReco:

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TracerRecord@ACMIRecorder@@QAEXPAUACMITracerStartRecord@@@Z ENDP ; ACMIRecorder::TracerRecord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
;	COMDAT ?IsRecording@ACMIRecorder@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRecording@ACMIRecorder@@QAEHXZ PROC			; ACMIRecorder::IsRecording, COMDAT
; _this$ = ecx

; 319  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return _recording;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 321  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRecording@ACMIRecorder@@QAEHXZ ENDP			; ACMIRecorder::IsRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleRecording@ACMIRecorder@@QAEXXZ PROC		; ACMIRecorder::ToggleRecording
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 584  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 585  : 	if ( IsRecording() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRecording@ACMIRecorder@@QAEHXZ	; ACMIRecorder::IsRecording
	test	eax, eax
	je	SHORT $LN2@ToggleReco

; 586  : 		StopRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StopRecording

; 587  : 	else

	jmp	SHORT $LN1@ToggleReco
$LN2@ToggleReco:

; 588  : 		StartRecording();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRecording@ACMIRecorder@@QAEXXZ	; ACMIRecorder::StartRecording
$LN1@ToggleReco:

; 589  : 	F4LeaveCriticalSection( _csect );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4

; 590  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleRecording@ACMIRecorder@@QAEXXZ ENDP		; ACMIRecorder::ToggleRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_hdr$ = -36						; size = 5
_idx$ = -28						; size = 4
$T1 = -24						; size = 4
_list$ = -20						; size = 4
_rec$ = -16						; size = 4
_i$ = -12						; size = 4
_count$ = -8						; size = 4
_this$ = -4						; size = 4
?StopRecording@ACMIRecorder@@QAEXXZ PROC		; ACMIRecorder::StopRecording
; _this$ = ecx

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 	long i,count;
; 169  : 	unsigned long idx;
; 170  : 	ACMI_HASHNODE *rec;
; 171  : 	ACMI_CallRec *list;
; 172  : 	ACMIRecHeader  hdr;
; 173  : 
; 174  : 
; 175  : 	F4EnterCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 176  : 	if ( !_fd )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN4@StopRecord

; 177  : 	{
; 178  : 		_recording = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 179  : 		F4LeaveCriticalSection( _csect );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 180  : 		return;

	jmp	$LN5@StopRecord
$LN4@StopRecord:

; 181  : 	}
; 182  : 
; 183  : 	// Write out the Callsign/Color list
; 184  : 
; 185  : 	count=ACMIIDTable->GetLastID();

	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?GetLastID@ACMI_Hash@@QAEJXZ		; ACMI_Hash::GetLastID
	mov	DWORD PTR _count$[ebp], eax

; 186  : 	if(count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jle	$LN3@StopRecord

; 187  : 	{
; 188  : 		list=new ACMI_CallRec[count];

	xor	ecx, ecx
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _list$[ebp], eax

; 189  : 		memset(list,0,sizeof(ACMI_CallRec)*count);

	mov	ecx, DWORD PTR _count$[ebp]
	imul	ecx, 20					; 00000014H
	push	ecx
	push	0
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 190  : 
; 191  : 		hdr.type=ACMICallsignList;

	mov	BYTE PTR _hdr$[ebp], 13			; 0000000dH

; 192  : 		hdr.time=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _hdr$[ebp+1], xmm0

; 193  : 		fwrite(&hdr,sizeof(ACMIRecHeader),1,_fd);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	5
	lea	edx, DWORD PTR _hdr$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 194  : 
; 195  : 		fwrite(&count,sizeof(long),1,_fd);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	4
	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 196  : 
; 197  : 		i=ACMIIDTable->GetFirst(&rec,&idx);

	lea	eax, DWORD PTR _idx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?GetFirst@ACMI_Hash@@QAEJPAPAVACMI_HASHNODE@@PAK@Z ; ACMI_Hash::GetFirst
	mov	DWORD PTR _i$[ebp], eax
$LN2@StopRecord:

; 198  : 		while(rec && i >=0 && i < count)

	cmp	DWORD PTR _rec$[ebp], 0
	je	SHORT $LN1@StopRecord
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN1@StopRecord
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@StopRecord

; 199  : 		{
; 200  : 			strncpy(list[i].label,rec->label,15);

	push	15					; 0000000fH
	mov	eax, DWORD PTR _rec$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 201  : 			list[i].teamColor=rec->color;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _rec$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+edx+16], ecx

; 202  : 
; 203  : 			i=ACMIIDTable->GetNext(&rec,&idx);

	lea	edx, DWORD PTR _idx$[ebp]
	push	edx
	lea	eax, DWORD PTR _rec$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?GetNext@ACMI_Hash@@QAEJPAPAVACMI_HASHNODE@@PAK@Z ; ACMI_Hash::GetNext
	mov	DWORD PTR _i$[ebp], eax

; 204  : 		}

	jmp	SHORT $LN2@StopRecord
$LN1@StopRecord:

; 205  : 		fwrite(list,sizeof(ACMI_CallRec)*count,1,_fd);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	1
	mov	eax, DWORD PTR _count$[ebp]
	imul	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
$LN3@StopRecord:

; 206  : 	}
; 207  : 
; 208  : 	fclose( _fd );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fclose
	add	esp, 4

; 209  : 	_fd = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 210  : 	_recording = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 211  : 
; 212  : 	CleanupACMIIDTable();

	call	?CleanupACMIIDTable@@YAXXZ		; CleanupACMIIDTable

; 213  : 
; 214  : 	F4LeaveCriticalSection( _csect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 215  : 
; 216  : 	MonoPrint( "ACMI Stopped Recording\n" );

	push	OFFSET ??_C@_0BI@CNKPCEA@ACMI?5Stopped?5Recording?6?$AA@
	call	_MonoPrint
	add	esp, 4
$LN5@StopRecord:

; 217  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StopRecording@ACMIRecorder@@QAEXXZ ENDP		; ACMIRecorder::StopRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_fp$ = -276						; size = 4
_y$ = -272						; size = 4
_this$ = -268						; size = 4
_fname$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
?StartRecording@ACMIRecorder@@QAEXXZ PROC		; ACMIRecorder::StartRecording
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 	char fname[MAX_PATH];
; 114  : 	int y;
; 115  : 	FILE *fp;
; 116  : 
; 117  : 	InitACMIIDTable();

	call	?InitACMIIDTable@@YAXXZ			; InitACMIIDTable

; 118  : 
; 119  : 	// init the display string
; 120  : 	strcpy( gAcmiStr, "----------" );

	push	OFFSET ??_C@_0L@BMPAELGO@?9?9?9?9?9?9?9?9?9?9?$AA@
	push	OFFSET ?gAcmiStr@@3PADA			; gAcmiStr
	call	_strcpy
	add	esp, 8

; 121  : 
; 122  : 	// if we're hit a write error, no more recording...
; 123  : 	if ( gACMIRecError == TRUE )

	cmp	DWORD PTR ?gACMIRecError@@3HA, 1	; gACMIRecError
	jne	SHORT $LN7@StartRecor

; 124  : 		return;

	jmp	$LN8@StartRecor
$LN7@StartRecor:

; 125  : 
; 126  : 	// set our max file size now
; 127  : 	_maxBytesToWrite = 1000000.0f * PlayerOptions.ACMIFileSize;

	cvtsi2ss xmm0, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+32
	mulss	xmm0, DWORD PTR __real@49742400
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 128  : 
; 129  : 	// find a suitable name for flight file
; 130  : 	for ( y = 0; y < 10000; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN6@StartRecor
$LN5@StartRecor:
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx
$LN6@StartRecor:
	cmp	DWORD PTR _y$[ebp], 10000		; 00002710H
	jge	SHORT $LN4@StartRecor

; 131  : 	{
; 132  : 		sprintf( fname, "acmibin\\acmi%04d.flt", y );

	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@LCEBFDCK@acmibin?2acmi?$CF04d?4flt?$AA@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 133  : 
; 134  : 		fp = fopen( fname, "r" );

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 135  : 		if ( !fp )

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN3@StartRecor

; 136  : 		{
; 137  : 			break;

	jmp	SHORT $LN4@StartRecor

; 138  : 		}
; 139  : 		else

	jmp	SHORT $LN2@StartRecor
$LN3@StartRecor:

; 140  : 		{
; 141  : 			fclose( fp );

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4
$LN2@StartRecor:

; 142  : 		}
; 143  : 	}

	jmp	SHORT $LN5@StartRecor
$LN4@StartRecor:

; 144  : 
; 145  : 	_fd = fopen( fname, "wb" );

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 146  : 
; 147  : 	if (_fd)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN1@StartRecor

; 148  : 	{
; 149  : 		// initialize the bytes written
; 150  : 		_bytesWritten = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+12], xmm0

; 151  : 
; 152  : 		// this is where a call to simdriver needs to go to initialize
; 153  : 		// objects
; 154  : 		SimDriver.InitACMIRecord();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?InitACMIRecord@SimulationDriver@@QAEXXZ ; SimulationDriver::InitACMIRecord

; 155  : 
; 156  : 		_recording = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 157  : 
; 158  : 		MonoPrint( "ACMI Recording, File Size = %f\n", _maxBytesToWrite );

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CA@KKCEGHMH@ACMI?5Recording?0?5File?5Size?5?$DN?5?$CFf?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH
$LN1@StartRecor:
$LN8@StartRecor:

; 159  : 	}
; 160  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?StartRecording@ACMIRecorder@@QAEXXZ ENDP		; ACMIRecorder::StartRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ACMIRecorder@@QAE@XZ PROC				; ACMIRecorder::~ACMIRecorder
; _this$ = ecx

; 99   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 	if ( _fd )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@ACMIRecord

; 101  : 		fclose( _fd );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fclose
	add	esp, 4
$LN1@ACMIRecord:

; 102  : 	_fd = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 103  : 	F4DestroyCriticalSection(_csect);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_F4DestroyCriticalSection
	add	esp, 4

; 104  : 	_csect = NULL; // JB 010108

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1ACMIRecorder@@QAE@XZ ENDP				; ACMIRecorder::~ACMIRecorder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\acmirec.cpp
_TEXT	SEGMENT
_handle$ = -592						; size = 4
_this$ = -588						; size = 4
_FindFileData$ = -584					; size = 320
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
??0ACMIRecorder@@QAE@XZ PROC				; ACMIRecorder::ACMIRecorder
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 	_fd = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 45   : 	_csect = F4CreateCriticalSection("acmi");

	push	OFFSET ??_C@_04EACMIGGP@acmi?$AA@
	call	_F4CreateCriticalSection
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 46   : 	_recording = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 47   : 
; 48   : 	// edg: We Need to get this from player options!!!!
; 49   : 	// at the moment there doesn't seem to be a value for this in the class
; 50   : 	// default to 5 meg
; 51   : 	_maxBytesToWrite = (float)PlayerOptions.AcmiFileSize()*1024*1024;

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?AcmiFileSize@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::AcmiFileSize
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@44800000
	mulss	xmm0, DWORD PTR __real@44800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 52   : 
; 53   : // OW BC
; 54   : #if 1
; 55   : 	HANDLE handle = INVALID_HANDLE_VALUE;

	mov	DWORD PTR _handle$[ebp], -1

; 56   : 	WIN32_FIND_DATA FindFileData; 
; 57   : 	char	path[MAX_PATH] = "";

	mov	cl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _path$[ebp], cl
	push	259					; 00000103H
	push	0
	lea	edx, DWORD PTR _path$[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 58   : 
; 59   : 	handle = FindFirstFile("acmibin\\*.flt", &FindFileData);

	lea	eax, DWORD PTR _FindFileData$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@NJBINIAI@acmibin?2?$CK?4flt?$AA@
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	DWORD PTR _handle$[ebp], eax

; 60   : 
; 61   : 	if(handle != INVALID_HANDLE_VALUE) {

	cmp	DWORD PTR _handle$[ebp], -1
	je	$LN3@ACMIRecord

; 62   : 		strcpy(path, "acmibin\\");

	push	OFFSET ??_C@_08DIILMCIP@acmibin?2?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 63   : 		strcat(path, FindFileData.cFileName);

	lea	edx, DWORD PTR _FindFileData$[ebp+44]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 64   : 		DeleteFile(path);

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	DWORD PTR __imp__DeleteFileA@4
$LN2@ACMIRecord:

; 65   : 
; 66   : 		while(FindNextFile(handle,  &FindFileData)) {

	lea	edx, DWORD PTR _FindFileData$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	DWORD PTR __imp__FindNextFileA@8
	test	eax, eax
	je	SHORT $LN1@ACMIRecord

; 67   : 			strcpy(path, "acmibin\\");

	push	OFFSET ??_C@_08DIILMCIP@acmibin?2?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 68   : 			strcat(path, FindFileData.cFileName);

	lea	edx, DWORD PTR _FindFileData$[ebp+44]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 69   : 			DeleteFile(path);

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	DWORD PTR __imp__DeleteFileA@4

; 70   : 		}

	jmp	SHORT $LN2@ACMIRecord
$LN1@ACMIRecord:

; 71   : 		FindClose(handle);

	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	DWORD PTR __imp__FindClose@4
$LN3@ACMIRecord:

; 72   : 	}
; 73   : #else
; 74   : 	HANDLE handle = INVALID_HANDLE_VALUE;
; 75   : 	LPWIN32_FIND_DATA lpFindFileData = NULL; 
; 76   : 	char	path[MAX_PATH] = "";
; 77   : 
; 78   : 	handle = FindFirstFile("acmibin\\*.flt", lpFindFileData);
; 79   : 
; 80   : 	if(handle != INVALID_HANDLE_VALUE) {
; 81   : 		strcpy(path, "acmibin\\");
; 82   : 		strcat(path, lpFindFileData->cFileName);
; 83   : 		DeleteFile(path);
; 84   : 
; 85   : 		while(FindNextFile(handle,  lpFindFileData)) {
; 86   : 			strcpy(path, "acmibin\\");
; 87   : 			strcat(path, lpFindFileData->cFileName);
; 88   : 			DeleteFile(path);
; 89   : 		}
; 90   : 		FindClose(handle);
; 91   : 	}
; 92   : #endif
; 93   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??0ACMIRecorder@@QAE@XZ ENDP				; ACMIRecorder::ACMIRecorder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmihash.h
;	COMDAT ?GetLastID@ACMI_Hash@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastID@ACMI_Hash@@QAEJXZ PROC			; ACMI_Hash::GetLastID, COMDAT
; _this$ = ecx

; 45   : 		long GetLastID() { return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastID@ACMI_Hash@@QAEJXZ ENDP			; ACMI_Hash::GetLastID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
