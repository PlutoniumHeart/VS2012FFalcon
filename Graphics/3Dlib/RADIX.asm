; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\Graphics\3Dlib\RADIX.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RadixReset
PUBLIC	_RadixSortAscending
PUBLIC	_RadixSortDescending
PUBLIC	_RadixFindFirst
PUBLIC	_RadixRFindFirst
PUBLIC	_RadixFindNext
PUBLIC	_RadixRFindNext
PUBLIC	_RadixRelink
PUBLIC	_RadixRRelink
_BSS	SEGMENT
_sortTable DD	0200H DUP (?)
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixRRelink
_TEXT	SEGMENT
_head$ = -12						; size = 4
_tail$ = -8						; size = 4
_scanh$ = -4						; size = 4
_RadixRRelink PROC					; COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 81   : 	radix_sort_t **scanh;
; 82   : 	radix_sort_t *head,*tail;
; 83   : 
; 84   : 	scanh = RadixRFindFirst(sortTable+255);

	push	OFFSET _sortTable+1020
	call	_RadixRFindFirst
	add	esp, 4
	mov	DWORD PTR _scanh$[ebp], eax

; 85   : 	head = scanh[0];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _scanh$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _head$[ebp], edx

; 86   : 	scanh[0] = 0;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _scanh$[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 87   : 	tail = scanh[256];

	mov	edx, 4
	shl	edx, 8
	mov	eax, DWORD PTR _scanh$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _tail$[ebp], ecx

; 88   : 
; 89   : 	scanh = RadixRFindNext(scanh);

	mov	edx, DWORD PTR _scanh$[ebp]
	push	edx
	call	_RadixRFindNext
	add	esp, 4
	mov	DWORD PTR _scanh$[ebp], eax
$LN2@RadixRReli:

; 90   : 	while(scanh != 0UL)

	cmp	DWORD PTR _scanh$[ebp], 0
	je	SHORT $LN1@RadixRReli

; 91   : 	{
; 92   : 		tail->pNext = scanh[0];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _tail$[ebp]
	mov	edx, DWORD PTR _scanh$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], eax

; 93   : 		tail = scanh[256];

	mov	ecx, 4
	shl	ecx, 8
	mov	edx, DWORD PTR _scanh$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _tail$[ebp], eax

; 94   : 		scanh[0] = 0;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _scanh$[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 95   : 		scanh = RadixRFindNext(scanh);

	mov	eax, DWORD PTR _scanh$[ebp]
	push	eax
	call	_RadixRFindNext
	add	esp, 4
	mov	DWORD PTR _scanh$[ebp], eax

; 96   : 	}

	jmp	SHORT $LN2@RadixRReli
$LN1@RadixRReli:

; 97   : 
; 98   : 	return(head);

	mov	eax, DWORD PTR _head$[ebp]

; 99   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RadixRRelink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixRelink
_TEXT	SEGMENT
_head$ = -12						; size = 4
_tail$ = -8						; size = 4
_scanh$ = -4						; size = 4
_RadixRelink PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 59   : 	radix_sort_t **scanh;
; 60   : 	radix_sort_t *head,*tail;
; 61   : 
; 62   : 	scanh = RadixFindFirst(sortTable);

	push	OFFSET _sortTable
	call	_RadixFindFirst
	add	esp, 4
	mov	DWORD PTR _scanh$[ebp], eax

; 63   : 	head = scanh[0];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _scanh$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _head$[ebp], edx

; 64   : 	scanh[0] = 0;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _scanh$[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 65   : 	tail = scanh[256];

	mov	edx, 4
	shl	edx, 8
	mov	eax, DWORD PTR _scanh$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _tail$[ebp], ecx

; 66   : 
; 67   : 	scanh = RadixFindNext(scanh);

	mov	edx, DWORD PTR _scanh$[ebp]
	push	edx
	call	_RadixFindNext
	add	esp, 4
	mov	DWORD PTR _scanh$[ebp], eax
$LN2@RadixRelin:

; 68   : 	while(scanh != 0UL)

	cmp	DWORD PTR _scanh$[ebp], 0
	je	SHORT $LN1@RadixRelin

; 69   : 	{
; 70   : 		tail->pNext = scanh[0];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _tail$[ebp]
	mov	edx, DWORD PTR _scanh$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], eax

; 71   : 		scanh[0] = 0;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _scanh$[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 72   : 		tail = scanh[256];

	mov	eax, 4
	shl	eax, 8
	mov	ecx, DWORD PTR _scanh$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _tail$[ebp], edx

; 73   : 		scanh = RadixFindNext(scanh);

	mov	eax, DWORD PTR _scanh$[ebp]
	push	eax
	call	_RadixFindNext
	add	esp, 4
	mov	DWORD PTR _scanh$[ebp], eax

; 74   : 	}

	jmp	SHORT $LN2@RadixRelin
$LN1@RadixRelin:

; 75   : 
; 76   : 	return(head);

	mov	eax, DWORD PTR _head$[ebp]

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RadixRelink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixRFindNext
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_RadixRFindNext PROC					; COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
$LN4@RadixRFind:

; 47   : 	do
; 48   : 	{
; 49   : 		ptr--;

	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 50   : 		if((unsigned int)ptr < (unsigned int)sortTable) return 0UL;

	cmp	DWORD PTR _ptr$[ebp], OFFSET _sortTable
	jae	SHORT $LN3@RadixRFind
	xor	eax, eax
	jmp	SHORT $LN5@RadixRFind
$LN3@RadixRFind:

; 51   : 	}
; 52   :  	while(0UL == *ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@RadixRFind

; 53   : 
; 54   : 	return(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN5@RadixRFind:

; 55   : }

	pop	ebp
	ret	0
_RadixRFindNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixFindNext
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_RadixFindNext PROC					; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
$LN4@RadixFindN:

; 35   : 	do
; 36   : 	{
; 37   : 		ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 38   : 		if((unsigned int)ptr > (unsigned int)(sortTable+255)) return 0UL;

	cmp	DWORD PTR _ptr$[ebp], OFFSET _sortTable+1020
	jbe	SHORT $LN3@RadixFindN
	xor	eax, eax
	jmp	SHORT $LN5@RadixFindN
$LN3@RadixFindN:

; 39   : 	}
; 40   :  	while(0UL == *ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@RadixFindN

; 41   : 
; 42   : 	return(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN5@RadixFindN:

; 43   : }

	pop	ebp
	ret	0
_RadixFindNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixRFindFirst
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_RadixRFindFirst PROC					; COMDAT

; 23   : {

	push	ebp
	mov	ebp, esp
$LN3@RadixRFind:

; 24   :  	while(0UL == *ptr)

	mov	eax, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@RadixRFind

; 25   : 	{
; 26   : 	 	ptr--;

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _ptr$[ebp], ecx

; 27   : 		if((unsigned int)ptr < (unsigned int)sortTable) return 0UL;

	cmp	DWORD PTR _ptr$[ebp], OFFSET _sortTable
	jae	SHORT $LN1@RadixRFind
	xor	eax, eax
	jmp	SHORT $LN4@RadixRFind
$LN1@RadixRFind:

; 28   : 	}

	jmp	SHORT $LN3@RadixRFind
$LN2@RadixRFind:

; 29   : 
; 30   : 	return(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN4@RadixRFind:

; 31   : }

	pop	ebp
	ret	0
_RadixRFindFirst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixFindFirst
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_RadixFindFirst PROC					; COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp
$LN3@RadixFindF:

; 13   :  	while(0UL == *ptr)

	mov	eax, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@RadixFindF

; 14   : 	{
; 15   : 	 	ptr++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptr$[ebp], ecx

; 16   : 		if((unsigned int)ptr > (unsigned int)(sortTable+255)) return 0UL;

	cmp	DWORD PTR _ptr$[ebp], OFFSET _sortTable+1020
	jbe	SHORT $LN1@RadixFindF
	xor	eax, eax
	jmp	SHORT $LN4@RadixFindF
$LN1@RadixFindF:

; 17   : 	}

	jmp	SHORT $LN3@RadixFindF
$LN2@RadixFindF:

; 18   : 
; 19   : 	return(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN4@RadixFindF:

; 20   : }

	pop	ebp
	ret	0
_RadixFindFirst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
_TEXT	SEGMENT
_nxt$ = -16						; size = 4
_byteval$ = -12						; size = 4
_index$ = -8						; size = 4
_ptr$ = -4						; size = 4
_iptr$ = 8						; size = 4
_offset$ = 12						; size = 4
_RadixSortDescending PROC

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 154  : 	radix_sort_t *ptr,*nxt;
; 155  : 	unsigned char *byteval;
; 156  : 	int index;
; 157  : 
; 158  : 	ptr = iptr;

	mov	eax, DWORD PTR _iptr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 159  : 
; 160  : 	if(ptr->pNext == 0UL) return ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN16@RadixSortD
	mov	eax, DWORD PTR _ptr$[ebp]
	jmp	$LN18@RadixSortD
$LN16@RadixSortD:

; 161  : 
; 162  : 	while(ptr != 0UL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN15@RadixSortD

; 163  : 	{
; 164  : 		byteval = ((unsigned char *)ptr)+offset;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _byteval$[ebp], edx

; 165  : 		index = *byteval;

	mov	eax, DWORD PTR _byteval$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _index$[ebp], ecx

; 166  : 		nxt = ptr->pNext;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _nxt$[ebp], eax

; 167  : 		
; 168  : 		if(0UL == sortTable[index])

	mov	ecx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _sortTable[ecx*4], 0
	jne	SHORT $LN14@RadixSortD

; 169  : 			sortTable[index] = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[edx*4], eax

; 170  : 		else

	jmp	SHORT $LN13@RadixSortD
$LN14@RadixSortD:

; 171  : 			sortTable[index+256]->pNext = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _sortTable[ecx*4+1024]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@RadixSortD:

; 172  : 
; 173  : 		sortTable[index+256] = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[ecx*4+1024], edx

; 174  : 		ptr->pNext = 0UL;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], 0

; 175  : 		ptr = nxt;

	mov	ecx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 176  : 	}

	jmp	SHORT $LN16@RadixSortD
$LN15@RadixSortD:

; 177  : 
; 178  : 	ptr = RadixRRelink();

	call	_RadixRRelink
	mov	DWORD PTR _ptr$[ebp], eax

; 179  : 	offset++;

	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, 1
	mov	DWORD PTR _offset$[ebp], edx
$LN12@RadixSortD:

; 180  : 
; 181  : 	while(ptr != 0UL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN11@RadixSortD

; 182  : 	{
; 183  : 		byteval = ((unsigned char *)ptr)+offset;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _byteval$[ebp], eax

; 184  : 		index = *byteval;

	mov	ecx, DWORD PTR _byteval$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _index$[ebp], edx

; 185  : 		nxt = ptr->pNext;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nxt$[ebp], ecx

; 186  : 
; 187  : 		if(0UL == sortTable[index])

	mov	edx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _sortTable[edx*4], 0
	jne	SHORT $LN10@RadixSortD

; 188  : 			sortTable[index] = ptr;

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[eax*4], ecx

; 189  : 		else

	jmp	SHORT $LN9@RadixSortD
$LN10@RadixSortD:

; 190  : 			sortTable[index+256]->pNext = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _sortTable[edx*4+1024]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx
$LN9@RadixSortD:

; 191  : 
; 192  : 		sortTable[index+256] = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[edx*4+1024], eax

; 193  : 		ptr->pNext = 0UL;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], 0

; 194  : 		ptr = nxt;

	mov	edx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 195  : 	}

	jmp	SHORT $LN12@RadixSortD
$LN11@RadixSortD:

; 196  : 
; 197  : 	ptr = RadixRRelink();

	call	_RadixRRelink
	mov	DWORD PTR _ptr$[ebp], eax

; 198  : 
; 199  : 	offset++;

	mov	eax, DWORD PTR _offset$[ebp]
	add	eax, 1
	mov	DWORD PTR _offset$[ebp], eax
$LN8@RadixSortD:

; 200  : 
; 201  : 	while(ptr != 0UL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN7@RadixSortD

; 202  : 	{
; 203  : 		byteval = ((unsigned char *)ptr)+offset;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _byteval$[ebp], ecx

; 204  : 		index = *byteval;

	mov	edx, DWORD PTR _byteval$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _index$[ebp], eax

; 205  : 		nxt = ptr->pNext;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _nxt$[ebp], edx

; 206  : 
; 207  : 		if(0UL == sortTable[index])

	mov	eax, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _sortTable[eax*4], 0
	jne	SHORT $LN6@RadixSortD

; 208  : 			sortTable[index] = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[ecx*4], edx

; 209  : 		else

	jmp	SHORT $LN5@RadixSortD
$LN6@RadixSortD:

; 210  : 			sortTable[index+256]->pNext = ptr;

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _sortTable[eax*4+1024]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx
$LN5@RadixSortD:

; 211  : 
; 212  : 		sortTable[index+256] = ptr;

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[eax*4+1024], ecx

; 213  : 		ptr->pNext = 0UL;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], 0

; 214  : 		ptr = nxt;

	mov	eax, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 215  : 	}

	jmp	SHORT $LN8@RadixSortD
$LN7@RadixSortD:

; 216  : 
; 217  : 	ptr = RadixRRelink();

	call	_RadixRRelink
	mov	DWORD PTR _ptr$[ebp], eax

; 218  : 
; 219  : 	offset++;

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _offset$[ebp], ecx
$LN4@RadixSortD:

; 220  : 
; 221  : 	while(ptr != 0UL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN3@RadixSortD

; 222  : 	{
; 223  : 		byteval = ((unsigned char *)ptr)+offset;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _byteval$[ebp], edx

; 224  : 		index = *byteval;

	mov	eax, DWORD PTR _byteval$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _index$[ebp], ecx

; 225  : 		nxt = ptr->pNext;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _nxt$[ebp], eax

; 226  : 
; 227  : 		if(0UL == sortTable[index])

	mov	ecx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _sortTable[ecx*4], 0
	jne	SHORT $LN2@RadixSortD

; 228  : 			sortTable[index] = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[edx*4], eax

; 229  : 		else

	jmp	SHORT $LN1@RadixSortD
$LN2@RadixSortD:

; 230  : 			sortTable[index+256]->pNext = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _sortTable[ecx*4+1024]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@RadixSortD:

; 231  : 
; 232  : 		sortTable[index+256] = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[ecx*4+1024], edx

; 233  : 		ptr->pNext = 0UL;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], 0

; 234  : 		ptr = nxt;

	mov	ecx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 235  : 	}

	jmp	SHORT $LN4@RadixSortD
$LN3@RadixSortD:

; 236  : 
; 237  : 	ptr = RadixRRelink();

	call	_RadixRRelink
	mov	DWORD PTR _ptr$[ebp], eax

; 238  : 
; 239  : 	return(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN18@RadixSortD:

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RadixSortDescending ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
_TEXT	SEGMENT
_nxt$ = -16						; size = 4
_byteval$ = -12						; size = 4
_index$ = -8						; size = 4
_ptr$ = -4						; size = 4
_iptr$ = 8						; size = 4
_offset$ = 12						; size = 4
_RadixSortAscending PROC

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 103  : 	radix_sort_t *ptr,*nxt;
; 104  : 	unsigned char *byteval;
; 105  : 	int index;
; 106  : 
; 107  : 	ptr = iptr;

	mov	eax, DWORD PTR _iptr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 108  : 
; 109  : 	if(ptr->pNext == 0UL) return ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN8@RadixSortA
	mov	eax, DWORD PTR _ptr$[ebp]
	jmp	$LN10@RadixSortA
$LN8@RadixSortA:

; 110  : 
; 111  : 	while(ptr != 0UL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN7@RadixSortA

; 112  : 	{
; 113  : 		byteval = ((unsigned char *)ptr)+offset;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _byteval$[ebp], edx

; 114  : 		index = *byteval;

	mov	eax, DWORD PTR _byteval$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _index$[ebp], ecx

; 115  : 		nxt = ptr->pNext;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _nxt$[ebp], eax

; 116  : 
; 117  : 		if(0UL == sortTable[index])

	mov	ecx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _sortTable[ecx*4], 0
	jne	SHORT $LN6@RadixSortA

; 118  : 			sortTable[index] = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[edx*4], eax

; 119  : 		else

	jmp	SHORT $LN5@RadixSortA
$LN6@RadixSortA:

; 120  : 			sortTable[index+256]->pNext = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _sortTable[ecx*4+1024]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN5@RadixSortA:

; 121  : 
; 122  : 		sortTable[index+256] = ptr;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[ecx*4+1024], edx

; 123  : 		ptr->pNext = 0UL;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], 0

; 124  : 		ptr = nxt;

	mov	ecx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 125  : 	}

	jmp	SHORT $LN8@RadixSortA
$LN7@RadixSortA:

; 126  : 
; 127  : 	ptr = RadixRelink();

	call	_RadixRelink
	mov	DWORD PTR _ptr$[ebp], eax

; 128  : 
; 129  : 	offset++;

	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, 1
	mov	DWORD PTR _offset$[ebp], edx
$LN4@RadixSortA:

; 130  : 
; 131  : 	while(ptr != 0UL )

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN3@RadixSortA

; 132  : 	{
; 133  : 		byteval = ((unsigned char *)ptr)+offset;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _byteval$[ebp], eax

; 134  : 		index = *byteval;

	mov	ecx, DWORD PTR _byteval$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _index$[ebp], edx

; 135  : 		nxt = ptr->pNext;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nxt$[ebp], ecx

; 136  : 
; 137  : 		if(0UL == sortTable[index])

	mov	edx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _sortTable[edx*4], 0
	jne	SHORT $LN2@RadixSortA

; 138  : 			sortTable[index] = ptr;

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[eax*4], ecx

; 139  : 		else

	jmp	SHORT $LN1@RadixSortA
$LN2@RadixSortA:

; 140  : 			sortTable[index+256]->pNext = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _sortTable[edx*4+1024]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@RadixSortA:

; 141  : 
; 142  : 		sortTable[index+256] = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sortTable[edx*4+1024], eax

; 143  : 		ptr->pNext = 0UL;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], 0

; 144  : 		ptr = nxt;

	mov	edx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 145  : 	}

	jmp	SHORT $LN4@RadixSortA
$LN3@RadixSortA:

; 146  : 
; 147  : 	ptr = RadixRelink();

	call	_RadixRelink
	mov	DWORD PTR _ptr$[ebp], eax

; 148  : 
; 149  : 	return(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN10@RadixSortA:

; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RadixSortAscending ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\3dlib\radix.c
;	COMDAT _RadixReset
_TEXT	SEGMENT
_i$ = -4						; size = 4
_RadixReset PROC					; COMDAT

; 6    : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7    : 	int i;
; 8    : 	for(i = 255; i >= 0; i--) sortTable[i] = 0UL;

	mov	DWORD PTR _i$[ebp], 255			; 000000ffH
	jmp	SHORT $LN3@RadixReset
$LN2@RadixReset:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@RadixReset:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN4@RadixReset
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sortTable[ecx*4], 0
	jmp	SHORT $LN2@RadixReset
$LN4@RadixReset:

; 9    : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RadixReset ENDP
_TEXT	ENDS
END
