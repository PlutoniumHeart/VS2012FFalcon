; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\Graphics\Renderer\OTW.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?PERSPECTIVE_RANGE@RenderOTW@@2MB		; RenderOTW::PERSPECTIVE_RANGE
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?NVG_TUNNEL_PERCENT@RenderOTW@@2MB		; RenderOTW::NVG_TUNNEL_PERCENT
PUBLIC	?DETAIL_RANGE@RenderOTW@@2MB			; RenderOTW::DETAIL_RANGE
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
_DATA	SEGMENT
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_DATA	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
CONST	SEGMENT
?PERSPECTIVE_RANGE@RenderOTW@@2MB DD 045bb8000r	; 6000	; RenderOTW::PERSPECTIVE_RANGE
?NVG_TUNNEL_PERCENT@RenderOTW@@2MB DD 03e4ccccdr ; 0.2	; RenderOTW::NVG_TUNNEL_PERCENT
?DETAIL_RANGE@RenderOTW@@2MB DD 045fa0000r	; 8000	; RenderOTW::DETAIL_RANGE
_big	DD	03f99999ar			; 1.2
_ltl	DD	03f000000r			; 0.5
_PercentBlend DD 03dcccccdr			; 0.1
_NEAR_CLIP DD	03f800000r			; 1
_Q_SCALE DD	03a51b717r			; 0.0008
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_atanf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?GetNVGmode@CTimeOfDay@@QAEHXZ			; CTimeOfDay::GetNVGmode
PUBLIC	?GetRainColor@CTimeOfDay@@QAEKXZ		; CTimeOfDay::GetRainColor
PUBLIC	?GetSnowColor@CTimeOfDay@@QAEKXZ		; CTimeOfDay::GetSnowColor
PUBLIC	?GetLightningColor@CTimeOfDay@@QAE?AUTcolor@@XZ	; CTimeOfDay::GetLightningColor
PUBLIC	?LastNearTexLOD@TMap@@QAEHXZ			; TMap::LastNearTexLOD
PUBLIC	?LastFarTexLOD@TMap@@QAEHXZ			; TMap::LastFarTexLOD
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetDisplayDevice@ImageBuffer@@QAEPAVDisplayDevice@@XZ ; ImageBuffer::GetDisplayDevice
PUBLIC	?IsHardware@DisplayDevice@@QAEHXZ		; DisplayDevice::IsHardware
PUBLIC	?GetMaxPostRange@TBlockList@@QAEHXZ		; TBlockList::GetMaxPostRange
PUBLIC	?GetMinLOD@TViewPoint@@QAEHXZ			; TViewPoint::GetMinLOD
PUBLIC	?GetMaxLOD@TViewPoint@@QAEHXZ			; TViewPoint::GetMaxLOD
PUBLIC	?GetMaxRange@TViewPoint@@QAEMXZ			; TViewPoint::GetMaxRange
PUBLIC	?GetMaxPostRange@TViewPoint@@QAEHH@Z		; TViewPoint::GetMaxPostRange
PUBLIC	?GetPost@TViewPoint@@QAEPAUTpost@@HHH@Z		; TViewPoint::GetPost
PUBLIC	?Z@TViewPoint@@QAEMXZ				; TViewPoint::Z
PUBLIC	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z		; TViewPoint::GetPos
PUBLIC	?GetNextDrawDistance@ObjectDisplayList@@QAEMXZ	; ObjectDisplayList::GetNextDrawDistance
PUBLIC	?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInTerrain
PUBLIC	?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsBelowClouds
PUBLIC	?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ	; RViewPoint::Clouds
PUBLIC	?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInClouds
PUBLIC	?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveClouds
PUBLIC	?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveRoof
PUBLIC	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z	; VirtualDisplay::viewportXtoPixel
PUBLIC	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z	; VirtualDisplay::viewportYtoPixel
PUBLIC	?Cleanup@Render3D@@UAEXXZ			; Render3D::Cleanup
PUBLIC	?SetFar@Render3D@@QAEXM@Z			; Render3D::SetFar
PUBLIC	?GetFOV@Render3D@@QAEMXZ			; Render3D::GetFOV
PUBLIC	?Setup@RenderOTW@@UAEXPAVImageBuffer@@PAVRViewPoint@@@Z ; RenderOTW::Setup
PUBLIC	?Cleanup@RenderOTW@@UAEXXZ			; RenderOTW::Cleanup
PUBLIC	?StartDraw@RenderOTW@@UAEXXZ			; RenderOTW::StartDraw
PUBLIC	?EndDraw@RenderOTW@@UAEXXZ			; RenderOTW::EndDraw
PUBLIC	?SetTerrainTextureLevel@RenderOTW@@QAEXH@Z	; RenderOTW::SetTerrainTextureLevel
PUBLIC	?SetHazeMode@RenderOTW@@QAEXH@Z			; RenderOTW::SetHazeMode
PUBLIC	?SetDitheringMode@RenderOTW@@QAEXH@Z		; RenderOTW::SetDitheringMode
PUBLIC	?SetFilteringMode@RenderOTW@@QAEXH@Z		; RenderOTW::SetFilteringMode
PUBLIC	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z		; RenderOTW::GetRangeOnlyFog
PUBLIC	?GetValleyFog@RenderOTW@@QAEMMM@Z		; RenderOTW::GetValleyFog
PUBLIC	?GetFogColor@RenderOTW@@QAEPAUTcolor@@XZ	; RenderOTW::GetFogColor
PUBLIC	?DrawScene@RenderOTW@@QAEXPBUTpoint@@PBUTrotation@@@Z ; RenderOTW::DrawScene
PUBLIC	?PreLoadScene@RenderOTW@@QAEXPBUTpoint@@PBUTrotation@@@Z ; RenderOTW::PreLoadScene
PUBLIC	?SetTunnelPercent@RenderOTW@@QAEXMK@Z		; RenderOTW::SetTunnelPercent
PUBLIC	?PostSceneCloudOcclusion@RenderOTW@@QAEXXZ	; RenderOTW::PostSceneCloudOcclusion
PUBLIC	?DrawTunnelBorder@RenderOTW@@QAEXXZ		; RenderOTW::DrawTunnelBorder
PUBLIC	?SetupStates@RenderOTW@@IAEXXZ			; RenderOTW::SetupStates
PUBLIC	?TransformRun@RenderOTW@@IAEXHHHHH@Z		; RenderOTW::TransformRun
PUBLIC	?ComputeVertexColor@RenderOTW@@MAEXPAUTerrainVertex@@PAUTpost@@MMM@Z ; RenderOTW::ComputeVertexColor
PUBLIC	?PreSceneCloudOcclusion@RenderOTW@@IAEXMK@Z	; RenderOTW::PreSceneCloudOcclusion
PUBLIC	?DrawTerrainRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z ; RenderOTW::DrawTerrainRing
PUBLIC	?DrawConnectorRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z ; RenderOTW::DrawConnectorRing
PUBLIC	?DrawGapFiller@RenderOTW@@IAEXPAUSpanListEntry@@@Z ; RenderOTW::DrawGapFiller
PUBLIC	?DrawGroundAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@@Z ; RenderOTW::DrawGroundAndObjects
PUBLIC	?DrawCloudsAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@0@Z ; RenderOTW::DrawCloudsAndObjects
PUBLIC	?DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z	; RenderOTW::DrawWeather
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDFloat@@YAMXZ				; PRANDFloat
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?ShadowsOn@PlayerOptionsClass@@QAEHXZ		; PlayerOptionsClass::ShadowsOn
PUBLIC	?LinearFog@CDXEngine@@QAEX_N@Z			; CDXEngine::LinearFog
PUBLIC	?FabsF@@YAMM@Z					; FabsF
PUBLIC	?SqrtF@@YAMM@Z					; SqrtF
PUBLIC	?InsideOvercast@RealWeather@@QAE_NXZ		; RealWeather::InsideOvercast
PUBLIC	?UnderOvercast@RealWeather@@QAE_NXZ		; RealWeather::UnderOvercast
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_C@_0M@CFLADCE@Feb?518?52013?$AA@		; `string'
PUBLIC	??_C@_07IANNNNBC@OTW?4cpp?$AA@			; `string'
PUBLIC	??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BP@EILOODAH@Failed?5to?5allocate?5span?5buffer?$AA@ ; `string'
PUBLIC	??_C@_0CN@BENOGLFA@Failed?5to?5allocate?5transformed?5v@ ; `string'
PUBLIC	??_C@_0DC@HNCJDNKO@Failed?5to?5allocate?5transformed?5v@ ; `string'
PUBLIC	??_C@_0DE@HLCDCKBN@Failed?5to?5allocate?5memory?5for?5LO@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3d072b02
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f340000
PUBLIC	__real@3f34fdf4
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3f866666
PUBLIC	__real@3fc90fdb
PUBLIC	__real@40000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
PUBLIC	__real@437fe666
PUBLIC	__real@453b8000
PUBLIC	__real@466a6000
PUBLIC	__real@470ca000
PUBLIC	__real@477fff00
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_exit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_sprintf:PROC
EXTRN	?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z:PROC ; TimeManager::RegisterTimeUpdateCB
EXTRN	?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z:PROC ; TimeManager::ReleaseTimeUpdateCB
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetState@ContextMPR@@QAEXGK@Z:PROC		; ContextMPR::SetState
EXTRN	?EndDraw@ContextMPR@@QAEXXZ:PROC		; ContextMPR::EndDraw
EXTRN	?SelectForegroundColor@ContextMPR@@QAEXH@Z:PROC	; ContextMPR::SelectForegroundColor
EXTRN	?RestoreState@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::RestoreState
EXTRN	?SetZBuffering@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::SetZBuffering
EXTRN	?SetTVmode@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::SetTVmode
EXTRN	?SetIRmode@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::SetIRmode
EXTRN	?DrawPrimitive@ContextMPR@@QAEXHGGPAUMPRVtx_t@@G@Z:PROC ; ContextMPR::DrawPrimitive
EXTRN	?WaitUpdates@ObjectLOD@@SAXXZ:PROC		; ObjectLOD::WaitUpdates
EXTRN	?SetGreenMode@Drawable2D@@SAXH@Z:PROC		; Drawable2D::SetGreenMode
EXTRN	?SetColorMode@ColorBankClass@@SAXW4ColorMode@1@@Z:PROC ; ColorBankClass::SetColorMode
EXTRN	?GetPost@TBlockList@@QAEPAUTpost@@HH@Z:PROC	; TBlockList::GetPost
EXTRN	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z:PROC ; ObjectDisplayList::DrawBeyond
EXTRN	?PreLoad@ObjectDisplayList@@QAEXPAVRenderOTW@@@Z:PROC ; ObjectDisplayList::PreLoad
EXTRN	?ResetObjectTraversal@RViewPoint@@QAEXXZ:PROC	; RViewPoint::ResetObjectTraversal
EXTRN	?GetContainingList@RViewPoint@@QAEHM@Z:PROC	; RViewPoint::GetContainingList
EXTRN	?SetFog@StateStackClass@@SAXMPAUPcolor@@@Z:PROC	; StateStackClass::SetFog
EXTRN	?GetViewport@VirtualDisplay@@QAEXPAM000@Z:PROC	; VirtualDisplay::GetViewport
EXTRN	?Cleanup@Render2D@@UAEXXZ:PROC			; Render2D::Cleanup
EXTRN	?SetClipFlags@Render2D@@QAEXPAUTwoDVertex@@@Z:PROC ; Render2D::SetClipFlags
EXTRN	?ClipAndDraw2DFan@Render2D@@QAEXPAPAUTwoDVertex@@I_N@Z:PROC ; Render2D::ClipAndDraw2DFan
EXTRN	?Setup@Render3D@@UAEXPAVImageBuffer@@@Z:PROC	; Render3D::Setup
EXTRN	?StartDraw@Render3D@@UAEXXZ:PROC		; Render3D::StartDraw
EXTRN	?SetFOV@Render3D@@QAEXMM@Z:PROC			; Render3D::SetFOV
EXTRN	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; Render3D::SetCamera
EXTRN	?SetObjectTextureState@Render3D@@QAEXH@Z:PROC	; Render3D::SetObjectTextureState
EXTRN	?SetRoofMode@RenderOTW@@QAEXH@Z:PROC		; RenderOTW::SetRoofMode
EXTRN	?ComputeBounds@RenderOTW@@IAEXXZ:PROC		; RenderOTW::ComputeBounds
EXTRN	?BuildRingList@RenderOTW@@IAEXXZ:PROC		; RenderOTW::BuildRingList
EXTRN	?ClipHorizontalSectors@RenderOTW@@IAEXXZ:PROC	; RenderOTW::ClipHorizontalSectors
EXTRN	?ClipVerticalSectors@RenderOTW@@IAEXXZ:PROC	; RenderOTW::ClipVerticalSectors
EXTRN	?BuildCornerSet@RenderOTW@@IAEXXZ:PROC		; RenderOTW::BuildCornerSet
EXTRN	?TrimCornerSet@RenderOTW@@IAEXXZ:PROC		; RenderOTW::TrimCornerSet
EXTRN	?BuildVertexSet@RenderOTW@@IAEXXZ:PROC		; RenderOTW::BuildVertexSet
EXTRN	?TransformVertexSet@RenderOTW@@IAEXXZ:PROC	; RenderOTW::TransformVertexSet
EXTRN	?DrawSky@RenderOTW@@IAEHXZ:PROC			; RenderOTW::DrawSky
EXTRN	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z:PROC	; RenderOTW::DrawTerrainSquare
EXTRN	?DrawUpConnector@RenderOTW@@IAEXHHH@Z:PROC	; RenderOTW::DrawUpConnector
EXTRN	?DrawRightConnector@RenderOTW@@IAEXHHH@Z:PROC	; RenderOTW::DrawRightConnector
EXTRN	?DrawDownConnector@RenderOTW@@IAEXHHH@Z:PROC	; RenderOTW::DrawDownConnector
EXTRN	?DrawLeftConnector@RenderOTW@@IAEXHHH@Z:PROC	; RenderOTW::DrawLeftConnector
EXTRN	?TimeUpdateCallback@RenderOTW@@KAXPAX@Z:PROC	; RenderOTW::TimeUpdateCallback
EXTRN	?WaitUpdates@TextureBankClass@@SAXXZ:PROC	; TextureBankClass::WaitUpdates
EXTRN	?DX2D_Reset@CDXEngine@@QAEXXZ:PROC		; CDXEngine::DX2D_Reset
EXTRN	?Setup@RealWeather@@QAEXPAVObjectDisplayList@@0@Z:PROC ; RealWeather::Setup
EXTRN	?SetRenderer@RealWeather@@QAEXPAVRenderOTW@@@Z:PROC ; RealWeather::SetRenderer
EXTRN	?RefreshWeather@RealWeather@@QAEXPAVRenderOTW@@@Z:PROC ; RealWeather::RefreshWeather
EXTRN	?Draw@RealWeather@@QAEXXZ:PROC			; RealWeather::Draw
EXTRN	?SetGreenMode@RealWeather@@QAEXH@Z:PROC		; RealWeather::SetGreenMode
EXTRN	?SetDrawingOrder@RealWeather@@QAEXM@Z:PROC	; RealWeather::SetDrawingOrder
EXTRN	?PS_Exec@DrawableParticleSys@@SAXPAVRenderOTW@@@Z:PROC ; DrawableParticleSys::PS_Exec
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?TheTimeManager@@3VTimeManager@@A:BYTE		; TheTimeManager
EXTRN	?TheTimeOfDay@@3VCTimeOfDay@@A:BYTE		; TheTimeOfDay
EXTRN	?FeetPerPost@@3MA:DWORD				; FeetPerPost
EXTRN	?TheMap@@3VTMap@@A:BYTE				; TheMap
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?DisplayOptions@@3VDisplayOptionsClass@@A:BYTE	; DisplayOptions
EXTRN	?m_LinearFog@CDXEngine@@0_NA:BYTE		; CDXEngine::m_LinearFog
EXTRN	?TheDXEngine@@3VCDXEngine@@A:BYTE		; TheDXEngine
EXTRN	?realWeather@@3PAVRealWeather@@A:DWORD		; realWeather
EXTRN	?g_bFullScreenNVG@@3_NA:BYTE			; g_bFullScreenNVG
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

_OutsidePoints DQ 0dH DUP (?)
_PercentScale DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?VALLEY_HAZE_START_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
_BSS	SEGMENT
?VALLEY_HAZE_START_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB DD 01H DUP (?) ; `RenderOTW::GetValleyFog'::`2'::VALLEY_HAZE_START_RANGE
_BSS	ENDS
;	COMDAT ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA
_BSS	SEGMENT
?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA DD 01H DUP (?) ; `RenderOTW::GetValleyFog'::`2'::$S1
_BSS	ENDS
;	COMDAT ?VALLEY_HAZE_FULL_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
_BSS	SEGMENT
?VALLEY_HAZE_FULL_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB DD 01H DUP (?) ; `RenderOTW::GetValleyFog'::`2'::VALLEY_HAZE_FULL_RANGE
_BSS	ENDS
;	COMDAT ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
_BSS	SEGMENT
?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB DD 01H DUP (?) ; `RenderOTW::DrawWeather'::`17'::TRI2
_BSS	ENDS
;	COMDAT ?$S2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4IA
_BSS	SEGMENT
?$S2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4IA DD 01H DUP (?) ; `RenderOTW::DrawWeather'::`17'::$S2
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@470ca000
CONST	SEGMENT
__real@470ca000 DD 0470ca000r			; 36000
CONST	ENDS
;	COMDAT __real@466a6000
CONST	SEGMENT
__real@466a6000 DD 0466a6000r			; 15000
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@437fe666
CONST	SEGMENT
__real@437fe666 DD 0437fe666r			; 255.9
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3f866666
CONST	SEGMENT
__real@3f866666 DD 03f866666r			; 1.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f34fdf4
CONST	SEGMENT
__real@3f34fdf4 DD 03f34fdf4r			; 0.707
CONST	ENDS
;	COMDAT __real@3f340000
CONST	SEGMENT
__real@3f340000 DD 03f340000r			; 0.703125
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d072b02
CONST	SEGMENT
__real@3d072b02 DD 03d072b02r			; 0.033
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ?TRIX@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
CONST	SEGMENT
?TRIX@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB DD 03c1374bcr ; 0.009 ; `RenderOTW::DrawWeather'::`17'::TRIX
CONST	ENDS
;	COMDAT ?VALLEY_HAZE_MAX@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
CONST	SEGMENT
?VALLEY_HAZE_MAX@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB DD 03f400000r ; 0.75 ; `RenderOTW::GetValleyFog'::`2'::VALLEY_HAZE_MAX
CONST	ENDS
;	COMDAT ?VALLEY_HAZE_TOP@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
CONST	SEGMENT
?VALLEY_HAZE_TOP@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB DD 0447a0000r ; 1000 ; `RenderOTW::GetValleyFog'::`2'::VALLEY_HAZE_TOP
CONST	ENDS
;	COMDAT ??_C@_0DE@HLCDCKBN@Failed?5to?5allocate?5memory?5for?5LO@
CONST	SEGMENT
??_C@_0DE@HLCDCKBN@Failed?5to?5allocate?5memory?5for?5LO@ DB 'Failed to a'
	DB	'llocate memory for LOD step vector array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HNCJDNKO@Failed?5to?5allocate?5transformed?5v@
CONST	SEGMENT
??_C@_0DC@HNCJDNKO@Failed?5to?5allocate?5transformed?5v@ DB 'Failed to al'
	DB	'locate transformed vertex buffer list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BENOGLFA@Failed?5to?5allocate?5transformed?5v@
CONST	SEGMENT
??_C@_0CN@BENOGLFA@Failed?5to?5allocate?5transformed?5v@ DB 'Failed to al'
	DB	'locate transformed vertex buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EILOODAH@Failed?5to?5allocate?5span?5buffer?$AA@
CONST	SEGMENT
??_C@_0BP@EILOODAH@Failed?5to?5allocate?5span?5buffer?$AA@ DB 'Failed to '
	DB	'allocate span buffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@ DB 'Error:  %'
	DB	'0d  %s  %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07IANNNNBC@OTW?4cpp?$AA@
CONST	SEGMENT
??_C@_07IANNNNBC@OTW?4cpp?$AA@ DB 'OTW.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
CONST	SEGMENT
??_C@_0M@CFLADCE@Feb?518?52013?$AA@ DB 'Feb 18 2013', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_OutsidePoints$initializer$ DD FLAT:??__EOutsidePoints@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_PercentScale$initializer$ DD FLAT:??__EPercentScale@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
;	COMDAT ??__EPercentScale@@YAXXZ
text$yc	SEGMENT
??__EPercentScale@@YAXXZ PROC				; `dynamic initializer for 'PercentScale'', COMDAT

; 360  : static const float	PercentScale = 1.0f + PercentBlend;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _PercentBlend
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _PercentScale, xmm0
	pop	ebp
	ret	0
??__EPercentScale@@YAXXZ ENDP				; `dynamic initializer for 'PercentScale''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
;	COMDAT ??__EOutsidePoints@@YAXXZ
text$yc	SEGMENT
??__EOutsidePoints@@YAXXZ PROC				; `dynamic initializer for 'OutsidePoints'', COMDAT

; 344  : 	{	 ltl,	 big	},

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _ltl
	movss	DWORD PTR _OutsidePoints, xmm0
	movss	xmm0, DWORD PTR _big
	movss	DWORD PTR _OutsidePoints+4, xmm0

; 345  : 	{	 1.0f,	 1.0f	},

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _OutsidePoints+8, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _OutsidePoints+12, xmm0

; 346  : 	{	 big,	 ltl	},

	movss	xmm0, DWORD PTR _big
	movss	DWORD PTR _OutsidePoints+16, xmm0
	movss	xmm0, DWORD PTR _ltl
	movss	DWORD PTR _OutsidePoints+20, xmm0

; 347  : 	{	 big,	-ltl	},

	movss	xmm0, DWORD PTR _big
	movss	DWORD PTR _OutsidePoints+24, xmm0
	movss	xmm0, DWORD PTR _ltl
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+28, xmm0

; 348  : 	{	 1.0f,	-1.0f	},

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _OutsidePoints+32, xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _OutsidePoints+36, xmm0

; 349  : 	{	 ltl,	-big	},

	movss	xmm0, DWORD PTR _ltl
	movss	DWORD PTR _OutsidePoints+40, xmm0
	movss	xmm0, DWORD PTR _big
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+44, xmm0

; 350  : 	{	-ltl,	-big	},

	movss	xmm0, DWORD PTR _ltl
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+48, xmm0
	movss	xmm0, DWORD PTR _big
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+52, xmm0

; 351  : 	{	-1.0f,	-1.0f	},

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _OutsidePoints+56, xmm0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _OutsidePoints+60, xmm0

; 352  : 	{	-big,	-ltl	},

	movss	xmm0, DWORD PTR _big
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+64, xmm0
	movss	xmm0, DWORD PTR _ltl
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+68, xmm0

; 353  : 	{	-big,	 ltl	},

	movss	xmm0, DWORD PTR _big
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+72, xmm0
	movss	xmm0, DWORD PTR _ltl
	movss	DWORD PTR _OutsidePoints+76, xmm0

; 354  : 	{	-1.0f,	 1.0f	},

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _OutsidePoints+80, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _OutsidePoints+84, xmm0

; 355  : 	{	-ltl,	 big	},

	movss	xmm0, DWORD PTR _ltl
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _OutsidePoints+88, xmm0
	movss	xmm0, DWORD PTR _big
	movss	DWORD PTR _OutsidePoints+92, xmm0

; 356  : 	{	 ltl,	 big	}

	movss	xmm0, DWORD PTR _ltl
	movss	DWORD PTR _OutsidePoints+96, xmm0
	movss	xmm0, DWORD PTR _big
	movss	DWORD PTR _OutsidePoints+100, xmm0

; 357  : };

	pop	ebp
	ret	0
??__EOutsidePoints@@YAXXZ ENDP				; `dynamic initializer for 'OutsidePoints''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\realweather.h
;	COMDAT ?UnderOvercast@RealWeather@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnderOvercast@RealWeather@@QAE_NXZ PROC		; RealWeather::UnderOvercast, COMDAT
; _this$ = ecx

; 150  : 	bool	UnderOvercast() { return UnderOVCST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+15996]
	mov	esp, ebp
	pop	ebp
	ret	0
?UnderOvercast@RealWeather@@QAE_NXZ ENDP		; RealWeather::UnderOvercast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\realweather.h
;	COMDAT ?InsideOvercast@RealWeather@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InsideOvercast@RealWeather@@QAE_NXZ PROC		; RealWeather::InsideOvercast, COMDAT
; _this$ = ecx

; 149  : 	bool	InsideOvercast() { return InsideOVCST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+15998]
	mov	esp, ebp
	pop	ebp
	ret	0
?InsideOvercast@RealWeather@@QAE_NXZ ENDP		; RealWeather::InsideOvercast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h
;	COMDAT ?SqrtF@@YAMM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?SqrtF@@YAMM@Z PROC					; SqrtF, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	_asm
; 51   : 	{
; 52   : 		fld f;

	fld	DWORD PTR _f$[ebp]

; 53   : 		fsqrt;

	fsqrt

; 54   : 		fstp f;

	fstp	DWORD PTR _f$[ebp]

; 55   : 	}
; 56   : 
; 57   : 	return f;

	fld	DWORD PTR _f$[ebp]

; 58   : }

	pop	ebp
	ret	0
?SqrtF@@YAMM@Z ENDP					; SqrtF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h
;	COMDAT ?FabsF@@YAMM@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?FabsF@@YAMM@Z PROC					; FabsF, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp

; 38   : 	_asm
; 39   : 	{
; 40   : 		fld f;

	fld	DWORD PTR _f$[ebp]

; 41   : 		fabs;

	fabs

; 42   : 		fstp f;

	fstp	DWORD PTR _f$[ebp]

; 43   : 	}
; 44   : 
; 45   : 	return f;

	fld	DWORD PTR _f$[ebp]

; 46   : }

	pop	ebp
	ret	0
?FabsF@@YAMM@Z ENDP					; FabsF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\dxengine\dxengine.h
;	COMDAT ?LinearFog@CDXEngine@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Status$ = 8						; size = 1
?LinearFog@CDXEngine@@QAEX_N@Z PROC			; CDXEngine::LinearFog, COMDAT
; _this$ = ecx

; 119  : 	void LinearFog(bool Status) { m_LinearFog = Status; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, BYTE PTR _Status$[ebp]
	mov	BYTE PTR ?m_LinearFog@CDXEngine@@0_NA, al ; CDXEngine::m_LinearFog
	mov	esp, ebp
	pop	ebp
	ret	4
?LinearFog@CDXEngine@@QAEX_N@Z ENDP			; CDXEngine::LinearFog
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?ShadowsOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?ShadowsOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::ShadowsOn, COMDAT
; _this$ = ecx

; 120  : 	int ShadowsOn(void)										{ return (DispFlags & DISP_SHADOWS) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $LN3@ShadowsOn
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@ShadowsOn
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@ShadowsOn
$LN3@ShadowsOn:
	mov	DWORD PTR tv68[ebp], 0
$LN4@ShadowsOn:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShadowsOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::ShadowsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloat@@YAMXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloat@@YAMXZ PROC					; PRANDFloat, COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR tv75[ebp], xmm1
	fld	DWORD PTR tv75[ebp]

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloat@@YAMXZ ENDP					; PRANDFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_mlt$1 = -72						; size = 8
_ocol$2 = -64						; size = 4
_max$3 = -60						; size = 4
_ocol$4 = -56						; size = 4
_dx$5 = -52						; size = 4
_dy$6 = -48						; size = 4
_sx$7 = -44						; size = 4
_sy$8 = -40						; size = 4
_i$9 = -36						; size = 4
_scol$10 = -32						; size = 4
_max$11 = -28						; size = 4
_i$12 = -24						; size = 4
_speedfactor$13 = -20					; size = 4
_rcol$14 = -16						; size = 4
_sx$15 = -12						; size = 4
_sy$16 = -8						; size = 4
_this$ = -4						; size = 4
_orientation$ = 8					; size = 4
?DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z PROC	; RenderOTW::DrawWeather
; _this$ = ecx

; 1890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 1891 :     // rain effects
; 1892 :     if (rainFactor > 0) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263204]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN12@DrawWeathe

; 1893 : 	int max = (int)(100 * rainFactor);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR [ecx+263204]
	cvttss2si edx, xmm0
	mov	DWORD PTR _max$11[ebp], edx

; 1894 : 	DWORD rcol = TheTimeOfDay.GetRainColor();

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetRainColor@CTimeOfDay@@QAEKXZ	; CTimeOfDay::GetRainColor
	mov	DWORD PTR _rcol$14[ebp], eax

; 1895 : 	if (TheTimeOfDay.GetNVGmode())

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetNVGmode@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetNVGmode
	test	eax, eax
	je	SHORT $LN11@DrawWeathe

; 1896 : 	    rcol &= 0xff00ff00; // just green component

	mov	eax, DWORD PTR _rcol$14[ebp]
	and	eax, -16711936				; ff00ff00H
	mov	DWORD PTR _rcol$14[ebp], eax
$LN11@DrawWeathe:

; 1897 : 	DWORD ocol = Color();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _ocol$4[ebp], eax

; 1898 : 	SetColor(rcol);

	mov	ecx, DWORD PTR _rcol$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 1899 : 	mlTrig mlt;
; 1900 : 	mlSinCos(&mlt, roll);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+262920]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _mlt$1[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1901 : 
; 1902 : 	// JB 010608 Adjust for speed
; 1903 : 	float speedfactor = (viewpoint->Speed + 10) / 100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263088]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR __real@41200000
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _speedfactor$13[ebp], xmm0

; 1904 : 	float dx = 0.033f * mlt.sin / speedfactor;

	movss	xmm0, DWORD PTR __real@3d072b02
	mulss	xmm0, DWORD PTR _mlt$1[ebp]
	divss	xmm0, DWORD PTR _speedfactor$13[ebp]
	movss	DWORD PTR _dx$5[ebp], xmm0

; 1905 : 	float dy = 0.033f * mlt.cos / speedfactor;

	movss	xmm0, DWORD PTR __real@3d072b02
	mulss	xmm0, DWORD PTR _mlt$1[ebp+4]
	divss	xmm0, DWORD PTR _speedfactor$13[ebp]
	movss	DWORD PTR _dy$6[ebp], xmm0

; 1906 : 	max = (int)(float(max) * speedfactor);

	cvtsi2ss xmm0, DWORD PTR _max$11[ebp]
	mulss	xmm0, DWORD PTR _speedfactor$13[ebp]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _max$11[ebp], ecx

; 1907 : 
; 1908 : 	for (int i = 0; i < max; i ++) {

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN10@DrawWeathe
$LN9@DrawWeathe:
	mov	edx, DWORD PTR _i$12[ebp]
	add	edx, 1
	mov	DWORD PTR _i$12[ebp], edx
$LN10@DrawWeathe:
	mov	eax, DWORD PTR _i$12[ebp]
	cmp	eax, DWORD PTR _max$11[ebp]
	jge	$LN8@DrawWeathe

; 1909 : 	    float sx, sy;
; 1910 : 	    sx = PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR _sx$7[ebp]

; 1911 : 	    sy = PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR _sy$8[ebp]

; 1912 : 	    
; 1913 : 	    // just vertical lines currently. Need to slant them based on speed....
; 1914 : 	    // but thats tricky, cos we have no knowledge of that here
; 1915 : 			// JB 010608 We do now!
; 1916 : 	    Render2DLine(viewportXtoPixel(sx), viewportYtoPixel(sy), 
; 1917 : 		viewportXtoPixel(sx+dx), viewportYtoPixel(sy + dy));

	movss	xmm0, DWORD PTR _sy$8[ebp]
	addss	xmm0, DWORD PTR _dy$6[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sx$7[ebp]
	addss	xmm0, DWORD PTR _dx$5[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _sy$8[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _sx$7[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 1918 : 	}

	jmp	$LN9@DrawWeathe
$LN8@DrawWeathe:

; 1919 : 	SetColor(ocol);

	mov	ecx, DWORD PTR _ocol$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx
$LN12@DrawWeathe:

; 1920 :     }
; 1921 : 
; 1922 :     if (thunderAndLightning) {
; 1923 : 	// draw some shapes...
; 1924 : 
; 1925 : 	// do something clever - damm out of time!!
; 1926 : 	// algorithm written, (in perl) and ready to go,
; 1927 : 	// this is the wrong place anyway, should be tied to a cloud and done in 3-d space.
; 1928 :     }
; 1929 : 
; 1930 :     if (snowFactor > 0) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263208]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN6@DrawWeathe

; 1931 : 	// snow effects
; 1932 : 	int max = (int)(100 * snowFactor);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR [eax+263208]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _max$3[ebp], ecx

; 1933 : 	DWORD scol = TheTimeOfDay.GetSnowColor();

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetSnowColor@CTimeOfDay@@QAEKXZ	; CTimeOfDay::GetSnowColor
	mov	DWORD PTR _scol$10[ebp], eax

; 1934 : 	if (TheTimeOfDay.GetNVGmode())

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetNVGmode@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetNVGmode
	test	eax, eax
	je	SHORT $LN5@DrawWeathe

; 1935 : 	    scol &= 0xff00ff00; // just green component

	mov	edx, DWORD PTR _scol$10[ebp]
	and	edx, -16711936				; ff00ff00H
	mov	DWORD PTR _scol$10[ebp], edx
$LN5@DrawWeathe:

; 1936 : 	DWORD ocol = Color();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _ocol$2[ebp], eax

; 1937 : 	SetColor(scol);

	mov	ecx, DWORD PTR _scol$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 1938 : 	static const float TRIX = 0.009f, TRI2 = TRIX/2.0f;

	mov	eax, DWORD PTR ?$S2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4IA
	and	eax, 1
	jne	SHORT $LN4@DrawWeathe
	mov	ecx, DWORD PTR ?$S2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4IA, ecx
	movss	xmm0, DWORD PTR ?TRIX@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB, xmm0
$LN4@DrawWeathe:

; 1939 : 	
; 1940 : 	for (int i = 0; i < max; i++) {

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN3@DrawWeathe
$LN2@DrawWeathe:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN3@DrawWeathe:
	mov	eax, DWORD PTR _i$9[ebp]
	cmp	eax, DWORD PTR _max$3[ebp]
	jge	$LN1@DrawWeathe

; 1941 : 	    float sx, sy;
; 1942 : 	    sx = PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR _sx$15[ebp]

; 1943 : 	    sy = PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR _sy$16[ebp]

; 1944 : 
; 1945 : 	    // we just draw small 6-pt stars. Two crossed triangles.
; 1946 : 	    Render2DTri(viewportXtoPixel(sx), viewportXtoPixel(sy), 
; 1947 : 		viewportXtoPixel(sx +TRIX), viewportXtoPixel(sy), 
; 1948 : 		viewportXtoPixel(sx+TRI2), viewportXtoPixel(sy + TRIX));

	movss	xmm0, DWORD PTR _sy$16[ebp]
	addss	xmm0, DWORD PTR ?TRIX@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sx$15[ebp]
	addss	xmm0, DWORD PTR ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _sy$16[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sx$15[ebp]
	addss	xmm0, DWORD PTR ?TRIX@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _sy$16[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _sx$15[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax

; 1949 : 	    Render2DTri(viewportXtoPixel(sx), viewportXtoPixel(sy+TRI2), 
; 1950 : 		viewportXtoPixel(sx+TRIX), viewportXtoPixel(sy+TRI2), 
; 1951 : 		viewportXtoPixel(sx+TRI2), viewportXtoPixel(sy-TRI2));

	movss	xmm0, DWORD PTR _sy$16[ebp]
	subss	xmm0, DWORD PTR ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sx$15[ebp]
	addss	xmm0, DWORD PTR ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sy$16[ebp]
	addss	xmm0, DWORD PTR ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sx$15[ebp]
	addss	xmm0, DWORD PTR ?TRIX@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _sy$16[ebp]
	addss	xmm0, DWORD PTR ?TRI2@?BB@??DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z@4MB
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _sx$15[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax

; 1952 : 	}

	jmp	$LN2@DrawWeathe
$LN1@DrawWeathe:

; 1953 : 	SetColor(ocol);

	mov	ecx, DWORD PTR _ocol$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx
$LN6@DrawWeathe:

; 1954 :     }
; 1955 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawWeather@RenderOTW@@IAEXPBUTrotation@@@Z ENDP	; RenderOTW::DrawWeather
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_distance$ = -4						; size = 4
_clouds$ = 8						; size = 4
_objects$ = 12						; size = 4
?DrawCloudsAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@0@Z PROC ; RenderOTW::DrawCloudsAndObjects
; _this$ = ecx

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN3@DrawClouds:

; 1223 : 	float distance;
; 1224 : 	
; 1225 : 	do
; 1226 : 	{
; 1227 : 		distance = objects->GetNextDrawDistance();

	mov	ecx, DWORD PTR _objects$[ebp]
	call	?GetNextDrawDistance@ObjectDisplayList@@QAEMXZ ; ObjectDisplayList::GetNextDrawDistance
	fstp	DWORD PTR _distance$[ebp]

; 1228 : 		clouds->DrawBeyond(distance,0,this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _clouds$[ebp]
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 1229 : 		objects->DrawBeyond(distance,0,this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _objects$[ebp]
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 1230 : 	}
; 1231 : 	while (distance > -1.0f);

	movss	xmm0, DWORD PTR _distance$[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	ja	SHORT $LN3@DrawClouds

; 1232 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawCloudsAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@0@Z ENDP ; RenderOTW::DrawCloudsAndObjects
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv169 = -12						; size = 4
_span$ = -8						; size = 4
_this$ = -4						; size = 4
_objectList$ = 8					; size = 4
?DrawGroundAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@@Z PROC ; RenderOTW::DrawGroundAndObjects
; _this$ = ecx

; 1021 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1022 : 	SpanListEntry*	span;
; 1023 : 	
; 1024 : #ifdef TWO_D_MAP_AVAILABLE
; 1025 : 	if (twoDmode) {
; 1026 : 		// Set the clip flag for each vertex to indicate it hasn't been xformed
; 1027 : 		int usedLODcount	= viewpoint->GetMaxLOD() - viewpoint->GetMinLOD() + 1;
; 1028 : 		int LODbufferSize	= (maxSpanExtent) * (maxSpanExtent);
; 1029 : 		for (TerrainVertex* v = vertexMemory; v <  vertexMemory + usedLODcount * LODbufferSize; v++) {
; 1030 : 			v->clipFlag = 0xFFFF;
; 1031 : 		}
; 1032 : 
; 1033 : 		context.SetState(MPR_STA_DISABLES,MPR_SE_SHADING);
; 1034 : 		context.SetState(MPR_STA_ENABLES,MPR_SE_ALPHA); //JAM 02Oct03 - MPR_SE_BLENDING );
; 1035 : 	}
; 1036 : #endif
; 1037 : 
; 1038 : 	// Compute the potentially visible region of terrain and divide it into rings
; 1039 : 	ComputeBounds();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeBounds@RenderOTW@@IAEXXZ	; RenderOTW::ComputeBounds

; 1040 : 	BuildRingList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildRingList@RenderOTW@@IAEXXZ	; RenderOTW::BuildRingList

; 1041 : 
; 1042 : 	// Clip the inside edges of the rings to the computed bounding volume in world space
; 1043 : 	ClipHorizontalSectors();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipHorizontalSectors@RenderOTW@@IAEXXZ ; RenderOTW::ClipHorizontalSectors

; 1044 : 	ClipVerticalSectors();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipVerticalSectors@RenderOTW@@IAEXXZ	; RenderOTW::ClipVerticalSectors

; 1045 : 	BuildCornerSet();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildCornerSet@RenderOTW@@IAEXXZ	; RenderOTW::BuildCornerSet

; 1046 : 	TrimCornerSet();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrimCornerSet@RenderOTW@@IAEXXZ	; RenderOTW::TrimCornerSet

; 1047 : 
; 1048 : 	// Transform all the verteces required to draw the terrain squares described in the span list
; 1049 : 	BuildVertexSet();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildVertexSet@RenderOTW@@IAEXXZ	; RenderOTW::BuildVertexSet

; 1050 : 	TransformVertexSet();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TransformVertexSet@RenderOTW@@IAEXXZ	; RenderOTW::TransformVertexSet

; 1051 : 
; 1052 : 
; 1053 : #ifdef TWO_D_MAP_AVAILABLE
; 1054 : 	if (twoDmode) {
; 1055 : 		ThreeDVertex	v;
; 1056 : 		ThreeDVertex	*vert = &v;
; 1057 : 		Tpoint			v1, v2;
; 1058 : 		int	levelCol;
; 1059 : 		int	levelRow;
; 1060 : 		int	LOD;
; 1061 : 
; 1062 : 		for ( span = spanList; span<firstEmptySpan; span++ ) {
; 1063 : 			LOD = span->LOD;
; 1064 : 
; 1065 : 			levelRow = span->ring;
; 1066 : 			if (span->Tsector.maxEndPoint > span->Tsector.minEndPoint) {
; 1067 : 				v1.y = v2.y = (yRes>>1) - TWODSCALE*WORLD_TO_FLOAT_GLOBAL_POST( span->Tsector.insideEdge - viewpoint->X() );
; 1068 : 				v1.x = (xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Tsector.maxEndPoint - viewpoint->Y()) );
; 1069 : 				v2.x = (xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Tsector.minEndPoint - viewpoint->Y()) );
; 1070 : 
; 1071 : 				SetColor( (0x4040 << ((span->LOD-2)*8)) | 0x80000000 );
; 1072 : 				Render2DLine( (UInt16)v1.x, (UInt16)v1.y, (UInt16)v2.x, (UInt16)v2.y );                           
; 1073 : 			}
; 1074 : 			for (levelCol = span->Tsector.startDraw; levelCol <= span->Tsector.stopDraw; levelCol++) {
; 1075 : 				vert->x = (xRes>>1) + TWODSCALE*((float)((levelCol+ LODdata[LOD].centerCol) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->Y()));
; 1076 : 				vert->y = (yRes>>1) - TWODSCALE*((float)((levelRow+ LODdata[LOD].centerRow) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->X()));
; 1077 : 
; 1078 : 				// Draw a marker at this vertex location
; 1079 : 				SetColor( 0xF0008080 );
; 1080 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1081 : 							(UInt16)(vert->x+1), (UInt16)(vert->y-1),
; 1082 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1));
; 1083 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1084 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1),
; 1085 : 							(UInt16)(vert->x-1), (UInt16)(vert->y+1));
; 1086 : 			}
; 1087 : 
; 1088 : 			levelCol = span->ring;
; 1089 : 			if (span->Rsector.maxEndPoint > span->Rsector.minEndPoint) {
; 1090 : 				v1.x = v2.x = (xRes>>1) + TWODSCALE*WORLD_TO_FLOAT_GLOBAL_POST( span->Rsector.insideEdge - viewpoint->Y() );
; 1091 : 				v1.y = (yRes>>1) - TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Rsector.maxEndPoint - viewpoint->X()) );
; 1092 : 				v2.y = (yRes>>1) - TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Rsector.minEndPoint - viewpoint->X()) );
; 1093 : 
; 1094 : 				SetColor( (0x4040 << ((span->LOD-2)*8)) | 0x80000000 );
; 1095 : 				Render2DLine( (UInt16)v1.x, (UInt16)v1.y, (UInt16)v2.x, (UInt16)v2.y );                           
; 1096 : 			}
; 1097 : 			for (levelRow = span->Rsector.startDraw; levelRow <= span->Rsector.stopDraw; levelRow++) {
; 1098 : 				vert->x = (xRes>>1) + TWODSCALE*((float)((levelCol+ LODdata[LOD].centerCol) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->Y()));
; 1099 : 				vert->y = (yRes>>1) - TWODSCALE*((float)((levelRow+ LODdata[LOD].centerRow) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->X()));
; 1100 : 
; 1101 : 				// Draw a marker at this vertex location
; 1102 : 				SetColor( 0xF0008080 );
; 1103 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1104 : 							(UInt16)(vert->x+1), (UInt16)(vert->y-1),
; 1105 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1));
; 1106 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1107 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1),
; 1108 : 							(UInt16)(vert->x-1), (UInt16)(vert->y+1));
; 1109 : 			}
; 1110 : 
; 1111 : 			levelRow = -span->ring;
; 1112 : 			if (span->Bsector.maxEndPoint > span->Bsector.minEndPoint) {
; 1113 : 				v1.y = v2.y = (yRes>>1) - TWODSCALE*WORLD_TO_FLOAT_GLOBAL_POST( span->Bsector.insideEdge - viewpoint->X() );
; 1114 : 				v1.x = (xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Bsector.maxEndPoint - viewpoint->Y()) );
; 1115 : 				v2.x = (xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Bsector.minEndPoint - viewpoint->Y()) );
; 1116 : 
; 1117 : 				SetColor( (0x4040 << ((span->LOD-2)*8)) | 0x80000000 );
; 1118 : 				Render2DLine( (UInt16)v1.x, (UInt16)v1.y, (UInt16)v2.x, (UInt16)v2.y );                           
; 1119 : 			}
; 1120 : 			for (levelCol = span->Bsector.startDraw; levelCol <= span->Bsector.stopDraw; levelCol++) {
; 1121 : 				vert->x = (xRes>>1) + TWODSCALE*((float)((levelCol+ LODdata[LOD].centerCol) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->Y()));
; 1122 : 				vert->y = (yRes>>1) - TWODSCALE*((float)((levelRow+ LODdata[LOD].centerRow) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->X()));
; 1123 : 
; 1124 : 				// Draw a marker at this vertex location
; 1125 : 				SetColor( 0xF0008080 );
; 1126 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1127 : 							(UInt16)(vert->x+1), (UInt16)(vert->y-1),
; 1128 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1));
; 1129 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1130 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1),
; 1131 : 							(UInt16)(vert->x-1), (UInt16)(vert->y+1));
; 1132 : 			}
; 1133 : 
; 1134 : 			levelCol = -span->ring;
; 1135 : 			if (span->Lsector.maxEndPoint > span->Lsector.minEndPoint) {
; 1136 : 				v1.x = v2.x = (xRes>>1) + TWODSCALE*WORLD_TO_FLOAT_GLOBAL_POST( span->Lsector.insideEdge - viewpoint->Y() );
; 1137 : 				v1.y = (yRes>>1) - TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Lsector.maxEndPoint - viewpoint->X()) );
; 1138 : 				v2.y = (yRes>>1) - TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(span->Lsector.minEndPoint - viewpoint->X()) );
; 1139 : 
; 1140 : 				SetColor( (0x4040 << ((span->LOD-2)*8)) | 0x80000000 );
; 1141 : 				Render2DLine( (UInt16)v1.x, (UInt16)v1.y, (UInt16)v2.x, (UInt16)v2.y );                           
; 1142 : 			}
; 1143 : 			for (levelRow = span->Lsector.startDraw; levelRow <= span->Lsector.stopDraw; levelRow++) {
; 1144 : 				vert->x = (xRes>>1) + TWODSCALE*((float)((levelCol+ LODdata[LOD].centerCol) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->Y()));
; 1145 : 				vert->y = (yRes>>1) - TWODSCALE*((float)((levelRow+ LODdata[LOD].centerRow) << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->X()));
; 1146 : 
; 1147 : 				// Draw a marker at this vertex location
; 1148 : 				SetColor( 0xF0008080 );
; 1149 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1150 : 							(UInt16)(vert->x+1), (UInt16)(vert->y-1),
; 1151 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1));
; 1152 : 				Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1153 : 							(UInt16)(vert->x+1), (UInt16)(vert->y+1),
; 1154 : 							(UInt16)(vert->x-1), (UInt16)(vert->y+1));
; 1155 : 			}
; 1156 : 		}
; 1157 : 
; 1158 : //		return;
; 1159 : 	}
; 1160 : #endif
; 1161 : 
; 1162 : 
; 1163 : 
; 1164 : 	//START_PROFILE("In Ground");
; 1165 : 
; 1166 : 	// Render all the require polygons from farthest to nearest
; 1167 : 	for ( span = spanList+1; span<firstEmptySpan; span++ ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263348]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN7@DrawGround
$LN6@DrawGround:
	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN7@DrawGround:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263352]
	jae	$LN5@DrawGround

; 1168 : 
; 1169 : 		// Call the appropriate routine to draw the ring
; 1170 : 		if ( span->LOD == (span+1)->LOD ) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+124]
	jne	SHORT $LN4@DrawGround

; 1171 : 			DrawTerrainRing( span );

	mov	edx, DWORD PTR _span$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z ; RenderOTW::DrawTerrainRing

; 1172 : 		} else {

	jmp	SHORT $LN3@DrawGround
$LN4@DrawGround:

; 1173 : 			// Skip the last ring at the lower LOD (its used only for culling and transformation)
; 1174 : 			span++;

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], eax

; 1175 : 
; 1176 : 			// Use the first span at the new LOD to draw the connector ring
; 1177 : 			DrawConnectorRing( span );

	mov	ecx, DWORD PTR _span$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawConnectorRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z ; RenderOTW::DrawConnectorRing

; 1178 : 
; 1179 : 			span++;

	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx

; 1180 : 
; 1181 : 			// Draw the gap filler
; 1182 : 			DrawGapFiller( span );

	mov	eax, DWORD PTR _span$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGapFiller@RenderOTW@@IAEXPAUSpanListEntry@@@Z ; RenderOTW::DrawGapFiller
$LN3@DrawGround:

; 1183 : 		}
; 1184 : 
; 1185 : 
; 1186 : 		// Draw any object over this ring
; 1187 : 
; 1188 : 		// COBRA - RED - Only this is good...just do nothing is false
; 1189 : 		//JAM 13Nov03
; 1190 : 		if((realWeather->weatherCondition <= FAIR) || (viewpoint->Z() > realWeather->MidOvercast))

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [ecx+15688], 2
	jle	SHORT $LN1@DrawGround
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?Z@TViewPoint@@QAEMXZ			; TViewPoint::Z
	fstp	DWORD PTR tv169[ebp]
	movss	xmm0, DWORD PTR tv169[ebp]
	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	comiss	xmm0, DWORD PTR [eax+15760]
	jbe	SHORT $LN2@DrawGround
$LN1@DrawGround:

; 1191 : 			// If we're above the overcast layer, ground objects are not visible.
; 1192 : 			objectList->DrawBeyond(LEVEL_POST_TO_WORLD(span->ring,span->LOD),span->LOD,this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _objectList$[ebp]
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond
$LN2@DrawGround:

; 1193 : 		//else
; 1194 : 			//objectList->DrawBeyond(LEVEL_POST_TO_WORLD(span->ring,span->LOD),-1,this);
; 1195 : 		// COBRA - RED - End
; 1196 : 
; 1197 : 	}

	jmp	$LN6@DrawGround
$LN5@DrawGround:

; 1198 : 
; 1199 : 	//STOP_PROFILE("In Ground");
; 1200 : 
; 1201 : 	// Draw any remaining objects
; 1202 : 
; 1203 : 	// COBRA - RED - Seems completely wrong condition, completely wrong way to do it to me
; 1204 : 	// these condition ( corrected ) should be placed above
; 1205 : 	//JAM 13Nov03
; 1206 : /*	if(!(realWeather->weatherCondition > FAIR && (-viewpoint->Z()) > (-realWeather->stratusZ)))
; 1207 : 	{
; 1208 : 		// If we're above the overcast layer, ground objects are not visible.
; 1209 : 			objectList->DrawBeyond(0.f,-1,this);
; 1210 : 	}*/
; 1211 : 	// COBRA - RED - End
; 1212 : 
; 1213 : 	// Turn off all non-default rendering parameters
; 1214 : 	context.RestoreState( STATE_SOLID );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState

; 1215 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawGroundAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@@Z ENDP ; RenderOTW::DrawGroundAndObjects
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv218 = -52						; size = 4
tv204 = -48						; size = 4
tv189 = -44						; size = 4
tv175 = -40						; size = 4
tv153 = -36						; size = 4
tv139 = -32						; size = 4
tv92 = -28						; size = 4
tv78 = -24						; size = 4
_LOD$ = -20						; size = 4
_this$ = -16						; size = 4
_crossOver$ = -12					; size = 4
_r$ = -8						; size = 4
_c$ = -4						; size = 4
_span$ = 8						; size = 4
?DrawGapFiller@RenderOTW@@IAEXPAUSpanListEntry@@@Z PROC	; RenderOTW::DrawGapFiller
; _this$ = ecx

; 1841 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1842 : 	int				LOD		= span->LOD;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _LOD$[ebp], ecx

; 1843 : 	register int	r, c;
; 1844 : 	int				crossOver;
; 1845 : 
; 1846 : 
; 1847 : 	if ( LODdata[span->LOD].glueOnBottom ) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	cmp	DWORD PTR [edx+eax+48], 0
	je	$LN28@DrawGapFil

; 1848 : 		// BOTTOM_SPAN -- Horizontal (Sector 3 and 4)
; 1849 : 		r = -span->ring;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	mov	DWORD PTR _r$[ebp], ecx

; 1850 : 
; 1851 : 		crossOver = max( span->Bsector.startDraw, 0 ); 

	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+76], 0
	jle	SHORT $LN31@DrawGapFil
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN32@DrawGapFil
$LN31@DrawGapFil:
	mov	DWORD PTR tv78[ebp], 0
$LN32@DrawGapFil:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _crossOver$[ebp], edx

; 1852 : 		for ( c = span->Bsector.stopDraw; c >= crossOver; c-- )		DrawTerrainSquare( r, c, LOD );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _c$[ebp], ecx
	jmp	SHORT $LN27@DrawGapFil
$LN26@DrawGapFil:
	mov	edx, DWORD PTR _c$[ebp]
	sub	edx, 1
	mov	DWORD PTR _c$[ebp], edx
$LN27@DrawGapFil:
	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN25@DrawGapFil
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN26@DrawGapFil
$LN25@DrawGapFil:

; 1853 : 
; 1854 : 		crossOver = min( span->Bsector.stopDraw, -1 ); 

	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+80], -1
	jge	SHORT $LN33@DrawGapFil
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN34@DrawGapFil
$LN33@DrawGapFil:
	mov	DWORD PTR tv92[ebp], -1
$LN34@DrawGapFil:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1855 : 		for ( c = span->Bsector.startDraw; c <= crossOver; c++ )	DrawTerrainSquare( r, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN24@DrawGapFil
$LN23@DrawGapFil:
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx
$LN24@DrawGapFil:
	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN22@DrawGapFil
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN23@DrawGapFil
$LN22@DrawGapFil:
	jmp	$LN21@DrawGapFil
$LN28@DrawGapFil:

; 1856 : 	} else {
; 1857 : 		// TOP_SPAN -- Horizontal (Sector 0 and 7)
; 1858 : 		r = span->ring;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _r$[ebp], ecx

; 1859 : 
; 1860 : 		crossOver = max( span->Tsector.startDraw, 0 ); 

	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jle	SHORT $LN35@DrawGapFil
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv139[ebp], ecx
	jmp	SHORT $LN36@DrawGapFil
$LN35@DrawGapFil:
	mov	DWORD PTR tv139[ebp], 0
$LN36@DrawGapFil:
	mov	edx, DWORD PTR tv139[ebp]
	mov	DWORD PTR _crossOver$[ebp], edx

; 1861 : 		for ( c = span->Tsector.stopDraw; c >= crossOver; c-- )		DrawTerrainSquare( r, c, LOD );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _c$[ebp], ecx
	jmp	SHORT $LN20@DrawGapFil
$LN19@DrawGapFil:
	mov	edx, DWORD PTR _c$[ebp]
	sub	edx, 1
	mov	DWORD PTR _c$[ebp], edx
$LN20@DrawGapFil:
	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN18@DrawGapFil
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN19@DrawGapFil
$LN18@DrawGapFil:

; 1862 : 
; 1863 : 		crossOver = min( span->Tsector.stopDraw, -1 ); 

	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+24], -1
	jge	SHORT $LN37@DrawGapFil
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv153[ebp], eax
	jmp	SHORT $LN38@DrawGapFil
$LN37@DrawGapFil:
	mov	DWORD PTR tv153[ebp], -1
$LN38@DrawGapFil:
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1864 : 		for ( c = span->Tsector.startDraw; c <= crossOver; c++ )	DrawTerrainSquare( r, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN17@DrawGapFil
$LN16@DrawGapFil:
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx
$LN17@DrawGapFil:
	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN21@DrawGapFil
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN16@DrawGapFil
$LN21@DrawGapFil:

; 1865 : 	}
; 1866 : 
; 1867 : 		
; 1868 : 	if ( LODdata[span->LOD].glueOnLeft ) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	cmp	DWORD PTR [eax+ecx+52], 0
	je	$LN14@DrawGapFil

; 1869 : 		// LEFT_SPAN -- Vertical (Sector 5 and 6)
; 1870 : 		c = -span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	DWORD PTR _c$[ebp], edx

; 1871 : 
; 1872 : 		crossOver = max( span->Lsector.startDraw, 0 ); 

	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jle	SHORT $LN39@DrawGapFil
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR tv175[ebp], edx
	jmp	SHORT $LN40@DrawGapFil
$LN39@DrawGapFil:
	mov	DWORD PTR tv175[ebp], 0
$LN40@DrawGapFil:
	mov	eax, DWORD PTR tv175[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1873 : 		for ( r = span->Lsector.stopDraw; r >= crossOver; r-- )		DrawTerrainSquare( r, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _r$[ebp], edx
	jmp	SHORT $LN13@DrawGapFil
$LN12@DrawGapFil:
	mov	eax, DWORD PTR _r$[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$[ebp], eax
$LN13@DrawGapFil:
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN11@DrawGapFil
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN12@DrawGapFil
$LN11@DrawGapFil:

; 1874 : 
; 1875 : 		crossOver = min( span->Lsector.stopDraw, -1 ); 

	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+108], -1
	jge	SHORT $LN41@DrawGapFil
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR tv189[ebp], ecx
	jmp	SHORT $LN42@DrawGapFil
$LN41@DrawGapFil:
	mov	DWORD PTR tv189[ebp], -1
$LN42@DrawGapFil:
	mov	edx, DWORD PTR tv189[ebp]
	mov	DWORD PTR _crossOver$[ebp], edx

; 1876 : 		for ( r = span->Lsector.startDraw; r <= crossOver; r++ )	DrawTerrainSquare( r, c, LOD );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _r$[ebp], ecx
	jmp	SHORT $LN10@DrawGapFil
$LN9@DrawGapFil:
	mov	edx, DWORD PTR _r$[ebp]
	add	edx, 1
	mov	DWORD PTR _r$[ebp], edx
$LN10@DrawGapFil:
	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN8@DrawGapFil
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN9@DrawGapFil
$LN8@DrawGapFil:
	jmp	$LN29@DrawGapFil
$LN14@DrawGapFil:

; 1877 : 	} else {
; 1878 : 		// RIGHT_SPAN -- Vertical (Sector 1 and 2)
; 1879 : 		c = span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx

; 1880 : 
; 1881 : 		crossOver = max( span->Rsector.startDraw, 0 ); 

	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jle	SHORT $LN43@DrawGapFil
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR tv204[ebp], edx
	jmp	SHORT $LN44@DrawGapFil
$LN43@DrawGapFil:
	mov	DWORD PTR tv204[ebp], 0
$LN44@DrawGapFil:
	mov	eax, DWORD PTR tv204[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1882 : 		for ( r = span->Rsector.stopDraw; r >= crossOver; r-- )		DrawTerrainSquare( r, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _r$[ebp], edx
	jmp	SHORT $LN6@DrawGapFil
$LN5@DrawGapFil:
	mov	eax, DWORD PTR _r$[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$[ebp], eax
$LN6@DrawGapFil:
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN4@DrawGapFil
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN5@DrawGapFil
$LN4@DrawGapFil:

; 1883 : 
; 1884 : 		crossOver = min( span->Rsector.stopDraw, -1 ); 

	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+52], -1
	jge	SHORT $LN45@DrawGapFil
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR tv218[ebp], ecx
	jmp	SHORT $LN46@DrawGapFil
$LN45@DrawGapFil:
	mov	DWORD PTR tv218[ebp], -1
$LN46@DrawGapFil:
	mov	edx, DWORD PTR tv218[ebp]
	mov	DWORD PTR _crossOver$[ebp], edx

; 1885 : 		for ( r = span->Rsector.startDraw; r <= crossOver; r++ )	DrawTerrainSquare( r, c, LOD );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _r$[ebp], ecx
	jmp	SHORT $LN3@DrawGapFil
$LN2@DrawGapFil:
	mov	edx, DWORD PTR _r$[ebp]
	add	edx, 1
	mov	DWORD PTR _r$[ebp], edx
$LN3@DrawGapFil:
	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN29@DrawGapFil
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN2@DrawGapFil
$LN29@DrawGapFil:

; 1886 : 	}	
; 1887 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawGapFiller@RenderOTW@@IAEXPAUSpanListEntry@@@Z ENDP	; RenderOTW::DrawGapFiller
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv313 = -72						; size = 4
tv286 = -68						; size = 4
tv272 = -64						; size = 4
tv254 = -60						; size = 4
tv227 = -56						; size = 4
tv213 = -52						; size = 4
tv197 = -48						; size = 4
tv172 = -44						; size = 4
tv158 = -40						; size = 4
tv142 = -36						; size = 4
tv85 = -32						; size = 4
tv71 = -28						; size = 4
_crossOver$ = -24					; size = 4
_r$ = -20						; size = 4
_c$ = -16						; size = 4
_this$ = -12						; size = 4
_LOD$ = -8						; size = 4
_span$ = -4						; size = 4
_outterSpan$ = 8					; size = 4
?DrawConnectorRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z PROC ; RenderOTW::DrawConnectorRing
; _this$ = ecx

; 1786 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 1787 : 	int				LOD;
; 1788 : 	int				crossOver;
; 1789 : 	register int	r, c;
; 1790 : 	SpanListEntry	*span;
; 1791 : 
; 1792 : 	LOD = outterSpan->LOD;

	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _LOD$[ebp], ecx

; 1793 : 
; 1794 : 
; 1795 : 	// TOP_SPAN -- Horizontal (Sector 0 and 7)
; 1796 : 	span = LODdata[LOD].glueOnBottom ? outterSpan+1 : outterSpan;

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+48], 0
	je	SHORT $LN27@DrawConnec
	mov	edx, DWORD PTR _outterSpan$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN28@DrawConnec
$LN27@DrawConnec:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	DWORD PTR tv71[ebp], eax
$LN28@DrawConnec:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _span$[ebp], ecx

; 1797 : 
; 1798 : 	crossOver = max( span->Tsector.startDraw, LODdata[LOD].glueOnLeft );

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, DWORD PTR [ecx+edx+52]
	jle	SHORT $LN29@DrawConnec
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR tv85[ebp], edx
	jmp	SHORT $LN30@DrawConnec
$LN29@DrawConnec:
	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [edx+eax+52]
	mov	DWORD PTR tv85[ebp], eax
$LN30@DrawConnec:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1799 : 	for ( c = span->Tsector.stopDraw; c >= crossOver; c-=2 )	DrawUpConnector( span->ring, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN24@DrawConnec
$LN23@DrawConnec:
	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _c$[ebp], ecx
$LN24@DrawConnec:
	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN22@DrawConnec
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawUpConnector@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawUpConnector
	jmp	SHORT $LN23@DrawConnec
$LN22@DrawConnec:

; 1800 : 
; 1801 : 	crossOver = min( span->Tsector.stopDraw, -2+LODdata[LOD].glueOnLeft ); 

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	ecx, DWORD PTR [eax+ecx+52]
	sub	ecx, 2
	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+24], ecx
	jge	SHORT $LN31@DrawConnec
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv142[ebp], ecx
	jmp	SHORT $LN32@DrawConnec
$LN31@DrawConnec:
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+52]
	sub	edx, 2
	mov	DWORD PTR tv142[ebp], edx
$LN32@DrawConnec:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1802 : 	for ( c = span->Tsector.startDraw; c <= crossOver; c+=2 )	DrawUpConnector( span->ring, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _c$[ebp], edx
	jmp	SHORT $LN21@DrawConnec
$LN20@DrawConnec:
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 2
	mov	DWORD PTR _c$[ebp], eax
$LN21@DrawConnec:
	mov	ecx, DWORD PTR _c$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN19@DrawConnec
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawUpConnector@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawUpConnector
	jmp	SHORT $LN20@DrawConnec
$LN19@DrawConnec:

; 1803 : 
; 1804 : 
; 1805 : 	// RIGHT_SPAN -- Vertical (Sector 1 and 2)
; 1806 : 	span = LODdata[LOD].glueOnLeft ? outterSpan+1 : outterSpan;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	cmp	DWORD PTR [edx+eax+52], 0
	je	SHORT $LN33@DrawConnec
	mov	eax, DWORD PTR _outterSpan$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR tv158[ebp], eax
	jmp	SHORT $LN34@DrawConnec
$LN33@DrawConnec:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	DWORD PTR tv158[ebp], ecx
$LN34@DrawConnec:
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR _span$[ebp], edx

; 1807 : 
; 1808 : 	crossOver = max( span->Rsector.startDraw, LODdata[LOD].glueOnBottom ); 

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	cmp	ecx, DWORD PTR [edx+eax+48]
	jle	SHORT $LN35@DrawConnec
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $LN36@DrawConnec
$LN35@DrawConnec:
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	ecx, DWORD PTR [eax+ecx+48]
	mov	DWORD PTR tv172[ebp], ecx
$LN36@DrawConnec:
	mov	edx, DWORD PTR tv172[ebp]
	mov	DWORD PTR _crossOver$[ebp], edx

; 1809 : 	for ( r = span->Rsector.stopDraw; r >= crossOver; r-=2 )	DrawRightConnector( r, span->ring, LOD );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _r$[ebp], ecx
	jmp	SHORT $LN18@DrawConnec
$LN17@DrawConnec:
	mov	edx, DWORD PTR _r$[ebp]
	sub	edx, 2
	mov	DWORD PTR _r$[ebp], edx
$LN18@DrawConnec:
	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN16@DrawConnec
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRightConnector@RenderOTW@@IAEXHHH@Z ; RenderOTW::DrawRightConnector
	jmp	SHORT $LN17@DrawConnec
$LN16@DrawConnec:

; 1810 : 
; 1811 : 	crossOver = min( span->Rsector.stopDraw, -2+LODdata[LOD].glueOnBottom ); 

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+48]
	sub	edx, 2
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+52], edx
	jge	SHORT $LN37@DrawConnec
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR tv197[ebp], edx
	jmp	SHORT $LN38@DrawConnec
$LN37@DrawConnec:
	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [edx+eax+48]
	sub	eax, 2
	mov	DWORD PTR tv197[ebp], eax
$LN38@DrawConnec:
	mov	ecx, DWORD PTR tv197[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1812 : 	for ( r = span->Rsector.startDraw; r <= crossOver; r+=2 )	DrawRightConnector( r, span->ring, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _r$[ebp], eax
	jmp	SHORT $LN15@DrawConnec
$LN14@DrawConnec:
	mov	ecx, DWORD PTR _r$[ebp]
	add	ecx, 2
	mov	DWORD PTR _r$[ebp], ecx
$LN15@DrawConnec:
	mov	edx, DWORD PTR _r$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN13@DrawConnec
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRightConnector@RenderOTW@@IAEXHHH@Z ; RenderOTW::DrawRightConnector
	jmp	SHORT $LN14@DrawConnec
$LN13@DrawConnec:

; 1813 : 
; 1814 : 
; 1815 : 	// BOTTOM_SPAN -- Horizontal (Sector 3 and 4)
; 1816 : 	span = LODdata[LOD].glueOnBottom ? outterSpan : outterSpan+1;

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	cmp	DWORD PTR [eax+ecx+48], 0
	je	SHORT $LN39@DrawConnec
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	DWORD PTR tv213[ebp], ecx
	jmp	SHORT $LN40@DrawConnec
$LN39@DrawConnec:
	mov	edx, DWORD PTR _outterSpan$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR tv213[ebp], edx
$LN40@DrawConnec:
	mov	eax, DWORD PTR tv213[ebp]
	mov	DWORD PTR _span$[ebp], eax

; 1817 : 
; 1818 : 	crossOver = max( span->Bsector.startDraw, LODdata[LOD].glueOnLeft ); 

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [edx+76]
	cmp	edx, DWORD PTR [eax+ecx+52]
	jle	SHORT $LN41@DrawConnec
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv227[ebp], ecx
	jmp	SHORT $LN42@DrawConnec
$LN41@DrawConnec:
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+52]
	mov	DWORD PTR tv227[ebp], edx
$LN42@DrawConnec:
	mov	eax, DWORD PTR tv227[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1819 : 	for ( c = span->Bsector.stopDraw; c >= crossOver; c-=2 )	DrawDownConnector( -span->ring+1, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR _c$[ebp], edx
	jmp	SHORT $LN12@DrawConnec
$LN11@DrawConnec:
	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 2
	mov	DWORD PTR _c$[ebp], eax
$LN12@DrawConnec:
	mov	ecx, DWORD PTR _c$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN10@DrawConnec
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDownConnector@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawDownConnector
	jmp	SHORT $LN11@DrawConnec
$LN10@DrawConnec:

; 1820 : 
; 1821 : 	crossOver = min( span->Bsector.stopDraw, -2+LODdata[LOD].glueOnLeft ); 

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [edx+eax+52]
	sub	eax, 2
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+80], eax
	jge	SHORT $LN43@DrawConnec
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR tv254[ebp], eax
	jmp	SHORT $LN44@DrawConnec
$LN43@DrawConnec:
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	ecx, DWORD PTR [eax+ecx+52]
	sub	ecx, 2
	mov	DWORD PTR tv254[ebp], ecx
$LN44@DrawConnec:
	mov	edx, DWORD PTR tv254[ebp]
	mov	DWORD PTR _crossOver$[ebp], edx

; 1822 : 	for ( c = span->Bsector.startDraw; c <= crossOver; c+=2 )	DrawDownConnector( -span->ring+1, c, LOD );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _c$[ebp], ecx
	jmp	SHORT $LN9@DrawConnec
$LN8@DrawConnec:
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 2
	mov	DWORD PTR _c$[ebp], edx
$LN9@DrawConnec:
	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN7@DrawConnec
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDownConnector@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawDownConnector
	jmp	SHORT $LN8@DrawConnec
$LN7@DrawConnec:

; 1823 : 
; 1824 : 	
; 1825 : 	// LEFT_SPAN -- Vertical (Sector 5 and 6)
; 1826 : 	span = LODdata[LOD].glueOnLeft ? outterSpan : outterSpan+1;

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+52], 0
	je	SHORT $LN45@DrawConnec
	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	DWORD PTR tv272[ebp], edx
	jmp	SHORT $LN46@DrawConnec
$LN45@DrawConnec:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR tv272[ebp], eax
$LN46@DrawConnec:
	mov	ecx, DWORD PTR tv272[ebp]
	mov	DWORD PTR _span$[ebp], ecx

; 1827 : 
; 1828 : 	crossOver = max( span->Lsector.startDraw, LODdata[LOD].glueOnBottom ); 

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax+104]
	cmp	eax, DWORD PTR [ecx+edx+48]
	jle	SHORT $LN47@DrawConnec
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR tv286[ebp], edx
	jmp	SHORT $LN48@DrawConnec
$LN47@DrawConnec:
	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [edx+eax+48]
	mov	DWORD PTR tv286[ebp], eax
$LN48@DrawConnec:
	mov	ecx, DWORD PTR tv286[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1829 : 	for ( r = span->Lsector.stopDraw; r >= crossOver; r-=2 )	DrawLeftConnector( r, -span->ring+1, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _r$[ebp], eax
	jmp	SHORT $LN6@DrawConnec
$LN5@DrawConnec:
	mov	ecx, DWORD PTR _r$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _r$[ebp], ecx
$LN6@DrawConnec:
	mov	edx, DWORD PTR _r$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN4@DrawConnec
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLeftConnector@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawLeftConnector
	jmp	SHORT $LN5@DrawConnec
$LN4@DrawConnec:

; 1830 : 
; 1831 : 	crossOver = min( span->Lsector.stopDraw, -2+LODdata[LOD].glueOnBottom ); 

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	ecx, DWORD PTR [eax+ecx+48]
	sub	ecx, 2
	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+108], ecx
	jge	SHORT $LN49@DrawConnec
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR tv313[ebp], ecx
	jmp	SHORT $LN50@DrawConnec
$LN49@DrawConnec:
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+48]
	sub	edx, 2
	mov	DWORD PTR tv313[ebp], edx
$LN50@DrawConnec:
	mov	eax, DWORD PTR tv313[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1832 : 	for ( r = span->Lsector.startDraw; r <= crossOver; r+=2 )	DrawLeftConnector( r, -span->ring+1, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR _r$[ebp], edx
	jmp	SHORT $LN3@DrawConnec
$LN2@DrawConnec:
	mov	eax, DWORD PTR _r$[ebp]
	add	eax, 2
	mov	DWORD PTR _r$[ebp], eax
$LN3@DrawConnec:
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN25@DrawConnec
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLeftConnector@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawLeftConnector
	jmp	SHORT $LN2@DrawConnec
$LN25@DrawConnec:

; 1833 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawConnectorRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z ENDP ; RenderOTW::DrawConnectorRing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv206 = -52						; size = 4
tv192 = -48						; size = 4
tv176 = -44						; size = 4
tv162 = -40						; size = 4
tv146 = -36						; size = 4
tv132 = -32						; size = 4
tv85 = -28						; size = 4
tv71 = -24						; size = 4
_this$ = -20						; size = 4
_LOD$ = -16						; size = 4
_crossOver$ = -12					; size = 4
_r$ = -8						; size = 4
_c$ = -4						; size = 4
_span$ = 8						; size = 4
?DrawTerrainRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z PROC ; RenderOTW::DrawTerrainRing
; _this$ = ecx

; 1733 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1734 : 	int				LOD		 = span->LOD;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _LOD$[ebp], ecx

; 1735 : 	register int	r, c;
; 1736 : 	int				crossOver;
; 1737 : 
; 1738 : 
; 1739 : 	// TOP_SPAN -- Horizontal (Sector 0 and 7)
; 1740 : 	r = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _r$[ebp], eax

; 1741 : 
; 1742 : 	crossOver = max( span->Tsector.startDraw, 0 ); 

	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jle	SHORT $LN27@DrawTerrai
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN28@DrawTerrai
$LN27@DrawTerrai:
	mov	DWORD PTR tv71[ebp], 0
$LN28@DrawTerrai:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1743 : 	for ( c = span->Tsector.stopDraw; c >= crossOver; c-- )		DrawTerrainSquare( r, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN24@DrawTerrai
$LN23@DrawTerrai:
	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx
$LN24@DrawTerrai:
	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN22@DrawTerrai
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN23@DrawTerrai
$LN22@DrawTerrai:

; 1744 : 
; 1745 : 	crossOver = min( span->Tsector.stopDraw, -1 ); 

	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jge	SHORT $LN29@DrawTerrai
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR tv85[ebp], edx
	jmp	SHORT $LN30@DrawTerrai
$LN29@DrawTerrai:
	mov	DWORD PTR tv85[ebp], -1
$LN30@DrawTerrai:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1746 : 	for ( c = span->Tsector.startDraw; c <= crossOver; c++ )	DrawTerrainSquare( r, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _c$[ebp], edx
	jmp	SHORT $LN21@DrawTerrai
$LN20@DrawTerrai:
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _c$[ebp], eax
$LN21@DrawTerrai:
	mov	ecx, DWORD PTR _c$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN19@DrawTerrai
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN20@DrawTerrai
$LN19@DrawTerrai:

; 1747 : 
; 1748 : 		
; 1749 : 	// RIGHT_SPAN -- Vertical (Sector 1 and 2)
; 1750 : 	c = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax

; 1751 : 
; 1752 : 	crossOver = max( span->Rsector.startDraw, 0 ); 

	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jle	SHORT $LN31@DrawTerrai
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN32@DrawTerrai
$LN31@DrawTerrai:
	mov	DWORD PTR tv132[ebp], 0
$LN32@DrawTerrai:
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1753 : 	for ( r = span->Rsector.stopDraw; r >= crossOver; r-- )		DrawTerrainSquare( r, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _r$[ebp], eax
	jmp	SHORT $LN18@DrawTerrai
$LN17@DrawTerrai:
	mov	ecx, DWORD PTR _r$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _r$[ebp], ecx
$LN18@DrawTerrai:
	mov	edx, DWORD PTR _r$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN16@DrawTerrai
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN17@DrawTerrai
$LN16@DrawTerrai:

; 1754 : 
; 1755 : 	crossOver = min( span->Rsector.stopDraw, -1 ); 

	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+52], -1
	jge	SHORT $LN33@DrawTerrai
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR tv146[ebp], edx
	jmp	SHORT $LN34@DrawTerrai
$LN33@DrawTerrai:
	mov	DWORD PTR tv146[ebp], -1
$LN34@DrawTerrai:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1756 : 	for ( r = span->Rsector.startDraw; r <= crossOver; r++ )	DrawTerrainSquare( r, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _r$[ebp], edx
	jmp	SHORT $LN15@DrawTerrai
$LN14@DrawTerrai:
	mov	eax, DWORD PTR _r$[ebp]
	add	eax, 1
	mov	DWORD PTR _r$[ebp], eax
$LN15@DrawTerrai:
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN13@DrawTerrai
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN14@DrawTerrai
$LN13@DrawTerrai:

; 1757 : 
; 1758 : 
; 1759 : 	// BOTTOM_SPAN -- Horizontal (Sector 3 and 4)
; 1760 : 	r = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	DWORD PTR _r$[ebp], eax

; 1761 : 
; 1762 : 	crossOver = max( span->Bsector.startDraw, 0 ); 

	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	jle	SHORT $LN35@DrawTerrai
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN36@DrawTerrai
$LN35@DrawTerrai:
	mov	DWORD PTR tv162[ebp], 0
$LN36@DrawTerrai:
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1763 : 	for ( c = span->Bsector.stopDraw; c >= crossOver; c-- )		DrawTerrainSquare( r, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN12@DrawTerrai
$LN11@DrawTerrai:
	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx
$LN12@DrawTerrai:
	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN10@DrawTerrai
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN11@DrawTerrai
$LN10@DrawTerrai:

; 1764 : 
; 1765 : 	crossOver = min( span->Bsector.stopDraw, -1 ); 

	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+80], -1
	jge	SHORT $LN37@DrawTerrai
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR tv176[ebp], edx
	jmp	SHORT $LN38@DrawTerrai
$LN37@DrawTerrai:
	mov	DWORD PTR tv176[ebp], -1
$LN38@DrawTerrai:
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1766 : 	for ( c = span->Bsector.startDraw; c <= crossOver; c++ )	DrawTerrainSquare( r, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR _c$[ebp], edx
	jmp	SHORT $LN9@DrawTerrai
$LN8@DrawTerrai:
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _c$[ebp], eax
$LN9@DrawTerrai:
	mov	ecx, DWORD PTR _c$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN7@DrawTerrai
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN8@DrawTerrai
$LN7@DrawTerrai:

; 1767 : 
; 1768 : 
; 1769 : 	// LEFT_SPAN -- Vertical (Sector 5 and 6)
; 1770 : 	c = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	DWORD PTR _c$[ebp], eax

; 1771 : 
; 1772 : 	crossOver = max( span->Lsector.startDraw, 0 ); 

	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	jle	SHORT $LN39@DrawTerrai
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR tv192[ebp], eax
	jmp	SHORT $LN40@DrawTerrai
$LN39@DrawTerrai:
	mov	DWORD PTR tv192[ebp], 0
$LN40@DrawTerrai:
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR _crossOver$[ebp], ecx

; 1773 : 	for ( r = span->Lsector.stopDraw; r >= crossOver; r-- )		DrawTerrainSquare( r, c, LOD );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _r$[ebp], eax
	jmp	SHORT $LN6@DrawTerrai
$LN5@DrawTerrai:
	mov	ecx, DWORD PTR _r$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _r$[ebp], ecx
$LN6@DrawTerrai:
	mov	edx, DWORD PTR _r$[ebp]
	cmp	edx, DWORD PTR _crossOver$[ebp]
	jl	SHORT $LN4@DrawTerrai
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN5@DrawTerrai
$LN4@DrawTerrai:

; 1774 : 
; 1775 : 	crossOver = min( span->Lsector.stopDraw, -1 ); 

	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+108], -1
	jge	SHORT $LN41@DrawTerrai
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR tv206[ebp], edx
	jmp	SHORT $LN42@DrawTerrai
$LN41@DrawTerrai:
	mov	DWORD PTR tv206[ebp], -1
$LN42@DrawTerrai:
	mov	eax, DWORD PTR tv206[ebp]
	mov	DWORD PTR _crossOver$[ebp], eax

; 1776 : 	for ( r = span->Lsector.startDraw; r <= crossOver; r++ )	DrawTerrainSquare( r, c, LOD );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR _r$[ebp], edx
	jmp	SHORT $LN3@DrawTerrai
$LN2@DrawTerrai:
	mov	eax, DWORD PTR _r$[ebp]
	add	eax, 1
	mov	DWORD PTR _r$[ebp], eax
$LN3@DrawTerrai:
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR _crossOver$[ebp]
	jg	SHORT $LN25@DrawTerrai
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTerrainSquare@RenderOTW@@IAEXHHH@Z	; RenderOTW::DrawTerrainSquare
	jmp	SHORT $LN2@DrawTerrai
$LN25@DrawTerrai:

; 1777 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawTerrainRing@RenderOTW@@IAEXPAUSpanListEntry@@@Z ENDP ; RenderOTW::DrawTerrainRing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_percent$ = 8						; size = 4
_color$ = 12						; size = 4
?PreSceneCloudOcclusion@RenderOTW@@IAEXMK@Z PROC	; RenderOTW::PreSceneCloudOcclusion
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 	// If we're in software, we turn on the special color munging function
; 411  : 	if ( image->GetDisplayDevice()->IsHardware() ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?GetDisplayDevice@ImageBuffer@@QAEPAVDisplayDevice@@XZ ; ImageBuffer::GetDisplayDevice
	mov	ecx, eax
	call	?IsHardware@DisplayDevice@@QAEHXZ	; DisplayDevice::IsHardware
	test	eax, eax
	je	SHORT $LN2@PreSceneCl

; 412  : 
; 413  : 		// Save the cloud color with alpha for post processing use.
; 414  : 		cloudColor = (color & 0x00FFFFFF) | (FloatToInt32(percent * 255.9f) << 24);

	mov	esi, DWORD PTR _color$[ebp]
	and	esi, 16777215				; 00ffffffH
	movss	xmm0, DWORD PTR _percent$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	shl	eax, 24					; 00000018H
	or	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263252], esi
$LN2@PreSceneCl:

; 415  : 
; 416  : 	} else {
; 417  : 
; 418  : 		// Set the MPR color correction terms to get "fade out"
; 419  : 		// TODO:  Update this once Marc's changes are in...
; 420  : #if 1
; 421  : //		context.SetColorCorrection( color, percent );
; 422  : #else
; 423  : 		// This is a total hack to get "green" results on MFDs:
; 424  : 		float correction = 1.0f + percent * percent * 100.0f;
; 425  : 
; 426  : 		// Red
; 427  : 		if (((color & 0x000000FF) == 0x0 ) &&
; 428  : 			((color & 0x0000FF00) >= 0x10) &&
; 429  : 			((color & 0x00FF0000) == 0x0 )) {
; 430  : 
; 431  : 			// Guess that we're on a green display
; 432  : //			context.SetState( MPR_STA_GAMMA_RED,   (DWORD)(1.0f) );
; 433  : //			context.SetState( MPR_STA_GAMMA_GREEN, (DWORD)(correction) );
; 434  : //			context.SetState( MPR_STA_GAMMA_BLUE,  (DWORD)(1.0f) );
; 435  : 		} else {
; 436  : 			// Assume a color display
; 437  : //			context.SetState( MPR_STA_GAMMA_RED,   (DWORD)(correction) );
; 438  : //			context.SetState( MPR_STA_GAMMA_GREEN, (DWORD)(correction) );
; 439  : //			context.SetState( MPR_STA_GAMMA_BLUE,  (DWORD)(correction) );
; 440  : 		}
; 441  : #endif
; 442  : 	}
; 443  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?PreSceneCloudOcclusion@RenderOTW@@IAEXMK@Z ENDP	; RenderOTW::PreSceneCloudOcclusion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv834 = -192						; size = 4
tv873 = -188						; size = 4
tv685 = -184						; size = 4
tv880 = -180						; size = 4
tv997 = -176						; size = 4
tv887 = -172						; size = 4
tv901 = -168						; size = 4
tv1042 = -164						; size = 4
tv894 = -160						; size = 4
tv1044 = -156						; size = 4
tv738 = -152						; size = 4
tv220 = -148						; size = 4
tv286 = -144						; size = 4
tv185 = -140						; size = 4
tv437 = -136						; size = 4
tv571 = -132						; size = 4
_dx$1 = -128						; size = 4
tv547 = -124						; size = 4
tv421 = -120						; size = 4
_dz$2 = -116						; size = 4
_dx$3 = -112						; size = 4
_dy$4 = -108						; size = 4
_dz$5 = -104						; size = 4
_inv$ = -100						; size = 4
_iTot$6 = -96						; size = 4
_fog$7 = -92						; size = 4
_range$8 = -88						; size = 4
_fog$ = -84						; size = 4
_iDiff$9 = -80						; size = 4
_i$10 = -76						; size = 4
_range$11 = -72						; size = 4
_scale$ = -68						; size = 4
_i$12 = -64						; size = 4
_row$ = -60						; size = 4
_col$ = -56						; size = 4
_r$ = -52						; size = 4
_g$ = -48						; size = 4
_b$ = -44						; size = 4
_alpha$13 = -40						; size = 4
_alpha$ = -36						; size = 4
_this$ = -32						; size = 4
_lightningColor$14 = -28				; size = 12
_n$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_vert$ = 8						; size = 4
_post$ = 12						; size = 4
_distance$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?ComputeVertexColor@RenderOTW@@MAEXPAUTerrainVertex@@PAUTpost@@MMM@Z PROC ; RenderOTW::ComputeVertexColor
; _this$ = ecx

; 1450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1451 : 	// RED - The Linear fogging conditions
; 1452 : 	// Disable as default
; 1453 : 	TheDXEngine.LinearFog(false);

	push	0
	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?LinearFog@CDXEngine@@QAEX_N@Z		; CDXEngine::LinearFog

; 1454 : 
; 1455 : 	// ***************** COBRA - RED - SINGLE OTW RENDERER / THE NVG VERSION *****************************
; 1456 : 	if(TheTimeOfDay.GetNVGmode()){

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetNVGmode@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetNVGmode
	test	eax, eax
	je	$LN62@ComputeVer

; 1457 : 		float alpha,fog;
; 1458 : 
; 1459 : 		vert->r = 0.f;

	mov	eax, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+8], xmm0

; 1460 : 		vert->b = 0.f;

	mov	ecx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+16], xmm0

; 1461 : 		vert->g = NVG_LIGHT_LEVEL;

	mov	edx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR __real@3f340000
	movss	DWORD PTR [edx+12], xmm0

; 1462 : 
; 1463 : 		if(realWeather->weatherCondition > FAIR){

	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [eax+15688], 2
	jle	$LN61@ComputeVer

; 1464 : 			// if we are lower than overcast layer upper limit, enable Fog...
; 1465 : 			if(realWeather->InsideOvercast() || realWeather->UnderOvercast()) TheDXEngine.LinearFog(true);

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?InsideOvercast@RealWeather@@QAE_NXZ	; RealWeather::InsideOvercast
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN59@ComputeVer
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?UnderOvercast@RealWeather@@QAE_NXZ	; RealWeather::UnderOvercast
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN60@ComputeVer
$LN59@ComputeVer:
	push	1
	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?LinearFog@CDXEngine@@QAEX_N@Z		; CDXEngine::LinearFog
$LN60@ComputeVer:

; 1466 : 			// if we are upper the middle of layer, do not draw grounded objects
; 1467 : 			if(viewpoint->Z() < realWeather->MidOvercast){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?Z@TViewPoint@@QAEMXZ			; TViewPoint::Z
	fstp	DWORD PTR tv685[ebp]
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [ecx+15760]
	comiss	xmm0, DWORD PTR tv685[ebp]
	jbe	SHORT $LN58@ComputeVer

; 1468 : 				vert->RenderingStateHandle = state_far;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263120]
	mov	DWORD PTR [edx+56], ecx

; 1469 : 			} else {

	jmp	SHORT $LN57@ComputeVer
$LN58@ComputeVer:

; 1470 : 				vert->RenderingStateHandle = state_near;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263112]
	mov	DWORD PTR [edx+56], ecx
$LN57@ComputeVer:

; 1471 : 			} 

	jmp	$LN48@ComputeVer
$LN61@ComputeVer:

; 1472 : 		} else if(distance > haze_start+haze_depth+3000){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263080]
	addss	xmm0, DWORD PTR [eax+263084]
	addss	xmm0, DWORD PTR __real@453b8000
	movss	xmm1, DWORD PTR _distance$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN55@ComputeVer

; 1473 : 			vert->RenderingStateHandle = state_far;

	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263120]
	mov	DWORD PTR [ecx+56], eax
	jmp	$LN48@ComputeVer
$LN55@ComputeVer:

; 1474 : 		}
; 1475 : 		else if(distance < PERSPECTIVE_RANGE)

	movss	xmm0, DWORD PTR ?PERSPECTIVE_RANGE@RenderOTW@@2MB
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN53@ComputeVer

; 1476 : 		{
; 1477 : 			vert->RenderingStateHandle = state_fore;

	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263108]
	mov	DWORD PTR [ecx+56], eax
	jmp	SHORT $LN48@ComputeVer
$LN53@ComputeVer:

; 1478 : 		}
; 1479 : 		else if(!hazed && distance < haze_start)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+263096], 0
	jne	SHORT $LN51@ComputeVer
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263080]
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN51@ComputeVer

; 1480 : 		{
; 1481 : 			vert->RenderingStateHandle = state_near;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263112]
	mov	DWORD PTR [eax+56], edx
	jmp	SHORT $LN48@ComputeVer
$LN51@ComputeVer:

; 1482 : 		}
; 1483 : 		else if(distance > haze_start+haze_depth)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263080]
	addss	xmm0, DWORD PTR [ecx+263084]
	movss	xmm1, DWORD PTR _distance$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN49@ComputeVer

; 1484 : 		{
; 1485 : 			vert->RenderingStateHandle = state_far;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263120]
	mov	DWORD PTR [edx+56], ecx

; 1486 : 		}
; 1487 : 		else

	jmp	SHORT $LN48@ComputeVer
$LN49@ComputeVer:

; 1488 : 		{
; 1489 : 			vert->RenderingStateHandle = state_mid;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263116]
	mov	DWORD PTR [edx+56], ecx
$LN48@ComputeVer:

; 1490 : 		}
; 1491 : 
; 1492 : 		if(distance > haze_start + haze_depth)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263080]
	addss	xmm0, DWORD PTR [eax+263084]
	movss	xmm1, DWORD PTR _distance$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN47@ComputeVer

; 1493 : 		{
; 1494 : 			alpha = 0.f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$13[ebp], xmm0
	jmp	$LN37@ComputeVer
$LN47@ComputeVer:

; 1495 : 		}
; 1496 : 		else if(distance < PERSPECTIVE_RANGE)

	movss	xmm0, DWORD PTR ?PERSPECTIVE_RANGE@RenderOTW@@2MB
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN45@ComputeVer

; 1497 : 		{
; 1498 : 			alpha = 1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$13[ebp], xmm0

; 1499 : 		}
; 1500 : 		else

	jmp	$LN37@ComputeVer
$LN45@ComputeVer:

; 1501 : 		{
; 1502 : 			if(hazed)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+263096], 0
	je	$LN43@ComputeVer

; 1503 : 			{
; 1504 : 				fog = min(GetValleyFog(distance,post->z),.6f);

	mov	edx, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetValleyFog@RenderOTW@@QAEMMM@Z	; RenderOTW::GetValleyFog
	fstp	DWORD PTR tv738[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	comiss	xmm0, DWORD PTR tv738[ebp]
	jbe	SHORT $LN65@ComputeVer
	mov	eax, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetValleyFog@RenderOTW@@QAEMMM@Z	; RenderOTW::GetValleyFog
	fstp	DWORD PTR tv185[ebp]
	jmp	SHORT $LN66@ComputeVer
$LN65@ComputeVer:
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv185[ebp], xmm0
$LN66@ComputeVer:
	movss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR _fog$7[ebp], xmm0

; 1505 : 
; 1506 : 				if(distance < haze_start)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263080]
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN42@ComputeVer

; 1507 : 				{
; 1508 : 					alpha = 1.f-fog;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fog$7[ebp]
	movss	DWORD PTR _alpha$13[ebp], xmm0

; 1509 : 				}
; 1510 : 				else

	jmp	SHORT $LN41@ComputeVer
$LN42@ComputeVer:

; 1511 : 				{
; 1512 : 					alpha = GetRangeOnlyFog(distance);

	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z	; RenderOTW::GetRangeOnlyFog
	fstp	DWORD PTR _alpha$13[ebp]

; 1513 : 
; 1514 : 					if(alpha < fog)	alpha = fog;

	movss	xmm0, DWORD PTR _fog$7[ebp]
	comiss	xmm0, DWORD PTR _alpha$13[ebp]
	jbe	SHORT $LN40@ComputeVer
	movss	xmm0, DWORD PTR _fog$7[ebp]
	movss	DWORD PTR _alpha$13[ebp], xmm0
$LN40@ComputeVer:

; 1515 : 
; 1516 : 					alpha = 1.f-alpha;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _alpha$13[ebp]
	movss	DWORD PTR _alpha$13[ebp], xmm0
$LN41@ComputeVer:

; 1517 : 				}
; 1518 : 			}
; 1519 : 			else

	jmp	SHORT $LN37@ComputeVer
$LN43@ComputeVer:

; 1520 : 			{
; 1521 : 				if(distance < haze_start)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263080]
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN38@ComputeVer

; 1522 : 				{
; 1523 : 					alpha = 1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$13[ebp], xmm0

; 1524 : 				}
; 1525 : 				else

	jmp	SHORT $LN37@ComputeVer
$LN38@ComputeVer:

; 1526 : 				{
; 1527 : 					alpha = GetRangeOnlyFog(distance);

	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z	; RenderOTW::GetRangeOnlyFog
	fstp	DWORD PTR _alpha$13[ebp]

; 1528 : 
; 1529 : 					alpha = 1.f-alpha;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _alpha$13[ebp]
	movss	DWORD PTR _alpha$13[ebp], xmm0
$LN37@ComputeVer:

; 1530 : 				}
; 1531 : 			}
; 1532 : 		}
; 1533 : 		vert->a = alpha;

	mov	eax, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _alpha$13[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 1534 : 		return;

	jmp	$LN63@ComputeVer
$LN62@ComputeVer:

; 1535 : 	}
; 1536 : 	// ********************************COBRA - RED - END ********************************************************************
; 1537 : 
; 1538 : 
; 1539 : 	Ppoint n;
; 1540 : 	int row,col;
; 1541 : 	float fog,alpha;
; 1542 : 
; 1543 : 	float scale = min(distance/far_clip,1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _distance$[ebp]
	divss	xmm0, DWORD PTR [ecx+262876]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN67@ComputeVer
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _distance$[ebp]
	divss	xmm0, DWORD PTR [edx+262876]
	movss	DWORD PTR tv220[ebp], xmm0
	jmp	SHORT $LN68@ComputeVer
$LN67@ComputeVer:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv220[ebp], xmm0
$LN68@ComputeVer:
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0

; 1544 : 	float inv = 1.f-scale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR _inv$[ebp], xmm0

; 1545 : 
; 1546 : 	float r = TheMap.ColorTable[post->colorIndex].r*scale+ground_color.r*inv;

	mov	eax, DWORD PTR _post$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	movss	xmm0, DWORD PTR ?TheMap@@3VTMap@@A[ecx]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+263156]
	mulss	xmm1, DWORD PTR _inv$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _r$[ebp], xmm0

; 1547 : 	float g = TheMap.ColorTable[post->colorIndex].g*scale+ground_color.g*inv;

	mov	eax, DWORD PTR _post$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	movss	xmm0, DWORD PTR ?TheMap@@3VTMap@@A[ecx+4]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+263160]
	mulss	xmm1, DWORD PTR _inv$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _g$[ebp], xmm0

; 1548 : 	float b = TheMap.ColorTable[post->colorIndex].b*scale+ground_color.b*inv;

	mov	eax, DWORD PTR _post$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	movss	xmm0, DWORD PTR ?TheMap@@3VTMap@@A[ecx+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+263164]
	mulss	xmm1, DWORD PTR _inv$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _b$[ebp], xmm0

; 1549 : 
; 1550 : 	if(realWeather->weatherCondition > FAIR){

	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [eax+15688], 2
	jle	$LN36@ComputeVer

; 1551 : 		// Setup ground color
; 1552 : 		r = haze_ground_color.r;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263144]
	movss	DWORD PTR _r$[ebp], xmm0

; 1553 : 		g = haze_ground_color.g;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263148]
	movss	DWORD PTR _g$[ebp], xmm0

; 1554 : 		b = haze_ground_color.b;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263152]
	movss	DWORD PTR _b$[ebp], xmm0

; 1555 : 		// check for lightining
; 1556 : 		if(realWeather->isLightning){

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [ecx+4], 0
	je	$LN34@ComputeVer

; 1557 : 			Tcolor lightningColor = TheTimeOfDay.GetLightningColor();

	lea	edx, DWORD PTR _lightningColor$14[ebp]
	push	edx
	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetLightningColor@CTimeOfDay@@QAE?AUTcolor@@XZ ; CTimeOfDay::GetLightningColor

; 1558 : 
; 1559 : 			float dx = x-realWeather->lightningGroundPos.x;

	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR _dx$3[ebp], xmm0

; 1560 : 			float dz = distance-realWeather->lightningGroundPos.z; 

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR _distance$[ebp]
	subss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR _dz$5[ebp], xmm0

; 1561 : 
; 1562 : 			float range = FabsF(SqrtF(dx*dx+dz*dz));

	movss	xmm0, DWORD PTR _dx$3[ebp]
	mulss	xmm0, DWORD PTR _dx$3[ebp]
	movss	xmm1, DWORD PTR _dz$5[ebp]
	mulss	xmm1, DWORD PTR _dz$5[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtF@@YAMM@Z				; SqrtF
	fstp	DWORD PTR [esp]
	call	?FabsF@@YAMM@Z				; FabsF
	add	esp, 4
	fstp	DWORD PTR _range$8[ebp]

; 1563 : 
; 1564 : 			if(range < LIGHTNING_RADIUS)

	movss	xmm0, DWORD PTR __real@466a6000
	comiss	xmm0, DWORD PTR _range$8[ebp]
	jbe	$LN34@ComputeVer

; 1565 : 			{
; 1566 : 				float i = max(1.f-(LIGHTNING_RADIUS-range)/LIGHTNING_RADIUS,.5f);

	movss	xmm0, DWORD PTR __real@466a6000
	subss	xmm0, DWORD PTR _range$8[ebp]
	divss	xmm0, DWORD PTR __real@466a6000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@3f000000
	jbe	SHORT $LN69@ComputeVer
	movss	xmm0, DWORD PTR __real@466a6000
	subss	xmm0, DWORD PTR _range$8[ebp]
	divss	xmm0, DWORD PTR __real@466a6000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR tv286[ebp], xmm1
	jmp	SHORT $LN70@ComputeVer
$LN69@ComputeVer:
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv286[ebp], xmm0
$LN70@ComputeVer:
	movss	xmm0, DWORD PTR tv286[ebp]
	movss	DWORD PTR _i$12[ebp], xmm0

; 1567 : 
; 1568 : 				r = ((1.f-i)*lightningColor.r)+(i*r);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _i$12[ebp]
	mulss	xmm0, DWORD PTR _lightningColor$14[ebp]
	movss	xmm1, DWORD PTR _i$12[ebp]
	mulss	xmm1, DWORD PTR _r$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _r$[ebp], xmm0

; 1569 : 				g = ((1.f-i)*lightningColor.g)+(i*g);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _i$12[ebp]
	mulss	xmm0, DWORD PTR _lightningColor$14[ebp+4]
	movss	xmm1, DWORD PTR _i$12[ebp]
	mulss	xmm1, DWORD PTR _g$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _g$[ebp], xmm0

; 1570 : 				b = ((1.f-i)*lightningColor.b)+(i*b);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _i$12[ebp]
	mulss	xmm0, DWORD PTR _lightningColor$14[ebp+8]
	movss	xmm1, DWORD PTR _i$12[ebp]
	mulss	xmm1, DWORD PTR _b$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _b$[ebp], xmm0
$LN34@ComputeVer:

; 1571 : 			}
; 1572 : 		}
; 1573 : 		// if we are lower than overcast layer upper limit, enable Fog...
; 1574 : 		if(realWeather->InsideOvercast() || realWeather->UnderOvercast()) TheDXEngine.LinearFog(true);

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?InsideOvercast@RealWeather@@QAE_NXZ	; RealWeather::InsideOvercast
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN32@ComputeVer
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?UnderOvercast@RealWeather@@QAE_NXZ	; RealWeather::UnderOvercast
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@ComputeVer
$LN32@ComputeVer:
	push	1
	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?LinearFog@CDXEngine@@QAEX_N@Z		; CDXEngine::LinearFog
$LN33@ComputeVer:

; 1575 : 		// if we are upper the middle of layer, do not draw grounded objects
; 1576 : 		if(viewpoint->Z() < realWeather->MidOvercast){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?Z@TViewPoint@@QAEMXZ			; TViewPoint::Z
	fstp	DWORD PTR tv834[ebp]
	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [edx+15760]
	comiss	xmm0, DWORD PTR tv834[ebp]
	jbe	SHORT $LN31@ComputeVer

; 1577 : 			vert->RenderingStateHandle = state_far;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263120]
	mov	DWORD PTR [eax+56], edx

; 1578 : 		} else {

	jmp	SHORT $LN30@ComputeVer
$LN31@ComputeVer:

; 1579 : 			vert->RenderingStateHandle = state_near;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263112]
	mov	DWORD PTR [eax+56], edx
$LN30@ComputeVer:

; 1580 : 		}

	jmp	$LN17@ComputeVer
$LN36@ComputeVer:

; 1581 : 	}
; 1582 : 	else if(distance > haze_start+haze_depth)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263080]
	addss	xmm0, DWORD PTR [ecx+263084]
	movss	xmm1, DWORD PTR _distance$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN28@ComputeVer

; 1583 : 	{
; 1584 : 		vert->RenderingStateHandle = state_far;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263120]
	mov	DWORD PTR [edx+56], ecx

; 1585 : 	}
; 1586 : 	else

	jmp	$LN17@ComputeVer
$LN28@ComputeVer:

; 1587 : 	{
; 1588 : 		if(distance < PERSPECTIVE_RANGE)

	movss	xmm0, DWORD PTR ?PERSPECTIVE_RANGE@RenderOTW@@2MB
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN26@ComputeVer

; 1589 : 		{
; 1590 : 			vert->RenderingStateHandle = state_fore;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263108]
	mov	DWORD PTR [edx+56], ecx
	jmp	SHORT $LN23@ComputeVer
$LN26@ComputeVer:

; 1591 : 		}
; 1592 : 		else if(distance < haze_start)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263080]
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN24@ComputeVer

; 1593 : 		{
; 1594 : 			vert->RenderingStateHandle = state_near;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263112]
	mov	DWORD PTR [eax+56], edx

; 1595 : 		}
; 1596 : 		else

	jmp	SHORT $LN23@ComputeVer
$LN24@ComputeVer:

; 1597 : 		{
; 1598 : 			vert->RenderingStateHandle = state_mid;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263116]
	mov	DWORD PTR [eax+56], edx
$LN23@ComputeVer:

; 1599 : 		}
; 1600 : 
; 1601 : 		if(DisplayOptions.bSpecularLighting) // Terrain shading

	movzx	eax, BYTE PTR ?DisplayOptions@@3VDisplayOptionsClass@@A+19
	test	eax, eax
	je	$LN22@ComputeVer

; 1602 : 		{
; 1603 : 			float iDiff = 0.f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _iDiff$9[ebp], xmm0

; 1604 : 
; 1605 : 			if(lightDiffuse)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262976]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN21@ComputeVer

; 1606 : 			{
; 1607 : 				n.x = sinf(post->phi)*cosf(post->theta);

	mov	edx, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	fstp	DWORD PTR tv873[ebp]
	movss	xmm0, DWORD PTR tv873[ebp]
	mov	eax, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv1042[ebp], xmm0
	call	_cosf
	add	esp, 4
	fstp	DWORD PTR tv880[ebp]
	movss	xmm0, DWORD PTR tv1042[ebp]
	mulss	xmm0, DWORD PTR tv880[ebp]
	movss	DWORD PTR _n$[ebp], xmm0

; 1608 : 				n.y = sinf(post->phi)*sinf(post->theta);

	mov	ecx, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	fstp	DWORD PTR tv887[ebp]
	movss	xmm0, DWORD PTR tv887[ebp]
	mov	edx, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [edx+24]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv1044[ebp], xmm0
	call	_sinf
	add	esp, 4
	fstp	DWORD PTR tv894[ebp]
	movss	xmm0, DWORD PTR tv1044[ebp]
	mulss	xmm0, DWORD PTR tv894[ebp]
	movss	DWORD PTR _n$[ebp+4], xmm0

; 1609 : 				n.z = -cosf(post->phi);

	mov	eax, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	fstp	DWORD PTR tv901[ebp]
	movss	xmm0, DWORD PTR tv901[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _n$[ebp+8], xmm0

; 1610 : 	
; 1611 : 				iDiff = max(n.x*lightVector.x+n.y*lightVector.y+n.z*lightVector.z,0.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _n$[ebp]
	mulss	xmm0, DWORD PTR [ecx+262984]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _n$[ebp+4]
	mulss	xmm1, DWORD PTR [edx+262988]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _n$[ebp+8]
	mulss	xmm1, DWORD PTR [eax+262992]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN71@ComputeVer
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _n$[ebp]
	mulss	xmm0, DWORD PTR [ecx+262984]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _n$[ebp+4]
	mulss	xmm1, DWORD PTR [edx+262988]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _n$[ebp+8]
	mulss	xmm1, DWORD PTR [eax+262992]
	addss	xmm0, xmm1
	movss	DWORD PTR tv421[ebp], xmm0
	jmp	SHORT $LN72@ComputeVer
$LN71@ComputeVer:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv421[ebp], xmm0
$LN72@ComputeVer:
	movss	xmm0, DWORD PTR tv421[ebp]
	movss	DWORD PTR _iDiff$9[ebp], xmm0
$LN21@ComputeVer:

; 1612 : 			}
; 1613 : 
; 1614 : 			float iTot = min(lightAmbient+iDiff,1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262972]
	addss	xmm0, DWORD PTR _iDiff$9[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN73@ComputeVer
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262972]
	addss	xmm0, DWORD PTR _iDiff$9[ebp]
	movss	DWORD PTR tv437[ebp], xmm0
	jmp	SHORT $LN74@ComputeVer
$LN73@ComputeVer:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv437[ebp], xmm0
$LN74@ComputeVer:
	movss	xmm0, DWORD PTR tv437[ebp]
	movss	DWORD PTR _iTot$6[ebp], xmm0

; 1615 : 
; 1616 : 			r *= iTot;

	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR _iTot$6[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 1617 : 			g *= iTot;

	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR _iTot$6[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 1618 : 			b *= iTot;

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _iTot$6[ebp]
	movss	DWORD PTR _b$[ebp], xmm0
$LN22@ComputeVer:

; 1619 : 		}
; 1620 : 
; 1621 : 		if(PlayerOptions.ShadowsOn() && realWeather->weatherCondition == FAIR)

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ShadowsOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::ShadowsOn
	test	eax, eax
	je	$LN17@ComputeVer
	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [eax+15688], 2
	jne	$LN17@ComputeVer

; 1622 : 		{
; 1623 : 			for(row = realWeather->shadowCell; row < realWeather->numCells-realWeather->shadowCell; row++)

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	mov	edx, DWORD PTR [ecx+15672]
	mov	DWORD PTR _row$[ebp], edx
	jmp	SHORT $LN19@ComputeVer
$LN18@ComputeVer:
	mov	eax, DWORD PTR _row$[ebp]
	add	eax, 1
	mov	DWORD PTR _row$[ebp], eax
$LN19@ComputeVer:
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	mov	eax, DWORD PTR [ecx+15660]
	sub	eax, DWORD PTR [edx+15672]
	cmp	DWORD PTR _row$[ebp], eax
	jge	$LN17@ComputeVer

; 1624 : 			{
; 1625 : 				for(col = realWeather->shadowCell; col < realWeather->numCells-realWeather->shadowCell; col++)

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	mov	edx, DWORD PTR [ecx+15672]
	mov	DWORD PTR _col$[ebp], edx
	jmp	SHORT $LN16@ComputeVer
$LN15@ComputeVer:
	mov	eax, DWORD PTR _col$[ebp]
	add	eax, 1
	mov	DWORD PTR _col$[ebp], eax
$LN16@ComputeVer:
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	mov	eax, DWORD PTR [ecx+15660]
	sub	eax, DWORD PTR [edx+15672]
	cmp	DWORD PTR _col$[ebp], eax
	jge	$LN14@ComputeVer

; 1626 : 				{
; 1627 : 					if(realWeather->weatherCellArray[row][col].onScreen)

	mov	ecx, DWORD PTR _row$[ebp]
	imul	ecx, 1728				; 000006c0H
	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	lea	eax, DWORD PTR [edx+ecx+108]
	mov	ecx, DWORD PTR _col$[ebp]
	imul	ecx, 192				; 000000c0H
	cmp	DWORD PTR [eax+ecx], 0
	je	$LN12@ComputeVer

; 1628 : 					{
; 1629 : 						float dx = x-realWeather->weatherCellArray[row][col].shadowPos.x;

	mov	edx, DWORD PTR _row$[ebp]
	imul	edx, 1728				; 000006c0H
	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	lea	ecx, DWORD PTR [eax+edx+108]
	mov	edx, DWORD PTR _col$[ebp]
	imul	edx, 192				; 000000c0H
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [ecx+edx+4]
	movss	DWORD PTR _dx$1[ebp], xmm0

; 1630 : 						float dy = y-realWeather->weatherCellArray[row][col].shadowPos.y;

	mov	eax, DWORD PTR _row$[ebp]
	imul	eax, 1728				; 000006c0H
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	lea	edx, DWORD PTR [ecx+eax+108]
	mov	eax, DWORD PTR _col$[ebp]
	imul	eax, 192				; 000000c0H
	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [edx+eax+8]
	movss	DWORD PTR _dy$4[ebp], xmm0

; 1631 : 						float dz = distance-realWeather->weatherCellArray[row][col].shadowPos.z; 

	mov	ecx, DWORD PTR _row$[ebp]
	imul	ecx, 1728				; 000006c0H
	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	lea	eax, DWORD PTR [edx+ecx+108]
	mov	ecx, DWORD PTR _col$[ebp]
	imul	ecx, 192				; 000000c0H
	movss	xmm0, DWORD PTR _distance$[ebp]
	subss	xmm0, DWORD PTR [eax+ecx+12]
	movss	DWORD PTR _dz$2[ebp], xmm0

; 1632 : 						float range = FabsF(SqrtF(dx*dx+dy*dy+dz*dz));

	movss	xmm0, DWORD PTR _dx$1[ebp]
	mulss	xmm0, DWORD PTR _dx$1[ebp]
	movss	xmm1, DWORD PTR _dy$4[ebp]
	mulss	xmm1, DWORD PTR _dy$4[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$2[ebp]
	mulss	xmm1, DWORD PTR _dz$2[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtF@@YAMM@Z				; SqrtF
	fstp	DWORD PTR [esp]
	call	?FabsF@@YAMM@Z				; FabsF
	add	esp, 4
	fstp	DWORD PTR _range$11[ebp]

; 1633 : 
; 1634 : 						if(range < realWeather->cloudRadius)

	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [edx+15736]
	comiss	xmm0, DWORD PTR _range$11[ebp]
	jbe	$LN12@ComputeVer

; 1635 : 						{
; 1636 : 							float i = max(1.f-(realWeather->cloudRadius-range)/realWeather->cloudRadius,.5f);

	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [eax+15736]
	subss	xmm0, DWORD PTR _range$11[ebp]
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	divss	xmm0, DWORD PTR [ecx+15736]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@3f000000
	jbe	SHORT $LN75@ComputeVer
	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [edx+15736]
	subss	xmm0, DWORD PTR _range$11[ebp]
	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	divss	xmm0, DWORD PTR [eax+15736]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR tv547[ebp], xmm1
	jmp	SHORT $LN76@ComputeVer
$LN75@ComputeVer:
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv547[ebp], xmm0
$LN76@ComputeVer:
	movss	xmm0, DWORD PTR tv547[ebp]
	movss	DWORD PTR _i$10[ebp], xmm0

; 1637 : 	
; 1638 : 							r *= i;

	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR _i$10[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 1639 : 							g *= i;

	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR _i$10[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 1640 : 							b *= i;

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _i$10[ebp]
	movss	DWORD PTR _b$[ebp], xmm0
$LN12@ComputeVer:

; 1641 : 						}
; 1642 : 					}
; 1643 : 				}

	jmp	$LN15@ComputeVer
$LN14@ComputeVer:

; 1644 : 			}

	jmp	$LN18@ComputeVer
$LN17@ComputeVer:

; 1645 : 		}
; 1646 : 		/*else if(realWeather->weatherCondition > FAIR)
; 1647 : 		{
; 1648 : 			if((-viewpoint->Z()) > (-realWeather->stratusZ))
; 1649 : 			{
; 1650 : 				r = haze_ground_color.r;
; 1651 : 				g = haze_ground_color.g;
; 1652 : 				b = haze_ground_color.b;
; 1653 : 			}
; 1654 : 			else if(realWeather->isLightning)
; 1655 : 			{
; 1656 : 				Tcolor lightningColor = TheTimeOfDay.GetLightningColor();
; 1657 : 	
; 1658 : 				float dx = x-realWeather->lightningGroundPos.x;
; 1659 : 				float dz = distance-realWeather->lightningGroundPos.z; 
; 1660 : 
; 1661 : 				float range = FabsF(SqrtF(dx*dx+dz*dz));
; 1662 : 
; 1663 : 				if(range < LIGHTNING_RADIUS)
; 1664 : 				{
; 1665 : 					float i = max(1.f-(LIGHTNING_RADIUS-range)/LIGHTNING_RADIUS,.5f);
; 1666 : 	
; 1667 : 					r = ((1.f-i)*lightningColor.r)+(i*r);
; 1668 : 					g = ((1.f-i)*lightningColor.g)+(i*g);
; 1669 : 					b = ((1.f-i)*lightningColor.b)+(i*b);
; 1670 : 				}
; 1671 : 			}
; 1672 : 		}*/
; 1673 : 	}
; 1674 : 
; 1675 : 	if(distance > haze_start+haze_depth)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263080]
	addss	xmm0, DWORD PTR [edx+263084]
	movss	xmm1, DWORD PTR _distance$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@ComputeVer

; 1676 : 	{
; 1677 : 		alpha = 0.f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$[ebp], xmm0
	jmp	$LN1@ComputeVer
$LN11@ComputeVer:

; 1678 : 	}
; 1679 : 	else if(distance < PERSPECTIVE_RANGE)

	movss	xmm0, DWORD PTR ?PERSPECTIVE_RANGE@RenderOTW@@2MB
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN9@ComputeVer

; 1680 : 	{
; 1681 : 		alpha = 1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$[ebp], xmm0

; 1682 : 	}
; 1683 : 	else

	jmp	$LN1@ComputeVer
$LN9@ComputeVer:

; 1684 : 	{
; 1685 : 		if(hazed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+263096], 0
	je	$LN7@ComputeVer

; 1686 : 		{
; 1687 : 			fog = min(GetValleyFog(distance,post->z),.6f);

	mov	ecx, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetValleyFog@RenderOTW@@QAEMMM@Z	; RenderOTW::GetValleyFog
	fstp	DWORD PTR tv997[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	comiss	xmm0, DWORD PTR tv997[ebp]
	jbe	SHORT $LN77@ComputeVer
	mov	edx, DWORD PTR _post$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetValleyFog@RenderOTW@@QAEMMM@Z	; RenderOTW::GetValleyFog
	fstp	DWORD PTR tv571[ebp]
	jmp	SHORT $LN78@ComputeVer
$LN77@ComputeVer:
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv571[ebp], xmm0
$LN78@ComputeVer:
	movss	xmm0, DWORD PTR tv571[ebp]
	movss	DWORD PTR _fog$[ebp], xmm0

; 1688 : 
; 1689 : 			if(distance < haze_start)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263080]
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN6@ComputeVer

; 1690 : 			{
; 1691 : 				alpha = 1.f-fog;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _fog$[ebp]
	movss	DWORD PTR _alpha$[ebp], xmm0

; 1692 : 			}
; 1693 : 			else

	jmp	SHORT $LN5@ComputeVer
$LN6@ComputeVer:

; 1694 : 			{
; 1695 : 				alpha = GetRangeOnlyFog(distance);

	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z	; RenderOTW::GetRangeOnlyFog
	fstp	DWORD PTR _alpha$[ebp]

; 1696 : 
; 1697 : 				if(alpha < fog)	alpha = fog;

	movss	xmm0, DWORD PTR _fog$[ebp]
	comiss	xmm0, DWORD PTR _alpha$[ebp]
	jbe	SHORT $LN4@ComputeVer
	movss	xmm0, DWORD PTR _fog$[ebp]
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN4@ComputeVer:

; 1698 : 
; 1699 : 				alpha = 1.f-alpha;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _alpha$[ebp]
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN5@ComputeVer:

; 1700 : 			}
; 1701 : 		}
; 1702 : 		else

	jmp	SHORT $LN1@ComputeVer
$LN7@ComputeVer:

; 1703 : 		{
; 1704 : 			if(distance < haze_start)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263080]
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN2@ComputeVer

; 1705 : 			{
; 1706 : 				alpha = 1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$[ebp], xmm0

; 1707 : 			}
; 1708 : 			else

	jmp	SHORT $LN1@ComputeVer
$LN2@ComputeVer:

; 1709 : 			{
; 1710 : 				alpha = GetRangeOnlyFog(distance);

	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z	; RenderOTW::GetRangeOnlyFog
	fstp	DWORD PTR _alpha$[ebp]

; 1711 : 
; 1712 : 				alpha = 1.f-alpha;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _alpha$[ebp]
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN1@ComputeVer:

; 1713 : 			}
; 1714 : 		}
; 1715 : 	}
; 1716 : 
; 1717 : 
; 1718 : 	vert->r = r;

	mov	edx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 1719 : 	vert->g = g;

	mov	eax, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 1720 : 	vert->b = b;

	mov	ecx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 1721 : 	vert->a = alpha;

	mov	edx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _alpha$[ebp]
	movss	DWORD PTR [edx+20], xmm0

; 1722 : 
; 1723 : 	context.SetTVmode(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetTVmode@ContextMPR@@QAEXH@Z		; ContextMPR::SetTVmode

; 1724 : 	context.SetIRmode(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetIRmode@ContextMPR@@QAEXH@Z		; ContextMPR::SetIRmode

; 1725 : 	TheStateStack.SetFog(alpha,(Pcolor*)GetFogColor());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFogColor@RenderOTW@@QAEPAUTcolor@@XZ ; RenderOTW::GetFogColor
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _alpha$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SetFog@StateStackClass@@SAXMPAUPcolor@@@Z ; StateStackClass::SetFog
	add	esp, 8
$LN63@ComputeVer:

; 1726 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ComputeVertexColor@RenderOTW@@MAEXPAUTerrainVertex@@PAUTpost@@MMM@Z ENDP ; RenderOTW::ComputeVertexColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_levelStop$ = -80					; size = 4
tv489 = -76						; size = 4
tv476 = -72						; size = 4
_vertStep$ = -68					; size = 4
_OneOverZ$1 = -64					; size = 4
_dz$ = -60						; size = 4
_zVector$ = -56						; size = 4
_y$ = -52						; size = 4
_x$ = -48						; size = 4
_hVector$ = -44						; size = 4
_levelRow$ = -40					; size = 4
_levelCol$ = -36					; size = 4
_z$ = -32						; size = 4
_pChange$ = -28						; size = 4
_post$ = -24						; size = 4
_scratch_y$ = -20					; size = 4
_scratch_x$ = -16					; size = 4
_scratch_z$ = -12					; size = 4
_vert$ = -8						; size = 4
_this$ = -4						; size = 4
_row$ = 8						; size = 4
_col$ = 12						; size = 4
_run$ = 16						; size = 4
_LOD$ = 20						; size = 4
_do_row$ = 24						; size = 4
?TransformRun@RenderOTW@@IAEXHHHHH@Z PROC		; RenderOTW::TransformRun
; _this$ = ecx

; 1242 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 1243 : 	register TerrainVertex	*vert;
; 1244 : 	register Tpost			*post;
; 1245 : 	int						levelRow, levelCol, levelStop;
; 1246 : 	float					scratch_x, scratch_y, scratch_z;
; 1247 : 	float					x, y, z, dz;
; 1248 : 	int						*pChange;
; 1249 : 	float					*hVector;
; 1250 : 	float					*zVector;
; 1251 : 	int						vertStep;
; 1252 : 
; 1253 : 
; 1254 : 	// Dump out if we have nothing to do
; 1255 : 	if (run <= 0)

	cmp	DWORD PTR _run$[ebp], 0
	jg	SHORT $LN14@TransformR

; 1256 : 		return;

	jmp	$LN15@TransformR
$LN14@TransformR:

; 1257 : 
; 1258 : 	// Select which variable to increment based on whether we're doing rows or columns
; 1259 : 	if ( do_row ) {

	cmp	DWORD PTR _do_row$[ebp], 0
	je	SHORT $LN13@TransformR

; 1260 : 		pChange = &levelCol;

	lea	eax, DWORD PTR _levelCol$[ebp]
	mov	DWORD PTR _pChange$[ebp], eax

; 1261 : 		hVector = LODdata[LOD].Ystep;

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	lea	ecx, DWORD PTR [eax+ecx+12]
	mov	DWORD PTR _hVector$[ebp], ecx

; 1262 : 		vertStep = 1;

	mov	DWORD PTR _vertStep$[ebp], 1

; 1263 : 	} else {

	jmp	SHORT $LN12@TransformR
$LN13@TransformR:

; 1264 : 		pChange = &levelRow;

	lea	edx, DWORD PTR _levelRow$[ebp]
	mov	DWORD PTR _pChange$[ebp], edx

; 1265 : 		hVector = LODdata[LOD].Xstep;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	add	edx, eax
	mov	DWORD PTR _hVector$[ebp], edx

; 1266 : 		vertStep = maxSpanExtent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263336]
	mov	DWORD PTR _vertStep$[ebp], ecx
$LN12@TransformR:

; 1267 : 	}
; 1268 : 	zVector = LODdata[LOD].Zstep;

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	lea	edx, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _zVector$[ebp], edx

; 1269 : 
; 1270 : 
; 1271 : 	// Find the coordinates of the first post to transform FROM
; 1272 : 	levelRow	 = row + LODdata[LOD].centerRow;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	ecx, DWORD PTR _row$[ebp]
	add	ecx, DWORD PTR [edx+eax+40]
	mov	DWORD PTR _levelRow$[ebp], ecx

; 1273 : 	levelCol	 = col + LODdata[LOD].centerCol;

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _col$[ebp]
	add	eax, DWORD PTR [ecx+edx+44]
	mov	DWORD PTR _levelCol$[ebp], eax

; 1274 : 	levelStop	= *pChange + run;

	mov	ecx, DWORD PTR _pChange$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _run$[ebp]
	mov	DWORD PTR _levelStop$[ebp], edx

; 1275 : 
; 1276 : 
; 1277 : 	// Find the storage location for the first vertex to transform INTO
; 1278 : 	vert =	vertexBuffer[LOD] + maxSpanExtent*row + col;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263336]
	imul	eax, DWORD PTR _row$[ebp]
	imul	eax, 60					; 0000003cH
	mov	edx, DWORD PTR _LOD$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, eax
	mov	edx, DWORD PTR _col$[ebp]
	imul	edx, 60					; 0000003cH
	add	ecx, edx
	mov	DWORD PTR _vert$[ebp], ecx

; 1279 : 
; 1280 : 	// Get the this post from the terrain database
; 1281 : 	post = viewpoint->GetPost( levelRow, levelCol, LOD );

	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _levelCol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _levelRow$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetPost@TViewPoint@@QAEPAUTpost@@HHH@Z	; TViewPoint::GetPost
	mov	DWORD PTR _post$[ebp], eax

; 1282 : 	ShiAssert( post );
; 1283 : 
; 1284 : 	// Compute our world space starting location
; 1285 : 	x = LEVEL_POST_TO_WORLD( levelRow, LOD );

	mov	edx, DWORD PTR _levelRow$[ebp]
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	movss	DWORD PTR _x$[ebp], xmm0

; 1286 : 	y = LEVEL_POST_TO_WORLD( levelCol, LOD );

	mov	eax, DWORD PTR _levelCol$[ebp]
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	eax, cl
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	movss	DWORD PTR _y$[ebp], xmm0

; 1287 : 
; 1288 : 	// This part does rotation, translation, and scaling on the initial point
; 1289 : 	// Note, we're swapping the x and z axes here to get from z up/down to z far/near
; 1290 : 	// then we're swapping the x and y axes to get into conventional screen pixel coordinates
; 1291 : 	z = post->z;

	mov	ecx, DWORD PTR _post$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _z$[ebp], xmm0

; 1292 : 	scratch_z = T.M11 * x + T.M12 * y + T.M13 * z + move.x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263008]
	mulss	xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+263012]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+263016]
	mulss	xmm1, DWORD PTR _z$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+262996]
	movss	DWORD PTR _scratch_z$[ebp], xmm0

; 1293 : 	scratch_x = T.M21 * x + T.M22 * y + T.M23 * z + move.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263020]
	mulss	xmm0, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+263024]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+263028]
	mulss	xmm1, DWORD PTR _z$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+263000]
	movss	DWORD PTR _scratch_x$[ebp], xmm0

; 1294 : 	scratch_y = T.M31 * x + T.M32 * y + T.M33 * z + move.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263032]
	mulss	xmm0, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+263036]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+263040]
	mulss	xmm1, DWORD PTR _z$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+263004]
	movss	DWORD PTR _scratch_y$[ebp], xmm0
$LN11@TransformR:

; 1295 : 
; 1296 : 
; 1297 : 	// Transform all the rest of the verteces (will break out below)
; 1298 : 	while (TRUE) {

	mov	edx, 1
	test	edx, edx
	je	$LN10@TransformR

; 1299 : 
; 1300 : 		ShiAssert( vert >= vertexBuffer[LOD] - maxSpanExtent*maxSpanOffset - maxSpanOffset );
; 1301 : 		ShiAssert( vert <= vertexBuffer[LOD] + maxSpanExtent*maxSpanOffset + maxSpanOffset );
; 1302 : 
; 1303 : 		// Store a pointer to the source post in the transformed vertex structure
; 1304 : 		vert->post = post;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _post$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 1305 : 
; 1306 : 
; 1307 : #ifdef TWO_D_MAP_AVAILABLE
; 1308 : 	if (twoDmode) {
; 1309 : 		vert->x = (xRes>>1) + TWODSCALE*((float)(levelCol << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->Y()));
; 1310 : 		vert->y = (yRes>>1) - TWODSCALE*((float)(levelRow << LOD) - WORLD_TO_FLOAT_GLOBAL_POST(viewpoint->X()));
; 1311 : 
; 1312 : 		vert->clipFlag = ON_SCREEN;
; 1313 : 
; 1314 : 		vert->r = 0.3f;
; 1315 : 		vert->g = 0.1f;
; 1316 : 		vert->b = 0.1f;
; 1317 : 		vert->a = 0.5f;
; 1318 : 
; 1319 : 		// Draw a marker at this vertex location
; 1320 : 		SetColor( 0x80808080 );
; 1321 : 		Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1322 : 					(UInt16)(vert->x+1), (UInt16)(vert->y-1),
; 1323 : 					(UInt16)(vert->x+1), (UInt16)(vert->y+1));
; 1324 : 		Render2DTri((UInt16)(vert->x-1), (UInt16)(vert->y-1),
; 1325 : 					(UInt16)(vert->x+1), (UInt16)(vert->y+1),
; 1326 : 					(UInt16)(vert->x-1), (UInt16)(vert->y+1));
; 1327 : 	} else {
; 1328 : #endif
; 1329 : 		// Now determine if the point is out behind us or to the sides
; 1330 : 		// See GetRangeClipFlags(), GetHorizontalClipFlags(), and GetVerticalClipFlags()
; 1331 : 		vert->clipFlag = ON_SCREEN;

	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+36], 0

; 1332 : 
; 1333 : 		if ( scratch_z < NEAR_CLIP ) {

	movss	xmm0, DWORD PTR _NEAR_CLIP
	comiss	xmm0, DWORD PTR _scratch_z$[ebp]
	jbe	SHORT $LN9@TransformR

; 1334 : 			vert->clipFlag |= CLIP_NEAR;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN9@TransformR:

; 1335 : 		}
; 1336 : 
; 1337 : 		if ( fabs(scratch_y) > scratch_z ) {

	push	ecx
	movss	xmm0, DWORD PTR _scratch_y$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv476[ebp]
	movss	xmm0, DWORD PTR tv476[ebp]
	comiss	xmm0, DWORD PTR _scratch_z$[ebp]
	jbe	SHORT $LN6@TransformR

; 1338 : 			if ( scratch_y > scratch_z ) {

	movss	xmm0, DWORD PTR _scratch_y$[ebp]
	comiss	xmm0, DWORD PTR _scratch_z$[ebp]
	jbe	SHORT $LN7@TransformR

; 1339 : 				vert->clipFlag |= CLIP_BOTTOM;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 8
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 1340 : 			} else {

	jmp	SHORT $LN6@TransformR
$LN7@TransformR:

; 1341 : 				vert->clipFlag |= CLIP_TOP;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 4
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN6@TransformR:

; 1342 : 			}
; 1343 : 		}
; 1344 : 
; 1345 : 		if ( fabs(scratch_x) > scratch_z ) {

	push	ecx
	movss	xmm0, DWORD PTR _scratch_x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv489[ebp]
	movss	xmm0, DWORD PTR tv489[ebp]
	comiss	xmm0, DWORD PTR _scratch_z$[ebp]
	jbe	SHORT $LN3@TransformR

; 1346 : 			if ( scratch_x > scratch_z ) {

	movss	xmm0, DWORD PTR _scratch_x$[ebp]
	comiss	xmm0, DWORD PTR _scratch_z$[ebp]
	jbe	SHORT $LN4@TransformR

; 1347 : 				vert->clipFlag |= CLIP_RIGHT;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 2
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 1348 : 			} else {

	jmp	SHORT $LN3@TransformR
$LN4@TransformR:

; 1349 : 				vert->clipFlag |= CLIP_LEFT;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 1
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN3@TransformR:

; 1350 : 			}
; 1351 : 		}
; 1352 : 
; 1353 : 
; 1354 : 		vert->csX = scratch_x;

	mov	eax, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _scratch_x$[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 1355 : 		vert->csY = scratch_y;

	mov	ecx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _scratch_y$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 1356 : 		vert->csZ = scratch_z;

	mov	edx, DWORD PTR _vert$[ebp]
	movss	xmm0, DWORD PTR _scratch_z$[ebp]
	movss	DWORD PTR [edx+48], xmm0

; 1357 : 
; 1358 : 
; 1359 : 		// Finally, do the perspective divide and scale and shift into screen space
; 1360 : 		if ( !(vert->clipFlag & CLIP_NEAR) ) {

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN2@TransformR

; 1361 : 			ShiAssert( scratch_z > 0.0f );
; 1362 : 			register float OneOverZ = 1.0f / scratch_z;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _scratch_z$[ebp]
	movss	DWORD PTR _OneOverZ$1[ebp], xmm0

; 1363 : 			vert->x = viewportXtoPixel( scratch_x * OneOverZ );

	movss	xmm0, DWORD PTR _scratch_x$[ebp]
	mulss	xmm0, DWORD PTR _OneOverZ$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx]

; 1364 : 			vert->y = viewportYtoPixel( scratch_y * OneOverZ );

	movss	xmm0, DWORD PTR _scratch_y$[ebp]
	mulss	xmm0, DWORD PTR _OneOverZ$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+4]

; 1365 : 			vert->q = scratch_z * Q_SCALE;

	movss	xmm0, DWORD PTR _scratch_z$[ebp]
	mulss	xmm0, DWORD PTR _Q_SCALE
	mov	ecx, DWORD PTR _vert$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
$LN2@TransformR:

; 1366 : 		}
; 1367 : 
; 1368 : 
; 1369 : 		// Do any color computations required for this post
; 1370 : 		ComputeVertexColor(vert,post,scratch_z,scratch_x,scratch_y); //JAM 03Dec03

	push	ecx
	movss	xmm0, DWORD PTR _scratch_y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scratch_x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scratch_z$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _post$[ebp]
	push	edx
	mov	eax, DWORD PTR _vert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax

; 1371 : 
; 1372 : 
; 1373 : #ifdef TWO_D_MAP_AVAILABLE
; 1374 : 	}
; 1375 : #endif
; 1376 : 
; 1377 : 		//
; 1378 : 		// Break out of our loop if we need to
; 1379 : 		//
; 1380 : 		if (*pChange >= levelStop) {

	mov	ecx, DWORD PTR _pChange$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _levelStop$[ebp]
	jl	SHORT $LN1@TransformR

; 1381 : 			break;

	jmp	$LN10@TransformR
$LN1@TransformR:

; 1382 : 		}
; 1383 : 
; 1384 : 
; 1385 : 		// Advance to the next post to transform
; 1386 : 		vert += vertStep;

	mov	eax, DWORD PTR _vertStep$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR _vert$[ebp], eax

; 1387 : 		(*pChange)++;

	mov	ecx, DWORD PTR _pChange$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _pChange$[ebp]
	mov	DWORD PTR [eax], edx

; 1388 : 
; 1389 : 		// Get the this post from the terrain database
; 1390 : 		post = viewpoint->GetPost( levelRow, levelCol, LOD );

	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _levelCol$[ebp]
	push	edx
	mov	eax, DWORD PTR _levelRow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetPost@TViewPoint@@QAEPAUTpost@@HHH@Z	; TViewPoint::GetPost
	mov	DWORD PTR _post$[ebp], eax

; 1391 : 		ShiAssert( post );
; 1392 : 
; 1393 : 		// Compute the new transformed location based on the known horizontal
; 1394 : 		// step, and the vertical difference between this post and the previous one
; 1395 : 		dz = post->z - z;

	mov	edx, DWORD PTR _post$[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _dz$[ebp], xmm0

; 1396 : 		z = post->z;

	mov	eax, DWORD PTR _post$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _z$[ebp], xmm0

; 1397 : 		scratch_z += hVector[0] + dz * zVector[0];

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _zVector$[ebp]
	movss	xmm0, DWORD PTR _dz$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _hVector$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _scratch_z$[ebp]
	movss	DWORD PTR _scratch_z$[ebp], xmm0

; 1398 : 		scratch_x += hVector[1] + dz * zVector[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _zVector$[ebp]
	movss	xmm0, DWORD PTR _dz$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _hVector$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _scratch_x$[ebp]
	movss	DWORD PTR _scratch_x$[ebp], xmm0

; 1399 : 		scratch_y += hVector[2] + dz * zVector[2];

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _zVector$[ebp]
	movss	xmm0, DWORD PTR _dz$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _hVector$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _scratch_y$[ebp]
	movss	DWORD PTR _scratch_y$[ebp], xmm0

; 1400 :  	}

	jmp	$LN11@TransformR
$LN10@TransformR:
$LN15@TransformR:

; 1401 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?TransformRun@RenderOTW@@IAEXHHHHH@Z ENDP		; RenderOTW::TransformRun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetupStates@RenderOTW@@IAEXXZ PROC			; RenderOTW::SetupStates
; _this$ = ecx

; 310  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 	state_far = STATE_GOURAUD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263120], 2

; 312  : 
; 313  : 	if(textureLevel == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+263232], 0
	jne	SHORT $LN4@SetupState

; 314  : 	{
; 315  : 		state_mid  = state_far;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263120]
	mov	DWORD PTR [edx+263116], ecx

; 316  : 		state_near = state_far;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263120]
	mov	DWORD PTR [edx+263112], ecx

; 317  : 		state_fore = state_far;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263120]
	mov	DWORD PTR [edx+263108], ecx

; 318  : 	}
; 319  : 	else

	jmp	SHORT $LN5@SetupState
$LN4@SetupState:

; 320  : 	{
; 321  : 		// RED - WTF..!!! if u Eneter that light is hi, u would not get lights on when light go down...
; 322  : 		if(DisplayOptions.m_texMode == DisplayOptionsClass::TEX_MODE_DDS/* && TheTerrTextures.lightLevel < 0.5f*/)

	cmp	DWORD PTR ?DisplayOptions@@3VDisplayOptionsClass@@A+24, 70161 ; 00011211H
	jne	SHORT $LN2@SetupState

; 323  : 		{
; 324  : 			state_fore	= STATE_MULTITEXTURE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263108], 37		; 00000025H

; 325  : 			state_near	= STATE_MULTITEXTURE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263112], 37		; 00000025H

; 326  : 			state_mid	= STATE_MULTITEXTURE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263116], 37		; 00000025H

; 327  : 		}
; 328  : 		else

	jmp	SHORT $LN5@SetupState
$LN2@SetupState:

; 329  : 		{
; 330  : 			state_fore	= STATE_LANDSCAPE_GOURAUD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263108], 15		; 0000000fH

; 331  : 			state_near	= STATE_LANDSCAPE_GOURAUD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263112], 15		; 0000000fH

; 332  : 			state_mid	= STATE_LANDSCAPE_GOURAUD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263116], 15		; 0000000fH
$LN5@SetupState:

; 333  : 		}
; 334  : 	}
; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetupStates@RenderOTW@@IAEXXZ ENDP			; RenderOTW::SetupStates
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv487 = -1176						; size = 8
tv467 = -1168						; size = 8
tv477 = -1160						; size = 8
_vertPointers$ = -1152					; size = 16
tv474 = -1136						; size = 4
tv464 = -1132						; size = 4
_alpha$ = -1128						; size = 4
tv484 = -1124						; size = 4
_b$ = -1120						; size = 4
_g$ = -1116						; size = 4
_r$ = -1112						; size = 4
_x$ = -1108						; size = 4
_y$ = -1104						; size = 4
_j2$ = -1100						; size = 4
_j1$ = -1096						; size = 4
_this$ = -1092						; size = 4
_i$ = -1088						; size = 4
_vert$ = -1084						; size = 1080
__$ArrayPad$ = -4					; size = 4
?DrawTunnelBorder@RenderOTW@@QAEXXZ PROC		; RenderOTW::DrawTunnelBorder
; _this$ = ecx

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1176				; 00000498H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 520  : 	TwoDVertex	vert[NumPoints*2+1];
; 521  : 	TwoDVertex* vertPointers[4];
; 522  : 	int			i;
; 523  : 	int			j1, j2;
; 524  : 	float		x, y;
; 525  : 	float		alpha;
; 526  : 
; 527  : 	// Quit now if the tunnel isn't being drawn
; 528  : 	if (tunnelAlphaWidth <= 0.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+263240]
	jb	SHORT $LN16@DrawTunnel

; 529  : 		return;

	jmp	$LN17@DrawTunnel
$LN16@DrawTunnel:

; 530  : 
; 531  : 	// OW 
; 532  : 	ZeroMemory(vert, sizeof(vert));

	push	1080					; 00000438H
	push	0
	lea	ecx, DWORD PTR _vert$[ebp]
	push	ecx
	call	_memset

; 533  : 
; 534  : 	// Restart the rasterizer to draw the tunnel border
; 535  : 	//context.StartFrame();
; 536  : 
; 537  : 	// Put the clip rectangle at full size to allow drawing of the border
; 538  : 	SetViewport( -1.0f, 1.0f, 1.0f, -1.0f );

	add	esp, 8
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 539  : 
; 540  : 	// Initialize all the verticies
; 541  : 	float r = (float)((tunnelColor)     & 0xFF) / 255.9f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263248]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR tv464[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv464[ebp]
	mov	edx, DWORD PTR tv464[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv467[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv467[ebp]
	divss	xmm0, DWORD PTR __real@437fe666
	movss	DWORD PTR _r$[ebp], xmm0

; 542  : 	float g = (float)((tunnelColor>>8)  & 0xFF) / 255.9f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263248]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR tv474[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv474[ebp]
	mov	edx, DWORD PTR tv474[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv477[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv477[ebp]
	divss	xmm0, DWORD PTR __real@437fe666
	movss	DWORD PTR _g$[ebp], xmm0

; 543  : 	float b = (float)((tunnelColor>>16) & 0xFF) / 255.9f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263248]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR tv484[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv484[ebp]
	mov	edx, DWORD PTR tv484[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv487[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv487[ebp]
	divss	xmm0, DWORD PTR __real@437fe666
	movss	DWORD PTR _b$[ebp], xmm0

; 544  : 
; 545  : 	for (i = 0; i<NumPoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@DrawTunnel
$LN14@DrawTunnel:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@DrawTunnel:
	cmp	DWORD PTR _i$[ebp], 13			; 0000000dH
	jge	$LN13@DrawTunnel

; 546  : 	{
; 547  : 		j1 = i << 1;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _j1$[ebp], ecx

; 548  : 		j2 = j1 + 1;

	mov	edx, DWORD PTR _j1$[ebp]
	add	edx, 1
	mov	DWORD PTR _j2$[ebp], edx

; 549  : 
; 550  : 		// Color
; 551  : 		vert[j1].r = vert[j2].r = r;

	mov	eax, DWORD PTR _j2$[ebp]
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _vert$[ebp+eax+8], xmm0
	mov	ecx, DWORD PTR _j1$[ebp]
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _vert$[ebp+ecx+8], xmm0

; 552  : 		vert[j1].g = vert[j2].g = g;

	mov	edx, DWORD PTR _j2$[ebp]
	imul	edx, 40					; 00000028H
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR _vert$[ebp+edx+12], xmm0
	mov	eax, DWORD PTR _j1$[ebp]
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR _vert$[ebp+eax+12], xmm0

; 553  : 		vert[j1].b = vert[j2].b = b;

	mov	ecx, DWORD PTR _j2$[ebp]
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR _vert$[ebp+ecx+16], xmm0
	mov	edx, DWORD PTR _j1$[ebp]
	imul	edx, 40					; 00000028H
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR _vert$[ebp+edx+16], xmm0

; 554  : 		vert[j1].a = vert[j2].a = 1.0f;

	mov	eax, DWORD PTR _j2$[ebp]
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vert$[ebp+eax+20], xmm0
	mov	ecx, DWORD PTR _j1$[ebp]
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vert$[ebp+ecx+20], xmm0

; 555  : 
; 556  : 		// Root location
; 557  : 		vert[j1].x = viewportXtoPixel( OutsidePoints[i].x );

	mov	edx, DWORD PTR _i$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _OutsidePoints[edx*8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	mov	eax, DWORD PTR _j1$[ebp]
	imul	eax, 40					; 00000028H
	fstp	DWORD PTR _vert$[ebp+eax]

; 558  : 		vert[j1].y = viewportYtoPixel( OutsidePoints[i].y );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _OutsidePoints[ecx*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	mov	edx, DWORD PTR _j1$[ebp]
	imul	edx, 40					; 00000028H
	fstp	DWORD PTR _vert$[ebp+edx+4]

; 559  : 		SetClipFlags( &vert[j1] );

	mov	eax, DWORD PTR _j1$[ebp]
	imul	eax, 40					; 00000028H
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetClipFlags@Render2D@@QAEXPAUTwoDVertex@@@Z ; Render2D::SetClipFlags

; 560  : 
; 561  : 		// Inside edge
; 562  : 		x = (1.0f - tunnelSolidWidth) * OutsidePoints[i].x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+263244]
	mov	eax, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR _OutsidePoints[eax*8]
	movss	DWORD PTR _x$[ebp], xmm0

; 563  : 		y = (1.0f - tunnelSolidWidth) * OutsidePoints[i].y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [ecx+263244]
	mov	edx, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR _OutsidePoints[edx*8+4]
	movss	DWORD PTR _y$[ebp], xmm0

; 564  : 		vert[j2].x = viewportXtoPixel( x );

	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	mov	eax, DWORD PTR _j2$[ebp]
	imul	eax, 40					; 00000028H
	fstp	DWORD PTR _vert$[ebp+eax]

; 565  : 		vert[j2].y = viewportYtoPixel( y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	mov	ecx, DWORD PTR _j2$[ebp]
	imul	ecx, 40					; 00000028H
	fstp	DWORD PTR _vert$[ebp+ecx+4]

; 566  : 		SetClipFlags( &vert[j2] );

	mov	edx, DWORD PTR _j2$[ebp]
	imul	edx, 40					; 00000028H
	lea	eax, DWORD PTR _vert$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetClipFlags@Render2D@@QAEXPAUTwoDVertex@@@Z ; Render2D::SetClipFlags

; 567  : 	}

	jmp	$LN14@DrawTunnel
$LN13@DrawTunnel:

; 568  : 	
; 569  : 	// Special pickup for the one vertex which wasn't colored this time, but will be used next
; 570  : 	vert[i*2].r = r;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 1
	imul	ecx, 40					; 00000028H
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _vert$[ebp+ecx+8], xmm0

; 571  : 	vert[i*2].g = g;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	imul	edx, 40					; 00000028H
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR _vert$[ebp+edx+12], xmm0

; 572  : 	vert[i*2].b = b;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR _vert$[ebp+eax+16], xmm0

; 573  : 
; 574  : 	// Draw the flat colored mesh if it is visible
; 575  : 	if(tunnelSolidWidth > 0.0f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263244]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN9@DrawTunnel

; 576  : 	{
; 577  : 		context.RestoreState( STATE_SOLID );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState

; 578  : 
; 579  : 		for(i=NumPoints-2; i>=0; i--)

	mov	DWORD PTR _i$[ebp], 11			; 0000000bH
	jmp	SHORT $LN11@DrawTunnel
$LN10@DrawTunnel:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN11@DrawTunnel:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$LN9@DrawTunnel

; 580  : 		{
; 581  : 			j1 = i<<1;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	DWORD PTR _j1$[ebp], eax

; 582  : 			vertPointers[0] = &vert[j1];

	mov	ecx, DWORD PTR _j1$[ebp]
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	mov	DWORD PTR _vertPointers$[ebp+eax], edx

; 583  : 			vertPointers[1] = &vert[j1+2];

	mov	ecx, DWORD PTR _j1$[ebp]
	add	ecx, 2
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR _vertPointers$[ebp+eax], edx

; 584  : 			vertPointers[2] = &vert[j1+3];

	mov	ecx, DWORD PTR _j1$[ebp]
	add	ecx, 3
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	DWORD PTR _vertPointers$[ebp+eax], edx

; 585  : 			vertPointers[3] = &vert[j1+1];

	mov	ecx, DWORD PTR _j1$[ebp]
	add	ecx, 1
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 3
	mov	DWORD PTR _vertPointers$[ebp+eax], edx

; 586  : 			ClipAndDraw2DFan(vertPointers, 4);

	push	0
	push	4
	lea	ecx, DWORD PTR _vertPointers$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipAndDraw2DFan@Render2D@@QAEXPAPAUTwoDVertex@@I_N@Z ; Render2D::ClipAndDraw2DFan

; 587  : 		}

	jmp	$LN10@DrawTunnel
$LN9@DrawTunnel:

; 588  : 	}
; 589  : 
; 590  : 	// Update the ending alpha value and alpha percent for the closing out the view case
; 591  : 	if (tunnelAlphaWidth > 1.0f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263240]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN8@DrawTunnel

; 592  : 	{
; 593  : 		alpha = (tunnelAlphaWidth - 1.0f) / PercentBlend;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263240]
	subss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _PercentBlend
	movss	DWORD PTR _alpha$[ebp], xmm0

; 594  : 		tunnelAlphaWidth = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+263240], xmm0

; 595  : 	}
; 596  : 
; 597  : 	else

	jmp	SHORT $LN7@DrawTunnel
$LN8@DrawTunnel:

; 598  : 		alpha = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN7@DrawTunnel:

; 599  : 
; 600  : 	// Fill the blended portion of the border
; 601  : 	// NOTE:  The inside of the solid mesh is the outside of the blending mesh
; 602  : 	// therefore, the odd numbered vertices from above can be reused
; 603  : 
; 604  : 	for (i = 0; i<NumPoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@DrawTunnel
$LN5@DrawTunnel:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@DrawTunnel:
	cmp	DWORD PTR _i$[ebp], 13			; 0000000dH
	jge	$LN4@DrawTunnel

; 605  : 	{
; 606  : 		j1 = (i << 1)+1;		// Index of vertex to be reused (last times inside edge)

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	mov	DWORD PTR _j1$[ebp], ecx

; 607  : 		j2 = j1 + 1;			// Index of vertex to replace (last times outside edge)

	mov	edx, DWORD PTR _j1$[ebp]
	add	edx, 1
	mov	DWORD PTR _j2$[ebp], edx

; 608  : 
; 609  : 		// Alpha
; 610  : 		vert[j2].a = alpha;

	mov	eax, DWORD PTR _j2$[ebp]
	imul	eax, 40					; 00000028H
	movss	xmm0, DWORD PTR _alpha$[ebp]
	movss	DWORD PTR _vert$[ebp+eax+20], xmm0

; 611  : 
; 612  : 		// Inside edge
; 613  : 		x = (1.0f - tunnelAlphaWidth) * OutsidePoints[i].x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [ecx+263240]
	mov	edx, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR _OutsidePoints[edx*8]
	movss	DWORD PTR _x$[ebp], xmm0

; 614  : 		y = (1.0f - tunnelAlphaWidth) * OutsidePoints[i].y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [eax+263240]
	mov	ecx, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR _OutsidePoints[ecx*8+4]
	movss	DWORD PTR _y$[ebp], xmm0

; 615  : 		vert[j2].x = viewportXtoPixel(x);

	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	mov	edx, DWORD PTR _j2$[ebp]
	imul	edx, 40					; 00000028H
	fstp	DWORD PTR _vert$[ebp+edx]

; 616  : 		vert[j2].y = viewportYtoPixel(y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	mov	eax, DWORD PTR _j2$[ebp]
	imul	eax, 40					; 00000028H
	fstp	DWORD PTR _vert$[ebp+eax+4]

; 617  : 		SetClipFlags(&vert[j2]);

	mov	ecx, DWORD PTR _j2$[ebp]
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetClipFlags@Render2D@@QAEXPAUTwoDVertex@@@Z ; Render2D::SetClipFlags

; 618  : 	}

	jmp	$LN5@DrawTunnel
$LN4@DrawTunnel:

; 619  : 
; 620  : 	// Draw the blended mesh
; 621  : 	context.RestoreState(STATE_ALPHA_GOURAUD);

	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState

; 622  : 
; 623  : 	for(i=NumPoints-2; i>=0; i--)

	mov	DWORD PTR _i$[ebp], 11			; 0000000bH
	jmp	SHORT $LN3@DrawTunnel
$LN2@DrawTunnel:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@DrawTunnel:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$LN1@DrawTunnel

; 624  : 	{
; 625  : 		j1 = (i<<1) + 1;

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	mov	DWORD PTR _j1$[ebp], edx

; 626  : 		vertPointers[0] = &vert[j1];

	mov	eax, DWORD PTR _j1$[ebp]
	imul	eax, 40					; 00000028H
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	mov	DWORD PTR _vertPointers$[ebp+edx], ecx

; 627  : 		vertPointers[1] = &vert[j1+2];

	mov	eax, DWORD PTR _j1$[ebp]
	add	eax, 2
	imul	eax, 40					; 00000028H
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _vertPointers$[ebp+edx], ecx

; 628  : 		vertPointers[2] = &vert[j1+3];

	mov	eax, DWORD PTR _j1$[ebp]
	add	eax, 3
	imul	eax, 40					; 00000028H
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _vertPointers$[ebp+edx], ecx

; 629  : 		vertPointers[3] = &vert[j1+1];

	mov	eax, DWORD PTR _j1$[ebp]
	add	eax, 1
	imul	eax, 40					; 00000028H
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 3
	mov	DWORD PTR _vertPointers$[ebp+edx], ecx

; 630  : 		ClipAndDraw2DFan( vertPointers, 4 );

	push	0
	push	4
	lea	eax, DWORD PTR _vertPointers$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipAndDraw2DFan@Render2D@@QAEXPAPAUTwoDVertex@@I_N@Z ; Render2D::ClipAndDraw2DFan

; 631  : 	}

	jmp	$LN2@DrawTunnel
$LN1@DrawTunnel:
$LN17@DrawTunnel:

; 632  : 
; 633  : 	// Close down the renderer and flush the queue
; 634  : 	//context.FinishFrame(NULL);
; 635  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawTunnelBorder@RenderOTW@@QAEXXZ ENDP		; RenderOTW::DrawTunnelBorder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_pVtx$1 = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?PostSceneCloudOcclusion@RenderOTW@@QAEXXZ PROC		; RenderOTW::PostSceneCloudOcclusion
; _this$ = ecx

; 451  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 452  : 	// If we're in software, we turn off the special color munging function
; 453  : 	if ( image->GetDisplayDevice()->IsHardware() ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?GetDisplayDevice@ImageBuffer@@QAEPAVDisplayDevice@@XZ ; ImageBuffer::GetDisplayDevice
	mov	ecx, eax
	call	?IsHardware@DisplayDevice@@QAEHXZ	; DisplayDevice::IsHardware
	test	eax, eax
	je	$LN3@PostSceneC

; 454  : 
; 455  : 		// Drop out if alpha is 0
; 456  : 		if ((cloudColor & 0xFF000000) == 0) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263252]
	and	edx, -16777216				; ff000000H
	jne	SHORT $LN2@PostSceneC

; 457  : 			return;

	jmp	$LN4@PostSceneC
$LN2@PostSceneC:

; 458  : 		}
; 459  : 
; 460  : // OW
; 461  : #if 1
; 462  : 		// Draw the viewport sized alpha blended polygon
; 463  : 		MPRVtx_t	pVtx[4];
; 464  : 
; 465  : 		// Set the foreground color and drawing state
; 466  : 		context.SelectForegroundColor( cloudColor );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263252]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SelectForegroundColor@ContextMPR@@QAEXH@Z ; ContextMPR::SelectForegroundColor

; 467  : 		context.RestoreState( STATE_ALPHA_SOLID );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState

; 468  : 
; 469  : 		// Now intialize the four corners of the rectangle to fill
; 470  : 		pVtx[0].x = leftPixel;	pVtx[0].y = bottomPixel;

	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _pVtx$1[ebp+edx], ecx
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _pVtx$1[ebp+edx+4], ecx

; 471  : 		pVtx[1].x = leftPixel;	pVtx[1].y = topPixel;

	mov	edx, 8
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _pVtx$1[ebp+edx], ecx
	mov	edx, 8
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _pVtx$1[ebp+edx+4], ecx

; 472  : 		pVtx[2].x = rightPixel;	pVtx[2].y = topPixel;

	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pVtx$1[ebp+edx], ecx
	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _pVtx$1[ebp+edx+4], ecx

; 473  : 		pVtx[3].x = rightPixel;	pVtx[3].y = bottomPixel;

	mov	edx, 8
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pVtx$1[ebp+edx], ecx
	mov	edx, 8
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _pVtx$1[ebp+edx+4], ecx

; 474  : 
; 475  : 		context.DrawPrimitive( MPR_PRM_TRIFAN, 0, 4, pVtx, sizeof(pVtx[0]));

	push	8
	lea	edx, DWORD PTR _pVtx$1[ebp]
	push	edx
	push	4
	push	0
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?DrawPrimitive@ContextMPR@@QAEXHGGPAUMPRVtx_t@@G@Z ; ContextMPR::DrawPrimitive
$LN3@PostSceneC:
$LN4@PostSceneC:

; 476  : #else
; 477  : 		// Draw the viewport sized alpha blended polygon
; 478  : 		MPRVtx_t	*p;
; 479  : 
; 480  : 		// Set the foreground color and drawing state
; 481  : 		context.SelectForegroundColor( cloudColor );
; 482  : 		context.RestoreState( STATE_ALPHA_SOLID );
; 483  : 
; 484  : 		// Start the primitive and get a pointer to the target vertex data
; 485  : 		context.Primitive( MPR_PRM_TRIFAN, 0, 4, sizeof(*p) );
; 486  : 		p = (MPRVtx_t*)context.GetContextBufferPtr();
; 487  : 
; 488  : 		// Now intialize the four corners of the rectangle to fill
; 489  : 		p->x = leftPixel;	p->y = bottomPixel;		p++;
; 490  : 		p->x = leftPixel;	p->y = topPixel;		p++;
; 491  : 		p->x = rightPixel;	p->y = topPixel;		p++;
; 492  : 		p->x = rightPixel;	p->y = bottomPixel;		p++;
; 493  : 
; 494  : 		// Finish off the primitive and send it (since it'll be slow)
; 495  : 		context.SetContextBufferPtr( (BYTE*)p );
; 496  : 		context.SendCurrentPacket();
; 497  : #endif
; 498  : 
; 499  : 	} else {
; 500  : 
; 501  : 		// Set the color correction terms back to normal
; 502  : 		// TODO:  Update this once Marc's changes are in...
; 503  : //		context.SetState( MPR_STA_GAMMA_RED,   (DWORD)(1.0f) );
; 504  : //		context.SetState( MPR_STA_GAMMA_GREEN, (DWORD)(1.0f) );
; 505  : //		context.SetState( MPR_STA_GAMMA_BLUE,  (DWORD)(1.0f) );
; 506  : 
; 507  : 	}
; 508  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PostSceneCloudOcclusion@RenderOTW@@QAEXXZ ENDP		; RenderOTW::PostSceneCloudOcclusion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv175 = -52						; size = 8
tv164 = -44						; size = 8
tv153 = -36						; size = 8
_startpct$ = -28					; size = 4
tv134 = -24						; size = 4
tv172 = -20						; size = 4
tv161 = -16						; size = 4
tv150 = -12						; size = 4
_t$1 = -8						; size = 4
_this$ = -4						; size = 4
_percent$ = 8						; size = 4
_color$ = 12						; size = 4
?SetTunnelPercent@RenderOTW@@QAEXMK@Z PROC		; RenderOTW::SetTunnelPercent
; _this$ = ecx

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 371  : 	float startpct = percent;

	movss	xmm0, DWORD PTR _percent$[ebp]
	movss	DWORD PTR _startpct$[ebp], xmm0

; 372  : 	// Clamp the percent value to the allowable range
; 373  : 	if (percent > 1.0f)			percent = 1.0f;

	movss	xmm0, DWORD PTR _percent$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@SetTunnelP
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _percent$[ebp], xmm0
	jmp	SHORT $LN5@SetTunnelP
$LN7@SetTunnelP:

; 374  : 	else if (percent < 0.0f)	percent = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _percent$[ebp]
	jbe	SHORT $LN5@SetTunnelP
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _percent$[ebp], xmm0
$LN5@SetTunnelP:

; 375  : 
; 376  : 	// Apply adjustments if we're in NVG mode
; 377  : 	if (TheTimeOfDay.GetNVGmode() && (percent < NVG_TUNNEL_PERCENT))

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetNVGmode@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetNVGmode
	test	eax, eax
	je	$LN1@SetTunnelP
	movss	xmm0, DWORD PTR ?NVG_TUNNEL_PERCENT@RenderOTW@@2MB
	comiss	xmm0, DWORD PTR _percent$[ebp]
	jbe	$LN1@SetTunnelP

; 378  : 	{
; 379  : 		percent = NVG_TUNNEL_PERCENT;

	movss	xmm0, DWORD PTR ?NVG_TUNNEL_PERCENT@RenderOTW@@2MB
	movss	DWORD PTR _percent$[ebp], xmm0

; 380  : 
; 381  : 		if (percent <= 0.0f) {

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _percent$[ebp]
	jb	SHORT $LN3@SetTunnelP

; 382  : 			color = 0;

	mov	DWORD PTR _color$[ebp], 0

; 383  : 		} else {

	jmp	$LN2@SetTunnelP
$LN3@SetTunnelP:

; 384  : 			float t = percent/NVG_TUNNEL_PERCENT;

	movss	xmm0, DWORD PTR _percent$[ebp]
	divss	xmm0, DWORD PTR ?NVG_TUNNEL_PERCENT@RenderOTW@@2MB
	movss	DWORD PTR _t$1[ebp], xmm0

; 385  : 			color = (FloatToInt32((color & 0x00FF0000) * t) & 0x000000FF) |
; 386  : 					(FloatToInt32((color & 0x00FF0000) * t) & 0x0000FF00) |
; 387  : 					(FloatToInt32((color & 0x00FF0000) * t) & 0x00FF0000);

	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 16711680				; 00ff0000H
	mov	DWORD PTR tv150[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv150[ebp]
	mov	ecx, DWORD PTR tv150[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv153[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv153[ebp]
	mulss	xmm0, DWORD PTR _t$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esi, eax
	and	esi, 255				; 000000ffH
	mov	edx, DWORD PTR _color$[ebp]
	and	edx, 16711680				; 00ff0000H
	mov	DWORD PTR tv161[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv161[ebp]
	mov	eax, DWORD PTR tv161[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv164[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv164[ebp]
	mulss	xmm0, DWORD PTR _t$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	and	eax, 65280				; 0000ff00H
	or	esi, eax
	mov	ecx, DWORD PTR _color$[ebp]
	and	ecx, 16711680				; 00ff0000H
	mov	DWORD PTR tv172[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv172[ebp]
	mov	edx, DWORD PTR tv172[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv175[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv175[ebp]
	mulss	xmm0, DWORD PTR _t$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	and	eax, 16711680				; 00ff0000H
	or	esi, eax
	mov	DWORD PTR _color$[ebp], esi
$LN2@SetTunnelP:

; 388  : 		}
; 389  : 		if (g_bFullScreenNVG)

	movzx	eax, BYTE PTR ?g_bFullScreenNVG@@3_NA	; g_bFullScreenNVG
	test	eax, eax
	je	SHORT $LN1@SetTunnelP

; 390  : 			percent = startpct;

	movss	xmm0, DWORD PTR _startpct$[ebp]
	movss	DWORD PTR _percent$[ebp], xmm0
$LN1@SetTunnelP:

; 391  : 	}
; 392  : 
; 393  : 	// Store the new tunnel vision parameters
; 394  : 	tunnelColor			= color;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _color$[ebp]
	mov	DWORD PTR [ecx+263248], edx

; 395  : 	tunnelPercent		= percent;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _percent$[ebp]
	movss	DWORD PTR [eax+263236], xmm0

; 396  : 	// RV - Biker - Give little more alpha for blackout
; 397  : 	//tunnelAlphaWidth	= percent*PercentScale;
; 398  : 	//tunnelSolidWidth	= tunnelAlphaWidth - PercentBlend;
; 399  : 	tunnelAlphaWidth	= min(percent*2.0f, 1.05f);

	movss	xmm0, DWORD PTR _percent$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f866666
	comiss	xmm1, xmm0
	jbe	SHORT $LN10@SetTunnelP
	movss	xmm0, DWORD PTR _percent$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN11@SetTunnelP
$LN10@SetTunnelP:
	movss	xmm0, DWORD PTR __real@3f866666
	movss	DWORD PTR tv134[ebp], xmm0
$LN11@SetTunnelP:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR [ecx+263240], xmm0

; 400  : 	tunnelSolidWidth	= percent*2.0f - 0.95f;

	movss	xmm0, DWORD PTR _percent$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR __real@3f733333
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+263244], xmm0

; 401  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTunnelPercent@RenderOTW@@QAEXMK@Z ENDP		; RenderOTW::SetTunnelPercent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_containingList$ = -44					; size = 4
_prevTop$ = -40						; size = 4
_prevBottom$ = -36					; size = 4
_prevFOV$ = -32						; size = 4
_prevLeft$ = -28					; size = 4
_prevRight$ = -24					; size = 4
_this$ = -20						; size = 4
_position$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_offset$ = 8						; size = 4
_orientation$ = 12					; size = 4
?PreLoadScene@RenderOTW@@QAEXPBUTpoint@@PBUTrotation@@@Z PROC ; RenderOTW::PreLoadScene
; _this$ = ecx

; 642  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 	Tpoint	position={0.0F};

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _position$[ebp], xmm0
	xor	eax, eax
	mov	DWORD PTR _position$[ebp+4], eax
	mov	DWORD PTR _position$[ebp+8], eax

; 644  : 	int		containingList=0;

	mov	DWORD PTR _containingList$[ebp], 0

; 645  : 	float	prevFOV = 0.0F, prevLeft = 0.0F, prevRight = 0.0F, prevTop = 0.0F, prevBottom = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevFOV$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevLeft$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevRight$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevTop$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevBottom$[ebp], xmm0

; 646  : 
; 647  : 	prevFOV = GetFOV();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@Render3D@@QAEMXZ		; Render3D::GetFOV
	fstp	DWORD PTR _prevFOV$[ebp]

; 648  : 	GetViewport( &prevLeft, &prevTop, &prevRight, &prevBottom );

	lea	ecx, DWORD PTR _prevBottom$[ebp]
	push	ecx
	lea	edx, DWORD PTR _prevRight$[ebp]
	push	edx
	lea	eax, DWORD PTR _prevTop$[ebp]
	push	eax
	lea	ecx, DWORD PTR _prevLeft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetViewport@VirtualDisplay@@QAEXPAM000@Z ; VirtualDisplay::GetViewport

; 649  : 
; 650  : 	// Get our world space position from our viewpoint
; 651  : 	viewpoint->GetPos( &position );

	lea	edx, DWORD PTR _position$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z	; TViewPoint::GetPos

; 652  : 
; 653  : 	// Apply the offset (if provided) -- in world space for now (TODO: camera space?)
; 654  : 	if (offset) {

	cmp	DWORD PTR _offset$[ebp], 0
	je	SHORT $LN1@PreLoadSce

; 655  : 		position.x += offset->x;

	mov	ecx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _position$[ebp], xmm0

; 656  : 		position.y += offset->y;

	mov	edx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+4]
	addss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR _position$[ebp+4], xmm0

; 657  : 		position.z += offset->z;

	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+8]
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _position$[ebp+8], xmm0
$LN1@PreLoadSce:

; 658  : 	}
; 659  : 
; 660  : 	// Call Render3D's cammera update function with the new position
; 661  : 	SetCamera( &position, orientation );

	mov	ecx, DWORD PTR _orientation$[ebp]
	push	ecx
	lea	edx, DWORD PTR _position$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera

; 662  : 
; 663  : 
; 664  : 	// Sort the object list based on our location
; 665  : 	viewpoint->ResetObjectTraversal();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ResetObjectTraversal@RViewPoint@@QAEXXZ ; RViewPoint::ResetObjectTraversal

; 666  : 
; 667  : 	// Preload each possible List	
; 668  : 	viewpoint->ObjectsAboveRoof()->PreLoad( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveRoof
	mov	ecx, eax
	call	?PreLoad@ObjectDisplayList@@QAEXPAVRenderOTW@@@Z ; ObjectDisplayList::PreLoad

; 669  : 	viewpoint->ObjectsInTerrain()->PreLoad( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInTerrain
	mov	ecx, eax
	call	?PreLoad@ObjectDisplayList@@QAEXPAVRenderOTW@@@Z ; ObjectDisplayList::PreLoad

; 670  : 	viewpoint->ObjectsBelowClouds()->PreLoad( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsBelowClouds
	mov	ecx, eax
	call	?PreLoad@ObjectDisplayList@@QAEXPAVRenderOTW@@@Z ; ObjectDisplayList::PreLoad

; 671  : 	viewpoint->ObjectsInClouds()->PreLoad( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInClouds
	mov	ecx, eax
	call	?PreLoad@ObjectDisplayList@@QAEXPAVRenderOTW@@@Z ; ObjectDisplayList::PreLoad

; 672  : 	viewpoint->ObjectsAboveClouds()->PreLoad( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveClouds
	mov	ecx, eax
	call	?PreLoad@ObjectDisplayList@@QAEXPAVRenderOTW@@@Z ; ObjectDisplayList::PreLoad

; 673  : 
; 674  : 	// ok, now fill object and texture banks
; 675  : 	ObjectLOD::WaitUpdates();

	call	?WaitUpdates@ObjectLOD@@SAXXZ		; ObjectLOD::WaitUpdates

; 676  : 	TheTextureBank.WaitUpdates();

	call	?WaitUpdates@TextureBankClass@@SAXXZ	; TextureBankClass::WaitUpdates

; 677  : 
; 678  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?PreLoadScene@RenderOTW@@QAEXPBUTpoint@@PBUTrotation@@@Z ENDP ; RenderOTW::PreLoadScene
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_fov$1 = -92						; size = 4
_bottom$2 = -88						; size = 4
_left$3 = -84						; size = 4
_top$4 = -80						; size = 4
tv473 = -76						; size = 4
tv131 = -72						; size = 4
tv137 = -68						; size = 4
_bToggle$ = -64						; size = 4
tv91 = -60						; size = 4
_right$5 = -56						; size = 4
tv129 = -52						; size = 4
_prevFOV$ = -48						; size = 4
_prevTop$ = -44						; size = 4
_prevBottom$ = -40					; size = 4
_prevLeft$ = -36					; size = 4
_prevRight$ = -32					; size = 4
_visible$6 = -28					; size = 4
_containingList$ = -24					; size = 4
_this$ = -20						; size = 4
_position$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_offset$ = 8						; size = 4
_orientation$ = 12					; size = 4
?DrawScene@RenderOTW@@QAEXPBUTpoint@@PBUTrotation@@@Z PROC ; RenderOTW::DrawScene
; _this$ = ecx

; 685  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 	Tpoint	position={0.0F};

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _position$[ebp], xmm0
	xor	eax, eax
	mov	DWORD PTR _position$[ebp+4], eax
	mov	DWORD PTR _position$[ebp+8], eax

; 687  : 	int		containingList=0;

	mov	DWORD PTR _containingList$[ebp], 0

; 688  : 	float	prevFOV = 0.0F, prevLeft = 0.0F, prevRight = 0.0F, prevTop = 0.0F, prevBottom = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevFOV$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevLeft$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevRight$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevTop$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _prevBottom$[ebp], xmm0

; 689  : 
; 690  : 	// reset 2D Engine
; 691  : 	TheDXEngine.DX2D_Reset();

	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?DX2D_Reset@CDXEngine@@QAEXXZ		; CDXEngine::DX2D_Reset

; 692  : 	// OK - Here it kills the lights from the Pit, as the Pit has is own call out of the DrawScene
; 693  : 	// Passed into the DX Engine, at the end of any data flush, as it's the end of a scene
; 694  : 	//TheDXEngine.ClearLights();
; 695  : 
; 696  : 	prevFOV = GetFOV();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@Render3D@@QAEMXZ		; Render3D::GetFOV
	fstp	DWORD PTR _prevFOV$[ebp]

; 697  : 	GetViewport( &prevLeft, &prevTop, &prevRight, &prevBottom );

	lea	ecx, DWORD PTR _prevBottom$[ebp]
	push	ecx
	lea	edx, DWORD PTR _prevRight$[ebp]
	push	edx
	lea	eax, DWORD PTR _prevTop$[ebp]
	push	eax
	lea	ecx, DWORD PTR _prevLeft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetViewport@VirtualDisplay@@QAEXPAM000@Z ; VirtualDisplay::GetViewport

; 698  : 
; 699  : 	// Reduce the viewport size to save on overdraw costs if there's a tunnel in effect
; 700  : 	if (tunnelSolidWidth > 0.0f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263244]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN15@DrawScene

; 701  : 	{		
; 702  : 		float	visible = (1.0f - tunnelSolidWidth) * big;		

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [eax+263244]
	mulss	xmm0, DWORD PTR _big
	movss	DWORD PTR _visible$6[ebp], xmm0

; 703  : 
; 704  : 		if (visible <= 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _visible$6[ebp]
	jb	$LN15@DrawScene

; 705  : 		{
; 706  : 			float	left, top, right, bottom;
; 707  : 			float	fov;
; 708  : 
; 709  : 			right	= min(  visible, prevRight  );

	movss	xmm0, DWORD PTR _prevRight$[ebp]
	comiss	xmm0, DWORD PTR _visible$6[ebp]
	jbe	SHORT $LN19@DrawScene
	movss	xmm0, DWORD PTR _visible$6[ebp]
	movss	DWORD PTR tv91[ebp], xmm0
	jmp	SHORT $LN20@DrawScene
$LN19@DrawScene:
	movss	xmm0, DWORD PTR _prevRight$[ebp]
	movss	DWORD PTR tv91[ebp], xmm0
$LN20@DrawScene:
	movss	xmm0, DWORD PTR tv91[ebp]
	movss	DWORD PTR _right$5[ebp], xmm0

; 710  : 			left	= max( -visible, prevLeft   );

	movss	xmm0, DWORD PTR _visible$6[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _prevLeft$[ebp]
	jbe	SHORT $LN21@DrawScene
	movss	xmm0, DWORD PTR _visible$6[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv129[ebp], xmm0
	jmp	SHORT $LN22@DrawScene
$LN21@DrawScene:
	movss	xmm0, DWORD PTR _prevLeft$[ebp]
	movss	DWORD PTR tv129[ebp], xmm0
$LN22@DrawScene:
	movss	xmm0, DWORD PTR tv129[ebp]
	movss	DWORD PTR _left$3[ebp], xmm0

; 711  : 			top		= min(  visible, prevTop    );

	movss	xmm0, DWORD PTR _prevTop$[ebp]
	comiss	xmm0, DWORD PTR _visible$6[ebp]
	jbe	SHORT $LN23@DrawScene
	movss	xmm0, DWORD PTR _visible$6[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN24@DrawScene
$LN23@DrawScene:
	movss	xmm0, DWORD PTR _prevTop$[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
$LN24@DrawScene:
	movss	xmm0, DWORD PTR tv131[ebp]
	movss	DWORD PTR _top$4[ebp], xmm0

; 712  : 			bottom	= max( -visible, prevBottom );

	movss	xmm0, DWORD PTR _visible$6[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _prevBottom$[ebp]
	jbe	SHORT $LN25@DrawScene
	movss	xmm0, DWORD PTR _visible$6[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv137[ebp], xmm0
	jmp	SHORT $LN26@DrawScene
$LN25@DrawScene:
	movss	xmm0, DWORD PTR _prevBottom$[ebp]
	movss	DWORD PTR tv137[ebp], xmm0
$LN26@DrawScene:
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR _bottom$2[ebp], xmm0

; 713  : 			fov = 2.0f * (float)atan( right / oneOVERtanHFOV );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _right$5[ebp]
	divss	xmm0, DWORD PTR [ecx+262904]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR tv473[ebp]
	movss	xmm0, DWORD PTR tv473[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _fov$1[ebp], xmm0

; 714  : 
; 715  : 			SetFOV( fov );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fov$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@Render3D@@QAEXMM@Z		; Render3D::SetFOV

; 716  : 			SetViewport( left, top, right, bottom );

	push	ecx
	movss	xmm0, DWORD PTR _bottom$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _right$5[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _top$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _left$3[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
$LN15@DrawScene:

; 717  : 		}
; 718  : 	}
; 719  : 
; 720  : 
; 721  : 	// Get our world space position from our viewpoint
; 722  : 	viewpoint->GetPos( &position );

	lea	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z	; TViewPoint::GetPos

; 723  : 
; 724  : 	// Apply the offset (if provided) -- in world space for now (TODO: camera space?)
; 725  : 	if (offset) {

	cmp	DWORD PTR _offset$[ebp], 0
	je	SHORT $LN14@DrawScene

; 726  : 		position.x += offset->x;

	mov	edx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp]
	addss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _position$[ebp], xmm0

; 727  : 		position.y += offset->y;

	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR _position$[ebp+4], xmm0

; 728  : 		position.z += offset->z;

	mov	ecx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+8]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR _position$[ebp+8], xmm0
$LN14@DrawScene:

; 729  : 	}
; 730  : 
; 731  : 	// Call Render3D's cammera update function with the new position
; 732  : 	SetCamera( &position, orientation );

	mov	edx, DWORD PTR _orientation$[ebp]
	push	edx
	lea	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera

; 733  : 
; 734  : 
; 735  : 	// Update the sky color based on our current attitude and position
; 736  : 	// sfr: this is called inside DrawSky
; 737  : 	//AdjustSkyColor();
; 738  : 
; 739  : //	float opacity = viewpoint->CloudOpacity();
; 740  : /*	if (g_bEnableWeatherExtensions) 
; 741  : 	{
; 742  : 	  if (position.z > viewpoint->GetLocalCloudTops()) // are we below clouds? -ve z's
; 743  : 		{
; 744  : 			float tvis = viewpoint->GetVisibility();
; 745  : 			visibility = 0.95f * visibility + 0.05f * tvis; // phase in new vis
; 746  : 			float train = viewpoint->GetRainFactor();
; 747  : 			rainFactor = 0.95 * rainFactor + 0.05f * train; // phase in rain
; 748  : 			float temp = RealWeather->TemperatureAt(&position);
; 749  : 			static const float TEMP_RANGE = 10;
; 750  : 			static const float TEMP_MIN = TEMP_RANGE / 2.0f;
; 751  : 			
; 752  : 			if (temp < - TEMP_MIN) // all rain turns to snow
; 753  : 			{
; 754  : 				snowFactor = rainFactor;
; 755  : 				rainFactor = 0;
; 756  : 			}
; 757  : 			else if (temp < TEMP_MIN) // maybe do snow
; 758  : 			{
; 759  : 				temp += TEMP_MIN;
; 760  : 				snowFactor = rainFactor * (TEMP_RANGE - temp)/TEMP_RANGE;
; 761  : 				rainFactor = rainFactor * (temp / TEMP_RANGE);
; 762  : 			}
; 763  : 			else 
; 764  : 				snowFactor = 0;
; 765  : 			
; 766  : 			if (viewpoint->GetLightning())
; 767  : 			{
; 768  : 				thunderAndLightning = true;
; 769  : 				opacity = max(opacity, 0.97); // a flash of lightning.
; 770  : 				thundertimer = vuxRealTime + 10000.0f*PRANDFloatPos(); // in 10 seconds time
; 771  : 			}
; 772  : 			else 
; 773  : 				thunderAndLightning = false;
; 774  : 		}
; 775  : 	  else
; 776  : 		{
; 777  : 			visibility = 1;
; 778  : 			rainFactor = 0;
; 779  : 			snowFactor = 0;
; 780  :     }
; 781  : 
; 782  :     if (thundertimer > 0 && thundertimer < vuxRealTime)
; 783  : 		{
; 784  : 			thunder = true;
; 785  : 			thundertimer = 0;
; 786  :     }
; 787  :     else
; 788  : 			thunder = false;
; 789  : 	}
; 790  : */
; 791  : /*	if (visibility < 1) // less than perfect.
; 792  : 	    opacity = max(opacity, 1.0 - visibility);
; 793  : 
; 794  : 	// Handle the entering/inside/leaving cloud effects
; 795  : 	if (opacity <= 0.0f && !Lightning) 
; 796  : 	{
; 797  : */		// We're not being affected by a cloud, the only effect is sun glare (if any)
; 798  : 		PreSceneCloudOcclusion( SunGlareWashout, 0xFFFFFFFF );

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263196]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreSceneCloudOcclusion@RenderOTW@@IAEXMK@Z ; RenderOTW::PreSceneCloudOcclusion

; 799  : /*	} 
; 800  : 	else
; 801  : 	{
; 802  : 		// We're being affected by a cloud.
; 803  : 		Tcolor		color;
; 804  : 		DWORD		c;
; 805  : 		float		scaler;
; 806  : 		float		blend;
; 807  : 
; 808  : 		if (thunderAndLightning) // Lightning for nuke
; 809  : 		{
; 810  : 		    color = TheTimeOfDay.GetLightningColor();
; 811  : 		}
; 812  : 		else if (Lightning)
; 813  : 		{
; 814  : 			color.r = 1.0F;
; 815  : 			color.b = 1.0F;
; 816  : 			color.g = 1.0F;
; 817  : 			lightningtimer += SimLibMajorFrameTime;
; 818  : 			if (lightningtimer > 5.0F)	// 5 seconds full white
; 819  : 				opacity = (0.97F - ((lightningtimer - 6) * 0.068F));
; 820  : 			else
; 821  : 				opacity = 0.97F;
; 822  : 			if (lightningtimer >= 20.0F)
; 823  : 			{
; 824  : 				lightningtimer = 0.0F;
; 825  : 				Lightning = false;
; 826  : 			}
; 827  : 		}
; 828  : 		else
; 829  : 		{
; 830  : 	    // Get the cloud properties
; 831  : 	    color	= viewpoint->CloudColor();
; 832  : 		}
; 833  : 
; 834  : 		// Factor in sun glare (if any)
; 835  : 		scaler	= 1.0f / (opacity + SunGlareWashout);
; 836  : 		blend	= max( opacity, SunGlareWashout );
; 837  : 
; 838  : 		// Decide on the composite blending color
; 839  : 		color.r = (opacity*color.r + SunGlareWashout) * scaler;
; 840  : 		color.g = (opacity*color.g + SunGlareWashout) * scaler;
; 841  : 		color.b = (opacity*color.b + SunGlareWashout) * scaler;
; 842  : 
; 843  : 		// JB 010618 vary the brightness on cloud thickness
; 844  : 		if (g_bEnableWeatherExtensions && !thunderAndLightning) 
; 845  : 		{
; 846  : 			float thickness = fabs(viewpoint->GetLocalCloudTops() - position.z);
; 847  : 			if (thickness > 0)
; 848  : 			{
; 849  : 				float tbrt = max(.2, min(1, g_fCloudThicknessFactor / thickness));
; 850  : 				brightness = 0.95f * brightness + 0.05f * tbrt; // phase in new brt
; 851  : 			}
; 852  : 			else
; 853  : 				brightness = 1.0;
; 854  : 
; 855  : 			color.r *= brightness;
; 856  : 			color.g *= brightness;
; 857  : 			color.b *= brightness;
; 858  : 		}
; 859  : 
; 860  : 		// Construct a 32 bit RGB value
; 861  : 		ProcessColor( &color );
; 862  : 		c  = (FloatToInt32(color.r * 255.9f));
; 863  : 		c |= (FloatToInt32(color.g * 255.9f)) << 8;
; 864  : 		c |= (FloatToInt32(color.b * 255.9f)) << 16;
; 865  : 
; 866  : 		// Are we IN it our NEAR it?
; 867  : 		if (blend >= 1.0f)
; 868  : 		{
; 869  : 			// Clear the screen to cloud color
; 870  : 			context.SetState( MPR_STA_BG_COLOR, c );
; 871  : 			ClearFrame();
; 872  : 
; 873  : 			// Draw the tunnel vision effect if any
; 874  : 			if (tunnelSolidWidth > 0.0f)
; 875  : 			{
; 876  : 				SetFOV( prevFOV );
; 877  : 				SetViewport( prevLeft, prevTop, prevRight, prevBottom );
; 878  : 			}
; 879  : 
; 880  : 			// And we're done!
; 881  : 			return;
; 882  : 
; 883  : 		}
; 884  : 		else
; 885  : 		{
; 886  : 			// We're entering or leaving the cloud, so "fuzz" things
; 887  : 			PreSceneCloudOcclusion( blend, c );
; 888  : 		}
; 889  : 	}
; 890  : */
; 891  : 	// RED - Update weather
; 892  : 	realWeather->RefreshWeather(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?RefreshWeather@RealWeather@@QAEXPAVRenderOTW@@@Z ; RealWeather::RefreshWeather

; 893  : 	// RED - Refresh colors
; 894  : 	SetTimeOfDayColor();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax

; 895  : 	//JAM 15Dec03
; 896  : 	BOOL bToggle = FALSE; 

	mov	DWORD PTR _bToggle$[ebp], 0

; 897  : 
; 898  : 	if(context.bZBuffering && DisplayOptions.bZBuffering){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+140], 0
	je	SHORT $LN13@DrawScene
	movzx	edx, BYTE PTR ?DisplayOptions@@3VDisplayOptionsClass@@A+16
	test	edx, edx
	je	SHORT $LN13@DrawScene

; 899  : 		bToggle = TRUE;

	mov	DWORD PTR _bToggle$[ebp], 1

; 900  : 		context.SetZBuffering(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetZBuffering@ContextMPR@@QAEXH@Z	; ContextMPR::SetZBuffering

; 901  : 		context.SetState(MPR_STA_DISABLES,MPR_SE_Z_WRITE);

	push	512					; 00000200H
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState

; 902  : 		context.SetState(MPR_STA_DISABLES,MPR_SE_Z_BUFFERING);

	push	8
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState
$LN13@DrawScene:

; 903  : 	}
; 904  : 
; 905  : 	// Draw the sky
; 906  : 	DrawSky();	

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawSky@RenderOTW@@IAEHXZ		; RenderOTW::DrawSky

; 907  : 
; 908  : 	//realWeather->Draw();
; 909  :    //JAM 15Dec03
; 910  : 	if(bToggle && DisplayOptions.bZBuffering){

	cmp	DWORD PTR _bToggle$[ebp], 0
	je	SHORT $LN12@DrawScene
	movzx	eax, BYTE PTR ?DisplayOptions@@3VDisplayOptionsClass@@A+16
	test	eax, eax
	je	SHORT $LN12@DrawScene

; 911  : 		context.SetZBuffering(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetZBuffering@ContextMPR@@QAEXH@Z	; ContextMPR::SetZBuffering

; 912  : 		context.SetState(MPR_STA_ENABLES,MPR_SE_Z_WRITE);

	push	512					; 00000200H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState

; 913  : 		context.SetState(MPR_STA_ENABLES,MPR_SE_Z_BUFFERING);

	push	8
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState
$LN12@DrawScene:

; 914  : 	}
; 915  : 	//JAM
; 916  : 
; 917  : 	// Sort the object list based on our location
; 918  : 	viewpoint->ResetObjectTraversal();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ResetObjectTraversal@RViewPoint@@QAEXXZ ; RViewPoint::ResetObjectTraversal

; 919  : 
; 920  : 	// Figure out which list would contain our eye point
; 921  : 	containingList = viewpoint->GetContainingList( position.z );

	push	ecx
	movss	xmm0, DWORD PTR _position$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetContainingList@RViewPoint@@QAEHM@Z	; RViewPoint::GetContainingList
	mov	DWORD PTR _containingList$[ebp], eax

; 922  : 
; 923  : 	
; 924  : 	// Setup the layers for the 2D DX Engine
; 925  : 	/*switch(containingList){
; 926  : 		case	0	:
; 927  : 		case	1	:	{DWORD	DrawOrder[]={LAYER_ROOF, LAYER_STRATUS2, LAYER_MIDDLE, LAYER_STRATUS1, LAYER_GROUND, LAYER_TOP};
; 928  : 						// RED - Weather Stuff - if weatehr > FAIR, do not draw some layers, they are not visible
; 929  : 						//if(realWeather->weatherCondition > FAIR) DrawOrder[0] = DrawOrder[1] = DrawOrder[2] = LAYER_NODRAW;
; 930  : 						TheDXEngine.DX2D_SetDrawOrder(DrawOrder);}
; 931  : 						break;
; 932  : 		
; 933  : 		case	2	:	{DWORD	DrawOrder[]={LAYER_ROOF, LAYER_STRATUS2, LAYER_GROUND, LAYER_STRATUS1, LAYER_MIDDLE, LAYER_TOP};
; 934  : 						// RED - Weather Stuff - if weatehr > FAIR, do not draw some layers, they are not visible
; 935  : 						//if(realWeather->weatherCondition > FAIR) DrawOrder[2] = LAYER_NODRAW;
; 936  : 						TheDXEngine.DX2D_SetDrawOrder(DrawOrder);}
; 937  : 						break;
; 938  : 		case	3	:
; 939  : 		case	4	:	{DWORD	DrawOrder[]={LAYER_GROUND, LAYER_STRATUS1, LAYER_MIDDLE, LAYER_STRATUS2, LAYER_ROOF, LAYER_TOP};
; 940  : 						// RED - Weather Stuff - if weatehr > FAIR, do not draw some layers, they are not visible
; 941  : 						//if(realWeather->weatherCondition > FAIR) DrawOrder[0] = LAYER_NODRAW;
; 942  : 						TheDXEngine.DX2D_SetDrawOrder(DrawOrder);}
; 943  : 						break;
; 944  : 
; 945  : 		default		:	{DWORD	DrawOrder[]={LAYER_NODRAW, LAYER_NODRAW, LAYER_NODRAW, LAYER_NODRAW, LAYER_NODRAW, LAYER_TOP };
; 946  : 						TheDXEngine.DX2D_SetDrawOrder(DrawOrder);}
; 947  : 						
; 948  : 	}*/
; 949  : 	
; 950  : 	// Make the wweaher to decide drawing order for 2D/Alpha stuff
; 951  : 	realWeather->SetDrawingOrder(position.z);

	push	ecx
	movss	xmm0, DWORD PTR _position$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?SetDrawingOrder@RealWeather@@QAEXM@Z	; RealWeather::SetDrawingOrder

; 952  : 	realWeather->Draw();

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?Draw@RealWeather@@QAEXXZ		; RealWeather::Draw

; 953  : 	
; 954  : 	// Special case if we're above the roof and the roof is diplayed
; 955  : 	if ((containingList == 4) && (skyRoof)){

	cmp	DWORD PTR _containingList$[ebp], 4
	jne	$LN11@DrawScene
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+263100], 0
	je	$LN11@DrawScene

; 956  : 		viewpoint->ObjectsAboveRoof()->DrawBeyond( 0.0f, 0, this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveRoof
	mov	ecx, eax
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 957  : 
; 958  : 		// Restore the FOV if it was changed by the tunnel code
; 959  : 		if (tunnelSolidWidth > 0.0f){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263244]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@DrawScene

; 960  : 			SetFOV( prevFOV );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevFOV$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@Render3D@@QAEXMM@Z		; Render3D::SetFOV

; 961  : 			SetViewport( prevLeft, prevTop, prevRight, prevBottom );

	push	ecx
	movss	xmm0, DWORD PTR _prevBottom$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevRight$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevTop$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevLeft$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
$LN10@DrawScene:

; 962  : 		}
; 963  : 		return;

	jmp	$LN17@DrawScene
$LN11@DrawScene:

; 964  : 	}
; 965  : 
; 966  : 	// Draw scene components in height sorted groups dependent of our altitude
; 967  : 	// Upward order (don't draw the one we're in)
; 968  : 	if( containingList > 0 ){

	cmp	DWORD PTR _containingList$[ebp], 0
	jle	$LN6@DrawScene

; 969  : 		//START_PROFILE("Grnd & Objects");
; 970  : 		DrawGroundAndObjects(viewpoint->ObjectsInTerrain());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInTerrain
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGroundAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@@Z ; RenderOTW::DrawGroundAndObjects

; 971  : 		//STOP_PROFILE("Grnd & Objects");
; 972  : 
; 973  : 		if( containingList > 1 ){

	cmp	DWORD PTR _containingList$[ebp], 1
	jle	$LN6@DrawScene

; 974  : 			viewpoint->ObjectsBelowClouds()->DrawBeyond(0.f,0,this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsBelowClouds
	mov	ecx, eax
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 975  : 			if( containingList > 2 ){

	cmp	DWORD PTR _containingList$[ebp], 2
	jle	SHORT $LN6@DrawScene

; 976  : 				//START_PROFILE("Clouds & Objects");
; 977  : 				DrawCloudsAndObjects(viewpoint->Clouds(),viewpoint->ObjectsInClouds());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInClouds
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::Clouds
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCloudsAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@0@Z ; RenderOTW::DrawCloudsAndObjects

; 978  : 				//STOP_PROFILE("Clouds & Objects");
; 979  : 				if( containingList > 3 ){

	cmp	DWORD PTR _containingList$[ebp], 3
	jle	SHORT $LN6@DrawScene

; 980  : 					viewpoint->ObjectsAboveClouds()->DrawBeyond(0.f,0,this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveClouds
	mov	ecx, eax
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond
$LN6@DrawScene:

; 981  : 				}
; 982  : 			}
; 983  : 		}
; 984  : 	}
; 985  : 
; 986  : 	// Downward order (finishing with the one we're in)
; 987  : 	viewpoint->ObjectsAboveRoof()->DrawBeyond(0.f,0,this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveRoof
	mov	ecx, eax
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 988  : 	if( containingList < 4 ){

	cmp	DWORD PTR _containingList$[ebp], 4
	jge	$LN2@DrawScene

; 989  : 		viewpoint->ObjectsAboveClouds()->DrawBeyond(0.f,0,this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsAboveClouds
	mov	ecx, eax
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 990  : 		if( containingList < 3 ){

	cmp	DWORD PTR _containingList$[ebp], 3
	jge	SHORT $LN2@DrawScene

; 991  : 			DrawCloudsAndObjects(viewpoint->Clouds(),viewpoint->ObjectsInClouds());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInClouds
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::Clouds
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCloudsAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@0@Z ; RenderOTW::DrawCloudsAndObjects

; 992  : 			if( containingList < 2 ){

	cmp	DWORD PTR _containingList$[ebp], 2
	jge	SHORT $LN2@DrawScene

; 993  : 				viewpoint->ObjectsBelowClouds()->DrawBeyond(0.f,0,this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsBelowClouds
	mov	ecx, eax
	call	?DrawBeyond@ObjectDisplayList@@QAEXMHPAVRenderOTW@@@Z ; ObjectDisplayList::DrawBeyond

; 994  : 				if( containingList < 1 ){

	cmp	DWORD PTR _containingList$[ebp], 1
	jge	SHORT $LN2@DrawScene

; 995  : 					//START_PROFILE("Grnd & Objects");
; 996  : 					DrawGroundAndObjects(viewpoint->ObjectsInTerrain());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsInTerrain
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGroundAndObjects@RenderOTW@@IAEXPAVObjectDisplayList@@@Z ; RenderOTW::DrawGroundAndObjects
$LN2@DrawScene:

; 997  : 					//STOP_PROFILE("Grnd & Objects");
; 998  : 				}
; 999  : 			}		
; 1000 : 		}
; 1001 : 	}
; 1002 : 
; 1003 : 
; 1004 : 	// Update Particle Sys
; 1005 : #ifdef	USE_NEW_PS
; 1006 : 	DrawableParticleSys::PS_Exec(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?PS_Exec@DrawableParticleSys@@SAXPAVRenderOTW@@@Z ; DrawableParticleSys::PS_Exec
	add	esp, 4

; 1007 : #endif
; 1008 : 
; 1009 : 	// Restore the FOV if it was changed by the tunnel code
; 1010 : 	if(tunnelSolidWidth > 0.0f){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263244]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@DrawScene

; 1011 : 		SetFOV(prevFOV);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevFOV$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@Render3D@@QAEXMM@Z		; Render3D::SetFOV

; 1012 : 		SetViewport(prevLeft,prevTop,prevRight,prevBottom);

	push	ecx
	movss	xmm0, DWORD PTR _prevBottom$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevRight$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevTop$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _prevLeft$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 1013 : 		SetCamera(&position,orientation);

	mov	ecx, DWORD PTR _orientation$[ebp]
	push	ecx
	lea	edx, DWORD PTR _position$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera
$LN1@DrawScene:
$LN17@DrawScene:

; 1014 : 	}
; 1015 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?DrawScene@RenderOTW@@QAEXPBUTpoint@@PBUTrotation@@@Z ENDP ; RenderOTW::DrawScene
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\renderow.h
;	COMDAT ?GetFogColor@RenderOTW@@QAEPAUTcolor@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFogColor@RenderOTW@@QAEPAUTcolor@@XZ PROC		; RenderOTW::GetFogColor, COMDAT
; _this$ = ecx

; 147  : 	Tcolor* GetFogColor( void )					{ return &haze_ground_color; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263144				; 000403e8H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFogColor@RenderOTW@@QAEPAUTcolor@@XZ ENDP		; RenderOTW::GetFogColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv89 = -16						; size = 4
_fog$ = -12						; size = 4
tv77 = -8						; size = 4
_valleyFog$ = -4					; size = 4
_distance$ = 8						; size = 4
_worldZ$ = 12						; size = 4
?GetValleyFog@RenderOTW@@QAEMMM@Z PROC			; RenderOTW::GetValleyFog
; _this$ = ecx

; 1410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1411 : 	float	fog;
; 1412 : 	float	valleyFog;
; 1413 : 
; 1414 : 	// Valley fog
; 1415 : 	static const float	VALLEY_HAZE_TOP			= 1000.0f;
; 1416 : 	static const float	VALLEY_HAZE_MAX			= 0.75f;
; 1417 : 	static const float	VALLEY_HAZE_START_RANGE	= PERSPECTIVE_RANGE;

	mov	eax, DWORD PTR ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA
	and	eax, 1
	jne	SHORT $LN5@GetValleyF
	mov	ecx, DWORD PTR ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA, ecx
	movss	xmm0, DWORD PTR ?PERSPECTIVE_RANGE@RenderOTW@@2MB
	movss	DWORD PTR ?VALLEY_HAZE_START_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB, xmm0
$LN5@GetValleyF:

; 1418 : 	static const float	VALLEY_HAZE_FULL_RANGE	= PERSPECTIVE_RANGE + 36000.0f;

	mov	edx, DWORD PTR ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA
	and	edx, 2
	jne	SHORT $LN4@GetValleyF
	mov	eax, DWORD PTR ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA
	or	eax, 2
	mov	DWORD PTR ?$S1@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4IA, eax
	movss	xmm0, DWORD PTR ?PERSPECTIVE_RANGE@RenderOTW@@2MB
	addss	xmm0, DWORD PTR __real@470ca000
	movss	DWORD PTR ?VALLEY_HAZE_FULL_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB, xmm0
$LN4@GetValleyF:

; 1419 : 
; 1420 : 	if(worldZ > -VALLEY_HAZE_TOP)

	movss	xmm0, DWORD PTR ?VALLEY_HAZE_TOP@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _worldZ$[ebp]
	comiss	xmm1, xmm0
	jbe	$LN3@GetValleyF

; 1421 : 	{
; 1422 : 		// We're below the top of the valley fog layer
; 1423 : 		valleyFog = (VALLEY_HAZE_TOP + worldZ)/VALLEY_HAZE_TOP;

	movss	xmm0, DWORD PTR ?VALLEY_HAZE_TOP@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	addss	xmm0, DWORD PTR _worldZ$[ebp]
	divss	xmm0, DWORD PTR ?VALLEY_HAZE_TOP@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	movss	DWORD PTR _valleyFog$[ebp], xmm0

; 1424 : 		valleyFog = min(valleyFog,VALLEY_HAZE_MAX);

	movss	xmm0, DWORD PTR ?VALLEY_HAZE_MAX@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	comiss	xmm0, DWORD PTR _valleyFog$[ebp]
	jbe	SHORT $LN8@GetValleyF
	movss	xmm0, DWORD PTR _valleyFog$[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN9@GetValleyF
$LN8@GetValleyF:
	movss	xmm0, DWORD PTR ?VALLEY_HAZE_MAX@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	movss	DWORD PTR tv77[ebp], xmm0
$LN9@GetValleyF:
	movss	xmm0, DWORD PTR tv77[ebp]
	movss	DWORD PTR _valleyFog$[ebp], xmm0

; 1425 : 
; 1426 : 		if(distance < VALLEY_HAZE_FULL_RANGE)

	movss	xmm0, DWORD PTR ?VALLEY_HAZE_FULL_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	comiss	xmm0, DWORD PTR _distance$[ebp]
	jbe	SHORT $LN2@GetValleyF

; 1427 : 		{
; 1428 : 			valleyFog *= (distance-VALLEY_HAZE_START_RANGE)/(VALLEY_HAZE_FULL_RANGE-VALLEY_HAZE_START_RANGE);

	movss	xmm0, DWORD PTR _distance$[ebp]
	subss	xmm0, DWORD PTR ?VALLEY_HAZE_START_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	movss	xmm1, DWORD PTR ?VALLEY_HAZE_FULL_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	subss	xmm1, DWORD PTR ?VALLEY_HAZE_START_RANGE@?1??GetValleyFog@RenderOTW@@QAEMMM@Z@4MB
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _valleyFog$[ebp]
	movss	DWORD PTR _valleyFog$[ebp], xmm0
$LN2@GetValleyF:

; 1429 : 		}
; 1430 : 
; 1431 : 		// Distance fog
; 1432 : 		fog = GetRangeOnlyFog(distance);

	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z	; RenderOTW::GetRangeOnlyFog
	fstp	DWORD PTR _fog$[ebp]

; 1433 : 
; 1434 : 		// Mixing
; 1435 : 		return max(fog,valleyFog);

	movss	xmm0, DWORD PTR _fog$[ebp]
	comiss	xmm0, DWORD PTR _valleyFog$[ebp]
	jbe	SHORT $LN10@GetValleyF
	movss	xmm0, DWORD PTR _fog$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN11@GetValleyF
$LN10@GetValleyF:
	movss	xmm0, DWORD PTR _valleyFog$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
$LN11@GetValleyF:
	fld	DWORD PTR tv89[ebp]
	jmp	SHORT $LN1@GetValleyF

; 1436 : 	}
; 1437 : 	else

	jmp	SHORT $LN1@GetValleyF
$LN3@GetValleyF:

; 1438 : 	{
; 1439 : 		// We're above the valley fog layer
; 1440 : 		return GetRangeOnlyFog(distance);

	push	ecx
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRangeOnlyFog@RenderOTW@@QAEMM@Z	; RenderOTW::GetRangeOnlyFog
$LN1@GetValleyF:

; 1441 : 	}
; 1442 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetValleyFog@RenderOTW@@QAEMMM@Z ENDP			; RenderOTW::GetValleyFog
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\renderow.h
;	COMDAT ?GetRangeOnlyFog@RenderOTW@@QAEMM@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_range$ = 8						; size = 4
?GetRangeOnlyFog@RenderOTW@@QAEMM@Z PROC		; RenderOTW::GetRangeOnlyFog, COMDAT
; _this$ = ecx

; 144  : 	float GetRangeOnlyFog(float range)			{ return min((range-haze_start)/haze_depth,1.f); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _range$[ebp]
	subss	xmm0, DWORD PTR [eax+263080]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+263084]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@GetRangeOn
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _range$[ebp]
	subss	xmm0, DWORD PTR [edx+263080]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+263084]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN4@GetRangeOn
$LN3@GetRangeOn:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv77[ebp], xmm0
$LN4@GetRangeOn:
	fld	DWORD PTR tv77[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRangeOnlyFog@RenderOTW@@QAEMM@Z ENDP		; RenderOTW::GetRangeOnlyFog
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\renderow.h
;	COMDAT ?SetFilteringMode@RenderOTW@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetFilteringMode@RenderOTW@@QAEXH@Z PROC		; RenderOTW::SetFilteringMode, COMDAT
; _this$ = ecx

; 140  : 	void SetFilteringMode( BOOL state )			{ filtering = state; SetupStates(); };	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+263104], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupStates@RenderOTW@@IAEXXZ		; RenderOTW::SetupStates
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFilteringMode@RenderOTW@@QAEXH@Z ENDP		; RenderOTW::SetFilteringMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\renderow.h
;	COMDAT ?SetDitheringMode@RenderOTW@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetDitheringMode@RenderOTW@@QAEXH@Z PROC		; RenderOTW::SetDitheringMode, COMDAT
; _this$ = ecx

; 137  : 	void SetDitheringMode( BOOL state )			{ dithered = state; SetupStates(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+263092], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupStates@RenderOTW@@IAEXXZ		; RenderOTW::SetupStates
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDitheringMode@RenderOTW@@QAEXH@Z ENDP		; RenderOTW::SetDitheringMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\renderow.h
;	COMDAT ?SetHazeMode@RenderOTW@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetHazeMode@RenderOTW@@QAEXH@Z PROC			; RenderOTW::SetHazeMode, COMDAT
; _this$ = ecx

; 122  : 	void SetHazeMode( BOOL state )				{ hazed = state; SetupStates(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+263096], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupStates@RenderOTW@@IAEXXZ		; RenderOTW::SetupStates
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHazeMode@RenderOTW@@QAEXH@Z ENDP			; RenderOTW::SetHazeMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
tv142 = -16						; size = 4
tv133 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_level$ = 8						; size = 4
?SetTerrainTextureLevel@RenderOTW@@QAEXH@Z PROC		; RenderOTW::SetTerrainTextureLevel
; _this$ = ecx

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 273  : 	// Limit the texture level to legal values
; 274  : 	textureLevel = max( level, viewpoint->GetMinLOD()-1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetMinLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMinLOD
	sub	eax, 1
	cmp	DWORD PTR _level$[ebp], eax
	jle	SHORT $LN7@SetTerrain
	mov	ecx, DWORD PTR _level$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN8@SetTerrain
$LN7@SetTerrain:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetMinLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMinLOD
	sub	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN8@SetTerrain:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR [eax+263232], ecx

; 275  : 	textureLevel = min( textureLevel, viewpoint->GetMaxLOD() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+263232], eax
	jge	SHORT $LN9@SetTerrain
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263232]
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN10@SetTerrain
$LN9@SetTerrain:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	mov	DWORD PTR tv133[ebp], eax
$LN10@SetTerrain:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR [edx+263232], eax

; 276  : 	textureLevel = min( textureLevel, TheMap.LastFarTexLOD() );

	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?LastFarTexLOD@TMap@@QAEHXZ		; TMap::LastFarTexLOD
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+263232], eax
	jge	SHORT $LN11@SetTerrain
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263232]
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN12@SetTerrain
$LN11@SetTerrain:
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?LastFarTexLOD@TMap@@QAEHXZ		; TMap::LastFarTexLOD
	mov	DWORD PTR tv142[ebp], eax
$LN12@SetTerrain:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR [ecx+263232], edx

; 277  : 	
; 278  : 	// Rearrange the fog settings
; 279  : 	//JAM 13Nov03
; 280  : 	if(realWeather->weatherCondition == INCLEMENT)

	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [eax+15688], 4
	jne	SHORT $LN4@SetTerrain

; 281  : 	{
; 282  : 		haze_start = far_clip*.05f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262876]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+263080], xmm0

; 283  : 		haze_depth = far_clip*.3f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262876]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263084], xmm0
	jmp	$LN1@SetTerrain
$LN4@SetTerrain:

; 284  : 	}
; 285  : 	else if(realWeather->weatherCondition == POOR)

	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [edx+15688], 3
	jne	SHORT $LN2@SetTerrain

; 286  : 	{
; 287  : 		haze_start = far_clip*.1f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262876]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263080], xmm0

; 288  : 		haze_depth = far_clip*.6f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262876]
	mulss	xmm0, DWORD PTR __real@3f19999a
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+263084], xmm0

; 289  : 	}
; 290  : 	else

	jmp	SHORT $LN1@SetTerrain
$LN2@SetTerrain:

; 291  : 	{
; 292  : 		haze_start = far_clip*.1f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262876]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+263080], xmm0

; 293  : 		haze_depth = far_clip*.6f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262876]
	mulss	xmm0, DWORD PTR __real@3f19999a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263084], xmm0
$LN1@SetTerrain:

; 294  : 	}
; 295  : 
; 296  : 	// Rearrange the texture blend settings
; 297  : //	blend_start	= viewpoint->GetMaxRange( textureLevel - 1 );
; 298  : //	blend_depth	= viewpoint->GetMaxRange( textureLevel ) * 0.8f;
; 299  : 
; 300  : 	// Convert from range from viewer to range from start
; 301  : 	haze_depth	-= haze_start;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263084]
	subss	xmm0, DWORD PTR [eax+263080]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263084], xmm0

; 302  : 
; 303  : 	// Reevaluate which rendering states to use for each LOD
; 304  : 	SetupStates();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupStates@RenderOTW@@IAEXXZ		; RenderOTW::SetupStates

; 305  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTerrainTextureLevel@RenderOTW@@QAEXH@Z ENDP		; RenderOTW::SetTerrainTextureLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EndDraw@RenderOTW@@UAEXXZ PROC				; RenderOTW::EndDraw
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	context.EndDraw();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?EndDraw@ContextMPR@@QAEXXZ		; ContextMPR::EndDraw

; 265  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndDraw@RenderOTW@@UAEXXZ ENDP				; RenderOTW::EndDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartDraw@RenderOTW@@UAEXXZ PROC			; RenderOTW::StartDraw
; _this$ = ecx

; 243  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 	Render3D::StartDraw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartDraw@Render3D@@UAEXXZ		; Render3D::StartDraw

; 245  : 
; 246  : 	if( TheTimeOfDay.GetNVGmode() )

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetNVGmode@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetNVGmode
	test	eax, eax
	je	SHORT $LN2@StartDraw

; 247  : 	{
; 248  : 		Drawable2D::SetGreenMode(TRUE);

	push	1
	call	?SetGreenMode@Drawable2D@@SAXH@Z	; Drawable2D::SetGreenMode
	add	esp, 4

; 249  : //		DrawableOvercast::SetGreenMode(TRUE);
; 250  : 		realWeather->SetGreenMode(TRUE); //JAM 10Nov03

	push	1
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?SetGreenMode@RealWeather@@QAEXH@Z	; RealWeather::SetGreenMode

; 251  : 		TheColorBank.SetColorMode(ColorBankClass::GreenMode);

	push	2
	call	?SetColorMode@ColorBankClass@@SAXW4ColorMode@1@@Z ; ColorBankClass::SetColorMode
	add	esp, 4

; 252  : 	} else 	{

	jmp	SHORT $LN3@StartDraw
$LN2@StartDraw:

; 253  : 		Drawable2D::SetGreenMode(FALSE);

	push	0
	call	?SetGreenMode@Drawable2D@@SAXH@Z	; Drawable2D::SetGreenMode
	add	esp, 4

; 254  : //		DrawableOvercast::SetGreenMode(FALSE);
; 255  : 		realWeather->SetGreenMode(FALSE); //JAM 10Nov03

	push	0
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?SetGreenMode@RealWeather@@QAEXH@Z	; RealWeather::SetGreenMode

; 256  : 		TheColorBank.SetColorMode(ColorBankClass::NormalMode);

	push	0
	call	?SetColorMode@ColorBankClass@@SAXW4ColorMode@1@@Z ; ColorBankClass::SetColorMode
	add	esp, 4
$LN3@StartDraw:

; 257  : 	}
; 258  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartDraw@RenderOTW@@UAEXXZ ENDP			; RenderOTW::StartDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
?Cleanup@RenderOTW@@UAEXXZ PROC				; RenderOTW::Cleanup
; _this$ = ecx

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	// Stop receiving time updates
; 203  : 	TheTimeManager.ReleaseTimeUpdateCB( TimeUpdateCallback, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?TimeUpdateCallback@RenderOTW@@KAXPAX@Z ; RenderOTW::TimeUpdateCallback
	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ; TimeManager::ReleaseTimeUpdateCB

; 204  : 
; 205  : 	// Release the memory used to hold the LOD data blocks
; 206  : 	ShiAssert( LODdata );
; 207  : 	delete[] LODdata;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 208  : 	LODdata = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263364], 0

; 209  : 	
; 210  : 	// Release the memory for the array of transformed vertex buffer pointers
; 211  : 	ShiAssert( vertexBuffer );
; 212  : 	delete[] vertexBuffer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263356]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 213  : 	vertexBuffer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263356], 0

; 214  : 
; 215  : 	// Release the memory for the list of vertex spans
; 216  : 	ShiAssert( spanList );
; 217  : 	delete[] spanList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263348]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 218  : 	spanList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263348], 0

; 219  : 
; 220  : 	// Release the memory for the the transformed vertex buffers
; 221  : 	ShiAssert( vertexMemory );
; 222  : 	delete[] vertexMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263360]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 223  : 	vertexMemory = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263360], 0

; 224  : 	
; 225  : 	// Set our allowable ranges to 0
; 226  : 	maxSpanOffset		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263340], 0

; 227  : 	maxSpanExtent		= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263336], 0

; 228  : 	spanListMaxEntries	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263344], 0

; 229  : 
; 230  : 	// Discard the pointer to our associated TViewPoint object
; 231  : 	viewpoint = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263088], 0

; 232  : 
; 233  : 	// Call our parent's cleanup
; 234  : 	Render3D::Cleanup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@Render3D@@UAEXXZ		; Render3D::Cleanup

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@RenderOTW@@UAEXXZ ENDP				; RenderOTW::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otw.cpp
_TEXT	SEGMENT
$T1 = -2364						; size = 4
tv449 = -2360						; size = 4
$T2 = -2356						; size = 4
$T3 = -2352						; size = 4
$T4 = -2348						; size = 4
tv209 = -2344						; size = 4
_usedLODcount$ = -2340					; size = 4
_LODbufferSize$ = -2336					; size = 4
_LOD$ = -2332						; size = 4
_this$ = -2328						; size = 4
_buffer$5 = -2324					; size = 580
_buffer$6 = -1744					; size = 580
_buffer$7 = -1164					; size = 580
_buffer$8 = -584					; size = 580
__$ArrayPad$ = -4					; size = 4
_imageBuffer$ = 8					; size = 4
_vp$ = 12						; size = 4
?Setup@RenderOTW@@UAEXPAVImageBuffer@@PAVRViewPoint@@@Z PROC ; RenderOTW::Setup
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2364				; 0000093cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	int				usedLODcount;
; 73   : 	int				LOD;
; 74   : 	int				LODbufferSize;
; 75   : 
; 76   : 
; 77   : 	// Call our parents Setup code (win is available only after this call)
; 78   : 	Render3D::Setup( imageBuffer );

	mov	eax, DWORD PTR _imageBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Setup@Render3D@@UAEXPAVImageBuffer@@@Z	; Render3D::Setup

; 79   : 	
; 80   : 	// Retain a pointer to the TViewPoint we are to use
; 81   : 	viewpoint = vp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vp$[ebp]
	mov	DWORD PTR [ecx+263088], edx

; 82   : 
; 83   : 	// Start with the default light source position (over head)
; 84   : 	lightTheta		= 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+263124], xmm0

; 85   : 	lightPhi		= PI_OVER_2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fdb
	movss	DWORD PTR [ecx+263128], xmm0

; 86   : 	SunGlareValue	= 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+263192], xmm0

; 87   : 	SunGlareWashout	= 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+263196], xmm0

; 88   : //	smoothed = 0; // intialise to something
; 89   : 	textureLevel = 4; //JAM 01Dec03 - Hardcoding this for now, to be removed.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263232], 4

; 90   : 	filtering = hazed = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263096], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263104], 0

; 91   : 
; 92   : 	// Start with no tunnel vision or cloud effects
; 93   : 	SetTunnelPercent( 0.0f, 0x80808080 );

	push	-2139062144				; 80808080H
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTunnelPercent@RenderOTW@@QAEXMK@Z	; RenderOTW::SetTunnelPercent

; 94   : 	PreSceneCloudOcclusion( 0.0f, 0x80808080 );

	push	-2139062144				; 80808080H
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreSceneCloudOcclusion@RenderOTW@@IAEXMK@Z ; RenderOTW::PreSceneCloudOcclusion

; 95   : 		
; 96   : 	// Adjust our back clipping plane based on the range defined for this viewpoint
; 97   : 	SetFar( viewpoint->GetMaxRange() * 0.707f );	// far = maxRange * cos(half_angle)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetMaxRange@TViewPoint@@QAEMXZ		; TViewPoint::GetMaxRange
	fstp	DWORD PTR tv449[ebp]
	movss	xmm0, DWORD PTR tv449[ebp]
	mulss	xmm0, DWORD PTR __real@3f34fdf4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFar@Render3D@@QAEXM@Z		; Render3D::SetFar

; 98   : 
; 99   : 	// Set the default sky and haze properties
; 100  : 	SetDitheringMode( TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDitheringMode@RenderOTW@@QAEXH@Z	; RenderOTW::SetDitheringMode

; 101  : 	SetTerrainTextureLevel( TheMap.LastNearTexLOD() );

	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?LastNearTexLOD@TMap@@QAEHXZ		; TMap::LastNearTexLOD
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTerrainTextureLevel@RenderOTW@@QAEXH@Z ; RenderOTW::SetTerrainTextureLevel

; 102  : 	SetObjectTextureState( TRUE );	// Default to using textured objects

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetObjectTextureState@Render3D@@QAEXH@Z ; Render3D::SetObjectTextureState

; 103  : 	SetFilteringMode( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFilteringMode@RenderOTW@@QAEXH@Z	; RenderOTW::SetFilteringMode

; 104  : 	SetHazeMode( TRUE );			// (TRUE = ON, FALSE = OFF)

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHazeMode@RenderOTW@@QAEXH@Z		; RenderOTW::SetHazeMode

; 105  : 	SetRoofMode( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoofMode@RenderOTW@@QAEXH@Z		; RenderOTW::SetRoofMode

; 106  : //	SetSmoothShadingMode( TRUE ); // JPO - this uses the value from previous state
; 107  : 
; 108  :     // Default to full alpha blending for special effects
; 109  : //    alphaMode = TRUE;
; 110  : 
; 111  : 	// Setup a default sky (will be replaced by Time of Day processing)
; 112  : 	sky_color.r			= sky_color.g			= sky_color.b			= 0.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [edx+263140], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+263136], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+263132], xmm0

; 113  : 	haze_sky_color.r	= haze_sky_color.g		= haze_sky_color.b		= 0.4f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [edx+263188], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [eax+263184], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [ecx+263180], xmm0

; 114  : 	haze_ground_color.r	= haze_ground_color.g	= haze_ground_color.b	= 0.3f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [edx+263152], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [eax+263148], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [ecx+263144], xmm0

; 115  : 	earth_end_color.r	= earth_end_color.g		= earth_end_color.b		= 0.2f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [edx+263176], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [eax+263172], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [ecx+263168], xmm0

; 116  : 
; 117  : 
; 118  : 	// Figure out how many posts outward we might ever see at any detail level
; 119  : 	maxSpanOffset = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263340], 0

; 120  : 	for (LOD = viewpoint->GetMinLOD(); LOD <= viewpoint->GetMaxLOD(); LOD++) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetMinLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMinLOD
	mov	DWORD PTR _LOD$[ebp], eax
	jmp	SHORT $LN14@Setup
$LN13@Setup:
	mov	ecx, DWORD PTR _LOD$[ebp]
	add	ecx, 1
	mov	DWORD PTR _LOD$[ebp], ecx
$LN14@Setup:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	cmp	DWORD PTR _LOD$[ebp], eax
	jg	SHORT $LN12@Setup

; 121  : 		maxSpanOffset = max( maxSpanOffset, viewpoint->GetMaxPostRange( LOD ) );

	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetMaxPostRange@TViewPoint@@QAEHH@Z	; TViewPoint::GetMaxPostRange
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+263340], eax
	jle	SHORT $LN17@Setup
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263340]
	mov	DWORD PTR tv209[ebp], ecx
	jmp	SHORT $LN18@Setup
$LN17@Setup:
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetMaxPostRange@TViewPoint@@QAEHH@Z	; TViewPoint::GetMaxPostRange
	mov	DWORD PTR tv209[ebp], eax
$LN18@Setup:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv209[ebp]
	mov	DWORD PTR [ecx+263340], edx

; 122  : 	}

	jmp	$LN13@Setup
$LN12@Setup:

; 123  : 	maxSpanExtent = maxSpanOffset*2 + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263340]
	lea	edx, DWORD PTR [ecx+ecx+1]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+263336], edx

; 124  : 
; 125  : 	// Figure the total number of rings to deal with assuming max number of posts
; 126  : 	// across each of the detail levels.  Include room for a few extra padding rings
; 127  : 	usedLODcount		= viewpoint->GetMaxLOD() - viewpoint->GetMinLOD() + 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetMinLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMinLOD
	sub	esi, eax
	add	esi, 1
	mov	DWORD PTR _usedLODcount$[ebp], esi

; 128  : 	spanListMaxEntries	= (maxSpanOffset+1) * usedLODcount + 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263340]
	add	ecx, 1
	imul	ecx, DWORD PTR _usedLODcount$[ebp]
	add	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+263344], ecx

; 129  : 
; 130  : 
; 131  : 	// Allocate memory for our list of vertex spans
; 132  : 	spanList = new SpanListEntry[ spanListMaxEntries ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263344]
	mov	edx, 120				; 00000078H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [eax+263348], ecx

; 133  : 	firstEmptySpan = spanList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263348]
	mov	DWORD PTR [edx+263352], ecx

; 134  : 	if (!spanList) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+263348], 0
	jne	SHORT $LN11@Setup

; 135  : 		ShiError( "Failed to allocate span buffer" );

	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_07IANNNNBC@OTW?4cpp?$AA@
	push	135					; 00000087H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BP@EILOODAH@Failed?5to?5allocate?5span?5buffer?$AA@
	lea	ecx, DWORD PTR _buffer$5[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN11@Setup:

; 136  : 	}
; 137  : 	memset (spanList, 0, sizeof(*spanList) * spanListMaxEntries); // JPO zero out

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263344]
	imul	eax, 120				; 00000078H
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263348]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 138  : 
; 139  : 	// Allocate memory for the the transformed vertex buffers we need
; 140  : 	LODbufferSize = (maxSpanExtent) * (maxSpanExtent);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+263336]
	imul	edx, DWORD PTR [ecx+263336]
	mov	DWORD PTR _LODbufferSize$[ebp], edx

; 141  : 	vertexMemory = new TerrainVertex[ usedLODcount * LODbufferSize ];

	mov	eax, DWORD PTR _usedLODcount$[ebp]
	imul	eax, DWORD PTR _LODbufferSize$[ebp]
	xor	ecx, ecx
	mov	edx, 60					; 0000003cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+263360], ecx

; 142  : 	if (!vertexMemory) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+263360], 0
	jne	SHORT $LN10@Setup

; 143  : 		ShiError("Failed to allocate transformed vertex buffer");

	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_07IANNNNBC@OTW?4cpp?$AA@
	push	143					; 0000008fH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0CN@BENOGLFA@Failed?5to?5allocate?5transformed?5v@
	lea	ecx, DWORD PTR _buffer$6[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN10@Setup:

; 144  : 	}
; 145  : 	memset(vertexMemory, 0, sizeof(*vertexMemory) * usedLODcount * LODbufferSize); // JPO start with 0

	mov	edx, DWORD PTR _usedLODcount$[ebp]
	imul	edx, 60					; 0000003cH
	imul	edx, DWORD PTR _LODbufferSize$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263360]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 146  : 
; 147  : 	// Allocate memory for the array of transformed vertex buffer pointers
; 148  : 	vertexBuffer = new TerrainVertex*[ (viewpoint->GetMaxLOD()+1) ];

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	add	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+263356], ecx

; 149  : 	if (!vertexBuffer) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+263356], 0
	jne	SHORT $LN9@Setup

; 150  : 		ShiError("Failed to allocate transformed vertex buffer list");

	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_07IANNNNBC@OTW?4cpp?$AA@
	push	150					; 00000096H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$8[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0DC@HNCJDNKO@Failed?5to?5allocate?5transformed?5v@
	lea	ecx, DWORD PTR _buffer$8[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN9@Setup:

; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	// Setup the + and - indexable vertex pointers (they point into the vertexMemory)
; 155  : 	for ( LOD = 0; LOD <= viewpoint->GetMaxLOD(); LOD++ ) {

	mov	DWORD PTR _LOD$[ebp], 0
	jmp	SHORT $LN8@Setup
$LN7@Setup:
	mov	edx, DWORD PTR _LOD$[ebp]
	add	edx, 1
	mov	DWORD PTR _LOD$[ebp], edx
$LN8@Setup:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	cmp	DWORD PTR _LOD$[ebp], eax
	jg	$LN6@Setup

; 156  : 		if ( LOD < viewpoint->GetMinLOD() ) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetMinLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMinLOD
	cmp	DWORD PTR _LOD$[ebp], eax
	jge	SHORT $LN5@Setup

; 157  : 			vertexBuffer[LOD] = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263356]
	mov	ecx, DWORD PTR _LOD$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 158  : 		} else {

	jmp	SHORT $LN4@Setup
$LN5@Setup:

; 159  : 			vertexBuffer[LOD] = vertexMemory + 
; 160  : 								(LOD-viewpoint->GetMinLOD()) * LODbufferSize +
; 161  : 								maxSpanExtent*maxSpanOffset + maxSpanOffset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetMinLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMinLOD
	mov	ecx, DWORD PTR _LOD$[ebp]
	sub	ecx, eax
	imul	ecx, DWORD PTR _LODbufferSize$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263360]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263336]
	imul	ecx, DWORD PTR [edx+263340]
	imul	ecx, 60					; 0000003cH
	add	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263340]
	imul	ecx, 60					; 0000003cH
	add	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263356]
	mov	edx, DWORD PTR _LOD$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN4@Setup:

; 162  : 		}
; 163  : 	}

	jmp	$LN7@Setup
$LN6@Setup:

; 164  : 
; 165  : 
; 166  : 	// Allocate memory for the array of information stored for each LOD (viewer location & vectors)
; 167  : 	LODdata = new LODdataBlock[ (viewpoint->GetMaxLOD()+1) ];	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetMaxLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetMaxLOD
	add	eax, 1
	xor	ecx, ecx
	mov	edx, 56					; 00000038H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+263364], ecx

; 168  : 	if ( !LODdata ) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+263364], 0
	jne	SHORT $LN3@Setup

; 169  : 		ShiError( "Failed to allocate memory for LOD step vector array" );

	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_07IANNNNBC@OTW?4cpp?$AA@
	push	169					; 000000a9H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$7[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0DE@HLCDCKBN@Failed?5to?5allocate?5memory?5for?5LO@
	lea	ecx, DWORD PTR _buffer$7[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN3@Setup:

; 170  : 	}
; 171  : 
; 172  : 	brightness = 1.0; // JB 010618 vary the brightness on cloud thickness

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+263212], xmm0

; 173  : 	visibility = 1.0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+263200], xmm0

; 174  : 	rainFactor = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+263204], xmm0

; 175  : 	snowFactor = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+263208], xmm0

; 176  : 	thunderAndLightning = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+263216], 0

; 177  : 	thundertimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263220], 0

; 178  : 	thunder = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+263217], 0

; 179  : 	Lightning = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+263224], 0

; 180  : 	lightningtimer = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+263228], xmm0

; 181  : 
; 182  : 	// Initialize the lighting conditions and register for future time of day updates
; 183  : 	TimeUpdateCallback( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?TimeUpdateCallback@RenderOTW@@KAXPAX@Z	; RenderOTW::TimeUpdateCallback
	add	esp, 4

; 184  : 	TheTimeManager.RegisterTimeUpdateCB( TimeUpdateCallback, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?TimeUpdateCallback@RenderOTW@@KAXPAX@Z ; RenderOTW::TimeUpdateCallback
	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ; TimeManager::RegisterTimeUpdateCB

; 185  : 
; 186  : 	//JAM 26Dec03
; 187  : 	if(DisplayOptions.bZBuffering)

	movzx	ecx, BYTE PTR ?DisplayOptions@@3VDisplayOptionsClass@@A+16
	test	ecx, ecx
	je	SHORT $LN2@Setup

; 188  : 		realWeather->Setup();

	push	0
	push	0
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?Setup@RealWeather@@QAEXPAVObjectDisplayList@@0@Z ; RealWeather::Setup

; 189  : 	else

	jmp	SHORT $LN1@Setup
$LN2@Setup:

; 190  : 		realWeather->Setup(viewpoint->ObjectsBelowClouds(),viewpoint->Clouds());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::Clouds
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ; RViewPoint::ObjectsBelowClouds
	push	eax
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?Setup@RealWeather@@QAEXPAVObjectDisplayList@@0@Z ; RealWeather::Setup
$LN1@Setup:

; 191  : 
; 192  : 	realWeather->SetRenderer(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?SetRenderer@RealWeather@@QAEXPAVRenderOTW@@@Z ; RealWeather::SetRenderer
$LN15@Setup:

; 193  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?Setup@RenderOTW@@UAEXPAVImageBuffer@@PAVRViewPoint@@@Z ENDP ; RenderOTW::Setup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?GetFOV@Render3D@@QAEMXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?GetFOV@Render3D@@QAEMXZ PROC				; Render3D::GetFOV, COMDAT
; _this$ = ecx

; 61   : 	float GetFOV( void )			{ return horizontal_half_angle * 2.0f; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262892]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFOV@Render3D@@QAEMXZ ENDP				; Render3D::GetFOV
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?SetFar@Render3D@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_distance$ = 8						; size = 4
?SetFar@Render3D@@QAEXM@Z PROC				; Render3D::SetFar, COMDAT
; _this$ = ecx

; 57   : 	void SetFar( float distance )	{ far_clip = distance; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _distance$[ebp]
	movss	DWORD PTR [eax+262876], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFar@Render3D@@QAEXM@Z ENDP				; Render3D::SetFar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?Cleanup@Render3D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cleanup@Render3D@@UAEXXZ PROC				; Render3D::Cleanup, COMDAT
; _this$ = ecx

; 49   : 	virtual void Cleanup( void )	{ Render2D::Cleanup(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@Render2D@@UAEXXZ		; Render2D::Cleanup
	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@Render3D@@UAEXXZ ENDP				; Render3D::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?viewportYtoPixel@VirtualDisplay@@QAEMM@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_y$ = 8							; size = 4
?viewportYtoPixel@VirtualDisplay@@QAEMM@Z PROC		; VirtualDisplay::viewportYtoPixel, COMDAT
; _this$ = ecx

; 169  :     float viewportYtoPixel( float y ) { return (y * scaleY) + shiftY; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ENDP		; VirtualDisplay::viewportYtoPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?viewportXtoPixel@VirtualDisplay@@QAEMM@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?viewportXtoPixel@VirtualDisplay@@QAEMM@Z PROC		; VirtualDisplay::viewportXtoPixel, COMDAT
; _this$ = ecx

; 168  :     float viewportXtoPixel( float x ) { return (x * scaleX) + shiftX; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ENDP		; VirtualDisplay::viewportXtoPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ PROC ; RViewPoint::ObjectsAboveRoof, COMDAT
; _this$ = ecx

; 68   : 	ObjectDisplayList*	ObjectsAboveRoof( void )	{ return &objectLists[4].displayList; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 28					; 0000001cH
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectsAboveRoof@RViewPoint@@QAEPAVObjectDisplayList@@XZ ENDP ; RViewPoint::ObjectsAboveRoof
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ PROC ; RViewPoint::ObjectsAboveClouds, COMDAT
; _this$ = ecx

; 67   : 	ObjectDisplayList*	ObjectsAboveClouds( void )	{ return &objectLists[3].displayList; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 28					; 0000001cH
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectsAboveClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ENDP ; RViewPoint::ObjectsAboveClouds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ PROC ; RViewPoint::ObjectsInClouds, COMDAT
; _this$ = ecx

; 66   : 	ObjectDisplayList*	ObjectsInClouds( void )		{ return &objectLists[2].displayList; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 28					; 0000001cH
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectsInClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ENDP ; RViewPoint::ObjectsInClouds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ PROC	; RViewPoint::Clouds, COMDAT
; _this$ = ecx

; 65   : 	ObjectDisplayList*	Clouds( void )				{ return &cloudList; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 208				; 000000d0H
	mov	esp, ebp
	pop	ebp
	ret	0
?Clouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ENDP	; RViewPoint::Clouds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ PROC ; RViewPoint::ObjectsBelowClouds, COMDAT
; _this$ = ecx

; 64   : 	ObjectDisplayList*	ObjectsBelowClouds( void )	{ return &objectLists[1].displayList; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 28					; 0000001cH
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectsBelowClouds@RViewPoint@@QAEPAVObjectDisplayList@@XZ ENDP ; RViewPoint::ObjectsBelowClouds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ PROC ; RViewPoint::ObjectsInTerrain, COMDAT
; _this$ = ecx

; 63   : 	ObjectDisplayList*	ObjectsInTerrain( void )	{ return &objectLists[0].displayList; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 28					; 0000001cH
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	add	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectsInTerrain@RViewPoint@@QAEPAVObjectDisplayList@@XZ ENDP ; RViewPoint::ObjectsInTerrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\objlist.h
;	COMDAT ?GetNextDrawDistance@ObjectDisplayList@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextDrawDistance@ObjectDisplayList@@QAEMXZ PROC	; ObjectDisplayList::GetNextDrawDistance, COMDAT
; _this$ = ecx

; 59   : 	float	GetNextDrawDistance( void )	{ if (nextToDraw) return nextToDraw->distance; else return -1.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@GetNextDra
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	fld	DWORD PTR [edx+44]
	jmp	SHORT $LN1@GetNextDra
	jmp	SHORT $LN1@GetNextDra
$LN2@GetNextDra:
	fld	DWORD PTR __real@bf800000
$LN1@GetNextDra:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextDrawDistance@ObjectDisplayList@@QAEMXZ ENDP	; ObjectDisplayList::GetNextDrawDistance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z PROC		; TViewPoint::GetPos, COMDAT
; _this$ = ecx

; 119  : 	void	GetPos( Tpoint *p )		{ *p = pos; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z ENDP		; TViewPoint::GetPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?Z@TViewPoint@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Z@TViewPoint@@QAEMXZ PROC				; TViewPoint::Z, COMDAT
; _this$ = ecx

; 117  : 	float	Z( void )	{ return pos.z; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?Z@TViewPoint@@QAEMXZ ENDP				; TViewPoint::Z
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetPost@TViewPoint@@QAEPAUTpost@@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_levelPostRow$ = 8					; size = 4
_levelPostCol$ = 12					; size = 4
_LOD$ = 16						; size = 4
?GetPost@TViewPoint@@QAEPAUTpost@@HHH@Z PROC		; TViewPoint::GetPost, COMDAT
; _this$ = ecx

; 80   : 	Tpost* GetPost( int levelPostRow, int levelPostCol, int LOD ) { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		return blockLists[LOD].GetPost( levelPostRow, levelPostCol );

	mov	eax, DWORD PTR _levelPostCol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _levelPostRow$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	call	?GetPost@TBlockList@@QAEPAUTpost@@HH@Z	; TBlockList::GetPost

; 82   : 	};

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetPost@TViewPoint@@QAEPAUTpost@@HHH@Z ENDP		; TViewPoint::GetPost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetMaxPostRange@TViewPoint@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_LOD$ = 8						; size = 4
?GetMaxPostRange@TViewPoint@@QAEHH@Z PROC		; TViewPoint::GetMaxPostRange, COMDAT
; _this$ = ecx

; 63   : 	int		GetMaxPostRange( int LOD )	{ return blockLists[LOD].GetMaxPostRange(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+24]
	call	?GetMaxPostRange@TBlockList@@QAEHXZ	; TBlockList::GetMaxPostRange
	mov	esp, ebp
	pop	ebp
	ret	4
?GetMaxPostRange@TViewPoint@@QAEHH@Z ENDP		; TViewPoint::GetMaxPostRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetMaxRange@TViewPoint@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxRange@TViewPoint@@QAEMXZ PROC			; TViewPoint::GetMaxRange, COMDAT
; _this$ = ecx

; 61   : 	float	GetMaxRange( void )			{ return maxRange[maxLOD]; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	fld	DWORD PTR [eax+ecx*4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxRange@TViewPoint@@QAEMXZ ENDP			; TViewPoint::GetMaxRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetMaxLOD@TViewPoint@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxLOD@TViewPoint@@QAEHXZ PROC			; TViewPoint::GetMaxLOD, COMDAT
; _this$ = ecx

; 50   : 	int		GetMaxLOD(void)		{ return maxLOD; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxLOD@TViewPoint@@QAEHXZ ENDP			; TViewPoint::GetMaxLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetMinLOD@TViewPoint@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinLOD@TViewPoint@@QAEHXZ PROC			; TViewPoint::GetMinLOD, COMDAT
; _this$ = ecx

; 49   : 	int		GetMinLOD(void)		{ return minLOD; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinLOD@TViewPoint@@QAEHXZ ENDP			; TViewPoint::GetMinLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tblklist.h
;	COMDAT ?GetMaxPostRange@TBlockList@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxPostRange@TBlockList@@QAEHXZ PROC		; TBlockList::GetMaxPostRange, COMDAT
; _this$ = ecx

; 57   : 	int  GetMaxPostRange( void )			{ return interestRange; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxPostRange@TBlockList@@QAEHXZ ENDP		; TBlockList::GetMaxPostRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\device.h
;	COMDAT ?IsHardware@DisplayDevice@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsHardware@DisplayDevice@@QAEHXZ PROC			; DisplayDevice::IsHardware, COMDAT
; _this$ = ecx

; 24   : 	BOOL			IsHardware( void )				{ ShiAssert(IsReady());  return m_DXCtx->m_eDeviceCategory > DXContext::D3DDeviceCategory_Software; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+60], 1
	jle	SHORT $LN3@IsHardware
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsHardware
$LN3@IsHardware:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsHardware:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHardware@DisplayDevice@@QAEHXZ ENDP			; DisplayDevice::IsHardware
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\imagebuf.h
;	COMDAT ?GetDisplayDevice@ImageBuffer@@QAEPAVDisplayDevice@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplayDevice@ImageBuffer@@QAEPAVDisplayDevice@@XZ PROC ; ImageBuffer::GetDisplayDevice, COMDAT
; _this$ = ecx

; 41   : 	DisplayDevice *GetDisplayDevice()	{ return device; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplayDevice@ImageBuffer@@QAEPAVDisplayDevice@@XZ ENDP ; ImageBuffer::GetDisplayDevice
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tmap.h
;	COMDAT ?LastFarTexLOD@TMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LastFarTexLOD@TMap@@QAEHXZ PROC			; TMap::LastFarTexLOD, COMDAT
; _this$ = ecx

; 36   : 	int		LastFarTexLOD( void )	{ return lastFarTexturedLOD; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12296]
	mov	esp, ebp
	pop	ebp
	ret	0
?LastFarTexLOD@TMap@@QAEHXZ ENDP			; TMap::LastFarTexLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tmap.h
;	COMDAT ?LastNearTexLOD@TMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LastNearTexLOD@TMap@@QAEHXZ PROC			; TMap::LastNearTexLOD, COMDAT
; _this$ = ecx

; 35   : 	int		LastNearTexLOD( void )	{ return lastNearTexturedLOD; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12292]
	mov	esp, ebp
	pop	ebp
	ret	0
?LastNearTexLOD@TMap@@QAEHXZ ENDP			; TMap::LastNearTexLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetLightningColor@CTimeOfDay@@QAE?AUTcolor@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetLightningColor@CTimeOfDay@@QAE?AUTcolor@@XZ PROC	; CTimeOfDay::GetLightningColor, COMDAT
; _this$ = ecx

; 149  : 	Tcolor GetLightningColor()					{ return LightningColor; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetLightningColor@CTimeOfDay@@QAE?AUTcolor@@XZ ENDP	; CTimeOfDay::GetLightningColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetSnowColor@CTimeOfDay@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSnowColor@CTimeOfDay@@QAEKXZ PROC			; CTimeOfDay::GetSnowColor, COMDAT
; _this$ = ecx

; 148  : 	DWORD GetSnowColor()						{ return SnowColor; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSnowColor@CTimeOfDay@@QAEKXZ ENDP			; CTimeOfDay::GetSnowColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetRainColor@CTimeOfDay@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRainColor@CTimeOfDay@@QAEKXZ PROC			; CTimeOfDay::GetRainColor, COMDAT
; _this$ = ecx

; 147  : 	DWORD GetRainColor()						{ return RainColor; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRainColor@CTimeOfDay@@QAEKXZ ENDP			; CTimeOfDay::GetRainColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetNVGmode@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNVGmode@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::GetNVGmode, COMDAT
; _this$ = ecx

; 69   : 	BOOL GetNVGmode()							{ return NVGmode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+348]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNVGmode@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::GetNVGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
