; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\Graphics\Renderer\Display.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?CircleX@@3PAMA					; CircleX
PUBLIC	?CircleY@@3PAMA					; CircleY
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?FontLUT@VirtualDisplay@@1QBEB			; VirtualDisplay::FontLUT
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?Font@VirtualDisplay@@1PAPBEA			; VirtualDisplay::Font
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?FontLength@VirtualDisplay@@1IB			; VirtualDisplay::FontLength
PUBLIC	?InvFont@VirtualDisplay@@1PAY07EA		; VirtualDisplay::InvFont
PUBLIC	?pFontSet@VirtualDisplay@@2PAUFontSet@@A	; VirtualDisplay::pFontSet
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?oldTop@VirtualDisplay@@1MA			; VirtualDisplay::oldTop
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?oldLeft@VirtualDisplay@@1MA			; VirtualDisplay::oldLeft
PUBLIC	?oldBottom@VirtualDisplay@@1MA			; VirtualDisplay::oldBottom
PUBLIC	?oldRight@VirtualDisplay@@1MA			; VirtualDisplay::oldRight
PUBLIC	?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
PUBLIC	?oldTarget@VirtualDisplay@@1PAUIDirectDrawSurface7@@A ; VirtualDisplay::oldTarget
PUBLIC	?r3d@VirtualDisplay@@1PAVRender3D@@A		; VirtualDisplay::r3d
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
_BSS	SEGMENT
?CircleX@@3PAMA DD 05bH DUP (?)				; CircleX
?CircleY@@3PAMA DD 05bH DUP (?)				; CircleY
?InvFont@VirtualDisplay@@1PAY07EA DB 0250H DUP (?)	; VirtualDisplay::InvFont
?pFontSet@VirtualDisplay@@2PAUFontSet@@A DD 01H DUP (?)	; VirtualDisplay::pFontSet
?oldTop@VirtualDisplay@@1MA DD 01H DUP (?)		; VirtualDisplay::oldTop
?oldLeft@VirtualDisplay@@1MA DD 01H DUP (?)		; VirtualDisplay::oldLeft
?oldBottom@VirtualDisplay@@1MA DD 01H DUP (?)		; VirtualDisplay::oldBottom
?oldRight@VirtualDisplay@@1MA DD 01H DUP (?)		; VirtualDisplay::oldRight
?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A DD 01H DUP (?) ; VirtualDisplay::renderTexture
?oldTarget@VirtualDisplay@@1PAUIDirectDrawSurface7@@A DD 01H DUP (?) ; VirtualDisplay::oldTarget
?r3d@VirtualDisplay@@1PAVRender3D@@A DD 01H DUP (?)	; VirtualDisplay::r3d
_BSS	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
_DATA	SEGMENT
?Font@VirtualDisplay@@1PAPBEA DD FLAT:_Space		; VirtualDisplay::Font
	DD	FLAT:_OpenParen
	DD	FLAT:_CloseParen
	DD	FLAT:_Asterisk
	DD	FLAT:_Plus
	DD	FLAT:_Comma
	DD	FLAT:_Minus
	DD	FLAT:_Period
	DD	FLAT:_Slash
	DD	FLAT:_Number0
	DD	FLAT:_Number1
	DD	FLAT:_Number2
	DD	FLAT:_Number3
	DD	FLAT:_Number4
	DD	FLAT:_Number5
	DD	FLAT:_Number6
	DD	FLAT:_Number7
	DD	FLAT:_Number8
	DD	FLAT:_Number9
	DD	FLAT:_Colon
	DD	FLAT:_SemiColon
	DD	FLAT:_Less
	DD	FLAT:_Equal
	DD	FLAT:_More
	DD	FLAT:_Quest
	DD	FLAT:_Each
	DD	FLAT:_LetterA
	DD	FLAT:_LetterB
	DD	FLAT:_LetterC
	DD	FLAT:_LetterD
	DD	FLAT:_LetterE
	DD	FLAT:_LetterF
	DD	FLAT:_LetterG
	DD	FLAT:_LetterH
	DD	FLAT:_LetterI
	DD	FLAT:_LetterJ
	DD	FLAT:_LetterK
	DD	FLAT:_LetterL
	DD	FLAT:_LetterM
	DD	FLAT:_LetterN
	DD	FLAT:_LetterO
	DD	FLAT:_LetterP
	DD	FLAT:_LetterQ
	DD	FLAT:_LetterR
	DD	FLAT:_LetterS
	DD	FLAT:_LetterT
	DD	FLAT:_LetterU
	DD	FLAT:_LetterV
	DD	FLAT:_LetterW
	DD	FLAT:_LetterX
	DD	FLAT:_LetterY
	DD	FLAT:_LetterZ
	DD	FLAT:_Apostrophe
	DD	FLAT:_LetterAumlaut
	DD	FLAT:_LetterOumlaut
	DD	FLAT:_LetterUumlaut
	DD	FLAT:_LetterBeta
	DD	FLAT:_Degree
	DD	FLAT:_Mu
	DD	FLAT:_Exclaim
	DD	FLAT:_Quote
	DD	FLAT:_And
	DD	FLAT:_LetterAaccent
	DD	FLAT:_LetterAsquiggle
	DD	FLAT:_LetterEaccent
	DD	FLAT:_LetterEhat
	DD	FLAT:_LetterIaccent
	DD	FLAT:_LetterNsquiggle
	DD	FLAT:_LetterOsquiggle
	DD	FLAT:_LetterOaccent
	DD	FLAT:_LetterUaccent
	DD	FLAT:_LetterCstem
	DD	FLAT:_LetterAhat
	DD	FLAT:_LetterAbackaccent
_Space	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_OpenParen DB	00H
	DB	00H
	DB	040H
	DB	080H
	DB	080H
	DB	080H
	DB	040H
	DB	00H
	DB	02H
	ORG $+3
_CloseParen DB	00H
	DB	00H
	DB	080H
	DB	040H
	DB	040H
	DB	040H
	DB	080H
	DB	00H
	DB	02H
	ORG $+3
_Asterisk DB	00H
	DB	00H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_Plus	DB	00H
	DB	00H
	DB	040H
	DB	0e0H
	DB	00H
	DB	0e0H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_Comma	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	040H
	DB	080H
	DB	02H
	ORG $+3
_Minus	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0e0H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_Period	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	080H
	DB	00H
	DB	02H
	ORG $+3
_Slash	DB	00H
	DB	00H
	DB	020H
	DB	020H
	DB	040H
	DB	080H
	DB	080H
	DB	00H
	DB	03H
	ORG $+3
_Number0 DB	00H
	DB	00H
	DB	0e0H
	DB	0a0H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Number1 DB	00H
	DB	00H
	DB	040H
	DB	0c0H
	DB	040H
	DB	040H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Number2 DB	00H
	DB	00H
	DB	0e0H
	DB	020H
	DB	0e0H
	DB	080H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Number3 DB	00H
	DB	00H
	DB	0e0H
	DB	020H
	DB	060H
	DB	020H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Number4 DB	00H
	DB	00H
	DB	080H
	DB	0a0H
	DB	0e0H
	DB	020H
	DB	020H
	DB	00H
	DB	03H
	ORG $+3
_Number5 DB	00H
	DB	00H
	DB	0e0H
	DB	080H
	DB	0c0H
	DB	020H
	DB	0c0H
	DB	00H
	DB	03H
	ORG $+3
_Number6 DB	00H
	DB	00H
	DB	080H
	DB	080H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Number7 DB	00H
	DB	00H
	DB	0e0H
	DB	020H
	DB	020H
	DB	020H
	DB	020H
	DB	00H
	DB	03H
	ORG $+3
_Number8 DB	00H
	DB	00H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Number9 DB	00H
	DB	00H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	020H
	DB	020H
	DB	00H
	DB	03H
	ORG $+3
_Colon	DB	00H
	DB	00H
	DB	00H
	DB	080H
	DB	00H
	DB	080H
	DB	00H
	DB	00H
	DB	01H
	ORG $+3
_SemiColon DB	00H
	DB	00H
	DB	00H
	DB	040H
	DB	00H
	DB	040H
	DB	040H
	DB	080H
	DB	02H
	ORG $+3
_Less	DB	00H
	DB	00H
	DB	020H
	DB	040H
	DB	080H
	DB	040H
	DB	020H
	DB	00H
	DB	03H
	ORG $+3
_Equal	DB	00H
	DB	00H
	DB	00H
	DB	0e0H
	DB	00H
	DB	0e0H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_More	DB	00H
	DB	00H
	DB	080H
	DB	040H
	DB	020H
	DB	040H
	DB	080H
	DB	00H
	DB	03H
	ORG $+3
_Quest	DB	040H
	DB	00H
	DB	0c0H
	DB	020H
	DB	040H
	DB	00H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_Each	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_LetterA DB	00H
	DB	00H
	DB	040H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	0a0H
	DB	00H
	DB	03H
	ORG $+3
_LetterB DB	00H
	DB	00H
	DB	0c0H
	DB	0a0H
	DB	0c0H
	DB	0a0H
	DB	0c0H
	DB	00H
	DB	03H
	ORG $+3
_LetterC DB	00H
	DB	00H
	DB	040H
	DB	0a0H
	DB	080H
	DB	0a0H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_LetterD DB	00H
	DB	00H
	DB	0c0H
	DB	0a0H
	DB	0a0H
	DB	0a0H
	DB	0c0H
	DB	00H
	DB	03H
	ORG $+3
_LetterE DB	00H
	DB	00H
	DB	0e0H
	DB	080H
	DB	0c0H
	DB	080H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterF DB	00H
	DB	00H
	DB	0e0H
	DB	080H
	DB	0c0H
	DB	080H
	DB	080H
	DB	00H
	DB	03H
	ORG $+3
_LetterG DB	00H
	DB	00H
	DB	060H
	DB	080H
	DB	0a0H
	DB	0a0H
	DB	060H
	DB	00H
	DB	03H
	ORG $+3
_LetterH DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	0a0H
	DB	0a0H
	DB	00H
	DB	03H
	ORG $+3
_LetterI DB	00H
	DB	00H
	DB	0e0H
	DB	040H
	DB	040H
	DB	040H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterJ DB	00H
	DB	00H
	DB	020H
	DB	020H
	DB	020H
	DB	0a0H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_LetterK DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	0c0H
	DB	0a0H
	DB	0a0H
	DB	00H
	DB	03H
	ORG $+3
_LetterL DB	00H
	DB	00H
	DB	080H
	DB	080H
	DB	080H
	DB	080H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterM DB	00H
	DB	00H
	DB	088H
	DB	0d8H
	DB	0a8H
	DB	0a8H
	DB	088H
	DB	00H
	DB	05H
	ORG $+3
_LetterN DB	00H
	DB	00H
	DB	090H
	DB	0d0H
	DB	0b0H
	DB	090H
	DB	090H
	DB	00H
	DB	04H
	ORG $+3
_LetterO DB	00H
	DB	00H
	DB	060H
	DB	090H
	DB	090H
	DB	090H
	DB	060H
	DB	00H
	DB	04H
	ORG $+3
_LetterP DB	00H
	DB	00H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	080H
	DB	080H
	DB	00H
	DB	03H
	ORG $+3
_LetterQ DB	00H
	DB	00H
	DB	060H
	DB	090H
	DB	090H
	DB	0a0H
	DB	0d0H
	DB	00H
	DB	04H
	ORG $+3
_LetterR DB	00H
	DB	00H
	DB	0c0H
	DB	0a0H
	DB	0c0H
	DB	0a0H
	DB	0a0H
	DB	00H
	DB	03H
	ORG $+3
_LetterS DB	00H
	DB	00H
	DB	060H
	DB	080H
	DB	040H
	DB	020H
	DB	0c0H
	DB	00H
	DB	03H
	ORG $+3
_LetterT DB	00H
	DB	00H
	DB	0e0H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_LetterU DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterV DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_LetterW DB	00H
	DB	00H
	DB	088H
	DB	088H
	DB	0a8H
	DB	0a8H
	DB	050H
	DB	00H
	DB	05H
	ORG $+3
_LetterX DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	040H
	DB	0a0H
	DB	0a0H
	DB	00H
	DB	03H
	ORG $+3
_LetterY DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	040H
	DB	040H
	DB	00H
	DB	03H
	ORG $+3
_LetterZ DB	00H
	DB	00H
	DB	0e0H
	DB	020H
	DB	040H
	DB	080H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_Apostrophe DB	00H
	DB	00H
	DB	040H
	DB	080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	ORG $+3
_LetterAumlaut DB 00H
	DB	0a0H
	DB	040H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	0a0H
	DB	00H
	DB	03H
	ORG $+3
_LetterOumlaut DB 00H
	DB	090H
	DB	060H
	DB	090H
	DB	090H
	DB	090H
	DB	060H
	DB	00H
	DB	04H
	ORG $+3
_LetterUumlaut DB 00H
	DB	0a0H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterBeta DB	00H
	DB	00H
	DB	0f0H
	DB	090H
	DB	0b8H
	DB	088H
	DB	0f8H
	DB	00H
	DB	05H
	ORG $+3
_Degree	DB	00H
	DB	00H
	DB	0e0H
	DB	0a0H
	DB	0e0H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_Mu	DB	00H
	DB	00H
	DB	050H
	DB	050H
	DB	050H
	DB	060H
	DB	080H
	DB	00H
	DB	04H
	ORG $+3
_Exclaim DB	00H
	DB	00H
	DB	080H
	DB	080H
	DB	080H
	DB	00H
	DB	080H
	DB	00H
	DB	01H
	ORG $+3
_Quote	DB	00H
	DB	00H
	DB	0a0H
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	ORG $+3
_And	DB	00H
	DB	00H
	DB	040H
	DB	0a0H
	DB	040H
	DB	0a0H
	DB	050H
	DB	00H
	DB	04H
	ORG $+3
_LetterAaccent DB 010H
	DB	020H
	DB	040H
	DB	060H
	DB	090H
	DB	0f0H
	DB	090H
	DB	00H
	DB	04H
	ORG $+3
_LetterAbackaccent DB 040H
	DB	020H
	DB	010H
	DB	060H
	DB	090H
	DB	0f0H
	DB	090H
	DB	00H
	DB	04H
	ORG $+3
_LetterAsquiggle DB 050H
	DB	0a0H
	DB	00H
	DB	060H
	DB	090H
	DB	0f0H
	DB	090H
	DB	00H
	DB	04H
	ORG $+3
_LetterAhat DB	060H
	DB	090H
	DB	00H
	DB	060H
	DB	090H
	DB	0f0H
	DB	090H
	DB	00H
	DB	04H
	ORG $+3
_LetterEaccent DB 020H
	DB	040H
	DB	0e0H
	DB	080H
	DB	0c0H
	DB	080H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterEhat DB	040H
	DB	0a0H
	DB	0e0H
	DB	080H
	DB	0c0H
	DB	080H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterIaccent DB 020H
	DB	040H
	DB	0e0H
	DB	040H
	DB	040H
	DB	040H
	DB	0e0H
	DB	00H
	DB	03H
	ORG $+3
_LetterNsquiggle DB 050H
	DB	0a0H
	DB	00H
	DB	090H
	DB	0d0H
	DB	0b0H
	DB	090H
	DB	00H
	DB	04H
	ORG $+3
_LetterOsquiggle DB 050H
	DB	0a0H
	DB	00H
	DB	0f0H
	DB	090H
	DB	090H
	DB	0f0H
	DB	00H
	DB	04H
	ORG $+3
_LetterOaccent DB 010H
	DB	020H
	DB	040H
	DB	0f0H
	DB	090H
	DB	090H
	DB	0f0H
	DB	00H
	DB	04H
	ORG $+3
_LetterUaccent DB 010H
	DB	020H
	DB	040H
	DB	090H
	DB	090H
	DB	090H
	DB	0f0H
	DB	00H
	DB	04H
	ORG $+3
_LetterCstem DB	00H
	DB	00H
	DB	0e0H
	DB	080H
	DB	080H
	DB	0e0H
	DB	040H
	DB	0c0H
	DB	03H
_DATA	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_Q_SCALE DD	03a51b717r			; 0.0008
?FontLUT@VirtualDisplay@@1QBEB DB 00H			; VirtualDisplay::FontLUT
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03bH
	DB	03cH
	DB	00H
	DB	00H
	DB	00H
	DB	03dH
	DB	034H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01cH
	DB	02eH
	DB	01eH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01cH
	DB	01eH
	DB	01eH
	DB	01eH
	DB	025H
	DB	025H
	DB	025H
	DB	01aH
	DB	01aH
	DB	01eH
	DB	01aH
	DB	01aH
	DB	028H
	DB	028H
	DB	028H
	DB	02eH
	DB	02eH
	DB	032H
	DB	028H
	DB	02eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	025H
	DB	028H
	DB	02eH
	DB	027H
	DB	027H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	039H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03aH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	049H
	DB	03eH
	DB	048H
	DB	03fH
	DB	035H
	DB	01aH
	DB	01aH
	DB	047H
	DB	01eH
	DB	040H
	DB	041H
	DB	01eH
	DB	022H
	DB	042H
	DB	022H
	DB	022H
	DB	01dH
	DB	043H
	DB	028H
	DB	045H
	DB	028H
	DB	044H
	DB	036H
	DB	00H
	DB	028H
	DB	02eH
	DB	046H
	DB	02eH
	DB	037H
	DB	00H
	DB	00H
	DB	038H
	DB	049H
	DB	03eH
	DB	048H
	DB	03fH
	DB	035H
	DB	01aH
	DB	01aH
	DB	047H
	DB	01eH
	DB	040H
	DB	041H
	DB	01eH
	DB	025H
	DB	042H
	DB	025H
	DB	025H
	DB	00H
	DB	043H
	DB	028H
	DB	045H
	DB	028H
	DB	044H
	DB	036H
	DB	028H
	DB	00H
	DB	02eH
	DB	046H
	DB	02eH
	DB	037H
	DB	032H
	DB	00H
	DB	032H
?FontLength@VirtualDisplay@@1IB DD 04aH			; VirtualDisplay::FontLength
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
PUBLIC	_cosf
PUBLIC	_fmodf
PUBLIC	_sinf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fmod@@YAMMM@Z					; fmod
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??_GTextureHandle@@QAEPAXI@Z			; TextureHandle::`scalar deleting destructor'
PUBLIC	?targetSurface@ImageBuffer@@QAEPAUIDirectDrawSurface7@@XZ ; ImageBuffer::targetSurface
PUBLIC	?targetXres@ImageBuffer@@QAEHXZ			; ImageBuffer::targetXres
PUBLIC	?targetYres@ImageBuffer@@QAEHXZ			; ImageBuffer::targetYres
PUBLIC	??0FontSet@@QAE@XZ				; FontSet::FontSet
PUBLIC	??1FontSet@@QAE@XZ				; FontSet::~FontSet
PUBLIC	?InitializeFonts@VirtualDisplay@@SAXXZ		; VirtualDisplay::InitializeFonts
PUBLIC	?Setup@VirtualDisplay@@UAEXXZ			; VirtualDisplay::Setup
PUBLIC	?Cleanup@VirtualDisplay@@UAEXXZ			; VirtualDisplay::Cleanup
PUBLIC	?Point@VirtualDisplay@@UAEXMM@Z			; VirtualDisplay::Point
PUBLIC	?Line@VirtualDisplay@@UAEXMMMM@Z		; VirtualDisplay::Line
PUBLIC	?Line@VirtualDisplay@@UAEXMMMMM@Z		; VirtualDisplay::Line
PUBLIC	?Tri@VirtualDisplay@@UAEXMMMMMM@Z		; VirtualDisplay::Tri
PUBLIC	?Oval@VirtualDisplay@@UAEXMMMM@Z		; VirtualDisplay::Oval
PUBLIC	?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z		; VirtualDisplay::OvalArc
PUBLIC	?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z		; VirtualDisplay::TextLeft
PUBLIC	?TextRight@VirtualDisplay@@UAEXMMPBDH@Z		; VirtualDisplay::TextRight
PUBLIC	?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z	; VirtualDisplay::TextLeftVertical
PUBLIC	?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z	; VirtualDisplay::TextRightVertical
PUBLIC	?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z	; VirtualDisplay::TextCenter
PUBLIC	?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z ; VirtualDisplay::TextCenterVertical
PUBLIC	?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z		; VirtualDisplay::TextWrap
PUBLIC	?ScreenTextHeight@VirtualDisplay@@SAHXZ		; VirtualDisplay::ScreenTextHeight
PUBLIC	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z	; VirtualDisplay::ScreenTextWidth
PUBLIC	?SetFont@VirtualDisplay@@SAXH@Z			; VirtualDisplay::SetFont
PUBLIC	?SetViewport@VirtualDisplay@@UAEXMMMM@Z		; VirtualDisplay::SetViewport
PUBLIC	?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z	; VirtualDisplay::SetViewportRelative
PUBLIC	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
PUBLIC	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin
PUBLIC	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ	; VirtualDisplay::CenterOriginInViewport
PUBLIC	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ	; VirtualDisplay::ZeroRotationAboutOrigin
PUBLIC	?SaveDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z ; VirtualDisplay::SaveDisplayMatrix
PUBLIC	?RestoreDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z ; VirtualDisplay::RestoreDisplayMatrix
PUBLIC	?GetViewport@VirtualDisplay@@QAEXPAM000@Z	; VirtualDisplay::GetViewport
PUBLIC	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z	; VirtualDisplay::viewportXtoPixel
PUBLIC	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z	; VirtualDisplay::viewportYtoPixel
PUBLIC	?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z	; VirtualDisplay::Render2DTri
PUBLIC	?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z	; VirtualDisplay::SetupRttTarget
PUBLIC	?CleanupRttTarget@VirtualDisplay@@SA_NXZ	; VirtualDisplay::CleanupRttTarget
PUBLIC	?StartRtt@VirtualDisplay@@QAEXPAVRender3D@@@Z	; VirtualDisplay::StartRtt
PUBLIC	?FinishRtt@VirtualDisplay@@QAEXXZ		; VirtualDisplay::FinishRtt
PUBLIC	?SetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@00DM@Z ; VirtualDisplay::SetRttCanvas
PUBLIC	?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z	; VirtualDisplay::SetRttRect
PUBLIC	?AdjustRttViewport@VirtualDisplay@@QAEXXZ	; VirtualDisplay::AdjustRttViewport
PUBLIC	?ResetRttViewport@VirtualDisplay@@QAEXXZ	; VirtualDisplay::ResetRttViewport
PUBLIC	?DrawRttQuad@VirtualDisplay@@QAEXXZ		; VirtualDisplay::DrawRttQuad
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?Font2D@VirtualDisplay@@2UFontSet@@A		; VirtualDisplay::Font2D
PUBLIC	?Font3D@VirtualDisplay@@2UFontSet@@A		; VirtualDisplay::Font3D
PUBLIC	??_C@_09BAFPBEDI@RttTarget?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40490fdb
PUBLIC	__real@4066800000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@43340000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_cos:PROC
EXTRN	_fmod:PROC
EXTRN	_sin:PROC
EXTRN	_free:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strdup:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetRenderTarget@DXContext@@QAE_NPAUIDirectDrawSurface7@@@Z:PROC ; DXContext::SetRenderTarget
EXTRN	??0TextureHandle@@QAE@XZ:PROC			; TextureHandle::TextureHandle
EXTRN	??1TextureHandle@@QAE@XZ:PROC			; TextureHandle::~TextureHandle
EXTRN	?Create@TextureHandle@@QAE_NPADKGGGK@Z:PROC	; TextureHandle::Create
EXTRN	?SelectTexture1@ContextMPR@@QAEXH@Z:PROC	; ContextMPR::SelectTexture1
EXTRN	?RestoreState@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::RestoreState
EXTRN	?ZeroViewport@ContextMPR@@QAEXXZ:PROC		; ContextMPR::ZeroViewport
EXTRN	??0Texture@@QAE@XZ:PROC				; Texture::Texture
EXTRN	??1Texture@@QAE@XZ:PROC				; Texture::~Texture
EXTRN	?TransformPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z:PROC ; Render3D::TransformPoint
EXTRN	?DrawSquare@Render3D@@QAEXPAUThreeDVertex@@000H_N1@Z:PROC ; Render3D::DrawSquare
EXTRN	?SetViewport@CDXEngine@@QAEXKKKK@Z:PROC		; CDXEngine::SetViewport
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?TheDXEngine@@3VCDXEngine@@A:BYTE		; TheDXEngine
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?Font2D@VirtualDisplay@@2UFontSet@@A DB 06068H DUP (?)	; VirtualDisplay::Font2D
?Font3D@VirtualDisplay@@2UFontSet@@A DB 06068H DUP (?)	; VirtualDisplay::Font3D
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-007
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09BAFPBEDI@RttTarget?$AA@
CONST	SEGMENT
??_C@_09BAFPBEDI@RttTarget?$AA@ DB 'RttTarget', 00H	; `string'
CONST	ENDS
;	COMDAT ?E@?1??SetViewport@VirtualDisplay@@UAEXMMMM@Z@4MB
CONST	SEGMENT
?E@?1??SetViewport@VirtualDisplay@@UAEXMMMM@Z@4MB DD 03c23d70ar ; 0.01 ; `VirtualDisplay::SetViewport'::`2'::E
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z$0
__ehfuncinfo$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?Font2D$initializer$@VirtualDisplay@@2P6AXXZA DD FLAT:??__E?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ; VirtualDisplay::Font2D$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?Font3D$initializer$@VirtualDisplay@@2P6AXXZA DD FLAT:??__E?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ; VirtualDisplay::Font3D$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ
text$yd	SEGMENT
??__F?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ PROC	; `dynamic atexit destructor for 'VirtualDisplay::Font3D'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?Font3D@VirtualDisplay@@2UFontSet@@A ; VirtualDisplay::Font3D
	call	??1FontSet@@QAE@XZ			; FontSet::~FontSet
	pop	ebp
	ret	0
??__F?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ENDP	; `dynamic atexit destructor for 'VirtualDisplay::Font3D''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
;	COMDAT ??__E?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ
text$yc	SEGMENT
??__E?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ PROC	; `dynamic initializer for 'VirtualDisplay::Font3D'', COMDAT

; 37   : FontSet VirtualDisplay::Font3D;;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?Font3D@VirtualDisplay@@2UFontSet@@A ; VirtualDisplay::Font3D
	call	??0FontSet@@QAE@XZ			; FontSet::FontSet
	push	OFFSET ??__F?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ; `dynamic atexit destructor for 'VirtualDisplay::Font3D''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?Font3D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ENDP	; `dynamic initializer for 'VirtualDisplay::Font3D''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ
text$yd	SEGMENT
??__F?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ PROC	; `dynamic atexit destructor for 'VirtualDisplay::Font2D'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?Font2D@VirtualDisplay@@2UFontSet@@A ; VirtualDisplay::Font2D
	call	??1FontSet@@QAE@XZ			; FontSet::~FontSet
	pop	ebp
	ret	0
??__F?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ENDP	; `dynamic atexit destructor for 'VirtualDisplay::Font2D''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
;	COMDAT ??__E?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ
text$yc	SEGMENT
??__E?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ PROC	; `dynamic initializer for 'VirtualDisplay::Font2D'', COMDAT

; 36   : FontSet VirtualDisplay::Font2D;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?Font2D@VirtualDisplay@@2UFontSet@@A ; VirtualDisplay::Font2D
	call	??0FontSet@@QAE@XZ			; FontSet::FontSet
	push	OFFSET ??__F?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ; `dynamic atexit destructor for 'VirtualDisplay::Font2D''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?Font2D@VirtualDisplay@@2UFontSet@@A@@YAXXZ ENDP	; `dynamic initializer for 'VirtualDisplay::Font2D''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -228						; size = 4
_v0$ = -224						; size = 52
_v1$ = -172						; size = 52
_v2$ = -120						; size = 52
_v3$ = -68						; size = 52
_os$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?DrawRttQuad@VirtualDisplay@@QAEXXZ PROC		; VirtualDisplay::DrawRttQuad
; _this$ = ecx

; 1183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1184 : 	r3d->context.RestoreState( rttBlendMode );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+262816]
	push	ecx
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState

; 1185 : 	r3d->context.SelectTexture1( (DWORD)renderTexture );

	mov	edx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	push	edx
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	add	ecx, 100				; 00000064H
	call	?SelectTexture1@ContextMPR@@QAEXH@Z	; ContextMPR::SelectTexture1

; 1186 : 
; 1187 : 	Tpoint os;
; 1188 : 	ThreeDVertex v0,v1,v2,v3;
; 1189 : 	
; 1190 : 	os.x = canUL.x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262780]
	movss	DWORD PTR _os$[ebp], xmm0

; 1191 : 	os.y = canUL.y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262784]
	movss	DWORD PTR _os$[ebp+4], xmm0

; 1192 : 	os.z = canUL.z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262788]
	movss	DWORD PTR _os$[ebp+8], xmm0

; 1193 : 	r3d->TransformPoint(&os, &v0);	

	lea	eax, DWORD PTR _v0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _os$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	call	?TransformPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformPoint

; 1194 : 	
; 1195 : 	os.x = canUR.x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262792]
	movss	DWORD PTR _os$[ebp], xmm0

; 1196 : 	os.y = canUR.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262796]
	movss	DWORD PTR _os$[ebp+4], xmm0

; 1197 : 	os.z = canUR.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262800]
	movss	DWORD PTR _os$[ebp+8], xmm0

; 1198 : 	r3d->TransformPoint(&os, &v1);	

	lea	edx, DWORD PTR _v1$[ebp]
	push	edx
	lea	eax, DWORD PTR _os$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	call	?TransformPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformPoint

; 1199 : 		
; 1200 : 	os.x =  canLL.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262804]
	movss	DWORD PTR _os$[ebp], xmm0

; 1201 : 	os.y =  canUR.y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262796]
	movss	DWORD PTR _os$[ebp+4], xmm0

; 1202 : 	os.z =  canLL.z;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262812]
	movss	DWORD PTR _os$[ebp+8], xmm0

; 1203 : 	r3d->TransformPoint(&os, &v2);	

	lea	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _os$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	call	?TransformPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformPoint

; 1204 : 		
; 1205 : 	os.x = canLL.x; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262804]
	movss	DWORD PTR _os$[ebp], xmm0

; 1206 : 	os.y = canLL.y; 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+262808]
	movss	DWORD PTR _os$[ebp+4], xmm0

; 1207 : 	os.z = canLL.z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262812]
	movss	DWORD PTR _os$[ebp+8], xmm0

; 1208 : 	r3d->TransformPoint(&os, &v3);	

	lea	eax, DWORD PTR _v3$[ebp]
	push	eax
	lea	ecx, DWORD PTR _os$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	call	?TransformPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformPoint

; 1209 : 
; 1210 : 	v0.u = (float)tLeft / (float)renderTexture->m_nActualWidth;  

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+262756]
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [eax+16]
	divss	xmm0, xmm1
	movss	DWORD PTR _v0$[ebp+24], xmm0

; 1211 : 	v0.v = (float)tTop / (float)renderTexture->m_nActualHeight; 

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+262760]
	mov	edx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [edx+20]
	divss	xmm0, xmm1
	movss	DWORD PTR _v0$[ebp+28], xmm0

; 1212 : 	v0.q = v0.csZ * Q_SCALE;

	movss	xmm0, DWORD PTR _v0$[ebp+48]
	mulss	xmm0, DWORD PTR _Q_SCALE
	movss	DWORD PTR _v0$[ebp+32], xmm0

; 1213 : 	
; 1214 : 	v1.u = (float)tRight / (float)renderTexture->m_nActualWidth; 

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+262764]
	mov	ecx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [ecx+16]
	divss	xmm0, xmm1
	movss	DWORD PTR _v1$[ebp+24], xmm0

; 1215 : 	v1.v = (float)tTop / (float)renderTexture->m_nActualHeight; 

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+262760]
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [eax+20]
	divss	xmm0, xmm1
	movss	DWORD PTR _v1$[ebp+28], xmm0

; 1216 : 	v1.q = v1.csZ * Q_SCALE;

	movss	xmm0, DWORD PTR _v1$[ebp+48]
	mulss	xmm0, DWORD PTR _Q_SCALE
	movss	DWORD PTR _v1$[ebp+32], xmm0

; 1217 : 	
; 1218 : 	v2.u = (float)tRight / (float)renderTexture->m_nActualWidth; 

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+262764]
	mov	edx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [edx+16]
	divss	xmm0, xmm1
	movss	DWORD PTR _v2$[ebp+24], xmm0

; 1219 : 	v2.v = (float)tBottom / (float)renderTexture->m_nActualHeight; 

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+262768]
	mov	ecx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [ecx+20]
	divss	xmm0, xmm1
	movss	DWORD PTR _v2$[ebp+28], xmm0

; 1220 : 	v2.q = v2.csZ * Q_SCALE;

	movss	xmm0, DWORD PTR _v2$[ebp+48]
	mulss	xmm0, DWORD PTR _Q_SCALE
	movss	DWORD PTR _v2$[ebp+32], xmm0

; 1221 : 	
; 1222 : 	v3.u = (float)tLeft / (float)renderTexture->m_nActualWidth; 

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+262756]
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [eax+16]
	divss	xmm0, xmm1
	movss	DWORD PTR _v3$[ebp+24], xmm0

; 1223 : 	v3.v = (float)tBottom / (float)renderTexture->m_nActualHeight; 

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+262768]
	mov	edx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	cvtsi2ss xmm1, DWORD PTR [edx+20]
	divss	xmm0, xmm1
	movss	DWORD PTR _v3$[ebp+28], xmm0

; 1224 : 	v3.q = v3.csZ * Q_SCALE;

	movss	xmm0, DWORD PTR _v3$[ebp+48]
	mulss	xmm0, DWORD PTR _Q_SCALE
	movss	DWORD PTR _v3$[ebp+32], xmm0

; 1225 : 
; 1226 : 	v0.r = v1.r = v2.r = v3.r = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _v3$[ebp+8], xmm0
	movss	xmm0, DWORD PTR _v3$[ebp+8]
	movss	DWORD PTR _v2$[ebp+8], xmm0
	movss	xmm0, DWORD PTR _v2$[ebp+8]
	movss	DWORD PTR _v1$[ebp+8], xmm0
	movss	xmm0, DWORD PTR _v1$[ebp+8]
	movss	DWORD PTR _v0$[ebp+8], xmm0

; 1227 : 	v0.g = v1.g = v2.g = v3.g = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _v3$[ebp+12], xmm0
	movss	xmm0, DWORD PTR _v3$[ebp+12]
	movss	DWORD PTR _v2$[ebp+12], xmm0
	movss	xmm0, DWORD PTR _v2$[ebp+12]
	movss	DWORD PTR _v1$[ebp+12], xmm0
	movss	xmm0, DWORD PTR _v1$[ebp+12]
	movss	DWORD PTR _v0$[ebp+12], xmm0

; 1228 : 	v0.b = v1.b = v2.b = v3.b = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _v3$[ebp+16], xmm0
	movss	xmm0, DWORD PTR _v3$[ebp+16]
	movss	DWORD PTR _v2$[ebp+16], xmm0
	movss	xmm0, DWORD PTR _v2$[ebp+16]
	movss	DWORD PTR _v1$[ebp+16], xmm0
	movss	xmm0, DWORD PTR _v1$[ebp+16]
	movss	DWORD PTR _v0$[ebp+16], xmm0

; 1229 : 	v0.a = v1.a = v2.a = v3.a = rttAlpha;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+262820]
	movss	DWORD PTR _v3$[ebp+20], xmm0
	movss	xmm0, DWORD PTR _v3$[ebp+20]
	movss	DWORD PTR _v2$[ebp+20], xmm0
	movss	xmm0, DWORD PTR _v2$[ebp+20]
	movss	DWORD PTR _v1$[ebp+20], xmm0
	movss	xmm0, DWORD PTR _v1$[ebp+20]
	movss	DWORD PTR _v0$[ebp+20], xmm0

; 1230 : 	
; 1231 : 	r3d->DrawSquare(&v0,&v1,&v2,&v3,CULL_ALLOW_ALL,false);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _v3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _v2$[ebp]
	push	edx
	lea	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v0$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A ; VirtualDisplay::r3d
	call	?DrawSquare@Render3D@@QAEXPAUThreeDVertex@@000H_N1@Z ; Render3D::DrawSquare

; 1232 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawRttQuad@VirtualDisplay@@QAEXXZ ENDP		; VirtualDisplay::DrawRttQuad
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv81 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?ResetRttViewport@VirtualDisplay@@QAEXXZ PROC		; VirtualDisplay::ResetRttViewport
; _this$ = ecx

; 1160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1161 : 	// ASSO: reset adjusted RTT viewport
; 1162 : 	context.m_pRenderTarget = image->targetSurface();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?targetSurface@ImageBuffer@@QAEPAUIDirectDrawSurface7@@XZ ; ImageBuffer::targetSurface
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262464], eax

; 1163 : 	context.RestoreState( STATE_SOLID );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState

; 1164 : 	
; 1165 : 	xRes = txRes = image->targetXres();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?targetXres@ImageBuffer@@QAEHXZ		; ImageBuffer::targetXres
	mov	DWORD PTR tv76[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR [eax+262772], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR [edx+8], eax

; 1166 : 	yRes = tyRes = image->targetYres();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?targetYres@ImageBuffer@@QAEHXZ		; ImageBuffer::targetYres
	mov	DWORD PTR tv81[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR [edx+262776], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1167 : 	tLeft = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262756], 0

; 1168 : 	tTop = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262760], 0

; 1169 : 	tRight = xRes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+262764], ecx

; 1170 : 	tBottom = yRes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+262768], ecx

; 1171 : 	
; 1172 : 	// Setup the default viewport
; 1173 : 	SetViewport( -1.0f, 1.0f, 1.0f, -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 1174 : 
; 1175 : 	// Setup the default offset and rotation
; 1176 : 	CenterOriginInViewport();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport

; 1177 : 	ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 1178 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetRttViewport@VirtualDisplay@@QAEXXZ ENDP		; VirtualDisplay::ResetRttViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AdjustRttViewport@VirtualDisplay@@QAEXXZ PROC		; VirtualDisplay::AdjustRttViewport
; _this$ = ecx

; 1153 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 	context.m_pRenderTarget = renderTexture->m_pDDS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+262464], edx

; 1155 : 	//context.SetViewportAbs( 0, 0, renderTexture->m_nActualWidth, renderTexture->m_nActualHeight );
; 1156 : 	SetViewport(-1.0f, 1.0f, 1.0f, -1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 1157 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustRttViewport@VirtualDisplay@@QAEXXZ ENDP		; VirtualDisplay::AdjustRttViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv87 = -8						; size = 4
_this$ = -4						; size = 4
_tLeft_$ = 8						; size = 4
_tTop_$ = 12						; size = 4
_tRight_$ = 16						; size = 4
_tBottom_$ = 20						; size = 4
_rt_$ = 24						; size = 1
?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z PROC		; VirtualDisplay::SetRttRect
; _this$ = ecx

; 1102 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 	//oldXRes = xRes;
; 1104 : 	//oldYRes = yRes;
; 1105 : 	tLeft = tLeft_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tLeft_$[ebp]
	mov	DWORD PTR [eax+262756], ecx

; 1106 : 	tTop = tTop_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tTop_$[ebp]
	mov	DWORD PTR [edx+262760], eax

; 1107 : 	tRight = tRight_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tRight_$[ebp]
	mov	DWORD PTR [ecx+262764], edx

; 1108 : 	tBottom = tBottom_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tBottom_$[ebp]
	mov	DWORD PTR [eax+262768], ecx

; 1109 : 
; 1110 : 	xRes = tRight - tLeft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+262764]
	sub	ecx, DWORD PTR [eax+262756]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1111 : 	yRes = tBottom - tTop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+262768]
	sub	edx, DWORD PTR [ecx+262760]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1112 : 
; 1113 : 	if( rt_ && renderTexture) {

	movzx	ecx, BYTE PTR _rt_$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@SetRttRect
	cmp	DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A, 0 ; VirtualDisplay::renderTexture
	je	SHORT $LN2@SetRttRect

; 1114 : 		txRes = renderTexture->m_nActualWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+262772], ecx

; 1115 : 		tyRes = renderTexture->m_nActualHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+262776], ecx

; 1116 : 		//context.SetViewportAbs( 0, 0, renderTexture->m_nActualWidth, renderTexture->m_nActualHeight );
; 1117 : 	}
; 1118 : 	else {

	jmp	SHORT $LN1@SetRttRect
$LN2@SetRttRect:

; 1119 : 		xRes = txRes = image->targetXres();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?targetXres@ImageBuffer@@QAEHXZ		; ImageBuffer::targetXres
	mov	DWORD PTR tv87[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR [eax+262772], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR [edx+8], eax

; 1120 : 		yRes = tyRes = image->targetYres();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?targetYres@ImageBuffer@@QAEHXZ		; ImageBuffer::targetYres
	mov	DWORD PTR tv92[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR [edx+262776], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1121 : 		tLeft = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262756], 0

; 1122 : 		tTop = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262760], 0

; 1123 : 		tRight = xRes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+262764], ecx

; 1124 : 		tBottom = yRes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+262768], ecx
$LN1@SetRttRect:

; 1125 : 		//context.SetViewportAbs( 0, 0, xRes, yRes );
; 1126 : 	}
; 1127 : 	context.ZeroViewport();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ZeroViewport@ContextMPR@@QAEXXZ	; ContextMPR::ZeroViewport

; 1128 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z ENDP		; VirtualDisplay::SetRttRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_ul_$ = 8						; size = 4
_ur_$ = 12						; size = 4
_ll_$ = 16						; size = 4
_blendMode_$ = 20					; size = 1
_alpha_$ = 24						; size = 4
?SetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@00DM@Z PROC ; VirtualDisplay::SetRttCanvas
; _this$ = ecx

; 1075 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 	canUL = *ul_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 262780				; 0004027cH
	mov	ecx, DWORD PTR _ul_$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 1077 : 	canUR = *ur_;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 262792				; 00040288H
	mov	eax, DWORD PTR _ur_$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1078 : 	canLL = *ll_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 262804				; 00040294H
	mov	edx, DWORD PTR _ll_$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 1079 : 	
; 1080 : 	switch( blendMode_ )

	movsx	eax, BYTE PTR _blendMode_$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR tv71[ebp]
	sub	ecx, 97					; 00000061H
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 19			; 00000013H
	ja	SHORT $LN1@SetRttCanv
	mov	edx, DWORD PTR tv71[ebp]
	movzx	eax, BYTE PTR $LN10@SetRttCanv[edx]
	jmp	DWORD PTR $LN11@SetRttCanv[eax*4]
$LN5@SetRttCanv:

; 1081 : 	{
; 1082 : 	  case 'a':
; 1083 : 	  	rttBlendMode = STATE_ALPHA_TEXTURE_GOURAUD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262816], 32		; 00000020H

; 1084 : 		break;

	jmp	SHORT $LN6@SetRttCanv
$LN4@SetRttCanv:

; 1085 : 	  case 'c':
; 1086 : 		rttBlendMode = STATE_CHROMA_TEXTURE_GOURAUD2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262816], 25		; 00000019H

; 1087 : 		break;

	jmp	SHORT $LN6@SetRttCanv
$LN3@SetRttCanv:

; 1088 : 	  case 'g':
; 1089 : 		rttBlendMode = STATE_TEXTURE_GOURAUD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262816], 9

; 1090 : 		break;

	jmp	SHORT $LN6@SetRttCanv
$LN2@SetRttCanv:

; 1091 : 	  case 't':
; 1092 : 		rttBlendMode = STATE_TEXTURE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262816], 3

; 1093 : 		break;

	jmp	SHORT $LN6@SetRttCanv
$LN1@SetRttCanv:

; 1094 : 	  default:
; 1095 : 		rttBlendMode = STATE_TEXTURE_GOURAUD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262816], 9
$LN6@SetRttCanv:

; 1096 : 	}
; 1097 : 	
; 1098 : 	rttAlpha = alpha_;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _alpha_$[ebp]
	movss	DWORD PTR [eax+262820], xmm0

; 1099 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN11@SetRttCanv:
	DD	$LN5@SetRttCanv
	DD	$LN4@SetRttCanv
	DD	$LN3@SetRttCanv
	DD	$LN2@SetRttCanv
	DD	$LN1@SetRttCanv
$LN10@SetRttCanv:
	DB	0
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?SetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@00DM@Z ENDP ; VirtualDisplay::SetRttCanvas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FinishRtt@VirtualDisplay@@QAEXXZ PROC			; VirtualDisplay::FinishRtt
; _this$ = ecx

; 1144 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1145 : 	context.m_pRenderTarget = image->targetSurface();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?targetSurface@ImageBuffer@@QAEPAUIDirectDrawSurface7@@XZ ; ImageBuffer::targetSurface
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262464], eax

; 1146 : 	context.m_pCtxDX->SetRenderTarget( context.m_pRenderTarget );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+262464]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+262460]
	call	?SetRenderTarget@DXContext@@QAE_NPAUIDirectDrawSurface7@@@Z ; DXContext::SetRenderTarget

; 1147 : 	SetRttRect( 0, 0, 0, 0, false );

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z ; VirtualDisplay::SetRttRect

; 1148 : 	//SetViewport(-1.0f, 1.0f, 1.0f, -1.0f);
; 1149 : 	SetViewport( oldLeft, oldTop, oldRight, oldBottom );	// restore viewport	

	push	ecx
	movss	xmm0, DWORD PTR ?oldBottom@VirtualDisplay@@1MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?oldRight@VirtualDisplay@@1MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?oldTop@VirtualDisplay@@1MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?oldLeft@VirtualDisplay@@1MA
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 1150 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FinishRtt@VirtualDisplay@@QAEXXZ ENDP			; VirtualDisplay::FinishRtt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r3d_$ = 8						; size = 4
?StartRtt@VirtualDisplay@@QAEXPAVRender3D@@@Z PROC	; VirtualDisplay::StartRtt
; _this$ = ecx

; 1131 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1132 : 	r3d = r3d_;

	mov	eax, DWORD PTR _r3d_$[ebp]
	mov	DWORD PTR ?r3d@VirtualDisplay@@1PAVRender3D@@A, eax ; VirtualDisplay::r3d

; 1133 : 	//oldXRes = xRes;
; 1134 : 	//oldYRes = yRes;
; 1135 : 	GetViewport( &oldLeft, &oldTop, &oldRight, &oldBottom ); // save the current viewport

	push	OFFSET ?oldBottom@VirtualDisplay@@1MA	; VirtualDisplay::oldBottom
	push	OFFSET ?oldRight@VirtualDisplay@@1MA	; VirtualDisplay::oldRight
	push	OFFSET ?oldTop@VirtualDisplay@@1MA	; VirtualDisplay::oldTop
	push	OFFSET ?oldLeft@VirtualDisplay@@1MA	; VirtualDisplay::oldLeft
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetViewport@VirtualDisplay@@QAEXPAM000@Z ; VirtualDisplay::GetViewport

; 1136 : 	oldTarget = context.m_pRenderTarget;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262464]
	mov	DWORD PTR ?oldTarget@VirtualDisplay@@1PAUIDirectDrawSurface7@@A, edx ; VirtualDisplay::oldTarget

; 1137 : 	context.m_pRenderTarget = renderTexture->m_pDDS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+262464], edx

; 1138 : 	context.m_pCtxDX->SetRenderTarget( context.m_pRenderTarget );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+262464]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+262460]
	call	?SetRenderTarget@DXContext@@QAE_NPAUIDirectDrawSurface7@@@Z ; DXContext::SetRenderTarget

; 1139 : 	SetRttRect( 0, 0, renderTexture->m_nActualWidth, renderTexture->m_nActualHeight );

	push	1
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z ; VirtualDisplay::SetRttRect

; 1140 : 	SetViewport(-1.0f, 1.0f, 1.0f, -1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 1141 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StartRtt@VirtualDisplay@@QAEXPAVRender3D@@@Z ENDP	; VirtualDisplay::StartRtt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?CleanupRttTarget@VirtualDisplay@@SA_NXZ PROC		; VirtualDisplay::CleanupRttTarget

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1066 : 	if( renderTexture ) {

	cmp	DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A, 0 ; VirtualDisplay::renderTexture
	je	SHORT $LN1@CleanupRtt

; 1067 : 		delete renderTexture;

	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@CleanupRtt
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GTextureHandle@@QAEPAXI@Z
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN5@CleanupRtt
$LN4@CleanupRtt:
	mov	DWORD PTR tv69[ebp], 0
$LN5@CleanupRtt:

; 1068 : 		renderTexture = NULL;

	mov	DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A, 0 ; VirtualDisplay::renderTexture

; 1069 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@CleanupRtt
$LN1@CleanupRtt:

; 1070 : 	}
; 1071 : 	return false;

	xor	al, al
$LN2@CleanupRtt:

; 1072 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupRttTarget@VirtualDisplay@@SA_NXZ ENDP		; VirtualDisplay::CleanupRttTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv76 = -28						; size = 4
$T3 = -24						; size = 4
tv65 = -20						; size = 4
_tBpp$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_tXres_$ = 8						; size = 4
_tYres_$ = 12						; size = 4
_tBpp_$ = 16						; size = 4
?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z PROC		; VirtualDisplay::SetupRttTarget

; 1035 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1036 : 	// Initialize the shared renderTexture only once
; 1037 : 	if( !renderTexture )

	cmp	DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A, 0 ; VirtualDisplay::renderTexture
	jne	$LN7@SetupRttTa

; 1038 : 	{
; 1039 : 		int tBpp;
; 1040 : 		switch( tBpp_ )

	mov	eax, DWORD PTR _tBpp_$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	je	SHORT $LN4@SetupRttTa
	cmp	DWORD PTR tv65[ebp], 24			; 00000018H
	je	SHORT $LN3@SetupRttTa
	cmp	DWORD PTR tv65[ebp], 32			; 00000020H
	je	SHORT $LN2@SetupRttTa
	jmp	SHORT $LN1@SetupRttTa
$LN4@SetupRttTa:

; 1041 : 		{
; 1042 : 		  case 16: 
; 1043 : 			tBpp = MPR_TI_RGB16;

	mov	DWORD PTR _tBpp$4[ebp], 2097152		; 00200000H

; 1044 : 			break;

	jmp	SHORT $LN5@SetupRttTa
$LN3@SetupRttTa:

; 1045 : 		  case 24: 
; 1046 : 			tBpp = MPR_TI_RGB24;

	mov	DWORD PTR _tBpp$4[ebp], 4194304		; 00400000H

; 1047 : 			break;

	jmp	SHORT $LN5@SetupRttTa
$LN2@SetupRttTa:

; 1048 : 		  case 32: 
; 1049 : 			tBpp = MPR_TI_ARGB32;

	mov	DWORD PTR _tBpp$4[ebp], 8388608		; 00800000H

; 1050 : 			break;

	jmp	SHORT $LN5@SetupRttTa
$LN1@SetupRttTa:

; 1051 : 		  default:
; 1052 : 			tBpp = MPR_TI_ARGB32;

	mov	DWORD PTR _tBpp$4[ebp], 8388608		; 00800000H
$LN5@SetupRttTa:

; 1053 : 		}
; 1054 : 
; 1055 : 		renderTexture = new TextureHandle;

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN10@SetupRttTa
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0TextureHandle@@QAE@XZ		; TextureHandle::TextureHandle
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN11@SetupRttTa
$LN10@SetupRttTa:
	mov	DWORD PTR tv76[ebp], 0
$LN11@SetupRttTa:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A, edx ; VirtualDisplay::renderTexture

; 1056 : 		renderTexture->Create( "RttTarget", tBpp, 0, tXres_, tYres_, 
; 1057 : 				TextureHandle::FLAG_RENDERTARGET | TextureHandle::FLAG_HINT_DYNAMIC );

	push	17					; 00000011H
	movzx	eax, WORD PTR _tYres_$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tXres_$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _tBpp$4[ebp]
	push	edx
	push	OFFSET ??_C@_09BAFPBEDI@RttTarget?$AA@
	mov	ecx, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	call	?Create@TextureHandle@@QAE_NPADKGGGK@Z	; TextureHandle::Create

; 1058 : 
; 1059 : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@SetupRttTa
$LN7@SetupRttTa:

; 1060 : 	}
; 1061 : 	return false;

	xor	al, al
$LN8@SetupRttTa:

; 1062 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z ENDP		; VirtualDisplay::SetupRttTarget
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_x3$ = 24						; size = 4
_y3$ = 28						; size = 4
?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z PROC		; VirtualDisplay::Render2DTri
; _this$ = ecx

; 375  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	Render2DLine( x1, y1, x2, y2 );

	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 377  : 	Render2DLine( x2, y2, x3, y3 );

	push	ecx
	movss	xmm0, DWORD PTR _y3$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x3$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 378  : 	Render2DLine( x3, y3, x1, y1 );

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y3$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x3$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 379  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z ENDP		; VirtualDisplay::Render2DTri
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?viewportYtoPixel@VirtualDisplay@@QAEMM@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_y$ = 8							; size = 4
?viewportYtoPixel@VirtualDisplay@@QAEMM@Z PROC		; VirtualDisplay::viewportYtoPixel, COMDAT
; _this$ = ecx

; 169  :     float viewportYtoPixel( float y ) { return (y * scaleY) + shiftY; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ENDP		; VirtualDisplay::viewportYtoPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?viewportXtoPixel@VirtualDisplay@@QAEMM@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?viewportXtoPixel@VirtualDisplay@@QAEMM@Z PROC		; VirtualDisplay::viewportXtoPixel, COMDAT
; _this$ = ecx

; 168  :     float viewportXtoPixel( float x ) { return (x * scaleX) + shiftX; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ENDP		; VirtualDisplay::viewportXtoPixel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_leftSide$ = 8						; size = 4
_topSide$ = 12						; size = 4
_rightSide$ = 16					; size = 4
_bottomSide$ = 20					; size = 4
?GetViewport@VirtualDisplay@@QAEXPAM000@Z PROC		; VirtualDisplay::GetViewport
; _this$ = ecx

; 157  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 	*leftSide	= left;

	mov	eax, DWORD PTR _leftSide$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 159  : 	*topSide	= top;

	mov	eax, DWORD PTR _topSide$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 160  : 	*rightSide	= right;

	mov	eax, DWORD PTR _rightSide$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 161  : 	*bottomSide	= bottom;

	mov	eax, DWORD PTR _bottomSide$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetViewport@VirtualDisplay@@QAEXPAM000@Z ENDP		; VirtualDisplay::GetViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dm$ = 8						; size = 4
?RestoreDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z PROC ; VirtualDisplay::RestoreDisplayMatrix
; _this$ = ecx

; 200  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 201  : 	dmatrix = *dm;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _dm$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 202  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RestoreDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z ENDP ; VirtualDisplay::RestoreDisplayMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dm$ = 8						; size = 4
?SaveDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z PROC ; VirtualDisplay::SaveDisplayMatrix
; _this$ = ecx

; 195  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 	*dm = dmatrix;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _dm$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 197  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SaveDisplayMatrix@VirtualDisplay@@QAEXPAUDisplayMatrix@@@Z ENDP ; VirtualDisplay::SaveDisplayMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::ZeroRotationAboutOrigin, COMDAT
; _this$ = ecx

; 144  :     void ZeroRotationAboutOrigin( void ) { dmatrix.rotation01 = dmatrix.rotation10 = 0.0f, dmatrix.rotation00 = dmatrix.rotation11 = 1.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+84], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+80], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+88], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+76], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::ZeroRotationAboutOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CenterOriginInViewport@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::CenterOriginInViewport, COMDAT
; _this$ = ecx

; 143  : 	void CenterOriginInViewport( void )  { dmatrix.translationX = 0.0f; dmatrix.translationY = 0.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+68], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+72], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::CenterOriginInViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_temp$ = -16						; size = 4
_cosAng$ = -12						; size = 4
_sinAng$ = -8						; size = 4
_this$ = -4						; size = 4
_angle$ = 8						; size = 4
?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z PROC	; VirtualDisplay::AdjustRotationAboutOrigin
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	float temp;
; 181  : 	float cosAng = (float)cos( angle );

	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosAng$[ebp]

; 182  : 	float sinAng = (float)sin( angle );

	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinAng$[ebp]

; 183  : 
; 184  :     temp	   = dmatrix.rotation00 * cosAng - dmatrix.rotation01 * sinAng;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+76]
	mulss	xmm0, DWORD PTR _cosAng$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+80]
	mulss	xmm1, DWORD PTR _sinAng$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _temp$[ebp], xmm0

; 185  :     dmatrix.rotation01 = dmatrix.rotation00 * sinAng + dmatrix.rotation01 * cosAng;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+76]
	mulss	xmm0, DWORD PTR _sinAng$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+80]
	mulss	xmm1, DWORD PTR _cosAng$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+80], xmm0

; 186  :     dmatrix.rotation00 = temp;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _temp$[ebp]
	movss	DWORD PTR [edx+76], xmm0

; 187  : 
; 188  :     temp       = dmatrix.rotation10 * cosAng - dmatrix.rotation11 * sinAng;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR _cosAng$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+88]
	mulss	xmm1, DWORD PTR _sinAng$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _temp$[ebp], xmm0

; 189  :     dmatrix.rotation11 = dmatrix.rotation10 * sinAng + dmatrix.rotation11 * cosAng;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+84]
	mulss	xmm0, DWORD PTR _sinAng$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+88]
	mulss	xmm1, DWORD PTR _cosAng$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+88], xmm0

; 190  :     dmatrix.rotation10 = temp;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _temp$[ebp]
	movss	DWORD PTR [edx+84], xmm0

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ENDP	; VirtualDisplay::AdjustRotationAboutOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_horizontal$ = 8					; size = 4
_vertical$ = 12						; size = 4
?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z PROC	; VirtualDisplay::AdjustOriginInViewport
; _this$ = ecx

; 169  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	dmatrix.translationX += horizontal;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	addss	xmm0, DWORD PTR _horizontal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+68], xmm0

; 171  : 	dmatrix.translationY += vertical;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+72]
	addss	xmm0, DWORD PTR _vertical$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+72], xmm0

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ENDP	; VirtualDisplay::AdjustOriginInViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_leftSide$ = -28					; size = 4
_topSide$ = -24						; size = 4
_rightSide$ = -20					; size = 4
_bottomSide$ = -16					; size = 4
_w$ = -12						; size = 4
_h$ = -8						; size = 4
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z PROC	; VirtualDisplay::SetViewportRelative
; _this$ = ecx

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 	float	w = right - left;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	subss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR _w$[ebp], xmm0

; 141  : 	float	h = top - bottom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+24]
	subss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR _h$[ebp], xmm0

; 142  : 
; 143  : 	float	topSide    = top    - (1.0f - t)/2.0f * h;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _t$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+24]
	subss	xmm1, xmm0
	movss	DWORD PTR _topSide$[ebp], xmm1

; 144  : 	float	bottomSide = bottom + (1.0f + b)/2.0f * h;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _b$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR _bottomSide$[ebp], xmm0

; 145  : 	float	leftSide   = left   + (1.0f + l)/2.0f * w;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _l$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR _leftSide$[ebp], xmm0

; 146  : 	float	rightSide  = right  - (1.0f - r)/2.0f * w;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _r$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+20]
	subss	xmm1, xmm0
	movss	DWORD PTR _rightSide$[ebp], xmm1

; 147  : 
; 148  : 	SetViewport( leftSide, topSide, rightSide, bottomSide );

	push	ecx
	movss	xmm0, DWORD PTR _bottomSide$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rightSide$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _topSide$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _leftSide$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 149  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z ENDP	; VirtualDisplay::SetViewportRelative
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv292 = -60						; size = 8
tv283 = -52						; size = 8
tv274 = -44						; size = 8
tv265 = -36						; size = 8
tv290 = -28						; size = 4
tv281 = -24						; size = 4
tv272 = -20						; size = 4
tv263 = -16						; size = 4
_this$ = -12						; size = 4
tv287 = -8						; size = 2
tv278 = -6						; size = 2
tv269 = -4						; size = 2
tv260 = -2						; size = 2
_l$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_b$ = 20						; size = 4
?SetViewport@VirtualDisplay@@UAEXMMMM@Z PROC		; VirtualDisplay::SetViewport
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 	static const float	E = 0.01f;	// Eplsion value to ensure we stay within our pixel limits
; 93   : 
; 94   : 	//sfr: some cropping
; 95   : 	if (l < -1.0f){ l = -1.0f; }

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _l$[ebp]
	jbe	SHORT $LN6@SetViewpor
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _l$[ebp], xmm0
$LN6@SetViewpor:

; 96   : 	if (t > 1.0f){ t = 1.0f; }

	movss	xmm0, DWORD PTR _t$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN5@SetViewpor
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t$[ebp], xmm0
$LN5@SetViewpor:

; 97   : 	if (r > 1.0f){ r = 1.0f; }

	movss	xmm0, DWORD PTR _r$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN4@SetViewpor
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _r$[ebp], xmm0
$LN4@SetViewpor:

; 98   : 	if (b < -1.0f){ b = -1.0f; }

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _b$[ebp]
	jbe	SHORT $LN3@SetViewpor
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _b$[ebp], xmm0
$LN3@SetViewpor:

; 99   : 
; 100  : 	left = l, top = t, 
; 101  : 	right = r, bottom = b;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _l$[ebp]
	movss	DWORD PTR [eax+16], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [ecx+24], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [edx+20], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [eax+28], xmm0

; 102  : 
; 103  : 	scaleX = (r-l)*xRes*0.25f - E;

	movss	xmm0, DWORD PTR _r$[ebp]
	subss	xmm0, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+8]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3e800000
	subss	xmm0, DWORD PTR ?E@?1??SetViewport@VirtualDisplay@@UAEXMMMM@Z@4MB
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+32], xmm0

; 104  : 	if (scaleX < 0.0f) scaleX = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+32]
	jbe	SHORT $LN2@SetViewpor
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+32], xmm0
$LN2@SetViewpor:

; 105  : 	shiftX = (l+1.0f+(r-l)*0.5f)*xRes*0.5f;

	movss	xmm0, DWORD PTR _l$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR _r$[ebp]
	subss	xmm1, DWORD PTR _l$[ebp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+8]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 106  : 	shiftX += tLeft;	// ASSO: for adjusted RTT viewport

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+262756]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 107  : 
; 108  : 	scaleY = (t-b)*yRes*0.25f - E;

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+12]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3e800000
	subss	xmm0, DWORD PTR ?E@?1??SetViewport@VirtualDisplay@@UAEXMMMM@Z@4MB
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+36], xmm0

; 109  : 	if (scaleY < 0.0f) scaleY = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+36]
	jbe	SHORT $LN1@SetViewpor
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+36], xmm0
$LN1@SetViewpor:

; 110  : 	shiftY = yRes - ((b+1.0f+(t-b)*0.5f)*yRes*0.5f);

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+12]
	movss	xmm1, DWORD PTR _b$[ebp]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _t$[ebp]
	subss	xmm2, DWORD PTR _b$[ebp]
	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm1, xmm2
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm2, DWORD PTR [eax+12]
	mulss	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 111  : 	shiftY += tTop;		// ASSO: for adjusted RTT viewport

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+262760]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 112  : 	
; 113  : 
; 114  : 	// Now store our pixel space boundries
; 115  : 	// (top/right inclusive, bottom/left exclusive)
; 116  : 	topPixel	= viewportYtoPixel(-1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+52]

; 117  : 	bottomPixel	= viewportYtoPixel( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+56]

; 118  : 	leftPixel	= viewportXtoPixel(-1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+60]

; 119  : 	rightPixel	= viewportXtoPixel( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+64]

; 120  : 
; 121  : 	ShiAssert( floor(topPixel)   >= 0.0f );
; 122  : 	ShiAssert( ceil(bottomPixel) >= 0.0f );
; 123  : 	ShiAssert( floor(leftPixel)  >= 0.0f );
; 124  : 	ShiAssert( ceil(rightPixel)  >= 0.0f );
; 125  : 	// ASSO: changed xRes to txRes and yRes to tyRes
; 126  : 	ShiAssert( floor(topPixel)	 <= tyRes );
; 127  : 	ShiAssert( ceil(bottomPixel) <= tyRes );	
; 128  : 	ShiAssert( floor(leftPixel)	 <= txRes );
; 129  : 	ShiAssert( ceil(rightPixel)  <= txRes );
; 130  : 	TheDXEngine.SetViewport((DWORD)leftPixel, (DWORD)topPixel, (DWORD)rightPixel, (DWORD)bottomPixel);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	fnstcw	WORD PTR tv260[ebp]
	movzx	eax, WORD PTR tv260[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv263[ebp], eax
	fldcw	WORD PTR tv263[ebp]
	fistp	QWORD PTR tv265[ebp]
	fldcw	WORD PTR tv260[ebp]
	mov	ecx, DWORD PTR tv265[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+64]
	fnstcw	WORD PTR tv269[ebp]
	movzx	eax, WORD PTR tv269[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv272[ebp], eax
	fldcw	WORD PTR tv272[ebp]
	fistp	QWORD PTR tv274[ebp]
	fldcw	WORD PTR tv269[ebp]
	mov	eax, DWORD PTR tv274[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+52]
	fnstcw	WORD PTR tv278[ebp]
	movzx	eax, WORD PTR tv278[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv281[ebp], eax
	fldcw	WORD PTR tv281[ebp]
	fistp	QWORD PTR tv283[ebp]
	fldcw	WORD PTR tv278[ebp]
	mov	edx, DWORD PTR tv283[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	fnstcw	WORD PTR tv287[ebp]
	movzx	eax, WORD PTR tv287[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv290[ebp], eax
	fldcw	WORD PTR tv290[ebp]
	fistp	QWORD PTR tv292[ebp]
	fldcw	WORD PTR tv287[ebp]
	mov	ecx, DWORD PTR tv292[ebp]
	push	ecx
	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?SetViewport@CDXEngine@@QAEXKKKK@Z	; CDXEngine::SetViewport

; 131  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetViewport@VirtualDisplay@@UAEXMMMM@Z ENDP		; VirtualDisplay::SetViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_newfont$ = 8						; size = 4
?SetFont@VirtualDisplay@@SAXH@Z PROC			; VirtualDisplay::SetFont

; 1027 : { 

	push	ebp
	mov	ebp, esp

; 1028 :     ShiAssert(newfont >= 0 && newfont < NUM_FONT_RESOLUTIONS);
; 1029 :     if (newfont >= pFontSet->totalFont) 

	mov	eax, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	ecx, DWORD PTR _newfont$[ebp]
	cmp	ecx, DWORD PTR [eax+24676]
	jl	SHORT $LN2@SetFont

; 1030 : 	newfont = pFontSet->totalFont-1; 

	mov	edx, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	eax, DWORD PTR [edx+24676]
	sub	eax, 1
	mov	DWORD PTR _newfont$[ebp], eax
	jmp	SHORT $LN3@SetFont
$LN2@SetFont:

; 1031 :     else pFontSet->fontNum = newfont;

	mov	ecx, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	edx, DWORD PTR _newfont$[ebp]
	mov	DWORD PTR [ecx+24672], edx
$LN3@SetFont:

; 1032 : }

	pop	ebp
	ret	0
?SetFont@VirtualDisplay@@SAXH@Z ENDP			; VirtualDisplay::SetFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_width$ = -4						; size = 4
_string$ = 8						; size = 4
?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z PROC		; VirtualDisplay::ScreenTextWidth

; 637  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 638  : #ifndef USE_TEXTURE_FONT
; 639  : 	unsigned	num;
; 640  : 	int			width;
; 641  : 
; 642  : 	width = 0;
; 643  : 
; 644  : 	while (*string)
; 645  : 	{
; 646  : 		num = FontLUT[*(unsigned char *)string];
; 647  : 		ShiAssert( num < FontLength );
; 648  : 
; 649  : 		width += Font[num][8] + 1;
; 650  : 
; 651  : 		string++;
; 652  : 	}
; 653  : 
; 654  : 	return width - 1;
; 655  : #else
; 656  : 	int width = 0;

	mov	DWORD PTR _width$[ebp], 0
$LN2@ScreenText:

; 657  : 
; 658  : 	while (*string)

	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@ScreenText

; 659  : 	{
; 660  : 		width += FloatToInt32(pFontSet->fontData[pFontSet->fontNum][*string].pixelWidth);

	mov	edx, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	eax, DWORD PTR [edx+24672]
	imul	eax, 6144				; 00001800H
	mov	ecx, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	lea	edx, DWORD PTR [ecx+eax+96]
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	imul	ecx, 24					; 00000018H
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 661  : 		string++;

	mov	edx, DWORD PTR _string$[ebp]
	add	edx, 1
	mov	DWORD PTR _string$[ebp], edx

; 662  : 	}

	jmp	SHORT $LN2@ScreenText
$LN1@ScreenText:

; 663  : 
; 664  : 	return width;

	mov	eax, DWORD PTR _width$[ebp]

; 665  : #endif
; 666  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ENDP		; VirtualDisplay::ScreenTextWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
?ScreenTextHeight@VirtualDisplay@@SAHXZ PROC		; VirtualDisplay::ScreenTextHeight

; 673  : {

	push	ebp
	mov	ebp, esp

; 674  : #ifndef USE_TEXTURE_FONT
; 675  : 	// Right now we have only one font.  It draws 6 pixels high with one
; 676  : 	// pixel each above and below for spacing and reverse video effects.
; 677  : 	return 8;
; 678  : #else
; 679  : 	return FloatToInt32(pFontSet->fontData[pFontSet->fontNum][32].pixelHeight);

	mov	eax, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	ecx, DWORD PTR [eax+24672]
	imul	ecx, 6144				; 00001800H
	mov	edx, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	lea	eax, DWORD PTR [edx+ecx+96]
	mov	ecx, 24					; 00000018H
	shl	ecx, 5
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx+20]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 680  : #endif
; 681  : }

	pop	ebp
	ret	0
?ScreenTextHeight@VirtualDisplay@@SAHXZ ENDP		; VirtualDisplay::ScreenTextHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_pixelsLeft$ = -24					; size = 4
_line$ = -20						; size = 4
_this$ = -16						; size = 4
_string$ = -12						; size = 4
_lineBreak$ = -8					; size = 4
_prevChar$ = -1						; size = 1
_h$ = 8							; size = 4
_v$ = 12						; size = 4
_s$ = 16						; size = 4
_spacing$ = 20						; size = 4
_width$ = 24						; size = 4
?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z PROC		; VirtualDisplay::TextWrap
; _this$ = ecx

; 572  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 	char *string = strdup(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_strdup
	add	esp, 4
	mov	DWORD PTR _string$[ebp], eax

; 574  : 	int pixelsLeft;
; 575  : 	char *lineBreak;
; 576  : 	char prevChar;
; 577  : 	int line = 0;

	mov	DWORD PTR _line$[ebp], 0
$LN12@TextWrap:

; 578  : 
; 579  : 	// While we have more to display
; 580  : 	while (*string) {

	mov	ecx, DWORD PTR _string$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN11@TextWrap

; 581  : 
; 582  : 		// We start from the end of the string
; 583  : 		lineBreak = string+strlen(string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _lineBreak$[ebp], eax

; 584  : 		ShiAssert( *lineBreak == '\0' );	
; 585  : 		prevChar = '\0';

	mov	BYTE PTR _prevChar$[ebp], 0

; 586  : 		pixelsLeft = FloatToInt32(width*scaleX) - ScreenTextWidth( string );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR [ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	sub	esi, eax
	mov	DWORD PTR _pixelsLeft$[ebp], esi
$LN10@TextWrap:

; 587  : 
; 588  : 		// While we need to shorten the string...
; 589  : 		while (pixelsLeft < 0) {

	cmp	DWORD PTR _pixelsLeft$[ebp], 0
	jge	SHORT $LN9@TextWrap

; 590  : 
; 591  : 			// Take the synthetic NULL back out
; 592  : 			*lineBreak = prevChar;

	mov	eax, DWORD PTR _lineBreak$[ebp]
	mov	cl, BYTE PTR _prevChar$[ebp]
	mov	BYTE PTR [eax], cl
$LN8@TextWrap:

; 593  : 
; 594  : 			// Find the next word to slice off
; 595  : 			do {
; 596  : 				lineBreak--;

	mov	edx, DWORD PTR _lineBreak$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lineBreak$[ebp], edx

; 597  : 				ShiAssert( lineBreak >= string );
; 598  : 			} while (*lineBreak != ' ');

	mov	eax, DWORD PTR _lineBreak$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN8@TextWrap
$LN6@TextWrap:

; 599  : 			do {
; 600  : 				lineBreak--;

	mov	edx, DWORD PTR _lineBreak$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lineBreak$[ebp], edx

; 601  : 				ShiAssert( lineBreak >= string );
; 602  : 			} while (*lineBreak == ' ');

	mov	eax, DWORD PTR _lineBreak$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN6@TextWrap

; 603  : 			lineBreak++;	// Step back to the first space after the word

	mov	edx, DWORD PTR _lineBreak$[ebp]
	add	edx, 1
	mov	DWORD PTR _lineBreak$[ebp], edx

; 604  : 
; 605  : 			// Save the existing character, then insert NULL terminator
; 606  : 			prevChar = *lineBreak;

	mov	eax, DWORD PTR _lineBreak$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _prevChar$[ebp], cl

; 607  : 			*lineBreak = '\0';

	mov	edx, DWORD PTR _lineBreak$[ebp]
	mov	BYTE PTR [edx], 0

; 608  : 
; 609  : 			// Recompute the length of the trimmed string
; 610  : 			pixelsLeft = FloatToInt32(width*scaleX) - ScreenTextWidth( string );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	sub	esi, eax
	mov	DWORD PTR _pixelsLeft$[ebp], esi

; 611  : 		}

	jmp	SHORT $LN10@TextWrap
$LN9@TextWrap:

; 612  : 
; 613  : 		// Now print the trimmed string
; 614  : 		TextLeft( h, v-line*spacing, string );

	push	0
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	cvtsi2ss xmm0, DWORD PTR _line$[ebp]
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	movss	xmm1, DWORD PTR _v$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 615  : 
; 616  : 		// Take the synthetic NULL back out and advance
; 617  : 		*lineBreak = prevChar;

	mov	ecx, DWORD PTR _lineBreak$[ebp]
	mov	dl, BYTE PTR _prevChar$[ebp]
	mov	BYTE PTR [ecx], dl

; 618  : 		string = lineBreak;

	mov	eax, DWORD PTR _lineBreak$[ebp]
	mov	DWORD PTR _string$[ebp], eax

; 619  : 		line++;

	mov	ecx, DWORD PTR _line$[ebp]
	add	ecx, 1
	mov	DWORD PTR _line$[ebp], ecx
$LN2@TextWrap:

; 620  : 
; 621  : 		// Skip any extra white space
; 622  : 		while (*string == ' ') {

	mov	edx, DWORD PTR _string$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN1@TextWrap

; 623  : 			string++;

	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, 1
	mov	DWORD PTR _string$[ebp], ecx

; 624  : 		}

	jmp	SHORT $LN2@TextWrap
$LN1@TextWrap:

; 625  : 	}

	jmp	$LN12@TextWrap
$LN11@TextWrap:

; 626  : 
; 627  : 
; 628  : 	free(string);

	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 629  : 	return line;

	mov	eax, DWORD PTR _line$[ebp]

; 630  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z ENDP		; VirtualDisplay::TextWrap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_xPixel$ = -12						; size = 4
_yPixel$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z PROC	; VirtualDisplay::TextCenterVertical
; _this$ = ecx

; 548  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 549  : 	float	xPixel, yPixel;
; 550  : 
; 551  : 	// Rotation and translate this point based on the current settings
; 552  : 	// Convert from viewport coordiants to screen space
; 553  : 	xPixel = viewportXtoPixel(  x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	fstp	DWORD PTR _xPixel$[ebp]

; 554  : 	yPixel = viewportYtoPixel( -x1 * dmatrix.rotation10 - y1 * dmatrix.rotation11 - dmatrix.translationY );

	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	fstp	DWORD PTR _yPixel$[ebp]

; 555  : 
; 556  : 	// Adjust our starting point in screen space to get proper alignment
; 557  : 	xPixel -= ScreenTextWidth (string) / 2;

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _xPixel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _xPixel$[ebp], xmm1

; 558  : 	yPixel -= ScreenTextHeight() / 2;

	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _yPixel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _yPixel$[ebp], xmm1

; 559  : 
; 560  : 	// Draw the string on the screen
; 561  : 	ScreenText( xPixel, yPixel, string, boxed );

	mov	ecx, DWORD PTR _boxed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _yPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 562  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z ENDP	; VirtualDisplay::TextCenterVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_yPixel$ = -12						; size = 4
_xPixel$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z PROC		; VirtualDisplay::TextCenter
; _this$ = ecx

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 527  : 	float	xPixel, yPixel;
; 528  : 
; 529  : 	// Rotation and translate this point based on the current settings
; 530  : 	// Convert from viewport coordiants to screen space
; 531  : 	xPixel = viewportXtoPixel(  x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	fstp	DWORD PTR _xPixel$[ebp]

; 532  : 	yPixel = viewportYtoPixel( -x1 * dmatrix.rotation10 - y1 * dmatrix.rotation11 - dmatrix.translationY );

	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	fstp	DWORD PTR _yPixel$[ebp]

; 533  : 
; 534  : 	// Adjust our starting point in screen space to get proper alignment
; 535  : 	xPixel -= ScreenTextWidth (string) / 2;

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _xPixel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _xPixel$[ebp], xmm1

; 536  : 
; 537  : 	// Draw the string on the screen
; 538  : 	ScreenText( xPixel, yPixel, string, boxed );

	mov	ecx, DWORD PTR _boxed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _yPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 539  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z ENDP		; VirtualDisplay::TextCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_xPixel$ = -12						; size = 4
_yPixel$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z PROC	; VirtualDisplay::TextRightVertical
; _this$ = ecx

; 503  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 	float	xPixel, yPixel;
; 505  : 
; 506  : 	// Rotation and translate this point based on the current settings
; 507  : 	// Convert from viewport coordiants to screen space
; 508  : 	xPixel = viewportXtoPixel(  x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	fstp	DWORD PTR _xPixel$[ebp]

; 509  : 	yPixel = viewportYtoPixel( -x1 * dmatrix.rotation10 - y1 * dmatrix.rotation11 - dmatrix.translationY );

	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	fstp	DWORD PTR _yPixel$[ebp]

; 510  : 
; 511  : 	// Adjust our starting point in screen space to get proper alignment
; 512  : 	xPixel -= ScreenTextWidth (string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _xPixel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _xPixel$[ebp], xmm1

; 513  : 	yPixel -= ScreenTextHeight() / 2;

	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _yPixel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _yPixel$[ebp], xmm1

; 514  : 
; 515  : 	// Draw the string on the screen
; 516  : 	ScreenText( xPixel, yPixel, string, boxed );

	mov	ecx, DWORD PTR _boxed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _yPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z ENDP	; VirtualDisplay::TextRightVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z PROC	; VirtualDisplay::TextLeftVertical
; _this$ = ecx

; 468  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 	float	x, y;
; 470  : 
; 471  : 	// Rotation and translate this point based on the current settings
; 472  : 	x = viewportXtoPixel(x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	fstp	DWORD PTR _x$[ebp]

; 473  : 	y = viewportYtoPixel( -x1 * dmatrix.rotation10 - y1 * dmatrix.rotation11 - dmatrix.translationY );

	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	fstp	DWORD PTR _y$[ebp]

; 474  : 
; 475  : 	y -= ScreenTextHeight() / 2;

	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _y$[ebp], xmm1

; 476  : 
; 477  : 	// Convert from viewport coordiants to screen space and draw the string
; 478  : 	ScreenText( x, y, string, boxed );

	mov	eax, DWORD PTR _boxed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 479  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z ENDP	; VirtualDisplay::TextLeftVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_yPixel$ = -12						; size = 4
_xPixel$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?TextRight@VirtualDisplay@@UAEXMMPBDH@Z PROC		; VirtualDisplay::TextRight
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	float	xPixel, yPixel;
; 489  : 
; 490  : 	// Rotation and translate this point based on the current settings
; 491  : 	// Convert from viewport coordiants to screen space
; 492  : 	xPixel = viewportXtoPixel(  x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	fstp	DWORD PTR _xPixel$[ebp]

; 493  : 	yPixel = viewportYtoPixel( -x1 * dmatrix.rotation10 - y1 * dmatrix.rotation11 - dmatrix.translationY );

	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	fstp	DWORD PTR _yPixel$[ebp]

; 494  : 
; 495  : 	// Adjust our starting point in screen space to get proper alignment
; 496  : 	xPixel -= ScreenTextWidth (string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _xPixel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _xPixel$[ebp], xmm1

; 497  : 
; 498  : 	// Draw the string on the screen
; 499  : 	ScreenText( xPixel, yPixel, string, boxed );

	mov	ecx, DWORD PTR _boxed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _yPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPixel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 500  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TextRight@VirtualDisplay@@UAEXMMPBDH@Z ENDP		; VirtualDisplay::TextRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z PROC		; VirtualDisplay::TextLeft
; _this$ = ecx

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 	float	x, y;
; 458  : 
; 459  : 	// Rotation and translate this point based on the current settings
; 460  : 	x = x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 461  : 	y = x1 * dmatrix.rotation10 + y1 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y$[ebp], xmm0

; 462  : 
; 463  : 	// Convert from viewport coordiants to screen space and draw the string
; 464  : 	ScreenText( viewportXtoPixel(x), viewportYtoPixel(-y), string, boxed );

	mov	eax, DWORD PTR _boxed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 465  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z ENDP		; VirtualDisplay::TextLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv221 = -24						; size = 4
tv207 = -20						; size = 4
_stopEntry$ = -16					; size = 4
_startEntry$ = -12					; size = 4
_this$ = -8						; size = 4
_entry$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
_yRadius$ = 20						; size = 4
_start$ = 24						; size = 4
_stop$ = 28						; size = 4
?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z PROC		; VirtualDisplay::OvalArc
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 	int		entry, startEntry, stopEntry;
; 422  : 
; 423  : 	// Find the first and last segment end point of interest
; 424  : 	startEntry	= (int)(fmod(start, 2.0f*PI) / PI * 180.0) / CircleStep;

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR tv207[ebp]
	movss	xmm0, DWORD PTR tv207[ebp]
	divss	xmm0, DWORD PTR __real@40490fdb
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@4066800000000000
	cvttsd2si eax, xmm0
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _startEntry$[ebp], eax

; 425  : 	stopEntry	= (int)(fmod(stop,  2.0f*PI) / PI * 180.0) / CircleStep;

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _stop$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR tv221[ebp]
	movss	xmm0, DWORD PTR tv221[ebp]
	divss	xmm0, DWORD PTR __real@40490fdb
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@4066800000000000
	cvttsd2si eax, xmm0
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _stopEntry$[ebp], eax

; 426  : 
; 427  : 	// Make sure we aren't overrunning the precomputed array
; 428  : 	ShiAssert( startEntry >= 0 );
; 429  : 	ShiAssert( stopEntry >= 0 );
; 430  : 	ShiAssert( startEntry < CircleSegments );
; 431  : 	ShiAssert( stopEntry < CircleSegments );
; 432  : 
; 433  : 	if ( startEntry <= stopEntry) {

	mov	eax, DWORD PTR _startEntry$[ebp]
	cmp	eax, DWORD PTR _stopEntry$[ebp]
	jg	$LN11@OvalArc

; 434  : 		for (entry = startEntry; entry < stopEntry; entry++) {

	mov	ecx, DWORD PTR _startEntry$[ebp]
	mov	DWORD PTR _entry$[ebp], ecx
	jmp	SHORT $LN10@OvalArc
$LN9@OvalArc:
	mov	edx, DWORD PTR _entry$[ebp]
	add	edx, 1
	mov	DWORD PTR _entry$[ebp], edx
$LN10@OvalArc:
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	eax, DWORD PTR _stopEntry$[ebp]
	jge	$LN8@OvalArc

; 435  : 			Line( x + xRadius*CircleX[entry],   y + yRadius*CircleY[entry],
; 436  : 				  x + xRadius*CircleX[entry+1], y + yRadius*CircleY[entry+1] );

	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[ecx*4+4]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[edx*4+4]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[eax*4]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[ecx*4]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 437  : 		}

	jmp	$LN9@OvalArc
$LN8@OvalArc:
	jmp	$LN1@OvalArc
$LN11@OvalArc:

; 438  : 	} else {
; 439  : 		for (entry = startEntry; entry < CircleSegments-1; entry++) {

	mov	eax, DWORD PTR _startEntry$[ebp]
	mov	DWORD PTR _entry$[ebp], eax
	jmp	SHORT $LN6@OvalArc
$LN5@OvalArc:
	mov	ecx, DWORD PTR _entry$[ebp]
	add	ecx, 1
	mov	DWORD PTR _entry$[ebp], ecx
$LN6@OvalArc:
	cmp	DWORD PTR _entry$[ebp], 90		; 0000005aH
	jge	$LN4@OvalArc

; 440  : 			Line( x + xRadius*CircleX[entry],   y + yRadius*CircleY[entry],
; 441  : 				  x + xRadius*CircleX[entry+1], y + yRadius*CircleY[entry+1] );

	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[edx*4+4]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[eax*4+4]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[ecx*4]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[edx*4]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 442  : 		}

	jmp	$LN5@OvalArc
$LN4@OvalArc:

; 443  : 		for (entry = 0; entry < stopEntry; entry++) {

	mov	DWORD PTR _entry$[ebp], 0
	jmp	SHORT $LN3@OvalArc
$LN2@OvalArc:
	mov	ecx, DWORD PTR _entry$[ebp]
	add	ecx, 1
	mov	DWORD PTR _entry$[ebp], ecx
$LN3@OvalArc:
	mov	edx, DWORD PTR _entry$[ebp]
	cmp	edx, DWORD PTR _stopEntry$[ebp]
	jge	$LN1@OvalArc

; 444  : 			Line( x + xRadius*CircleX[entry],   y + yRadius*CircleY[entry],
; 445  : 				  x + xRadius*CircleX[entry+1], y + yRadius*CircleY[entry+1] );

	mov	eax, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[eax*4+4]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[ecx*4+4]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[edx*4]
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[eax*4]
	addss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 446  : 		}

	jmp	$LN2@OvalArc
$LN1@OvalArc:

; 447  : 	}
; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z ENDP		; VirtualDisplay::OvalArc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_y1$ = -24						; size = 4
_y2$ = -20						; size = 4
_x1$ = -16						; size = 4
_x2$ = -12						; size = 4
_this$ = -8						; size = 4
_entry$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
_yRadius$ = 20						; size = 4
?Oval@VirtualDisplay@@UAEXMMMM@Z PROC			; VirtualDisplay::Oval
; _this$ = ecx

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	int entry;
; 389  : 
; 390  : 	float x1, y1;
; 391  : 	float x2, y2;
; 392  : 
; 393  : 	// Prime the pump
; 394  : 	x1 = x + xRadius*CircleX[0];

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[eax]
	addss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 395  : 	y1 = y + yRadius*CircleY[0];

	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[ecx]
	addss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 396  : 
; 397  : 	for (entry = 1; entry <= CircleSegments-1; entry++) {

	mov	DWORD PTR _entry$[ebp], 1
	jmp	SHORT $LN3@Oval
$LN2@Oval:
	mov	edx, DWORD PTR _entry$[ebp]
	add	edx, 1
	mov	DWORD PTR _entry$[ebp], edx
$LN3@Oval:
	cmp	DWORD PTR _entry$[ebp], 90		; 0000005aH
	jg	$LN1@Oval

; 398  : 
; 399  : 		// Compute the end point of this next segment
; 400  : 		x2 = (x + xRadius*CircleX[entry]);

	mov	eax, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleX@@3PAMA[eax*4]
	addss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 401  : 		y2 = (y + yRadius*CircleY[entry]);

	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR _yRadius$[ebp]
	mulss	xmm0, DWORD PTR ?CircleY@@3PAMA[ecx*4]
	addss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 402  : 
; 403  : 		// Draw the segment
; 404  : 		Line( x1, y1, x2, y2 );

	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 405  : 
; 406  : 		// Save the end point of this one to use as the start point of the next one
; 407  : 		x1 = x2;

	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 408  : 		y1 = y2;

	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 409  : 	}

	jmp	$LN2@Oval
$LN1@Oval:

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Oval@VirtualDisplay@@UAEXMMMM@Z ENDP			; VirtualDisplay::Oval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_x$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_x3$ = 24						; size = 4
_y3$ = 28						; size = 4
?Tri@VirtualDisplay@@UAEXMMMMMM@Z PROC			; VirtualDisplay::Tri
; _this$ = ecx

; 352  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 353  : float	x;
; 354  : 
; 355  : 	// Rotation and translate this point based on the current settings
; 356  : 	x  = x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 357  : 	y1 = x1 * dmatrix.rotation10 + y1 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y1$[ebp], xmm0

; 358  : 	x1 = x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 359  : 
; 360  : 	x  = x2 * dmatrix.rotation00 + y2 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 361  : 	y2 = x2 * dmatrix.rotation10 + y2 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y2$[ebp], xmm0

; 362  : 	x2 = x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 363  : 
; 364  : 	x  = x3 * dmatrix.rotation00 + y3 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x3$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y3$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 365  : 	y3 = x3 * dmatrix.rotation10 + y3 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x3$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y3$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y3$[ebp], xmm0

; 366  : 	x3 = x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x3$[ebp], xmm0

; 367  : 
; 368  :    Render2DTri (
; 369  :       viewportXtoPixel(x1), viewportYtoPixel(-y1),
; 370  :       viewportXtoPixel(x2), viewportYtoPixel(-y2),
; 371  :       viewportXtoPixel(x3), viewportYtoPixel(-y3));

	movss	xmm0, DWORD PTR _y3$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x3$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _y2$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _y1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax

; 372  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Tri@VirtualDisplay@@UAEXMMMMMM@Z ENDP			; VirtualDisplay::Tri
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_l$ = -108						; size = 4
_this$ = -104						; size = 4
_a$ = -100						; size = 12
_d$ = -88						; size = 12
_c$ = -76						; size = 12
_b$ = -64						; size = 12
_e$ = -52						; size = 12
_s$ = -40						; size = 12
_normal$ = -28						; size = 12
_cross$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_width$ = 24						; size = 4
?Line@VirtualDisplay@@UAEXMMMMM@Z PROC			; VirtualDisplay::Line
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 	Tpoint a, b, c, d, normal, s, e, cross;
; 294  : 	// MD -- 20041028: new function for drawing wider lines:
; 295  : 	// mrivers figured out how to draw a line of greater than 1 pixel width in the
; 296  : 	// following manner -- I'm just the scribe here...
; 297  : 
; 298  : //	vector2 start(x1,y1);
; 299  : //	vector2 end(x2,y2);
; 300  : 	s.x = x1;

	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 301  : 	s.y = y1;

	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _s$[ebp+4], xmm0

; 302  : 	e.x = x2;

	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _e$[ebp], xmm0

; 303  : 	e.y = y2;

	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _e$[ebp+4], xmm0

; 304  : 
; 305  : 	normal.x = e.x - s.x;

	movss	xmm0, DWORD PTR _e$[ebp]
	subss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _normal$[ebp], xmm0

; 306  : 	normal.y = e.y - s.y;

	movss	xmm0, DWORD PTR _e$[ebp+4]
	subss	xmm0, DWORD PTR _s$[ebp+4]
	movss	DWORD PTR _normal$[ebp+4], xmm0

; 307  : 
; 308  : //	normal.norm();
; 309  : 	float l = (float) sqrt(normal.x * normal.x + normal.y * normal.y);

	movss	xmm0, DWORD PTR _normal$[ebp]
	mulss	xmm0, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR _normal$[ebp+4]
	mulss	xmm1, DWORD PTR _normal$[ebp+4]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _l$[ebp]

; 310  : 	if (l > 0.0000001)

	cvtss2sd xmm0, DWORD PTR _l$[ebp]
	comisd	xmm0, QWORD PTR __real@3e7ad7f29abcaf48
	jbe	SHORT $LN1@Line

; 311  : 	{
; 312  : 		normal.x /= l;

	movss	xmm0, DWORD PTR _normal$[ebp]
	divss	xmm0, DWORD PTR _l$[ebp]
	movss	DWORD PTR _normal$[ebp], xmm0

; 313  : 		normal.y /= l;

	movss	xmm0, DWORD PTR _normal$[ebp+4]
	divss	xmm0, DWORD PTR _l$[ebp]
	movss	DWORD PTR _normal$[ebp+4], xmm0
$LN1@Line:

; 314  : 	}
; 315  : 
; 316  : //	vector2 cross(-normal.y,normal.x);
; 317  : 	cross.x = -normal.y;

	movss	xmm0, DWORD PTR _normal$[ebp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _cross$[ebp], xmm0

; 318  : 	cross.y = normal.x;

	movss	xmm0, DWORD PTR _normal$[ebp]
	movss	DWORD PTR _cross$[ebp+4], xmm0

; 319  : 	cross.x *= width / 2;

	movss	xmm0, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _cross$[ebp]
	movss	DWORD PTR _cross$[ebp], xmm0

; 320  : 	cross.y *= width / 2;

	movss	xmm0, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _cross$[ebp+4]
	movss	DWORD PTR _cross$[ebp+4], xmm0

; 321  : 
; 322  : // RV - Biker - Do the trigonometry properly
; 323  : //	vector2 a=start+cross;
; 324  : 	a.x = s.x + cross.x;

	movss	xmm0, DWORD PTR _s$[ebp]
	addss	xmm0, DWORD PTR _cross$[ebp]
	movss	DWORD PTR _a$[ebp], xmm0

; 325  : 	a.y = s.y + cross.y;

	movss	xmm0, DWORD PTR _s$[ebp+4]
	addss	xmm0, DWORD PTR _cross$[ebp+4]
	movss	DWORD PTR _a$[ebp+4], xmm0

; 326  : 
; 327  : //	vector2 b=start-cross;
; 328  : 	//b.x = s.x + cross.x;
; 329  : 	//b.y = s.y + cross.y;
; 330  : 	b.x = s.x - cross.x;

	movss	xmm0, DWORD PTR _s$[ebp]
	subss	xmm0, DWORD PTR _cross$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 331  : 	b.y = s.y - cross.y;

	movss	xmm0, DWORD PTR _s$[ebp+4]
	subss	xmm0, DWORD PTR _cross$[ebp+4]
	movss	DWORD PTR _b$[ebp+4], xmm0

; 332  : 
; 333  : //	vector2 c=end+cross;
; 334  : 	c.x = e.x + cross.x;

	movss	xmm0, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR _cross$[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 335  : 	c.y = e.y + cross.y;

	movss	xmm0, DWORD PTR _e$[ebp+4]
	addss	xmm0, DWORD PTR _cross$[ebp+4]
	movss	DWORD PTR _c$[ebp+4], xmm0

; 336  : 
; 337  : //	vector2 d=end-cross;
; 338  : 	//d.x = e.x + cross.x;
; 339  : 	//d.y = e.y + cross.y;
; 340  : 	d.x = e.x - cross.x;

	movss	xmm0, DWORD PTR _e$[ebp]
	subss	xmm0, DWORD PTR _cross$[ebp]
	movss	DWORD PTR _d$[ebp], xmm0

; 341  : 	d.y = e.y - cross.y;

	movss	xmm0, DWORD PTR _e$[ebp+4]
	subss	xmm0, DWORD PTR _cross$[ebp+4]
	movss	DWORD PTR _d$[ebp+4], xmm0

; 342  : 
; 343  : 	Tri(a.x, a.y, b.x, b.y, c.x, c.y);

	push	ecx
	movss	xmm0, DWORD PTR _c$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _c$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _a$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 344  : 	Tri(c.x, c.y, d.x, d.y, b.x, b.y);

	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _c$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _c$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 345  : 
; 346  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Line@VirtualDisplay@@UAEXMMMMM@Z ENDP			; VirtualDisplay::Line
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_x$ = -12						; size = 4
_clipFlag$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?Line@VirtualDisplay@@UAEXMMMM@Z PROC			; VirtualDisplay::Line
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	float	x;
; 232  : 	int		clipFlag = ON_SCREEN;

	mov	DWORD PTR _clipFlag$[ebp], 0

; 233  : 
; 234  : 	// Rotation and translate this point based on the current settings
; 235  : 	x  = x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 236  : 	y1 = x1 * dmatrix.rotation10 + y1 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y1$[ebp], xmm0

; 237  : 	x1 = x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 238  : 
; 239  : 	x  = x2 * dmatrix.rotation00 + y2 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 240  : 	y2 = x2 * dmatrix.rotation10 + y2 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y2$[ebp], xmm0

; 241  : 	x2 = x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 242  : 
; 243  : 
; 244  : 	// Clip point 1
; 245  : 	clipFlag = ON_SCREEN;

	mov	DWORD PTR _clipFlag$[ebp], 0

; 246  : 	if ( x1 < -1.0f ) {

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _x1$[ebp]
	jbe	SHORT $LN16@Line

; 247  : 		 y1 = y2 + (y1-y2)*( (x2+1.0f)/(x2-x1) );

	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _y2$[ebp]
	movss	xmm1, DWORD PTR _x2$[ebp]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _x2$[ebp]
	subss	xmm2, DWORD PTR _x1$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 248  : 		 x1 = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _x1$[ebp], xmm0

; 249  : 		 clipFlag = CLIP_LEFT;

	mov	DWORD PTR _clipFlag$[ebp], 1
	jmp	SHORT $LN14@Line
$LN16@Line:

; 250  : 	} else if ( x1 > 1.0f ) {

	movss	xmm0, DWORD PTR _x1$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@Line

; 251  : 		 y1 = y2 + (y1-y2)*( (x2-1.0f)/(x2-x1) );

	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR _y2$[ebp]
	movss	xmm1, DWORD PTR _x2$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _x2$[ebp]
	subss	xmm2, DWORD PTR _x1$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 252  : 		 x1 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _x1$[ebp], xmm0

; 253  : 		 clipFlag = CLIP_RIGHT;

	mov	DWORD PTR _clipFlag$[ebp], 2
$LN14@Line:

; 254  : 	}
; 255  : 	if ( y1 < -1.0f ) {

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _y1$[ebp]
	jbe	SHORT $LN13@Line

; 256  : 		 x1 = x2 + (x1-x2)*( (y2+1.0f)/(y2-y1) );

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _y2$[ebp]
	subss	xmm2, DWORD PTR _y1$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 257  : 		 y1 = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _y1$[ebp], xmm0

; 258  : 		 clipFlag |= CLIP_BOTTOM;

	mov	eax, DWORD PTR _clipFlag$[ebp]
	or	eax, 8
	mov	DWORD PTR _clipFlag$[ebp], eax
	jmp	SHORT $LN11@Line
$LN13@Line:

; 259  : 	} else if ( y1 > 1.0f ) {

	movss	xmm0, DWORD PTR _y1$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN11@Line

; 260  : 		 x1 = x2 + (x1-x2)*( (y2-1.0f)/(y2-y1) );

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _y2$[ebp]
	subss	xmm2, DWORD PTR _y1$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 261  : 		 y1 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _y1$[ebp], xmm0

; 262  : 		 clipFlag |= CLIP_TOP;

	mov	ecx, DWORD PTR _clipFlag$[ebp]
	or	ecx, 4
	mov	DWORD PTR _clipFlag$[ebp], ecx
$LN11@Line:

; 263  : 	}
; 264  : 
; 265  : 	// Clip point 2
; 266  : 	if ( x2 < -1.0f ) {

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _x2$[ebp]
	jbe	SHORT $LN10@Line

; 267  : 		 y2 = y1 + (y2-y1)*( (x1+1.0f)/(x1-x2) );

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	xmm1, DWORD PTR _x1$[ebp]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _x1$[ebp]
	subss	xmm2, DWORD PTR _x2$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 268  : 		 x2 = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _x2$[ebp], xmm0

; 269  : 		 if (clipFlag & CLIP_LEFT)  return;

	mov	edx, DWORD PTR _clipFlag$[ebp]
	and	edx, 1
	je	SHORT $LN9@Line
	jmp	$LN17@Line
$LN9@Line:

; 270  : 	} else if ( x2 > 1.0f ) {

	jmp	SHORT $LN6@Line
$LN10@Line:
	movss	xmm0, DWORD PTR _x2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN6@Line

; 271  : 		 y2 = y1 + (y2-y1)*( (x1-1.0f)/(x1-x2) );

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	xmm1, DWORD PTR _x1$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _x1$[ebp]
	subss	xmm2, DWORD PTR _x2$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 272  : 		 x2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _x2$[ebp], xmm0

; 273  : 		 if (clipFlag & CLIP_RIGHT)  return;

	mov	eax, DWORD PTR _clipFlag$[ebp]
	and	eax, 2
	je	SHORT $LN6@Line
	jmp	$LN17@Line
$LN6@Line:

; 274  : 	}
; 275  : 	if ( y2 < -1.0f ) {

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _y2$[ebp]
	jbe	SHORT $LN5@Line

; 276  : 		 x2 = x1 + (x2-x1)*( (y1+1.0f)/(y1-y2) );

	movss	xmm0, DWORD PTR _x2$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _y1$[ebp]
	subss	xmm2, DWORD PTR _y2$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 277  : 		 y2 = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _y2$[ebp], xmm0

; 278  : 		 if (clipFlag & CLIP_BOTTOM)  return;

	mov	ecx, DWORD PTR _clipFlag$[ebp]
	and	ecx, 8
	je	SHORT $LN4@Line
	jmp	$LN17@Line
$LN4@Line:

; 279  : 	} else if ( y2 > 1.0f ) {

	jmp	SHORT $LN1@Line
$LN5@Line:
	movss	xmm0, DWORD PTR _y2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN1@Line

; 280  : 		 x2 = x1 + (x2-x1)*( (y1-1.0f)/(y1-y2) );

	movss	xmm0, DWORD PTR _x2$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR _y1$[ebp]
	subss	xmm2, DWORD PTR _y2$[ebp]
	divss	xmm1, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 281  : 		 y2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _y2$[ebp], xmm0

; 282  : 		 if (clipFlag & CLIP_TOP)  return;

	mov	edx, DWORD PTR _clipFlag$[ebp]
	and	edx, 4
	je	SHORT $LN1@Line
	jmp	SHORT $LN17@Line
$LN1@Line:

; 283  : 	}
; 284  : 
; 285  : 	Render2DLine( viewportXtoPixel(  x1 ),
; 286  : 		          viewportYtoPixel( -y1 ),
; 287  : 				  viewportXtoPixel(  x2 ),
; 288  : 				  viewportYtoPixel( -y2 ));

	movss	xmm0, DWORD PTR _y2$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	movss	xmm0, DWORD PTR _y1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
$LN17@Line:

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Line@VirtualDisplay@@UAEXMMMM@Z ENDP			; VirtualDisplay::Line
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
?Point@VirtualDisplay@@UAEXMM@Z PROC			; VirtualDisplay::Point
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 	float x, y;
; 211  : 
; 212  : 	// Rotation and translate this point based on the current settings
; 213  : 	x = x1 * dmatrix.rotation00 + y1 * dmatrix.rotation01 + dmatrix.translationX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+80]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _x$[ebp], xmm0

; 214  : 	y = x1 * dmatrix.rotation10 + y1 * dmatrix.rotation11 + dmatrix.translationY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR [ecx+88]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR _y$[ebp], xmm0

; 215  : 
; 216  : 	// Clipping
; 217  : 	if ((x >= -1.0f) && (x <= 1.0f) && (y <= 1.0f) && (y >= -1.0f)) {

	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jb	SHORT $LN1@Point
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _x$[ebp]
	jb	SHORT $LN1@Point
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _y$[ebp]
	jb	SHORT $LN1@Point
	movss	xmm0, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jb	SHORT $LN1@Point

; 218  : 
; 219  : 		// Convert to pixel coordinates and draw the point on the display
; 220  : 		Render2DPoint( viewportXtoPixel( x ), viewportYtoPixel( -y ) );

	movss	xmm0, DWORD PTR _y$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportYtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportYtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?viewportXtoPixel@VirtualDisplay@@QAEMM@Z ; VirtualDisplay::viewportXtoPixel
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	call	eax
$LN1@Point:

; 221  : 
; 222  : 	}
; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Point@VirtualDisplay@@UAEXMM@Z ENDP			; VirtualDisplay::Point
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cleanup@VirtualDisplay@@UAEXXZ PROC			; VirtualDisplay::Cleanup
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	ShiAssert( IsReady() );
; 83   : 	ready = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@VirtualDisplay@@UAEXXZ ENDP			; VirtualDisplay::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
tv150 = -24						; size = 8
_angle$ = -16						; size = 8
_entry$ = -8						; size = 4
_this$ = -4						; size = 4
?Setup@VirtualDisplay@@UAEXXZ PROC			; VirtualDisplay::Setup
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	ShiAssert( !IsReady() );
; 52   : 	
; 53   : 	// Setup the default viewport
; 54   : 	SetViewport( -1.0f, 1.0f, 1.0f, -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 55   : 
; 56   : 	// Setup the default offset and rotation
; 57   : 	CenterOriginInViewport();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport

; 58   : 	ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 59   : 
; 60   : 	// Initialize the unit circle array (in case someone else hasn't done it already)
; 61   : 	double	angle;
; 62   : 	int		entry;
; 63   : 	for (entry = 0; entry < CircleSegments; entry++) {

	mov	DWORD PTR _entry$[ebp], 0
	jmp	SHORT $LN3@Setup
$LN2@Setup:
	mov	ecx, DWORD PTR _entry$[ebp]
	add	ecx, 1
	mov	DWORD PTR _entry$[ebp], ecx
$LN3@Setup:
	cmp	DWORD PTR _entry$[ebp], 91		; 0000005bH
	jge	SHORT $LN1@Setup

; 64   :  		angle = (entry * CircleStep) * PI / 180.0f;

	mov	edx, DWORD PTR _entry$[ebp]
	shl	edx, 2
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@43340000
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _angle$[ebp], xmm0

; 65   : 
; 66   : 		CircleX[entry] =  (float)cos( angle );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _angle$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	mov	eax, DWORD PTR _entry$[ebp]
	fstp	DWORD PTR ?CircleX@@3PAMA[eax*4]

; 67   : 		CircleY[entry] = -(float)sin( angle );	// Account for the y axis flip

	sub	esp, 8
	movsd	xmm0, QWORD PTR _angle$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv150[ebp]
	movsd	xmm0, QWORD PTR tv150[ebp]
	cvtsd2ss xmm0, xmm0
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	DWORD PTR ?CircleY@@3PAMA[ecx*4], xmm0

; 68   : 	}

	jmp	$LN2@Setup
$LN1@Setup:

; 69   : 
; 70   :     type = DISPLAY_GENERAL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 71   : 
; 72   : 	ready = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 1

; 73   : 	ForceAlpha=false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+96], 0

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Setup@VirtualDisplay@@UAEXXZ ENDP			; VirtualDisplay::Setup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\display.cpp
_TEXT	SEGMENT
_c$ = -8						; size = 4
_r$ = -4						; size = 4
?InitializeFonts@VirtualDisplay@@SAXXZ PROC		; VirtualDisplay::InitializeFonts

; 1015 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1016 : 	int c, r;
; 1017 : 
; 1018 : 	for (c=0; c<VirtualDisplay::FontLength; c++) {

	mov	DWORD PTR _c$[ebp], 0
	jmp	SHORT $LN6@Initialize
$LN5@Initialize:
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _c$[ebp], eax
$LN6@Initialize:
	cmp	DWORD PTR _c$[ebp], 74			; 0000004aH
	jae	SHORT $LN7@Initialize

; 1019 : 		// Shift each row right one to make room for the edging
; 1020 : 		for (r=0; r<8; r++) {

	mov	DWORD PTR _r$[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	ecx, DWORD PTR _r$[ebp]
	add	ecx, 1
	mov	DWORD PTR _r$[ebp], ecx
$LN3@Initialize:
	cmp	DWORD PTR _r$[ebp], 8
	jge	SHORT $LN1@Initialize

; 1021 : 			InvFont[c][r] = (unsigned char)(~(Font[c][r] >> 1));

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR ?Font@VirtualDisplay@@1PAPBEA[edx*4]
	mov	ecx, DWORD PTR _r$[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	sar	edx, 1
	not	edx
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	BYTE PTR ?InvFont@VirtualDisplay@@1PAY07EA[eax+ecx*8], dl

; 1022 : 		}

	jmp	SHORT $LN2@Initialize
$LN1@Initialize:

; 1023 : 	}

	jmp	SHORT $LN5@Initialize
$LN7@Initialize:

; 1024 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitializeFonts@VirtualDisplay@@SAXXZ ENDP		; VirtualDisplay::InitializeFonts
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??1FontSet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FontSet@@QAE@XZ PROC					; FontSet::~FontSet, COMDAT
; _this$ = ecx

; 38   : 	~FontSet() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??1Texture@@QAE@XZ		; Texture::~Texture
	push	4
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	esp, ebp
	pop	ebp
	ret	0
??1FontSet@@QAE@XZ ENDP					; FontSet::~FontSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??0FontSet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FontSet@@QAE@XZ PROC					; FontSet::FontSet, COMDAT
; _this$ = ecx

; 37   : 	FontSet() { fontNum = 0; totalFont = 3; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??1Texture@@QAE@XZ		; Texture::~Texture
	push	OFFSET ??0Texture@@QAE@XZ		; Texture::Texture
	push	4
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24672], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24676], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FontSet@@QAE@XZ ENDP					; FontSet::FontSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\imagebuf.h
;	COMDAT ?targetYres@ImageBuffer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?targetYres@ImageBuffer@@QAEHXZ PROC			; ImageBuffer::targetYres, COMDAT
; _this$ = ecx

; 46   : 	int	targetYres()	{ return height; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]
	mov	esp, ebp
	pop	ebp
	ret	0
?targetYres@ImageBuffer@@QAEHXZ ENDP			; ImageBuffer::targetYres
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\imagebuf.h
;	COMDAT ?targetXres@ImageBuffer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?targetXres@ImageBuffer@@QAEHXZ PROC			; ImageBuffer::targetXres, COMDAT
; _this$ = ecx

; 45   : 	int targetXres()	{ return width; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]
	mov	esp, ebp
	pop	ebp
	ret	0
?targetXres@ImageBuffer@@QAEHXZ ENDP			; ImageBuffer::targetXres
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\imagebuf.h
;	COMDAT ?targetSurface@ImageBuffer@@QAEPAUIDirectDrawSurface7@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?targetSurface@ImageBuffer@@QAEPAUIDirectDrawSurface7@@XZ PROC ; ImageBuffer::targetSurface, COMDAT
; _this$ = ecx

; 42   : 	IDirectDrawSurface7 *targetSurface()	{ return m_pDDSBack; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+164]
	mov	esp, ebp
	pop	ebp
	ret	0
?targetSurface@ImageBuffer@@QAEPAUIDirectDrawSurface7@@XZ ENDP ; ImageBuffer::targetSurface
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GTextureHandle@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTextureHandle@@QAEPAXI@Z PROC			; TextureHandle::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureHandle@@QAE@XZ		; TextureHandle::~TextureHandle
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTextureHandle@@QAEPAXI@Z ENDP			; TextureHandle::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 521  :         {return (fmodf(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fmodf
	add	esp, 8
	pop	ebp
	ret	0
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv77 = -12						; size = 8
tv79 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 418  :         {return ((float)fmod((double)_X, (double)_Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv77[ebp]
	movsd	xmm0, QWORD PTR tv77[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
END
