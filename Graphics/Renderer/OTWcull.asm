; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\Graphics\Renderer\OTWcull.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
CONST	SEGMENT
_MAX_POSTIVE_F DD 04b9c66d1r			; 2.04999e+007
_MAX_NEGATIVE_F DD 0cb9c66d1r			; -2.04999e+007
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_cosf
PUBLIC	_floorf
PUBLIC	_sinf
PUBLIC	_tanf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?floor@@YAMM@Z					; floor
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?tan@@YAMM@Z					; tan
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetAvailablePostRange@TBlockList@@QAEHXZ	; TBlockList::GetAvailablePostRange
PUBLIC	?GetHighLOD@TViewPoint@@QAEHXZ			; TViewPoint::GetHighLOD
PUBLIC	?GetLowLOD@TViewPoint@@QAEHXZ			; TViewPoint::GetLowLOD
PUBLIC	?GetAvailablePostRange@TViewPoint@@QAEHH@Z	; TViewPoint::GetAvailablePostRange
PUBLIC	?X@TViewPoint@@QAEMXZ				; TViewPoint::X
PUBLIC	?Y@TViewPoint@@QAEMXZ				; TViewPoint::Y
PUBLIC	?GetTerrainFloor@RViewPoint@@QAEMXZ		; RViewPoint::GetTerrainFloor
PUBLIC	?GetTerrainCeiling@RViewPoint@@QAEMXZ		; RViewPoint::GetTerrainCeiling
PUBLIC	??0Edge@@QAE@XZ					; Edge::Edge
PUBLIC	??1Edge@@QAE@XZ					; Edge::~Edge
PUBLIC	?SetupWithPoints@Edge@@QAEXMMMM@Z		; Edge::SetupWithPoints
PUBLIC	?Normalize@Edge@@QAEXXZ				; Edge::Normalize
PUBLIC	?X@Edge@@QAEMM@Z				; Edge::X
PUBLIC	?Y@Edge@@QAEMM@Z				; Edge::Y
PUBLIC	?X@Render3D@@QAEMXZ				; Render3D::X
PUBLIC	?Y@Render3D@@QAEMXZ				; Render3D::Y
PUBLIC	?Z@Render3D@@QAEMXZ				; Render3D::Z
PUBLIC	?Yaw@Render3D@@QAEMXZ				; Render3D::Yaw
PUBLIC	?Pitch@Render3D@@QAEMXZ				; Render3D::Pitch
PUBLIC	?GetAt@Render3D@@QAEXPAUTpoint@@@Z		; Render3D::GetAt
PUBLIC	??0BoundSegment@@QAE@XZ				; BoundSegment::BoundSegment
PUBLIC	??1BoundSegment@@QAE@XZ				; BoundSegment::~BoundSegment
PUBLIC	?ComputeBounds@RenderOTW@@IAEXXZ		; RenderOTW::ComputeBounds
PUBLIC	?BuildRingList@RenderOTW@@IAEXXZ		; RenderOTW::BuildRingList
PUBLIC	?ClipHorizontalSectors@RenderOTW@@IAEXXZ	; RenderOTW::ClipHorizontalSectors
PUBLIC	?ClipVerticalSectors@RenderOTW@@IAEXXZ		; RenderOTW::ClipVerticalSectors
PUBLIC	?BuildCornerSet@RenderOTW@@IAEXXZ		; RenderOTW::BuildCornerSet
PUBLIC	?TrimCornerSet@RenderOTW@@IAEXXZ		; RenderOTW::TrimCornerSet
PUBLIC	?BuildVertexSet@RenderOTW@@IAEXXZ		; RenderOTW::BuildVertexSet
PUBLIC	?TransformVertexSet@RenderOTW@@IAEXXZ		; RenderOTW::TransformVertexSet
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@40490fdb
PUBLIC	__real@4096cbe4
PUBLIC	__real@bf800000
PUBLIC	__real@bfc90fdb
PUBLIC	__real@f149f2ca
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?TransformRun@RenderOTW@@IAEXHHHHH@Z:PROC	; RenderOTW::TransformRun
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?FeetPerPost@@3MA:DWORD				; FeetPerPost
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@f149f2ca
CONST	SEGMENT
__real@f149f2ca DD 0f149f2car			; -1e+030
CONST	ENDS
;	COMDAT __real@bfc90fdb
CONST	SEGMENT
__real@bfc90fdb DD 0bfc90fdbr			; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@4096cbe4
CONST	SEGMENT
__real@4096cbe4 DD 04096cbe4r			; 4.71239
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ClipVerticalSectors@RenderOTW@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ClipVerticalSectors@RenderOTW@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ClipVerticalSectors@RenderOTW@@IAEXXZ$1
__unwindtable$?ClipHorizontalSectors@RenderOTW@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ClipHorizontalSectors@RenderOTW@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ClipHorizontalSectors@RenderOTW@@IAEXXZ$1
__ehfuncinfo$?ClipVerticalSectors@RenderOTW@@IAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ClipVerticalSectors@RenderOTW@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ClipHorizontalSectors@RenderOTW@@IAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ClipHorizontalSectors@RenderOTW@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
_ring$ = -20						; size = 4
_LOD$ = -16						; size = 4
_this$ = -12						; size = 4
_span$ = -8						; size = 4
_sector$ = -4						; size = 4
?TransformVertexSet@RenderOTW@@IAEXXZ PROC		; RenderOTW::TransformVertexSet
; _this$ = ecx

; 1187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 	SpanListEntry	*span;
; 1189 : 	int				LOD;
; 1190 : 	int				ring;
; 1191 : 	SpanMinMax		*sector;
; 1192 : 
; 1193 : 	// Move from inner ring outward
; 1194 : 	for ( span = firstEmptySpan-1; span>=spanList; span-- ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	sub	ecx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN3@TransformV
$LN2@TransformV:
	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN3@TransformV:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263348]
	jb	$LN4@TransformV

; 1195 : 		LOD		= span->LOD;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _LOD$[ebp], eax

; 1196 : 		ring	= span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ring$[ebp], edx

; 1197 : 
; 1198 : 		// TOP_SPAN
; 1199 : 		sector	= &span->Tsector;

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 8
	mov	DWORD PTR _sector$[ebp], eax

; 1200 : 		TransformRun( ring,  sector->startXform, sector->stopXform - sector->startXform, LOD, TRUE );

	push	1
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sector$[ebp]
	mov	eax, DWORD PTR _sector$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	sub	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _sector$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ring$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TransformRun@RenderOTW@@IAEXHHHHH@Z	; RenderOTW::TransformRun

; 1201 : 
; 1202 : 		// RIGHT_SPAN
; 1203 : 		sector	= &span->Rsector;

	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR _sector$[ebp], edx

; 1204 : 		TransformRun( sector->startXform,  ring, sector->stopXform - sector->startXform, LOD, FALSE );

	push	0
	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sector$[ebp]
	mov	edx, DWORD PTR _sector$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ring$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sector$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TransformRun@RenderOTW@@IAEXHHHHH@Z	; RenderOTW::TransformRun

; 1205 : 
; 1206 : 		// BOTTOM_SPAN
; 1207 : 		sector	= &span->Bsector;

	mov	ecx, DWORD PTR _span$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR _sector$[ebp], ecx

; 1208 : 		TransformRun( -ring, sector->startXform, sector->stopXform - sector->startXform, LOD, TRUE );

	push	1
	mov	edx, DWORD PTR _LOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _sector$[ebp]
	mov	ecx, DWORD PTR _sector$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _sector$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ring$[ebp]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TransformRun@RenderOTW@@IAEXHHHHH@Z	; RenderOTW::TransformRun

; 1209 : 
; 1210 : 		// LEFT_SPAN
; 1211 : 		sector	= &span->Lsector;

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 92					; 0000005cH
	mov	DWORD PTR _sector$[ebp], eax

; 1212 : 		TransformRun( sector->startXform, -ring, sector->stopXform - sector->startXform, LOD, FALSE );

	push	0
	mov	ecx, DWORD PTR _LOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sector$[ebp]
	mov	eax, DWORD PTR _sector$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	sub	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ring$[ebp]
	neg	edx
	push	edx
	mov	eax, DWORD PTR _sector$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TransformRun@RenderOTW@@IAEXHHHHH@Z	; RenderOTW::TransformRun

; 1213 : 	}

	jmp	$LN2@TransformV
$LN4@TransformV:

; 1214 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TransformVertexSet@RenderOTW@@IAEXXZ ENDP		; RenderOTW::TransformVertexSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
tv876 = -220						; size = 4
tv339 = -216						; size = 4
tv859 = -212						; size = 4
tv477 = -208						; size = 4
tv844 = -204						; size = 4
tv214 = -200						; size = 4
tv830 = -196						; size = 4
tv409 = -192						; size = 4
tv818 = -188						; size = 4
tv275 = -184						; size = 4
tv801 = -180						; size = 4
tv162 = -176						; size = 4
tv786 = -172						; size = 4
tv136 = -168						; size = 4
tv772 = -164						; size = 4
tv379 = -160						; size = 4
tv754 = -156						; size = 4
tv307 = -152						; size = 4
tv737 = -148						; size = 4
tv243 = -144						; size = 4
tv722 = -140						; size = 4
tv188 = -136						; size = 4
tv708 = -132						; size = 4
tv494 = -128						; size = 4
tv696 = -124						; size = 4
tv461 = -120						; size = 4
tv679 = -116						; size = 4
tv426 = -112						; size = 4
tv664 = -108						; size = 4
tv393 = -104						; size = 4
tv650 = -100						; size = 4
tv356 = -96						; size = 4
tv632 = -92						; size = 4
tv324 = -88						; size = 4
tv615 = -84						; size = 4
tv292 = -80						; size = 4
tv599 = -76						; size = 4
tv260 = -72						; size = 4
tv585 = -68						; size = 4
tv228 = -64						; size = 4
tv563 = -60						; size = 4
tv202 = -56						; size = 4
tv546 = -52						; size = 4
tv176 = -48						; size = 4
tv530 = -44						; size = 4
tv150 = -40						; size = 4
tv516 = -36						; size = 4
tv447 = -32						; size = 4
_LOD$ = -28						; size = 4
_this$ = -24						; size = 4
_lowPos$ = -20						; size = 4
_controlSpan$ = -16					; size = 4
_outterSpan$ = -12					; size = 4
_innerSpan$ = -8					; size = 4
_span$ = -4						; size = 4
?BuildVertexSet@RenderOTW@@IAEXXZ PROC			; RenderOTW::BuildVertexSet
; _this$ = ecx

; 1009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 	SpanListEntry	*span;
; 1011 : 	SpanListEntry	*innerSpan;
; 1012 : 	SpanListEntry	*outterSpan;
; 1013 : 	SpanListEntry	*controlSpan;
; 1014 : 	int				LOD;
; 1015 : 	int				lowPos;
; 1016 : 
; 1017 : 
; 1018 : 	// First clear the list of spans to be transformed
; 1019 : 	for ( span = spanList; span<firstEmptySpan; span++ ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263348]
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN20@BuildVerte
$LN19@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN20@BuildVerte:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263352]
	jae	SHORT $LN18@BuildVerte

; 1020 : 		span->Tsector.startXform = MAX_POSITIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+28], 25000		; 000061a8H

; 1021 : 		span->Tsector.stopXform  = MAX_NEGATIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+32], -25000		; ffff9e58H

; 1022 : 		span->Rsector.startXform = MAX_POSITIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+56], 25000		; 000061a8H

; 1023 : 		span->Rsector.stopXform  = MAX_NEGATIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+60], -25000		; ffff9e58H

; 1024 : 		span->Bsector.startXform = MAX_POSITIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+84], 25000		; 000061a8H

; 1025 : 		span->Bsector.stopXform  = MAX_NEGATIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+88], -25000		; ffff9e58H

; 1026 : 		span->Lsector.startXform = MAX_POSITIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+112], 25000		; 000061a8H

; 1027 : 		span->Lsector.stopXform  = MAX_NEGATIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+116], -25000		; ffff9e58H

; 1028 : 	}

	jmp	SHORT $LN19@BuildVerte
$LN18@BuildVerte:

; 1029 : 
; 1030 : 
; 1031 : 	// Move from outter ring inward (same traversal as the drawing loop will use)
; 1032 : 	for ( span = spanList+1; span<firstEmptySpan; span++ ) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263348]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
	jmp	SHORT $LN17@BuildVerte
$LN16@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], eax
$LN17@BuildVerte:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [ecx+263352]
	jae	$LN21@BuildVerte

; 1033 : 
; 1034 : 		if ( span->LOD == (span+1)->LOD ) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+124]
	jne	$LN14@BuildVerte

; 1035 : 
; 1036 : 			// We will call DrawTerrainRing on this span
; 1037 : 			span->Tsector.startXform = min( span->Tsector.startDraw,  span->Tsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN23@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv136[ebp], ecx
	jmp	SHORT $LN24@BuildVerte
$LN23@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv136[ebp], eax
$LN24@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1038 : 			span->Tsector.stopXform  = max( span->Tsector.stopDraw+1, span->Tsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+32]
	jle	SHORT $LN25@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	DWORD PTR tv150[ebp], ecx
	jmp	SHORT $LN26@BuildVerte
$LN25@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR tv150[ebp], eax
$LN26@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv150[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1039 : 			span->Rsector.startXform = min( span->Rsector.startDraw,  span->Rsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+48]
	cmp	edx, DWORD PTR [ecx+56]
	jge	SHORT $LN27@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR tv162[ebp], ecx
	jmp	SHORT $LN28@BuildVerte
$LN27@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR tv162[ebp], eax
$LN28@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR [ecx+56], edx

; 1040 : 			span->Rsector.stopXform  = max( span->Rsector.stopDraw+1, span->Rsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+60]
	jle	SHORT $LN29@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	DWORD PTR tv176[ebp], ecx
	jmp	SHORT $LN30@BuildVerte
$LN29@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR tv176[ebp], eax
$LN30@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR [ecx+60], edx

; 1041 : 			span->Bsector.startXform = min( span->Bsector.startDraw,  span->Bsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+84]
	jge	SHORT $LN31@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv188[ebp], ecx
	jmp	SHORT $LN32@BuildVerte
$LN31@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR tv188[ebp], eax
$LN32@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR [ecx+84], edx

; 1042 : 			span->Bsector.stopXform  = max( span->Bsector.stopDraw+1, span->Bsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+88]
	jle	SHORT $LN33@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	DWORD PTR tv202[ebp], ecx
	jmp	SHORT $LN34@BuildVerte
$LN33@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR tv202[ebp], eax
$LN34@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv202[ebp]
	mov	DWORD PTR [ecx+88], edx

; 1043 : 			span->Lsector.startXform = min( span->Lsector.startDraw,  span->Lsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+104]
	cmp	edx, DWORD PTR [ecx+112]
	jge	SHORT $LN35@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR tv214[ebp], ecx
	jmp	SHORT $LN36@BuildVerte
$LN35@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR tv214[ebp], eax
$LN36@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR [ecx+112], edx

; 1044 : 			span->Lsector.stopXform  = max( span->Lsector.stopDraw+1, span->Lsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+116]
	jle	SHORT $LN37@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 1
	mov	DWORD PTR tv228[ebp], ecx
	jmp	SHORT $LN38@BuildVerte
$LN37@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR tv228[ebp], eax
$LN38@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv228[ebp]
	mov	DWORD PTR [ecx+116], edx

; 1045 : 
; 1046 : 			(span-1)->Tsector.startXform = min( span->Tsector.startDraw,  (span-1)->Tsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx-92]
	jge	SHORT $LN39@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv243[ebp], ecx
	jmp	SHORT $LN40@BuildVerte
$LN39@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx-92]
	mov	DWORD PTR tv243[ebp], eax
$LN40@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv243[ebp]
	mov	DWORD PTR [ecx-92], edx

; 1047 : 			(span-1)->Tsector.stopXform  = max( span->Tsector.stopDraw+1, (span-1)->Tsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx-88]
	jle	SHORT $LN41@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	DWORD PTR tv260[ebp], ecx
	jmp	SHORT $LN42@BuildVerte
$LN41@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx-88]
	mov	DWORD PTR tv260[ebp], eax
$LN42@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv260[ebp]
	mov	DWORD PTR [ecx-88], edx

; 1048 : 			(span-1)->Rsector.startXform = min( span->Rsector.startDraw,  (span-1)->Rsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+48]
	cmp	edx, DWORD PTR [ecx-64]
	jge	SHORT $LN43@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR tv275[ebp], ecx
	jmp	SHORT $LN44@BuildVerte
$LN43@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx-64]
	mov	DWORD PTR tv275[ebp], eax
$LN44@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv275[ebp]
	mov	DWORD PTR [ecx-64], edx

; 1049 : 			(span-1)->Rsector.stopXform  = max( span->Rsector.stopDraw+1, (span-1)->Rsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx-60]
	jle	SHORT $LN45@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	DWORD PTR tv292[ebp], ecx
	jmp	SHORT $LN46@BuildVerte
$LN45@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx-60]
	mov	DWORD PTR tv292[ebp], eax
$LN46@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv292[ebp]
	mov	DWORD PTR [ecx-60], edx

; 1050 : 			(span+1)->Bsector.startXform = min( span->Bsector.startDraw,  (span+1)->Bsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $LN47@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv307[ebp], ecx
	jmp	SHORT $LN48@BuildVerte
$LN47@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv307[ebp], eax
$LN48@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv307[ebp]
	mov	DWORD PTR [ecx+204], edx

; 1051 : 			(span+1)->Bsector.stopXform  = max( span->Bsector.stopDraw+1, (span+1)->Bsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+208]
	jle	SHORT $LN49@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	DWORD PTR tv324[ebp], ecx
	jmp	SHORT $LN50@BuildVerte
$LN49@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR tv324[ebp], eax
$LN50@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv324[ebp]
	mov	DWORD PTR [ecx+208], edx

; 1052 : 			(span+1)->Lsector.startXform = min( span->Lsector.startDraw,  (span+1)->Lsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+104]
	cmp	edx, DWORD PTR [ecx+232]
	jge	SHORT $LN51@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR tv339[ebp], ecx
	jmp	SHORT $LN52@BuildVerte
$LN51@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR tv339[ebp], eax
$LN52@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv339[ebp]
	mov	DWORD PTR [ecx+232], edx

; 1053 : 			(span+1)->Lsector.stopXform  = max( span->Lsector.stopDraw+1, (span+1)->Lsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+236]
	jle	SHORT $LN53@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 1
	mov	DWORD PTR tv356[ebp], ecx
	jmp	SHORT $LN54@BuildVerte
$LN53@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+236]
	mov	DWORD PTR tv356[ebp], eax
$LN54@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv356[ebp]
	mov	DWORD PTR [ecx+236], edx

; 1054 : 
; 1055 : 		} else {

	jmp	$LN13@BuildVerte
$LN14@BuildVerte:

; 1056 : 
; 1057 : 			// Skip the inner transform ring (last ring at lower detail level)
; 1058 : 			span++;

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], eax

; 1059 : 
; 1060 : 			LOD = span->LOD;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _LOD$[ebp], edx

; 1061 : 
; 1062 : 			// We'll call draw ConnectorRing on this span (outter xform)
; 1063 : 			// TOP
; 1064 : 			if ( LODdata[LOD].glueOnBottom ) {

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	cmp	DWORD PTR [edx+eax+48], 0
	je	SHORT $LN12@BuildVerte

; 1065 : 				innerSpan  = span+1;		// "glue control"

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _innerSpan$[ebp], eax

; 1066 : 				controlSpan= span+1;		// "glue control"

	mov	ecx, DWORD PTR _span$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR _controlSpan$[ebp], ecx

; 1067 : 				outterSpan = span-2;		// "last drawn"

	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 240				; 000000f0H
	mov	DWORD PTR _outterSpan$[ebp], edx

; 1068 : 			} else {

	jmp	SHORT $LN11@BuildVerte
$LN12@BuildVerte:

; 1069 : 				innerSpan  = span;			// "outter xform"

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR _innerSpan$[ebp], eax

; 1070 : 				controlSpan= span;			// "outter xform"

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR _controlSpan$[ebp], ecx

; 1071 : 				outterSpan = span-2;		// "last drawn"

	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 240				; 000000f0H
	mov	DWORD PTR _outterSpan$[ebp], edx
$LN11@BuildVerte:

; 1072 : 			}
; 1073 : 			innerSpan->Tsector.startXform  = min( controlSpan->Tsector.startDraw,		innerSpan->Tsector.startXform );

	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN55@BuildVerte
	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv379[ebp], ecx
	jmp	SHORT $LN56@BuildVerte
$LN55@BuildVerte:
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv379[ebp], eax
$LN56@BuildVerte:
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR tv379[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1074 : 			innerSpan->Tsector.stopXform   = max( controlSpan->Tsector.stopDraw+2,		innerSpan->Tsector.stopXform  );

	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 2
	mov	edx, DWORD PTR _innerSpan$[ebp]
	cmp	ecx, DWORD PTR [edx+32]
	jle	SHORT $LN57@BuildVerte
	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 2
	mov	DWORD PTR tv393[ebp], ecx
	jmp	SHORT $LN58@BuildVerte
$LN57@BuildVerte:
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR tv393[ebp], eax
$LN58@BuildVerte:
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR tv393[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1075 : 			lowPos = (controlSpan->Tsector.startDraw  + LODdata[LOD].glueOnLeft)	>> 1;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, DWORD PTR [edx+eax+52]
	sar	ecx, 1
	mov	DWORD PTR _lowPos$[ebp], ecx

; 1076 : 			outterSpan->Tsector.startXform = min( lowPos, outterSpan->Tsector.startXform );

	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR _lowPos$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN59@BuildVerte
	mov	ecx, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv409[ebp], ecx
	jmp	SHORT $LN60@BuildVerte
$LN59@BuildVerte:
	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv409[ebp], eax
$LN60@BuildVerte:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR tv409[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1077 : 			lowPos = (controlSpan->Tsector.stopDraw+2 + LODdata[LOD].glueOnLeft)	>> 1;

	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [eax+edx+52]
	lea	eax, DWORD PTR [ecx+edx+2]
	sar	eax, 1
	mov	DWORD PTR _lowPos$[ebp], eax

; 1078 : 			outterSpan->Tsector.stopXform  = max( lowPos, outterSpan->Tsector.stopXform  );

	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR _lowPos$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jle	SHORT $LN61@BuildVerte
	mov	eax, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv426[ebp], eax
	jmp	SHORT $LN62@BuildVerte
$LN61@BuildVerte:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv426[ebp], edx
$LN62@BuildVerte:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR tv426[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1079 : 
; 1080 : 			// RIGHT
; 1081 : 			if ( LODdata[LOD].glueOnLeft ) {

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+52], 0
	je	SHORT $LN10@BuildVerte

; 1082 : 				innerSpan  = span+1;		// "glue control"

	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _innerSpan$[ebp], edx

; 1083 : 				controlSpan= span+1;		// "glue control"

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _controlSpan$[ebp], eax

; 1084 : 				outterSpan = span-2;		// "last drawn"

	mov	ecx, DWORD PTR _span$[ebp]
	sub	ecx, 240				; 000000f0H
	mov	DWORD PTR _outterSpan$[ebp], ecx

; 1085 : 			} else {

	jmp	SHORT $LN9@BuildVerte
$LN10@BuildVerte:

; 1086 : 				innerSpan  = span;			// "outter xform"

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR _innerSpan$[ebp], edx

; 1087 : 				controlSpan= span;			// "outter xform"

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR _controlSpan$[ebp], eax

; 1088 : 				outterSpan = span-2;		// "last drawn"

	mov	ecx, DWORD PTR _span$[ebp]
	sub	ecx, 240				; 000000f0H
	mov	DWORD PTR _outterSpan$[ebp], ecx
$LN9@BuildVerte:

; 1089 : 			}
; 1090 : 			innerSpan->Rsector.startXform  = min( innerSpan->Rsector.startDraw,			innerSpan->Rsector.startXform );

	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR _innerSpan$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $LN63@BuildVerte
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv447[ebp], eax
	jmp	SHORT $LN64@BuildVerte
$LN63@BuildVerte:
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR tv447[ebp], edx
$LN64@BuildVerte:
	mov	eax, DWORD PTR _innerSpan$[ebp]
	mov	ecx, DWORD PTR tv447[ebp]
	mov	DWORD PTR [eax+56], ecx

; 1091 : 			innerSpan->Rsector.stopXform   = max( innerSpan->Rsector.stopDraw+2,		innerSpan->Rsector.stopXform  );

	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+52]
	add	eax, 2
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	cmp	eax, DWORD PTR [ecx+60]
	jle	SHORT $LN65@BuildVerte
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+52]
	add	eax, 2
	mov	DWORD PTR tv461[ebp], eax
	jmp	SHORT $LN66@BuildVerte
$LN65@BuildVerte:
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR tv461[ebp], edx
$LN66@BuildVerte:
	mov	eax, DWORD PTR _innerSpan$[ebp]
	mov	ecx, DWORD PTR tv461[ebp]
	mov	DWORD PTR [eax+60], ecx

; 1092 : 			lowPos = (innerSpan->Rsector.startDraw  + LODdata[LOD].glueOnBottom)	>> 1;

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [eax+48]
	add	eax, DWORD PTR [ecx+edx+48]
	sar	eax, 1
	mov	DWORD PTR _lowPos$[ebp], eax

; 1093 : 			outterSpan->Rsector.startXform = min( lowPos, outterSpan->Rsector.startXform );

	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR _lowPos$[ebp]
	cmp	edx, DWORD PTR [ecx+56]
	jge	SHORT $LN67@BuildVerte
	mov	eax, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv477[ebp], eax
	jmp	SHORT $LN68@BuildVerte
$LN67@BuildVerte:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR tv477[ebp], edx
$LN68@BuildVerte:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR tv477[ebp]
	mov	DWORD PTR [eax+56], ecx

; 1094 : 			lowPos = (innerSpan->Rsector.stopDraw+2 + LODdata[LOD].glueOnBottom)	>> 1;

	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	mov	ecx, DWORD PTR [edx+ecx+48]
	lea	edx, DWORD PTR [eax+ecx+2]
	sar	edx, 1
	mov	DWORD PTR _lowPos$[ebp], edx

; 1095 : 			outterSpan->Rsector.stopXform  = max( lowPos, outterSpan->Rsector.stopXform  );

	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR _lowPos$[ebp]
	cmp	ecx, DWORD PTR [eax+60]
	jle	SHORT $LN69@BuildVerte
	mov	edx, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv494[ebp], edx
	jmp	SHORT $LN70@BuildVerte
$LN69@BuildVerte:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR tv494[ebp], ecx
$LN70@BuildVerte:
	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR tv494[ebp]
	mov	DWORD PTR [edx+60], eax

; 1096 : 
; 1097 : 			// BOTTOM
; 1098 : 			if ( LODdata[LOD].glueOnBottom ) {

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	cmp	DWORD PTR [eax+ecx+48], 0
	je	SHORT $LN8@BuildVerte

; 1099 : 				innerSpan  = span+1;		// "glue control"

	mov	ecx, DWORD PTR _span$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR _innerSpan$[ebp], ecx

; 1100 : 				controlSpan= span;			// "outter xform"

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR _controlSpan$[ebp], edx

; 1101 : 				outterSpan = span-1;		// "inner xform"

	mov	eax, DWORD PTR _span$[ebp]
	sub	eax, 120				; 00000078H
	mov	DWORD PTR _outterSpan$[ebp], eax

; 1102 : 			} else {

	jmp	SHORT $LN7@BuildVerte
$LN8@BuildVerte:

; 1103 : 				innerSpan  = span+2;		// "first normal draw"

	mov	ecx, DWORD PTR _span$[ebp]
	add	ecx, 240				; 000000f0H
	mov	DWORD PTR _innerSpan$[ebp], ecx

; 1104 : 				controlSpan= span+1;		// "glue control"

	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _controlSpan$[ebp], edx

; 1105 : 				outterSpan = span-1;		// "inner xform"

	mov	eax, DWORD PTR _span$[ebp]
	sub	eax, 120				; 00000078H
	mov	DWORD PTR _outterSpan$[ebp], eax
$LN7@BuildVerte:

; 1106 : 			}
; 1107 : 			innerSpan->Bsector.startXform  = min( controlSpan->Bsector.startDraw,		innerSpan->Bsector.startXform );

	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [ecx+76]
	cmp	eax, DWORD PTR [edx+84]
	jge	SHORT $LN71@BuildVerte
	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR tv516[ebp], edx
	jmp	SHORT $LN72@BuildVerte
$LN71@BuildVerte:
	mov	eax, DWORD PTR _innerSpan$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR tv516[ebp], ecx
$LN72@BuildVerte:
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR tv516[ebp]
	mov	DWORD PTR [edx+84], eax

; 1108 : 			innerSpan->Bsector.stopXform   = max( controlSpan->Bsector.stopDraw+2,		innerSpan->Bsector.stopXform  );

	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	add	edx, 2
	mov	eax, DWORD PTR _innerSpan$[ebp]
	cmp	edx, DWORD PTR [eax+88]
	jle	SHORT $LN73@BuildVerte
	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	add	edx, 2
	mov	DWORD PTR tv530[ebp], edx
	jmp	SHORT $LN74@BuildVerte
$LN73@BuildVerte:
	mov	eax, DWORD PTR _innerSpan$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR tv530[ebp], ecx
$LN74@BuildVerte:
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR tv530[ebp]
	mov	DWORD PTR [edx+88], eax

; 1109 : 			lowPos = (controlSpan->Bsector.startDraw  + LODdata[LOD].glueOnLeft)	>> 1;

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR _controlSpan$[ebp]
	mov	edx, DWORD PTR [edx+76]
	add	edx, DWORD PTR [eax+ecx+52]
	sar	edx, 1
	mov	DWORD PTR _lowPos$[ebp], edx

; 1110 : 			outterSpan->Bsector.startXform = min( lowPos, outterSpan->Bsector.startXform );

	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR _lowPos$[ebp]
	cmp	ecx, DWORD PTR [eax+84]
	jge	SHORT $LN75@BuildVerte
	mov	edx, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv546[ebp], edx
	jmp	SHORT $LN76@BuildVerte
$LN75@BuildVerte:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR tv546[ebp], ecx
$LN76@BuildVerte:
	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR tv546[ebp]
	mov	DWORD PTR [edx+84], eax

; 1111 : 			lowPos = (controlSpan->Bsector.stopDraw+2 + LODdata[LOD].glueOnLeft)	>> 1;

	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [ecx+eax+52]
	lea	ecx, DWORD PTR [edx+eax+2]
	sar	ecx, 1
	mov	DWORD PTR _lowPos$[ebp], ecx

; 1112 : 			outterSpan->Bsector.stopXform  = max( lowPos, outterSpan->Bsector.stopXform  );

	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR _lowPos$[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jle	SHORT $LN77@BuildVerte
	mov	ecx, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv563[ebp], ecx
	jmp	SHORT $LN78@BuildVerte
$LN77@BuildVerte:
	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR tv563[ebp], eax
$LN78@BuildVerte:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR tv563[ebp]
	mov	DWORD PTR [ecx+88], edx

; 1113 : 
; 1114 : 			// LEFT
; 1115 : 			if ( LODdata[LOD].glueOnLeft ) {

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	cmp	DWORD PTR [edx+eax+52], 0
	je	SHORT $LN6@BuildVerte

; 1116 : 				innerSpan  = span+1;		// "glue control"

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _innerSpan$[ebp], eax

; 1117 : 				controlSpan= span;			// "outter xform"

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR _controlSpan$[ebp], ecx

; 1118 : 				outterSpan = span-1;		// "inner xform"

	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _outterSpan$[ebp], edx

; 1119 : 			} else {

	jmp	SHORT $LN5@BuildVerte
$LN6@BuildVerte:

; 1120 : 				innerSpan  = span+2;		// "first normal draw"

	mov	eax, DWORD PTR _span$[ebp]
	add	eax, 240				; 000000f0H
	mov	DWORD PTR _innerSpan$[ebp], eax

; 1121 : 				controlSpan= span+1;		// "glue control"

	mov	ecx, DWORD PTR _span$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR _controlSpan$[ebp], ecx

; 1122 : 				outterSpan = span-1;		// "inner xform"

	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _outterSpan$[ebp], edx
$LN5@BuildVerte:

; 1123 : 			}
; 1124 : 			innerSpan->Lsector.startXform  = min( controlSpan->Lsector.startDraw,		innerSpan->Lsector.startXform );

	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR [eax+104]
	cmp	edx, DWORD PTR [ecx+112]
	jge	SHORT $LN79@BuildVerte
	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR tv585[ebp], ecx
	jmp	SHORT $LN80@BuildVerte
$LN79@BuildVerte:
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR tv585[ebp], eax
$LN80@BuildVerte:
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR tv585[ebp]
	mov	DWORD PTR [ecx+112], edx

; 1125 : 			innerSpan->Lsector.stopXform   = max( controlSpan->Lsector.stopDraw+2,		innerSpan->Lsector.stopXform  );

	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 2
	mov	edx, DWORD PTR _innerSpan$[ebp]
	cmp	ecx, DWORD PTR [edx+116]
	jle	SHORT $LN81@BuildVerte
	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 2
	mov	DWORD PTR tv599[ebp], ecx
	jmp	SHORT $LN82@BuildVerte
$LN81@BuildVerte:
	mov	edx, DWORD PTR _innerSpan$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR tv599[ebp], eax
$LN82@BuildVerte:
	mov	ecx, DWORD PTR _innerSpan$[ebp]
	mov	edx, DWORD PTR tv599[ebp]
	mov	DWORD PTR [ecx+116], edx

; 1126 : 			lowPos = (controlSpan->Lsector.startDraw  + LODdata[LOD].glueOnBottom)	>> 1;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	ecx, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [ecx+104]
	add	ecx, DWORD PTR [edx+eax+48]
	sar	ecx, 1
	mov	DWORD PTR _lowPos$[ebp], ecx

; 1127 : 			outterSpan->Lsector.startXform = min( lowPos, outterSpan->Lsector.startXform );

	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR _lowPos$[ebp]
	cmp	eax, DWORD PTR [edx+112]
	jge	SHORT $LN83@BuildVerte
	mov	ecx, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv615[ebp], ecx
	jmp	SHORT $LN84@BuildVerte
$LN83@BuildVerte:
	mov	edx, DWORD PTR _outterSpan$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR tv615[ebp], eax
$LN84@BuildVerte:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR tv615[ebp]
	mov	DWORD PTR [ecx+112], edx

; 1128 : 			lowPos = (controlSpan->Lsector.stopDraw+2 + LODdata[LOD].glueOnBottom)	>> 1;

	mov	eax, DWORD PTR _controlSpan$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [eax+edx+48]
	lea	eax, DWORD PTR [ecx+edx+2]
	sar	eax, 1
	mov	DWORD PTR _lowPos$[ebp], eax

; 1129 : 			outterSpan->Lsector.stopXform  = max( lowPos, outterSpan->Lsector.stopXform  );

	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR _lowPos$[ebp]
	cmp	edx, DWORD PTR [ecx+116]
	jle	SHORT $LN85@BuildVerte
	mov	eax, DWORD PTR _lowPos$[ebp]
	mov	DWORD PTR tv632[ebp], eax
	jmp	SHORT $LN86@BuildVerte
$LN85@BuildVerte:
	mov	ecx, DWORD PTR _outterSpan$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR tv632[ebp], edx
$LN86@BuildVerte:
	mov	eax, DWORD PTR _outterSpan$[ebp]
	mov	ecx, DWORD PTR tv632[ebp]
	mov	DWORD PTR [eax+116], ecx

; 1130 : 
; 1131 : 			span++;

	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx

; 1132 : 
; 1133 : 			// We'll call draw gap filler on this span
; 1134 : 			if ( LODdata[LOD].glueOnBottom ) {

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	cmp	DWORD PTR [edx+eax+48], 0
	je	$LN4@BuildVerte

; 1135 : 				span->Bsector.startXform = min( span->Bsector.startDraw,			span->Bsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+84]
	jge	SHORT $LN87@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv650[ebp], ecx
	jmp	SHORT $LN88@BuildVerte
$LN87@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR tv650[ebp], eax
$LN88@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv650[ebp]
	mov	DWORD PTR [ecx+84], edx

; 1136 : 				span->Bsector.stopXform  = max( span->Bsector.stopDraw+1,			span->Bsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+88]
	jle	SHORT $LN89@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	DWORD PTR tv664[ebp], ecx
	jmp	SHORT $LN90@BuildVerte
$LN89@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR tv664[ebp], eax
$LN90@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv664[ebp]
	mov	DWORD PTR [ecx+88], edx

; 1137 : 				(span+1)->Bsector.startXform = min( span->Bsector.startDraw,	(span+1)->Bsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+76]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $LN91@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR tv679[ebp], ecx
	jmp	SHORT $LN92@BuildVerte
$LN91@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv679[ebp], eax
$LN92@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv679[ebp]
	mov	DWORD PTR [ecx+204], edx

; 1138 : 				(span+1)->Bsector.stopXform  = max( span->Bsector.stopDraw+1,	(span+1)->Bsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+208]
	jle	SHORT $LN93@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	DWORD PTR tv696[ebp], ecx
	jmp	SHORT $LN94@BuildVerte
$LN93@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR tv696[ebp], eax
$LN94@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv696[ebp]
	mov	DWORD PTR [ecx+208], edx

; 1139 : 			} else {

	jmp	$LN3@BuildVerte
$LN4@BuildVerte:

; 1140 : 				span->Tsector.startXform = min( span->Tsector.startDraw,			span->Tsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN95@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv708[ebp], ecx
	jmp	SHORT $LN96@BuildVerte
$LN95@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv708[ebp], eax
$LN96@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv708[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1141 : 				span->Tsector.stopXform  = max( span->Tsector.stopDraw+1,			span->Tsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx+32]
	jle	SHORT $LN97@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	DWORD PTR tv722[ebp], ecx
	jmp	SHORT $LN98@BuildVerte
$LN97@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR tv722[ebp], eax
$LN98@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv722[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1142 : 				(span-1)->Tsector.startXform = min( span->Tsector.startDraw,	(span-1)->Tsector.startXform );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx-92]
	jge	SHORT $LN99@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv737[ebp], ecx
	jmp	SHORT $LN100@BuildVerte
$LN99@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx-92]
	mov	DWORD PTR tv737[ebp], eax
$LN100@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv737[ebp]
	mov	DWORD PTR [ecx-92], edx

; 1143 : 				(span-1)->Tsector.stopXform  = max( span->Tsector.stopDraw+1,	(span-1)->Tsector.stopXform  );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [edx-88]
	jle	SHORT $LN101@BuildVerte
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	DWORD PTR tv754[ebp], ecx
	jmp	SHORT $LN102@BuildVerte
$LN101@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx-88]
	mov	DWORD PTR tv754[ebp], eax
$LN102@BuildVerte:
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR tv754[ebp]
	mov	DWORD PTR [ecx-88], edx
$LN3@BuildVerte:

; 1144 : 			}
; 1145 : 			if ( LODdata[span->LOD].glueOnLeft ) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	cmp	DWORD PTR [eax+ecx+52], 0
	je	$LN2@BuildVerte

; 1146 : 				span->Lsector.startXform = min( span->Lsector.startDraw,			span->Lsector.startXform );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, DWORD PTR [edx+112]
	jge	SHORT $LN103@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR tv772[ebp], edx
	jmp	SHORT $LN104@BuildVerte
$LN103@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR tv772[ebp], ecx
$LN104@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv772[ebp]
	mov	DWORD PTR [edx+112], eax

; 1147 : 				span->Lsector.stopXform  = max( span->Lsector.stopDraw+1,			span->Lsector.stopXform  );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [eax+116]
	jle	SHORT $LN105@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	add	edx, 1
	mov	DWORD PTR tv786[ebp], edx
	jmp	SHORT $LN106@BuildVerte
$LN105@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv786[ebp], ecx
$LN106@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv786[ebp]
	mov	DWORD PTR [edx+116], eax

; 1148 : 				(span+1)->Lsector.startXform = min( span->Lsector.startDraw,	(span+1)->Lsector.startXform );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, DWORD PTR [edx+232]
	jge	SHORT $LN107@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR tv801[ebp], edx
	jmp	SHORT $LN108@BuildVerte
$LN107@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	mov	DWORD PTR tv801[ebp], ecx
$LN108@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv801[ebp]
	mov	DWORD PTR [edx+232], eax

; 1149 : 				(span+1)->Lsector.stopXform  = max( span->Lsector.stopDraw+1,	(span+1)->Lsector.stopXform  );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [eax+236]
	jle	SHORT $LN109@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	add	edx, 1
	mov	DWORD PTR tv818[ebp], edx
	jmp	SHORT $LN110@BuildVerte
$LN109@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	DWORD PTR tv818[ebp], ecx
$LN110@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv818[ebp]
	mov	DWORD PTR [edx+236], eax

; 1150 : 			} else {

	jmp	$LN13@BuildVerte
$LN2@BuildVerte:

; 1151 : 				span->Rsector.startXform = min( span->Rsector.startDraw,			span->Rsector.startXform );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, DWORD PTR [edx+56]
	jge	SHORT $LN111@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR tv830[ebp], edx
	jmp	SHORT $LN112@BuildVerte
$LN111@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv830[ebp], ecx
$LN112@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv830[ebp]
	mov	DWORD PTR [edx+56], eax

; 1152 : 				span->Rsector.stopXform  = max( span->Rsector.stopDraw+1,			span->Rsector.stopXform  );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [eax+60]
	jle	SHORT $LN113@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 1
	mov	DWORD PTR tv844[ebp], edx
	jmp	SHORT $LN114@BuildVerte
$LN113@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR tv844[ebp], ecx
$LN114@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv844[ebp]
	mov	DWORD PTR [edx+60], eax

; 1153 : 				(span-1)->Rsector.startXform = min( span->Rsector.startDraw,	(span-1)->Rsector.startXform );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, DWORD PTR [edx-64]
	jge	SHORT $LN115@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR tv859[ebp], edx
	jmp	SHORT $LN116@BuildVerte
$LN115@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax-64]
	mov	DWORD PTR tv859[ebp], ecx
$LN116@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv859[ebp]
	mov	DWORD PTR [edx-64], eax

; 1154 : 				(span-1)->Rsector.stopXform  = max( span->Rsector.stopDraw+1,	(span-1)->Rsector.stopXform  );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [eax-60]
	jle	SHORT $LN117@BuildVerte
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 1
	mov	DWORD PTR tv876[ebp], edx
	jmp	SHORT $LN118@BuildVerte
$LN117@BuildVerte:
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax-60]
	mov	DWORD PTR tv876[ebp], ecx
$LN118@BuildVerte:
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR tv876[ebp]
	mov	DWORD PTR [edx-60], eax
$LN13@BuildVerte:

; 1155 : 			}
; 1156 : 		}
; 1157 : 	}

	jmp	$LN16@BuildVerte
$LN21@BuildVerte:

; 1158 : 
; 1159 : 
; 1160 : #if 0
; 1161 : 	// Try to eliminate overlapping vertex entries in adjacent rows and columns
; 1162 : 	// Move from outter ring inward
; 1163 : 	// TODO:  Fix this -- it occasionally removes verticies we actually need for connector rings
; 1164 : 	// Because construction in vertical can require verts in the horizontal (and vis-versa),
; 1165 : 	// we'd have to find the associated span and add in the verticies we want to avoid doing
; 1166 : 	// ourselves -- probably not worth the trouble.
; 1167 : 	for ( span = spanList; span<firstEmptySpan; span++ ) {
; 1168 : 		span->Tsector.startXform = max( -span->ring-1, span->Tsector.startXform );
; 1169 : 		span->Tsector.stopXform  = min(  span->ring+1, span->Tsector.stopXform  );
; 1170 : 		span->Rsector.startXform = max( -span->ring-1, span->Rsector.startXform );
; 1171 : 		span->Rsector.stopXform  = min(  span->ring+1, span->Rsector.stopXform  );
; 1172 : 		span->Bsector.startXform = max( -span->ring-1, span->Bsector.startXform );
; 1173 : 		span->Bsector.stopXform  = min(  span->ring+1, span->Bsector.stopXform  );
; 1174 : 		span->Lsector.startXform = max( -span->ring-1, span->Lsector.startXform );
; 1175 : 		span->Lsector.stopXform  = min(  span->ring+1, span->Lsector.stopXform  );
; 1176 : 	}
; 1177 : #endif
; 1178 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildVertexSet@RenderOTW@@IAEXXZ ENDP			; RenderOTW::BuildVertexSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
_LOD$1 = -12						; size = 4
_this$ = -8						; size = 4
_span$ = -4						; size = 4
?TrimCornerSet@RenderOTW@@IAEXXZ PROC			; RenderOTW::TrimCornerSet
; _this$ = ecx

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 717  : 	SpanListEntry	*span;
; 718  : 
; 719  : 
; 720  : 	// Move from inner ring outward
; 721  : 	for ( span = firstEmptySpan-1; span>=spanList; span-- ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	sub	ecx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN70@TrimCorner
$LN69@TrimCorner:
	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN70@TrimCorner:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263348]
	jb	$LN71@TrimCorner

; 722  : 
; 723  : 		if ( (span < spanList+2) || (span->LOD == (span-2)->LOD) ) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263348]
	add	eax, 240				; 000000f0H
	cmp	DWORD PTR _span$[ebp], eax
	jb	SHORT $LN66@TrimCorner
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx-236]
	jne	$LN67@TrimCorner
$LN66@TrimCorner:

; 724  : 
; 725  : 			// Normal Draw.
; 726  : 			// Cut off all spans at their intersections with the y=x and y=-x lines
; 727  : 			if (span->Tsector.startDraw < -span->ring) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN65@TrimCorner

; 728  : 				span->Tsector.startDraw = -span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN65@TrimCorner:

; 729  : 			}
; 730  : 			if (span->Tsector.stopDraw > span->ring) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN64@TrimCorner

; 731  : 				span->Tsector.stopDraw = span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+24], eax
$LN64@TrimCorner:

; 732  : 			}
; 733  : 			if (span->Rsector.startDraw < -span->ring+1) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+48], edx
	jge	SHORT $LN63@TrimCorner

; 734  : 				span->Rsector.startDraw = -span->ring+1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+48], edx
$LN63@TrimCorner:

; 735  : 			}
; 736  : 			if (span->Rsector.stopDraw > span->ring-1) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+52], edx
	jle	SHORT $LN62@TrimCorner

; 737  : 				span->Rsector.stopDraw = span->ring-1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+52], edx
$LN62@TrimCorner:

; 738  : 			}
; 739  : 			if (span->Bsector.startDraw < -span->ring) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+76], edx
	jge	SHORT $LN61@TrimCorner

; 740  : 				span->Bsector.startDraw = -span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+76], edx
$LN61@TrimCorner:

; 741  : 			}
; 742  : 			if (span->Bsector.stopDraw > span->ring) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+80]
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN60@TrimCorner

; 743  : 				span->Bsector.stopDraw = span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+80], eax
$LN60@TrimCorner:

; 744  : 			}
; 745  : 			if (span->Lsector.startDraw < -span->ring+1) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+104], edx
	jge	SHORT $LN59@TrimCorner

; 746  : 				span->Lsector.startDraw = -span->ring+1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+104], edx
$LN59@TrimCorner:

; 747  : 			}
; 748  : 			if (span->Lsector.stopDraw > span->ring-1) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+108], edx
	jle	SHORT $LN58@TrimCorner

; 749  : 				span->Lsector.stopDraw = span->ring-1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+108], edx
$LN58@TrimCorner:

; 750  : 			}
; 751  : 
; 752  : 		} else {

	jmp	$LN57@TrimCorner
$LN67@TrimCorner:

; 753  : 			int LOD = span->LOD;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _LOD$1[ebp], edx

; 754  : 
; 755  : 			if ( LOD == (span-1)->LOD ) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _LOD$1[ebp]
	cmp	ecx, DWORD PTR [eax-116]
	jne	$LN56@TrimCorner

; 756  : 
; 757  : 				// Glue control span (also controls some connector drawing)
; 758  : 				if ( LODdata[LOD].glueOnBottom ) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+48], 0
	je	$LN55@TrimCorner

; 759  : 					// For Glue
; 760  : 					if (span->Bsector.startDraw < -span->ring +1-LODdata[LOD].glueOnLeft) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _LOD$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	sub	eax, DWORD PTR [edx+ecx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+76], eax
	jge	SHORT $LN54@TrimCorner

; 761  : 						span->Bsector.startDraw = -span->ring +1-LODdata[LOD].glueOnLeft;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _LOD$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	sub	eax, DWORD PTR [edx+ecx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN54@TrimCorner:

; 762  : 					}
; 763  : 					if (span->Bsector.stopDraw > span->ring - LODdata[LOD].glueOnLeft) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+edx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+80], eax
	jle	SHORT $LN53@TrimCorner

; 764  : 						span->Bsector.stopDraw = span->ring - LODdata[LOD].glueOnLeft;

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+edx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+80], eax
$LN53@TrimCorner:

; 765  : 					}
; 766  : 
; 767  : 					// For connector
; 768  : 					if ( LODdata[LOD].glueOnLeft ) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+52], 0
	je	$LN52@TrimCorner

; 769  : 						// Bottom Left
; 770  : 						// Clipping
; 771  : 						if (span->Tsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jge	SHORT $LN51@TrimCorner

; 772  : 							span->Tsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN51@TrimCorner:

; 773  : 						}
; 774  : 						if (span->Tsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN50@TrimCorner

; 775  : 							span->Tsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+24], ecx
$LN50@TrimCorner:

; 776  : 						}
; 777  : 						if (span->Rsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+48], eax
	jge	SHORT $LN49@TrimCorner

; 778  : 							span->Rsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN49@TrimCorner:

; 779  : 						}
; 780  : 						if (span->Rsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN48@TrimCorner

; 781  : 							span->Rsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+52], ecx
$LN48@TrimCorner:

; 782  : 						}
; 783  : 
; 784  : 						// Rounding
; 785  : 						span->Tsector.startDraw = (span->Tsector.startDraw -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 786  : 						span->Tsector.stopDraw  = (span->Tsector.stopDraw  -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 787  : 						span->Rsector.startDraw = (span->Rsector.startDraw -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+48]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 788  : 						span->Rsector.stopDraw  = (span->Rsector.stopDraw  -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+52]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 789  : 					} else {

	jmp	$LN47@TrimCorner
$LN52@TrimCorner:

; 790  : 						// Bottom Right
; 791  : 						// Clipping
; 792  : 						if (span->Tsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jge	SHORT $LN46@TrimCorner

; 793  : 							span->Tsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN46@TrimCorner:

; 794  : 						}
; 795  : 						if (span->Tsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN45@TrimCorner

; 796  : 							span->Tsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+24], ecx
$LN45@TrimCorner:

; 797  : 						}
; 798  : 						if (span->Lsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+104], eax
	jge	SHORT $LN44@TrimCorner

; 799  : 							span->Lsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax
$LN44@TrimCorner:

; 800  : 						}
; 801  : 						if (span->Lsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+108]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN43@TrimCorner

; 802  : 							span->Lsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+108], ecx
$LN43@TrimCorner:

; 803  : 						}
; 804  : 
; 805  : 						// Rounding
; 806  : 						span->Tsector.startDraw = span->Tsector.startDraw & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 807  : 						span->Tsector.stopDraw  = span->Tsector.stopDraw  & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 808  : 						span->Lsector.startDraw = (span->Lsector.startDraw -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+104]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 809  : 						span->Lsector.stopDraw  = (span->Lsector.stopDraw  -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+108]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN47@TrimCorner:

; 810  : 					}
; 811  : 				} else {

	jmp	$LN42@TrimCorner
$LN55@TrimCorner:

; 812  : 					// For Glue
; 813  : 					if (span->Tsector.startDraw < -span->ring +1-LODdata[LOD].glueOnLeft) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _LOD$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	sub	eax, DWORD PTR [edx+ecx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jge	SHORT $LN41@TrimCorner

; 814  : 						span->Tsector.startDraw = -span->ring +1-LODdata[LOD].glueOnLeft;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _LOD$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	sub	eax, DWORD PTR [edx+ecx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN41@TrimCorner:

; 815  : 					}
; 816  : 					if (span->Tsector.stopDraw > span->ring - LODdata[LOD].glueOnLeft) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+edx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN40@TrimCorner

; 817  : 						span->Tsector.stopDraw = span->ring - LODdata[LOD].glueOnLeft;

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+edx+52]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN40@TrimCorner:

; 818  : 					}
; 819  : 
; 820  : 					// For connector
; 821  : 					if ( LODdata[LOD].glueOnLeft ) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+52], 0
	je	$LN39@TrimCorner

; 822  : 						// Top Left
; 823  : 						// Clipping
; 824  : 						if (span->Bsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+76], eax
	jge	SHORT $LN38@TrimCorner

; 825  : 							span->Bsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN38@TrimCorner:

; 826  : 						}
; 827  : 						if (span->Bsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN37@TrimCorner

; 828  : 							span->Bsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+80], ecx
$LN37@TrimCorner:

; 829  : 						}
; 830  : 						if (span->Rsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+48], eax
	jge	SHORT $LN36@TrimCorner

; 831  : 							span->Rsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN36@TrimCorner:

; 832  : 						}
; 833  : 						if (span->Rsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN35@TrimCorner

; 834  : 							span->Rsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+52], ecx
$LN35@TrimCorner:

; 835  : 						}
; 836  : 
; 837  : 						// Rounding
; 838  : 						span->Bsector.startDraw = (span->Bsector.startDraw -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+76]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 839  : 						span->Bsector.stopDraw  = (span->Bsector.stopDraw  -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+80]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 840  : 						span->Rsector.startDraw = span->Rsector.startDraw & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 841  : 						span->Rsector.stopDraw  = span->Rsector.stopDraw  & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+52]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 842  : 					} else {

	jmp	$LN42@TrimCorner
$LN39@TrimCorner:

; 843  : 						// Top Right
; 844  : 						// Clipping
; 845  : 						if (span->Bsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+76], eax
	jge	SHORT $LN33@TrimCorner

; 846  : 							span->Bsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN33@TrimCorner:

; 847  : 						}
; 848  : 						if (span->Bsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN32@TrimCorner

; 849  : 							span->Bsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+80], ecx
$LN32@TrimCorner:

; 850  : 						}
; 851  : 						if (span->Lsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+104], eax
	jge	SHORT $LN31@TrimCorner

; 852  : 							span->Lsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax
$LN31@TrimCorner:

; 853  : 						}
; 854  : 						if (span->Lsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+108]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN30@TrimCorner

; 855  : 							span->Lsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+108], ecx
$LN30@TrimCorner:

; 856  : 						}
; 857  : 
; 858  : 						// Rounding
; 859  : 						span->Bsector.startDraw = span->Bsector.startDraw & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+76]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 860  : 						span->Bsector.stopDraw  = span->Bsector.stopDraw  & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+80]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 861  : 						span->Lsector.startDraw = span->Lsector.startDraw & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+104]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 862  : 						span->Lsector.stopDraw  = span->Lsector.stopDraw  & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+108]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN42@TrimCorner:

; 863  : 					}
; 864  : 				}
; 865  : 
; 866  : 				if ( LODdata[LOD].glueOnLeft ) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+52], 0
	je	SHORT $LN29@TrimCorner

; 867  : 					// For Glue
; 868  : 					if (span->Lsector.startDraw < -span->ring+1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+104], eax
	jge	SHORT $LN28@TrimCorner

; 869  : 						span->Lsector.startDraw = -span->ring+1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax
$LN28@TrimCorner:

; 870  : 					}
; 871  : 					if (span->Lsector.stopDraw > span->ring-1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+108], eax
	jle	SHORT $LN27@TrimCorner

; 872  : 						span->Lsector.stopDraw = span->ring-1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN27@TrimCorner:

; 873  : 					}
; 874  : 				} else {

	jmp	SHORT $LN26@TrimCorner
$LN29@TrimCorner:

; 875  : 					// For Glue
; 876  : 					if (span->Rsector.startDraw < -span->ring+1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+48], eax
	jge	SHORT $LN25@TrimCorner

; 877  : 						span->Rsector.startDraw = -span->ring+1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN25@TrimCorner:

; 878  : 					}
; 879  : 					if (span->Rsector.stopDraw > span->ring-1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+52], eax
	jle	SHORT $LN26@TrimCorner

; 880  : 						span->Rsector.stopDraw = span->ring-1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN26@TrimCorner:

; 881  : 					}
; 882  : 				}
; 883  : 
; 884  : 			} else {

	jmp	$LN57@TrimCorner
$LN56@TrimCorner:

; 885  : 
; 886  : 				// Outter Xform span (controls some parts of connector drawing)
; 887  : 				if ( LODdata[LOD].glueOnBottom ) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+48], 0
	je	$LN22@TrimCorner

; 888  : 					if (LODdata[LOD].glueOnLeft) {

	mov	edx, DWORD PTR _LOD$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	cmp	DWORD PTR [ecx+edx+52], 0
	je	$LN21@TrimCorner

; 889  : 						// Bottom Left
; 890  : 						// Clipping
; 891  : 						if (span->Bsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+76], eax
	jge	SHORT $LN20@TrimCorner

; 892  : 							span->Bsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN20@TrimCorner:

; 893  : 						}
; 894  : 						if (span->Bsector.stopDraw > span->ring-1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+80], eax
	jle	SHORT $LN19@TrimCorner

; 895  : 							span->Bsector.stopDraw = span->ring-1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+80], eax
$LN19@TrimCorner:

; 896  : 						}
; 897  : 						if (span->Lsector.startDraw < -span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+104], eax
	jge	SHORT $LN18@TrimCorner

; 898  : 							span->Lsector.startDraw = -span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax
$LN18@TrimCorner:

; 899  : 						}
; 900  : 						if (span->Lsector.stopDraw > span->ring-1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+108], eax
	jle	SHORT $LN17@TrimCorner

; 901  : 							span->Lsector.stopDraw = span->ring-1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN17@TrimCorner:

; 902  : 						}
; 903  : 						span->Tsector.startDraw = MAX_POSITIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+20], 25000		; 000061a8H

; 904  : 						span->Tsector.stopDraw  = MAX_NEGATIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+24], -25000		; ffff9e58H

; 905  : 						span->Rsector.startDraw = MAX_POSITIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], 25000		; 000061a8H

; 906  : 						span->Rsector.stopDraw  = MAX_NEGATIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+52], -25000		; ffff9e58H

; 907  : 
; 908  : 						// Rounding
; 909  : 						span->Bsector.startDraw = (span->Bsector.startDraw -1) | 1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	sub	ecx, 1
	or	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 910  : 						span->Bsector.stopDraw  = (span->Bsector.stopDraw  -1) | 1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	sub	ecx, 1
	or	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+80], ecx

; 911  : 						span->Lsector.startDraw = (span->Lsector.startDraw -1) | 1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	sub	ecx, 1
	or	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+104], ecx

; 912  : 						span->Lsector.stopDraw  = (span->Lsector.stopDraw  -1) | 1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sub	ecx, 1
	or	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+108], ecx

; 913  : 					} else {

	jmp	$LN16@TrimCorner
$LN21@TrimCorner:

; 914  : 						// Bottom Right
; 915  : 						// Clipping
; 916  : 						if (span->Bsector.startDraw < -span->ring+1) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+76], ecx
	jge	SHORT $LN15@TrimCorner

; 917  : 							span->Bsector.startDraw = -span->ring+1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	add	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN15@TrimCorner:

; 918  : 						}
; 919  : 						if (span->Bsector.stopDraw > span->ring) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [eax+80]
	cmp	edx, DWORD PTR [ecx]
	jle	SHORT $LN14@TrimCorner

; 920  : 							span->Bsector.stopDraw = span->ring;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+80], edx
$LN14@TrimCorner:

; 921  : 						}
; 922  : 						if (span->Rsector.startDraw < -span->ring) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+48], ecx
	jge	SHORT $LN13@TrimCorner

; 923  : 							span->Rsector.startDraw = -span->ring;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+48], ecx
$LN13@TrimCorner:

; 924  : 						}
; 925  : 						if (span->Rsector.stopDraw > span->ring-1) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [edx+52], ecx
	jle	SHORT $LN12@TrimCorner

; 926  : 							span->Rsector.stopDraw = span->ring-1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN12@TrimCorner:

; 927  : 						}
; 928  : 						span->Tsector.startDraw = MAX_POSITIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+20], 25000		; 000061a8H

; 929  : 						span->Tsector.stopDraw  = MAX_NEGATIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+24], -25000		; ffff9e58H

; 930  : 						span->Lsector.startDraw = MAX_POSITIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+104], 25000		; 000061a8H

; 931  : 						span->Lsector.stopDraw  = MAX_NEGATIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+108], -25000		; ffff9e58H

; 932  : 
; 933  : 						// Rounding
; 934  : 						span->Bsector.startDraw = span->Bsector.startDraw & ~1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+76], edx

; 935  : 						span->Bsector.stopDraw  = span->Bsector.stopDraw  & ~1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+80], edx

; 936  : 						span->Rsector.startDraw = (span->Rsector.startDraw -1) | 1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 1
	or	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+48], edx

; 937  : 						span->Rsector.stopDraw  = (span->Rsector.stopDraw  -1) | 1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sub	edx, 1
	or	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+52], edx
$LN16@TrimCorner:

; 938  : 					}
; 939  : 				} else {

	jmp	$LN57@TrimCorner
$LN22@TrimCorner:

; 940  : 					if (LODdata[LOD].glueOnLeft) {

	mov	ecx, DWORD PTR _LOD$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	cmp	DWORD PTR [eax+ecx+52], 0
	je	$LN10@TrimCorner

; 941  : 						// Top Left
; 942  : 						// Clipping
; 943  : 						if (span->Tsector.startDraw < -span->ring) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN9@TrimCorner

; 944  : 							span->Tsector.startDraw = -span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN9@TrimCorner:

; 945  : 						}
; 946  : 						if (span->Tsector.stopDraw > span->ring-1) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+24], edx
	jle	SHORT $LN8@TrimCorner

; 947  : 							span->Tsector.stopDraw = span->ring-1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN8@TrimCorner:

; 948  : 						}
; 949  : 						if (span->Lsector.startDraw < -span->ring+1) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [eax+104], edx
	jge	SHORT $LN7@TrimCorner

; 950  : 							span->Lsector.startDraw = -span->ring+1;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	add	edx, 1
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+104], edx
$LN7@TrimCorner:

; 951  : 						}
; 952  : 						if (span->Lsector.stopDraw > span->ring) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN6@TrimCorner

; 953  : 							span->Lsector.stopDraw = span->ring;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+108], eax
$LN6@TrimCorner:

; 954  : 						}
; 955  : 						span->Bsector.startDraw = MAX_POSITIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], 25000		; 000061a8H

; 956  : 						span->Bsector.stopDraw  = MAX_NEGATIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+80], -25000		; ffff9e58H

; 957  : 						span->Rsector.startDraw = MAX_POSITIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+48], 25000		; 000061a8H

; 958  : 						span->Rsector.stopDraw  = MAX_NEGATIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+52], -25000		; ffff9e58H

; 959  : 
; 960  : 						// Rounding
; 961  : 						span->Tsector.startDraw = (span->Tsector.startDraw -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 962  : 						span->Tsector.stopDraw  = (span->Tsector.stopDraw  -1) | 1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, 1
	or	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 963  : 						span->Lsector.startDraw = span->Lsector.startDraw & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+104]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 964  : 						span->Lsector.stopDraw  = span->Lsector.stopDraw  & ~1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+108]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 965  : 					} else {

	jmp	$LN57@TrimCorner
$LN10@TrimCorner:

; 966  : 						// Top Right
; 967  : 						// Clipping
; 968  : 						if (span->Tsector.startDraw < -span->ring+1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jge	SHORT $LN4@TrimCorner

; 969  : 							span->Tsector.startDraw = -span->ring+1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN4@TrimCorner:

; 970  : 						}
; 971  : 						if (span->Tsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN3@TrimCorner

; 972  : 							span->Tsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+24], ecx
$LN3@TrimCorner:

; 973  : 						}
; 974  : 						if (span->Rsector.startDraw < -span->ring+1) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	DWORD PTR [ecx+48], eax
	jge	SHORT $LN2@TrimCorner

; 975  : 							span->Rsector.startDraw = -span->ring+1;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	add	eax, 1
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN2@TrimCorner:

; 976  : 						}
; 977  : 						if (span->Rsector.stopDraw > span->ring) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN1@TrimCorner

; 978  : 							span->Rsector.stopDraw = span->ring;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+52], ecx
$LN1@TrimCorner:

; 979  : 						}
; 980  : 						span->Bsector.startDraw = MAX_POSITIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+76], 25000		; 000061a8H

; 981  : 						span->Bsector.stopDraw  = MAX_NEGATIVE_I;

	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+80], -25000		; ffff9e58H

; 982  : 						span->Lsector.startDraw = MAX_POSITIVE_I;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+104], 25000		; 000061a8H

; 983  : 						span->Lsector.stopDraw  = MAX_NEGATIVE_I;

	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+108], -25000		; ffff9e58H

; 984  : 
; 985  : 						// Rounding
; 986  : 						span->Tsector.startDraw = span->Tsector.startDraw & ~1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 987  : 						span->Tsector.stopDraw  = span->Tsector.stopDraw  & ~1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 988  : 						span->Rsector.startDraw = span->Rsector.startDraw & ~1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+48], ecx

; 989  : 						span->Rsector.stopDraw  = span->Rsector.stopDraw  & ~1;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN57@TrimCorner:

; 990  : 					}
; 991  : 				}
; 992  : 			}
; 993  : 		}
; 994  : 	}

	jmp	$LN69@TrimCorner
$LN71@TrimCorner:

; 995  : 
; 996  : 	
; 997  :  	// AT THIS POINT:	startDraw and stopDraw in all the rings completly and exactly specify
; 998  : 	//					the lower left corner points for squares to be drawn.
; 999  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TrimCornerSet@RenderOTW@@IAEXXZ ENDP			; RenderOTW::TrimCornerSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
tv394 = -72						; size = 4
tv376 = -68						; size = 4
tv358 = -64						; size = 4
tv340 = -60						; size = 4
tv322 = -56						; size = 4
tv304 = -52						; size = 4
tv286 = -48						; size = 4
tv268 = -44						; size = 4
tv250 = -40						; size = 4
tv232 = -36						; size = 4
tv214 = -32						; size = 4
tv196 = -28						; size = 4
tv178 = -24						; size = 4
tv160 = -20						; size = 4
tv142 = -16						; size = 4
tv92 = -12						; size = 4
_this$ = -8						; size = 4
_span$ = -4						; size = 4
?BuildCornerSet@RenderOTW@@IAEXXZ PROC			; RenderOTW::BuildCornerSet
; _this$ = ecx

; 618  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 619  : 	SpanListEntry	*span;
; 620  : 
; 621  : 
; 622  : 	// Move from inner ring outward
; 623  : 	for ( span = firstEmptySpan-1; span>=spanList; span-- ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	sub	ecx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN6@BuildCorne
$LN5@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN6@BuildCorne:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263348]
	jb	$LN4@BuildCorne

; 624  : 
; 625  : 		// The start/stop points were computed for the inside edges of each ring of squares.
; 626  : 		// Make sure the outter edge doesn't dictate a larger span.
; 627  : 		if (span != spanList) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	cmp	eax, DWORD PTR [edx+263348]
	je	$LN1@BuildCorne

; 628  : 			if (span->LOD == (span-1)->LOD) {

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx-116]
	jne	$LN2@BuildCorne

; 629  : 				// Normal case (look out one ring)
; 630  : 				ShiAssert( (span-1) >= spanList );
; 631  : 				span->Tsector.minEndPoint = min( span->Tsector.minEndPoint, (span-1)->Tsector.minEndPoint );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-108]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN9@BuildCorne
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN10@BuildCorne
$LN9@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-108]
	movss	DWORD PTR tv92[ebp], xmm0
$LN10@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv92[ebp]
	movss	DWORD PTR [edx+12], xmm0

; 632  : 				span->Tsector.maxEndPoint = max( span->Tsector.maxEndPoint, (span-1)->Tsector.maxEndPoint );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [ecx-104]
	jbe	SHORT $LN11@BuildCorne
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN12@BuildCorne
$LN11@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-104]
	movss	DWORD PTR tv142[ebp], xmm0
$LN12@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 633  : 				span->Rsector.minEndPoint = min( span->Rsector.minEndPoint, (span-1)->Rsector.minEndPoint );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-80]
	comiss	xmm0, DWORD PTR [edx+40]
	jbe	SHORT $LN13@BuildCorne
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR tv160[ebp], xmm0
	jmp	SHORT $LN14@BuildCorne
$LN13@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-80]
	movss	DWORD PTR tv160[ebp], xmm0
$LN14@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv160[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 634  : 				span->Rsector.maxEndPoint = max( span->Rsector.maxEndPoint, (span-1)->Rsector.maxEndPoint );

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [edx-76]
	jbe	SHORT $LN15@BuildCorne
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR tv178[ebp], xmm0
	jmp	SHORT $LN16@BuildCorne
$LN15@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-76]
	movss	DWORD PTR tv178[ebp], xmm0
$LN16@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR [edx+44], xmm0

; 635  : 				span->Bsector.minEndPoint = min( span->Bsector.minEndPoint, (span-1)->Bsector.minEndPoint );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-52]
	comiss	xmm0, DWORD PTR [eax+68]
	jbe	SHORT $LN17@BuildCorne
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR tv196[ebp], xmm0
	jmp	SHORT $LN18@BuildCorne
$LN17@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-52]
	movss	DWORD PTR tv196[ebp], xmm0
$LN18@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR [ecx+68], xmm0

; 636  : 				span->Bsector.maxEndPoint = max( span->Bsector.maxEndPoint, (span-1)->Bsector.maxEndPoint );

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [eax-48]
	jbe	SHORT $LN19@BuildCorne
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+72]
	movss	DWORD PTR tv214[ebp], xmm0
	jmp	SHORT $LN20@BuildCorne
$LN19@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-48]
	movss	DWORD PTR tv214[ebp], xmm0
$LN20@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv214[ebp]
	movss	DWORD PTR [eax+72], xmm0

; 637  : 				span->Lsector.minEndPoint = min( span->Lsector.minEndPoint, (span-1)->Lsector.minEndPoint );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-24]
	comiss	xmm0, DWORD PTR [ecx+96]
	jbe	SHORT $LN21@BuildCorne
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR tv232[ebp], xmm0
	jmp	SHORT $LN22@BuildCorne
$LN21@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-24]
	movss	DWORD PTR tv232[ebp], xmm0
$LN22@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	movss	DWORD PTR [edx+96], xmm0

; 638  : 				span->Lsector.maxEndPoint = max( span->Lsector.maxEndPoint, (span-1)->Lsector.maxEndPoint );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [ecx-20]
	jbe	SHORT $LN23@BuildCorne
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	movss	DWORD PTR tv250[ebp], xmm0
	jmp	SHORT $LN24@BuildCorne
$LN23@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-20]
	movss	DWORD PTR tv250[ebp], xmm0
$LN24@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv250[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 639  : 			} else {

	jmp	$LN1@BuildCorne
$LN2@BuildCorne:

; 640  : 				// Connector case (look out two rings to a lower LOD)
; 641  : 				ShiAssert( (span-2) >= spanList );
; 642  : 				span->Tsector.minEndPoint = min( span->Tsector.minEndPoint, (span-2)->Tsector.minEndPoint );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-228]
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN25@BuildCorne
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN26@BuildCorne
$LN25@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-228]
	movss	DWORD PTR tv268[ebp], xmm0
$LN26@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 643  : 				span->Tsector.maxEndPoint = max( span->Tsector.maxEndPoint, (span-2)->Tsector.maxEndPoint );

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [edx-224]
	jbe	SHORT $LN27@BuildCorne
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR tv286[ebp], xmm0
	jmp	SHORT $LN28@BuildCorne
$LN27@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-224]
	movss	DWORD PTR tv286[ebp], xmm0
$LN28@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 644  : 				span->Rsector.minEndPoint = min( span->Rsector.minEndPoint, (span-2)->Rsector.minEndPoint );

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-200]
	comiss	xmm0, DWORD PTR [eax+40]
	jbe	SHORT $LN29@BuildCorne
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR tv304[ebp], xmm0
	jmp	SHORT $LN30@BuildCorne
$LN29@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-200]
	movss	DWORD PTR tv304[ebp], xmm0
$LN30@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv304[ebp]
	movss	DWORD PTR [ecx+40], xmm0

; 645  : 				span->Rsector.maxEndPoint = max( span->Rsector.maxEndPoint, (span-2)->Rsector.maxEndPoint );

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [eax-196]
	jbe	SHORT $LN31@BuildCorne
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR tv322[ebp], xmm0
	jmp	SHORT $LN32@BuildCorne
$LN31@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-196]
	movss	DWORD PTR tv322[ebp], xmm0
$LN32@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv322[ebp]
	movss	DWORD PTR [eax+44], xmm0

; 646  : 				span->Bsector.minEndPoint = min( span->Bsector.minEndPoint, (span-2)->Bsector.minEndPoint );

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-172]
	comiss	xmm0, DWORD PTR [ecx+68]
	jbe	SHORT $LN33@BuildCorne
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	movss	DWORD PTR tv340[ebp], xmm0
	jmp	SHORT $LN34@BuildCorne
$LN33@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-172]
	movss	DWORD PTR tv340[ebp], xmm0
$LN34@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv340[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 647  : 				span->Bsector.maxEndPoint = max( span->Bsector.maxEndPoint, (span-2)->Bsector.maxEndPoint );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [ecx-168]
	jbe	SHORT $LN35@BuildCorne
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+72]
	movss	DWORD PTR tv358[ebp], xmm0
	jmp	SHORT $LN36@BuildCorne
$LN35@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-168]
	movss	DWORD PTR tv358[ebp], xmm0
$LN36@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv358[ebp]
	movss	DWORD PTR [ecx+72], xmm0

; 648  : 				span->Lsector.minEndPoint = min( span->Lsector.minEndPoint, (span-2)->Lsector.minEndPoint );

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax-144]
	comiss	xmm0, DWORD PTR [edx+96]
	jbe	SHORT $LN37@BuildCorne
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+96]
	movss	DWORD PTR tv376[ebp], xmm0
	jmp	SHORT $LN38@BuildCorne
$LN37@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx-144]
	movss	DWORD PTR tv376[ebp], xmm0
$LN38@BuildCorne:
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv376[ebp]
	movss	DWORD PTR [eax+96], xmm0

; 649  : 				span->Lsector.maxEndPoint = max( span->Lsector.maxEndPoint, (span-2)->Lsector.maxEndPoint );

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mov	edx, DWORD PTR _span$[ebp]
	comiss	xmm0, DWORD PTR [edx-140]
	jbe	SHORT $LN39@BuildCorne
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR tv394[ebp], xmm0
	jmp	SHORT $LN40@BuildCorne
$LN39@BuildCorne:
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx-140]
	movss	DWORD PTR tv394[ebp], xmm0
$LN40@BuildCorne:
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR tv394[ebp]
	movss	DWORD PTR [edx+100], xmm0
$LN1@BuildCorne:

; 650  : 			}
; 651  : 		}
; 652  : 
; 653  : 		// Convert all the start/stop points into units of level posts
; 654  : 		span->Tsector.startDraw	= WORLD_TO_LEVEL_POST( span->Tsector.minEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+20], eax

; 655  : 		span->Tsector.stopDraw	= WORLD_TO_LEVEL_POST( span->Tsector.maxEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+24], eax

; 656  : 		span->Rsector.startDraw	= WORLD_TO_LEVEL_POST( span->Rsector.minEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+48], eax

; 657  : 		span->Rsector.stopDraw	= WORLD_TO_LEVEL_POST( span->Rsector.maxEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+52], eax

; 658  : 		span->Bsector.startDraw	= WORLD_TO_LEVEL_POST( span->Bsector.minEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+76], eax

; 659  : 		span->Bsector.stopDraw	= WORLD_TO_LEVEL_POST( span->Bsector.maxEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+72]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+80], eax

; 660  : 		span->Lsector.startDraw	= WORLD_TO_LEVEL_POST( span->Lsector.minEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+104], eax

; 661  : 		span->Lsector.stopDraw	= WORLD_TO_LEVEL_POST( span->Lsector.maxEndPoint, span->LOD );

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	sar	eax, cl
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+108], eax

; 662  : 
; 663  : #if 0
; 664  : 		// If min and max fall onto the same level post, we can't tell the different between an empty
; 665  : 		// segment and a segment containing a single post.  This check resolves that ambiguity.
; 666  : 		// It may also prevent us from causing neighboring verticies to be transformed
; 667  : 		// when we won't, in fact be drawing anything.
; 668  : 		if ( span->Tsector.minEndPoint > span->Tsector.maxEndPoint ) {
; 669  : 			span->Tsector.startDraw = MAX_POSITIVE_I;
; 670  : 			span->Tsector.stopDraw  = MAX_NEGATIVE_I;
; 671  : 		}
; 672  : 		if ( span->Rsector.minEndPoint > span->Rsector.maxEndPoint ) {
; 673  : 			span->Rsector.startDraw = MAX_POSITIVE_I;
; 674  : 			span->Rsector.stopDraw  = MAX_NEGATIVE_I;
; 675  : 		}
; 676  : 		if ( span->Bsector.minEndPoint > span->Bsector.maxEndPoint ) {
; 677  : 			span->Bsector.startDraw = MAX_POSITIVE_I;
; 678  : 			span->Bsector.stopDraw  = MAX_NEGATIVE_I;
; 679  : 		}
; 680  : 		if ( span->Lsector.minEndPoint > span->Lsector.maxEndPoint ) {
; 681  : 			span->Lsector.startDraw = MAX_POSITIVE_I;
; 682  : 			span->Lsector.stopDraw  = MAX_NEGATIVE_I;
; 683  : 		}
; 684  : #endif
; 685  : 
; 686  : 		// Make all the start/stop points relative to the ring centers at each LOD
; 687  : 		span->Tsector.startDraw	-= LODdata[span->LOD].centerCol;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [eax+ecx+44]
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+20], edx

; 688  : 		span->Tsector.stopDraw	-= LODdata[span->LOD].centerCol;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax+24]
	sub	eax, DWORD PTR [ecx+edx+44]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 689  : 		span->Rsector.startDraw	-= LODdata[span->LOD].centerRow;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	sub	ecx, DWORD PTR [edx+eax+40]
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+48], ecx

; 690  : 		span->Rsector.stopDraw	-= LODdata[span->LOD].centerRow;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [edx+52]
	sub	edx, DWORD PTR [eax+ecx+40]
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+52], edx

; 691  : 		span->Bsector.startDraw	-= LODdata[span->LOD].centerCol;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax+76]
	sub	eax, DWORD PTR [ecx+edx+44]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 692  : 		span->Bsector.stopDraw	-= LODdata[span->LOD].centerCol;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	sub	ecx, DWORD PTR [edx+eax+44]
	mov	edx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [edx+80], ecx

; 693  : 		span->Lsector.startDraw	-= LODdata[span->LOD].centerRow;

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [edx+104]
	sub	edx, DWORD PTR [eax+ecx+40]
	mov	eax, DWORD PTR _span$[ebp]
	mov	DWORD PTR [eax+104], edx

; 694  : 		span->Lsector.stopDraw	-= LODdata[span->LOD].centerRow;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	eax, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [eax+108]
	sub	eax, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _span$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 695  : 	}

	jmp	$LN5@BuildCorne
$LN4@BuildCorne:

; 696  : 
; 697  : 	
; 698  :  	// AT THIS POINT:	startDraw and stopDraw in all the rings completly specify all the lower 
; 699  : 	//					left corner points for squares to be drawn, but may OVER specify them.
; 700  : 	//					TrimCornerSet() below will adjust and round the start/stop points as
; 701  : 	//					necessary.
; 702  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildCornerSet@RenderOTW@@IAEXXZ ENDP			; RenderOTW::BuildCornerSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
tv553 = -176						; size = 4
tv558 = -172						; size = 4
_LOD$ = -168						; size = 4
_startLocation$ = -164					; size = 4
_n$ = -160						; size = 4
_s$ = -156						; size = 4
_span$ = -152						; size = 4
_this$ = -148						; size = 4
_northBoundry$ = -144					; size = 64
_southBoundry$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ClipVerticalSectors@RenderOTW@@IAEXXZ PROC		; RenderOTW::ClipVerticalSectors
; _this$ = ecx

; 393  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ClipVerticalSectors@RenderOTW@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 394  : 	SpanListEntry	*span=NULL;

	mov	DWORD PTR _span$[ebp], 0

; 395  : 	int				LOD=0;

	mov	DWORD PTR _LOD$[ebp], 0

; 396  : 	int				n=0, s=0;

	mov	DWORD PTR _n$[ebp], 0
	mov	DWORD PTR _s$[ebp], 0

; 397  : 	float			startLocation=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 398  : 	BoundSegment	northBoundry[4];

	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	OFFSET ??0BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _northBoundry$[ebp]
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 399  : 	BoundSegment	southBoundry[4];

	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	OFFSET ??0BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	ecx, DWORD PTR _southBoundry$[ebp]
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 400  : 
; 401  : 
; 402  : 	// Construct the ordered edge list (horizontal span case - Y buckets (since Y is East/Right))
; 403  : 	if ( (Yaw() < PI_OVER_2) || (Yaw() > 3.0f*PI_OVER_2) ) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Yaw@Render3D@@QAEMXZ			; Render3D::Yaw
	fstp	DWORD PTR tv553[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fdb
	comiss	xmm0, DWORD PTR tv553[ebp]
	ja	SHORT $LN34@ClipVertic
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Yaw@Render3D@@QAEMXZ			; Render3D::Yaw
	fstp	DWORD PTR tv558[ebp]
	movss	xmm0, DWORD PTR tv558[ebp]
	comiss	xmm0, DWORD PTR __real@4096cbe4
	jbe	$LN35@ClipVertic
$LN34@ClipVertic:

; 404  : 		// Necessarily, rightY2 > leftY2
; 405  : 		if (rightY1 > rightY2) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263264]
	comiss	xmm0, DWORD PTR [eax+263268]
	jbe	$LN33@ClipVertic

; 406  : 			// Right front corner is east most
; 407  : 			startLocation = rightY1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263264]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 408  : 			northBoundry[0].edge = right_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263324				; 0004049cH
	mov	eax, 16					; 00000010H
	imul	eax, 0
	lea	ecx, DWORD PTR _northBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 409  : 			northBoundry[1].edge = back_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263300				; 00040484H
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _northBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 410  : 			northBoundry[2].edge = left_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _northBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 411  : 			northBoundry[0].end = rightY2;

	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263268]
	mov	DWORD PTR _northBoundry$[ebp+edx+12], ecx

; 412  : 			northBoundry[1].end = leftY2;

	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263284]
	mov	DWORD PTR _northBoundry$[ebp+edx+12], ecx

; 413  : 			northBoundry[2].end = leftY1;

	mov	edx, 16					; 00000010H
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263280]
	mov	DWORD PTR _northBoundry$[ebp+edx+12], ecx

; 414  : 			southBoundry[0].edge = front_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263288				; 00040478H
	mov	eax, 16					; 00000010H
	imul	eax, 0
	lea	ecx, DWORD PTR _southBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 415  : 			southBoundry[1].edge = left_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263312				; 00040490H
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _southBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 416  : 			southBoundry[2].edge = back_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _southBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 417  : 			southBoundry[0].end = leftY1;

	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263280]
	mov	DWORD PTR _southBoundry$[ebp+edx+12], ecx

; 418  : 			southBoundry[1].end = leftY2;

	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263284]
	mov	DWORD PTR _southBoundry$[ebp+edx+12], ecx

; 419  : 			southBoundry[2].end = rightY2;

	mov	edx, 16					; 00000010H
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263268]
	mov	DWORD PTR _southBoundry$[ebp+edx+12], ecx

; 420  : 		} else {

	jmp	$LN32@ClipVertic
$LN33@ClipVertic:

; 421  : 			// Right back corner is east most
; 422  : 			startLocation = rightY2;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263268]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 423  : 			northBoundry[0].edge = back_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263300				; 00040484H
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _northBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 424  : 			northBoundry[1].edge = left_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _northBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 425  : 			northBoundry[2].edge = front_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263288				; 00040478H
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _northBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 426  : 			northBoundry[0].end = leftY2;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263284]
	mov	DWORD PTR _northBoundry$[ebp+eax+12], edx

; 427  : 			northBoundry[1].end = leftY1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263280]
	mov	DWORD PTR _northBoundry$[ebp+eax+12], edx

; 428  : 			northBoundry[2].end = rightY1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263264]
	mov	DWORD PTR _northBoundry$[ebp+eax+12], edx

; 429  : 			southBoundry[0].edge = right_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263324				; 0004049cH
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _southBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 430  : 			southBoundry[1].edge = front_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263288				; 00040478H
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _southBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 431  : 			southBoundry[2].edge = left_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263312				; 00040490H
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _southBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 432  : 			southBoundry[0].end = rightY1;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263264]
	mov	DWORD PTR _southBoundry$[ebp+eax+12], edx

; 433  : 			southBoundry[1].end = leftY1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263280]
	mov	DWORD PTR _southBoundry$[ebp+eax+12], edx

; 434  : 			southBoundry[2].end = leftY2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263284]
	mov	DWORD PTR _southBoundry$[ebp+eax+12], edx
$LN32@ClipVertic:

; 435  : 		}
; 436  : 	} else {

	jmp	$LN29@ClipVertic
$LN35@ClipVertic:

; 437  : 		// Necessarily, rightY2 <= leftY2
; 438  : 		if (leftY1 > leftY2) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263280]
	comiss	xmm0, DWORD PTR [ecx+263284]
	jbe	$LN30@ClipVertic

; 439  : 			// Left front corner is east most
; 440  : 			startLocation = leftY1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263280]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 441  : 			northBoundry[0].edge = front_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263288				; 00040478H
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _northBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 442  : 			northBoundry[1].edge = right_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263324				; 0004049cH
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _northBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 443  : 			northBoundry[2].edge = back_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263300				; 00040484H
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _northBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 444  : 			northBoundry[0].end = rightY1;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263264]
	mov	DWORD PTR _northBoundry$[ebp+eax+12], edx

; 445  : 			northBoundry[1].end = rightY2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263268]
	mov	DWORD PTR _northBoundry$[ebp+eax+12], edx

; 446  : 			northBoundry[2].end = leftY2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263284]
	mov	DWORD PTR _northBoundry$[ebp+eax+12], edx

; 447  : 			southBoundry[0].edge = left_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263312				; 00040490H
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _southBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 448  : 			southBoundry[1].edge = back_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _southBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 449  : 			southBoundry[2].edge = right_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263324				; 0004049cH
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _southBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 450  : 			southBoundry[0].end = leftY2;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263284]
	mov	DWORD PTR _southBoundry$[ebp+eax+12], edx

; 451  : 			southBoundry[1].end = rightY2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263268]
	mov	DWORD PTR _southBoundry$[ebp+eax+12], edx

; 452  : 			southBoundry[2].end = rightY1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263264]
	mov	DWORD PTR _southBoundry$[ebp+eax+12], edx

; 453  : 		} else {

	jmp	$LN29@ClipVertic
$LN30@ClipVertic:

; 454  : 			// Left back corner is east most
; 455  : 			startLocation = leftY2;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263284]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 456  : 			northBoundry[0].edge = left_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	mov	edx, 16					; 00000010H
	imul	edx, 0
	lea	eax, DWORD PTR _northBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 457  : 			northBoundry[1].edge = front_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263288				; 00040478H
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _northBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 458  : 			northBoundry[2].edge = right_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263324				; 0004049cH
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _northBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 459  : 			northBoundry[0].end = leftY1;

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263280]
	mov	DWORD PTR _northBoundry$[ebp+ecx+12], eax

; 460  : 			northBoundry[1].end = rightY1;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263264]
	mov	DWORD PTR _northBoundry$[ebp+ecx+12], eax

; 461  : 			northBoundry[2].end = rightY2;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263268]
	mov	DWORD PTR _northBoundry$[ebp+ecx+12], eax

; 462  : 			southBoundry[0].edge = back_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	mov	edx, 16					; 00000010H
	imul	edx, 0
	lea	eax, DWORD PTR _southBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 463  : 			southBoundry[1].edge = right_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263324				; 0004049cH
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _southBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 464  : 			southBoundry[2].edge = front_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263288				; 00040478H
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _southBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 465  : 			southBoundry[0].end = rightY2;

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263268]
	mov	DWORD PTR _southBoundry$[ebp+ecx+12], eax

; 466  : 			southBoundry[1].end = rightY1;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263264]
	mov	DWORD PTR _southBoundry$[ebp+ecx+12], eax

; 467  : 			southBoundry[2].end = leftY1;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263280]
	mov	DWORD PTR _southBoundry$[ebp+ecx+12], eax
$LN29@ClipVertic:

; 468  : 		}
; 469  : 	}
; 470  : 
; 471  : 	// Terminated the edge chain with a point greater than any possible to ensure we see an "upturn"
; 472  : 	northBoundry[3].end = MAX_POSTIVE_F;

	mov	ecx, 16					; 00000010H
	imul	ecx, 3
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR _northBoundry$[ebp+ecx+12], xmm0

; 473  : 	southBoundry[3].end = MAX_POSTIVE_F;

	mov	edx, 16					; 00000010H
	imul	edx, 3
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR _southBoundry$[ebp+edx+12], xmm0

; 474  : 
; 475  : 
; 476  : 	// Force a fresh start by noting an illegal "current" LOD
; 477  : 	LOD = -1;

	mov	DWORD PTR _LOD$[ebp], -1

; 478  : 
; 479  : 	// Now fill in the extents of spans along the right edge of the bounding region
; 480  : 	for (span = spanList; span != firstEmptySpan; span++) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263348]
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN28@ClipVertic
$LN27@ClipVertic:
	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN28@ClipVertic:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263352]
	je	$LN26@ClipVertic

; 481  : 
; 482  : 		// Spans are empty until we get to the top corner of the bounding region
; 483  : 		if (span->Rsector.insideEdge > startLocation) {

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	comiss	xmm0, DWORD PTR _startLocation$[ebp]
	jbe	SHORT $LN25@ClipVertic

; 484  : 			span->Rsector.minEndPoint	= MAX_POSTIVE_F;

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [eax+40], xmm0

; 485  : 			span->Rsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [ecx+44], xmm0

; 486  : 			continue;

	jmp	SHORT $LN27@ClipVertic
$LN25@ClipVertic:

; 487  : 		}
; 488  : 
; 489  : 		// Restart the edge traversal since the spans can take a step backward at LOD change
; 490  : 		if (span->LOD != LOD) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _LOD$[ebp]
	je	SHORT $LN24@ClipVertic

; 491  : 			LOD = span->LOD;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _LOD$[ebp], edx

; 492  : 			n = s = 0;

	mov	DWORD PTR _s$[ebp], 0
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _n$[ebp], eax
$LN24@ClipVertic:

; 493  : 		}
; 494  : 
; 495  : 		// Switch controlling edges when required
; 496  : 		if (span->Rsector.insideEdge <= southBoundry[s].end) {

	mov	ecx, DWORD PTR _s$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _southBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR [edx+36]
	jb	$LN19@ClipVertic
$LN22@ClipVertic:

; 497  : 
; 498  : 			// Try to find an edge that will advance us at least one row
; 499  : 			while (southBoundry[s+1].end <= southBoundry[s].end) {

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _s$[ebp]
	shl	ecx, 4
	movss	xmm0, DWORD PTR _southBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR _southBoundry$[ebp+eax+12]
	jb	SHORT $LN21@ClipVertic

; 500  : 				s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 501  : 
; 502  : 				if (span->Rsector.insideEdge > southBoundry[s].end) {

	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	comiss	xmm0, DWORD PTR _southBoundry$[ebp+eax+12]
	jbe	SHORT $LN20@ClipVertic

; 503  : 					break;

	jmp	SHORT $LN21@ClipVertic
$LN20@ClipVertic:

; 504  : 				}
; 505  : 			}

	jmp	SHORT $LN22@ClipVertic
$LN21@ClipVertic:

; 506  : 
; 507  : 			// Nothing on these spans if we've exhausted our edges
; 508  : 			if (span->Rsector.insideEdge <= southBoundry[s].end) {

	mov	edx, DWORD PTR _s$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _southBoundry$[ebp+edx+12]
	comiss	xmm0, DWORD PTR [eax+36]
	jb	SHORT $LN19@ClipVertic

; 509  : 				span->Rsector.minEndPoint	= MAX_POSTIVE_F;

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [ecx+40], xmm0

; 510  : 				span->Rsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [edx+44], xmm0

; 511  : 				continue;

	jmp	$LN27@ClipVertic
$LN19@ClipVertic:

; 512  : 			}
; 513  : 
; 514  : 			ShiAssert( s < 3 );
; 515  : 			ShiAssert( southBoundry[s].end <= southBoundry[s-1].end );
; 516  : 		}
; 517  : 		if (span->Rsector.insideEdge <= northBoundry[n].end) {

	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _northBoundry$[ebp+eax+12]
	comiss	xmm0, DWORD PTR [ecx+36]
	jb	SHORT $LN16@ClipVertic
$LN17@ClipVertic:

; 518  : 
; 519  : 			// Try to find an edge that will advance us at least one row
; 520  : 			while (northBoundry[n+1].end <= northBoundry[n].end) {

	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	movss	xmm0, DWORD PTR _northBoundry$[ebp+eax+12]
	comiss	xmm0, DWORD PTR _northBoundry$[ebp+edx+12]
	jb	SHORT $LN16@ClipVertic

; 521  : 				n++;

	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx

; 522  : 
; 523  : 				if (span->Rsector.insideEdge > northBoundry[n].end) {

	mov	edx, DWORD PTR _n$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	comiss	xmm0, DWORD PTR _northBoundry$[ebp+edx+12]
	jbe	SHORT $LN15@ClipVertic

; 524  : 					break;

	jmp	SHORT $LN16@ClipVertic
$LN15@ClipVertic:

; 525  : 				}
; 526  : 			}

	jmp	SHORT $LN17@ClipVertic
$LN16@ClipVertic:

; 527  : 
; 528  : 			// We can't exhaust this edge without having already exhausted the one above
; 529  : //			ShiAssert( n > 0 );		// We _must_ have taken a step in the while above
; 530  : //			ShiAssert( n < 3 );
; 531  : //			ShiAssert( northBoundry[n].end <= northBoundry[n-1].end );
; 532  : 		}
; 533  : 
; 534  : 
; 535  : 		// Compute the intersection of this span with the bounding region
; 536  : 		span->Rsector.minEndPoint = southBoundry[s].edge.X( (float)span->Rsector.insideEdge );

	mov	ecx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _s$[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR _southBoundry$[ebp+edx]
	call	?X@Edge@@QAEMM@Z			; Edge::X
	mov	eax, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [eax+40]

; 537  : 		span->Rsector.maxEndPoint = northBoundry[n].edge.X( (float)span->Rsector.insideEdge );

	mov	ecx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _n$[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR _northBoundry$[ebp+edx]
	call	?X@Edge@@QAEMM@Z			; Edge::X
	mov	eax, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [eax+44]

; 538  : 	}

	jmp	$LN27@ClipVertic
$LN26@ClipVertic:

; 539  : 
; 540  : 
; 541  : 	// Force a fresh start by noting an illegal "current" LOD
; 542  : 	LOD = -1;

	mov	DWORD PTR _LOD$[ebp], -1

; 543  : 
; 544  : 	// Now fill in the extents of spans along the left edge of the bounding region
; 545  : 	for (span = firstEmptySpan-1; span >= spanList; span--) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263352]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
	jmp	SHORT $LN14@ClipVertic
$LN13@ClipVertic:
	mov	eax, DWORD PTR _span$[ebp]
	sub	eax, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], eax
$LN14@ClipVertic:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [ecx+263348]
	jb	$LN12@ClipVertic

; 546  : 
; 547  : 		// Spans are empty until we get to the top corner of the bounding region
; 548  : 		if (span->Lsector.insideEdge > startLocation) {

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+92]
	comiss	xmm0, DWORD PTR _startLocation$[ebp]
	jbe	SHORT $LN11@ClipVertic

; 549  : 			span->Lsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [ecx+100], xmm0

; 550  : 			span->Lsector.minEndPoint	= MAX_POSTIVE_F;

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [edx+96], xmm0

; 551  : 			continue;

	jmp	SHORT $LN13@ClipVertic
$LN11@ClipVertic:

; 552  : 		}
; 553  : 	
; 554  : 		// Restart the edge traversal since the spans can take a step backward at LOD change
; 555  : 		if (span->LOD != LOD) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _LOD$[ebp]
	je	SHORT $LN10@ClipVertic

; 556  : 			LOD = span->LOD;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _LOD$[ebp], eax

; 557  : 			n = s = 0;

	mov	DWORD PTR _s$[ebp], 0
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _n$[ebp], ecx
$LN10@ClipVertic:

; 558  : 		}
; 559  : 
; 560  : 		// Switch controlling edges when required
; 561  : 		if (span->Lsector.insideEdge <= southBoundry[s].end) {

	mov	edx, DWORD PTR _s$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _southBoundry$[ebp+edx+12]
	comiss	xmm0, DWORD PTR [eax+92]
	jb	$LN5@ClipVertic
$LN8@ClipVertic:

; 562  : 
; 563  : 			// Try to find an edge that will advance us at least one row
; 564  : 			while (southBoundry[s+1].end <= southBoundry[s].end) {

	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _s$[ebp]
	shl	edx, 4
	movss	xmm0, DWORD PTR _southBoundry$[ebp+edx+12]
	comiss	xmm0, DWORD PTR _southBoundry$[ebp+ecx+12]
	jb	SHORT $LN7@ClipVertic

; 565  : 				s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 566  : 
; 567  : 				if (span->Lsector.insideEdge > southBoundry[s].end) {

	mov	ecx, DWORD PTR _s$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+92]
	comiss	xmm0, DWORD PTR _southBoundry$[ebp+ecx+12]
	jbe	SHORT $LN6@ClipVertic

; 568  : 					break;

	jmp	SHORT $LN7@ClipVertic
$LN6@ClipVertic:

; 569  : 				}
; 570  : 			}

	jmp	SHORT $LN8@ClipVertic
$LN7@ClipVertic:

; 571  : 
; 572  : 			// Nothing on these spans if we've exhausted our edges
; 573  : 			if (span->Lsector.insideEdge <= southBoundry[s].end) {

	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _southBoundry$[ebp+eax+12]
	comiss	xmm0, DWORD PTR [ecx+92]
	jb	SHORT $LN5@ClipVertic

; 574  : 				span->Lsector.minEndPoint	= MAX_POSTIVE_F;

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [edx+96], xmm0

; 575  : 				span->Lsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [eax+100], xmm0

; 576  : 				continue;

	jmp	$LN13@ClipVertic
$LN5@ClipVertic:

; 577  : 			}
; 578  : 
; 579  : 			ShiAssert( s < 3 );
; 580  : 			ShiAssert( southBoundry[s].end <= southBoundry[s-1].end );
; 581  : 		}
; 582  : 		if (span->Lsector.insideEdge <= northBoundry[n].end) {

	mov	ecx, DWORD PTR _n$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _northBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR [edx+92]
	jb	SHORT $LN2@ClipVertic
$LN3@ClipVertic:

; 583  : 
; 584  : 			// Try to find an edge that will advance us at least one row
; 585  : 			while (northBoundry[n+1].end <= northBoundry[n].end) {

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _n$[ebp]
	shl	ecx, 4
	movss	xmm0, DWORD PTR _northBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR _northBoundry$[ebp+eax+12]
	jb	SHORT $LN2@ClipVertic

; 586  : 				n++;

	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx

; 587  : 
; 588  : 				if (span->Lsector.insideEdge > northBoundry[n].end) {

	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+92]
	comiss	xmm0, DWORD PTR _northBoundry$[ebp+eax+12]
	jbe	SHORT $LN1@ClipVertic

; 589  : 					break;

	jmp	SHORT $LN2@ClipVertic
$LN1@ClipVertic:

; 590  : 				}
; 591  : 			}

	jmp	SHORT $LN3@ClipVertic
$LN2@ClipVertic:

; 592  : 
; 593  : 			// We can't exhaust this edge without having already exhausted the one above
; 594  : //			ShiAssert( n > 0 );		// We _must_ have taken a step in the while above
; 595  : //			ShiAssert( n < 3 );
; 596  : //			ShiAssert( northBoundry[n].end <= northBoundry[n-1].end );
; 597  : 		}
; 598  : 
; 599  : 
; 600  : 		// Compute the intersection of this span with the bounding region
; 601  : 		span->Lsector.minEndPoint = southBoundry[s].edge.X( (float)span->Lsector.insideEdge );

	mov	edx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+92]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _southBoundry$[ebp+eax]
	call	?X@Edge@@QAEMM@Z			; Edge::X
	mov	ecx, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [ecx+96]

; 602  : 		span->Lsector.maxEndPoint = northBoundry[n].edge.X( (float)span->Lsector.insideEdge );

	mov	edx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+92]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _northBoundry$[ebp+eax]
	call	?X@Edge@@QAEMM@Z			; Edge::X
	mov	ecx, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [ecx+100]

; 603  : 	}

	jmp	$LN13@ClipVertic
$LN12@ClipVertic:

; 604  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	edx, DWORD PTR _southBoundry$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _northBoundry$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ClipVerticalSectors@RenderOTW@@IAEXXZ$0:
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _northBoundry$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__unwindfunclet$?ClipVerticalSectors@RenderOTW@@IAEXXZ$1:
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _southBoundry$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__ehhandler$?ClipVerticalSectors@RenderOTW@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ClipVerticalSectors@RenderOTW@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ClipVerticalSectors@RenderOTW@@IAEXXZ ENDP		; RenderOTW::ClipVerticalSectors
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
tv545 = -172						; size = 4
_LOD$ = -168						; size = 4
_startLocation$ = -164					; size = 4
_e$ = -160						; size = 4
_w$ = -156						; size = 4
_span$ = -152						; size = 4
_this$ = -148						; size = 4
_eastBoundry$ = -144					; size = 64
_westBoundry$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ClipHorizontalSectors@RenderOTW@@IAEXXZ PROC		; RenderOTW::ClipHorizontalSectors
; _this$ = ecx

; 172  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ClipHorizontalSectors@RenderOTW@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 	SpanListEntry	*span=NULL;

	mov	DWORD PTR _span$[ebp], 0

; 174  : 	int				LOD=0;

	mov	DWORD PTR _LOD$[ebp], 0

; 175  : 	int				w=0, e=0;

	mov	DWORD PTR _w$[ebp], 0
	mov	DWORD PTR _e$[ebp], 0

; 176  : 	float			startLocation=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 177  : 	BoundSegment	eastBoundry[4];

	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	OFFSET ??0BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _eastBoundry$[ebp]
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 178  : 	BoundSegment	westBoundry[4];

	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	OFFSET ??0BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	ecx, DWORD PTR _westBoundry$[ebp]
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 179  : 
; 180  : 
; 181  : 	// Construct the ordered edge list (horizontal span case - X buckets (since X is North/Up))
; 182  : 	if ( Yaw() > PI ) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Yaw@Render3D@@QAEMXZ			; Render3D::Yaw
	fstp	DWORD PTR tv545[ebp]
	movss	xmm0, DWORD PTR tv545[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	$LN34@ClipHorizo

; 183  : 		// Necessarily, rightX2 >= leftX2
; 184  : 		if (rightX1 > rightX2) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263256]
	comiss	xmm0, DWORD PTR [eax+263260]
	jbe	$LN33@ClipHorizo

; 185  : 			// Right front corner is north most
; 186  : 			startLocation = rightX1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263256]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 187  : 			westBoundry[0].edge = right_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263324				; 0004049cH
	mov	eax, 16					; 00000010H
	imul	eax, 0
	lea	ecx, DWORD PTR _westBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 188  : 			westBoundry[1].edge = back_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263300				; 00040484H
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _westBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 189  : 			westBoundry[2].edge = left_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _westBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 190  : 			westBoundry[0].end = rightX2;

	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263260]
	mov	DWORD PTR _westBoundry$[ebp+edx+12], ecx

; 191  : 			westBoundry[1].end = leftX2;

	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263276]
	mov	DWORD PTR _westBoundry$[ebp+edx+12], ecx

; 192  : 			westBoundry[2].end = leftX1;

	mov	edx, 16					; 00000010H
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263272]
	mov	DWORD PTR _westBoundry$[ebp+edx+12], ecx

; 193  : 			eastBoundry[0].edge = front_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263288				; 00040478H
	mov	eax, 16					; 00000010H
	imul	eax, 0
	lea	ecx, DWORD PTR _eastBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 194  : 			eastBoundry[1].edge = left_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263312				; 00040490H
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _eastBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 195  : 			eastBoundry[2].edge = back_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _eastBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 196  : 			eastBoundry[0].end = leftX1;

	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263272]
	mov	DWORD PTR _eastBoundry$[ebp+edx+12], ecx

; 197  : 			eastBoundry[1].end = leftX2;

	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263276]
	mov	DWORD PTR _eastBoundry$[ebp+edx+12], ecx

; 198  : 			eastBoundry[2].end = rightX2;

	mov	edx, 16					; 00000010H
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263260]
	mov	DWORD PTR _eastBoundry$[ebp+edx+12], ecx

; 199  : 		} else {

	jmp	$LN32@ClipHorizo
$LN33@ClipHorizo:

; 200  : 			// Right back corner is north most
; 201  : 			startLocation = rightX2;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263260]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 202  : 			westBoundry[0].edge = back_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263300				; 00040484H
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _westBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 203  : 			westBoundry[1].edge = left_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _westBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 204  : 			westBoundry[2].edge = front_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263288				; 00040478H
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _westBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 205  : 			westBoundry[0].end = leftX2;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263276]
	mov	DWORD PTR _westBoundry$[ebp+eax+12], edx

; 206  : 			westBoundry[1].end = leftX1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263272]
	mov	DWORD PTR _westBoundry$[ebp+eax+12], edx

; 207  : 			westBoundry[2].end = rightX1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263256]
	mov	DWORD PTR _westBoundry$[ebp+eax+12], edx

; 208  : 			eastBoundry[0].edge = right_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263324				; 0004049cH
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _eastBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 209  : 			eastBoundry[1].edge = front_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263288				; 00040478H
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _eastBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 210  : 			eastBoundry[2].edge = left_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263312				; 00040490H
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _eastBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 211  : 			eastBoundry[0].end = rightX1;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263256]
	mov	DWORD PTR _eastBoundry$[ebp+eax+12], edx

; 212  : 			eastBoundry[1].end = leftX1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263272]
	mov	DWORD PTR _eastBoundry$[ebp+eax+12], edx

; 213  : 			eastBoundry[2].end = leftX2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263276]
	mov	DWORD PTR _eastBoundry$[ebp+eax+12], edx
$LN32@ClipHorizo:

; 214  : 		}
; 215  : 	} else {

	jmp	$LN29@ClipHorizo
$LN34@ClipHorizo:

; 216  : 		// Necessarily, rightX2 <= leftX2
; 217  : 		if (leftX1 > leftX2) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263272]
	comiss	xmm0, DWORD PTR [ecx+263276]
	jbe	$LN30@ClipHorizo

; 218  : 			// Left front corner is north most
; 219  : 			startLocation = leftX1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263272]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 220  : 			westBoundry[0].edge = front_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263288				; 00040478H
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _westBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 221  : 			westBoundry[1].edge = right_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263324				; 0004049cH
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _westBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 222  : 			westBoundry[2].edge = back_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263300				; 00040484H
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _westBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 223  : 			westBoundry[0].end = rightX1;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263256]
	mov	DWORD PTR _westBoundry$[ebp+eax+12], edx

; 224  : 			westBoundry[1].end = rightX2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263260]
	mov	DWORD PTR _westBoundry$[ebp+eax+12], edx

; 225  : 			westBoundry[2].end = leftX2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263276]
	mov	DWORD PTR _westBoundry$[ebp+eax+12], edx

; 226  : 			eastBoundry[0].edge = left_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263312				; 00040490H
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR _eastBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 227  : 			eastBoundry[1].edge = back_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _eastBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 228  : 			eastBoundry[2].edge = right_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263324				; 0004049cH
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _eastBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 229  : 			eastBoundry[0].end = leftX2;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263276]
	mov	DWORD PTR _eastBoundry$[ebp+eax+12], edx

; 230  : 			eastBoundry[1].end = rightX2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263260]
	mov	DWORD PTR _eastBoundry$[ebp+eax+12], edx

; 231  : 			eastBoundry[2].end = rightX1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263256]
	mov	DWORD PTR _eastBoundry$[ebp+eax+12], edx

; 232  : 		} else {

	jmp	$LN29@ClipHorizo
$LN30@ClipHorizo:

; 233  : 			// Left back corner is north most
; 234  : 			startLocation = leftX2;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+263276]
	movss	DWORD PTR _startLocation$[ebp], xmm0

; 235  : 			westBoundry[0].edge = left_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	mov	edx, 16					; 00000010H
	imul	edx, 0
	lea	eax, DWORD PTR _westBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 236  : 			westBoundry[1].edge = front_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263288				; 00040478H
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _westBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 237  : 			westBoundry[2].edge = right_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263324				; 0004049cH
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _westBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 238  : 			westBoundry[0].end = leftX1;

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263272]
	mov	DWORD PTR _westBoundry$[ebp+ecx+12], eax

; 239  : 			westBoundry[1].end = rightX1;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263256]
	mov	DWORD PTR _westBoundry$[ebp+ecx+12], eax

; 240  : 			westBoundry[2].end = rightX2;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263260]
	mov	DWORD PTR _westBoundry$[ebp+ecx+12], eax

; 241  : 			eastBoundry[0].edge = back_edge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	mov	edx, 16					; 00000010H
	imul	edx, 0
	lea	eax, DWORD PTR _eastBoundry$[ebp+edx]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 242  : 			eastBoundry[1].edge = right_edge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 263324				; 0004049cH
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _eastBoundry$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 243  : 			eastBoundry[2].edge = front_edge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 263288				; 00040478H
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _eastBoundry$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 244  : 			eastBoundry[0].end = rightX2;

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263260]
	mov	DWORD PTR _eastBoundry$[ebp+ecx+12], eax

; 245  : 			eastBoundry[1].end = rightX1;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263256]
	mov	DWORD PTR _eastBoundry$[ebp+ecx+12], eax

; 246  : 			eastBoundry[2].end = leftX1;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263272]
	mov	DWORD PTR _eastBoundry$[ebp+ecx+12], eax
$LN29@ClipHorizo:

; 247  : 		}
; 248  : 	}
; 249  : 
; 250  : 	// Terminated the edge chain with a point greater than any possible to ensure we see an "upturn"
; 251  : 	eastBoundry[3].end = MAX_POSTIVE_F;

	mov	ecx, 16					; 00000010H
	imul	ecx, 3
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR _eastBoundry$[ebp+ecx+12], xmm0

; 252  : 	westBoundry[3].end = MAX_POSTIVE_F;

	mov	edx, 16					; 00000010H
	imul	edx, 3
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR _westBoundry$[ebp+edx+12], xmm0

; 253  : 
; 254  : 
; 255  : 	// Force a fresh start by noting an illegal "current" LOD
; 256  : 	LOD = -1;

	mov	DWORD PTR _LOD$[ebp], -1

; 257  : 
; 258  : 	// Now clip the top horizontal spans to the bounding region
; 259  : 	for (span = spanList; span != firstEmptySpan; span++) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263348]
	mov	DWORD PTR _span$[ebp], ecx
	jmp	SHORT $LN28@ClipHorizo
$LN27@ClipHorizo:
	mov	edx, DWORD PTR _span$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
$LN28@ClipHorizo:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _span$[ebp]
	cmp	ecx, DWORD PTR [eax+263352]
	je	$LN26@ClipHorizo

; 260  : 
; 261  : 		// Spans are  empty until we get to the top corner of the bounding region
; 262  : 		if (span->Tsector.insideEdge > startLocation) {

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR _startLocation$[ebp]
	jbe	SHORT $LN25@ClipHorizo

; 263  : 			span->Tsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [eax+16], xmm0

; 264  : 			span->Tsector.minEndPoint	= MAX_POSTIVE_F;

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [ecx+12], xmm0

; 265  : 			continue;

	jmp	SHORT $LN27@ClipHorizo
$LN25@ClipHorizo:

; 266  : 		}
; 267  : 
; 268  : 		// Restart the edge traversal since the spans can take a step backward at LOD change
; 269  : 		if (span->LOD != LOD) {

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _LOD$[ebp]
	je	SHORT $LN24@ClipHorizo

; 270  : 			LOD = span->LOD;

	mov	ecx, DWORD PTR _span$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _LOD$[ebp], edx

; 271  : 			e = w = 0;

	mov	DWORD PTR _w$[ebp], 0
	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _e$[ebp], eax
$LN24@ClipHorizo:

; 272  : 		}
; 273  : 
; 274  : 		// Switch controlling edges when required
; 275  : 		if (span->Tsector.insideEdge <= westBoundry[w].end) {

	mov	ecx, DWORD PTR _w$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _westBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR [edx+8]
	jb	$LN19@ClipHorizo
$LN22@ClipHorizo:

; 276  : 
; 277  : 			// Try to find an edge that will advance us at least one row
; 278  : 			while ( westBoundry[w+1].end <= westBoundry[w].end ) {

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _w$[ebp]
	shl	ecx, 4
	movss	xmm0, DWORD PTR _westBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR _westBoundry$[ebp+eax+12]
	jb	SHORT $LN21@ClipHorizo

; 279  : 				w++;

	mov	edx, DWORD PTR _w$[ebp]
	add	edx, 1
	mov	DWORD PTR _w$[ebp], edx

; 280  : 
; 281  : 				if (span->Tsector.insideEdge > westBoundry[w].end) {

	mov	eax, DWORD PTR _w$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR _westBoundry$[ebp+eax+12]
	jbe	SHORT $LN20@ClipHorizo

; 282  : 					break;

	jmp	SHORT $LN21@ClipHorizo
$LN20@ClipHorizo:

; 283  : 				}
; 284  : 			}

	jmp	SHORT $LN22@ClipHorizo
$LN21@ClipHorizo:

; 285  : 
; 286  : 			// Nothing on these spans if we've exhausted our edges
; 287  : 			if (span->Tsector.insideEdge <= westBoundry[w].end) {

	mov	edx, DWORD PTR _w$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _westBoundry$[ebp+edx+12]
	comiss	xmm0, DWORD PTR [eax+8]
	jb	SHORT $LN19@ClipHorizo

; 288  : 				span->Tsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [ecx+16], xmm0

; 289  : 				span->Tsector.minEndPoint	= MAX_POSTIVE_F;

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [edx+12], xmm0

; 290  : 				continue;

	jmp	$LN27@ClipHorizo
$LN19@ClipHorizo:

; 291  : 			}
; 292  : 
; 293  : 			ShiAssert( w < 3 );
; 294  : 			ShiAssert( westBoundry[w].end <= westBoundry[w-1].end );
; 295  : 		}
; 296  : 		if (span->Tsector.insideEdge <= eastBoundry[e].end) {

	mov	eax, DWORD PTR _e$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _eastBoundry$[ebp+eax+12]
	comiss	xmm0, DWORD PTR [ecx+8]
	jb	SHORT $LN16@ClipHorizo
$LN17@ClipHorizo:

; 297  : 
; 298  : 			// Try to find an edge that will advance us at least one row
; 299  : 			while ( eastBoundry[e+1].end <= eastBoundry[e].end ) {

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _e$[ebp]
	shl	eax, 4
	movss	xmm0, DWORD PTR _eastBoundry$[ebp+eax+12]
	comiss	xmm0, DWORD PTR _eastBoundry$[ebp+edx+12]
	jb	SHORT $LN16@ClipHorizo

; 300  : 				e++;

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1
	mov	DWORD PTR _e$[ebp], ecx

; 301  : 
; 302  : 				if (span->Tsector.insideEdge > eastBoundry[e].end) {

	mov	edx, DWORD PTR _e$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR _eastBoundry$[ebp+edx+12]
	jbe	SHORT $LN15@ClipHorizo

; 303  : 					break;

	jmp	SHORT $LN16@ClipHorizo
$LN15@ClipHorizo:

; 304  : 				}
; 305  : 			}

	jmp	SHORT $LN17@ClipHorizo
$LN16@ClipHorizo:

; 306  : 
; 307  : 			// We can't exhaust this edge without having already exhausted the one above
; 308  : //			ShiAssert( span->Tsector.insideEdge > eastBoundry[e].end );
; 309  : //			ShiAssert( e > 0 );		// We _must_ have taken a step in the while above
; 310  : //			ShiAssert( e < 3 );
; 311  : //			ShiAssert( eastBoundry[e].end <= eastBoundry[e-1].end );
; 312  : 		}
; 313  : 
; 314  : 
; 315  : 		// Compute the intersection of this span with the bounding region
; 316  : 		span->Tsector.minEndPoint = westBoundry[w].edge.Y( (float)span->Tsector.insideEdge );

	mov	ecx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _w$[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR _westBoundry$[ebp+edx]
	call	?Y@Edge@@QAEMM@Z			; Edge::Y
	mov	eax, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [eax+12]

; 317  : 		span->Tsector.maxEndPoint = eastBoundry[e].edge.Y( (float)span->Tsector.insideEdge );

	mov	ecx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR _eastBoundry$[ebp+edx]
	call	?Y@Edge@@QAEMM@Z			; Edge::Y
	mov	eax, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [eax+16]

; 318  : 	}

	jmp	$LN27@ClipHorizo
$LN26@ClipHorizo:

; 319  : 
; 320  : 	// Force a fresh start by noting an illegal "current" LOD
; 321  : 	LOD = -1;

	mov	DWORD PTR _LOD$[ebp], -1

; 322  : 
; 323  : 	// Now fill in the extents of spans at the bottom of the bounding region
; 324  : 	for (span = firstEmptySpan-1; span >= spanList; span--) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263352]
	sub	edx, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], edx
	jmp	SHORT $LN14@ClipHorizo
$LN13@ClipHorizo:
	mov	eax, DWORD PTR _span$[ebp]
	sub	eax, 120				; 00000078H
	mov	DWORD PTR _span$[ebp], eax
$LN14@ClipHorizo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _span$[ebp]
	cmp	edx, DWORD PTR [ecx+263348]
	jb	$LN12@ClipHorizo

; 325  : 
; 326  : 		// Spans are empty until we get to the top corner of the bounding region
; 327  : 		if (span->Bsector.insideEdge > startLocation) {

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	comiss	xmm0, DWORD PTR _startLocation$[ebp]
	jbe	SHORT $LN11@ClipHorizo

; 328  : 			span->Bsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [ecx+72], xmm0

; 329  : 			span->Bsector.minEndPoint	= MAX_POSTIVE_F;

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [edx+68], xmm0

; 330  : 			continue;

	jmp	SHORT $LN13@ClipHorizo
$LN11@ClipHorizo:

; 331  : 		}
; 332  : 	
; 333  : 		// Restart the edge traversal since the spans can take a step backward at LOD change
; 334  : 		if (span->LOD != LOD) {

	mov	eax, DWORD PTR _span$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _LOD$[ebp]
	je	SHORT $LN10@ClipHorizo

; 335  : 			LOD = span->LOD;

	mov	edx, DWORD PTR _span$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _LOD$[ebp], eax

; 336  : 			e = w = 0;

	mov	DWORD PTR _w$[ebp], 0
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _e$[ebp], ecx
$LN10@ClipHorizo:

; 337  : 		}
; 338  : 
; 339  : 		// Switch controlling edges when required
; 340  : 		if (span->Bsector.insideEdge <= westBoundry[w].end) {

	mov	edx, DWORD PTR _w$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _westBoundry$[ebp+edx+12]
	comiss	xmm0, DWORD PTR [eax+64]
	jb	$LN5@ClipHorizo
$LN8@ClipHorizo:

; 341  : 
; 342  : 			// Try to find an edge that will advance us at least one row
; 343  : 			while (westBoundry[w+1].end <= westBoundry[w].end) {

	mov	ecx, DWORD PTR _w$[ebp]
	add	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _w$[ebp]
	shl	edx, 4
	movss	xmm0, DWORD PTR _westBoundry$[ebp+edx+12]
	comiss	xmm0, DWORD PTR _westBoundry$[ebp+ecx+12]
	jb	SHORT $LN7@ClipHorizo

; 344  : 				w++;

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 1
	mov	DWORD PTR _w$[ebp], eax

; 345  : 
; 346  : 				if (span->Bsector.insideEdge > westBoundry[w].end) {

	mov	ecx, DWORD PTR _w$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	comiss	xmm0, DWORD PTR _westBoundry$[ebp+ecx+12]
	jbe	SHORT $LN6@ClipHorizo

; 347  : 					break;

	jmp	SHORT $LN7@ClipHorizo
$LN6@ClipHorizo:

; 348  : 				}
; 349  : 			}

	jmp	SHORT $LN8@ClipHorizo
$LN7@ClipHorizo:

; 350  : 
; 351  : 			// Nothing on these spans if we've exhausted our edges
; 352  : 			if (span->Bsector.insideEdge <= westBoundry[w].end) {

	mov	eax, DWORD PTR _w$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _westBoundry$[ebp+eax+12]
	comiss	xmm0, DWORD PTR [ecx+64]
	jb	SHORT $LN5@ClipHorizo

; 353  : 				span->Bsector.maxEndPoint	= MAX_NEGATIVE_F;

	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_NEGATIVE_F
	movss	DWORD PTR [edx+72], xmm0

; 354  : 				span->Bsector.minEndPoint	= MAX_POSTIVE_F;

	mov	eax, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _MAX_POSTIVE_F
	movss	DWORD PTR [eax+68], xmm0

; 355  : 				continue;

	jmp	$LN13@ClipHorizo
$LN5@ClipHorizo:

; 356  : 			}
; 357  : 
; 358  : 			ShiAssert( w < 3 );
; 359  : 			ShiAssert( westBoundry[w].end <= westBoundry[w-1].end );
; 360  : 		}
; 361  : 		if (span->Bsector.insideEdge <= eastBoundry[e].end) {

	mov	ecx, DWORD PTR _e$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR _eastBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR [edx+64]
	jb	SHORT $LN2@ClipHorizo
$LN3@ClipHorizo:

; 362  : 
; 363  : 			// Try to find an edge that will advance us at least one row
; 364  : 			while ( eastBoundry[e+1].end <= eastBoundry[e].end ) {

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _e$[ebp]
	shl	ecx, 4
	movss	xmm0, DWORD PTR _eastBoundry$[ebp+ecx+12]
	comiss	xmm0, DWORD PTR _eastBoundry$[ebp+eax+12]
	jb	SHORT $LN2@ClipHorizo

; 365  : 				e++;

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 1
	mov	DWORD PTR _e$[ebp], edx

; 366  : 
; 367  : 				if (span->Bsector.insideEdge > eastBoundry[e].end) {

	mov	eax, DWORD PTR _e$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _span$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	comiss	xmm0, DWORD PTR _eastBoundry$[ebp+eax+12]
	jbe	SHORT $LN1@ClipHorizo

; 368  : 					break;

	jmp	SHORT $LN2@ClipHorizo
$LN1@ClipHorizo:

; 369  : 				}
; 370  : 			}

	jmp	SHORT $LN3@ClipHorizo
$LN2@ClipHorizo:

; 371  : 
; 372  : 			// We can't exhaust this edge without having already exhausted the one above
; 373  : //			ShiAssert( e > 0 );		// We _must_ have taken a step in the while above
; 374  : //			ShiAssert( e < 3 );
; 375  : //			ShiAssert( eastBoundry[e].end <= eastBoundry[e-1].end );
; 376  : 		}
; 377  : 
; 378  : 
; 379  : 		// Compute the intersection of this span with the bounding region
; 380  : 		span->Bsector.minEndPoint = westBoundry[w].edge.Y( (float)span->Bsector.insideEdge );

	mov	edx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+64]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _w$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _westBoundry$[ebp+eax]
	call	?Y@Edge@@QAEMM@Z			; Edge::Y
	mov	ecx, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [ecx+68]

; 381  : 		span->Bsector.maxEndPoint = eastBoundry[e].edge.Y( (float)span->Bsector.insideEdge );

	mov	edx, DWORD PTR _span$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+64]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _eastBoundry$[ebp+eax]
	call	?Y@Edge@@QAEMM@Z			; Edge::Y
	mov	ecx, DWORD PTR _span$[ebp]
	fstp	DWORD PTR [ecx+72]

; 382  : 	}

	jmp	$LN13@ClipHorizo
$LN12@ClipHorizo:

; 383  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	edx, DWORD PTR _westBoundry$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _eastBoundry$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ClipHorizontalSectors@RenderOTW@@IAEXXZ$0:
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _eastBoundry$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__unwindfunclet$?ClipHorizontalSectors@RenderOTW@@IAEXXZ$1:
	push	OFFSET ??1BoundSegment@@QAE@XZ
	push	4
	push	16					; 00000010H
	lea	eax, DWORD PTR _westBoundry$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__ehhandler$?ClipHorizontalSectors@RenderOTW@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ClipHorizontalSectors@RenderOTW@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ClipHorizontalSectors@RenderOTW@@IAEXXZ ENDP		; RenderOTW::ClipHorizontalSectors
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
tv535 = -28						; size = 4
tv519 = -24						; size = 4
_startRing$ = -20					; size = 4
_stopRing$ = -16					; size = 4
_ring$ = -12						; size = 4
_LOD$ = -8						; size = 4
_this$ = -4						; size = 4
?BuildRingList@RenderOTW@@IAEXXZ PROC			; RenderOTW::BuildRingList
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	int				LOD;
; 33   : 	int				startRing;
; 34   : 	int				stopRing;
; 35   : 	int				ring;
; 36   : 
; 37   : 
; 38   : 	ShiAssert( IsReady() );
; 39   : 
; 40   : 
; 41   : 	//
; 42   : 	// Start a new span list
; 43   : 	//
; 44   : 	firstEmptySpan = spanList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263348]
	mov	DWORD PTR [eax+263352], edx

; 45   : 
; 46   : 
; 47   : 	//
; 48   : 	// Setup the data we need for each LOD
; 49   : 	//
; 50   : 	for ( LOD = viewpoint->GetLowLOD(); LOD >= viewpoint->GetHighLOD(); LOD-- ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetLowLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetLowLOD
	mov	DWORD PTR _LOD$[ebp], eax
	jmp	SHORT $LN15@BuildRingL
$LN14@BuildRingL:
	mov	ecx, DWORD PTR _LOD$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _LOD$[ebp], ecx
$LN15@BuildRingL:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetHighLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetHighLOD
	cmp	DWORD PTR _LOD$[ebp], eax
	jl	$LN13@BuildRingL

; 51   : 
; 52   : 		// Get the available range for each LOD
; 53   : 		LODdata[LOD].availablePostRange = viewpoint->GetAvailablePostRange( LOD );

	mov	eax, DWORD PTR _LOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetAvailablePostRange@TViewPoint@@QAEHH@Z ; TViewPoint::GetAvailablePostRange
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263364]
	mov	DWORD PTR [ecx+edx+36], eax

; 54   : 
; 55   : 		// Decide which post is to be the center of the rings at this level
; 56   : 		LODdata[LOD].centerRow = (int)WORLD_TO_LEVEL_POST( viewpoint->X(), LOD );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?X@TViewPoint@@QAEMXZ			; TViewPoint::X
	fstp	DWORD PTR tv519[ebp]
	movss	xmm0, DWORD PTR tv519[ebp]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _LOD$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	mov	DWORD PTR [edx+ecx+40], eax

; 57   : 		LODdata[LOD].centerCol = (int)WORLD_TO_LEVEL_POST( viewpoint->Y(), LOD );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?Y@TViewPoint@@QAEMXZ			; TViewPoint::Y
	fstp	DWORD PTR tv535[ebp]
	movss	xmm0, DWORD PTR tv535[ebp]
	divss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?floor@@YAMM@Z				; floor
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _LOD$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	mov	DWORD PTR [edx+ecx+44], eax

; 58   : 
; 59   : 		// Determine the location of the glue row and column at the outside of this LOD region
; 60   : 		// NOTE:  These two must evaluate to zero or one, as they are used arithmetically
; 61   : 		LODdata[LOD].glueOnBottom   = LODdata[LOD].centerRow & 1;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [edx+eax+40]
	and	eax, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	mov	DWORD PTR [edx+ecx+48], eax

; 62   : 		LODdata[LOD].glueOnLeft		= LODdata[LOD].centerCol & 1;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263364]
	mov	eax, DWORD PTR [edx+eax+44]
	and	eax, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263364]
	mov	DWORD PTR [edx+ecx+52], eax

; 63   : 
; 64   : 
; 65   : #ifdef TWO_D_MAP_AVAILABLE
; 66   : 		if (twoDmode) {
; 67   : 			char	message[80];
; 68   : 			SetColor( 0xFFFFFFFF );
; 69   : 			sprintf( message, "LOD%0d Glue: %s %s", LOD, 
; 70   : 				LODdata[LOD].glueOnBottom ? "Bottom" : "Top",
; 71   : 				LODdata[LOD].glueOnLeft   ? "Left"   : "Right" );
; 72   : 			ScreenText( 0.0f, 8.0f * LOD, message );
; 73   : 		}
; 74   : #endif	
; 75   : 
; 76   : 
; 77   : 		// Compute and record the camera space versions of the X, Y, and Z world space axes
; 78   : 		// Scale for LOD's horizontal step size
; 79   : 		LODdata[LOD].Xstep[0] = T.M11 * LEVEL_POST_TO_WORLD( 1, LOD );

	mov	eax, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	eax, cl
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+263008]
	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+263364]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [edx+ecx], xmm0

; 80   : 		LODdata[LOD].Xstep[1] = T.M21 * LEVEL_POST_TO_WORLD( 1, LOD );

	mov	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+263020]
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+263364]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 81   : 		LODdata[LOD].Xstep[2] = T.M31 * LEVEL_POST_TO_WORLD( 1, LOD );

	mov	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+263032]
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+263364]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [ecx+eax], xmm0

; 82   : 
; 83   : 		// Scale for LOD's horizontal step size
; 84   : 		LODdata[LOD].Ystep[0] = T.M12 * LEVEL_POST_TO_WORLD( 1, LOD );

	mov	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+263012]
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+263364]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [ecx+eax+12], xmm0

; 85   : 		LODdata[LOD].Ystep[1] = T.M22 * LEVEL_POST_TO_WORLD( 1, LOD );

	mov	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+263024]
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+263364]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [ecx+eax+12], xmm0

; 86   : 		LODdata[LOD].Ystep[2] = T.M32 * LEVEL_POST_TO_WORLD( 1, LOD );

	mov	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+263036]
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+263364]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [ecx+eax+12], xmm0

; 87   : 
; 88   : 		// Leave in world space units of feet
; 89   : 		LODdata[LOD].Zstep[0] = T.M13;

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+263364]
	mov	eax, 4
	imul	eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+263016]
	mov	DWORD PTR [ecx+eax+24], edx

; 90   : 		LODdata[LOD].Zstep[1] = T.M23;

	mov	eax, DWORD PTR _LOD$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+263364]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263028]
	mov	DWORD PTR [eax+edx+24], ecx

; 91   : 		LODdata[LOD].Zstep[2] = T.M33;

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+263364]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+263040]
	mov	DWORD PTR [edx+ecx+24], eax

; 92   : 	}

	jmp	$LN14@BuildRingL
$LN13@BuildRingL:

; 93   : 
; 94   : 
; 95   : 	//
; 96   : 	// Determine and record which rings we need to draw at each LOD
; 97   : 	//
; 98   : 
; 99   : 	// Start the rings at the most distant available post
; 100  : 	startRing = LODdata[ viewpoint->GetLowLOD() ].availablePostRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetLowLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetLowLOD
	imul	eax, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR [ecx+eax+36]
	mov	DWORD PTR _startRing$[ebp], edx

; 101  : 
; 102  : 	// We will consider rings at each level of detail from lowest detail to highest
; 103  : 	for ( LOD = viewpoint->GetLowLOD(); LOD >= viewpoint->GetHighLOD(); LOD-- ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetLowLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetLowLOD
	mov	DWORD PTR _LOD$[ebp], eax
	jmp	SHORT $LN12@BuildRingL
$LN11@BuildRingL:
	mov	ecx, DWORD PTR _LOD$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _LOD$[ebp], ecx
$LN12@BuildRingL:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+263088]
	call	?GetHighLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetHighLOD
	cmp	DWORD PTR _LOD$[ebp], eax
	jl	$LN10@BuildRingL

; 104  : 
; 105  : 		// Figure where to stop this LOD and move to the next
; 106  : 		if (LOD != viewpoint->GetHighLOD()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetHighLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetHighLOD
	cmp	DWORD PTR _LOD$[ebp], eax
	je	SHORT $LN9@BuildRingL

; 107  : 
; 108  : 			// The stop ring is one ring in from the first available ring at the next LOD
; 109  : 			stopRing = (LODdata[LOD-1].availablePostRange >> 1) - 1;

	mov	ecx, DWORD PTR _LOD$[ebp]
	sub	ecx, 1
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	ecx, DWORD PTR [eax+ecx+36]
	sar	ecx, 1
	sub	ecx, 1
	mov	DWORD PTR _stopRing$[ebp], ecx

; 110  : 
; 111  : 			// Make sure we have enough space for connectors at each LOD
; 112  : 			if (stopRing > startRing-3) {

	mov	edx, DWORD PTR _startRing$[ebp]
	sub	edx, 3
	cmp	DWORD PTR _stopRing$[ebp], edx
	jle	SHORT $LN8@BuildRingL

; 113  : 				stopRing = startRing-3;

	mov	eax, DWORD PTR _startRing$[ebp]
	sub	eax, 3
	mov	DWORD PTR _stopRing$[ebp], eax
$LN8@BuildRingL:

; 114  : 			}
; 115  : 
; 116  : 			// Stop at zero in any case
; 117  : 			if (stopRing < 0) {

	cmp	DWORD PTR _stopRing$[ebp], 0
	jge	SHORT $LN7@BuildRingL

; 118  : 				stopRing = 0;

	mov	DWORD PTR _stopRing$[ebp], 0
$LN7@BuildRingL:

; 119  : 			}
; 120  : 		} else {

	jmp	SHORT $LN6@BuildRingL
$LN9@BuildRingL:

; 121  : 			stopRing = 0;

	mov	DWORD PTR _stopRing$[ebp], 0
$LN6@BuildRingL:

; 122  : 		} 
; 123  : 
; 124  : 		ShiAssert( startRing <= maxSpanOffset );
; 125  : 		ShiAssert( stopRing >= 0 );
; 126  : 
; 127  : 		for ( ring = startRing; ring >= stopRing; ring-- ) {

	mov	ecx, DWORD PTR _startRing$[ebp]
	mov	DWORD PTR _ring$[ebp], ecx
	jmp	SHORT $LN5@BuildRingL
$LN4@BuildRingL:
	mov	edx, DWORD PTR _ring$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ring$[ebp], edx
$LN5@BuildRingL:
	mov	eax, DWORD PTR _ring$[ebp]
	cmp	eax, DWORD PTR _stopRing$[ebp]
	jl	$LN3@BuildRingL

; 128  : 
; 129  : 			ShiAssert( firstEmptySpan < spanList + spanListMaxEntries );
; 130  : 			ShiAssert( ring <= LODdata[LOD].availablePostRange );
; 131  : 
; 132  : 			firstEmptySpan->ring = ring;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263352]
	mov	eax, DWORD PTR _ring$[ebp]
	mov	DWORD PTR [edx], eax

; 133  : 			firstEmptySpan->LOD = LOD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263352]
	mov	eax, DWORD PTR _LOD$[ebp]
	mov	DWORD PTR [edx+4], eax

; 134  : 			
; 135  : 			// Figure out the actual location of each side of this ring
; 136  : 			firstEmptySpan->Tsector.insideEdge = LEVEL_POST_TO_WORLD( LODdata[LOD].centerRow + ring,     LOD );

	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263364]
	mov	edx, DWORD PTR [eax+ecx+40]
	add	edx, DWORD PTR _ring$[ebp]
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	movss	DWORD PTR [ecx+8], xmm0

; 137  : 			firstEmptySpan->Bsector.insideEdge = LEVEL_POST_TO_WORLD( LODdata[LOD].centerRow - ring + 1, LOD );

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+40]
	sub	edx, DWORD PTR _ring$[ebp]
	add	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	movss	DWORD PTR [ecx+64], xmm0

; 138  : 			firstEmptySpan->Rsector.insideEdge = LEVEL_POST_TO_WORLD( LODdata[LOD].centerCol + ring,     LOD );

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+44]
	add	edx, DWORD PTR _ring$[ebp]
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	movss	DWORD PTR [ecx+36], xmm0

; 139  : 			firstEmptySpan->Lsector.insideEdge = LEVEL_POST_TO_WORLD( LODdata[LOD].centerCol - ring + 1, LOD );

	mov	edx, DWORD PTR _LOD$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263364]
	mov	edx, DWORD PTR [ecx+edx+44]
	sub	edx, DWORD PTR _ring$[ebp]
	add	edx, 1
	mov	ecx, DWORD PTR _LOD$[ebp]
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	movss	DWORD PTR [ecx+92], xmm0

; 140  : 
; 141  : 			firstEmptySpan++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263352]
	add	eax, 120				; 00000078H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+263352], eax

; 142  : 		}

	jmp	$LN4@BuildRingL
$LN3@BuildRingL:

; 143  : 
; 144  : 		// If we've reached the viewer, stop now
; 145  : 		if (stopRing == 0) {

	cmp	DWORD PTR _stopRing$[ebp], 0
	jne	SHORT $LN2@BuildRingL

; 146  : 			break;

	jmp	SHORT $LN10@BuildRingL
$LN2@BuildRingL:

; 147  : 		}
; 148  : 		
; 149  : 		// What is the next ring at the next LOD (back out 1 to get an extra ring for the glue)
; 150  : 		startRing = (stopRing << 1) + 1;

	mov	edx, DWORD PTR _stopRing$[ebp]
	lea	eax, DWORD PTR [edx+edx+1]
	mov	DWORD PTR _startRing$[ebp], eax

; 151  : 	}

	jmp	$LN11@BuildRingL
$LN10@BuildRingL:

; 152  : 
; 153  : 	// Pad the end of the list to avoid overrunning the list when performing look ahead
; 154  : 	ShiAssert( firstEmptySpan < spanList + spanListMaxEntries );
; 155  : 	if ( firstEmptySpan != spanList ) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+263352]
	cmp	eax, DWORD PTR [edx+263348]
	je	SHORT $LN1@BuildRingL

; 156  : 		firstEmptySpan->ring = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263352]
	mov	DWORD PTR [edx], -1

; 157  : 		firstEmptySpan->LOD = (firstEmptySpan-1)->LOD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263352]
	mov	ecx, DWORD PTR [ecx-116]
	mov	DWORD PTR [eax+4], ecx

; 158  : 		firstEmptySpan->Tsector.insideEdge = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263352]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+8], xmm0

; 159  : 		firstEmptySpan->Bsector.insideEdge = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+263352]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+64], xmm0

; 160  : 		firstEmptySpan->Rsector.insideEdge = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263352]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+36], xmm0

; 161  : 		firstEmptySpan->Lsector.insideEdge = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+263352]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+92], xmm0
$LN1@BuildRingL:

; 162  : 	}
; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildRingList@RenderOTW@@IAEXXZ ENDP			; RenderOTW::BuildRingList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\renderer\otwcull.cpp
_TEXT	SEGMENT
tv510 = -216						; size = 4
tv852 = -212						; size = 4
tv505 = -208						; size = 4
tv547 = -204						; size = 4
tv499 = -200						; size = 4
_areaCeiling$ = -196					; size = 4
tv680 = -192						; size = 4
tv609 = -188						; size = 4
tv860 = -184						; size = 4
tv579 = -180						; size = 4
tv672 = -176						; size = 4
_cullMargin$ = -172					; size = 4
tv665 = -168						; size = 4
tv617 = -164						; size = 4
tv858 = -160						; size = 4
tv596 = -156						; size = 4
tv656 = -152						; size = 4
tv587 = -148						; size = 4
tv649 = -144						; size = 4
tv850 = -140						; size = 4
tv856 = -136						; size = 4
_areaFloor$ = -132					; size = 4
tv635 = -128						; size = 4
tv560 = -124						; size = 4
tv854 = -120						; size = 4
tv625 = -116						; size = 4
tv565 = -112						; size = 4
_A$ = -108						; size = 4
_B$ = -104						; size = 4
_temp$ = -100						; size = 4
_sinPitch$ = -96					; size = 4
_backupDistance$ = -92					; size = 4
_cosPitch$ = -88					; size = 4
_C$ = -84						; size = 4
_bottom$ = -80						; size = 4
_sinYaw$ = -76						; size = 4
_cosYaw$ = -72						; size = 4
_aboveMax$ = -68					; size = 4
_distanceLimit$ = -64					; size = 4
_aboveMin$ = -60					; size = 4
_top$ = -56						; size = 4
_back$ = -52						; size = 4
_front$ = -48						; size = 4
_this$ = -44						; size = 4
_Corner1$ = -40						; size = 12
_Corner2$ = -28						; size = 12
_CullPoint$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?ComputeBounds@RenderOTW@@IAEXXZ PROC			; RenderOTW::ComputeBounds
; _this$ = ecx

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1223 : 	// To avoid rounding errors (or possibly some other minor computational bug)
; 1224 : 	// I compute culling assuming a viewpoint somewhat behind the real
; 1225 : 	// camera postion which will always yeild a conservative estimate.
; 1226 : 	// To be really paranoid, the CULL_BACKUP_DISTANCE is
; 1227 : 	// a function of field of view to get a constant linear margin.
; 1228 : 	float cullMargin		= LEVEL_POST_TO_WORLD( 2, viewpoint->GetHighLOD() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetHighLOD@TViewPoint@@QAEHXZ		; TViewPoint::GetHighLOD
	mov	edx, 2
	mov	ecx, eax
	shl	edx, cl
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR ?FeetPerPost@@3MA
	movss	DWORD PTR _cullMargin$[ebp], xmm0

; 1229 : 	float backupDistance	= cullMargin / (float)sin( diagonal_half_angle );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+262900]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv499[ebp]
	movss	xmm0, DWORD PTR _cullMargin$[ebp]
	divss	xmm0, DWORD PTR tv499[ebp]
	movss	DWORD PTR _backupDistance$[ebp], xmm0

; 1230 : 	Tpoint	CullPoint;
; 1231 : 	GetAt( &CullPoint );

	lea	ecx, DWORD PTR _CullPoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAt@Render3D@@QAEXPAUTpoint@@@Z	; Render3D::GetAt

; 1232 : 	CullPoint.x = X() - CullPoint.x * backupDistance;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?X@Render3D@@QAEMXZ			; Render3D::X
	fstp	DWORD PTR tv505[ebp]
	movss	xmm0, DWORD PTR tv505[ebp]
	movss	xmm1, DWORD PTR _CullPoint$[ebp]
	mulss	xmm1, DWORD PTR _backupDistance$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _CullPoint$[ebp], xmm0

; 1233 : 	CullPoint.y = Y() - CullPoint.y * backupDistance;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Y@Render3D@@QAEMXZ			; Render3D::Y
	fstp	DWORD PTR tv510[ebp]
	movss	xmm0, DWORD PTR tv510[ebp]
	movss	xmm1, DWORD PTR _CullPoint$[ebp+4]
	mulss	xmm1, DWORD PTR _backupDistance$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _CullPoint$[ebp+4], xmm0

; 1234 : 	CullPoint.z = Z() - CullPoint.z * backupDistance;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Z@Render3D@@QAEMXZ			; Render3D::Z
	fstp	DWORD PTR tv547[ebp]
	movss	xmm0, DWORD PTR tv547[ebp]
	movss	xmm1, DWORD PTR _CullPoint$[ebp+8]
	mulss	xmm1, DWORD PTR _backupDistance$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _CullPoint$[ebp+8], xmm0

; 1235 : 	float distanceLimit = far_clip + backupDistance;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+262876]
	addss	xmm0, DWORD PTR _backupDistance$[ebp]
	movss	DWORD PTR _distanceLimit$[ebp], xmm0

; 1236 : 
; 1237 : 
; 1238 : 	// Get the vertical bounds of the terrain arround our viewpoint
; 1239 : 	float areaFloor;
; 1240 : 	float areaCeiling;
; 1241 : 	areaFloor	= viewpoint->GetTerrainFloor();		// -Z is up

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+263088]
	call	?GetTerrainFloor@RViewPoint@@QAEMXZ	; RViewPoint::GetTerrainFloor
	fstp	DWORD PTR _areaFloor$[ebp]

; 1242 : 	areaCeiling	= viewpoint->GetTerrainCeiling();	// -Z is up

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+263088]
	call	?GetTerrainCeiling@RViewPoint@@QAEMXZ	; RViewPoint::GetTerrainCeiling
	fstp	DWORD PTR _areaCeiling$[ebp]

; 1243 : 
; 1244 : 
; 1245 : 	//	First compute the front and back distances of the ground patch
; 1246 : 	//  (front may be behind the viewer, in which case it will be negative)
; 1247 : 	//  (back will never be behind the viewer and will never be negative)
; 1248 : 	float top	= Pitch() + diagonal_half_angle;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Pitch@Render3D@@QAEMXZ			; Render3D::Pitch
	fstp	DWORD PTR tv560[ebp]
	movss	xmm0, DWORD PTR tv560[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+262900]
	movss	DWORD PTR _top$[ebp], xmm0

; 1249 : 	float bottom= Pitch() - diagonal_half_angle;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Pitch@Render3D@@QAEMXZ			; Render3D::Pitch
	fstp	DWORD PTR tv565[ebp]
	movss	xmm0, DWORD PTR tv565[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+262900]
	movss	DWORD PTR _bottom$[ebp], xmm0

; 1250 : 
; 1251 : 	float aboveMin = areaFloor - CullPoint.z;		// -Z is up

	movss	xmm0, DWORD PTR _areaFloor$[ebp]
	subss	xmm0, DWORD PTR _CullPoint$[ebp+8]
	movss	DWORD PTR _aboveMin$[ebp], xmm0

; 1252 : 	float aboveMax = areaCeiling - CullPoint.z;		// -Z is up

	movss	xmm0, DWORD PTR _areaCeiling$[ebp]
	subss	xmm0, DWORD PTR _CullPoint$[ebp+8]
	movss	DWORD PTR _aboveMax$[ebp], xmm0

; 1253 : 
; 1254 : 	float front = -1e30f;

	movss	xmm0, DWORD PTR __real@f149f2ca
	movss	DWORD PTR _front$[ebp], xmm0

; 1255 : 	float back =  -1e30f;

	movss	xmm0, DWORD PTR __real@f149f2ca
	movss	DWORD PTR _back$[ebp], xmm0

; 1256 : 
; 1257 : 	if ( bottom < -PI_OVER_2 ) {

	movss	xmm0, DWORD PTR __real@bfc90fdb
	comiss	xmm0, DWORD PTR _bottom$[ebp]
	jbe	$LN31@ComputeBou

; 1258 : 		// bottom vector points down and backward
; 1259 : 		if (aboveMin >= 0.0f) {

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN30@ComputeBou

; 1260 : 			// We're above ground so intersect the bottom with min height
; 1261 : 			front = -aboveMin * (float)tan( -bottom-PI_OVER_2 );

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _bottom$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm1, DWORD PTR __real@3fc90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv850[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv579[ebp]
	movss	xmm0, DWORD PTR tv850[ebp]
	mulss	xmm0, DWORD PTR tv579[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1262 : 			if ( top > 0 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN29@ComputeBou

; 1263 : 				// top vector points up
; 1264 : 				back = distanceLimit;

	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0

; 1265 : 			} else {

	jmp	SHORT $LN28@ComputeBou
$LN29@ComputeBou:

; 1266 : 				// top vector points down
; 1267 : 				back = aboveMin * (float)tan( top+PI_OVER_2 );

	movss	xmm0, DWORD PTR _top$[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv587[ebp]
	movss	xmm0, DWORD PTR tv587[ebp]
	mulss	xmm0, DWORD PTR _aboveMin$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0
$LN28@ComputeBou:

; 1268 : 			}
; 1269 : 		} else {

	jmp	SHORT $LN25@ComputeBou
$LN30@ComputeBou:

; 1270 : 			// We're below ground 
; 1271 : 			if ( top > 0 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN26@ComputeBou

; 1272 : 				// top is pointing upward, so intersect the top with min height
; 1273 : 				front = -aboveMin / (float)tan( top );

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _top$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv852[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv596[ebp]
	movss	xmm0, DWORD PTR tv852[ebp]
	divss	xmm0, DWORD PTR tv596[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1274 : 				back = distanceLimit;

	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0

; 1275 : 			} else {

	jmp	SHORT $LN25@ComputeBou
$LN26@ComputeBou:

; 1276 : 				// We're below all terrain
; 1277 : 				front = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _front$[ebp], xmm0

; 1278 : 				back = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _back$[ebp], xmm0
$LN25@ComputeBou:

; 1279 : 			}
; 1280 : 		}

	jmp	$LN4@ComputeBou
$LN31@ComputeBou:

; 1281 : 	} else if ( bottom < 0 ) {

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _bottom$[ebp]
	jbe	$LN23@ComputeBou

; 1282 : 		// bottom vector points downward, but not backward
; 1283 : 		if (aboveMin >= 0.0f) {

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN22@ComputeBou

; 1284 : 			// We're above ground
; 1285 : 			if ( top >= 0 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN21@ComputeBou

; 1286 : 				// the top vector points upward
; 1287 : 				back = distanceLimit;

	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0

; 1288 : 			} else {

	jmp	SHORT $LN20@ComputeBou
$LN21@ComputeBou:

; 1289 : 				// the top vector points downward as well
; 1290 : 				back = aboveMin * (float)tan( top+PI_OVER_2 );

	movss	xmm0, DWORD PTR _top$[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv609[ebp]
	movss	xmm0, DWORD PTR tv609[ebp]
	mulss	xmm0, DWORD PTR _aboveMin$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0
$LN20@ComputeBou:

; 1291 : 			}	
; 1292 : 			if ( aboveMax > 0 ) {

	movss	xmm0, DWORD PTR _aboveMax$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@ComputeBou

; 1293 : 				// we're above all terrain
; 1294 : 				front = aboveMax * (float)tan( bottom+PI_OVER_2 );

	movss	xmm0, DWORD PTR _bottom$[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv617[ebp]
	movss	xmm0, DWORD PTR tv617[ebp]
	mulss	xmm0, DWORD PTR _aboveMax$[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1295 : 			} else {

	jmp	SHORT $LN16@ComputeBou
$LN19@ComputeBou:

; 1296 : 				// we're down in it
; 1297 : 				if ( top > PI_OVER_2 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fdb
	jbe	SHORT $LN17@ComputeBou

; 1298 : 					// top vector points backward
; 1299 : 					front = aboveMax / (float)tan( PI - top );

	movss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR _top$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv625[ebp]
	movss	xmm0, DWORD PTR _aboveMax$[ebp]
	divss	xmm0, DWORD PTR tv625[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1300 : 				} else {

	jmp	SHORT $LN16@ComputeBou
$LN17@ComputeBou:

; 1301 : 					// top vector points upward, but not backward
; 1302 : 					front = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _front$[ebp], xmm0
$LN16@ComputeBou:

; 1303 : 				}
; 1304 : 			}
; 1305 : 		} else {

	jmp	SHORT $LN13@ComputeBou
$LN22@ComputeBou:

; 1306 : 			// We're below ground
; 1307 : 			if ( top >= 0 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN14@ComputeBou

; 1308 : 				// top is pointing upward, so intersect the top with min height
; 1309 : 				front = -aboveMin / (float)tan( top );

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _top$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv854[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv635[ebp]
	movss	xmm0, DWORD PTR tv854[ebp]
	divss	xmm0, DWORD PTR tv635[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1310 : 				back = distanceLimit;

	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0

; 1311 : 			} else {

	jmp	SHORT $LN13@ComputeBou
$LN14@ComputeBou:

; 1312 : 				// the top vector points downward as well -- we're below all terrain
; 1313 : 				front = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _front$[ebp], xmm0

; 1314 : 				back = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _back$[ebp], xmm0
$LN13@ComputeBou:

; 1315 : 			}	
; 1316 : 		}
; 1317 : 	} else {

	jmp	$LN4@ComputeBou
$LN23@ComputeBou:

; 1318 : 		// bottom vector points upward
; 1319 : 		if ( aboveMax > 0 ) {

	movss	xmm0, DWORD PTR _aboveMax$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@ComputeBou

; 1320 : 			// we're above all terrain
; 1321 : 			front = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _front$[ebp], xmm0

; 1322 : 			back = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _back$[ebp], xmm0
	jmp	$LN4@ComputeBou
$LN11@ComputeBou:

; 1323 : 		} else if (aboveMin >= 0) {

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN9@ComputeBou

; 1324 : 			// we're down in it
; 1325 : 			back = -aboveMax / (float)tan( bottom );

	movss	xmm0, DWORD PTR _aboveMax$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _bottom$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv856[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv649[ebp]
	movss	xmm0, DWORD PTR tv856[ebp]
	divss	xmm0, DWORD PTR tv649[ebp]
	movss	DWORD PTR _back$[ebp], xmm0

; 1326 : 			if ( top > PI_OVER_2 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fdb
	jbe	SHORT $LN8@ComputeBou

; 1327 : 				// top vector points backward
; 1328 : 				front = aboveMax * (float)tan( top-PI_OVER_2 );

	movss	xmm0, DWORD PTR _top$[ebp]
	subss	xmm0, DWORD PTR __real@3fc90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv656[ebp]
	movss	xmm0, DWORD PTR tv656[ebp]
	mulss	xmm0, DWORD PTR _aboveMax$[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1329 : 			} else {

	jmp	SHORT $LN7@ComputeBou
$LN8@ComputeBou:

; 1330 : 				// top vector points up, but not backward
; 1331 : 				front = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _front$[ebp], xmm0
$LN7@ComputeBou:

; 1332 : 			}
; 1333 : 		} else {

	jmp	$LN4@ComputeBou
$LN9@ComputeBou:

; 1334 : 			// We're below ground
; 1335 : 			back = -aboveMax / (float)tan( bottom );

	movss	xmm0, DWORD PTR _aboveMax$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _bottom$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv858[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv665[ebp]
	movss	xmm0, DWORD PTR tv858[ebp]
	divss	xmm0, DWORD PTR tv665[ebp]
	movss	DWORD PTR _back$[ebp], xmm0

; 1336 : 			if ( top > PI_OVER_2 ) {

	movss	xmm0, DWORD PTR _top$[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fdb
	jbe	SHORT $LN5@ComputeBou

; 1337 : 				// top vector points backward
; 1338 : 				front = aboveMax * (float)tan( top-PI_OVER_2 );

	movss	xmm0, DWORD PTR _top$[ebp]
	subss	xmm0, DWORD PTR __real@3fc90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv672[ebp]
	movss	xmm0, DWORD PTR tv672[ebp]
	mulss	xmm0, DWORD PTR _aboveMax$[ebp]
	movss	DWORD PTR _front$[ebp], xmm0

; 1339 : 			} else {

	jmp	SHORT $LN4@ComputeBou
$LN5@ComputeBou:

; 1340 : 				// top vector points up, but not backward, so intersect the top with min height
; 1341 : 				front = -aboveMin / (float)tan( top );

	movss	xmm0, DWORD PTR _aboveMin$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _top$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv860[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv680[ebp]
	movss	xmm0, DWORD PTR tv860[ebp]
	divss	xmm0, DWORD PTR tv680[ebp]
	movss	DWORD PTR _front$[ebp], xmm0
$LN4@ComputeBou:

; 1342 : 			}
; 1343 : 		}
; 1344 : 	}
; 1345 : 
; 1346 : 	// Clamp the front and back values at the largest distance we could ever see
; 1347 : 	if (back > distanceLimit)	{ back = distanceLimit; }

	movss	xmm0, DWORD PTR _back$[ebp]
	comiss	xmm0, DWORD PTR _distanceLimit$[ebp]
	jbe	SHORT $LN3@ComputeBou
	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	movss	DWORD PTR _back$[ebp], xmm0
$LN3@ComputeBou:

; 1348 : 	if (front < -distanceLimit)	{ front = -distanceLimit; }

	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN2@ComputeBou
	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _front$[ebp], xmm0
$LN2@ComputeBou:

; 1349 : 	if (front > distanceLimit)	{ front = distanceLimit; }

	movss	xmm0, DWORD PTR _front$[ebp]
	comiss	xmm0, DWORD PTR _distanceLimit$[ebp]
	jbe	SHORT $LN1@ComputeBou
	movss	xmm0, DWORD PTR _distanceLimit$[ebp]
	movss	DWORD PTR _front$[ebp], xmm0
$LN1@ComputeBou:

; 1350 : 	
; 1351 : 	//
; 1352 : 	// Now go compute the left and right edges
; 1353 : 	//
; 1354 : 	float A;
; 1355 : 	float B;
; 1356 : 	float C;
; 1357 : 	float temp;
; 1358 : 
; 1359 : 
; 1360 : 	// Intersect the min elevation plane and the side of the view volume to get the right edge.
; 1361 : 	// (left side is a mirror of the right side)
; 1362 : 
; 1363 : 	// With the viewer looking down the x axis,
; 1364 : 	// the right side of view volume is defined by the origin (eye point) and 
; 1365 : 	Tpoint	Corner1 = { 1.0f, (float)tan(diagonal_half_angle),  1.0f };

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _Corner1$[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+262900]
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR _Corner1$[ebp+4]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _Corner1$[ebp+8], xmm0

; 1366 : 	Tpoint	Corner2 = { 1.0f, (float)tan(diagonal_half_angle), -1.0f };

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _Corner2$[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+262900]
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR _Corner2$[ebp+4]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _Corner2$[ebp+8], xmm0

; 1367 : 
; 1368 : 
; 1369 : 	// This plane should then be rotated in pitch about the y axis (look up/down)
; 1370 : 	// Rotate the two points
; 1371 : 	// NOTE:  We're computing the sides with pitch always pointing downward because
; 1372 : 	//		  the plane/plane intersection does the wrong thing when looking up.
; 1373 : 	// NOTE2: It would seem to me that I should have a minus sign in front of the pitch
; 1374 : 	//		  term in the following two lines.  I may have a sign wrong somewhere else, 
; 1375 : 	//        though, since it seems to work correctly as written...
; 1376 : 	float	sinPitch	= (float)sin( fabs(Pitch()) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Pitch@Render3D@@QAEMXZ			; Render3D::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinPitch$[ebp]

; 1377 : 	float	cosPitch	= (float)cos( fabs(Pitch()) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Pitch@Render3D@@QAEMXZ			; Render3D::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosPitch$[ebp]

; 1378 : 	float	sinYaw		= (float)sin( Yaw() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Yaw@Render3D@@QAEMXZ			; Render3D::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinYaw$[ebp]

; 1379 : 	float	cosYaw		= (float)cos( Yaw() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Yaw@Render3D@@QAEMXZ			; Render3D::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosYaw$[ebp]

; 1380 : 
; 1381 : 	temp		= Corner1.x * cosPitch	- Corner1.z * sinPitch;

	movss	xmm0, DWORD PTR _Corner1$[ebp]
	mulss	xmm0, DWORD PTR _cosPitch$[ebp]
	movss	xmm1, DWORD PTR _Corner1$[ebp+8]
	mulss	xmm1, DWORD PTR _sinPitch$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _temp$[ebp], xmm0

; 1382 : 	Corner1.z	= Corner1.x * sinPitch	+ Corner1.z * cosPitch;

	movss	xmm0, DWORD PTR _Corner1$[ebp]
	mulss	xmm0, DWORD PTR _sinPitch$[ebp]
	movss	xmm1, DWORD PTR _Corner1$[ebp+8]
	mulss	xmm1, DWORD PTR _cosPitch$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _Corner1$[ebp+8], xmm0

; 1383 : 	Corner1.x	= temp;

	movss	xmm0, DWORD PTR _temp$[ebp]
	movss	DWORD PTR _Corner1$[ebp], xmm0

; 1384 : 
; 1385 : 	temp		= Corner2.x * cosPitch	- Corner2.z * sinPitch;

	movss	xmm0, DWORD PTR _Corner2$[ebp]
	mulss	xmm0, DWORD PTR _cosPitch$[ebp]
	movss	xmm1, DWORD PTR _Corner2$[ebp+8]
	mulss	xmm1, DWORD PTR _sinPitch$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _temp$[ebp], xmm0

; 1386 : 	Corner2.z	= Corner2.x * sinPitch	+ Corner2.z * cosPitch;

	movss	xmm0, DWORD PTR _Corner2$[ebp]
	mulss	xmm0, DWORD PTR _sinPitch$[ebp]
	movss	xmm1, DWORD PTR _Corner2$[ebp+8]
	mulss	xmm1, DWORD PTR _cosPitch$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _Corner2$[ebp+8], xmm0

; 1387 : 	Corner2.x	= temp;

	movss	xmm0, DWORD PTR _temp$[ebp]
	movss	DWORD PTR _Corner2$[ebp], xmm0

; 1388 : 
; 1389 : 
; 1390 : 	// Construct the normal to the plane using the cross product of the vectors from the eye point
; 1391 : 	// (Note:  The normal components ARE the A, B, and C coefficients of the plane equation)
; 1392 : 	A = Corner1.y*Corner2.z - Corner1.z*Corner2.y;

	movss	xmm0, DWORD PTR _Corner1$[ebp+4]
	mulss	xmm0, DWORD PTR _Corner2$[ebp+8]
	movss	xmm1, DWORD PTR _Corner1$[ebp+8]
	mulss	xmm1, DWORD PTR _Corner2$[ebp+4]
	subss	xmm0, xmm1
	movss	DWORD PTR _A$[ebp], xmm0

; 1393 : 	B = Corner1.z*Corner2.x - Corner1.x*Corner2.z;

	movss	xmm0, DWORD PTR _Corner1$[ebp+8]
	mulss	xmm0, DWORD PTR _Corner2$[ebp]
	movss	xmm1, DWORD PTR _Corner1$[ebp]
	mulss	xmm1, DWORD PTR _Corner2$[ebp+8]
	subss	xmm0, xmm1
	movss	DWORD PTR _B$[ebp], xmm0

; 1394 : 	C = Corner1.x*Corner2.y - Corner1.y*Corner2.x;

	movss	xmm0, DWORD PTR _Corner1$[ebp]
	mulss	xmm0, DWORD PTR _Corner2$[ebp+4]
	movss	xmm1, DWORD PTR _Corner1$[ebp+4]
	mulss	xmm1, DWORD PTR _Corner2$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _C$[ebp], xmm0

; 1395 : 
; 1396 : 	// Since the origin is one of the points on the plane, D is necessarily zero
; 1397 : 	//
; 1398 : 	// The intersection of the plane with the minimum terrain feature height
; 1399 : 	// is the worst case.  This is the plane z = (alt - areaFloor)
; 1400 : 	// We use height above minimum since we set the eyepoint at the origin and positive z is down.
; 1401 : 	//
; 1402 : 	// The line equation given by performing the substitution for z in the plane equation is:
; 1403 : 	// Ax + By + C*aboveMin + D = 0;
; 1404 : 	// Where A B C and D are the coefficients of the plane equation
; 1405 : 	//
; 1406 : 	// The Line equation coefficients are:
; 1407 : 	// a = A;
; 1408 : 	// b = B;
; 1409 : 	// c = C*aboveMin + D;
; 1410 : 	//
; 1411 : 	// Convert C in place so A, B and C become the line equation coefficients
; 1412 : 	C *= aboveMin;

	movss	xmm0, DWORD PTR _C$[ebp]
	mulss	xmm0, DWORD PTR _aboveMin$[ebp]
	movss	DWORD PTR _C$[ebp], xmm0

; 1413 : 
; 1414 : 
; 1415 : 	// Now get two points on this line and two points on its reflection across the X axis
; 1416 : 	// point one on each side is at X = front.  Point two on each side is at X = back.
; 1417 : 	rightY1	= -(A*front+C)/B;	rightY2	= -(A*back+C)/B;

	movss	xmm0, DWORD PTR _A$[ebp]
	mulss	xmm0, DWORD PTR _front$[ebp]
	addss	xmm0, DWORD PTR _C$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _B$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+263264], xmm0
	movss	xmm0, DWORD PTR _A$[ebp]
	mulss	xmm0, DWORD PTR _back$[ebp]
	addss	xmm0, DWORD PTR _C$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263268], xmm0

; 1418 : 	leftY1	= -rightY1;			leftY2	= -rightY2;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+263264]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+263280], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+263268]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+263284], xmm0

; 1419 : 
; 1420 : 	// Rotate the four points about the z axis to account for the viewer's yaw angle
; 1421 : 	// and shift them out to the viewers location in world space
; 1422 : 	rightX1	= cosYaw*front - sinYaw*rightY1 + CullPoint.x;

	movss	xmm0, DWORD PTR _cosYaw$[ebp]
	mulss	xmm0, DWORD PTR _front$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _sinYaw$[ebp]
	mulss	xmm1, DWORD PTR [eax+263264]
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263256], xmm0

; 1423 : 	rightY1	= sinYaw*front + cosYaw*rightY1 + CullPoint.y;

	movss	xmm0, DWORD PTR _sinYaw$[ebp]
	mulss	xmm0, DWORD PTR _front$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _cosYaw$[ebp]
	mulss	xmm1, DWORD PTR [edx+263264]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+263264], xmm0

; 1424 : 	
; 1425 : 	rightX2	= cosYaw*back - sinYaw*rightY2 + CullPoint.x;

	movss	xmm0, DWORD PTR _cosYaw$[ebp]
	mulss	xmm0, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _sinYaw$[ebp]
	mulss	xmm1, DWORD PTR [ecx+263268]
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+263260], xmm0

; 1426 : 	rightY2	= sinYaw*back + cosYaw*rightY2 + CullPoint.y;

	movss	xmm0, DWORD PTR _sinYaw$[ebp]
	mulss	xmm0, DWORD PTR _back$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _cosYaw$[ebp]
	mulss	xmm1, DWORD PTR [eax+263268]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263268], xmm0

; 1427 : 	
; 1428 : 	leftX1	= cosYaw*front - sinYaw*leftY1 + CullPoint.x;

	movss	xmm0, DWORD PTR _cosYaw$[ebp]
	mulss	xmm0, DWORD PTR _front$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _sinYaw$[ebp]
	mulss	xmm1, DWORD PTR [edx+263280]
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+263272], xmm0

; 1429 : 	leftY1	= sinYaw*front + cosYaw*leftY1 + CullPoint.y;

	movss	xmm0, DWORD PTR _sinYaw$[ebp]
	mulss	xmm0, DWORD PTR _front$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _cosYaw$[ebp]
	mulss	xmm1, DWORD PTR [ecx+263280]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+263280], xmm0

; 1430 : 
; 1431 : 	leftX2	= cosYaw*back - sinYaw*leftY2 + CullPoint.x;

	movss	xmm0, DWORD PTR _cosYaw$[ebp]
	mulss	xmm0, DWORD PTR _back$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _sinYaw$[ebp]
	mulss	xmm1, DWORD PTR [eax+263284]
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+263276], xmm0

; 1432 : 	leftY2	= sinYaw*back + cosYaw*leftY2 + CullPoint.y;

	movss	xmm0, DWORD PTR _sinYaw$[ebp]
	mulss	xmm0, DWORD PTR _back$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR _cosYaw$[ebp]
	mulss	xmm1, DWORD PTR [edx+263284]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _CullPoint$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+263284], xmm0

; 1433 : 
; 1434 : 
; 1435 : 	//
; 1436 : 	// Build the four edges bounding the ground patch
; 1437 : 	//
; 1438 : 	right_edge.SetupWithPoints( rightX1, rightY1, rightX2, rightY2 );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263268]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+263260]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+263264]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263256]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263324				; 0004049cH
	call	?SetupWithPoints@Edge@@QAEXMMMM@Z	; Edge::SetupWithPoints

; 1439 : 	right_edge.Normalize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263324				; 0004049cH
	call	?Normalize@Edge@@QAEXXZ			; Edge::Normalize

; 1440 : 	left_edge.SetupWithPoints( leftX1, leftY1, leftX2, leftY2 );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+263284]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+263276]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263280]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+263272]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	call	?SetupWithPoints@Edge@@QAEXMMMM@Z	; Edge::SetupWithPoints

; 1441 : 	left_edge.Normalize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263312				; 00040490H
	call	?Normalize@Edge@@QAEXXZ			; Edge::Normalize

; 1442 : 	front_edge.SetupWithPoints( leftX1, leftY1, rightX1, rightY1 );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+263264]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263256]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+263280]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+263272]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263288				; 00040478H
	call	?SetupWithPoints@Edge@@QAEXMMMM@Z	; Edge::SetupWithPoints

; 1443 : 	front_edge.Normalize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263288				; 00040478H
	call	?Normalize@Edge@@QAEXXZ			; Edge::Normalize

; 1444 : 	back_edge.SetupWithPoints( leftX2, leftY2, rightX2, rightY2 );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263268]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+263260]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+263284]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+263276]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	call	?SetupWithPoints@Edge@@QAEXMMMM@Z	; Edge::SetupWithPoints

; 1445 : 	back_edge.Normalize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 263300				; 00040484H
	call	?Normalize@Edge@@QAEXXZ			; Edge::Normalize

; 1446 : 
; 1447 : #if 0
; 1448 : 	// Sometimes we end up here with a bow tie shaped area -- bad -- so we hack a fix
; 1449 : 	if (right_edge.LeftOf( leftX1, leftY1 )) {
; 1450 : 		float t;
; 1451 : 		t = leftX1;
; 1452 : 		leftX1 = rightX1;
; 1453 : 		rightX1 = t;
; 1454 : 		t = leftY1;
; 1455 : 		leftY1 = rightY1;
; 1456 : 		rightY1 = t;
; 1457 : 
; 1458 : 		right_edge.SetupWithPoints( rightX1, rightY1, rightX2, rightY2 );
; 1459 : 		right_edge.Normalize();
; 1460 : 		left_edge.SetupWithPoints( leftX1, leftY1, leftX2, leftY2 );
; 1461 : 		left_edge.Normalize();
; 1462 : 		front_edge.SetupWithPoints( leftX1, leftY1, rightX1, rightY1 );
; 1463 : 		front_edge.Normalize();
; 1464 : 		back_edge.SetupWithPoints( leftX2, leftY2, rightX2, rightY2 );
; 1465 : 		back_edge.Normalize();
; 1466 : 	}
; 1467 : 
; 1468 : 	ShiAssert( (leftX1 == rightX1 && leftY1 == rightY1) || right_edge.RightOf( leftX1, leftY1 ) );
; 1469 : 	ShiAssert( (leftX1 == rightX1 && leftY1 == rightY1) || left_edge.LeftOf( rightX1, rightY1 ) );
; 1470 : 	ShiAssert( right_edge.RightOf( leftX2, leftY2 ) );
; 1471 : 	ShiAssert( left_edge.LeftOf( rightX2, rightY2 ) );
; 1472 : #endif
; 1473 : 
; 1474 : 
; 1475 : #ifdef TWO_D_MAP_AVAILABLE
; 1476 : 	if (twoDmode) {
; 1477 : 		// Draw the view volume representation (assuming its in world space)
; 1478 : 		SetColor( 0xFF0000A0 );
; 1479 : 		Render2DLine((UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(rightY1-viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(rightX1-viewpoint->X()) )), 
; 1480 : 					 (UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(rightY2-viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(rightX2-viewpoint->X()) )) );                           
; 1481 : 		Render2DLine((UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(leftY1 -viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(leftX1 -viewpoint->X()) )),  
; 1482 : 					 (UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(leftY2 -viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(leftX2 -viewpoint->X()) )) );                           
; 1483 : 		Render2DLine((UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(leftY1 -viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(leftX1 -viewpoint->X()) )),  
; 1484 : 					 (UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(rightY1-viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(rightX1-viewpoint->X()) )) );                           
; 1485 : 		Render2DLine((UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(leftY2 -viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(leftX2 -viewpoint->X()) )),  
; 1486 : 					 (UInt16)((xRes>>1) + TWODSCALE*( WORLD_TO_FLOAT_GLOBAL_POST(rightY2-viewpoint->Y()) )),	(UInt16)((yRes>>1) - TWODSCALE*( WORLD_TO_GLOBAL_POST(rightX2-viewpoint->X()) )) );
; 1487 : 	}
; 1488 : #endif
; 1489 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ComputeBounds@RenderOTW@@IAEXXZ ENDP			; RenderOTW::ComputeBounds
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1BoundSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BoundSegment@@QAE@XZ PROC				; BoundSegment::~BoundSegment, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Edge@@QAE@XZ				; Edge::~Edge
	mov	esp, ebp
	pop	ebp
	ret	0
??1BoundSegment@@QAE@XZ ENDP				; BoundSegment::~BoundSegment
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0BoundSegment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoundSegment@@QAE@XZ PROC				; BoundSegment::BoundSegment, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Edge@@QAE@XZ				; Edge::Edge
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoundSegment@@QAE@XZ ENDP				; BoundSegment::BoundSegment
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?GetAt@Render3D@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?GetAt@Render3D@@QAEXPAUTpoint@@@Z PROC			; Render3D::GetAt, COMDAT
; _this$ = ecx

; 86   : 	void	GetAt( Tpoint *v )		{ v->x = cameraRot.M11, v->y = cameraRot.M12, v->z = cameraRot.M13; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262936]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262940]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262944]
	mov	DWORD PTR [eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@Render3D@@QAEXPAUTpoint@@@Z ENDP			; Render3D::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?Pitch@Render3D@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@Render3D@@QAEMXZ PROC				; Render3D::Pitch, COMDAT
; _this$ = ecx

; 83   : 	float	Pitch( void )	{ return pitch;	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+262916]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@Render3D@@QAEMXZ ENDP				; Render3D::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?Yaw@Render3D@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@Render3D@@QAEMXZ PROC				; Render3D::Yaw, COMDAT
; _this$ = ecx

; 82   : 	float	Yaw( void )		{ return yaw;	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+262912]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@Render3D@@QAEMXZ ENDP				; Render3D::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?Z@Render3D@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Z@Render3D@@QAEMXZ PROC				; Render3D::Z, COMDAT
; _this$ = ecx

; 80   : 	float	Z( void )	{ return cameraPos.z; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+262932]
	mov	esp, ebp
	pop	ebp
	ret	0
?Z@Render3D@@QAEMXZ ENDP				; Render3D::Z
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?Y@Render3D@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Y@Render3D@@QAEMXZ PROC				; Render3D::Y, COMDAT
; _this$ = ecx

; 79   : 	float	Y( void )	{ return cameraPos.y; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+262928]
	mov	esp, ebp
	pop	ebp
	ret	0
?Y@Render3D@@QAEMXZ ENDP				; Render3D::Y
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?X@Render3D@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?X@Render3D@@QAEMXZ PROC				; Render3D::X, COMDAT
; _this$ = ecx

; 78   : 	float	X( void )	{ return cameraPos.x; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+262924]
	mov	esp, ebp
	pop	ebp
	ret	0
?X@Render3D@@QAEMXZ ENDP				; Render3D::X
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\edge.h
;	COMDAT ?Y@Edge@@QAEMM@Z
_TEXT	SEGMENT
tv84 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?Y@Edge@@QAEMM@Z PROC					; Edge::Y, COMDAT
; _this$ = ecx

; 75   : 	float	Y( float x )	{	if(B==0.0f) return 0.0f;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@Y
	fldz
	jmp	SHORT $LN1@Y
	jmp	SHORT $LN1@Y
$LN2@Y:

; 76   :     								else return -(A*x + C) / B; };

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR tv84[ebp], xmm0
	fld	DWORD PTR tv84[ebp]
$LN1@Y:
	mov	esp, ebp
	pop	ebp
	ret	4
?Y@Edge@@QAEMM@Z ENDP					; Edge::Y
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\edge.h
;	COMDAT ?X@Edge@@QAEMM@Z
_TEXT	SEGMENT
tv84 = -8						; size = 4
_this$ = -4						; size = 4
_y$ = 8							; size = 4
?X@Edge@@QAEMM@Z PROC					; Edge::X, COMDAT
; _this$ = ecx

; 71   : 	float	X( float y )	{	if(A==0.0f) return 0.0f;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@X
	fldz
	jmp	SHORT $LN1@X
	jmp	SHORT $LN1@X
$LN2@X:

; 72   :     								else return -(B*y + C) / A; };

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR tv84[ebp], xmm0
	fld	DWORD PTR tv84[ebp]
$LN1@X:
	mov	esp, ebp
	pop	ebp
	ret	4
?X@Edge@@QAEMM@Z ENDP					; Edge::X
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\edge.h
;	COMDAT ?Normalize@Edge@@QAEXXZ
_TEXT	SEGMENT
_mag$ = -8						; size = 4
_this$ = -4						; size = 4
?Normalize@Edge@@QAEXXZ PROC				; Edge::Normalize, COMDAT
; _this$ = ecx

; 42   : 	void	Normalize( void )	{ float mag = (float)sqrt(A*A+B*B); A /= mag, B /= mag, C /= mag; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _mag$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	divss	xmm0, DWORD PTR _mag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	divss	xmm0, DWORD PTR _mag$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	divss	xmm0, DWORD PTR _mag$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+8], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?Normalize@Edge@@QAEXXZ ENDP				; Edge::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\edge.h
;	COMDAT ?SetupWithPoints@Edge@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?SetupWithPoints@Edge@@QAEXMMMM@Z PROC			; Edge::SetupWithPoints, COMDAT
; _this$ = ecx

; 32   : 	void	SetupWithPoints( float x1, float y1, float x2, float y2 ) { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 				A = y2-y1;   B = x1-x2;   C = -(A*x1 + B*y1);

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _x1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR _y1$[ebp]
	addss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 34   : 			};

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetupWithPoints@Edge@@QAEXMMMM@Z ENDP			; Edge::SetupWithPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\edge.h
;	COMDAT ??1Edge@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Edge@@QAE@XZ PROC					; Edge::~Edge, COMDAT
; _this$ = ecx

; 20   : 	~Edge()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1Edge@@QAE@XZ ENDP					; Edge::~Edge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\edge.h
;	COMDAT ??0Edge@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Edge@@QAE@XZ PROC					; Edge::Edge, COMDAT
; _this$ = ecx

; 19   : 	Edge()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Edge@@QAE@XZ ENDP					; Edge::Edge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?GetTerrainCeiling@RViewPoint@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTerrainCeiling@RViewPoint@@QAEMXZ PROC		; RViewPoint::GetTerrainCeiling, COMDAT
; _this$ = ecx

; 40   : 	float	GetTerrainCeiling( void )	{ return terrainCeiling; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+256]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTerrainCeiling@RViewPoint@@QAEMXZ ENDP		; RViewPoint::GetTerrainCeiling
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\rviewpnt.h
;	COMDAT ?GetTerrainFloor@RViewPoint@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTerrainFloor@RViewPoint@@QAEMXZ PROC		; RViewPoint::GetTerrainFloor, COMDAT
; _this$ = ecx

; 39   : 	float	GetTerrainFloor( void )		{ return terrainFloor; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+252]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTerrainFloor@RViewPoint@@QAEMXZ ENDP		; RViewPoint::GetTerrainFloor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?Y@TViewPoint@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Y@TViewPoint@@QAEMXZ PROC				; TViewPoint::Y, COMDAT
; _this$ = ecx

; 116  : 	float	Y( void )	{ return pos.y; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?Y@TViewPoint@@QAEMXZ ENDP				; TViewPoint::Y
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?X@TViewPoint@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?X@TViewPoint@@QAEMXZ PROC				; TViewPoint::X, COMDAT
; _this$ = ecx

; 115  : 	float	X( void )	{ return pos.x; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?X@TViewPoint@@QAEMXZ ENDP				; TViewPoint::X
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetAvailablePostRange@TViewPoint@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_LOD$ = 8						; size = 4
?GetAvailablePostRange@TViewPoint@@QAEHH@Z PROC		; TViewPoint::GetAvailablePostRange, COMDAT
; _this$ = ecx

; 69   : 	int		GetAvailablePostRange( int LOD )	{ return blockLists[LOD].GetAvailablePostRange(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _LOD$[ebp]
	imul	ecx, 52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+24]
	call	?GetAvailablePostRange@TBlockList@@QAEHXZ ; TBlockList::GetAvailablePostRange
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAvailablePostRange@TViewPoint@@QAEHH@Z ENDP		; TViewPoint::GetAvailablePostRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetLowLOD@TViewPoint@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLowLOD@TViewPoint@@QAEHXZ PROC			; TViewPoint::GetLowLOD, COMDAT
; _this$ = ecx

; 57   : 	int		GetLowLOD(void)		{ return lowDetail; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLowLOD@TViewPoint@@QAEHXZ ENDP			; TViewPoint::GetLowLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetHighLOD@TViewPoint@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHighLOD@TViewPoint@@QAEHXZ PROC			; TViewPoint::GetHighLOD, COMDAT
; _this$ = ecx

; 56   : 	int		GetHighLOD(void)	{ return highDetail; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHighLOD@TViewPoint@@QAEHXZ ENDP			; TViewPoint::GetHighLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tblklist.h
;	COMDAT ?GetAvailablePostRange@TBlockList@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvailablePostRange@TBlockList@@QAEHXZ PROC		; TBlockList::GetAvailablePostRange, COMDAT
; _this$ = ecx

; 56   : 	int  GetAvailablePostRange( void )		{ return availableRange; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvailablePostRange@TBlockList@@QAEHXZ ENDP		; TBlockList::GetAvailablePostRange
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?tan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?tan@@YAMM@Z PROC					; tan, COMDAT

; 543  :         {return (tanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_tanf
	add	esp, 4
	pop	ebp
	ret	0
?tan@@YAMM@Z ENDP					; tan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 519  :         {return (floorf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	pop	ebp
	ret	0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 416  :         {return ((float)floor((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
