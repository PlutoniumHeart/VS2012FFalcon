; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\Graphics\Utils\TimeMgr.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
PUBLIC	??0TimeManager@@QAE@XZ				; TimeManager::TimeManager
PUBLIC	??1TimeManager@@QAE@XZ				; TimeManager::~TimeManager
PUBLIC	?Setup@TimeManager@@QAEXHH@Z			; TimeManager::Setup
PUBLIC	?Cleanup@TimeManager@@QAEXXZ			; TimeManager::Cleanup
PUBLIC	?IsReady@TimeManager@@QAEHXZ			; TimeManager::IsReady
PUBLIC	?SetTime@TimeManager@@QAEXK@Z			; TimeManager::SetTime
PUBLIC	?Refresh@TimeManager@@QAEXXZ			; TimeManager::Refresh
PUBLIC	?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ; TimeManager::RegisterTimeUpdateCB
PUBLIC	?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ; TimeManager::ReleaseTimeUpdateCB
PUBLIC	?TheTimeManager@@3VTimeManager@@A		; TheTimeManager
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
?TheTimeManager@@3VTimeManager@@A DB 024H DUP (?)	; TheTimeManager
_BSS	ENDS
CRT$XCU	SEGMENT
_TheTimeManager$initializer$ DD FLAT:??__ETheTimeManager@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FTheTimeManager@@YAXXZ
text$yd	SEGMENT
??__FTheTimeManager@@YAXXZ PROC				; `dynamic atexit destructor for 'TheTimeManager'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	??1TimeManager@@QAE@XZ			; TimeManager::~TimeManager
	pop	ebp
	ret	0
??__FTheTimeManager@@YAXXZ ENDP				; `dynamic atexit destructor for 'TheTimeManager''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
;	COMDAT ??__ETheTimeManager@@YAXXZ
text$yc	SEGMENT
??__ETheTimeManager@@YAXXZ PROC				; `dynamic initializer for 'TheTimeManager'', COMDAT

; 13   : TimeManager TheTimeManager;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	??0TimeManager@@QAE@XZ			; TimeManager::TimeManager
	push	OFFSET ??__FTheTimeManager@@YAXXZ	; `dynamic atexit destructor for 'TheTimeManager''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__ETheTimeManager@@YAXXZ ENDP				; `dynamic initializer for 'TheTimeManager''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_fn$ = 8						; size = 4
_self$ = 12						; size = 4
?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z PROC	; TimeManager::ReleaseTimeUpdateCB
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 	ShiAssert( IsReady() );
; 86   : 	ShiAssert( fn );
; 87   :     int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 
; 89   : 	for (i=0; i<MAX_TOD_CALLBACKS; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@ReleaseTim
$LN4@ReleaseTim:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@ReleaseTim:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@ReleaseTim

; 90   : 		if (CBlist[i].fn == fn) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	cmp	ecx, DWORD PTR _fn$[ebp]
	jne	SHORT $LN2@ReleaseTim

; 91   : 			if (CBlist[i].self == self) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	cmp	edx, DWORD PTR _self$[ebp]
	jne	SHORT $LN2@ReleaseTim

; 92   : 				CBlist[i].fn	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*8], 0

; 93   : 				CBlist[i].self	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], 0

; 94   : 				break;

	jmp	SHORT $LN6@ReleaseTim
$LN2@ReleaseTim:

; 95   : 			}
; 96   : 		}
; 97   : 	}

	jmp	SHORT $LN4@ReleaseTim
$LN6@ReleaseTim:

; 98   : 
; 99   : 	// Squawk if someone tried to remove a callback that wasn't in the list
; 100  : 	ShiAssert( i<MAX_TOD_CALLBACKS );
; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ENDP	; TimeManager::ReleaseTimeUpdateCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_fn$ = 8						; size = 4
_self$ = 12						; size = 4
?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z PROC ; TimeManager::RegisterTimeUpdateCB
; _this$ = ecx

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 	ShiAssert( IsReady() );
; 61   : 	ShiAssert( fn );
; 62   :     int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 63   : 
; 64   : 	if (CBlist)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN6@RegisterTi

; 65   : 	{
; 66   : 		for (i=0; i<MAX_TOD_CALLBACKS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@RegisterTi
$LN3@RegisterTi:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@RegisterTi:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@RegisterTi

; 67   : 		{
; 68   : 			if (CBlist[i].fn == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*8], 0
	jne	SHORT $LN1@RegisterTi

; 69   : 			{
; 70   : 				CBlist[i].self	= self;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 71   : 				CBlist[i].fn	= fn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _fn$[ebp]
	mov	DWORD PTR [ecx+edx*8], eax

; 72   : 				break;

	jmp	SHORT $LN6@RegisterTi
$LN1@RegisterTi:

; 73   : 			}
; 74   : 		}

	jmp	SHORT $LN3@RegisterTi
$LN6@RegisterTi:

; 75   : 		// If we fell out the bottom, we ran out of room.
; 76   : 		ShiAssert( i<MAX_TOD_CALLBACKS );
; 77   : 	}
; 78   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ENDP ; TimeManager::RegisterTimeUpdateCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?Refresh@TimeManager@@QAEXXZ PROC			; TimeManager::Refresh
; _this$ = ecx

; 159  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 	ShiAssert( IsReady() );
; 161  : 
; 162  : 	for ( int i=0; i<MAX_TOD_CALLBACKS; i++ ) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@Refresh
$LN3@Refresh:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@Refresh:
	cmp	DWORD PTR _i$1[ebp], 64			; 00000040H
	jge	SHORT $LN2@Refresh

; 163  : 		// Make the callback if we have one in this slot
; 164  : 		if (CBlist[i].fn) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR [edx+eax*8], 0
	je	SHORT $LN1@Refresh

; 165  : 			CBlist[i].fn( CBlist[i].self ); 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	call	edx
	add	esp, 4
$LN1@Refresh:

; 166  : 		}
; 167  : 	}

	jmp	SHORT $LN3@Refresh
$LN2@Refresh:

; 168  : 
; 169  : 	// Reset our callback control variables
; 170  : 	nextCallToMake = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 171  : 	lastUpdateTime = currentTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+24], eax

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Refresh@TimeManager@@QAEXXZ ENDP			; TimeManager::Refresh
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
_TEXT	SEGMENT
tv94 = -16						; size = 4
_day$ = -12						; size = 4
_steps$ = -8						; size = 4
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetTime@TimeManager@@QAEXK@Z PROC			; TimeManager::SetTime
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 	ShiAssert( IsReady() );
; 108  : 
; 109  : 	// We're in trouble if the clock rolls over (approximatly 49 days after start)
; 110  : //	ShiAssert(newTime >= lastUpdateTime);
; 111  : 
; 112  : 	// Update all our measures of time
; 113  : 	deltaTime = newTime - currentTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTime$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 114  : 	currentTime = newTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTime$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 115  : 	DWORD day = currentTime / MSEC_PER_DAY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	edx, edx
	mov	ecx, 86400000				; 05265c00H
	div	ecx
	mov	DWORD PTR _day$[ebp], eax

; 116  : 	timeOfDay = currentTime - day * MSEC_PER_DAY;

	mov	edx, DWORD PTR _day$[ebp]
	imul	edx, 86400000				; 05265c00H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 117  : 	today = day + startDay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _day$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 118  : 	// TODO:  Deal with leap years???
; 119  : 	if (today >= 365) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 365			; 0000016dH
	jb	SHORT $LN7@SetTime

; 120  : 		year += 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 121  : 		today = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
$LN7@SetTime:

; 122  : 	}
; 123  : 	
; 124  : 	// Quit now unless enough time has passed to make it worth while
; 125  : 	// (for now we're set for 60 seconds)
; 126  : 	if (newTime - lastUpdateTime < CALLBACK_TIME_STEP) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTime$[ebp]
	sub	eax, DWORD PTR [edx+24]
	cmp	eax, 937				; 000003a9H
	jae	SHORT $LN6@SetTime

; 127  : 		return;

	jmp	$LN8@SetTime
$LN6@SetTime:

; 128  : 	}
; 129  : 
; 130  : 	// Decide how many steps to take (in case we had a large time step)
; 131  : 	int steps = (newTime - lastUpdateTime) / CALLBACK_TIME_STEP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTime$[ebp]
	sub	eax, DWORD PTR [ecx+24]
	xor	edx, edx
	mov	ecx, 937				; 000003a9H
	div	ecx
	mov	DWORD PTR _steps$[ebp], eax

; 132  : 	if (steps >= MAX_TOD_CALLBACKS) {

	cmp	DWORD PTR _steps$[ebp], 64		; 00000040H
	jl	SHORT $LN5@SetTime

; 133  : 		// Start back at the first callback to make sure things happen in order
; 134  : 		nextCallToMake = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 135  : 		steps = MAX_TOD_CALLBACKS;

	mov	DWORD PTR _steps$[ebp], 64		; 00000040H
$LN5@SetTime:

; 136  : 	}
; 137  : 	
; 138  : 	// Note the new time
; 139  : 	lastUpdateTime = newTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTime$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN4@SetTime:

; 140  : 
; 141  : 	// Make the callbacks
; 142  : 	while (steps--) {

	mov	edx, DWORD PTR _steps$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR _steps$[ebp]
	sub	eax, 1
	mov	DWORD PTR _steps$[ebp], eax
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN8@SetTime

; 143  : 		// Make the callback if we have one in this slot
; 144  : 		if (CBlist[nextCallToMake].fn) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx+edx*8], 0
	je	SHORT $LN2@SetTime

; 145  : 			CBlist[nextCallToMake].fn( CBlist[nextCallToMake].self ); 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+eax*8+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+edx*8]
	call	edx
	add	esp, 4
$LN2@SetTime:

; 146  : 		}
; 147  : 
; 148  : 		// Advance to the next slot for next time
; 149  : 		nextCallToMake++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 150  : 		if (nextCallToMake == MAX_TOD_CALLBACKS) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 64			; 00000040H
	jne	SHORT $LN1@SetTime

; 151  : 			nextCallToMake = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
$LN1@SetTime:

; 152  : 		}
; 153  : 	}

	jmp	SHORT $LN4@SetTime
$LN8@SetTime:

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTime@TimeManager@@QAEXK@Z ENDP			; TimeManager::SetTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ?IsReady@TimeManager@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsReady@TimeManager@@QAEHXZ PROC			; TimeManager::IsReady, COMDAT
; _this$ = ecx

; 36   : 	BOOL	IsReady( void )		{ return (CBlist != NULL); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@IsReady
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsReady
$LN3@IsReady:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsReady:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReady@TimeManager@@QAEHXZ ENDP			; TimeManager::IsReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Cleanup@TimeManager@@QAEXXZ PROC			; TimeManager::Cleanup
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 	ShiAssert( IsReady() );
; 40   : 
; 41   : #ifdef _DEBUG	
; 42   : 	for (nextCallToMake = 0; nextCallToMake < MAX_TOD_CALLBACKS; nextCallToMake++) {
; 43   : 		if ( CBlist[nextCallToMake].fn != NULL ) {
; 44   : 			//VP_changes This should be fixed, we have an error here Oct 8, 2002.
; 45   : 			ShiWarning( "TimeManager dieing with callbacks still registered!" );
; 46   : 			break;
; 47   : 		}
; 48   : 	}
; 49   : #endif
; 50   : 
; 51   : 	delete[] CBlist;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 52   : 	CBlist = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@TimeManager@@QAEXXZ ENDP			; TimeManager::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\utils\timemgr.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_startYear$ = 8						; size = 4
_startDayOfYear$ = 12					; size = 4
?Setup@TimeManager@@QAEXHH@Z PROC			; TimeManager::Setup
; _this$ = ecx

; 23   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 	ShiAssert( !IsReady() );
; 25   : 
; 26   : 	// Store the day the clock started
; 27   : 	year		= startYear;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _startYear$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 28   : 	startDay	= startDayOfYear;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _startDayOfYear$[ebp]
	mov	DWORD PTR [edx+12], eax

; 29   : 
; 30   : 	// Allocate and intialize the callback list.
; 31   : 	CBlist = new TimeCallBack[MAX_TOD_CALLBACKS];

	push	512					; 00000200H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+32], edx

; 32   : 	memset( CBlist, 0, sizeof(CBlist[0]) * MAX_TOD_CALLBACKS );

	push	512					; 00000200H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 33   : 	nextCallToMake = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 34   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Setup@TimeManager@@QAEXHH@Z ENDP			; TimeManager::Setup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ??1TimeManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TimeManager@@QAE@XZ PROC				; TimeManager::~TimeManager, COMDAT
; _this$ = ecx

; 31   : 	~TimeManager()		{ if (IsReady())	Cleanup (); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReady@TimeManager@@QAEHXZ		; TimeManager::IsReady
	test	eax, eax
	je	SHORT $LN2@TimeManage
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@TimeManager@@QAEXXZ		; TimeManager::Cleanup
$LN2@TimeManage:
	mov	esp, ebp
	pop	ebp
	ret	0
??1TimeManager@@QAE@XZ ENDP				; TimeManager::~TimeManager
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ??0TimeManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TimeManager@@QAE@XZ PROC				; TimeManager::TimeManager, COMDAT
; _this$ = ecx

; 30   : 	TimeManager( void )	{ year = lastUpdateTime = currentTime = timeOfDay = today = 0; CBlist = NULL; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TimeManager@@QAE@XZ ENDP				; TimeManager::TimeManager
_TEXT	ENDS
END
