; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\Graphics\Weather\Tod.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?MoonPhaseMask@CTimeOfDay@@1PAEA		; CTimeOfDay::MoonPhaseMask
PUBLIC	?CurrentMoonPhaseMask@CTimeOfDay@@1PAEA		; CTimeOfDay::CurrentMoonPhaseMask
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
_BSS	SEGMENT
?MoonPhaseMask@CTimeOfDay@@1PAEA DB 0200H DUP (?)	; CTimeOfDay::MoonPhaseMask
?CurrentMoonPhaseMask@CTimeOfDay@@1PAEA DB 0200H DUP (?) ; CTimeOfDay::CurrentMoonPhaseMask
_BSS	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
_DATA	SEGMENT
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_DATA	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
PUBLIC	_sinf
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?glConvertFromDegree@@YAHM@Z			; glConvertFromDegree
PUBLIC	?glConvertFromDegreef@@YAMM@Z			; glConvertFromDegreef
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetYearAD@TimeManager@@QAEKXZ			; TimeManager::GetYearAD
PUBLIC	?GetDayOfYear@TimeManager@@QAEKXZ		; TimeManager::GetDayOfYear
PUBLIC	?GetTimeOfDay@TimeManager@@QAEKXZ		; TimeManager::GetTimeOfDay
PUBLIC	?GetClockTime@TimeManager@@QAEKXZ		; TimeManager::GetClockTime
PUBLIC	??0CStar@@QAE@XZ				; CStar::CStar
PUBLIC	??1CStar@@UAE@XZ				; CStar::~CStar
PUBLIC	?GetStarData@CStar@@SAPAUStarData@@XZ		; CStar::GetStarData
PUBLIC	?SetSunPosition@CStar@@SAXMM@Z			; CStar::SetSunPosition
PUBLIC	?SetMoonPosition@CStar@@SAXMM@Z			; CStar::SetMoonPosition
PUBLIC	??_GCStar@@UAEPAXI@Z				; CStar::`scalar deleting destructor'
PUBLIC	??0CTimeOfDay@@QAE@XZ				; CTimeOfDay::CTimeOfDay
PUBLIC	??1CTimeOfDay@@QAE@XZ				; CTimeOfDay::~CTimeOfDay
PUBLIC	?Setup@CTimeOfDay@@QAEXPAD@Z			; CTimeOfDay::Setup
PUBLIC	?Cleanup@CTimeOfDay@@QAEXXZ			; CTimeOfDay::Cleanup
PUBLIC	?SetNVGmode@CTimeOfDay@@QAEXH@Z			; CTimeOfDay::SetNVGmode
PUBLIC	?IsReady@CTimeOfDay@@QAEHXZ			; CTimeOfDay::IsReady
PUBLIC	?GetLightDirection@CTimeOfDay@@QAEXPAUTpoint@@@Z ; CTimeOfDay::GetLightDirection
PUBLIC	?CalculateSunMoonPos@CTimeOfDay@@QAEXPAUTpoint@@H@Z ; CTimeOfDay::CalculateSunMoonPos
PUBLIC	?CalculateSunGroundPos@CTimeOfDay@@QAEXPAUTpoint@@@Z ; CTimeOfDay::CalculateSunGroundPos
PUBLIC	?SetSunGlareAngle@CTimeOfDay@@QAEXH@Z		; CTimeOfDay::SetSunGlareAngle
PUBLIC	?GetSunGlare@CTimeOfDay@@QAEMHH@Z		; CTimeOfDay::GetSunGlare
PUBLIC	?CreateMoonPhaseMask@CTimeOfDay@@QAEXPAEH@Z	; CTimeOfDay::CreateMoonPhaseMask
PUBLIC	?UpdateWeatherColors@CTimeOfDay@@QAEXK@Z	; CTimeOfDay::UpdateWeatherColors
PUBLIC	?CalculateMoonPhase@CTimeOfDay@@QAEXXZ		; CTimeOfDay::CalculateMoonPhase
PUBLIC	?RotateMoonMask@CTimeOfDay@@QAEXH@Z		; CTimeOfDay::RotateMoonMask
PUBLIC	?ThereIsASun@CTimeOfDay@@QAEHXZ			; CTimeOfDay::ThereIsASun
PUBLIC	?ThereIsAMoon@CTimeOfDay@@QAEHXZ		; CTimeOfDay::ThereIsAMoon
PUBLIC	?GetSunPitch@CTimeOfDay@@QAEHXZ			; CTimeOfDay::GetSunPitch
PUBLIC	?GetSunYaw@CTimeOfDay@@QAEHXZ			; CTimeOfDay::GetSunYaw
PUBLIC	?GetMoonPitch@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetMoonPitch
PUBLIC	?GetMoonYaw@CTimeOfDay@@QAEHXZ			; CTimeOfDay::GetMoonYaw
PUBLIC	?CalculateMoonPercent@CTimeOfDay@@QAEHXZ	; CTimeOfDay::CalculateMoonPercent
PUBLIC	?CalculateMoonBlend@CTimeOfDay@@QAEMM@Z		; CTimeOfDay::CalculateMoonBlend
PUBLIC	?CreateMoonPhase@CTimeOfDay@@QAEXPAE0@Z		; CTimeOfDay::CreateMoonPhase
PUBLIC	?UpdateSkyProperties@CTimeOfDay@@IAEXXZ		; CTimeOfDay::UpdateSkyProperties
PUBLIC	?SetVar@CTimeOfDay@@IAEXPAUTimeOfDayStruct@@@Z	; CTimeOfDay::SetVar
PUBLIC	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z	; CTimeOfDay::SetDefaultColor
PUBLIC	?ReadTODFile@CTimeOfDay@@IAEHPAU_iobuf@@PAUTimeOfDayStruct@@H@Z ; CTimeOfDay::ReadTODFile
PUBLIC	?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z		; CTimeOfDay::MakeColor
PUBLIC	?TimeUpdateCallback@CTimeOfDay@@KAXPAX@Z	; CTimeOfDay::TimeUpdateCallback
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?InsideOvercast@RealWeather@@QAE_NXZ		; RealWeather::InsideOvercast
PUBLIC	?UnderOvercast@RealWeather@@QAE_NXZ		; RealWeather::UnderOvercast
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_7CStar@@6B@					; CStar::`vftable'
PUBLIC	?TheTimeOfDay@@3VCTimeOfDay@@A			; TheTimeOfDay
PUBLIC	?TheStar@@3VCStar@@A				; TheStar
PUBLIC	??_C@_0M@ICLMKAHJ@?$CFs?2star?4dat?$AA@		; `string'
PUBLIC	??_C@_0L@DOMPLMHA@?$CFs?2tod?4lst?$AA@		; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CE@KJCMLJIH@No?5data?5obtained?5from?5TOD?5file?3?5@ ; `string'
PUBLIC	??_C@_0M@CFLADCE@Feb?518?52013?$AA@		; `string'
PUBLIC	??_C@_07IJIGHEME@Tod?4cpp?$AA@			; `string'
PUBLIC	??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BN@KPMPBEF@Failed?5TOD?5memory?5allocation?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_04MOLBCOPG@ZZZZ?$AA@			; `string'
PUBLIC	??_C@_04OHBONDIN@TIME?$AA@			; `string'
PUBLIC	??_C@_0M@GPKBBLOC@?$CFld?3?$CFld?3?$CFld?$AA@	; `string'
PUBLIC	??_C@_07IJBDOLPH@SUNTILT?$AA@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_08MNFPCDIE@MOONTILT?$AA@			; `string'
PUBLIC	??_C@_06PJIJMAIL@SUNYAW?$AA@			; `string'
PUBLIC	??_C@_07LBGMMAOH@MOONYAW?$AA@			; `string'
PUBLIC	??_C@_0BA@CGBGFJNH@HAZESUNSETCOLOR?$AA@		; `string'
PUBLIC	??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@	; `string'
PUBLIC	??_C@_0BB@MGNGOPJH@HAZESUNRISECOLOR?$AA@	; `string'
PUBLIC	??_C@_08OBHFEBMJ@SKYCOLOR?$AA@			; `string'
PUBLIC	??_C@_0N@KGMCODPI@HAZESKYCOLOR?$AA@		; `string'
PUBLIC	??_C@_0M@EKMCHPFP@GROUNDCOLOR?$AA@		; `string'
PUBLIC	??_C@_0BA@KGFPAIPL@HAZEGROUNDCOLOR?$AA@		; `string'
PUBLIC	??_C@_0BA@FFMIBFHJ@TEXTURELIGHTING?$AA@		; `string'
PUBLIC	??_C@_0BD@BAHCCJDF@BADWEATHERLIGHTING?$AA@	; `string'
PUBLIC	??_C@_07EFFMPHJG@AMBIENT?$AA@			; `string'
PUBLIC	??_C@_07PHAMEMIK@DIFFUSE?$AA@			; `string'
PUBLIC	??_C@_08EABEDICH@SPECULAR?$AA@			; `string'
PUBLIC	??_C@_08MKFDJMK@SUNPITCH?$AA@			; `string'
PUBLIC	??_C@_09MFONFFIE@MOONPITCH?$AA@			; `string'
PUBLIC	??_C@_04PLNEPNCN@STAR?$AA@			; `string'
PUBLIC	??_C@_09DLHNKEKO@RAINCOLOR?$AA@			; `string'
PUBLIC	??_C@_09DPCPNANL@SNOWCOLOR?$AA@			; `string'
PUBLIC	??_C@_0O@DEPEJMDN@MINVISIBILITY?$AA@		; `string'
PUBLIC	??_C@_08ENLHFMLF@VISCOLOR?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CStar@@6B@					; CStar::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCStar@@@8				; CStar `RTTI Type Descriptor'
PUBLIC	??_R3CStar@@8					; CStar::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStar@@8					; CStar::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CStar@@8				; CStar::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3db2b8c3
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e860a92
PUBLIC	__real@3e99999a
PUBLIC	__real@3ee66666
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f2b851f
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3fa00000
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@41300000
PUBLIC	__real@42000000
PUBLIC	__real@42360b61
PUBLIC	__real@42800000
PUBLIC	__real@43000000
PUBLIC	__real@437fe666
PUBLIC	__real@44800000
PUBLIC	__real@46000000
PUBLIC	__real@4a000000
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_fclose:PROC
EXTRN	_fscanf:PROC
EXTRN	_fseek:PROC
EXTRN	_sprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strupr:PROC
EXTRN	_abs:PROC
EXTRN	_atan:PROC
EXTRN	_sin:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_exit:PROC
EXTRN	?glGetCosine@@YANH@Z:PROC			; glGetCosine
EXTRN	?glGetSinCos@@YAXPAM0H@Z:PROC			; glGetSinCos
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?Refresh@TimeManager@@QAEXXZ:PROC		; TimeManager::Refresh
EXTRN	?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z:PROC ; TimeManager::RegisterTimeUpdateCB
EXTRN	?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z:PROC ; TimeManager::ReleaseTimeUpdateCB
EXTRN	?Setup@CStar@@SAHPADM@Z:PROC			; CStar::Setup
EXTRN	?Cleanup@CStar@@SAXXZ:PROC			; CStar::Cleanup
EXTRN	?CalculateDate@CStar@@SAXPAH00H@Z:PROC		; CStar::CalculateDate
EXTRN	?SetDate@CStar@@SAXHHH@Z:PROC			; CStar::SetDate
EXTRN	?SetUniversalTime@CStar@@SAXI@Z:PROC		; CStar::SetUniversalTime
EXTRN	?SetLocation@CStar@@SAXMM@Z:PROC		; CStar::SetLocation
EXTRN	?SetHorizon@CStar@@SAXMM@Z:PROC			; CStar::SetHorizon
EXTRN	?UpdateStar@CStar@@SAXXZ:PROC			; CStar::UpdateStar
EXTRN	?GetSunRaDec@CStar@@SAXPAM0@Z:PROC		; CStar::GetSunRaDec
EXTRN	?GetMoonRaDec@CStar@@SAXPAM0@Z:PROC		; CStar::GetMoonRaDec
EXTRN	?ConvertCoord@CStar@@SAXMMPAM00@Z:PROC		; CStar::ConvertCoord
EXTRN	?ConvertPosition@CStar@@SAXMMPAM0@Z:PROC	; CStar::ConvertPosition
EXTRN	?GetMoonPhase@CStar@@SAMXZ:PROC			; CStar::GetMoonPhase
EXTRN	??_ECStar@@UAEPAXI@Z:PROC			; CStar::`vector deleting destructor'
EXTRN	?FILE_Open@@YAPAU_iobuf@@PAD0@Z:PROC		; FILE_Open
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?TheTimeManager@@3VTimeManager@@A:BYTE		; TheTimeManager
EXTRN	?CurrentStarData@CStar@@1PAUStarData@@A:DWORD	; CStar::CurrentStarData
EXTRN	?SunAz@CStar@@1MA:DWORD				; CStar::SunAz
EXTRN	?SunAlt@CStar@@1MA:DWORD			; CStar::SunAlt
EXTRN	?MoonAz@CStar@@1MA:DWORD			; CStar::MoonAz
EXTRN	?MoonAlt@CStar@@1MA:DWORD			; CStar::MoonAlt
EXTRN	?realWeather@@3PAVRealWeather@@A:DWORD		; realWeather
EXTRN	?g_fLatitude@@3MA:DWORD				; g_fLatitude
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?TheTimeOfDay@@3VCTimeOfDay@@A DB 0160H DUP (?)		; TheTimeOfDay
?TheStar@@3VCStar@@A DD 01H DUP (?)			; TheStar
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@4a000000
CONST	SEGMENT
__real@4a000000 DD 04a000000r			; 2.09715e+006
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@437fe666
CONST	SEGMENT
__real@437fe666 DD 0437fe666r			; 255.9
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42360b61
CONST	SEGMENT
__real@42360b61 DD 042360b61r			; 45.5111
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f2b851f
CONST	SEGMENT
__real@3f2b851f DD 03f2b851fr			; 0.67
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e860a92
CONST	SEGMENT
__real@3e860a92 DD 03e860a92r			; 0.261799
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db2b8c3
CONST	SEGMENT
__real@3db2b8c3 DD 03db2b8c3r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CStar@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CStar@@8 DD FLAT:??_R0?AVCStar@@@8	; CStar::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStar@@8
rdata$r	ENDS
;	COMDAT ??_R2CStar@@8
rdata$r	SEGMENT
??_R2CStar@@8 DD FLAT:??_R1A@?0A@EA@CStar@@8		; CStar::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CStar@@8
rdata$r	SEGMENT
??_R3CStar@@8 DD 00H					; CStar::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CStar@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStar@@@8
_DATA	SEGMENT
??_R0?AVCStar@@@8 DD FLAT:??_7type_info@@6B@		; CStar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStar@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CStar@@6B@
rdata$r	SEGMENT
??_R4CStar@@6B@ DD 00H					; CStar::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCStar@@@8
	DD	FLAT:??_R3CStar@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENLHFMLF@VISCOLOR?$AA@
CONST	SEGMENT
??_C@_08ENLHFMLF@VISCOLOR?$AA@ DB 'VISCOLOR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEPEJMDN@MINVISIBILITY?$AA@
CONST	SEGMENT
??_C@_0O@DEPEJMDN@MINVISIBILITY?$AA@ DB 'MINVISIBILITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPCPNANL@SNOWCOLOR?$AA@
CONST	SEGMENT
??_C@_09DPCPNANL@SNOWCOLOR?$AA@ DB 'SNOWCOLOR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DLHNKEKO@RAINCOLOR?$AA@
CONST	SEGMENT
??_C@_09DLHNKEKO@RAINCOLOR?$AA@ DB 'RAINCOLOR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLNEPNCN@STAR?$AA@
CONST	SEGMENT
??_C@_04PLNEPNCN@STAR?$AA@ DB 'STAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFONFFIE@MOONPITCH?$AA@
CONST	SEGMENT
??_C@_09MFONFFIE@MOONPITCH?$AA@ DB 'MOONPITCH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MKFDJMK@SUNPITCH?$AA@
CONST	SEGMENT
??_C@_08MKFDJMK@SUNPITCH?$AA@ DB 'SUNPITCH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EABEDICH@SPECULAR?$AA@
CONST	SEGMENT
??_C@_08EABEDICH@SPECULAR?$AA@ DB 'SPECULAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PHAMEMIK@DIFFUSE?$AA@
CONST	SEGMENT
??_C@_07PHAMEMIK@DIFFUSE?$AA@ DB 'DIFFUSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFFMPHJG@AMBIENT?$AA@
CONST	SEGMENT
??_C@_07EFFMPHJG@AMBIENT?$AA@ DB 'AMBIENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BAHCCJDF@BADWEATHERLIGHTING?$AA@
CONST	SEGMENT
??_C@_0BD@BAHCCJDF@BADWEATHERLIGHTING?$AA@ DB 'BADWEATHERLIGHTING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FFMIBFHJ@TEXTURELIGHTING?$AA@
CONST	SEGMENT
??_C@_0BA@FFMIBFHJ@TEXTURELIGHTING?$AA@ DB 'TEXTURELIGHTING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KGFPAIPL@HAZEGROUNDCOLOR?$AA@
CONST	SEGMENT
??_C@_0BA@KGFPAIPL@HAZEGROUNDCOLOR?$AA@ DB 'HAZEGROUNDCOLOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EKMCHPFP@GROUNDCOLOR?$AA@
CONST	SEGMENT
??_C@_0M@EKMCHPFP@GROUNDCOLOR?$AA@ DB 'GROUNDCOLOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KGMCODPI@HAZESKYCOLOR?$AA@
CONST	SEGMENT
??_C@_0N@KGMCODPI@HAZESKYCOLOR?$AA@ DB 'HAZESKYCOLOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBHFEBMJ@SKYCOLOR?$AA@
CONST	SEGMENT
??_C@_08OBHFEBMJ@SKYCOLOR?$AA@ DB 'SKYCOLOR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGNGOPJH@HAZESUNRISECOLOR?$AA@
CONST	SEGMENT
??_C@_0BB@MGNGOPJH@HAZESUNRISECOLOR?$AA@ DB 'HAZESUNRISECOLOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
CONST	SEGMENT
??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@ DB '%f %f %f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGBGFJNH@HAZESUNSETCOLOR?$AA@
CONST	SEGMENT
??_C@_0BA@CGBGFJNH@HAZESUNSETCOLOR?$AA@ DB 'HAZESUNSETCOLOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBGMMAOH@MOONYAW?$AA@
CONST	SEGMENT
??_C@_07LBGMMAOH@MOONYAW?$AA@ DB 'MOONYAW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PJIJMAIL@SUNYAW?$AA@
CONST	SEGMENT
??_C@_06PJIJMAIL@SUNYAW?$AA@ DB 'SUNYAW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNFPCDIE@MOONTILT?$AA@
CONST	SEGMENT
??_C@_08MNFPCDIE@MOONTILT?$AA@ DB 'MOONTILT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJBDOLPH@SUNTILT?$AA@
CONST	SEGMENT
??_C@_07IJBDOLPH@SUNTILT?$AA@ DB 'SUNTILT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPKBBLOC@?$CFld?3?$CFld?3?$CFld?$AA@
CONST	SEGMENT
??_C@_0M@GPKBBLOC@?$CFld?3?$CFld?3?$CFld?$AA@ DB '%ld:%ld:%ld', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHBONDIN@TIME?$AA@
CONST	SEGMENT
??_C@_04OHBONDIN@TIME?$AA@ DB 'TIME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOLBCOPG@ZZZZ?$AA@
CONST	SEGMENT
??_C@_04MOLBCOPG@ZZZZ?$AA@ DB 'ZZZZ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KPMPBEF@Failed?5TOD?5memory?5allocation?$AA@
CONST	SEGMENT
??_C@_0BN@KPMPBEF@Failed?5TOD?5memory?5allocation?$AA@ DB 'Failed TOD mem'
	DB	'ory allocation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@ DB 'Error:  %'
	DB	'0d  %s  %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJIGHEME@Tod?4cpp?$AA@
CONST	SEGMENT
??_C@_07IJIGHEME@Tod?4cpp?$AA@ DB 'Tod.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
CONST	SEGMENT
??_C@_0M@CFLADCE@Feb?518?52013?$AA@ DB 'Feb 18 2013', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KJCMLJIH@No?5data?5obtained?5from?5TOD?5file?3?5@
CONST	SEGMENT
??_C@_0CE@KJCMLJIH@No?5data?5obtained?5from?5TOD?5file?3?5@ DB 'No data o'
	DB	'btained from TOD file:  %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DOMPLMHA@?$CFs?2tod?4lst?$AA@
CONST	SEGMENT
??_C@_0L@DOMPLMHA@?$CFs?2tod?4lst?$AA@ DB '%s\tod.lst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICLMKAHJ@?$CFs?2star?4dat?$AA@
CONST	SEGMENT
??_C@_0M@ICLMKAHJ@?$CFs?2star?4dat?$AA@ DB '%s\star.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CStar@@6B@
CONST	SEGMENT
??_7CStar@@6B@ DD FLAT:??_R4CStar@@6B@			; CStar::`vftable'
	DD	FLAT:??_ECStar@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_TheStar$initializer$ DD FLAT:??__ETheStar@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_TheTimeOfDay$initializer$ DD FLAT:??__ETheTimeOfDay@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FTheTimeOfDay@@YAXXZ
text$yd	SEGMENT
??__FTheTimeOfDay@@YAXXZ PROC				; `dynamic atexit destructor for 'TheTimeOfDay'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	??1CTimeOfDay@@QAE@XZ			; CTimeOfDay::~CTimeOfDay
	pop	ebp
	ret	0
??__FTheTimeOfDay@@YAXXZ ENDP				; `dynamic atexit destructor for 'TheTimeOfDay''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
;	COMDAT ??__ETheTimeOfDay@@YAXXZ
text$yc	SEGMENT
??__ETheTimeOfDay@@YAXXZ PROC				; `dynamic initializer for 'TheTimeOfDay'', COMDAT

; 31   : CTimeOfDay	TheTimeOfDay;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	??0CTimeOfDay@@QAE@XZ			; CTimeOfDay::CTimeOfDay
	push	OFFSET ??__FTheTimeOfDay@@YAXXZ		; `dynamic atexit destructor for 'TheTimeOfDay''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__ETheTimeOfDay@@YAXXZ ENDP				; `dynamic initializer for 'TheTimeOfDay''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FTheStar@@YAXXZ
text$yd	SEGMENT
??__FTheStar@@YAXXZ PROC				; `dynamic atexit destructor for 'TheStar'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?TheStar@@3VCStar@@A	; TheStar
	call	??1CStar@@UAE@XZ			; CStar::~CStar
	pop	ebp
	ret	0
??__FTheStar@@YAXXZ ENDP				; `dynamic atexit destructor for 'TheStar''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
;	COMDAT ??__ETheStar@@YAXXZ
text$yc	SEGMENT
??__ETheStar@@YAXXZ PROC				; `dynamic initializer for 'TheStar'', COMDAT

; 28   : CStar	TheStar;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?TheStar@@3VCStar@@A	; TheStar
	call	??0CStar@@QAE@XZ			; CStar::CStar
	push	OFFSET ??__FTheStar@@YAXXZ		; `dynamic atexit destructor for 'TheStar''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__ETheStar@@YAXXZ ENDP				; `dynamic initializer for 'TheStar''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\realweather.h
;	COMDAT ?UnderOvercast@RealWeather@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnderOvercast@RealWeather@@QAE_NXZ PROC		; RealWeather::UnderOvercast, COMDAT
; _this$ = ecx

; 150  : 	bool	UnderOvercast() { return UnderOVCST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+15996]
	mov	esp, ebp
	pop	ebp
	ret	0
?UnderOvercast@RealWeather@@QAE_NXZ ENDP		; RealWeather::UnderOvercast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\realweather.h
;	COMDAT ?InsideOvercast@RealWeather@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InsideOvercast@RealWeather@@QAE_NXZ PROC		; RealWeather::InsideOvercast, COMDAT
; _this$ = ecx

; 149  : 	bool	InsideOvercast() { return InsideOVCST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+15998]
	mov	esp, ebp
	pop	ebp
	ret	0
?InsideOvercast@RealWeather@@QAE_NXZ ENDP		; RealWeather::InsideOvercast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_self$ = 8						; size = 4
?TimeUpdateCallback@CTimeOfDay@@KAXPAX@Z PROC		; CTimeOfDay::TimeUpdateCallback

; 209  : {

	push	ebp
	mov	ebp, esp

; 210  : 	((CTimeOfDay*)self)->UpdateSkyProperties();

	mov	ecx, DWORD PTR _self$[ebp]
	call	?UpdateSkyProperties@CTimeOfDay@@IAEXXZ	; CTimeOfDay::UpdateSkyProperties

; 211  : }

	pop	ebp
	ret	0
?TimeUpdateCallback@CTimeOfDay@@KAXPAX@Z ENDP		; CTimeOfDay::TimeUpdateCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_col$ = 8						; size = 4
?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z PROC		; CTimeOfDay::MakeColor

; 981  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 982  :     return 
; 983  : 	(FloatToInt32(col->r * 255.9f) & 0xFF) |
; 984  : 	((FloatToInt32(col->g * 255.9f) & 0xFF) <<  8) |
; 985  : 	((FloatToInt32(col->b * 255.9f) & 0xFF) << 16) |
; 986  : 	0xff000000;

	mov	eax, DWORD PTR _col$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@437fe666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esi, eax
	and	esi, 255				; 000000ffH
	mov	ecx, DWORD PTR _col$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR __real@437fe666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	edx, DWORD PTR _col$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR __real@437fe666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	and	eax, 255				; 000000ffH
	shl	eax, 16					; 00000010H
	or	esi, eax
	or	esi, -16777216				; ff000000H
	mov	eax, esi

; 987  : }

	pop	esi
	pop	ebp
	ret	0
?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z ENDP		; CTimeOfDay::MakeColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_ivar2$1 = -108						; size = 4
_ivar3$2 = -104						; size = 4
_ivar1$3 = -100						; size = 4
_total$ = -96						; size = 4
_fvar$ = -92						; size = 4
_this$ = -88						; size = 4
_buffer$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_tod$ = 12						; size = 4
_countflag$ = 16					; size = 4
?ReadTODFile@CTimeOfDay@@IAEHPAU_iobuf@@PAUTimeOfDayStruct@@H@Z PROC ; CTimeOfDay::ReadTODFile
; _this$ = ecx

; 592  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 	float	fvar;
; 594  : 	int		total;
; 595  : 	char	buffer[80];
; 596  : 
; 597  : 	total = 0;

	mov	DWORD PTR _total$[ebp], 0
$LN52@ReadTODFil:

; 598  : 	while (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN51@ReadTODFil

; 599  : 		fscanf (in, "%s", buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 12					; 0000000cH

; 600  : 		strupr (buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strupr
	add	esp, 4

; 601  : 		if (strcmp( buffer, "ZZZZ" ) == 0) {

	push	OFFSET ??_C@_04MOLBCOPG@ZZZZ?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN50@ReadTODFil

; 602  : 		    SetDefaultColor(&tod->RainColor, &tod->HazeGroundColor);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ; CTimeOfDay::SetDefaultColor

; 603  : 		    SetDefaultColor(&tod->SnowColor, &tod->HazeGroundColor);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ; CTimeOfDay::SetDefaultColor

; 604  : 		    SetDefaultColor(&tod->VisColor, &tod->HazeSkyColor);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ; CTimeOfDay::SetDefaultColor

; 605  : 			break;

	jmp	$LN51@ReadTODFil
	jmp	$LN2@ReadTODFil
$LN50@ReadTODFil:

; 606  : 		} else if (strcmp( buffer, "TIME" ) == 0) {

	push	OFFSET ??_C@_04OHBONDIN@TIME?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN48@ReadTODFil

; 607  : 			DWORD	ivar1, ivar2, ivar3;
; 608  : 			if (total != 0) {

	cmp	DWORD PTR _total$[ebp], 0
	je	SHORT $LN47@ReadTODFil

; 609  : 			    SetDefaultColor(&tod->RainColor, &tod->HazeGroundColor);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ; CTimeOfDay::SetDefaultColor

; 610  : 			    SetDefaultColor(&tod->SnowColor, &tod->HazeGroundColor);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ; CTimeOfDay::SetDefaultColor

; 611  : 			    SetDefaultColor(&tod->VisColor, &tod->HazeSkyColor);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 140				; 0000008cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ; CTimeOfDay::SetDefaultColor
$LN47@ReadTODFil:

; 612  : 			}
; 613  : 			total++;

	mov	eax, DWORD PTR _total$[ebp]
	add	eax, 1
	mov	DWORD PTR _total$[ebp], eax

; 614  : 			if (!countflag) tod++;

	cmp	DWORD PTR _countflag$[ebp], 0
	jne	SHORT $LN46@ReadTODFil
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 156				; 0000009cH
	mov	DWORD PTR _tod$[ebp], ecx
$LN46@ReadTODFil:

; 615  : 
; 616  : 			fscanf (in, "%ld:%ld:%ld", &ivar1, &ivar2, &ivar3);

	lea	edx, DWORD PTR _ivar3$2[ebp]
	push	edx
	lea	eax, DWORD PTR _ivar2$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _ivar1$3[ebp]
	push	ecx
	push	OFFSET ??_C@_0M@GPKBBLOC@?$CFld?3?$CFld?3?$CFld?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 20					; 00000014H

; 617  : 			ivar1 *= 3600000;

	mov	eax, DWORD PTR _ivar1$3[ebp]
	imul	eax, 3600000				; 0036ee80H
	mov	DWORD PTR _ivar1$3[ebp], eax

; 618  : 			ivar2 *= 60000;

	mov	ecx, DWORD PTR _ivar2$1[ebp]
	imul	ecx, 60000				; 0000ea60H
	mov	DWORD PTR _ivar2$1[ebp], ecx

; 619  : 			ivar3 *= 1000;

	mov	edx, DWORD PTR _ivar3$2[ebp]
	imul	edx, 1000				; 000003e8H
	mov	DWORD PTR _ivar3$2[ebp], edx

; 620  : 			tod -> Time = ivar1 + ivar2 + ivar3;

	mov	eax, DWORD PTR _ivar1$3[ebp]
	add	eax, DWORD PTR _ivar2$1[ebp]
	add	eax, DWORD PTR _ivar3$2[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	DWORD PTR [ecx], eax

; 621  : 			tod -> Flag = 0;

	mov	edx, DWORD PTR _tod$[ebp]
	mov	DWORD PTR [edx+88], 0

; 622  : 			tod -> StarIntensity = 0.0f;

	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+100], xmm0

; 623  : 			tod->LightningColor.r = tod->LightningColor.g = 1; tod->LightningColor.b = 0;

	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+132], xmm0
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+128], xmm0
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+136], xmm0

; 624  : 			tod->RainColor.r = tod->RainColor.g = tod->RainColor.b = 1;

	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+112], xmm0
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+108], xmm0
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+104], xmm0

; 625  : 			tod->SnowColor.r = tod->SnowColor.g = tod->SnowColor.b = 1;

	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+124], xmm0
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+120], xmm0
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+116], xmm0

; 626  : 			tod->VisColor.r = tod->VisColor.g = tod->VisColor.b = -1;

	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+148], xmm0
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+144], xmm0
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+140], xmm0

; 627  : 			tod->MinVis = 0.1f;

	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [ecx+152], xmm0
	jmp	$LN2@ReadTODFil
$LN48@ReadTODFil:

; 628  : 		}
; 629  : 		else if (strcmp( buffer, "SUNTILT" ) == 0) {

	push	OFFSET ??_C@_07IJBDOLPH@SUNTILT?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@ReadTODFil

; 630  : 			fscanf (in, "%f", &fvar);

	lea	eax, DWORD PTR _fvar$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf

; 631  : 			ISunTilt = glConvertFromDegree(fvar);

	add	esp, 8
	movss	xmm0, DWORD PTR _fvar$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?glConvertFromDegree@@YAHM@Z		; glConvertFromDegree
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+320], eax
	jmp	$LN2@ReadTODFil
$LN44@ReadTODFil:

; 632  : 		}
; 633  : 		else if (strcmp (buffer, "MOONTILT") == 0) {

	push	OFFSET ??_C@_08MNFPCDIE@MOONTILT?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@ReadTODFil

; 634  : 			fscanf (in, "%f", &fvar);

	lea	ecx, DWORD PTR _fvar$[ebp]
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf

; 635  : 			IMoonTilt = glConvertFromDegree(fvar);

	add	esp, 8
	movss	xmm0, DWORD PTR _fvar$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?glConvertFromDegree@@YAHM@Z		; glConvertFromDegree
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], eax
	jmp	$LN2@ReadTODFil
$LN42@ReadTODFil:

; 636  : 		}
; 637  : 
; 638  : //---- ignore these ----
; 639  : 		else if (strcmp( buffer, "SUNYAW" ) == 0) {

	push	OFFSET ??_C@_06PJIJMAIL@SUNYAW?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@ReadTODFil

; 640  : 			fscanf (in, "%f", &fvar);

	lea	eax, DWORD PTR _fvar$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH
	jmp	$LN2@ReadTODFil
$LN40@ReadTODFil:

; 641  : 		}
; 642  : 		else if (strcmp (buffer, "MOONYAW") == 0) {

	push	OFFSET ??_C@_07LBGMMAOH@MOONYAW?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@ReadTODFil

; 643  : 			fscanf (in, "%f", &fvar);

	lea	eax, DWORD PTR _fvar$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH
	jmp	$LN2@ReadTODFil
$LN38@ReadTODFil:

; 644  : 		}
; 645  : //----------------------
; 646  : 		else if (strcmp (buffer, "HAZESUNSETCOLOR") == 0) {

	push	OFFSET ??_C@_0BA@CGBGFJNH@HAZESUNSETCOLOR?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@ReadTODFil

; 647  : 			fscanf (in, "%f %f %f", &HazeSunsetColor.r, &HazeSunsetColor.g, &HazeSunsetColor.b);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 284				; 0000011cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 276				; 00000114H
	push	edx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN36@ReadTODFil:

; 648  : 		}
; 649  : 		else if (strcmp (buffer, "HAZESUNRISECOLOR") == 0) {

	push	OFFSET ??_C@_0BB@MGNGOPJH@HAZESUNRISECOLOR?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@ReadTODFil

; 650  : 			fscanf (in, "%f %f %f", &HazeSunriseColor.r, &HazeSunriseColor.g, &HazeSunriseColor.b);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 272				; 00000110H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 268				; 0000010cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	push	ecx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN34@ReadTODFil:

; 651  : 		}
; 652  : 		else if (strcmp (buffer, "SKYCOLOR") == 0) {

	push	OFFSET ??_C@_08OBHFEBMJ@SKYCOLOR?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@ReadTODFil

; 653  : 			fscanf (in, "%f %f %f", &tod -> SkyColor.r, &tod -> SkyColor.g, &tod -> SkyColor.b);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN32@ReadTODFil:

; 654  : 		}
; 655  : 		else if (strcmp (buffer, "HAZESKYCOLOR") == 0) {

	push	OFFSET ??_C@_0N@KGMCODPI@HAZESKYCOLOR?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@ReadTODFil

; 656  : 			fscanf (in, "%f %f %f", &tod -> HazeSkyColor.r, &tod -> HazeSkyColor.g, &tod -> HazeSkyColor.b);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN30@ReadTODFil:

; 657  : 		}
; 658  : 		else if (strcmp (buffer, "GROUNDCOLOR") == 0) {

	push	OFFSET ??_C@_0M@EKMCHPFP@GROUNDCOLOR?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN28@ReadTODFil

; 659  : 			fscanf (in, "%f %f %f", &tod -> GroundColor.r, &tod -> GroundColor.g, &tod -> GroundColor.b);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN28@ReadTODFil:

; 660  : 		}
; 661  : 		else if (strcmp (buffer, "HAZEGROUNDCOLOR") == 0) {

	push	OFFSET ??_C@_0BA@KGFPAIPL@HAZEGROUNDCOLOR?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@ReadTODFil

; 662  : 			fscanf (in, "%f %f %f", &tod -> HazeGroundColor.r, &tod -> HazeGroundColor.g, &tod -> HazeGroundColor.b);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 20					; 00000014H

; 663  : 			tod -> HazeGroundColor.r *= 0.7f;

	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR __real@3f333333
	mov	eax, DWORD PTR _tod$[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 664  : 			tod -> HazeGroundColor.g *= 0.7f;

	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR __real@3f333333
	mov	edx, DWORD PTR _tod$[ebp]
	movss	DWORD PTR [edx+44], xmm0

; 665  : 			tod -> HazeGroundColor.b *= 0.7f;

	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR __real@3f333333
	mov	ecx, DWORD PTR _tod$[ebp]
	movss	DWORD PTR [ecx+48], xmm0
	jmp	$LN2@ReadTODFil
$LN26@ReadTODFil:

; 666  : 		}
; 667  : 		else if (strcmp (buffer, "TEXTURELIGHTING") == 0) {

	push	OFFSET ??_C@_0BA@FFMIBFHJ@TEXTURELIGHTING?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@ReadTODFil

; 668  : 			fscanf (in, "%f %f %f", &tod -> TextureLighting.r, &tod -> TextureLighting.g, &tod -> TextureLighting.b);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN24@ReadTODFil:

; 669  : 		}
; 670  : 
; 671  : 		else if (strcmp (buffer, "BADWEATHERLIGHTING") == 0) {

	push	OFFSET ??_C@_0BD@BAHCCJDF@BADWEATHERLIGHTING?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@ReadTODFil

; 672  : 			fscanf (in, "%f %f %f", &tod -> BadWeatherLighting.r, &tod -> BadWeatherLighting.g, &tod -> BadWeatherLighting.b);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN22@ReadTODFil:

; 673  : 		}
; 674  : //		else if (strcmp (buffer, "LIGHTNINGCOLOR") == 0) {
; 675  : //			fscanf (in, "%f %f %f", &tod ->LightningColor.r, &tod ->LightningColor.g, &tod ->LightningColor.b);
; 676  : //		}
; 677  : 
; 678  : 		else if (strcmp (buffer, "AMBIENT") == 0) {

	push	OFFSET ??_C@_07EFFMPHJG@AMBIENT?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@ReadTODFil

; 679  : 			fscanf (in, "%f", &tod -> Ambient);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 12					; 0000000cH
	jmp	$LN2@ReadTODFil
$LN20@ReadTODFil:

; 680  : 		}
; 681  : 		else if (strcmp (buffer, "DIFFUSE") == 0) {

	push	OFFSET ??_C@_07PHAMEMIK@DIFFUSE?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@ReadTODFil

; 682  : 			fscanf (in, "%f", &tod -> Diffuse);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 12					; 0000000cH
	jmp	$LN2@ReadTODFil
$LN18@ReadTODFil:

; 683  : 		}
; 684  : 		else if (strcmp (buffer, "SPECULAR") == 0) {

	push	OFFSET ??_C@_08EABEDICH@SPECULAR?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@ReadTODFil

; 685  : 			fscanf (in, "%f", &tod ->Specular);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 12					; 0000000cH
	jmp	$LN2@ReadTODFil
$LN16@ReadTODFil:

; 686  : 		}
; 687  : 		else if (strcmp (buffer, "SUNPITCH") == 0) {

	push	OFFSET ??_C@_08MKFDJMK@SUNPITCH?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@ReadTODFil

; 688  : 			fscanf (in, "%f", &tod -> SunPitch);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 12					; 0000000cH

; 689  : 			tod -> SunPitch = glConvertFromDegreef (tod -> SunPitch);

	mov	eax, DWORD PTR _tod$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+92]
	movss	DWORD PTR [esp], xmm0
	call	?glConvertFromDegreef@@YAMM@Z		; glConvertFromDegreef
	add	esp, 4
	mov	ecx, DWORD PTR _tod$[ebp]
	fstp	DWORD PTR [ecx+92]

; 690  : 			tod -> Flag |= GL_TIME_OF_DAY_USE_SUN;

	mov	edx, DWORD PTR _tod$[ebp]
	mov	eax, DWORD PTR [edx+88]
	or	eax, 1
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	DWORD PTR [ecx+88], eax
	jmp	$LN2@ReadTODFil
$LN14@ReadTODFil:

; 691  : 		}
; 692  : 		else if (strcmp (buffer, "MOONPITCH") == 0) {

	push	OFFSET ??_C@_09MFONFFIE@MOONPITCH?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@ReadTODFil

; 693  : 			fscanf (in, "%f", &tod -> MoonPitch);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH

; 694  : 			tod -> MoonPitch = glConvertFromDegreef (tod -> MoonPitch);

	mov	edx, DWORD PTR _tod$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [esp], xmm0
	call	?glConvertFromDegreef@@YAMM@Z		; glConvertFromDegreef
	add	esp, 4
	mov	eax, DWORD PTR _tod$[ebp]
	fstp	DWORD PTR [eax+96]

; 695  : 			tod -> Flag |= GL_TIME_OF_DAY_USE_MOON;

	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	or	edx, 2
	mov	eax, DWORD PTR _tod$[ebp]
	mov	DWORD PTR [eax+88], edx
	jmp	$LN2@ReadTODFil
$LN12@ReadTODFil:

; 696  : 		}
; 697  : 		else if (strcmp (buffer, "STAR") == 0) {

	push	OFFSET ??_C@_04PLNEPNCN@STAR?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@ReadTODFil

; 698  : 			tod -> StarIntensity = 1.0f;

	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+100], xmm0
	jmp	$LN2@ReadTODFil
$LN10@ReadTODFil:

; 699  : 		}
; 700  : 		// JPO additions
; 701  : 		else if (strcmp (buffer, "RAINCOLOR") == 0) {

	push	OFFSET ??_C@_09DLHNKEKO@RAINCOLOR?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@ReadTODFil

; 702  : 			fscanf (in, "%f %f %f", &tod ->RainColor.r, &tod ->RainColor.g, &tod ->RainColor.b);

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	$LN2@ReadTODFil
$LN8@ReadTODFil:

; 703  : 		}
; 704  : 		else if (strcmp (buffer, "SNOWCOLOR") == 0) {

	push	OFFSET ??_C@_09DPCPNANL@SNOWCOLOR?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@ReadTODFil

; 705  : 			fscanf (in, "%f %f %f", &tod ->SnowColor.r, &tod ->SnowColor.g, &tod ->SnowColor.b);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 120				; 00000078H
	push	ecx
	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fscanf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN2@ReadTODFil
$LN6@ReadTODFil:

; 706  : 		}
; 707  : 		else if (strcmp (buffer, "MINVISIBILITY") == 0) {

	push	OFFSET ??_C@_0O@DEPEJMDN@MINVISIBILITY?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@ReadTODFil

; 708  : 		    fscanf (in, "%f", &tod->MinVis);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 152				; 00000098H
	push	edx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fscanf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@ReadTODFil
$LN4@ReadTODFil:

; 709  : 		}
; 710  : 		else if (strcmp (buffer, "VISCOLOR") == 0) {

	push	OFFSET ??_C@_08ENLHFMLF@VISCOLOR?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@ReadTODFil

; 711  : 			fscanf (in, "%f %f %f", &tod ->VisColor.r, &tod ->VisColor.g, &tod ->VisColor.b);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	push	OFFSET ??_C@_08OEKJENGB@?$CFf?5?$CFf?5?$CFf?$AA@
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_fscanf
	add	esp, 20					; 00000014H
$LN2@ReadTODFil:

; 712  : 		}
; 713  : 		else {
; 714  : 		    //MonoPrint("Ignoring TOD item %s\n", buffer);
; 715  : 		}
; 716  : 	}

	jmp	$LN52@ReadTODFil
$LN51@ReadTODFil:

; 717  : 	return total;

	mov	eax, DWORD PTR _total$[ebp]

; 718  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadTODFile@CTimeOfDay@@IAEHPAU_iobuf@@PAUTimeOfDayStruct@@H@Z ENDP ; CTimeOfDay::ReadTODFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_defcol$ = 12						; size = 4
?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z PROC	; CTimeOfDay::SetDefaultColor
; _this$ = ecx

; 586  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 587  :     if (col->r ==-1)

	mov	eax, DWORD PTR _col$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@SetDefault

; 588  : 	*col = *defcol;

	mov	ecx, DWORD PTR _defcol$[ebp]
	mov	edx, DWORD PTR _col$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
$LN1@SetDefault:

; 589  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetDefaultColor@CTimeOfDay@@IAEXPAUTcolor@@0@Z ENDP	; CTimeOfDay::SetDefaultColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_tod$ = 8						; size = 4
?SetVar@CTimeOfDay@@IAEXPAUTimeOfDayStruct@@@Z PROC	; CTimeOfDay::SetVar
; _this$ = ecx

; 566  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 567  : 	m_SkyColor = tod ->SkyColor;

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 568  : 	m_HazeSkyColor = tod ->HazeSkyColor;

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 569  : 	m_GroundColor = tod ->GroundColor;

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 570  : 	m_HazeGroundColor = tod ->HazeGroundColor;

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 571  : 	m_TextureLighting = tod ->TextureLighting;

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 572  : 	m_BadWeatherLighting = tod ->BadWeatherLighting;

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 573  : 	m_Ambient = tod ->Ambient;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+116], edx

; 574  : 	m_Diffuse = tod ->Diffuse;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+120], edx

; 575  : 	m_Specular = tod ->Specular;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+124], edx

; 576  : 	Flag = tod -> Flag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+308], edx

; 577  : 	m_StarIntensity = tod -> StarIntensity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+144], edx

; 578  : 	RainColor = MakeColor(&tod->RainColor);

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	call	?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z	; CTimeOfDay::MakeColor
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 579  : 	SnowColor = MakeColor(&tod->SnowColor);

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	call	?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z	; CTimeOfDay::MakeColor
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 580  : 	LightningColor = tod->LightningColor;

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 128				; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 581  : 	m_MinVis = tod->MinVis;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+140], edx

; 582  : 	m_VisColor = tod->VisColor;

	mov	eax, DWORD PTR _tod$[ebp]
	add	eax, 140				; 0000008cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 583  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetVar@CTimeOfDay@@IAEXPAUTimeOfDayStruct@@@Z ENDP	; CTimeOfDay::SetVar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
tv1074 = -80						; size = 4
tv1123 = -76						; size = 4
_ra$ = -72						; size = 4
_curtime$ = -68						; size = 4
_dec$ = -64						; size = 4
_now$ = -60						; size = 4
_az$ = -56						; size = 4
_alt$ = -52						; size = 4
_i$ = -48						; size = 4
_n$ = -44						; size = 4
_c$ = -40						; size = 4
_tod$ = -36						; size = 4
_t1$1 = -32						; size = 4
_t$ = -28						; size = 4
_ntod$ = -24						; size = 4
_this$ = -20						; size = 4
_Color$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?UpdateSkyProperties@CTimeOfDay@@IAEXXZ PROC		; CTimeOfDay::UpdateSkyProperties
; _this$ = ecx

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 	int				i, c, n;
; 218  : 	TimeOfDayStruct	*tod, *ntod;
; 219  : 	unsigned		now;
; 220  : 	float			t;
; 221  : 
; 222  : 
; 223  : 	// Convert from time since clock start to time since midnight
; 224  : 	now = TheTimeManager.GetTimeOfDay();

	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?GetTimeOfDay@TimeManager@@QAEKXZ	; TimeManager::GetTimeOfDay
	mov	DWORD PTR _now$[ebp], eax

; 225  : 
; 226  : 	unsigned curtime = TheTimeManager.GetClockTime();

	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?GetClockTime@TimeManager@@QAEKXZ	; TimeManager::GetClockTime
	mov	DWORD PTR _curtime$[ebp], eax

; 227  : 	TheStar.SetUniversalTime( curtime );

	mov	eax, DWORD PTR _curtime$[ebp]
	push	eax
	call	?SetUniversalTime@CStar@@SAXI@Z		; CStar::SetUniversalTime
	add	esp, 4

; 228  : 	if (curtime) {

	cmp	DWORD PTR _curtime$[ebp], 0
	je	SHORT $LN17@UpdateSkyP

; 229  : 		if (lastMoonTime == 0 || lastMoonTime > curtime || ((curtime - lastMoonTime) > 60*60*1000)) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN16@UpdateSkyP
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR _curtime$[ebp]
	ja	SHORT $LN16@UpdateSkyP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _curtime$[ebp]
	sub	edx, DWORD PTR [ecx+28]
	cmp	edx, 3600000				; 0036ee80H
	jbe	SHORT $LN17@UpdateSkyP
$LN16@UpdateSkyP:

; 230  : 			lastMoonTime = curtime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curtime$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 231  : 			MoonPhase = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], -1

; 232  : 			MoonPhase = CalculateMoonPercent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMoonPercent@CTimeOfDay@@QAEHXZ ; CTimeOfDay::CalculateMoonPercent
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 233  : 			CreateMoonPhaseMask(MoonPhaseMask, MoonPhase);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET ?MoonPhaseMask@CTimeOfDay@@1PAEA	; CTimeOfDay::MoonPhaseMask
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateMoonPhaseMask@CTimeOfDay@@QAEXPAEH@Z ; CTimeOfDay::CreateMoonPhaseMask
$LN17@UpdateSkyP:

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 
; 238  : 	// Identify the Current time step in the TOD table
; 239  : 	for (i=0; i < TotalTimeOfDay;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@UpdateSkyP
$LN14@UpdateSkyP:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN15@UpdateSkyP:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	SHORT $LN13@UpdateSkyP

; 240  : 		if (TimeOfDay[i].Time > now) break;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx]
	cmp	ecx, DWORD PTR _now$[ebp]
	jbe	SHORT $LN12@UpdateSkyP
	jmp	SHORT $LN13@UpdateSkyP
$LN12@UpdateSkyP:

; 241  : 	}

	jmp	SHORT $LN14@UpdateSkyP
$LN13@UpdateSkyP:

; 242  : 	if (i == 0) c = TotalTimeOfDay - 1;

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN11@UpdateSkyP
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN8@UpdateSkyP
$LN11@UpdateSkyP:

; 243  : 	else if (i >= TotalTimeOfDay) c = TotalTimeOfDay - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jl	SHORT $LN9@UpdateSkyP
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx
	jmp	SHORT $LN8@UpdateSkyP
$LN9@UpdateSkyP:

; 244  : 	else c = i - 1;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _c$[ebp], edx
$LN8@UpdateSkyP:

; 245  : 
; 246  : 	// Identify the Next time step in the TOD table
; 247  : 	n = c + 1;

	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 248  : 	if (n >= TotalTimeOfDay) n = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jl	SHORT $LN7@UpdateSkyP
	mov	DWORD PTR _n$[ebp], 0
$LN7@UpdateSkyP:

; 249  : 
; 250  : 	// This should only happen if the table has less than two entries
; 251  : 	if (c == n) return;

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jne	SHORT $LN6@UpdateSkyP
	jmp	$LN19@UpdateSkyP
$LN6@UpdateSkyP:

; 252  : 
; 253  : 
; 254  : 	// Get pointers to the current and next TOD table entries
; 255  : 	tod = &(TimeOfDay[c]);

	mov	ecx, DWORD PTR _c$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _tod$[ebp], ecx

; 256  : 	ntod = &(TimeOfDay[n]);

	mov	eax, DWORD PTR _n$[ebp]
	imul	eax, 156				; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _ntod$[ebp], eax

; 257  : 
; 258  : 
; 259  : 	// No two table entries should have the same time stamp
; 260  : 	c = tod -> Time;

	mov	edx, DWORD PTR _tod$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax

; 261  : 	n = ntod -> Time;

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _n$[ebp], edx

; 262  : 	ShiAssert( c != n );
; 263  : 
; 264  : 	// Calculate the time between the two table entries
; 265  : 	if (n < c) n += MSEC_PER_DAY;

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	SHORT $LN5@UpdateSkyP
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 86400000				; 05265c00H
	mov	DWORD PTR _n$[ebp], ecx
$LN5@UpdateSkyP:

; 266  : 	n -= c;

	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _n$[ebp], edx

; 267  : 
; 268  : 	// Calculate the time between now and the current table entry
; 269  : 	if (now < (DWORD)c) now += MSEC_PER_DAY;

	mov	eax, DWORD PTR _now$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jae	SHORT $LN4@UpdateSkyP
	mov	ecx, DWORD PTR _now$[ebp]
	add	ecx, 86400000				; 05265c00H
	mov	DWORD PTR _now$[ebp], ecx
$LN4@UpdateSkyP:

; 270  : 	c = now - c;

	mov	edx, DWORD PTR _now$[ebp]
	sub	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 271  : 
; 272  : 	// Calculate the interpolation control variable "t"
; 273  : 	t = (float) c / (float) n;

	cvtsi2ss xmm0, DWORD PTR _c$[ebp]
	cvtsi2ss xmm1, DWORD PTR _n$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 274  : 
; 275  : 	// Set all our variable from the first record
; 276  : 	SetVar(tod);

	mov	eax, DWORD PTR _tod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVar@CTimeOfDay@@IAEXPAUTimeOfDayStruct@@@Z ; CTimeOfDay::SetVar

; 277  : 
; 278  :    	// Add in deltas toward the second record
; 279  : 	m_SkyColor.r			+= t * (ntod -> SkyColor.r - m_SkyColor.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 280  : 	m_SkyColor.g			+= t * (ntod -> SkyColor.g - m_SkyColor.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	subss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0

; 281  : 	m_SkyColor.b			+= t * (ntod -> SkyColor.b - m_SkyColor.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 282  : 	m_HazeSkyColor.r		+= t * (ntod -> HazeSkyColor.r - m_HazeSkyColor.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	subss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 283  : 	m_HazeSkyColor.g		+= t * (ntod -> HazeSkyColor.g - m_HazeSkyColor.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	subss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+60], xmm0

; 284  : 	m_HazeSkyColor.b		+= t * (ntod -> HazeSkyColor.b - m_HazeSkyColor.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	subss	xmm0, DWORD PTR [ecx+64]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+64]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+64], xmm0

; 285  : 	m_GroundColor.r			+= t * (ntod -> GroundColor.r - m_GroundColor.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	subss	xmm0, DWORD PTR [edx+68]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+68], xmm0

; 286  : 	m_GroundColor.g			+= t * (ntod -> GroundColor.g - m_GroundColor.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	subss	xmm0, DWORD PTR [eax+72]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+72], xmm0

; 287  : 	m_GroundColor.b			+= t * (ntod -> GroundColor.b - m_GroundColor.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	subss	xmm0, DWORD PTR [ecx+76]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+76], xmm0

; 288  : 	m_HazeGroundColor.r		+= t * (ntod -> HazeGroundColor.r - m_HazeGroundColor.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	subss	xmm0, DWORD PTR [edx+80]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+80], xmm0

; 289  : 	m_HazeGroundColor.g		+= t * (ntod -> HazeGroundColor.g - m_HazeGroundColor.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	subss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+84], xmm0

; 290  : 	m_HazeGroundColor.b		+= t * (ntod -> HazeGroundColor.b - m_HazeGroundColor.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR [ecx+88]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+88]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+88], xmm0

; 291  : 	m_TextureLighting.r		+= t * (ntod -> TextureLighting.r - m_TextureLighting.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	subss	xmm0, DWORD PTR [edx+92]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+92], xmm0

; 292  : 	m_TextureLighting.g		+= t * (ntod -> TextureLighting.g - m_TextureLighting.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	subss	xmm0, DWORD PTR [eax+96]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+96], xmm0

; 293  : 	m_TextureLighting.b		+= t * (ntod -> TextureLighting.b - m_TextureLighting.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	subss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+100]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 294  : 
; 295  : 	m_BadWeatherLighting.r	+= t * (ntod -> BadWeatherLighting.r - m_BadWeatherLighting.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	subss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+104]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 296  : 	m_BadWeatherLighting.g	+= t * (ntod -> BadWeatherLighting.g - m_BadWeatherLighting.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	subss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+108], xmm0

; 297  : 	m_BadWeatherLighting.b	+= t * (ntod -> BadWeatherLighting.b - m_BadWeatherLighting.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+72]
	subss	xmm0, DWORD PTR [ecx+112]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+112]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+112], xmm0

; 298  : 
; 299  : 	m_VisColor.r	+= t * (ntod -> VisColor.r - m_VisColor.r);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+140]
	subss	xmm0, DWORD PTR [edx+128]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+128], xmm0

; 300  : 	m_VisColor.g	+= t * (ntod -> VisColor.g - m_VisColor.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+144]
	subss	xmm0, DWORD PTR [eax+132]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+132]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+132], xmm0

; 301  : 	m_VisColor.b	+= t * (ntod -> VisColor.b - m_VisColor.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR [ecx+136]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+136]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+136], xmm0

; 302  : 
; 303  : 	Tcolor Color;
; 304  : 	Color = tod->RainColor;

	mov	ecx, DWORD PTR _tod$[ebp]
	add	ecx, 104				; 00000068H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _Color$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _Color$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _Color$[ebp+8], ecx

; 305  : 	Color.r		+= t * (ntod -> RainColor.r - tod->RainColor.r);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	subss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR _Color$[ebp]
	movss	DWORD PTR _Color$[ebp], xmm0

; 306  : 	Color.g		+= t * (ntod -> RainColor.g - tod->RainColor.g);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [ecx+108]
	subss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR _Color$[ebp+4]
	movss	DWORD PTR _Color$[ebp+4], xmm0

; 307  : 	Color.b		+= t * (ntod -> RainColor.b - tod->RainColor.b);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [eax+112]
	subss	xmm0, DWORD PTR [ecx+112]
	mulss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR _Color$[ebp+8]
	movss	DWORD PTR _Color$[ebp+8], xmm0

; 308  : 	RainColor = MakeColor(&Color);

	lea	edx, DWORD PTR _Color$[ebp]
	push	edx
	call	?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z	; CTimeOfDay::MakeColor
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 309  : 
; 310  : 	Color = tod->SnowColor;

	mov	edx, DWORD PTR _tod$[ebp]
	add	edx, 116				; 00000074H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Color$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _Color$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _Color$[ebp+8], edx

; 311  : 	Color.r		+= t * (ntod -> SnowColor.r - tod->SnowColor.r);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [eax+116]
	subss	xmm0, DWORD PTR [ecx+116]
	mulss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR _Color$[ebp]
	movss	DWORD PTR _Color$[ebp], xmm0

; 312  : 	Color.g		+= t * (ntod -> SnowColor.g - tod->SnowColor.g);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [edx+120]
	subss	xmm0, DWORD PTR [eax+120]
	mulss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR _Color$[ebp+4]
	movss	DWORD PTR _Color$[ebp+4], xmm0

; 313  : 	Color.b		+= t * (ntod -> SnowColor.b - tod->SnowColor.b);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	subss	xmm0, DWORD PTR [edx+124]
	mulss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR _Color$[ebp+8]
	movss	DWORD PTR _Color$[ebp+8], xmm0

; 314  : 	SnowColor = MakeColor(&Color);

	lea	eax, DWORD PTR _Color$[ebp]
	push	eax
	call	?MakeColor@CTimeOfDay@@KAKPAUTcolor@@@Z	; CTimeOfDay::MakeColor
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 315  : 
; 316  : 	LightningColor.r	+= t * (ntod -> LightningColor.r - tod->LightningColor.r);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [edx+128]
	subss	xmm0, DWORD PTR [eax+128]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+288]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+288], xmm0

; 317  : 	LightningColor.g	+= t * (ntod -> LightningColor.g - tod->LightningColor.g);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	subss	xmm0, DWORD PTR [ecx+132]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+292]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+292], xmm0

; 318  : 	LightningColor.b	+= t * (ntod -> LightningColor.b - tod->LightningColor.b);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _tod$[ebp]
	movss	xmm0, DWORD PTR [ecx+136]
	subss	xmm0, DWORD PTR [edx+136]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+296], xmm0

; 319  : 
; 320  : 	m_Ambient		+= t * (ntod -> Ambient - m_Ambient);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+76]
	subss	xmm0, DWORD PTR [eax+116]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+116]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+116], xmm0

; 321  : 	m_Diffuse		+= t * (ntod -> Diffuse - m_Diffuse);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	subss	xmm0, DWORD PTR [ecx+120]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+120]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 322  : 	m_Specular		+= t * (ntod -> Specular - m_Specular);

	mov	ecx, DWORD PTR _ntod$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+84]
	subss	xmm0, DWORD PTR [edx+124]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+124], xmm0

; 323  : 	m_MinVis		+= t * (ntod -> MinVis  - m_MinVis);

	mov	edx, DWORD PTR _ntod$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR [eax+140]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+140]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+140], xmm0

; 324  : 
; 325  : 	float	ra, dec, az, alt;
; 326  : 	TheStar.GetSunRaDec (&ra, &dec);

	lea	eax, DWORD PTR _dec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ra$[ebp]
	push	ecx
	call	?GetSunRaDec@CStar@@SAXPAM0@Z		; CStar::GetSunRaDec
	add	esp, 8

; 327  : 	TheStar.ConvertPosition (ra, dec, &az, &alt);

	lea	edx, DWORD PTR _alt$[ebp]
	push	edx
	lea	eax, DWORD PTR _az$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dec$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ra$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ConvertPosition@CStar@@SAXMMPAM0@Z	; CStar::ConvertPosition

; 328  : 	TheStar.SetSunPosition (az, alt);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _alt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SetSunPosition@CStar@@SAXMM@Z		; CStar::SetSunPosition
	add	esp, 8

; 329  : 	TheStar.ConvertCoord (ra, dec, &SunCoord.x, &SunCoord.y, &SunCoord.z);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dec$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ra$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ConvertCoord@CStar@@SAXMMPAM00@Z	; CStar::ConvertCoord
	add	esp, 20					; 00000014H

; 330  : 	ISunYaw = FloatToInt32 (radtoangle(az));

	movss	xmm0, DWORD PTR _az$[ebp]
	mulss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR __real@40490fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 331  : 	ISunPitch = FloatToInt32 (radtoangle(alt));

	movss	xmm0, DWORD PTR _alt$[ebp]
	mulss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR __real@40490fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], eax

; 332  : 	TheStar.GetMoonRaDec (&ra, &dec);

	lea	eax, DWORD PTR _dec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ra$[ebp]
	push	ecx
	call	?GetMoonRaDec@CStar@@SAXPAM0@Z		; CStar::GetMoonRaDec
	add	esp, 8

; 333  : 	TheStar.ConvertPosition (ra, dec, &az, &alt);

	lea	edx, DWORD PTR _alt$[ebp]
	push	edx
	lea	eax, DWORD PTR _az$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dec$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ra$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ConvertPosition@CStar@@SAXMMPAM0@Z	; CStar::ConvertPosition

; 334  : 	TheStar.SetMoonPosition (az, alt);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _alt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SetMoonPosition@CStar@@SAXMM@Z		; CStar::SetMoonPosition
	add	esp, 8

; 335  : 	TheStar.ConvertCoord (ra, dec, &MoonCoord.x, &MoonCoord.y, &MoonCoord.z);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dec$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ra$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ConvertCoord@CStar@@SAXMMPAM00@Z	; CStar::ConvertCoord
	add	esp, 20					; 00000014H

; 336  : 	IMoonYaw = FloatToInt32 (radtoangle(az));

	movss	xmm0, DWORD PTR _az$[ebp]
	mulss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR __real@40490fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 337  : 	IMoonPitch = FloatToInt32 (radtoangle(alt));

	movss	xmm0, DWORD PTR _alt$[ebp]
	mulss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR __real@40490fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+332], eax

; 338  : 
; 339  : 	if(ISunPitch < 256 || ISunPitch > (8192-256)) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 256		; 00000100H
	jl	SHORT $LN2@UpdateSkyP
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 7936		; 00001f00H
	jle	$LN3@UpdateSkyP
$LN2@UpdateSkyP:

; 340  : 	// Adjust the light level for the moon
; 341  : 	// (original levels are assumed to have been for a full moon)
; 342  : 	// At new moon and/or moon rise/set, we darken by at most 1/2
; 343  : 	// (at little more, actually, since the SIN can become negative just as the moon sets/rises)
; 344  : 		float t1 = (float) abs(NEW_MOON_PHASE - CalculateMoonPercent());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMoonPercent@CTimeOfDay@@QAEHXZ ; CTimeOfDay::CalculateMoonPercent
	mov	edx, 64					; 00000040H
	sub	edx, eax
	push	edx
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _t1$1[ebp], xmm0

; 345  : 		t1 = (t1 / NEW_MOON_PHASE) * (float)sin(alt);//angletorad(IMoonPitch));

	movss	xmm0, DWORD PTR _t1$1[ebp]
	divss	xmm0, DWORD PTR __real@42800000
	push	ecx
	movss	xmm1, DWORD PTR _alt$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv1123[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv1074[ebp]
	movss	xmm0, DWORD PTR tv1123[ebp]
	mulss	xmm0, DWORD PTR tv1074[ebp]
	movss	DWORD PTR _t1$1[ebp], xmm0

; 346  : 		t1 = (1.0f + t1)/2.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _t1$1[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _t1$1[ebp], xmm0

; 347  : 		if (t1 < 0.45f) t1 = 0.45f;		// limit the darkness level

	movss	xmm0, DWORD PTR __real@3ee66666
	comiss	xmm0, DWORD PTR _t1$1[ebp]
	jbe	SHORT $LN1@UpdateSkyP
	movss	xmm0, DWORD PTR __real@3ee66666
	movss	DWORD PTR _t1$1[ebp], xmm0
$LN1@UpdateSkyP:

; 348  : 
; 349  : 		m_HazeGroundColor.r		*= t1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+80], xmm0

; 350  : 		m_HazeGroundColor.g		*= t1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+84]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+84], xmm0

; 351  : 		m_HazeGroundColor.b		*= t1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+88]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+88], xmm0

; 352  : 		m_TextureLighting.r		*= t1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+92]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+92], xmm0

; 353  : 		m_TextureLighting.g		*= t1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+96]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+96], xmm0

; 354  : 		m_TextureLighting.b		*= t1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+100], xmm0

; 355  : 
; 356  : 		m_BadWeatherLighting.r	*= t1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 357  : 		m_BadWeatherLighting.g	*= t1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+108], xmm0

; 358  : 		m_BadWeatherLighting.b	*= t1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+112]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+112], xmm0

; 359  : 
; 360  : 		m_Ambient				*= t1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+116]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+116], xmm0

; 361  : 		m_Diffuse				*= t1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+120]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 362  : 		m_Specular				*= t1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	mulss	xmm0, DWORD PTR _t1$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+124], xmm0
$LN3@UpdateSkyP:

; 363  : 	}
; 364  : 
; 365  : 	// Update the positions and effects of the celstial objects
; 366  : 	m_StarIntensity += t * (ntod -> StarIntensity - m_StarIntensity);

	mov	eax, DWORD PTR _ntod$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	subss	xmm0, DWORD PTR [ecx+144]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+144]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+144], xmm0

; 367  : 	TheStar.UpdateStar();

	call	?UpdateStar@CStar@@SAXXZ		; CStar::UpdateStar
$LN19@UpdateSkyP:

; 368  : /*
; 369  : 	if(realWeather->weatherCondition > FAIR)
; 370  : 	{
; 371  : 		if(realWeather->weatherCondition == INCLEMENT)
; 372  : 		{
; 373  : 			BadWeatherLighting.r = max(BadWeatherLighting.r/1.5f,0.01f);
; 374  : 			BadWeatherLighting.g = max(BadWeatherLighting.g/1.5f,0.01f);
; 375  : 			BadWeatherLighting.b = max(BadWeatherLighting.b/1.5f,0.01f);
; 376  : 		}
; 377  : 
; 378  : 		if(realWeather->InsideOvercast() || realWeather->UnderOvercast())
; 379  : 		{
; 380  : 			if(realWeather->weatherCondition > POOR)
; 381  : 			 Specular = 0.f;
; 382  : 			else
; 383  : 			 Specular *= 0.2f;
; 384  : 
; 385  : 			SkyColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);
; 386  : 			SkyColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);
; 387  : 			SkyColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);
; 388  : 
; 389  : 			HazeSkyColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);
; 390  : 			HazeSkyColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);
; 391  : 			HazeSkyColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);
; 392  : 
; 393  : 			HazeGroundColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);
; 394  : 			HazeGroundColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);
; 395  : 			HazeGroundColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);
; 396  : 
; 397  : 			GroundColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);
; 398  : 			GroundColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);
; 399  : 			GroundColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);
; 400  : 
; 401  : 			TextureLighting.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);
; 402  : 			TextureLighting.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);
; 403  : 			TextureLighting.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);
; 404  : 		}
; 405  : 		else
; 406  : 		{
; 407  : 			SkyColor.r = (SkyColor.r*(1.f - scaleFactor))+(BadWeatherLighting.r*scaleFactor);
; 408  : 			SkyColor.g = (SkyColor.g*(1.f - scaleFactor))+(BadWeatherLighting.g*scaleFactor);
; 409  : 			SkyColor.b = (SkyColor.b*(1.f - scaleFactor))+(BadWeatherLighting.b*scaleFactor);
; 410  : 
; 411  : 			HazeSkyColor.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);
; 412  : 			HazeSkyColor.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);
; 413  : 			HazeSkyColor.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);
; 414  : 
; 415  : 			HazeGroundColor.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);
; 416  : 			HazeGroundColor.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);
; 417  : 			HazeGroundColor.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);
; 418  : 
; 419  : 			GroundColor.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);
; 420  : 			GroundColor.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);
; 421  : 			GroundColor.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);
; 422  : 
; 423  : 			TextureLighting.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);
; 424  : 			TextureLighting.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);
; 425  : 			TextureLighting.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);
; 426  : 		}
; 427  : 
; 428  : 		Diffuse /= max((2.f*scaleFactor),1.f);
; 429  : 	}*/
; 430  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateSkyProperties@CTimeOfDay@@IAEXXZ ENDP		; CTimeOfDay::UpdateSkyProperties
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_k$ = -20						; size = 4
_mask$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_c$1 = -2						; size = 1
_c1$2 = -1						; size = 1
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?CreateMoonPhase@CTimeOfDay@@QAEXPAE0@Z PROC		; CTimeOfDay::CreateMoonPhase
; _this$ = ecx

; 960  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 961  : 	int	i, j, k;
; 962  : 	unsigned char *mask = CurrentMoonPhaseMask;

	mov	DWORD PTR _mask$[ebp], OFFSET ?CurrentMoonPhaseMask@CTimeOfDay@@1PAEA ; CTimeOfDay::CurrentMoonPhaseMask

; 963  : 	for (i=0; i < 64; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@CreateMoon
$LN9@CreateMoon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@CreateMoon:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN11@CreateMoon

; 964  : 		for (j=0; j < 8; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@CreateMoon
$LN6@CreateMoon:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@CreateMoon:
	cmp	DWORD PTR _j$[ebp], 8
	jge	SHORT $LN5@CreateMoon

; 965  : 			unsigned char c = *mask++;

	mov	edx, DWORD PTR _mask$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _c$1[ebp], al
	mov	ecx, DWORD PTR _mask$[ebp]
	add	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx

; 966  : 			for (k=0; k < 8; k++) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@CreateMoon
$LN3@CreateMoon:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN4@CreateMoon:
	cmp	DWORD PTR _k$[ebp], 8
	jge	SHORT $LN2@CreateMoon

; 967  : 				unsigned char c1 = *src++;

	mov	eax, DWORD PTR _src$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c1$2[ebp], cl
	mov	edx, DWORD PTR _src$[ebp]
	add	edx, 1
	mov	DWORD PTR _src$[ebp], edx

; 968  : #ifdef USE_TRANSPARENT_MOON
; 969  : 				if (c1 && !(c & 0x80)) c1 = 0;
; 970  : #else
; 971  : 				if (c1 && !(c & 0x80)) c1 += 48;

	movzx	eax, BYTE PTR _c1$2[ebp]
	test	eax, eax
	je	SHORT $LN1@CreateMoon
	movzx	ecx, BYTE PTR _c$1[ebp]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN1@CreateMoon
	movzx	edx, BYTE PTR _c1$2[ebp]
	add	edx, 48					; 00000030H
	mov	BYTE PTR _c1$2[ebp], dl
$LN1@CreateMoon:

; 972  : #endif
; 973  : 				c <<= 1;

	mov	al, BYTE PTR _c$1[ebp]
	shl	al, 1
	mov	BYTE PTR _c$1[ebp], al

; 974  : 				*dest++ = c1;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	dl, BYTE PTR _c1$2[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _dest$[ebp], eax

; 975  : 			}

	jmp	SHORT $LN3@CreateMoon
$LN2@CreateMoon:

; 976  : 		}

	jmp	$LN6@CreateMoon
$LN5@CreateMoon:

; 977  : 	}

	jmp	$LN9@CreateMoon
$LN11@CreateMoon:

; 978  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateMoonPhase@CTimeOfDay@@QAEXPAE0@Z ENDP		; CTimeOfDay::CreateMoonPhase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_cos3$1 = -44						; size = 4
_cos2$2 = -40						; size = 4
_cos1$3 = -36						; size = 4
_sin1$4 = -32						; size = 4
_yaw1$5 = -28						; size = 4
_yaw$6 = -24						; size = 4
_pitch1$7 = -20						; size = 4
_pitch$8 = -16						; size = 4
_sin2$9 = -12						; size = 4
_this$ = -8						; size = 4
_alpha$ = -4						; size = 4
_glare$ = 8						; size = 4
?CalculateMoonBlend@CTimeOfDay@@QAEMM@Z PROC		; CTimeOfDay::CalculateMoonBlend
; _this$ = ecx

; 750  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 751  : 	if (IMoonPitch < 0) return 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+332], 0
	jge	SHORT $LN12@CalculateM
	fld1
	jmp	$LN13@CalculateM
$LN12@CalculateM:

; 752  : 	float alpha = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$[ebp], xmm0

; 753  : 	if (ISunPitch >= 0) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 0
	jl	$LN7@CalculateM

; 754  : 		int pitch = GetMoonPitch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoonPitch@CTimeOfDay@@QAEHXZ	; CTimeOfDay::GetMoonPitch
	mov	DWORD PTR _pitch$8[ebp], eax

; 755  : 		int yaw = GetMoonYaw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMoonYaw@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetMoonYaw
	mov	DWORD PTR _yaw$6[ebp], eax

; 756  : 		int pitch1 = GetSunPitch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSunPitch@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetSunPitch
	mov	DWORD PTR _pitch1$7[ebp], eax

; 757  : 		int yaw1 = GetSunYaw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSunYaw@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetSunYaw
	mov	DWORD PTR _yaw1$5[ebp], eax

; 758  : 		float sin1, sin2, cos1, cos2, cos3;
; 759  : 		glGetSinCos (&sin1, &cos1, pitch);

	mov	edx, DWORD PTR _pitch$8[ebp]
	push	edx
	lea	eax, DWORD PTR _cos1$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _sin1$4[ebp]
	push	ecx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 760  : 		glGetSinCos (&sin2, &cos2, pitch1);

	mov	edx, DWORD PTR _pitch1$7[ebp]
	push	edx
	lea	eax, DWORD PTR _cos2$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _sin2$9[ebp]
	push	ecx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 761  : 		cos3 = (float) glGetCosine (yaw - yaw1);

	mov	edx, DWORD PTR _yaw$6[ebp]
	sub	edx, DWORD PTR _yaw1$5[ebp]
	push	edx
	call	?glGetCosine@@YANH@Z			; glGetCosine
	add	esp, 4
	fstp	DWORD PTR _cos3$1[ebp]

; 762  : 		alpha = sin1 * sin2 + cos1 * cos2 * cos3;

	movss	xmm0, DWORD PTR _sin1$4[ebp]
	mulss	xmm0, DWORD PTR _sin2$9[ebp]
	movss	xmm1, DWORD PTR _cos1$3[ebp]
	mulss	xmm1, DWORD PTR _cos2$2[ebp]
	mulss	xmm1, DWORD PTR _cos3$1[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _alpha$[ebp], xmm0

; 763  : 		alpha -= SunGlareCosine;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _alpha$[ebp]
	subss	xmm0, DWORD PTR [eax+340]
	movss	DWORD PTR _alpha$[ebp], xmm0

; 764  : 		alpha *= SunGlareFactor;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _alpha$[ebp]
	mulss	xmm0, DWORD PTR [ecx+344]
	movss	DWORD PTR _alpha$[ebp], xmm0

; 765  : 		if (alpha > 1.0f) alpha = 1.0f;	

	movss	xmm0, DWORD PTR _alpha$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN10@CalculateM
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$[ebp], xmm0
	jmp	SHORT $LN8@CalculateM
$LN10@CalculateM:

; 766  : 		else if (alpha < 0.0f) alpha = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _alpha$[ebp]
	jbe	SHORT $LN8@CalculateM
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN8@CalculateM:

; 767  : 		if (sin2 > 0.0f) {

	movss	xmm0, DWORD PTR _sin2$9[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@CalculateM

; 768  : 			//sin2 *= 4.0f;
; 769  : 			alpha += sin2;

	movss	xmm0, DWORD PTR _alpha$[ebp]
	addss	xmm0, DWORD PTR _sin2$9[ebp]
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN7@CalculateM:

; 770  : 		}
; 771  : 	}
; 772  : 	if (glare < 0.0f) glare = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _glare$[ebp]
	jbe	SHORT $LN6@CalculateM
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _glare$[ebp], xmm0
	jmp	SHORT $LN4@CalculateM
$LN6@CalculateM:

; 773  : 	else if (glare > 1.0f) glare = 1.0f;

	movss	xmm0, DWORD PTR _glare$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN4@CalculateM
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _glare$[ebp], xmm0
$LN4@CalculateM:

; 774  : 	alpha = 1.0f - (alpha + glare);

	movss	xmm0, DWORD PTR _alpha$[ebp]
	addss	xmm0, DWORD PTR _glare$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _alpha$[ebp], xmm1

; 775  : 	if (alpha < 0.0f) alpha = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _alpha$[ebp]
	jbe	SHORT $LN3@CalculateM
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$[ebp], xmm0
	jmp	SHORT $LN1@CalculateM
$LN3@CalculateM:

; 776  : 	else if (alpha > 1.0f) alpha = 1.0f;

	movss	xmm0, DWORD PTR _alpha$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN1@CalculateM
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN1@CalculateM:

; 777  : 	return alpha;

	fld	DWORD PTR _alpha$[ebp]
$LN13@CalculateM:

; 778  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateMoonBlend@CTimeOfDay@@QAEMM@Z ENDP		; CTimeOfDay::CalculateMoonBlend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?CalculateMoonPercent@CTimeOfDay@@QAEHXZ PROC		; CTimeOfDay::CalculateMoonPercent
; _this$ = ecx

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 782  : 	if (MoonPhase == -1) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN1@CalculateM

; 783  : 		MoonPhase = FloatToInt32(TheStar.GetMoonPhase() * MOON_PHASE_SIZE);

	call	?GetMoonPhase@CStar@@SAMXZ		; CStar::GetMoonPhase
	fstp	DWORD PTR tv76[ebp]
	movss	xmm0, DWORD PTR tv76[ebp]
	mulss	xmm0, DWORD PTR __real@43000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN1@CalculateM:

; 784  : 	return MoonPhase;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]

; 785  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateMoonPercent@CTimeOfDay@@QAEHXZ ENDP		; CTimeOfDay::CalculateMoonPercent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetMoonYaw@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_yaw$ = -4						; size = 4
?GetMoonYaw@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::GetMoonYaw, COMDAT
; _this$ = ecx

; 137  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		int yaw = IMoonYaw;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	mov	DWORD PTR _yaw$[ebp], ecx

; 139  : 		if(IMoonPitch > 4096) yaw += 8192;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+332], 4096		; 00001000H
	jle	SHORT $LN1@GetMoonYaw
	mov	eax, DWORD PTR _yaw$[ebp]
	add	eax, 8192				; 00002000H
	mov	DWORD PTR _yaw$[ebp], eax
$LN1@GetMoonYaw:

; 140  : 		return yaw & 0x3fff;

	mov	eax, DWORD PTR _yaw$[ebp]
	and	eax, 16383				; 00003fffH

; 141  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoonYaw@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::GetMoonYaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetMoonPitch@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pitch$ = -4						; size = 4
?GetMoonPitch@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::GetMoonPitch, COMDAT
; _this$ = ecx

; 130  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		int pitch = IMoonPitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	mov	DWORD PTR _pitch$[ebp], ecx

; 132  : 		if(pitch > 4096) pitch = 8192 - pitch;

	cmp	DWORD PTR _pitch$[ebp], 4096		; 00001000H
	jle	SHORT $LN1@GetMoonPit
	mov	edx, 8192				; 00002000H
	sub	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR _pitch$[ebp], edx
$LN1@GetMoonPit:

; 133  : 		return pitch; 

	mov	eax, DWORD PTR _pitch$[ebp]

; 134  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoonPitch@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::GetMoonPitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetSunYaw@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_yaw$ = -4						; size = 4
?GetSunYaw@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::GetSunYaw, COMDAT
; _this$ = ecx

; 123  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		int yaw = ISunYaw;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	mov	DWORD PTR _yaw$[ebp], ecx

; 125  : 		if(ISunPitch > 4096) yaw += 8192;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 4096		; 00001000H
	jle	SHORT $LN1@GetSunYaw
	mov	eax, DWORD PTR _yaw$[ebp]
	add	eax, 8192				; 00002000H
	mov	DWORD PTR _yaw$[ebp], eax
$LN1@GetSunYaw:

; 126  : 		return yaw & 0x3fff;

	mov	eax, DWORD PTR _yaw$[ebp]
	and	eax, 16383				; 00003fffH

; 127  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSunYaw@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::GetSunYaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetSunPitch@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pitch$ = -4						; size = 4
?GetSunPitch@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::GetSunPitch, COMDAT
; _this$ = ecx

; 116  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		int pitch = ISunPitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR _pitch$[ebp], ecx

; 118  : 		if(pitch > 4096) pitch = 8192 - pitch;

	cmp	DWORD PTR _pitch$[ebp], 4096		; 00001000H
	jle	SHORT $LN1@GetSunPitc
	mov	edx, 8192				; 00002000H
	sub	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR _pitch$[ebp], edx
$LN1@GetSunPitc:

; 119  : 		return pitch; 

	mov	eax, DWORD PTR _pitch$[ebp]

; 120  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSunPitch@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::GetSunPitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?ThereIsAMoon@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?ThereIsAMoon@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::ThereIsAMoon, COMDAT
; _this$ = ecx

; 112  : 	int ThereIsAMoon()							{ return (IMoonPitch > 0); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+332], 0
	jle	SHORT $LN3@ThereIsAMo
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@ThereIsAMo
$LN3@ThereIsAMo:
	mov	DWORD PTR tv66[ebp], 0
$LN4@ThereIsAMo:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ThereIsAMoon@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::ThereIsAMoon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?ThereIsASun@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?ThereIsASun@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::ThereIsASun, COMDAT
; _this$ = ecx

; 111  : 	int ThereIsASun()							{ return (ISunPitch > 0); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 0
	jle	SHORT $LN3@ThereIsASu
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@ThereIsASu
$LN3@ThereIsASu:
	mov	DWORD PTR tv66[ebp], 0
$LN4@ThereIsASu:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ThereIsASun@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::ThereIsASun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -112						; size = 4
_cosine$ = -108						; size = 4
_duu$ = -104						; size = 4
_dvu$ = -100						; size = 4
_l$1 = -96						; size = 4
_duv$ = -92						; size = 4
_dvv$ = -88						; size = 4
_sine$ = -84						; size = 4
_j$ = -80						; size = 4
_tv$2 = -76						; size = 4
_uuu$3 = -72						; size = 4
_k$ = -68						; size = 4
_vv$ = -64						; size = 4
_vvv$4 = -60						; size = 4
_uu$ = -56						; size = 4
_i$ = -52						; size = 4
_dest$ = -48						; size = 4
_tu$5 = -44						; size = 4
_s32$ = -40						; size = 4
_c32$ = -36						; size = 4
_c$6 = -30						; size = 1
_c1$7 = -29						; size = 1
_v1$ = -28						; size = 12
_u1$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_angle$ = 8						; size = 4
?RotateMoonMask@CTimeOfDay@@QAEXH@Z PROC		; CTimeOfDay::RotateMoonMask
; _this$ = ecx

; 880  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 881  : 	float sine, cosine;
; 882  : 	glGetSinCos (&sine, &cosine, -angle);

	mov	eax, DWORD PTR _angle$[ebp]
	neg	eax
	push	eax
	lea	ecx, DWORD PTR _cosine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sine$[ebp]
	push	edx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 883  : 
; 884  : 	int u1[3], v1[3];
; 885  : 
; 886  : 	float c32, s32;
; 887  : 	c32 = 65536.0f*32.0f * cosine;

	movss	xmm0, DWORD PTR __real@4a000000
	mulss	xmm0, DWORD PTR _cosine$[ebp]
	movss	DWORD PTR _c32$[ebp], xmm0

; 888  : 	s32 = 65536.0f*32.0f * sine;

	movss	xmm0, DWORD PTR __real@4a000000
	mulss	xmm0, DWORD PTR _sine$[ebp]
	movss	DWORD PTR _s32$[ebp], xmm0

; 889  : 	u1[0] = (int) (-c32 + s32 + 65536.0f*32.0f);

	movss	xmm0, DWORD PTR _c32$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _s32$[ebp]
	addss	xmm0, DWORD PTR __real@4a000000
	cvttss2si eax, xmm0
	mov	ecx, 4
	imul	ecx, 0
	mov	DWORD PTR _u1$[ebp+ecx], eax

; 890  : 	v1[0] = (int) (-s32 - c32 + 65536.0f*32.0f);

	movss	xmm0, DWORD PTR _s32$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _c32$[ebp]
	addss	xmm0, DWORD PTR __real@4a000000
	cvttss2si edx, xmm0
	mov	eax, 4
	imul	eax, 0
	mov	DWORD PTR _v1$[ebp+eax], edx

; 891  : 	u1[1] = (int) ( c32 + s32 + 65536.0f*32.0f);

	movss	xmm0, DWORD PTR _c32$[ebp]
	addss	xmm0, DWORD PTR _s32$[ebp]
	addss	xmm0, DWORD PTR __real@4a000000
	cvttss2si ecx, xmm0
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _u1$[ebp+edx], ecx

; 892  : 	v1[1] = (int) ( s32 - c32 + 65536.0f*32.0f);

	movss	xmm0, DWORD PTR _s32$[ebp]
	subss	xmm0, DWORD PTR _c32$[ebp]
	addss	xmm0, DWORD PTR __real@4a000000
	cvttss2si eax, xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR _v1$[ebp+ecx], eax

; 893  : 	u1[2] = (int) (-c32 - s32 + 65536.0f*32.0f);

	movss	xmm0, DWORD PTR _c32$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _s32$[ebp]
	addss	xmm0, DWORD PTR __real@4a000000
	cvttss2si edx, xmm0
	mov	eax, 4
	shl	eax, 1
	mov	DWORD PTR _u1$[ebp+eax], edx

; 894  : 	v1[2] = (int) (-s32 + c32 + 65536.0f*32.0f);

	movss	xmm0, DWORD PTR _s32$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _c32$[ebp]
	addss	xmm0, DWORD PTR __real@4a000000
	cvttss2si ecx, xmm0
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _v1$[ebp+edx], ecx

; 895  : 
; 896  : 	int i, j, k;
; 897  : 	unsigned char *dest = CurrentMoonPhaseMask;

	mov	DWORD PTR _dest$[ebp], OFFSET ?CurrentMoonPhaseMask@CTimeOfDay@@1PAEA ; CTimeOfDay::CurrentMoonPhaseMask

; 898  : 	int uu = u1[0];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _u1$[ebp+eax]
	mov	DWORD PTR _uu$[ebp], ecx

; 899  : 	int vv = v1[0];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _v1$[ebp+edx]
	mov	DWORD PTR _vv$[ebp], eax

; 900  : 	int duu = (u1[1] - u1[0]) >> 6;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _u1$[ebp+ecx]
	sub	eax, DWORD PTR _u1$[ebp+edx]
	sar	eax, 6
	mov	DWORD PTR _duu$[ebp], eax

; 901  : 	int duv = (v1[1] - v1[0]) >> 6;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _v1$[ebp+ecx]
	sub	eax, DWORD PTR _v1$[ebp+edx]
	sar	eax, 6
	mov	DWORD PTR _duv$[ebp], eax

; 902  : 	int dvu = (u1[2] - u1[0]) >> 6;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _u1$[ebp+ecx]
	sub	eax, DWORD PTR _u1$[ebp+edx]
	sar	eax, 6
	mov	DWORD PTR _dvu$[ebp], eax

; 903  : 	int dvv = (v1[2] - v1[0]) >> 6;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _v1$[ebp+ecx]
	sub	eax, DWORD PTR _v1$[ebp+edx]
	sar	eax, 6
	mov	DWORD PTR _dvv$[ebp], eax

; 904  : 	for (i=0; i < 64; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@RotateMoon
$LN10@RotateMoon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN11@RotateMoon:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN9@RotateMoon

; 905  : 		int uuu = uu;

	mov	edx, DWORD PTR _uu$[ebp]
	mov	DWORD PTR _uuu$3[ebp], edx

; 906  : 		int vvv = vv;

	mov	eax, DWORD PTR _vv$[ebp]
	mov	DWORD PTR _vvv$4[ebp], eax

; 907  : 		for (j=0; j < 8; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN8@RotateMoon
$LN7@RotateMoon:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN8@RotateMoon:
	cmp	DWORD PTR _j$[ebp], 8
	jge	$LN6@RotateMoon

; 908  : 			unsigned char c1 = 0;

	mov	BYTE PTR _c1$7[ebp], 0

; 909  : 			for (k=0; k < 8; k++) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN5@RotateMoon
$LN4@RotateMoon:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN5@RotateMoon:
	cmp	DWORD PTR _k$[ebp], 8
	jge	$LN3@RotateMoon

; 910  : 				int tu = uuu >> 16;

	mov	eax, DWORD PTR _uuu$3[ebp]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _tu$5[ebp], eax

; 911  : 				int tv = vvv >> 16;

	mov	ecx, DWORD PTR _vvv$4[ebp]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _tv$2[ebp], ecx

; 912  : 				c1 <<= 1;

	mov	dl, BYTE PTR _c1$7[ebp]
	shl	dl, 1
	mov	BYTE PTR _c1$7[ebp], dl

; 913  : 				uuu += duu;

	mov	eax, DWORD PTR _uuu$3[ebp]
	add	eax, DWORD PTR _duu$[ebp]
	mov	DWORD PTR _uuu$3[ebp], eax

; 914  : 				vvv += duv;

	mov	ecx, DWORD PTR _vvv$4[ebp]
	add	ecx, DWORD PTR _duv$[ebp]
	mov	DWORD PTR _vvv$4[ebp], ecx

; 915  : 				if (tu >= 0 && tu < 64 && tv >= 0 && tv < 64) {

	cmp	DWORD PTR _tu$5[ebp], 0
	jl	SHORT $LN1@RotateMoon
	cmp	DWORD PTR _tu$5[ebp], 64		; 00000040H
	jge	SHORT $LN1@RotateMoon
	cmp	DWORD PTR _tv$2[ebp], 0
	jl	SHORT $LN1@RotateMoon
	cmp	DWORD PTR _tv$2[ebp], 64		; 00000040H
	jge	SHORT $LN1@RotateMoon

; 916  : 					int l = (tv << 3) + (tu >> 3);

	mov	edx, DWORD PTR _tu$5[ebp]
	sar	edx, 3
	mov	eax, DWORD PTR _tv$2[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _l$1[ebp], ecx

; 917  : 					unsigned char c = (unsigned char)(1 << (7 - (tu & 7)));

	mov	edx, DWORD PTR _tu$5[ebp]
	and	edx, 7
	mov	ecx, 7
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	BYTE PTR _c$6[ebp], al

; 918  : 					if (MoonPhaseMask[l] & c) c1 |= 1;

	mov	ecx, DWORD PTR _l$1[ebp]
	movzx	edx, BYTE PTR ?MoonPhaseMask@CTimeOfDay@@1PAEA[ecx]
	movzx	eax, BYTE PTR _c$6[ebp]
	and	edx, eax
	je	SHORT $LN1@RotateMoon
	movzx	ecx, BYTE PTR _c1$7[ebp]
	or	ecx, 1
	mov	BYTE PTR _c1$7[ebp], cl
$LN1@RotateMoon:

; 919  : 				}
; 920  : 			}

	jmp	$LN4@RotateMoon
$LN3@RotateMoon:

; 921  : 			*dest++ = c1;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	al, BYTE PTR _c1$7[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _dest$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dest$[ebp], ecx

; 922  : 		}

	jmp	$LN7@RotateMoon
$LN6@RotateMoon:

; 923  : 		uu += dvu;

	mov	edx, DWORD PTR _uu$[ebp]
	add	edx, DWORD PTR _dvu$[ebp]
	mov	DWORD PTR _uu$[ebp], edx

; 924  : 		vv += dvv;

	mov	eax, DWORD PTR _vv$[ebp]
	add	eax, DWORD PTR _dvv$[ebp]
	mov	DWORD PTR _vv$[ebp], eax

; 925  : 	}

	jmp	$LN10@RotateMoon
$LN9@RotateMoon:

; 926  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?RotateMoonMask@CTimeOfDay@@QAEXH@Z ENDP		; CTimeOfDay::RotateMoonMask
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
tv178 = -36						; size = 8
tv166 = -28						; size = 8
_angle1$ = -20						; size = 4
_dz$ = -16						; size = 4
_this$ = -12						; size = 4
_dy$ = -8						; size = 4
_angle$ = -4						; size = 4
?CalculateMoonPhase@CTimeOfDay@@QAEXXZ PROC		; CTimeOfDay::CalculateMoonPhase
; _this$ = ecx

; 929  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 	int	angle = 0;

	mov	DWORD PTR _angle$[ebp], 0

; 931  : 	float dy = SunCoord.y - MoonCoord.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR _dy$[ebp], xmm0

; 932  : 	if (dy > 1.0f) {

	movss	xmm0, DWORD PTR _dy$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN5@CalculateM

; 933  : 		dy -= 2.0f;

	movss	xmm0, DWORD PTR _dy$[ebp]
	subss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 934  : 		angle = -4096;

	mov	DWORD PTR _angle$[ebp], -4096		; fffff000H
	jmp	SHORT $LN3@CalculateM
$LN5@CalculateM:

; 935  : 	}
; 936  : 	else if (dy < -1.0f) {

	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN3@CalculateM

; 937  : 		dy += 2.0f;

	movss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 938  : 		angle = 4096;

	mov	DWORD PTR _angle$[ebp], 4096		; 00001000H
$LN3@CalculateM:

; 939  : 	}
; 940  : 	if (dy < 0) angle -= 4096;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN2@CalculateM
	mov	edx, DWORD PTR _angle$[ebp]
	sub	edx, 4096				; 00001000H
	mov	DWORD PTR _angle$[ebp], edx
	jmp	SHORT $LN1@CalculateM
$LN2@CalculateM:

; 941  : 	else angle += 4096;

	mov	eax, DWORD PTR _angle$[ebp]
	add	eax, 4096				; 00001000H
	mov	DWORD PTR _angle$[ebp], eax
$LN1@CalculateM:

; 942  : 
; 943  : 	float dz = SunCoord.z - MoonCoord.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR _dz$[ebp], xmm0

; 944  : 	angle += FloatToInt32(radtoangle((float)atan2(dz, dy)));

	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dz$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv166[ebp]
	movsd	xmm0, QWORD PTR tv166[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR __real@40490fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _angle$[ebp]
	mov	DWORD PTR _angle$[ebp], eax

; 945  : 	//MI moon phase fix
; 946  : #if 0
; 947  : 	dy = MoonCoord.z;
; 948  : 	dz = MoonCoord.y;
; 949  : #else
; 950  : 	dy = -MoonCoord.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 951  : 	dz = -MoonCoord.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dz$[ebp], xmm0

; 952  : #endif
; 953  : 	int angle1 = FloatToInt32(radtoangle((float)atan2(dz, dy)));

	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dz$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv178[ebp]
	movsd	xmm0, QWORD PTR tv178[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR __real@40490fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _angle1$[ebp], eax

; 954  : 	angle -= angle1;

	mov	edx, DWORD PTR _angle$[ebp]
	sub	edx, DWORD PTR _angle1$[ebp]
	mov	DWORD PTR _angle$[ebp], edx

; 955  : 
; 956  : 	RotateMoonMask(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateMoonMask@CTimeOfDay@@QAEXH@Z	; CTimeOfDay::RotateMoonMask

; 957  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateMoonPhase@CTimeOfDay@@QAEXXZ ENDP		; CTimeOfDay::CalculateMoonPhase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
tv857 = -224						; size = 4
tv505 = -220						; size = 4
tv854 = -216						; size = 4
tv232 = -212						; size = 4
tv839 = -208						; size = 4
tv352 = -204						; size = 4
tv825 = -200						; size = 4
tv551 = -196						; size = 4
tv822 = -192						; size = 4
tv412 = -188						; size = 4
tv807 = -184						; size = 4
tv292 = -180						; size = 4
tv793 = -176						; size = 4
tv153 = -172						; size = 4
tv790 = -168						; size = 4
tv534 = -164						; size = 4
tv775 = -160						; size = 4
tv487 = -156						; size = 4
tv761 = -152						; size = 4
tv382 = -148						; size = 4
tv758 = -144						; size = 4
tv322 = -140						; size = 4
tv743 = -136						; size = 4
tv262 = -132						; size = 4
tv729 = -128						; size = 4
tv177 = -124						; size = 4
tv726 = -120						; size = 4
tv139 = -116						; size = 4
tv711 = -112						; size = 4
tv537 = -108						; size = 4
tv697 = -104						; size = 4
tv519 = -100						; size = 4
tv694 = -96						; size = 4
tv502 = -92						; size = 4
tv679 = -88						; size = 4
tv427 = -84						; size = 4
tv665 = -80						; size = 4
tv397 = -76						; size = 4
tv662 = -72						; size = 4
tv367 = -68						; size = 4
tv647 = -64						; size = 4
tv337 = -60						; size = 4
tv633 = -56						; size = 4
tv307 = -52						; size = 4
tv630 = -48						; size = 4
tv277 = -44						; size = 4
tv615 = -40						; size = 4
tv247 = -36						; size = 4
tv601 = -32						; size = 4
tv217 = -28						; size = 4
tv598 = -24						; size = 4
tv165 = -20						; size = 4
tv583 = -16						; size = 4
tv569 = -12						; size = 4
tv566 = -8						; size = 4
_this$ = -4						; size = 4
_weatherCondition$ = 8					; size = 4
?UpdateWeatherColors@CTimeOfDay@@QAEXK@Z PROC		; CTimeOfDay::UpdateWeatherColors
; _this$ = ecx

; 435  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	DWORD PTR _this$[ebp], ecx

; 436  : 	// default values
; 437  : 	StarIntensity		= m_StarIntensity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+248], edx

; 438  : 	MinVis				= m_MinVis;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax+244], edx

; 439  : 	VisColor			= m_VisColor;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 440  : 	Ambient				= m_Ambient;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR [ecx+220], eax

; 441  : 	Specular			= m_Specular;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR [ecx+228], eax

; 442  : 
; 443  : 	// Deafule values if nont under/inside an overcast layer
; 444  : 	if(weatherCondition <= FAIR){

	cmp	DWORD PTR _weatherCondition$[ebp], 2
	ja	$LN9@UpdateWeat

; 445  : 		SkyColor			= m_SkyColor;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 446  : 		HazeSkyColor		= m_HazeSkyColor;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 447  : 		GroundColor			= m_GroundColor;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 448  : 		HazeGroundColor		= m_HazeGroundColor;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 184				; 000000b8H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 449  : 		TextureLighting		= m_TextureLighting;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 196				; 000000c4H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 450  : 		BadWeatherLighting	= m_BadWeatherLighting;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 208				; 000000d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 451  : 		Diffuse				= m_Diffuse;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR [ecx+224], eax

; 452  : 	} else {

	jmp	$LN1@UpdateWeat
$LN9@UpdateWeat:

; 453  : 
; 454  : 		Diffuse				= m_Diffuse / max((2.f*scaleFactor),1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN12@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN13@UpdateWeat
$LN12@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv139[ebp], xmm0
$LN13@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+120]
	divss	xmm0, DWORD PTR tv139[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+224], xmm0

; 455  : 
; 456  : 		// Bad weather stuff
; 457  : 		if(weatherCondition == INCLEMENT){

	cmp	DWORD PTR _weatherCondition$[ebp], 4
	jne	$LN7@UpdateWeat

; 458  : 			BadWeatherLighting.r = max(m_BadWeatherLighting.r/1.5f,0.01f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	divss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN14@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	divss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv153[ebp], xmm0
	jmp	SHORT $LN15@UpdateWeat
$LN14@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv153[ebp], xmm0
$LN15@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv153[ebp]
	movss	DWORD PTR [ecx+208], xmm0

; 459  : 			BadWeatherLighting.g = max(m_BadWeatherLighting.g/1.5f,0.01f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+108]
	divss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN16@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	divss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN17@UpdateWeat
$LN16@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv165[ebp], xmm0
$LN17@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR [ecx+212], xmm0

; 460  : 			BadWeatherLighting.b = max(m_BadWeatherLighting.b/1.5f,0.01f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+112]
	divss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN18@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+112]
	divss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv177[ebp], xmm0
	jmp	SHORT $LN19@UpdateWeat
$LN18@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv177[ebp], xmm0
$LN19@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv177[ebp]
	movss	DWORD PTR [ecx+216], xmm0

; 461  : 		} else {

	jmp	SHORT $LN6@UpdateWeat
$LN7@UpdateWeat:

; 462  : 			BadWeatherLighting.r = m_BadWeatherLighting.r;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR [edx+208], ecx

; 463  : 			BadWeatherLighting.g = m_BadWeatherLighting.g;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR [edx+212], ecx

; 464  : 			BadWeatherLighting.b = m_BadWeatherLighting.b;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [edx+216], ecx
$LN6@UpdateWeat:

; 465  : 		}
; 466  : 
; 467  : 		if(realWeather->InsideOvercast() || realWeather->UnderOvercast()){

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?InsideOvercast@RealWeather@@QAE_NXZ	; RealWeather::InsideOvercast
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@UpdateWeat
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?UnderOvercast@RealWeather@@QAE_NXZ	; RealWeather::UnderOvercast
	movzx	eax, al
	test	eax, eax
	je	$LN5@UpdateWeat
$LN4@UpdateWeat:

; 468  : 			
; 469  : 			if(realWeather->weatherCondition > POOR) Specular = 0.f;

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	cmp	DWORD PTR [ecx+15688], 3
	jle	SHORT $LN3@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+228], xmm0
	jmp	SHORT $LN2@UpdateWeat
$LN3@UpdateWeat:

; 470  : 			else Specular *= 0.2f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+228]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+228], xmm0
$LN2@UpdateWeat:

; 471  : 
; 472  : 			SkyColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN20@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv217[ebp], xmm0
	jmp	SHORT $LN21@UpdateWeat
$LN20@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv217[ebp], xmm0
$LN21@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv217[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+148], xmm0

; 473  : 			SkyColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN22@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv232[ebp], xmm0
	jmp	SHORT $LN23@UpdateWeat
$LN22@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv232[ebp], xmm0
$LN23@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv232[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+152], xmm0

; 474  : 			SkyColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN24@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv247[ebp], xmm0
	jmp	SHORT $LN25@UpdateWeat
$LN24@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv247[ebp], xmm0
$LN25@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv247[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+156], xmm0

; 475  : 
; 476  : 			HazeSkyColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN26@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv262[ebp], xmm0
	jmp	SHORT $LN27@UpdateWeat
$LN26@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv262[ebp], xmm0
$LN27@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv262[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+160], xmm0

; 477  : 			HazeSkyColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN28@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv277[ebp], xmm0
	jmp	SHORT $LN29@UpdateWeat
$LN28@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv277[ebp], xmm0
$LN29@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv277[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+164], xmm0

; 478  : 			HazeSkyColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN30@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv292[ebp], xmm0
	jmp	SHORT $LN31@UpdateWeat
$LN30@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv292[ebp], xmm0
$LN31@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv292[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+168], xmm0

; 479  : 
; 480  : 			HazeGroundColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN32@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv307[ebp], xmm0
	jmp	SHORT $LN33@UpdateWeat
$LN32@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv307[ebp], xmm0
$LN33@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv307[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+184], xmm0

; 481  : 			HazeGroundColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN34@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv322[ebp], xmm0
	jmp	SHORT $LN35@UpdateWeat
$LN34@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv322[ebp], xmm0
$LN35@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv322[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+188], xmm0

; 482  : 			HazeGroundColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN36@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv337[ebp], xmm0
	jmp	SHORT $LN37@UpdateWeat
$LN36@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv337[ebp], xmm0
$LN37@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv337[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+192], xmm0

; 483  : 
; 484  : 			GroundColor.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN38@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv352[ebp], xmm0
	jmp	SHORT $LN39@UpdateWeat
$LN38@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv352[ebp], xmm0
$LN39@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv352[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+172], xmm0

; 485  : 			GroundColor.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN40@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv367[ebp], xmm0
	jmp	SHORT $LN41@UpdateWeat
$LN40@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv367[ebp], xmm0
$LN41@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv367[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+176], xmm0

; 486  : 			GroundColor.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN42@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv382[ebp], xmm0
	jmp	SHORT $LN43@UpdateWeat
$LN42@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv382[ebp], xmm0
$LN43@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv382[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+180], xmm0

; 487  : 
; 488  : 			TextureLighting.r = BadWeatherLighting.r/max((1.25f*scaleFactor),1.f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN44@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv397[ebp], xmm0
	jmp	SHORT $LN45@UpdateWeat
$LN44@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv397[ebp], xmm0
$LN45@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv397[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+196], xmm0

; 489  : 			TextureLighting.g = BadWeatherLighting.g/max((1.25f*scaleFactor),1.f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN46@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv412[ebp], xmm0
	jmp	SHORT $LN47@UpdateWeat
$LN46@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv412[ebp], xmm0
$LN47@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv412[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+200], xmm0

; 490  : 			TextureLighting.b = BadWeatherLighting.b/max((1.25f*scaleFactor),1.f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN48@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv427[ebp], xmm0
	jmp	SHORT $LN49@UpdateWeat
$LN48@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv427[ebp], xmm0
$LN49@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv427[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+204], xmm0

; 491  : 		}
; 492  : 		else

	jmp	$LN1@UpdateWeat
$LN5@UpdateWeat:

; 493  : 		{
; 494  : 			SkyColor.r = (m_SkyColor.r*(1.f - scaleFactor))+(BadWeatherLighting.r*scaleFactor);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+336]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+208]
	mulss	xmm1, DWORD PTR [edx+336]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+148], xmm0

; 495  : 			SkyColor.g = (m_SkyColor.g*(1.f - scaleFactor))+(BadWeatherLighting.g*scaleFactor);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [ecx+336]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+48]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+212]
	mulss	xmm1, DWORD PTR [ecx+336]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+152], xmm0

; 496  : 			SkyColor.b = (m_SkyColor.b*(1.f - scaleFactor))+(BadWeatherLighting.b*scaleFactor);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [eax+336]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+216]
	mulss	xmm1, DWORD PTR [eax+336]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+156], xmm0

; 497  : 
; 498  : 			HazeSkyColor.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN50@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv487[ebp], xmm0
	jmp	SHORT $LN51@UpdateWeat
$LN50@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv487[ebp], xmm0
$LN51@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv487[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN54@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN52@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv502[ebp], xmm0
	jmp	SHORT $LN53@UpdateWeat
$LN52@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv502[ebp], xmm0
$LN53@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv502[ebp]
	movss	DWORD PTR tv505[ebp], xmm0
	jmp	SHORT $LN55@UpdateWeat
$LN54@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv505[ebp], xmm0
$LN55@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv505[ebp]
	movss	DWORD PTR [edx+160], xmm0

; 499  : 			HazeSkyColor.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN56@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv519[ebp], xmm0
	jmp	SHORT $LN57@UpdateWeat
$LN56@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv519[ebp], xmm0
$LN57@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv519[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN60@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN58@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv534[ebp], xmm0
	jmp	SHORT $LN59@UpdateWeat
$LN58@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv534[ebp], xmm0
$LN59@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv534[ebp]
	movss	DWORD PTR tv537[ebp], xmm0
	jmp	SHORT $LN61@UpdateWeat
$LN60@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv537[ebp], xmm0
$LN61@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv537[ebp]
	movss	DWORD PTR [eax+164], xmm0

; 500  : 			HazeSkyColor.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN62@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv551[ebp], xmm0
	jmp	SHORT $LN63@UpdateWeat
$LN62@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv551[ebp], xmm0
$LN63@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv551[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN66@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN64@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv566[ebp], xmm0
	jmp	SHORT $LN65@UpdateWeat
$LN64@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv566[ebp], xmm0
$LN65@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv566[ebp]
	movss	DWORD PTR tv569[ebp], xmm0
	jmp	SHORT $LN67@UpdateWeat
$LN66@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv569[ebp], xmm0
$LN67@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv569[ebp]
	movss	DWORD PTR [ecx+168], xmm0

; 501  : 
; 502  : 			HazeGroundColor.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN68@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv583[ebp], xmm0
	jmp	SHORT $LN69@UpdateWeat
$LN68@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv583[ebp], xmm0
$LN69@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv583[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN72@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN70@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv598[ebp], xmm0
	jmp	SHORT $LN71@UpdateWeat
$LN70@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv598[ebp], xmm0
$LN71@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv598[ebp]
	movss	DWORD PTR tv601[ebp], xmm0
	jmp	SHORT $LN73@UpdateWeat
$LN72@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv601[ebp], xmm0
$LN73@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv601[ebp]
	movss	DWORD PTR [edx+184], xmm0

; 503  : 			HazeGroundColor.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN74@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv615[ebp], xmm0
	jmp	SHORT $LN75@UpdateWeat
$LN74@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv615[ebp], xmm0
$LN75@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv615[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN78@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN76@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv630[ebp], xmm0
	jmp	SHORT $LN77@UpdateWeat
$LN76@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv630[ebp], xmm0
$LN77@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv630[ebp]
	movss	DWORD PTR tv633[ebp], xmm0
	jmp	SHORT $LN79@UpdateWeat
$LN78@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv633[ebp], xmm0
$LN79@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv633[ebp]
	movss	DWORD PTR [eax+188], xmm0

; 504  : 			HazeGroundColor.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN80@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv647[ebp], xmm0
	jmp	SHORT $LN81@UpdateWeat
$LN80@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv647[ebp], xmm0
$LN81@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv647[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN84@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN82@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv662[ebp], xmm0
	jmp	SHORT $LN83@UpdateWeat
$LN82@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv662[ebp], xmm0
$LN83@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv662[ebp]
	movss	DWORD PTR tv665[ebp], xmm0
	jmp	SHORT $LN85@UpdateWeat
$LN84@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv665[ebp], xmm0
$LN85@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv665[ebp]
	movss	DWORD PTR [ecx+192], xmm0

; 505  : 
; 506  : 			GroundColor.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN86@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv679[ebp], xmm0
	jmp	SHORT $LN87@UpdateWeat
$LN86@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv679[ebp], xmm0
$LN87@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv679[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN90@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN88@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv694[ebp], xmm0
	jmp	SHORT $LN89@UpdateWeat
$LN88@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv694[ebp], xmm0
$LN89@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv694[ebp]
	movss	DWORD PTR tv697[ebp], xmm0
	jmp	SHORT $LN91@UpdateWeat
$LN90@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv697[ebp], xmm0
$LN91@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv697[ebp]
	movss	DWORD PTR [edx+172], xmm0

; 507  : 			GroundColor.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN92@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv711[ebp], xmm0
	jmp	SHORT $LN93@UpdateWeat
$LN92@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv711[ebp], xmm0
$LN93@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv711[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN96@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN94@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv726[ebp], xmm0
	jmp	SHORT $LN95@UpdateWeat
$LN94@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv726[ebp], xmm0
$LN95@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv726[ebp]
	movss	DWORD PTR tv729[ebp], xmm0
	jmp	SHORT $LN97@UpdateWeat
$LN96@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv729[ebp], xmm0
$LN97@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv729[ebp]
	movss	DWORD PTR [eax+176], xmm0

; 508  : 			GroundColor.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN98@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv743[ebp], xmm0
	jmp	SHORT $LN99@UpdateWeat
$LN98@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv743[ebp], xmm0
$LN99@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv743[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN102@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN100@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv758[ebp], xmm0
	jmp	SHORT $LN101@UpdateWeat
$LN100@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv758[ebp], xmm0
$LN101@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv758[ebp]
	movss	DWORD PTR tv761[ebp], xmm0
	jmp	SHORT $LN103@UpdateWeat
$LN102@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv761[ebp], xmm0
$LN103@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv761[ebp]
	movss	DWORD PTR [ecx+180], xmm0

; 509  : 
; 510  : 			TextureLighting.r = min(BadWeatherLighting.r/max((1.25f*scaleFactor),.67f),.9f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN104@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv775[ebp], xmm0
	jmp	SHORT $LN105@UpdateWeat
$LN104@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv775[ebp], xmm0
$LN105@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv775[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN108@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN106@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv790[ebp], xmm0
	jmp	SHORT $LN107@UpdateWeat
$LN106@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv790[ebp], xmm0
$LN107@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	divss	xmm0, DWORD PTR tv790[ebp]
	movss	DWORD PTR tv793[ebp], xmm0
	jmp	SHORT $LN109@UpdateWeat
$LN108@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv793[ebp], xmm0
$LN109@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv793[ebp]
	movss	DWORD PTR [edx+196], xmm0

; 511  : 			TextureLighting.g = min(BadWeatherLighting.g/max((1.25f*scaleFactor),.67f),.9f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN110@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv807[ebp], xmm0
	jmp	SHORT $LN111@UpdateWeat
$LN110@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv807[ebp], xmm0
$LN111@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv807[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN114@UpdateWeat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [eax+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN112@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv822[ebp], xmm0
	jmp	SHORT $LN113@UpdateWeat
$LN112@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv822[ebp], xmm0
$LN113@UpdateWeat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	divss	xmm0, DWORD PTR tv822[ebp]
	movss	DWORD PTR tv825[ebp], xmm0
	jmp	SHORT $LN115@UpdateWeat
$LN114@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv825[ebp], xmm0
$LN115@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv825[ebp]
	movss	DWORD PTR [eax+200], xmm0

; 512  : 			TextureLighting.b = min(BadWeatherLighting.b/max((1.25f*scaleFactor),.67f),.9f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN116@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv839[ebp], xmm0
	jmp	SHORT $LN117@UpdateWeat
$LN116@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv839[ebp], xmm0
$LN117@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv839[ebp]
	movss	xmm1, DWORD PTR __real@3f666666
	comiss	xmm1, xmm0
	jbe	SHORT $LN120@UpdateWeat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@3f2b851f
	jbe	SHORT $LN118@UpdateWeat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fa00000
	mulss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv854[ebp], xmm0
	jmp	SHORT $LN119@UpdateWeat
$LN118@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR tv854[ebp], xmm0
$LN119@UpdateWeat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+216]
	divss	xmm0, DWORD PTR tv854[ebp]
	movss	DWORD PTR tv857[ebp], xmm0
	jmp	SHORT $LN121@UpdateWeat
$LN120@UpdateWeat:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv857[ebp], xmm0
$LN121@UpdateWeat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv857[ebp]
	movss	DWORD PTR [ecx+204], xmm0
$LN1@UpdateWeat:

; 513  : 		}
; 514  : 
; 515  : 	}
; 516  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateWeatherColors@CTimeOfDay@@QAEXK@Z ENDP		; CTimeOfDay::UpdateWeatherColors
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -352						; size = 4
_start$1 = -348						; size = 4
_y1$2 = -344						; size = 4
_x1$3 = -340						; size = 4
_stop$4 = -336						; size = 4
_reverse$5 = -332					; size = 4
_col$6 = -328						; size = 4
_col1$7 = -324						; size = 4
_dest$8 = -320						; size = 4
_col2$9 = -316						; size = 4
_flag$10 = -312						; size = 4
_d2$11 = -308						; size = 4
_sizex$12 = -304					; size = 4
_d1$13 = -300						; size = 4
_row$14 = -296						; size = 4
_bb$15 = -292						; size = 4
_aa$16 = -288						; size = 4
_xpos$17 = -284						; size = 4
_x$18 = -280						; size = 4
_j$19 = -276						; size = 4
_counter$20 = -272					; size = 4
_y$21 = -268						; size = 4
_c$22 = -261						; size = 1
_array$23 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_image$ = 8						; size = 4
_phase$ = 12						; size = 4
?CreateMoonPhaseMask@CTimeOfDay@@QAEXPAEH@Z PROC	; CTimeOfDay::CreateMoonPhaseMask
; _this$ = ecx

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	if (phase == NEW_MOON_PHASE) 			// new moon --> all moon dark

	cmp	DWORD PTR _phase$[ebp], 64		; 00000040H
	jne	SHORT $LN33@CreateMoon

; 790  : 		memset ((void *) image, 0, 8*64);

	push	512					; 00000200H
	push	0
	mov	eax, DWORD PTR _image$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 791  : 	else {					// part of moon dark

	jmp	$LN11@CreateMoon
$LN33@CreateMoon:

; 792  : 		int	array[64];
; 793  : 
; 794  : 		int reverse = 0;

	mov	DWORD PTR _reverse$5[ebp], 0

; 795  : 		int sizex = NEW_MOON_PHASE/2 - phase;

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _phase$[ebp]
	mov	DWORD PTR _sizex$12[ebp], ecx

; 796  : 		if (phase > NEW_MOON_PHASE) {

	cmp	DWORD PTR _phase$[ebp], 64		; 00000040H
	jle	SHORT $LN31@CreateMoon

; 797  : 			sizex += NEW_MOON_PHASE;

	mov	edx, DWORD PTR _sizex$12[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR _sizex$12[ebp], edx

; 798  : 			reverse = 1;

	mov	DWORD PTR _reverse$5[ebp], 1
$LN31@CreateMoon:

; 799  : 		}
; 800  : 
; 801  : 		int counter = 0;

	mov	DWORD PTR _counter$20[ebp], 0

; 802  : 		int flag = 1;

	mov	DWORD PTR _flag$10[ebp], 1

; 803  : 		int x = 0; 

	mov	DWORD PTR _x$18[ebp], 0

; 804  : 		int y = 32;

	mov	DWORD PTR _y$21[ebp], 32		; 00000020H

; 805  : 		int xpos = 32;

	mov	DWORD PTR _xpos$17[ebp], 32		; 00000020H

; 806  : 		float aa = (float) sizex * sizex;

	cvtsi2ss xmm0, DWORD PTR _sizex$12[ebp]
	cvtsi2ss xmm1, DWORD PTR _sizex$12[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _aa$16[ebp], xmm0

; 807  : 		float bb = (float) 32 * 32;

	movss	xmm0, DWORD PTR __real@44800000
	movss	DWORD PTR _bb$15[ebp], xmm0

; 808  : 		float d1 = bb - aa*32 + aa / 4.0f;

	movss	xmm0, DWORD PTR _aa$16[ebp]
	mulss	xmm0, DWORD PTR __real@42000000
	movss	xmm1, DWORD PTR _bb$15[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _aa$16[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	addss	xmm1, xmm0
	movss	DWORD PTR _d1$13[ebp], xmm1
$LN30@CreateMoon:

; 809  : 		while (aa * ((float) y - 0.5f) > bb * ((float) x + 1.0f)) {

	cvtsi2ss xmm0, DWORD PTR _y$21[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR _aa$16[ebp]
	cvtsi2ss xmm1, DWORD PTR _x$18[ebp]
	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR _bb$15[ebp]
	comiss	xmm0, xmm1
	jbe	$LN29@CreateMoon

; 810  : 			if (d1 < 0.0f) {

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _d1$13[ebp]
	jbe	SHORT $LN28@CreateMoon

; 811  : 				d1 += bb * ((float) (x << 1) + 3.0f);

	mov	eax, DWORD PTR _x$18[ebp]
	shl	eax, 1
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _bb$15[ebp]
	addss	xmm0, DWORD PTR _d1$13[ebp]
	movss	DWORD PTR _d1$13[ebp], xmm0

; 812  : 				x++;

	mov	ecx, DWORD PTR _x$18[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$18[ebp], ecx

; 813  : 				xpos++;

	mov	edx, DWORD PTR _xpos$17[ebp]
	add	edx, 1
	mov	DWORD PTR _xpos$17[ebp], edx

; 814  : 			}
; 815  : 			else {

	jmp	$LN27@CreateMoon
$LN28@CreateMoon:

; 816  : 				if (flag) {

	cmp	DWORD PTR _flag$10[ebp], 0
	je	SHORT $LN26@CreateMoon

; 817  : 					array[counter++] = xpos;

	mov	eax, DWORD PTR _counter$20[ebp]
	mov	ecx, DWORD PTR _xpos$17[ebp]
	mov	DWORD PTR _array$23[ebp+eax*4], ecx
	mov	edx, DWORD PTR _counter$20[ebp]
	add	edx, 1
	mov	DWORD PTR _counter$20[ebp], edx

; 818  : 					flag = 0;

	mov	DWORD PTR _flag$10[ebp], 0
$LN26@CreateMoon:

; 819  : 				}
; 820  : 				d1 += bb * ((float) (x << 1) + 3.0f) + aa * ((float) (-y << 1) + 2.0f);

	mov	eax, DWORD PTR _x$18[ebp]
	shl	eax, 1
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _bb$15[ebp]
	mov	ecx, DWORD PTR _y$21[ebp]
	neg	ecx
	shl	ecx, 1
	cvtsi2ss xmm1, ecx
	addss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _aa$16[ebp]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _d1$13[ebp]
	movss	DWORD PTR _d1$13[ebp], xmm0

; 821  : 				x++;

	mov	edx, DWORD PTR _x$18[ebp]
	add	edx, 1
	mov	DWORD PTR _x$18[ebp], edx

; 822  : 				xpos++;

	mov	eax, DWORD PTR _xpos$17[ebp]
	add	eax, 1
	mov	DWORD PTR _xpos$17[ebp], eax

; 823  : 				y--;

	mov	ecx, DWORD PTR _y$21[ebp]
	sub	ecx, 1
	mov	DWORD PTR _y$21[ebp], ecx

; 824  : 				array[counter++] = xpos;

	mov	edx, DWORD PTR _counter$20[ebp]
	mov	eax, DWORD PTR _xpos$17[ebp]
	mov	DWORD PTR _array$23[ebp+edx*4], eax
	mov	ecx, DWORD PTR _counter$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _counter$20[ebp], ecx
$LN27@CreateMoon:

; 825  : 			}	
; 826  : 		}

	jmp	$LN30@CreateMoon
$LN29@CreateMoon:

; 827  : 
; 828  : 		float x1 = (float) x + 0.5f;

	cvtsi2ss xmm0, DWORD PTR _x$18[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _x1$3[ebp], xmm0

; 829  : 		float y1 = (float) y - 1.0f;

	cvtsi2ss xmm0, DWORD PTR _y$21[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _y1$2[ebp], xmm0

; 830  : 		float d2 = bb * x1*x1 + aa * y1*y1 - aa*bb;

	movss	xmm0, DWORD PTR _bb$15[ebp]
	mulss	xmm0, DWORD PTR _x1$3[ebp]
	mulss	xmm0, DWORD PTR _x1$3[ebp]
	movss	xmm1, DWORD PTR _aa$16[ebp]
	mulss	xmm1, DWORD PTR _y1$2[ebp]
	mulss	xmm1, DWORD PTR _y1$2[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _aa$16[ebp]
	mulss	xmm1, DWORD PTR _bb$15[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _d2$11[ebp], xmm0
$LN25@CreateMoon:

; 831  : 		while (y > 0) {

	cmp	DWORD PTR _y$21[ebp], 0
	jle	$LN24@CreateMoon

; 832  : 			if (d2 < 0.0f) {

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _d2$11[ebp]
	jbe	$LN23@CreateMoon

; 833  : 				if (flag) {

	cmp	DWORD PTR _flag$10[ebp], 0
	je	SHORT $LN22@CreateMoon

; 834  : 					array[counter++] = xpos;

	mov	edx, DWORD PTR _counter$20[ebp]
	mov	eax, DWORD PTR _xpos$17[ebp]
	mov	DWORD PTR _array$23[ebp+edx*4], eax
	mov	ecx, DWORD PTR _counter$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _counter$20[ebp], ecx

; 835  : 					flag = 0;

	mov	DWORD PTR _flag$10[ebp], 0
$LN22@CreateMoon:

; 836  : 				}
; 837  : 				d2 += bb * ((float) (x << 1) + 2.0f) + aa * ((float) (-y << 1) + 3.0f);

	mov	edx, DWORD PTR _x$18[ebp]
	shl	edx, 1
	cvtsi2ss xmm0, edx
	addss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _bb$15[ebp]
	mov	eax, DWORD PTR _y$21[ebp]
	neg	eax
	shl	eax, 1
	cvtsi2ss xmm1, eax
	addss	xmm1, DWORD PTR __real@40400000
	mulss	xmm1, DWORD PTR _aa$16[ebp]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _d2$11[ebp]
	movss	DWORD PTR _d2$11[ebp], xmm0

; 838  : 				x++;

	mov	ecx, DWORD PTR _x$18[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$18[ebp], ecx

; 839  : 				xpos++;

	mov	edx, DWORD PTR _xpos$17[ebp]
	add	edx, 1
	mov	DWORD PTR _xpos$17[ebp], edx

; 840  : 				y--;

	mov	eax, DWORD PTR _y$21[ebp]
	sub	eax, 1
	mov	DWORD PTR _y$21[ebp], eax

; 841  : 			}
; 842  : 			else {

	jmp	SHORT $LN21@CreateMoon
$LN23@CreateMoon:

; 843  : 				d2 += aa * ((float) (-y << 1) + 3.0f);

	mov	ecx, DWORD PTR _y$21[ebp]
	neg	ecx
	shl	ecx, 1
	cvtsi2ss xmm0, ecx
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _aa$16[ebp]
	addss	xmm0, DWORD PTR _d2$11[ebp]
	movss	DWORD PTR _d2$11[ebp], xmm0

; 844  : 				y--;

	mov	edx, DWORD PTR _y$21[ebp]
	sub	edx, 1
	mov	DWORD PTR _y$21[ebp], edx
$LN21@CreateMoon:

; 845  : 			}
; 846  : 			array[counter++] = xpos;

	mov	eax, DWORD PTR _counter$20[ebp]
	mov	ecx, DWORD PTR _xpos$17[ebp]
	mov	DWORD PTR _array$23[ebp+eax*4], ecx
	mov	edx, DWORD PTR _counter$20[ebp]
	add	edx, 1
	mov	DWORD PTR _counter$20[ebp], edx

; 847  : 		}

	jmp	$LN25@CreateMoon
$LN24@CreateMoon:

; 848  : 
; 849  : 		int	j;
; 850  : 		for (j=0; j < 32;j++) array[63-j] = array[j];

	mov	DWORD PTR _j$19[ebp], 0
	jmp	SHORT $LN20@CreateMoon
$LN19@CreateMoon:
	mov	eax, DWORD PTR _j$19[ebp]
	add	eax, 1
	mov	DWORD PTR _j$19[ebp], eax
$LN20@CreateMoon:
	cmp	DWORD PTR _j$19[ebp], 32		; 00000020H
	jge	SHORT $LN18@CreateMoon
	mov	ecx, 63					; 0000003fH
	sub	ecx, DWORD PTR _j$19[ebp]
	mov	edx, DWORD PTR _j$19[ebp]
	mov	eax, DWORD PTR _array$23[ebp+edx*4]
	mov	DWORD PTR _array$23[ebp+ecx*4], eax
	jmp	SHORT $LN19@CreateMoon
$LN18@CreateMoon:

; 851  : 		if (sizex < 0) {

	cmp	DWORD PTR _sizex$12[ebp], 0
	jge	SHORT $LN14@CreateMoon

; 852  : 			for (j=0; j < 64;j++) array[j] = 64 - array[j];

	mov	DWORD PTR _j$19[ebp], 0
	jmp	SHORT $LN16@CreateMoon
$LN15@CreateMoon:
	mov	ecx, DWORD PTR _j$19[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$19[ebp], ecx
$LN16@CreateMoon:
	cmp	DWORD PTR _j$19[ebp], 64		; 00000040H
	jge	SHORT $LN14@CreateMoon
	mov	edx, DWORD PTR _j$19[ebp]
	mov	eax, 64					; 00000040H
	sub	eax, DWORD PTR _array$23[ebp+edx*4]
	mov	ecx, DWORD PTR _j$19[ebp]
	mov	DWORD PTR _array$23[ebp+ecx*4], eax
	jmp	SHORT $LN15@CreateMoon
$LN14@CreateMoon:

; 853  : 		}
; 854  : 
; 855  : 		int	row, col, col1;
; 856  : 		int	start, stop;
; 857  : 		unsigned char *dest = image;

	mov	edx, DWORD PTR _image$[ebp]
	mov	DWORD PTR _dest$8[ebp], edx

; 858  : 		for (row=0; row < 64; row++) {

	mov	DWORD PTR _row$14[ebp], 0
	jmp	SHORT $LN13@CreateMoon
$LN12@CreateMoon:
	mov	eax, DWORD PTR _row$14[ebp]
	add	eax, 1
	mov	DWORD PTR _row$14[ebp], eax
$LN13@CreateMoon:
	cmp	DWORD PTR _row$14[ebp], 64		; 00000040H
	jge	$LN11@CreateMoon

; 859  : 			if (reverse) {

	cmp	DWORD PTR _reverse$5[ebp], 0
	je	SHORT $LN10@CreateMoon

; 860  : 				start = 0; stop = array[row];

	mov	DWORD PTR _start$1[ebp], 0
	mov	ecx, DWORD PTR _row$14[ebp]
	mov	edx, DWORD PTR _array$23[ebp+ecx*4]
	mov	DWORD PTR _stop$4[ebp], edx

; 861  : 			}
; 862  : 			else {

	jmp	SHORT $LN9@CreateMoon
$LN10@CreateMoon:

; 863  : 				start = array[row]; stop = 64;

	mov	eax, DWORD PTR _row$14[ebp]
	mov	ecx, DWORD PTR _array$23[ebp+eax*4]
	mov	DWORD PTR _start$1[ebp], ecx
	mov	DWORD PTR _stop$4[ebp], 64		; 00000040H
$LN9@CreateMoon:

; 864  : 			}
; 865  : 			int col2 = 0;

	mov	DWORD PTR _col2$9[ebp], 0

; 866  : 			for (col=0; col < 8; col++) {

	mov	DWORD PTR _col$6[ebp], 0
	jmp	SHORT $LN8@CreateMoon
$LN7@CreateMoon:
	mov	edx, DWORD PTR _col$6[ebp]
	add	edx, 1
	mov	DWORD PTR _col$6[ebp], edx
$LN8@CreateMoon:
	cmp	DWORD PTR _col$6[ebp], 8
	jge	$LN6@CreateMoon

; 867  : 				unsigned char c = 0;

	mov	BYTE PTR _c$22[ebp], 0

; 868  : 				for (col1=0; col1 < 8; col1++) {

	mov	DWORD PTR _col1$7[ebp], 0
	jmp	SHORT $LN5@CreateMoon
$LN4@CreateMoon:
	mov	eax, DWORD PTR _col1$7[ebp]
	add	eax, 1
	mov	DWORD PTR _col1$7[ebp], eax
$LN5@CreateMoon:
	cmp	DWORD PTR _col1$7[ebp], 8
	jge	SHORT $LN3@CreateMoon

; 869  : 					c <<= 1;

	mov	cl, BYTE PTR _c$22[ebp]
	shl	cl, 1
	mov	BYTE PTR _c$22[ebp], cl

; 870  : 					if ((col2 < start) || (col2 >= stop)) c |= 1;

	mov	edx, DWORD PTR _col2$9[ebp]
	cmp	edx, DWORD PTR _start$1[ebp]
	jl	SHORT $LN1@CreateMoon
	mov	eax, DWORD PTR _col2$9[ebp]
	cmp	eax, DWORD PTR _stop$4[ebp]
	jl	SHORT $LN2@CreateMoon
$LN1@CreateMoon:
	movzx	ecx, BYTE PTR _c$22[ebp]
	or	ecx, 1
	mov	BYTE PTR _c$22[ebp], cl
$LN2@CreateMoon:

; 871  : 					col2++;

	mov	edx, DWORD PTR _col2$9[ebp]
	add	edx, 1
	mov	DWORD PTR _col2$9[ebp], edx

; 872  : 				}

	jmp	SHORT $LN4@CreateMoon
$LN3@CreateMoon:

; 873  : 				*dest++ = c;

	mov	eax, DWORD PTR _dest$8[ebp]
	mov	cl, BYTE PTR _c$22[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _dest$8[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$8[ebp], edx

; 874  : 			}

	jmp	$LN7@CreateMoon
$LN6@CreateMoon:

; 875  : 		}

	jmp	$LN12@CreateMoon
$LN11@CreateMoon:

; 876  : 	}
; 877  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?CreateMoonPhaseMask@CTimeOfDay@@QAEXPAEH@Z ENDP	; CTimeOfDay::CreateMoonPhaseMask
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_cos3$ = -36						; size = 4
_cos2$ = -32						; size = 4
_cos1$ = -28						; size = 4
_sin2$ = -24						; size = 4
_sin1$ = -20						; size = 4
_yaw1$ = -16						; size = 4
_pitch1$ = -12						; size = 4
_this$ = -8						; size = 4
_alpha$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
?GetSunGlare@CTimeOfDay@@QAEMHH@Z PROC			; CTimeOfDay::GetSunGlare
; _this$ = ecx

; 728  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 	// TODO: Instead of all this, just do a dot product with the light vector...
; 730  : 	int pitch1 = GetSunPitch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSunPitch@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetSunPitch
	mov	DWORD PTR _pitch1$[ebp], eax

; 731  : 	int yaw1 = GetSunYaw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSunYaw@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetSunYaw
	mov	DWORD PTR _yaw1$[ebp], eax

; 732  : 	float sin1, sin2, cos1, cos2, cos3;
; 733  : 	glGetSinCos (&sin1, &cos1, pitch);

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cos1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sin1$[ebp]
	push	edx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 734  : 	glGetSinCos (&sin2, &cos2, pitch1);

	mov	eax, DWORD PTR _pitch1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sin2$[ebp]
	push	edx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 735  : 	cos3 = (float) glGetCosine (yaw - yaw1);

	mov	eax, DWORD PTR _yaw$[ebp]
	sub	eax, DWORD PTR _yaw1$[ebp]
	push	eax
	call	?glGetCosine@@YANH@Z			; glGetCosine
	add	esp, 4
	fstp	DWORD PTR _cos3$[ebp]

; 736  : 	float alpha = sin1 * sin2 + cos1 * cos2 * cos3;

	movss	xmm0, DWORD PTR _sin1$[ebp]
	mulss	xmm0, DWORD PTR _sin2$[ebp]
	movss	xmm1, DWORD PTR _cos1$[ebp]
	mulss	xmm1, DWORD PTR _cos2$[ebp]
	mulss	xmm1, DWORD PTR _cos3$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _alpha$[ebp], xmm0

; 737  : 
; 738  : 	alpha -= SunGlareCosine;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _alpha$[ebp]
	subss	xmm0, DWORD PTR [ecx+340]
	movss	DWORD PTR _alpha$[ebp], xmm0

; 739  : 	alpha *= SunGlareFactor;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _alpha$[ebp]
	mulss	xmm0, DWORD PTR [edx+344]
	movss	DWORD PTR _alpha$[ebp], xmm0

; 740  : 
; 741  : 	// just to make sure, clamp value
; 742  : 	if (alpha > 1.0f) alpha = 1.0f;	

	movss	xmm0, DWORD PTR _alpha$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@GetSunGlar
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$[ebp], xmm0
	jmp	SHORT $LN1@GetSunGlar
$LN3@GetSunGlar:

; 743  : 	else if (alpha < 0.0f) alpha = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _alpha$[ebp]
	jbe	SHORT $LN1@GetSunGlar
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN1@GetSunGlar:

; 744  : 
; 745  : 	return alpha;

	fld	DWORD PTR _alpha$[ebp]

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetSunGlare@CTimeOfDay@@QAEMHH@Z ENDP			; CTimeOfDay::GetSunGlare
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_angle$ = 8						; size = 4
?SetSunGlareAngle@CTimeOfDay@@QAEXH@Z PROC		; CTimeOfDay::SetSunGlareAngle
; _this$ = ecx

; 722  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 723  : 	SunGlareCosine = (float) glGetCosine (angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?glGetCosine@@YANH@Z			; glGetCosine
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+340]

; 724  : 	SunGlareFactor = 1.0f / (1.0f - SunGlareCosine);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+340]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+344], xmm1

; 725  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSunGlareAngle@CTimeOfDay@@QAEXH@Z ENDP		; CTimeOfDay::SetSunGlareAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?CalculateSunGroundPos@CTimeOfDay@@QAEXPAUTpoint@@@Z PROC ; CTimeOfDay::CalculateSunGroundPos
; _this$ = ecx

; 522  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 523  : 	pos -> x =	SunCoord.x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 524  : 	pos -> y =	SunCoord.y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 525  : 	pos -> z =	0.0f;

	mov	eax, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+8], xmm0

; 526  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateSunGroundPos@CTimeOfDay@@QAEXPAUTpoint@@@Z ENDP ; CTimeOfDay::CalculateSunGroundPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
_ismoon$ = 12						; size = 4
?CalculateSunMoonPos@CTimeOfDay@@QAEXPAUTpoint@@H@Z PROC ; CTimeOfDay::CalculateSunMoonPos
; _this$ = ecx

; 530  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 531  : 	if (ismoon) *pos = MoonCoord;

	cmp	DWORD PTR _ismoon$[ebp], 0
	je	SHORT $LN2@CalculateS
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN3@CalculateS
$LN2@CalculateS:

; 532  : 	else *pos = SunCoord;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
$LN3@CalculateS:

; 533  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CalculateSunMoonPos@CTimeOfDay@@QAEXPAUTpoint@@H@Z ENDP ; CTimeOfDay::CalculateSunMoonPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_sC$ = -20						; size = 4
_sH$ = -16						; size = 4
_cH$ = -12						; size = 4
_cC$ = -8						; size = 4
_this$ = -4						; size = 4
_LightDirection$ = 8					; size = 4
?GetLightDirection@CTimeOfDay@@QAEXPAUTpoint@@@Z PROC	; CTimeOfDay::GetLightDirection
; _this$ = ecx

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 540  : 	float sH, cH, sC, cC;
; 541  : 	
; 542  : 	ShiAssert( LightDirection );
; 543  : 
; 544  : 	// See if the sun is up
; 545  : 	if ( ThereIsASun() ) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThereIsASun@CTimeOfDay@@QAEHXZ		; CTimeOfDay::ThereIsASun
	test	eax, eax
	je	SHORT $LN4@GetLightDi

; 546  : 		glGetSinCos (&sH, &cH, ISunYaw);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	lea	edx, DWORD PTR _cH$[ebp]
	push	edx
	lea	eax, DWORD PTR _sH$[ebp]
	push	eax
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 547  : 		glGetSinCos (&sC, &cC, ISunPitch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	lea	eax, DWORD PTR _cC$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sC$[ebp]
	push	ecx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@GetLightDi
$LN4@GetLightDi:

; 548  : 	} 
; 549  : 	else if ( ThereIsAMoon() ) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThereIsAMoon@CTimeOfDay@@QAEHXZ	; CTimeOfDay::ThereIsAMoon
	test	eax, eax
	je	SHORT $LN2@GetLightDi

; 550  : 		glGetSinCos (&sH, &cH, IMoonYaw);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+316]
	push	eax
	lea	ecx, DWORD PTR _cH$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sH$[ebp]
	push	edx
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 551  : 		glGetSinCos (&sC, &cC, IMoonPitch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	lea	edx, DWORD PTR _cC$[ebp]
	push	edx
	lea	eax, DWORD PTR _sC$[ebp]
	push	eax
	call	?glGetSinCos@@YAXPAM0H@Z		; glGetSinCos
	add	esp, 12					; 0000000cH

; 552  : 	} 
; 553  : 	else {

	jmp	SHORT $LN1@GetLightDi
$LN2@GetLightDi:

; 554  : 		cC = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cC$[ebp], xmm0

; 555  : 		sC = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _sC$[ebp], xmm0

; 556  : 		cH = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cH$[ebp], xmm0

; 557  : 		sH = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _sH$[ebp], xmm0
$LN1@GetLightDi:

; 558  : 	}
; 559  : 	LightDirection->x =	cC * cH;

	movss	xmm0, DWORD PTR _cC$[ebp]
	mulss	xmm0, DWORD PTR _cH$[ebp]
	mov	ecx, DWORD PTR _LightDirection$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 560  : 	LightDirection->y =	cC * sH;

	movss	xmm0, DWORD PTR _cC$[ebp]
	mulss	xmm0, DWORD PTR _sH$[ebp]
	mov	edx, DWORD PTR _LightDirection$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 561  : 	LightDirection->z =	-sC;

	movss	xmm0, DWORD PTR _sC$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _LightDirection$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 562  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLightDirection@CTimeOfDay@@QAEXPAUTpoint@@@Z ENDP	; CTimeOfDay::GetLightDirection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?IsReady@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsReady@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::IsReady, COMDAT
; _this$ = ecx

; 72   : 	BOOL	IsReady()								{ return (TimeOfDay != NULL); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN3@IsReady
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsReady
$LN3@IsReady:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsReady:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReady@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::IsReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetNVGmode@CTimeOfDay@@QAEXH@Z PROC			; CTimeOfDay::SetNVGmode
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 	NVGmode = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+348], ecx

; 186  : /*
; 187  : 	Tcolor	paletteEffect;
; 188  : 	int		id;
; 189  : 
; 190  : 	// Convert all the object texture palettes appropriatly
; 191  : 	paletteEffect.g = 1.0f;
; 192  : 	if (NVGmode) {
; 193  : 		paletteEffect.r = 0.0f;
; 194  : 		paletteEffect.b = 0.0f;
; 195  : 	} else {
; 196  : 		paletteEffect.r = 1.0f;
; 197  : 		paletteEffect.b = 1.0f;
; 198  : 	}
; 199  : 	for (id=0; ThePaletteBank.IsValidIndex( id ); id++) {
; 200  : 		ThePaletteBank.LightPalette( id, &paletteEffect );
; 201  : 	}
; 202  : */
; 203  : 	// Force a lighting refresh to reflect the changes
; 204  : 	TheTimeManager.Refresh();

	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?Refresh@TimeManager@@QAEXXZ		; TimeManager::Refresh

; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetNVGmode@CTimeOfDay@@QAEXH@Z ENDP			; CTimeOfDay::SetNVGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Cleanup@CTimeOfDay@@QAEXXZ PROC			; CTimeOfDay::Cleanup
; _this$ = ecx

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	ShiAssert( IsReady() );
; 171  : 
; 172  : 	// Stop receiving time updates
; 173  : 	TheTimeManager.ReleaseTimeUpdateCB(TimeUpdateCallback,this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?TimeUpdateCallback@CTimeOfDay@@KAXPAX@Z ; CTimeOfDay::TimeUpdateCallback
	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?ReleaseTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ; TimeManager::ReleaseTimeUpdateCB

; 174  : 
; 175  : 	// Clean up and release the start position data
; 176  : 	TheStar.Cleanup ();

	call	?Cleanup@CStar@@SAXXZ			; CStar::Cleanup

; 177  : 
; 178  : 	// Clean up and release the time of data transition data
; 179  : 	delete[] TimeOfDay;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 180  : 	TimeOfDay = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 181  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@CTimeOfDay@@QAEXXZ ENDP			; CTimeOfDay::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\weather\tod.cpp
_TEXT	SEGMENT
$T1 = -2136						; size = 4
_extraday$ = -2132					; size = 4
_month$ = -2128						; size = 4
_year$ = -2124						; size = 4
_day$ = -2120						; size = 4
_k$2 = -2116						; size = 4
_j$ = -2112						; size = 4
_in$ = -2108						; size = 4
_i$ = -2104						; size = 4
_this$ = -2100						; size = 4
_temptod$ = -2096					; size = 156
_buffer$3 = -1940					; size = 580
_buffer$4 = -1360					; size = 580
_string$5 = -780					; size = 256
_starfile$ = -524					; size = 260
_todfile$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_dataPath$ = 8						; size = 4
?Setup@CTimeOfDay@@QAEXPAD@Z PROC			; CTimeOfDay::Setup
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2136				; 00000858H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 	char	todfile[_MAX_PATH];
; 45   : 	char	starfile[_MAX_PATH];
; 46   : 	FILE	*in;
; 47   : 
; 48   : 	ShiAssert( !IsReady() );
; 49   : 
; 50   : 	// Construct the input filename we need
; 51   : //	if (skycolor)
; 52   : //		sprintf( todfile, "%s\\tod\\%s", dataPath, skycolor[PlayerOptions.skycol-1].todname);
; 53   : 
; 54   : 	sprintf( starfile, "%s\\star.dat", dataPath );

	mov	eax, DWORD PTR _dataPath$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@ICLMKAHJ@?$CFs?2star?4dat?$AA@
	lea	ecx, DWORD PTR _starfile$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 55   : 
; 56   : //	if (!skycolor || !(in=fopen(todfile,"r")))	// Oops, the todfile is not there ? Use default one
; 57   : //	{
; 58   : //		sprintf( todfile, "%s\\tod\\tod.lst.default", dataPath);
; 59   : 
; 60   : //		if (!(in=fopen(todfile,"r")))	// Oops, the todfile is not there ? Use default one
; 61   : //			sprintf( todfile, "%s\\tod.lst", dataPath);
; 62   : //		else 
; 63   : //			fclose(in);
; 64   : //	}
; 65   : //	else 
; 66   : //		fclose(in);
; 67   : 	
; 68   : 	sprintf(todfile,"%s\\tod.lst",dataPath);

	mov	edx, DWORD PTR _dataPath$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@DOMPLMHA@?$CFs?2tod?4lst?$AA@
	lea	eax, DWORD PTR _todfile$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 69   : 	in = FILE_Open (todfile, "r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	ecx, DWORD PTR _todfile$[ebp]
	push	ecx
	call	?FILE_Open@@YAPAU_iobuf@@PAD0@Z		; FILE_Open
	add	esp, 8
	mov	DWORD PTR _in$[ebp], eax

; 70   : 	if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN14@Setup

; 71   : 		//char string[256];
; 72   : 		//sprintf( string, "TOD file open failed:  %s", todfile );
; 73   : 		//ShiError( string );
; 74   : 		// We need to exit gracefully
; 75   : 		return;

	jmp	$LN15@Setup
$LN14@Setup:

; 76   : 	}
; 77   : 
; 78   : 	TimeOfDayStruct temptod;
; 79   : 	TotalTimeOfDay = ReadTODFile (in, &temptod, 1);

	push	1
	lea	edx, DWORD PTR _temptod$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadTODFile@CTimeOfDay@@IAEHPAU_iobuf@@PAUTimeOfDayStruct@@H@Z ; CTimeOfDay::ReadTODFile
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 80   : 	if (!TotalTimeOfDay) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $LN13@Setup

; 81   : 		fclose (in);

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 82   : 		char string[256];
; 83   : 		sprintf( string, "No data obtained from TOD file:  %s", todfile );

	lea	ecx, DWORD PTR _todfile$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CE@KJCMLJIH@No?5data?5obtained?5from?5TOD?5file?3?5@
	lea	edx, DWORD PTR _string$5[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 84   : 		ShiError( string );

	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_07IJIGHEME@Tod?4cpp?$AA@
	push	84					; 00000054H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$4[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	lea	ecx, DWORD PTR _string$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$4[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN13@Setup:

; 85   : 	}
; 86   : 
; 87   : 	TimeOfDay = new TimeOfDayStruct[TotalTimeOfDay];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, 156				; 0000009cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+36], ecx

; 88   : 	if (!TimeOfDay) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN12@Setup

; 89   : 		fclose (in);

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 90   : 		ShiError( "Failed TOD memory allocation" );

	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_07IJIGHEME@Tod?4cpp?$AA@
	push	90					; 0000005aH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BN@KPMPBEF@Failed?5TOD?5memory?5allocation?$AA@
	lea	edx, DWORD PTR _buffer$3[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN12@Setup:

; 91   : 	}
; 92   : 
; 93   : 	fseek (in, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 94   : 
; 95   : 	ISunYaw = IMoonYaw = 4096;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], 4096		; 00001000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], 4096		; 00001000H

; 96   : 	ISunTilt = IMoonTilt = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+324], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], 0

; 97   : 	HazeSunriseColor.r = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+264], xmm0

; 98   : 	HazeSunriseColor.g = 0.6f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [eax+268], xmm0

; 99   : 	HazeSunriseColor.b = 0.1f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [ecx+272], xmm0

; 100  : 	HazeSunsetColor.r = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+276], xmm0

; 101  : 	HazeSunsetColor.g = 0.6f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [eax+280], xmm0

; 102  : 	HazeSunsetColor.b = 0.1f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [ecx+284], xmm0

; 103  : 	Flag = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+308], 0

; 104  : 
; 105  : 	ReadTODFile (in, TimeOfDay-1);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, 156				; 0000009cH
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadTODFile@CTimeOfDay@@IAEHPAU_iobuf@@PAUTimeOfDayStruct@@H@Z ; CTimeOfDay::ReadTODFile

; 106  : 	fclose (in);

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 107  : 
; 108  : 	SetVar (TimeOfDay);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVar@CTimeOfDay@@IAEXPAUTimeOfDayStruct@@@Z ; CTimeOfDay::SetVar

; 109  : 
; 110  : ////////////////
; 111  : 	if (TheStar.Setup (starfile, 11.0f)) {	// load all stars with magnitude less than 11

	push	ecx
	movss	xmm0, DWORD PTR __real@41300000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _starfile$[ebp]
	push	eax
	call	?Setup@CStar@@SAHPADM@Z			; CStar::Setup
	add	esp, 8

; 112  : 	//ShiError ("Failed Loading Star"); 
; 113  : 	// We nead to exit cleanly?
; 114  : 	}
; 115  : 	TheStarData = TheStar.GetStarData();

	call	?GetStarData@CStar@@SAPAUStarData@@XZ	; CStar::GetStarData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 116  : 	TheStar.SetHorizon ((float) degtorad(5), (float) degtorad(15));	// display stars with elevation > horizon

	push	ecx
	movss	xmm0, DWORD PTR __real@3e860a92
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db2b8c3
	movss	DWORD PTR [esp], xmm0
	call	?SetHorizon@CStar@@SAXMM@Z		; CStar::SetHorizon

; 117  : // M.N. changed back from theater.map readout. It seems that the sun position is normalized to korean latitude,
; 118  : // so no need to change it at all...
; 119  : 	TheStar.SetLocation (g_fLatitude, 0.0f);								// latitude, longitude

	add	esp, 4
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?g_fLatitude@@3MA
	movss	DWORD PTR [esp], xmm0
	call	?SetLocation@CStar@@SAXMM@Z		; CStar::SetLocation
	add	esp, 8

; 120  : 
; 121  : /*
; 122  : 	struct tm *newtime;
; 123  : 	long ltime;
; 124  : 	time( &ltime );
; 125  : 	newtime = gmtime( &ltime );
; 126  : 	TheStar.SetDate (newtime -> tm_mday, newtime -> tm_mon + 1, newtime -> tm_year + 1900);
; 127  : */
; 128  : 	int year = TheTimeManager.GetYearAD();

	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?GetYearAD@TimeManager@@QAEKXZ		; TimeManager::GetYearAD
	mov	DWORD PTR _year$[ebp], eax

; 129  : 	int extraday = TheTimeManager.GetDayOfYear();

	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?GetDayOfYear@TimeManager@@QAEKXZ	; TimeManager::GetDayOfYear
	mov	DWORD PTR _extraday$[ebp], eax

; 130  : 	int month = 1;

	mov	DWORD PTR _month$[ebp], 1

; 131  : 	int day = 0;

	mov	DWORD PTR _day$[ebp], 0

; 132  : 	TheStar.CalculateDate (&day, &month, &year, extraday);

	mov	edx, DWORD PTR _extraday$[ebp]
	push	edx
	lea	eax, DWORD PTR _year$[ebp]
	push	eax
	lea	ecx, DWORD PTR _month$[ebp]
	push	ecx
	lea	edx, DWORD PTR _day$[ebp]
	push	edx
	call	?CalculateDate@CStar@@SAXPAH00H@Z	; CStar::CalculateDate
	add	esp, 16					; 00000010H

; 133  : 	TheStar.SetDate (day, month, year);	

	mov	eax, DWORD PTR _year$[ebp]
	push	eax
	mov	ecx, DWORD PTR _month$[ebp]
	push	ecx
	mov	edx, DWORD PTR _day$[ebp]
	push	edx
	call	?SetDate@CStar@@SAXHHH@Z		; CStar::SetDate
	add	esp, 12					; 0000000cH

; 134  : 
; 135  : 	lastMoonTime = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 136  : 	MoonPhase = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 137  : ////////////////////
; 138  : 
; 139  : 	int i, j;
; 140  : 	for (i=0; i < TotalTimeOfDay;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Setup
$LN9@Setup:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@Setup:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN8@Setup

; 141  : 		j = i + 1;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx

; 142  : 		if (j >= TotalTimeOfDay) j = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jl	SHORT $LN7@Setup
	mov	DWORD PTR _j$[ebp], 0
$LN7@Setup:

; 143  : 		if (!(TimeOfDay[j].Flag & GL_TIME_OF_DAY_USE_SUN))

	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 156				; 0000009cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+88]
	and	edx, 1
	jne	SHORT $LN6@Setup

; 144  : 			TimeOfDay[i].Flag &= ~GL_TIME_OF_DAY_USE_SUN;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 156				; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+88]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	DWORD PTR [edx+ecx+88], eax
$LN6@Setup:

; 145  : 		if (!(TimeOfDay[j].Flag & GL_TIME_OF_DAY_USE_MOON))

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 156				; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+88]
	and	eax, 2
	jne	SHORT $LN5@Setup

; 146  : 			TimeOfDay[i].Flag &= ~GL_TIME_OF_DAY_USE_MOON;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx+88]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 156				; 0000009cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+edx+88], ecx
$LN5@Setup:

; 147  : 		int k = 0;

	mov	DWORD PTR _k$2[ebp], 0

; 148  : 		if (TimeOfDay[i].StarIntensity > 0.0f) k = 1;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR [eax+ecx+100]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@Setup
	mov	DWORD PTR _k$2[ebp], 1
	jmp	SHORT $LN2@Setup
$LN4@Setup:

; 149  : 		else if (TimeOfDay[j].StarIntensity > 0.0f) k = 1;

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR [eax+ecx+100]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@Setup
	mov	DWORD PTR _k$2[ebp], 1
$LN2@Setup:

; 150  : 		if (k) TimeOfDay[i].Flag |= GL_TIME_OF_DAY_USE_STAR;

	cmp	DWORD PTR _k$2[ebp], 0
	je	SHORT $LN1@Setup
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx+88]
	or	ecx, 4
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 156				; 0000009cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+edx+88], ecx
$LN1@Setup:

; 151  : 	}

	jmp	$LN9@Setup
$LN8@Setup:

; 152  : 
; 153  : 
; 154  : 	// Default lighting conditions
; 155  : 	Ambient = .3f; Diffuse = .6f; Specular = .8f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [ecx+220], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [edx+224], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [eax+228], xmm0

; 156  : 
; 157  : 	// default glare angle is 22.5 deg
; 158  : 	SetSunGlareAngle (1024);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSunGlareAngle@CTimeOfDay@@QAEXH@Z	; CTimeOfDay::SetSunGlareAngle

; 159  : 
; 160  : 	// Start with NVGs off
; 161  : 	NVGmode = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+348], 0

; 162  : 
; 163  : 	// Initialize the lighting conditions and register for future time of day updates
; 164  : 	TimeUpdateCallback(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?TimeUpdateCallback@CTimeOfDay@@KAXPAX@Z ; CTimeOfDay::TimeUpdateCallback
	add	esp, 4

; 165  : 	TheTimeManager.RegisterTimeUpdateCB(TimeUpdateCallback,this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?TimeUpdateCallback@CTimeOfDay@@KAXPAX@Z ; CTimeOfDay::TimeUpdateCallback
	mov	ecx, OFFSET ?TheTimeManager@@3VTimeManager@@A ; TheTimeManager
	call	?RegisterTimeUpdateCB@TimeManager@@QAEXP6AXPAX@Z0@Z ; TimeManager::RegisterTimeUpdateCB
$LN15@Setup:

; 166  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?Setup@CTimeOfDay@@QAEXPAD@Z ENDP			; CTimeOfDay::Setup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ??1CTimeOfDay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTimeOfDay@@QAE@XZ PROC				; CTimeOfDay::~CTimeOfDay, COMDAT
; _this$ = ecx

; 63   : 	~CTimeOfDay()								{ if(IsReady())	Cleanup (); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReady@CTimeOfDay@@QAEHXZ		; CTimeOfDay::IsReady
	test	eax, eax
	je	SHORT $LN2@CTimeOfDay
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@CTimeOfDay@@QAEXXZ		; CTimeOfDay::Cleanup
$LN2@CTimeOfDay:
	mov	esp, ebp
	pop	ebp
	ret	0
??1CTimeOfDay@@QAE@XZ ENDP				; CTimeOfDay::~CTimeOfDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ??0CTimeOfDay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTimeOfDay@@QAE@XZ PROC				; CTimeOfDay::CTimeOfDay, COMDAT
; _this$ = ecx

; 62   : 	CTimeOfDay()								{ TimeOfDay = NULL; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CTimeOfDay@@QAE@XZ ENDP				; CTimeOfDay::CTimeOfDay
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCStar@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCStar@@UAEPAXI@Z PROC				; CStar::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CStar@@UAE@XZ			; CStar::~CStar
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCStar@@UAEPAXI@Z ENDP				; CStar::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\star.h
;	COMDAT ?SetMoonPosition@CStar@@SAXMM@Z
_TEXT	SEGMENT
_az$ = 8						; size = 4
_alt$ = 12						; size = 4
?SetMoonPosition@CStar@@SAXMM@Z PROC			; CStar::SetMoonPosition, COMDAT

; 133  : static void SetMoonPosition (float az, float alt) { MoonAz = az; MoonAlt = alt; };

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR ?MoonAz@CStar@@1MA, xmm0
	movss	xmm0, DWORD PTR _alt$[ebp]
	movss	DWORD PTR ?MoonAlt@CStar@@1MA, xmm0
	pop	ebp
	ret	0
?SetMoonPosition@CStar@@SAXMM@Z ENDP			; CStar::SetMoonPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\star.h
;	COMDAT ?SetSunPosition@CStar@@SAXMM@Z
_TEXT	SEGMENT
_az$ = 8						; size = 4
_alt$ = 12						; size = 4
?SetSunPosition@CStar@@SAXMM@Z PROC			; CStar::SetSunPosition, COMDAT

; 132  : static void SetSunPosition (float az, float alt) { SunAz = az; SunAlt = alt; };

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR ?SunAz@CStar@@1MA, xmm0
	movss	xmm0, DWORD PTR _alt$[ebp]
	movss	DWORD PTR ?SunAlt@CStar@@1MA, xmm0
	pop	ebp
	ret	0
?SetSunPosition@CStar@@SAXMM@Z ENDP			; CStar::SetSunPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\star.h
;	COMDAT ?GetStarData@CStar@@SAPAUStarData@@XZ
_TEXT	SEGMENT
?GetStarData@CStar@@SAPAUStarData@@XZ PROC		; CStar::GetStarData, COMDAT

; 106  : static StarData *GetStarData () { return CurrentStarData; };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?CurrentStarData@CStar@@1PAUStarData@@A ; CStar::CurrentStarData
	pop	ebp
	ret	0
?GetStarData@CStar@@SAPAUStarData@@XZ ENDP		; CStar::GetStarData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\star.h
;	COMDAT ??1CStar@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CStar@@UAE@XZ PROC					; CStar::~CStar, COMDAT
; _this$ = ecx

; 102  : virtual ~CStar() { Cleanup (); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CStar@@6B@
	call	?Cleanup@CStar@@SAXXZ			; CStar::Cleanup
	mov	esp, ebp
	pop	ebp
	ret	0
??1CStar@@UAE@XZ ENDP					; CStar::~CStar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\star.h
;	COMDAT ??0CStar@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CStar@@QAE@XZ PROC					; CStar::CStar, COMDAT
; _this$ = ecx

; 101  : CStar () {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CStar@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CStar@@QAE@XZ ENDP					; CStar::CStar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ?GetClockTime@TimeManager@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClockTime@TimeManager@@QAEKXZ PROC			; TimeManager::GetClockTime, COMDAT
; _this$ = ecx

; 48   : 	DWORD	GetClockTime( void )		{ return currentTime; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClockTime@TimeManager@@QAEKXZ ENDP			; TimeManager::GetClockTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ?GetTimeOfDay@TimeManager@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTimeOfDay@TimeManager@@QAEKXZ PROC			; TimeManager::GetTimeOfDay, COMDAT
; _this$ = ecx

; 47   : 	DWORD	GetTimeOfDay( void )		{ return timeOfDay; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTimeOfDay@TimeManager@@QAEKXZ ENDP			; TimeManager::GetTimeOfDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ?GetDayOfYear@TimeManager@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDayOfYear@TimeManager@@QAEKXZ PROC			; TimeManager::GetDayOfYear, COMDAT
; _this$ = ecx

; 45   : 	DWORD	GetDayOfYear( void )		{ return today; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDayOfYear@TimeManager@@QAEKXZ ENDP			; TimeManager::GetDayOfYear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\timemgr.h
;	COMDAT ?GetYearAD@TimeManager@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYearAD@TimeManager@@QAEKXZ PROC			; TimeManager::GetYearAD, COMDAT
; _this$ = ecx

; 44   : 	DWORD	GetYearAD( void )			{ return year; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetYearAD@TimeManager@@QAEKXZ ENDP			; TimeManager::GetYearAD
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\grinline.h
;	COMDAT ?glConvertFromDegreef@@YAMM@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
_deg$ = 8						; size = 4
?glConvertFromDegreef@@YAMM@Z PROC			; glConvertFromDegreef, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 103  : 	return (deg * 45.511111111f + 0.5f);

	movss	xmm0, DWORD PTR _deg$[ebp]
	mulss	xmm0, DWORD PTR __real@42360b61
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]

; 104  : }	/* glConvertFromDegreef */

	mov	esp, ebp
	pop	ebp
	ret	0
?glConvertFromDegreef@@YAMM@Z ENDP			; glConvertFromDegreef
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\grinline.h
;	COMDAT ?glConvertFromDegree@@YAHM@Z
_TEXT	SEGMENT
_deg$ = 8						; size = 4
?glConvertFromDegree@@YAHM@Z PROC			; glConvertFromDegree, COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp

; 98   : 	return ( FloatToInt32(deg * 45.511111111f + 0.5f) );

	movss	xmm0, DWORD PTR _deg$[ebp]
	mulss	xmm0, DWORD PTR __real@42360b61
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 99   : }	/* glConvertFromDegree */

	pop	ebp
	ret	0
?glConvertFromDegree@@YAHM@Z ENDP			; glConvertFromDegree
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
END
