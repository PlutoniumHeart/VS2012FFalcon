; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUPD\Supply.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_ceilf
PUBLIC	?ceil@@YAMM@Z					; ceil
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?GetObjectiveOldown@ObjectiveClass@@QAEEXZ	; ObjectiveClass::GetObjectiveOldown
PUBLIC	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ	; ObjectiveClass::GetObjectiveStatus
PUBLIC	?GetObjectiveSupplyLosses@ObjectiveClass@@QAEFXZ ; ObjectiveClass::GetObjectiveSupplyLosses
PUBLIC	?GetSupplyAvail@TeamClass@@QAEGXZ		; TeamClass::GetSupplyAvail
PUBLIC	?GetFuelAvail@TeamClass@@QAEGXZ			; TeamClass::GetFuelAvail
PUBLIC	?GetReplacementsAvail@TeamClass@@QAEGXZ		; TeamClass::GetReplacementsAvail
PUBLIC	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
PUBLIC	?GetLength@BasePathClass@@QAEHXZ		; BasePathClass::GetLength
PUBLIC	??1PathClass@@QAE@XZ				; PathClass::~PathClass
PUBLIC	?ProduceSupplies@@YAHK@Z			; ProduceSupplies
PUBLIC	?AddSupply@@YAXPAVObjectiveClass@@HH@Z		; AddSupply
PUBLIC	?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z	; SendSupply
PUBLIC	?SupplyUnit@@YAXPAVUnitClass@@HHHH@Z		; SupplyUnit
PUBLIC	?SupplyUnits@@YAHEK@Z				; SupplyUnits
PUBLIC	__real@00000000
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f59999a
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40c00000
PUBLIC	__real@41c80000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@4ca4cb80
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_rand:PROC
EXTRN	_ceil:PROC
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	??0MissionRequestClass@@QAE@XZ:PROC		; MissionRequestClass::MissionRequestClass
EXTRN	??1MissionRequestClass@@QAE@XZ:PROC		; MissionRequestClass::~MissionRequestClass
EXTRN	?RequestMission@MissionRequestClass@@QAEHXZ:PROC ; MissionRequestClass::RequestMission
EXTRN	?RequestEnemyMission@MissionRequestClass@@QAEHXZ:PROC ; MissionRequestClass::RequestEnemyMission
EXTRN	?SendObjMessage@ObjectiveClass@@QAEXVVU_ID@@FFFF@Z:PROC ; ObjectiveClass::SendObjMessage
EXTRN	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z:PROC	; ObjectiveClass::GetNeighbor
EXTRN	?GetObjectiveDataRate@ObjectiveClass@@QAEFXZ:PROC ; ObjectiveClass::GetObjectiveDataRate
EXTRN	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z:PROC ; GetFirstObjective
EXTRN	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z:PROC ; GetNextObjective
EXTRN	?SetSupplyAvail@TeamClass@@QAEXH@Z:PROC		; TeamClass::SetSupplyAvail
EXTRN	?SetFuelAvail@TeamClass@@QAEXH@Z:PROC		; TeamClass::SetFuelAvail
EXTRN	?SetReplacementsAvail@TeamClass@@QAEXH@Z:PROC	; TeamClass::SetReplacementsAvail
EXTRN	?GetEnemyTeam@@YAEE@Z:PROC			; GetEnemyTeam
EXTRN	??1BasePathClass@@QAE@XZ:PROC			; BasePathClass::~BasePathClass
EXTRN	?GetDirection@BasePathClass@@QAEHH@Z:PROC	; BasePathClass::GetDirection
EXTRN	??0PathClass@@QAE@XZ:PROC			; PathClass::PathClass
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetFullstrengthVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetFullstrengthVehicles
EXTRN	?ChangeVehicles@UnitClass@@QAEHH@Z:PROC		; UnitClass::ChangeVehicles
EXTRN	?GetUnitSupplyTime@UnitClass@@QAEKXZ:PROC	; UnitClass::GetUnitSupplyTime
EXTRN	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetFirstUnit
EXTRN	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetNextUnit
EXTRN	?DistanceToFront@@YAMFF@Z:PROC			; DistanceToFront
EXTRN	?FindNearestSupplySource@@YAPAVObjectiveClass@@PAV1@@Z:PROC ; FindNearestSupplySource
EXTRN	?FindNearestFriendlyObjective@@YAPAVObjectiveClass@@EPAF0H@Z:PROC ; FindNearestFriendlyObjective
EXTRN	?FindNearestFriendlyPowerStation@@YAPAVObjectiveClass@@PAVVuLinkedList@@EFF@Z:PROC ; FindNearestFriendlyPowerStation
EXTRN	?GetObjectivePath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1HHH@Z:PROC ; GetObjectivePath
EXTRN	?ReinforcePilots@SquadronClass@@QAEXH@Z:PROC	; SquadronClass::ReinforcePilots
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?AllUnitList@@3PAVVuLinkedList@@A:DWORD		; AllUnitList
EXTRN	?AllObjList@@3PAVVuLinkedList@@A:DWORD		; AllObjList
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?DataRateModRepl@@3MA:DWORD			; DataRateModRepl
EXTRN	?DataRateModSup@@3MA:DWORD			; DataRateModSup
EXTRN	?RelSquadBonus@@3MA:DWORD			; RelSquadBonus
EXTRN	?NoActionBonusProd@@3HA:DWORD			; NoActionBonusProd
EXTRN	?NoTypeBonusRepl@@3HA:DWORD			; NoTypeBonusRepl
EXTRN	?g_bPowerGrid@@3_NA:BYTE			; g_bPowerGrid
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4ca4cb80
CONST	SEGMENT
__real@4ca4cb80 DD 04ca4cb80r			; 8.64e+007
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z$0
__unwindtable$?ProduceSupplies@@YAHK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProduceSupplies@@YAHK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProduceSupplies@@YAHK@Z$1
__ehfuncinfo$?SupplyUnits@@YAHEK@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?SupplyUnits@@YAHEK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ProduceSupplies@@YAHK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ProduceSupplies@@YAHK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SupplyUnits@@YAHEK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SupplyUnits@@YAHEK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SupplyUnits@@YAHEK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SupplyUnits@@YAHEK@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SupplyUnits@@YAHEK@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?SupplyUnits@@YAHEK@Z$4
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\supply.cpp
_TEXT	SEGMENT
$T2 = -364						; size = 8
$T3 = -356						; size = 8
$T4 = -348						; size = 8
$T5 = -340						; size = 8
$T6 = -332						; size = 8
$T7 = -324						; size = 8
_objit$8 = -316						; size = 12
_myit$9 = -304						; size = 12
_myit$10 = -292						; size = 12
_objit$11 = -280					; size = 12
$T12 = -268						; size = 4
_dist$13 = -264						; size = 4
$T14 = -260						; size = 4
_sqnbonus$ = -256					; size = 4
tv1263 = -252						; size = 4
tv1265 = -248						; size = 4
tv494 = -244						; size = 4
tv480 = -240						; size = 4
_gots$ = -236						; size = 4
tv569 = -232						; size = 4
_gotf$ = -228						; size = 4
tv583 = -224						; size = 4
_s$ = -220						; size = 4
_repl_a_s$ = -216					; size = 4
_repl_sa$ = -212					; size = 4
_repl_v_s$ = -208					; size = 4
_repl_s$ = -204						; size = 4
_y$ = -200						; size = 2
_x$ = -196						; size = 2
_rneeded_v$ = -192					; size = 4
_fneeded$ = -188					; size = 4
_prob$ = -184						; size = 4
_a_v_nratio$ = -180					; size = 4
_sratio$ = -176						; size = 4
_sneeded$ = -172					; size = 4
_repl$ = -168						; size = 4
_fratio$ = -164						; size = 4
_rneeded_a$ = -160					; size = 4
_type$ = -156						; size = 4
_rneeded$ = -152					; size = 4
_supply$ = -148						; size = 4
_ox$15 = -144						; size = 2
_fuel$ = -140						; size = 4
_oy$16 = -136						; size = 2
_replacements$ = -132					; size = 4
_rratio$ = -128						; size = 4
_rratio_a$ = -124					; size = 4
_repl_v$ = -120						; size = 4
_repl_a$ = -116						; size = 4
_rratio_v$ = -112					; size = 4
_lambda$ = -108						; size = 4
_typeBonus$17 = -104					; size = 4
_o$ = -100						; size = 4
_unit$ = -96						; size = 4
_mis$ = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_who$ = 8						; size = 1
_deltaTime$ = 12					; size = 4
?SupplyUnits@@YAHEK@Z PROC				; SupplyUnits

; 310  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SupplyUnits@@YAHEK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 311  : 	Objective		o,s;
; 312  : 	Unit			unit;
; 313  : 	int				supply,fuel,replacements,gots,gotf,type;
; 314  : 	int				sneeded=0,fneeded=0,rneeded=0;

	mov	DWORD PTR _sneeded$[ebp], 0
	mov	DWORD PTR _fneeded$[ebp], 0
	mov	DWORD PTR _rneeded$[ebp], 0

; 315  : 	float			sratio,fratio,rratio;
; 316  : 	GridIndex		x,y;
; 317  : 	MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 318  : 	// A.S. begin additional variables 2001-12-09
; 319  : 	// A.S. We now distinguish between aircrafts and ground vehicles 
; 320  : 	int				rneeded_a=0, rneeded_v=0, repl_a=0, repl_v=0;	

	mov	DWORD PTR _rneeded_a$[ebp], 0
	mov	DWORD PTR _rneeded_v$[ebp], 0
	mov	DWORD PTR _repl_a$[ebp], 0
	mov	DWORD PTR _repl_v$[ebp], 0

; 321  : 	float			rratio_a, rratio_v,	a_v_nratio, repl; 			// A.S. 
; 322  : 	float			sqnbonus, lambda;								// A.S. 
; 323  : 	int				repl_a_s = 0, repl_v_s = 0, repl_s = 0, repl_sa = 0, prob = 0;	// A.S. debug variables

	mov	DWORD PTR _repl_a_s$[ebp], 0
	mov	DWORD PTR _repl_v_s$[ebp], 0
	mov	DWORD PTR _repl_s$[ebp], 0
	mov	DWORD PTR _repl_sa$[ebp], 0
	mov	DWORD PTR _prob$[ebp], 0

; 324  : 	// end added section
; 325  : 
; 326  : 	if (!TeamInfo[who] || !(TeamInfo[who]->flags & TEAM_ACTIVE))

	movzx	eax, BYTE PTR _who$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN65@SupplyUnit
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movsx	eax, WORD PTR [edx+350]
	and	eax, 1
	jne	SHORT $LN66@SupplyUnit
$LN65@SupplyUnit:

; 327  : 		return 0;

	mov	DWORD PTR $T12[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T12[ebp]
	jmp	$LN67@SupplyUnit
$LN66@SupplyUnit:

; 328  : 
; 329  : 	sratio = fratio = rratio = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rratio$[ebp], xmm0
	movss	xmm0, DWORD PTR _rratio$[ebp]
	movss	DWORD PTR _fratio$[ebp], xmm0
	movss	xmm0, DWORD PTR _fratio$[ebp]
	movss	DWORD PTR _sratio$[ebp], xmm0

; 330  : 
; 331  : 	// A.S. begin, 2001-12-09.
; 332  : 	rratio_a = rratio_v = a_v_nratio = repl = lambda = 0.0F;		// A.S.

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _lambda$[ebp], xmm0
	movss	xmm0, DWORD PTR _lambda$[ebp]
	movss	DWORD PTR _repl$[ebp], xmm0
	movss	xmm0, DWORD PTR _repl$[ebp]
	movss	DWORD PTR _a_v_nratio$[ebp], xmm0
	movss	xmm0, DWORD PTR _a_v_nratio$[ebp]
	movss	DWORD PTR _rratio_v$[ebp], xmm0
	movss	xmm0, DWORD PTR _rratio_v$[ebp]
	movss	DWORD PTR _rratio_a$[ebp], xmm0

; 333  : 	sqnbonus = RelSquadBonus;									    // A.S. gives Sqn relative (!) more repl. than Bde.

	movss	xmm0, DWORD PTR ?RelSquadBonus@@3MA
	movss	DWORD PTR _sqnbonus$[ebp], xmm0

; 334  : 	// end added section
; 335  : 
; 336  : 	// zero supply values
; 337  : 	{
; 338  : 		VuListIterator objit(AllObjList);

	mov	ecx, DWORD PTR ?AllObjList@@3PAVVuLinkedList@@A ; AllObjList
	push	ecx
	lea	ecx, DWORD PTR _objit$11[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 339  : 		o = GetFirstObjective(&objit);

	lea	edx, DWORD PTR _objit$11[ebp]
	push	edx
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax
$LN64@SupplyUnit:

; 340  : 		while (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN63@SupplyUnit

; 341  : 			if (o->GetTeam() == who)

	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN62@SupplyUnit

; 342  : 				o->static_data.local_data = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _o$[ebp]
	mov	WORD PTR [ecx+214], ax
$LN62@SupplyUnit:

; 343  : 			o = GetNextObjective(&objit);

	lea	edx, DWORD PTR _objit$11[ebp]
	push	edx
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax

; 344  : 		}

	jmp	SHORT $LN64@SupplyUnit
$LN63@SupplyUnit:

; 345  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _objit$11[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 346  : 
; 347  : 	// Calculate needs
; 348  : 	{
; 349  : 		VuListIterator myit(AllUnitList);

	mov	eax, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	eax
	lea	ecx, DWORD PTR _myit$9[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 350  : 		unit = GetFirstUnit(&myit);

	lea	ecx, DWORD PTR _myit$9[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _unit$[ebp], eax
$LN61@SupplyUnit:

; 351  : 		while (unit)

	cmp	DWORD PTR _unit$[ebp], 0
	je	$LN60@SupplyUnit

; 352  : 		{
; 353  : 			if (unit->GetTeam() == who && (unit->IsBattalion() || unit->IsSquadron()))

	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	movzx	ecx, BYTE PTR _who$[ebp]
	cmp	eax, ecx
	jne	$LN57@SupplyUnit
	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	jne	SHORT $LN58@SupplyUnit
	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	$LN57@SupplyUnit
$LN58@SupplyUnit:

; 354  : 			{
; 355  : 				sneeded += unit->GetUnitSupplyNeed(FALSE);

	push	0
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+536]
	call	eax
	add	eax, DWORD PTR _sneeded$[ebp]
	mov	DWORD PTR _sneeded$[ebp], eax

; 356  : 				fneeded += unit->GetUnitFuelNeed(FALSE);

	push	0
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	add	eax, DWORD PTR _fneeded$[ebp]
	mov	DWORD PTR _fneeded$[ebp], eax

; 357  : 				rneeded += unit->GetFullstrengthVehicles() - unit->GetTotalVehicles();

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	add	esi, DWORD PTR _rneeded$[ebp]
	mov	DWORD PTR _rneeded$[ebp], esi

; 358  : 				// A.S. begin
; 359  : 				if (unit->IsSquadron() && NoTypeBonusRepl)		// A.S. extra calculation for squadrons 

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	SHORT $LN57@SupplyUnit
	cmp	DWORD PTR ?NoTypeBonusRepl@@3HA, 0	; NoTypeBonusRepl
	je	SHORT $LN57@SupplyUnit

; 360  : 				{
; 361  : 					rneeded_a += unit->GetFullstrengthVehicles() - unit->GetTotalVehicles(); 

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	add	esi, DWORD PTR _rneeded_a$[ebp]
	mov	DWORD PTR _rneeded_a$[ebp], esi
$LN57@SupplyUnit:

; 362  : 				}														
; 363  : 
; 364  : 				// end added section
; 365  : 			}
; 366  : 			unit = GetNextUnit(&myit);

	lea	ecx, DWORD PTR _myit$9[ebp]
	push	ecx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _unit$[ebp], eax

; 367  : 		}

	jmp	$LN61@SupplyUnit
$LN60@SupplyUnit:

; 368  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _myit$9[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 369  : 
; 370  : 
; 371  : 	// A.S. begin, 2001-12-09.
; 372  : 	if (NoTypeBonusRepl) { 

	cmp	DWORD PTR ?NoTypeBonusRepl@@3HA, 0	; NoTypeBonusRepl
	je	$LN53@SupplyUnit

; 373  : 		rneeded_v = rneeded - rneeded_a;						//A.S. calculation for groud vehicles

	mov	edx, DWORD PTR _rneeded$[ebp]
	sub	edx, DWORD PTR _rneeded_a$[ebp]
	mov	DWORD PTR _rneeded_v$[ebp], edx

; 374  : 		if (rneeded > 0)

	cmp	DWORD PTR _rneeded$[ebp], 0
	jle	SHORT $LN55@SupplyUnit

; 375  : 			a_v_nratio = ( (float)rneeded_a ) / rneeded;

	cvtsi2ss xmm0, DWORD PTR _rneeded_a$[ebp]
	cvtsi2ss xmm1, DWORD PTR _rneeded$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _a_v_nratio$[ebp], xmm0

; 376  : 		else

	jmp	SHORT $LN54@SupplyUnit
$LN55@SupplyUnit:

; 377  : 			a_v_nratio = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _a_v_nratio$[ebp], xmm0
$LN54@SupplyUnit:

; 378  : 		repl = (float)TeamInfo[who]->GetReplacementsAvail();    // aggregate replacements available

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	ecx, ax
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _repl$[ebp], xmm0

; 379  : 		lambda =  a_v_nratio * sqnbonus;

	movss	xmm0, DWORD PTR _a_v_nratio$[ebp]
	mulss	xmm0, DWORD PTR _sqnbonus$[ebp]
	movss	DWORD PTR _lambda$[ebp], xmm0

; 380  : 		if (lambda > 1)

	movss	xmm0, DWORD PTR _lambda$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN53@SupplyUnit

; 381  : 			lambda = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lambda$[ebp], xmm0
$LN53@SupplyUnit:

; 382  : 	}
; 383  : 	// end added section
; 384  : 	
; 385  : 
; 386  : 	// Calculate the maximum ratio of supply we can give out
; 387  : 	if (sneeded > 0)

	cmp	DWORD PTR _sneeded$[ebp], 0
	jle	SHORT $LN52@SupplyUnit

; 388  : 		sratio = (float)TeamInfo[who]->GetSupplyAvail() / sneeded;

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetSupplyAvail@TeamClass@@QAEGXZ	; TeamClass::GetSupplyAvail
	movzx	eax, ax
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _sneeded$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _sratio$[ebp], xmm0
$LN52@SupplyUnit:

; 389  : 	if (sratio > MAX_SUPPLY_RATIO)

	movss	xmm0, DWORD PTR _sratio$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN51@SupplyUnit

; 390  : 		sratio = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _sratio$[ebp], xmm0
$LN51@SupplyUnit:

; 391  : 	if (fneeded > 0)

	cmp	DWORD PTR _fneeded$[ebp], 0
	jle	SHORT $LN50@SupplyUnit

; 392  : 		fratio = (float)TeamInfo[who]->GetFuelAvail() / fneeded;

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetFuelAvail@TeamClass@@QAEGXZ		; TeamClass::GetFuelAvail
	movzx	edx, ax
	cvtsi2ss xmm0, edx
	cvtsi2ss xmm1, DWORD PTR _fneeded$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fratio$[ebp], xmm0
$LN50@SupplyUnit:

; 393  : 	if (fratio > MAX_SUPPLY_RATIO)

	movss	xmm0, DWORD PTR _fratio$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN49@SupplyUnit

; 394  : 		fratio = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _fratio$[ebp], xmm0
$LN49@SupplyUnit:

; 395  : 	if (rneeded > 0)

	cmp	DWORD PTR _rneeded$[ebp], 0
	jle	SHORT $LN48@SupplyUnit

; 396  : 		rratio = (float)TeamInfo[who]->GetReplacementsAvail() / rneeded;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	ecx, ax
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _rneeded$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _rratio$[ebp], xmm0
$LN48@SupplyUnit:

; 397  : 
; 398  : 	if (!NoTypeBonusRepl) // A.S. added if-condiion 2001-12-09 

	cmp	DWORD PTR ?NoTypeBonusRepl@@3HA, 0	; NoTypeBonusRepl
	jne	SHORT $LN46@SupplyUnit

; 399  : 	{
; 400  : 		if (rratio > 0.25F)	

	movss	xmm0, DWORD PTR _rratio$[ebp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	SHORT $LN46@SupplyUnit

; 401  : 			rratio = 0.25F;		

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _rratio$[ebp], xmm0
$LN46@SupplyUnit:

; 402  : 	}
; 403  : 
; 404  : 	// A.S. begin, 2001-12-09
; 405  : 	if  (NoTypeBonusRepl) 

	cmp	DWORD PTR ?NoTypeBonusRepl@@3HA, 0	; NoTypeBonusRepl
	je	$LN37@SupplyUnit

; 406  : 	{ 
; 407  : 		if (rratio > MAX_SUPPLY_RATIO) {		

	movss	xmm0, DWORD PTR _rratio$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN44@SupplyUnit

; 408  : 			rratio = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _rratio$[ebp], xmm0
$LN44@SupplyUnit:

; 409  : 		}
; 410  : 		if (rneeded_a > 0)

	cmp	DWORD PTR _rneeded_a$[ebp], 0
	jle	SHORT $LN43@SupplyUnit

; 411  : 			rratio_a = repl / rneeded_a;			

	cvtsi2ss xmm0, DWORD PTR _rneeded_a$[ebp]
	movss	xmm1, DWORD PTR _repl$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _rratio_a$[ebp], xmm1

; 412  : 		else

	jmp	SHORT $LN42@SupplyUnit
$LN43@SupplyUnit:

; 413  : 			rratio_a = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _rratio_a$[ebp], xmm0
$LN42@SupplyUnit:

; 414  : 		if (rneeded_v > 0)

	cmp	DWORD PTR _rneeded_v$[ebp], 0
	jle	SHORT $LN41@SupplyUnit

; 415  : 			rratio_v = repl / rneeded_v;

	cvtsi2ss xmm0, DWORD PTR _rneeded_v$[ebp]
	movss	xmm1, DWORD PTR _repl$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _rratio_v$[ebp], xmm1

; 416  : 		else

	jmp	SHORT $LN40@SupplyUnit
$LN41@SupplyUnit:

; 417  : 			rratio_v = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _rratio_v$[ebp], xmm0
$LN40@SupplyUnit:

; 418  : 		
; 419  : 		if (rratio_a > MAX_SUPPLY_RATIO)

	movss	xmm0, DWORD PTR _rratio_a$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN39@SupplyUnit

; 420  : 			rratio_a = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _rratio_a$[ebp], xmm0
$LN39@SupplyUnit:

; 421  : 		if (rratio_v > MAX_SUPPLY_RATIO)

	movss	xmm0, DWORD PTR _rratio_v$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN38@SupplyUnit

; 422  : 			rratio_v = MAX_SUPPLY_RATIO;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _rratio_v$[ebp], xmm0
$LN38@SupplyUnit:

; 423  : 		if (repl == 0) {							// to handle situations like 0/0 !

	movss	xmm0, DWORD PTR _repl$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN37@SupplyUnit

; 424  : 			rratio_a = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rratio_a$[ebp], xmm0

; 425  : 			rratio_v = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rratio_v$[ebp], xmm0
$LN37@SupplyUnit:

; 426  : 		}
; 427  : 	}
; 428  : 	// end added section
; 429  : 
; 430  : 
; 431  : 	// Supply units
; 432  : 	{
; 433  : 		VuListIterator myit(AllUnitList);

	mov	edx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	edx
	lea	ecx, DWORD PTR _myit$10[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 434  : 		unit = GetFirstUnit(&myit);

	lea	eax, DWORD PTR _myit$10[ebp]
	push	eax
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _unit$[ebp], eax
$LN36@SupplyUnit:

; 435  : 		while (unit)

	cmp	DWORD PTR _unit$[ebp], 0
	je	$LN35@SupplyUnit

; 436  : 		{
; 437  : 			// We only supply/repair Battalions and Squadrons
; 438  : 			if (
; 439  : 				unit->GetTeam() == who && (unit->IsBattalion() || unit->IsSquadron()) &&
; 440  : 				TheCampaign.CurrentTime - unit->GetLastResupplyTime() > unit->GetUnitSupplyTime()
; 441  : 			){

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	jne	$LN34@SupplyUnit
	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN33@SupplyUnit
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	$LN34@SupplyUnit
$LN33@SupplyUnit:
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+792]
	call	eax
	mov	esi, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetUnitSupplyTime@UnitClass@@QAEKXZ	; UnitClass::GetUnitSupplyTime
	cmp	esi, eax
	jbe	$LN34@SupplyUnit

; 442  : 				float			typeBonus = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _typeBonus$17[ebp], xmm0

; 443  : 
; 444  : 				if (unit->GetUnitCurrentRole() == GRO_ATTACK)

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN32@SupplyUnit

; 445  : 					typeBonus = 6.0F;

	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR _typeBonus$17[ebp], xmm0
$LN32@SupplyUnit:

; 446  : 				if (unit->IsSquadron())

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	SHORT $LN31@SupplyUnit

; 447  : 				{
; 448  : 					((SquadronClass*)unit)->ReinforcePilots(2);

	push	2
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?ReinforcePilots@SquadronClass@@QAEXH@Z	; SquadronClass::ReinforcePilots

; 449  : 					typeBonus = 2.0F;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _typeBonus$17[ebp], xmm0
$LN31@SupplyUnit:

; 450  : 				}
; 451  : 				// Add some randomness
; 452  : 				typeBonus += ((rand()%50)-25.0F)/100.0F;

	call	_rand
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	cvtsi2ss xmm0, edx
	subss	xmm0, DWORD PTR __real@41c80000
	divss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, DWORD PTR _typeBonus$17[ebp]
	movss	DWORD PTR _typeBonus$17[ebp], xmm0

; 453  : 				if (typeBonus < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _typeBonus$17[ebp]
	jbe	SHORT $LN30@SupplyUnit

; 454  : 					typeBonus = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _typeBonus$17[ebp], xmm0
$LN30@SupplyUnit:

; 455  : 
; 456  : 				supply = FloatToInt32(unit->GetUnitSupplyNeed(FALSE) * sratio * typeBonus);

	push	0
	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax+536]
	call	edx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _sratio$[ebp]
	mulss	xmm0, DWORD PTR _typeBonus$17[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _supply$[ebp], eax

; 457  : 				fuel = FloatToInt32(unit->GetUnitFuelNeed(FALSE) * fratio * typeBonus);

	push	0
	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _fratio$[ebp]
	mulss	xmm0, DWORD PTR _typeBonus$17[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _fuel$[ebp], eax

; 458  : 
; 459  : 				// A.S.  2001-12-09. No Type Bonus for replacements. This helps fixing the bug that units can get more replacements than available.
; 460  : 				if (NoTypeBonusRepl)

	cmp	DWORD PTR ?NoTypeBonusRepl@@3HA, 0	; NoTypeBonusRepl
	je	SHORT $LN29@SupplyUnit

; 461  : 					typeBonus = 1.0F;		

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _typeBonus$17[ebp], xmm0
$LN29@SupplyUnit:

; 462  : 				// end added section
; 463  : 				
; 464  : 				replacements = FloatToInt32((unit->GetFullstrengthVehicles() - unit->GetTotalVehicles()) * rratio * typeBonus);

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	cvtsi2ss xmm0, esi
	mulss	xmm0, DWORD PTR _rratio$[ebp]
	mulss	xmm0, DWORD PTR _typeBonus$17[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _replacements$[ebp], eax

; 465  : 
; 466  : 				// A.S. begin, 2001-12-09
; 467  : 				repl_s += replacements;				// debug

	mov	ecx, DWORD PTR _repl_s$[ebp]
	add	ecx, DWORD PTR _replacements$[ebp]
	mov	DWORD PTR _repl_s$[ebp], ecx

; 468  : 				if (NoTypeBonusRepl) 	// New code for distinguishing between aircrafts and ground vehicles 

	cmp	DWORD PTR ?NoTypeBonusRepl@@3HA, 0	; NoTypeBonusRepl
	je	$LN28@SupplyUnit

; 469  : 				{
; 470  : 					if (unit->IsSquadron())				// this algorithm guarantees that no team can get more repl than available

	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx
	test	eax, eax
	je	$LN27@SupplyUnit

; 471  : 					{
; 472  : 						prob = rand() % 100;

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _prob$[ebp], edx

; 473  : 						repl_a = FloatToInt32((unit->GetFullstrengthVehicles() - unit->GetTotalVehicles()) * (lambda) * rratio_a);

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	cvtsi2ss xmm0, esi
	mulss	xmm0, DWORD PTR _lambda$[ebp]
	mulss	xmm0, DWORD PTR _rratio_a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _repl_a$[ebp], eax

; 474  : 						if ( TeamInfo[who]->GetReplacementsAvail() >= 1  && prob < 51  &&  ( ((float)unit->GetTotalVehicles())/unit->GetFullstrengthVehicles() <= 0.8F)) // rounding up with probability 0.5

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	eax, ax
	cmp	eax, 1
	jl	SHORT $LN26@SupplyUnit
	cmp	DWORD PTR _prob$[ebp], 51		; 00000033H
	jge	SHORT $LN26@SupplyUnit
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	movss	DWORD PTR tv1263[ebp], xmm0
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv1263[ebp]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, xmm1
	jb	SHORT $LN26@SupplyUnit

; 475  : 							repl_a = FloatToInt32( (float) ceil( (unit->GetFullstrengthVehicles() - unit->GetTotalVehicles()) * (lambda) * rratio_a) );

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	cvtsi2ss xmm0, esi
	mulss	xmm0, DWORD PTR _lambda$[ebp]
	mulss	xmm0, DWORD PTR _rratio_a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ceil@@YAMM@Z				; ceil
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _repl_a$[ebp], eax
$LN26@SupplyUnit:

; 476  : 						if (repl_a > 0) 

	cmp	DWORD PTR _repl_a$[ebp], 0
	jle	$LN25@SupplyUnit

; 477  : 						{
; 478  : 							TeamInfo[who]->SetReplacementsAvail( TeamInfo[who]->GetReplacementsAvail() - repl_a );

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	sub	edx, DWORD PTR _repl_a$[ebp]
	push	edx
	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail

; 479  : 							unit->ChangeVehicles( min(repl_a, TeamInfo[who]->GetReplacementsAvail()) );

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	cmp	DWORD PTR _repl_a$[ebp], edx
	jge	SHORT $LN69@SupplyUnit
	mov	eax, DWORD PTR _repl_a$[ebp]
	mov	DWORD PTR tv480[ebp], eax
	jmp	SHORT $LN70@SupplyUnit
$LN69@SupplyUnit:
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	mov	DWORD PTR tv480[ebp], edx
$LN70@SupplyUnit:
	mov	eax, DWORD PTR tv480[ebp]
	push	eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?ChangeVehicles@UnitClass@@QAEHH@Z	; UnitClass::ChangeVehicles

; 480  : 							repl_a_s += min(repl_a, TeamInfo[who]->GetReplacementsAvail()); // debug

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	cmp	DWORD PTR _repl_a$[ebp], edx
	jge	SHORT $LN71@SupplyUnit
	mov	eax, DWORD PTR _repl_a$[ebp]
	mov	DWORD PTR tv494[ebp], eax
	jmp	SHORT $LN72@SupplyUnit
$LN71@SupplyUnit:
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	mov	DWORD PTR tv494[ebp], edx
$LN72@SupplyUnit:
	mov	eax, DWORD PTR _repl_a_s$[ebp]
	add	eax, DWORD PTR tv494[ebp]
	mov	DWORD PTR _repl_a_s$[ebp], eax
$LN25@SupplyUnit:

; 481  : 						}
; 482  : 					}	
; 483  : 					else {

	jmp	$LN22@SupplyUnit
$LN27@SupplyUnit:

; 484  : 						prob = rand() % 100;

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _prob$[ebp], edx

; 485  : 						repl_v = FloatToInt32((unit->GetFullstrengthVehicles() - unit->GetTotalVehicles()) * (1 - lambda) * rratio_v);

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	cvtsi2ss xmm0, esi
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _lambda$[ebp]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _rratio_v$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _repl_v$[ebp], eax

; 486  : 						if ( TeamInfo[who]->GetReplacementsAvail() > 12  && prob < 51  &&  ( ((float)unit->GetTotalVehicles())/unit->GetFullstrengthVehicles() <= 0.85F)) // rounding up

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	eax, ax
	cmp	eax, 12					; 0000000cH
	jle	$LN23@SupplyUnit
	cmp	DWORD PTR _prob$[ebp], 51		; 00000033H
	jge	$LN23@SupplyUnit
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	movss	DWORD PTR tv1265[ebp], xmm0
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv1265[ebp]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f59999a
	comiss	xmm0, xmm1
	jb	SHORT $LN23@SupplyUnit

; 487  : 							repl_v = FloatToInt32( (float) ceil( (unit->GetFullstrengthVehicles() - unit->GetTotalVehicles()) * (1 - lambda) * rratio_v) );

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	sub	esi, eax
	cvtsi2ss xmm0, esi
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _lambda$[ebp]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _rratio_v$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ceil@@YAMM@Z				; ceil
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _repl_v$[ebp], eax
$LN23@SupplyUnit:

; 488  : 						if (repl_v > 0) 

	cmp	DWORD PTR _repl_v$[ebp], 0
	jle	$LN22@SupplyUnit

; 489  : 						{
; 490  : 							TeamInfo[who]->SetReplacementsAvail(TeamInfo[who]->GetReplacementsAvail() - repl_v);

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	sub	edx, DWORD PTR _repl_v$[ebp]
	push	edx
	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail

; 491  : 							unit->ChangeVehicles( min(repl_v, TeamInfo[who]->GetReplacementsAvail()) );

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	cmp	DWORD PTR _repl_v$[ebp], edx
	jge	SHORT $LN73@SupplyUnit
	mov	eax, DWORD PTR _repl_v$[ebp]
	mov	DWORD PTR tv569[ebp], eax
	jmp	SHORT $LN74@SupplyUnit
$LN73@SupplyUnit:
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	mov	DWORD PTR tv569[ebp], edx
$LN74@SupplyUnit:
	mov	eax, DWORD PTR tv569[ebp]
	push	eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?ChangeVehicles@UnitClass@@QAEHH@Z	; UnitClass::ChangeVehicles

; 492  : 							repl_v_s += min(repl_v, TeamInfo[who]->GetReplacementsAvail()); // debug

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	cmp	DWORD PTR _repl_v$[ebp], edx
	jge	SHORT $LN75@SupplyUnit
	mov	eax, DWORD PTR _repl_v$[ebp]
	mov	DWORD PTR tv583[ebp], eax
	jmp	SHORT $LN76@SupplyUnit
$LN75@SupplyUnit:
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	mov	DWORD PTR tv583[ebp], edx
$LN76@SupplyUnit:
	mov	eax, DWORD PTR _repl_v_s$[ebp]
	add	eax, DWORD PTR tv583[ebp]
	mov	DWORD PTR _repl_v_s$[ebp], eax
$LN22@SupplyUnit:

; 493  : 						}
; 494  : 					}
; 495  : 					// prob = rand() % 100;
; 496  : 				}
; 497  : 				else 

	jmp	$LN20@SupplyUnit
$LN28@SupplyUnit:

; 498  : 				{							
; 499  : 					if (replacements)	// ++++++ old code begin ++++++

	cmp	DWORD PTR _replacements$[ebp], 0
	je	$LN20@SupplyUnit

; 500  : 					{
; 501  : 					TeamInfo[who]->SetReplacementsAvail(TeamInfo[who]->GetReplacementsAvail() - replacements);

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	edx, ax
	sub	edx, DWORD PTR _replacements$[ebp]
	push	edx
	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail

; 502  : 					if (unit->IsSquadron())

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	SHORT $LN19@SupplyUnit

; 503  : 						{
; 504  : 						repl_sa += replacements; // A.S. debug

	mov	ecx, DWORD PTR _repl_sa$[ebp]
	add	ecx, DWORD PTR _replacements$[ebp]
	mov	DWORD PTR _repl_sa$[ebp], ecx

; 505  : 						TeamInfo[who]->SetReplacementsAvail(TeamInfo[who]->GetReplacementsAvail() - replacements);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	eax, ax
	sub	eax, DWORD PTR _replacements$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail

; 506  : 						unit->SetLastResupply(replacements);

	mov	edx, DWORD PTR _replacements$[ebp]
	push	edx
	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+764]
	call	eax
$LN19@SupplyUnit:

; 507  : 						}
; 508  : 					unit->ChangeVehicles(replacements);

	mov	ecx, DWORD PTR _replacements$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?ChangeVehicles@UnitClass@@QAEHH@Z	; UnitClass::ChangeVehicles
$LN20@SupplyUnit:

; 509  : 					}
; 510  : 				}	// end added section  (important: this section replaces(!) the section marked with ++++++ old code ++++++ !)
; 511  : 				
; 512  : 				if (fuel || supply)

	cmp	DWORD PTR _fuel$[ebp], 0
	jne	SHORT $LN17@SupplyUnit
	cmp	DWORD PTR _supply$[ebp], 0
	je	$LN14@SupplyUnit
$LN17@SupplyUnit:

; 513  : 				{
; 514  : 					unit->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 515  : 					o = FindNearestFriendlyObjective(who, &x, &y, 0);

	push	0
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	movzx	eax, BYTE PTR _who$[ebp]
	push	eax
	call	?FindNearestFriendlyObjective@@YAPAVObjectiveClass@@EPAF0H@Z ; FindNearestFriendlyObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$[ebp], eax

; 516  : 					if (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN14@SupplyUnit

; 517  : 					{
; 518  : 						s = FindNearestSupplySource(o);

	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	call	?FindNearestSupplySource@@YAPAVObjectiveClass@@PAV1@@Z ; FindNearestSupplySource
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 519  : 						if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN14@SupplyUnit

; 520  : 						{
; 521  : 							TeamInfo[who]->SetSupplyAvail(TeamInfo[who]->GetSupplyAvail() - supply);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetSupplyAvail@TeamClass@@QAEGXZ	; TeamClass::GetSupplyAvail
	movzx	eax, ax
	sub	eax, DWORD PTR _supply$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetSupplyAvail@TeamClass@@QAEXH@Z	; TeamClass::SetSupplyAvail

; 522  : 							TeamInfo[who]->SetFuelAvail(TeamInfo[who]->GetFuelAvail() - fuel);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetFuelAvail@TeamClass@@QAEGXZ		; TeamClass::GetFuelAvail
	movzx	eax, ax
	sub	eax, DWORD PTR _fuel$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetFuelAvail@TeamClass@@QAEXH@Z	; TeamClass::SetFuelAvail

; 523  : 							gots = supply;

	mov	edx, DWORD PTR _supply$[ebp]
	mov	DWORD PTR _gots$[ebp], edx

; 524  : 							gotf = fuel;

	mov	eax, DWORD PTR _fuel$[ebp]
	mov	DWORD PTR _gotf$[ebp], eax

; 525  : 							if (SendSupply(s,o,&gots,&gotf))

	lea	ecx, DWORD PTR _gotf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gots$[ebp]
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z ; SendSupply
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN14@SupplyUnit

; 526  : 								SupplyUnit(unit,supply,gots,fuel,gotf);

	mov	edx, DWORD PTR _gotf$[ebp]
	push	edx
	mov	eax, DWORD PTR _fuel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gots$[ebp]
	push	ecx
	mov	edx, DWORD PTR _supply$[ebp]
	push	edx
	mov	eax, DWORD PTR _unit$[ebp]
	push	eax
	call	?SupplyUnit@@YAXPAVUnitClass@@HHHH@Z	; SupplyUnit
	add	esp, 20					; 00000014H
$LN14@SupplyUnit:

; 527  : 						}
; 528  : 					}
; 529  : 				}
; 530  : 				unit->SetLastResupplyTime(TheCampaign.CurrentTime);

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	ecx
	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax+768]
	call	edx
$LN34@SupplyUnit:

; 531  : 			}
; 532  : 			unit = GetNextUnit(&myit);

	lea	eax, DWORD PTR _myit$10[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _unit$[ebp], eax

; 533  : 		}

	jmp	$LN36@SupplyUnit
$LN35@SupplyUnit:

; 534  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _myit$10[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 535  : 
; 536  : 	// A.S. debug begin
; 537  : 	//if (NoTypeBonusRepl) {
; 538  : 	//	if (who == 2 || who==6) {	
; 539  : 	//		FILE *deb;
; 540  : 	//		deb = fopen("c:\\temp\\deb1.txt", "a");
; 541  : 	//		fprintf(deb, "Team %2d  ReplaAvail = %3d  A_Needed = %3d  V_Needed %4d  Aircraft = %2d  Vehicle = %3d  TIME = %d\n", who, (int)repl, rneeded_a, rneeded_v, repl_a_s, repl_v_s, TheCampaign.CurrentTime );   
; 542  : 	//		fclose(deb);
; 543  : 	//	}
; 544  : 	//}
; 545  : 	//else {
; 546  : 	//	if (who == 2 || who==6) {	// A.S. debug
; 547  : 	//		FILE *deb;
; 548  : 	//		deb = fopen("c:\\temp\\deb1.txt", "a");
; 549  : 	//		fprintf(deb, "Team %2d  ReplaAvail = %3d  Needed = %3d | Repl_a = %2d repl_v = %3d | TIME = %d\n", who, TeamInfo[who]->GetReplacementsAvail(), rneeded, repl_sa, (repl_s-repl_sa) , TheCampaign.CurrentTime % CampaignHours );   
; 550  : 	//		fclose(deb);
; 551  : 	//	}
; 552  : 	//}
; 553  : 	// A.S. debug end
; 554  : 
; 555  : 	// Reset loss values, set supply values, and request missions
; 556  : 	{
; 557  : 		VuListIterator objit(AllObjList);

	mov	ecx, DWORD PTR ?AllObjList@@3PAVVuLinkedList@@A ; AllObjList
	push	ecx
	lea	ecx, DWORD PTR _objit$8[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 558  : 		o = GetFirstObjective(&objit);

	lea	edx, DWORD PTR _objit$8[ebp]
	push	edx
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax
$LN13@SupplyUnit:

; 559  : 		while (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN12@SupplyUnit

; 560  : 			if (o->GetTeam() == who){

	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	jne	$LN1@SupplyUnit

; 561  : 				supply = LOBYTE(o->static_data.local_data);

	mov	eax, DWORD PTR _o$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	mov	DWORD PTR _supply$[ebp], edx

; 562  : 				fuel = HIBYTE(o->static_data.local_data);

	mov	eax, DWORD PTR _o$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	mov	DWORD PTR _fuel$[ebp], edx

; 563  : 				if (supply > 5 || fuel > 5){

	cmp	DWORD PTR _supply$[ebp], 5
	jg	SHORT $LN9@SupplyUnit
	cmp	DWORD PTR _fuel$[ebp], 5
	jle	$LN1@SupplyUnit
$LN9@SupplyUnit:

; 564  : 					o->SendObjMessage(o->Id(),FalconObjectiveMessage::objSetSupply,(short)(supply),(short)(fuel),0);

	push	0
	movzx	eax, WORD PTR _fuel$[ebp]
	push	eax
	movzx	ecx, WORD PTR _supply$[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?SendObjMessage@ObjectiveClass@@QAEXVVU_ID@@FFFF@Z ; ObjectiveClass::SendObjMessage

; 565  : 					type = o->GetType();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	eax, al
	mov	DWORD PTR _type$[ebp], eax

; 566  : 					if (type == TYPE_ROAD || type == TYPE_INTERSECT)

	cmp	DWORD PTR _type$[ebp], 26		; 0000001aH
	je	SHORT $LN7@SupplyUnit
	cmp	DWORD PTR _type$[ebp], 15		; 0000000fH
	jne	$LN8@SupplyUnit
$LN7@SupplyUnit:

; 567  : 					{
; 568  : 						// Request an interdiction mission
; 569  : 						mis.requesterID = o->Id();

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], edx
	mov	DWORD PTR _mis$[ebp+4], eax

; 570  : 						o->GetLocation(&mis.tx,&mis.ty);

	lea	ecx, DWORD PTR _mis$[ebp+42]
	push	ecx
	lea	edx, DWORD PTR _mis$[ebp+40]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 571  : 						mis.vs = o->GetTeam();

	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$[ebp+33], al

; 572  : 						mis.who = GetEnemyTeam(mis.vs);

	movzx	ecx, BYTE PTR _mis$[ebp+33]
	push	ecx
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 573  : 						mis.tot = Camp_GetCurrentTime() + (30+rand()%480)*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	cdq
	mov	ecx, 480				; 000001e0H
	idiv	ecx
	add	edx, 30					; 0000001eH
	imul	edx, 60000				; 0000ea60H
	add	esi, edx
	mov	DWORD PTR _mis$[ebp+36], esi

; 574  : 						mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 575  : 						mis.targetID = FalconNullId;

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _mis$[ebp+8], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _mis$[ebp+12], eax

; 576  : 						mis.mission = AMIS_INT;

	mov	BYTE PTR _mis$[ebp+60], 24		; 00000018H

; 577  : 						mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 578  : 						mis.context = enemySupplyInterdictionZone;

	mov	BYTE PTR _mis$[ebp+62], 33		; 00000021H

; 579  : 						mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission
$LN8@SupplyUnit:

; 580  : 					}
; 581  : 					// RV - Biker - Do something special for bridges
; 582  : 					//if (type == TYPE_BRIDGE || type == TYPE_DEPOT || type == TYPE_PORT)
; 583  : 					if (type == TYPE_DEPOT || type == TYPE_PORT)

	cmp	DWORD PTR _type$[ebp], 10		; 0000000aH
	je	SHORT $LN5@SupplyUnit
	cmp	DWORD PTR _type$[ebp], 19		; 00000013H
	jne	$LN6@SupplyUnit
$LN5@SupplyUnit:

; 584  : 					{
; 585  : 						// Request an interdiction strike mission
; 586  : 						mis.requesterID = o->Id();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], edx
	mov	DWORD PTR _mis$[ebp+4], eax

; 587  : 						o->GetLocation(&mis.tx,&mis.ty);

	lea	ecx, DWORD PTR _mis$[ebp+42]
	push	ecx
	lea	edx, DWORD PTR _mis$[ebp+40]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 588  : 						mis.vs = o->GetTeam();

	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$[ebp+33], al

; 589  : 						mis.who = GetEnemyTeam(mis.vs);

	movzx	ecx, BYTE PTR _mis$[ebp+33]
	push	ecx
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 590  : 						mis.tot = Camp_GetCurrentTime() + (30+rand()%480)*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	cdq
	mov	ecx, 480				; 000001e0H
	idiv	ecx
	add	edx, 30					; 0000001eH
	imul	edx, 60000				; 0000ea60H
	add	esi, edx
	mov	DWORD PTR _mis$[ebp+36], esi

; 591  : 						mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 592  : 						mis.targetID = o->Id();

	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 593  : 						mis.mission = AMIS_INTSTRIKE;

	mov	BYTE PTR _mis$[ebp+60], 14		; 0000000eH

; 594  : 						mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 595  : 
; 596  : 						if (type == TYPE_DEPOT)

	cmp	DWORD PTR _type$[ebp], 10		; 0000000aH
	jne	SHORT $LN4@SupplyUnit

; 597  : 								mis.context = enemySupplyInterdictionDepot;

	mov	BYTE PTR _mis$[ebp+62], 32		; 00000020H
$LN4@SupplyUnit:

; 598  : 						if (type == TYPE_PORT)

	cmp	DWORD PTR _type$[ebp], 19		; 00000013H
	jne	SHORT $LN3@SupplyUnit

; 599  : 								mis.context = enemySupplyInterdictionPort;

	mov	BYTE PTR _mis$[ebp+62], 31		; 0000001fH
$LN3@SupplyUnit:

; 600  : 						mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission
$LN6@SupplyUnit:

; 601  : 					}
; 602  : 					if (type == TYPE_BRIDGE) {

	cmp	DWORD PTR _type$[ebp], 6
	jne	$LN1@SupplyUnit

; 603  : 						// Check distance to FLOT
; 604  : 						GridIndex ox = 0, oy = 0;

	xor	eax, eax
	mov	WORD PTR _ox$15[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _oy$16[ebp], cx

; 605  : 						o->GetLocation(&ox, &oy);

	lea	edx, DWORD PTR _oy$16[ebp]
	push	edx
	lea	eax, DWORD PTR _ox$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 606  : 						float dist = DistanceToFront(ox,oy);

	movzx	ecx, WORD PTR _oy$16[ebp]
	push	ecx
	movzx	edx, WORD PTR _ox$15[ebp]
	push	edx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR _dist$13[ebp]

; 607  : 
; 608  : 						if (dist >= 50.0f) {

	movss	xmm0, DWORD PTR _dist$13[ebp]
	comiss	xmm0, DWORD PTR __real@42480000
	jb	$LN1@SupplyUnit

; 609  : 							mis.requesterID = o->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 610  : 							mis.tx = ox;

	mov	ax, WORD PTR _ox$15[ebp]
	mov	WORD PTR _mis$[ebp+40], ax

; 611  : 							mis.ty = oy;

	mov	cx, WORD PTR _oy$16[ebp]
	mov	WORD PTR _mis$[ebp+42], cx

; 612  : 							mis.vs = o->GetTeam();

	mov	edx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	mov	BYTE PTR _mis$[ebp+33], al

; 613  : 							mis.who = GetEnemyTeam(mis.vs);

	movzx	eax, BYTE PTR _mis$[ebp+33]
	push	eax
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 614  : 							mis.tot = Camp_GetCurrentTime() + (30+rand()%480)*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	cdq
	mov	ecx, 480				; 000001e0H
	idiv	ecx
	add	edx, 30					; 0000001eH
	imul	edx, 60000				; 0000ea60H
	add	esi, edx
	mov	DWORD PTR _mis$[ebp+36], esi

; 615  : 							mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 616  : 							mis.targetID = o->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 617  : 							mis.mission = AMIS_INTSTRIKE;

	mov	BYTE PTR _mis$[ebp+60], 14		; 0000000eH

; 618  : 							mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 619  : 							mis.context = enemySupplyInterdictionBridge;

	mov	BYTE PTR _mis$[ebp+62], 30		; 0000001eH

; 620  : 							mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission
$LN1@SupplyUnit:

; 621  : 						}
; 622  : 					}
; 623  : 				}
; 624  : 			}
; 625  : 			o = GetNextObjective(&objit);

	lea	eax, DWORD PTR _objit$8[ebp]
	push	eax
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax

; 626  : 		}

	jmp	$LN13@SupplyUnit
$LN12@SupplyUnit:

; 627  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _objit$8[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 628  : 	return 1;

	mov	DWORD PTR $T14[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T14[ebp]
$LN67@SupplyUnit:

; 629  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SupplyUnits@@YAHEK@Z$0:
	lea	ecx, DWORD PTR _mis$[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__unwindfunclet$?SupplyUnits@@YAHEK@Z$1:
	lea	ecx, DWORD PTR _objit$11[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?SupplyUnits@@YAHEK@Z$2:
	lea	ecx, DWORD PTR _myit$9[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?SupplyUnits@@YAHEK@Z$3:
	lea	ecx, DWORD PTR _myit$10[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?SupplyUnits@@YAHEK@Z$4:
	lea	ecx, DWORD PTR _objit$8[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?SupplyUnits@@YAHEK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SupplyUnits@@YAHEK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SupplyUnits@@YAHEK@Z ENDP				; SupplyUnits
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\supply.cpp
_TEXT	SEGMENT
_sratio$ = -12						; size = 4
_fratio$ = -8						; size = 4
_e$ = -4						; size = 4
_u$ = 8							; size = 4
_sneed$ = 12						; size = 4
_supply$ = 16						; size = 4
_fneed$ = 20						; size = 4
_fuel$ = 24						; size = 4
?SupplyUnit@@YAXPAVUnitClass@@HHHH@Z PROC		; SupplyUnit

; 273  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 274  : 	Unit		e;
; 275  : 	float		sratio,fratio;
; 276  : 	
; 277  : 	if (u->IsBattalion() || u->IsSquadron())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN10@SupplyUnit
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	SHORT $LN11@SupplyUnit
$LN10@SupplyUnit:

; 278  : 		{
; 279  : 		if (!supply && !fuel)

	cmp	DWORD PTR _supply$[ebp], 0
	jne	SHORT $LN9@SupplyUnit
	cmp	DWORD PTR _fuel$[ebp], 0
	jne	SHORT $LN9@SupplyUnit

; 280  : 			return;

	jmp	$LN12@SupplyUnit
$LN9@SupplyUnit:

; 281  : 		// KCK: We can add supply and fuel directly now, since we're asserting all
; 282  : 		// entities are local to the host. Values will be updated via dirty data
; 283  : 		u->SupplyUnit(supply,fuel);

	mov	ecx, DWORD PTR _fuel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _supply$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+544]
	call	eax
	jmp	$LN1@SupplyUnit
$LN11@SupplyUnit:

; 284  : //		// Send the supply message
; 285  : //		u->SendUnitMessage(u->Id(),FalconUnitMessage::unitSupply,supply,fuel,0);
; 286  : 		}
; 287  : 	else if (u->IsBrigade())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	call	eax
	test	eax, eax
	je	$LN1@SupplyUnit

; 288  : 		{
; 289  : 		if (sneed > 0)

	cmp	DWORD PTR _sneed$[ebp], 0
	jle	SHORT $LN6@SupplyUnit

; 290  : 			sratio = (float)supply/(float)sneed;

	cvtsi2ss xmm0, DWORD PTR _supply$[ebp]
	cvtsi2ss xmm1, DWORD PTR _sneed$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _sratio$[ebp], xmm0

; 291  : 		else

	jmp	SHORT $LN5@SupplyUnit
$LN6@SupplyUnit:

; 292  : 			sratio = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _sratio$[ebp], xmm0
$LN5@SupplyUnit:

; 293  : 		if (fneed > 0)

	cmp	DWORD PTR _fneed$[ebp], 0
	jle	SHORT $LN4@SupplyUnit

; 294  : 			fratio = (float)fuel/(float)fneed;

	cvtsi2ss xmm0, DWORD PTR _fuel$[ebp]
	cvtsi2ss xmm1, DWORD PTR _fneed$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fratio$[ebp], xmm0

; 295  : 		else 

	jmp	SHORT $LN3@SupplyUnit
$LN4@SupplyUnit:

; 296  : 			fratio = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fratio$[ebp], xmm0
$LN3@SupplyUnit:

; 297  : 		e = u->GetFirstUnitElement();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN2@SupplyUnit:

; 298  : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN1@SupplyUnit

; 299  : 			{
; 300  : 			sneed = e->GetUnitSupplyNeed(FALSE);

	push	0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+536]
	call	eax
	mov	DWORD PTR _sneed$[ebp], eax

; 301  : 			fneed = e->GetUnitFuelNeed(FALSE);

	push	0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	mov	DWORD PTR _fneed$[ebp], eax

; 302  : 			SupplyUnit(e,sneed,FloatToInt32(sneed*sratio),fneed,FloatToInt32(fneed*fratio));

	cvtsi2ss xmm0, DWORD PTR _fneed$[ebp]
	mulss	xmm0, DWORD PTR _fratio$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _fneed$[ebp]
	push	ecx
	cvtsi2ss xmm0, DWORD PTR _sneed$[ebp]
	mulss	xmm0, DWORD PTR _sratio$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _sneed$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?SupplyUnit@@YAXPAVUnitClass@@HHHH@Z	; SupplyUnit
	add	esp, 20					; 00000014H

; 303  : 			e = u->GetNextUnitElement();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 304  : 			}

	jmp	$LN2@SupplyUnit
$LN1@SupplyUnit:
$LN12@SupplyUnit:

; 305  : 		}
; 306  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SupplyUnit@@YAXPAVUnitClass@@HHHH@Z ENDP		; SupplyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\supply.cpp
_TEXT	SEGMENT
_loss$ = -116						; size = 4
$T2 = -112						; size = 4
$T3 = -108						; size = 4
_n$ = -104						; size = 4
$T4 = -100						; size = 4
$T5 = -96						; size = 4
_l$ = -92						; size = 4
_i$ = -88						; size = 4
_type$ = -84						; size = 4
_c$ = -80						; size = 4
_path$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
_d$ = 12						; size = 4
_supply$ = 16						; size = 4
_fuel$ = 20						; size = 4
?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z PROC		; SendSupply

; 241  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 242  : 	Objective	c;
; 243  : 	PathClass	path;

	lea	ecx, DWORD PTR _path$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 244  : 	int			i,l,n,loss,type;
; 245  : 
; 246  : 	if (!*supply && !*fuel)

	mov	eax, DWORD PTR _supply$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@SendSupply
	mov	ecx, DWORD PTR _fuel$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN8@SendSupply

; 247  : 		return 0;

	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
	jmp	$LN9@SendSupply
$LN8@SendSupply:

; 248  : 	if (GetObjectivePath(&path,s,d,Foot,s->GetTeam(),PATH_MARINE) < 1)

	push	32					; 00000020H
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	push	1
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	?GetObjectivePath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1HHH@Z ; GetObjectivePath
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jge	SHORT $LN7@SendSupply

; 249  : 		return 0;

	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN9@SendSupply
$LN7@SendSupply:

; 250  : 
; 251  : 	c = s;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 252  : 	loss = 0;

	mov	DWORD PTR _loss$[ebp], 0

; 253  : 	AddSupply(s,*supply/10,*fuel/10);

	mov	edx, DWORD PTR _fuel$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _supply$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?AddSupply@@YAXPAVObjectiveClass@@HH@Z	; AddSupply
	add	esp, 12					; 0000000cH

; 254  : 	for (i=0; i<path.GetLength(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SendSupply
$LN5@SendSupply:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@SendSupply:
	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetLength@BasePathClass@@QAEHXZ	; BasePathClass::GetLength
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN4@SendSupply

; 255  : 		{
; 256  : 		n = path.GetDirection(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	DWORD PTR _n$[ebp], eax

; 257  : 		c = c->GetNeighbor(n);

	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	ecx, DWORD PTR _c$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _c$[ebp], eax

; 258  : 		type = c->GetType();

	mov	ecx, DWORD PTR _c$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	eax, al
	mov	DWORD PTR _type$[ebp], eax

; 259  : 		if (type == TYPE_ROAD || type == TYPE_INTERSECT || type == TYPE_RAILROAD || type == TYPE_BRIDGE)

	cmp	DWORD PTR _type$[ebp], 26		; 0000001aH
	je	SHORT $LN2@SendSupply
	cmp	DWORD PTR _type$[ebp], 15		; 0000000fH
	je	SHORT $LN2@SendSupply
	cmp	DWORD PTR _type$[ebp], 24		; 00000018H
	je	SHORT $LN2@SendSupply
	cmp	DWORD PTR _type$[ebp], 6
	jne	SHORT $LN3@SendSupply
$LN2@SendSupply:

; 260  : 			{
; 261  : 			AddSupply(c,*supply/10,*fuel/10);

	mov	ecx, DWORD PTR _fuel$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _supply$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	?AddSupply@@YAXPAVObjectiveClass@@HH@Z	; AddSupply
	add	esp, 12					; 0000000cH

; 262  : 			l = c->GetObjectiveSupplyLosses() + 2;		// Automatic loss rate of 2% per objective

	mov	ecx, DWORD PTR _c$[ebp]
	call	?GetObjectiveSupplyLosses@ObjectiveClass@@QAEFXZ ; ObjectiveClass::GetObjectiveSupplyLosses
	cwde
	add	eax, 2
	mov	DWORD PTR _l$[ebp], eax

; 263  : 			*supply = *supply*(100-l)/100;

	mov	ecx, 100				; 00000064H
	sub	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _supply$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _supply$[ebp]
	mov	DWORD PTR [edx], eax

; 264  : 			*fuel = *fuel*(100-l)/100;

	mov	eax, 100				; 00000064H
	sub	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _fuel$[ebp]
	imul	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _fuel$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@SendSupply:

; 265  : 			}
; 266  : 		if (!*supply && !*fuel)

	mov	eax, DWORD PTR _supply$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@SendSupply
	mov	ecx, DWORD PTR _fuel$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@SendSupply

; 267  : 			return 0;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN9@SendSupply
$LN1@SendSupply:

; 268  : 		}

	jmp	$LN5@SendSupply
$LN4@SendSupply:

; 269  : 	return 1;

	mov	DWORD PTR $T4[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
$LN9@SendSupply:

; 270  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z$0:
	lea	ecx, DWORD PTR _path$[ebp]
	jmp	??1PathClass@@QAE@XZ
__ehhandler$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendSupply@@YAHPAVObjectiveClass@@0PAH1@Z ENDP		; SendSupply
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\supply.cpp
_TEXT	SEGMENT
_f$ = -12						; size = 4
_s$ = -8						; size = 4
_sup$ = -4						; size = 2
_o$ = 8							; size = 4
_supply$ = 12						; size = 4
_fuel$ = 16						; size = 4
?AddSupply@@YAXPAVObjectiveClass@@HH@Z PROC		; AddSupply

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 226  : 	int			s,f;
; 227  : 	WORD		sup = o->static_data.local_data;

	mov	eax, DWORD PTR _o$[ebp]
	mov	cx, WORD PTR [eax+214]
	mov	WORD PTR _sup$[ebp], cx

; 228  : 
; 229  : 	s = LOBYTE(sup) + supply;

	movzx	edx, WORD PTR _sup$[ebp]
	and	edx, 255				; 000000ffH
	movzx	eax, dl
	add	eax, DWORD PTR _supply$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 230  : 	if (s > 255)

	cmp	DWORD PTR _s$[ebp], 255			; 000000ffH
	jle	SHORT $LN2@AddSupply

; 231  : 		s = 255;

	mov	DWORD PTR _s$[ebp], 255			; 000000ffH
$LN2@AddSupply:

; 232  : 	f = HIBYTE(sup) + fuel;

	movzx	ecx, WORD PTR _sup$[ebp]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	add	edx, DWORD PTR _fuel$[ebp]
	mov	DWORD PTR _f$[ebp], edx

; 233  : 	if (f > 255)

	cmp	DWORD PTR _f$[ebp], 255			; 000000ffH
	jle	SHORT $LN1@AddSupply

; 234  : 		f = 255;

	mov	DWORD PTR _f$[ebp], 255			; 000000ffH
$LN1@AddSupply:

; 235  : 	o->static_data.local_data = MAKEWORD(s,f);

	mov	eax, DWORD PTR _s$[ebp]
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	edx, DWORD PTR _f$[ebp]
	and	edx, 255				; 000000ffH
	movzx	eax, dl
	shl	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _o$[ebp]
	mov	WORD PTR [edx+214], cx

; 236  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AddSupply@@YAXPAVObjectiveClass@@HH@Z ENDP		; AddSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\supply.cpp
_TEXT	SEGMENT
$T2 = -384						; size = 8
$T3 = -376						; size = 8
$T4 = -368						; size = 8
$T5 = -360						; size = 8
$T6 = -352						; size = 8
$T7 = -344						; size = 8
$T8 = -336						; size = 8
$T9 = -328						; size = 8
tv814 = -320						; size = 8
tv661 = -312						; size = 8
tv803 = -304						; size = 8
tv828 = -296						; size = 8
tv789 = -288						; size = 8
tv650 = -280						; size = 8
_myit$10 = -272						; size = 12
$T11 = -260						; size = 4
_f$ = -256						; size = 4
tv785 = -252						; size = 4
tv800 = -248						; size = 4
tv825 = -244						; size = 4
tv810 = -240						; size = 4
tv646 = -236						; size = 4
tv657 = -232						; size = 4
_s$ = -228						; size = 4
_rate$ = -224						; size = 4
_actionBonus$12 = -220					; size = 4
_type$ = -216						; size = 4
_y$ = -212						; size = 2
_x$ = -208						; size = 2
_power$ = -204						; size = 4
_po$ = -200						; size = 4
_o$ = -196						; size = 4
_who$ = -189						; size = 1
_mis$ = -188						; size = 76
_replacements$ = -112					; size = 32
_supply$ = -80						; size = 32
_fuel$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_deltaTime$ = 8						; size = 4
?ProduceSupplies@@YAHK@Z PROC				; ProduceSupplies

; 54   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProduceSupplies@@YAHK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 55   : 	Objective		o, po;
; 56   : 	Team			who;
; 57   : 	float			rate;
; 58   : 	int				type;
; 59   : 	ulong			supply[NUM_TEAMS]={0},fuel[NUM_TEAMS]={0},s,f, power;

	mov	DWORD PTR _supply$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _supply$[ebp+4], eax
	mov	DWORD PTR _supply$[ebp+8], eax
	mov	DWORD PTR _supply$[ebp+12], eax
	mov	DWORD PTR _supply$[ebp+16], eax
	mov	DWORD PTR _supply$[ebp+20], eax
	mov	DWORD PTR _supply$[ebp+24], eax
	mov	DWORD PTR _supply$[ebp+28], eax
	mov	DWORD PTR _fuel$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _fuel$[ebp+4], ecx
	mov	DWORD PTR _fuel$[ebp+8], ecx
	mov	DWORD PTR _fuel$[ebp+12], ecx
	mov	DWORD PTR _fuel$[ebp+16], ecx
	mov	DWORD PTR _fuel$[ebp+20], ecx
	mov	DWORD PTR _fuel$[ebp+24], ecx
	mov	DWORD PTR _fuel$[ebp+28], ecx

; 60   : 	ulong			replacements[NUM_TEAMS]={0};

	mov	DWORD PTR _replacements$[ebp], 0
	xor	edx, edx
	mov	DWORD PTR _replacements$[ebp+4], edx
	mov	DWORD PTR _replacements$[ebp+8], edx
	mov	DWORD PTR _replacements$[ebp+12], edx
	mov	DWORD PTR _replacements$[ebp+16], edx
	mov	DWORD PTR _replacements$[ebp+20], edx
	mov	DWORD PTR _replacements$[ebp+24], edx
	mov	DWORD PTR _replacements$[ebp+28], edx

; 61   : 	MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 62   : 	GridIndex x, y;
; 63   : 
; 64   : 	// Produce supplies, fuel and reinforcements (factories and refineries)
; 65   : 	{
; 66   : 		VuListIterator	myit(AllObjList);

	mov	eax, DWORD PTR ?AllObjList@@3PAVVuLinkedList@@A ; AllObjList
	push	eax
	lea	ecx, DWORD PTR _myit$10[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 67   : 		o = GetFirstObjective(&myit);

	lea	ecx, DWORD PTR _myit$10[ebp]
	push	ecx
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax
$LN24@ProduceSup:

; 68   : 		while (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN23@ProduceSup

; 69   : 		{
; 70   : 			type = o->GetType();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	mov	DWORD PTR _type$[ebp], edx

; 71   : 			//Cobra Added Army, depot, and port per JimG
; 72   : 			if ((type == TYPE_FACTORY || type == TYPE_ARMYBASE || type == TYPE_DEPOT || type == TYPE_PORT) 
; 73   : 				&& o->GetObjectiveOldown() == o->GetOwner())		// Supply

	cmp	DWORD PTR _type$[ebp], 11		; 0000000bH
	je	SHORT $LN21@ProduceSup
	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN21@ProduceSup
	cmp	DWORD PTR _type$[ebp], 10		; 0000000aH
	je	SHORT $LN21@ProduceSup
	cmp	DWORD PTR _type$[ebp], 19		; 00000013H
	jne	$LN22@ProduceSup
$LN21@ProduceSup:
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveOldown@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveOldown
	movzx	esi, al
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	eax, al
	cmp	esi, eax
	jne	$LN22@ProduceSup

; 74   : 			{
; 75   : 			if (g_bPowerGrid) {

	movzx	ecx, BYTE PTR ?g_bPowerGrid@@3_NA	; g_bPowerGrid
	test	ecx, ecx
	je	$LN20@ProduceSup

; 76   : 				o->GetLocation(&x, &y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 77   : 				po = FindNearestFriendlyPowerStation(AllObjList, o->GetTeam(), x, y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR ?AllObjList@@3PAVVuLinkedList@@A ; AllObjList
	push	edx
	call	?FindNearestFriendlyPowerStation@@YAPAVObjectiveClass@@PAVVuLinkedList@@EFF@Z ; FindNearestFriendlyPowerStation
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax

; 78   : 				if (po) 

	cmp	DWORD PTR _po$[ebp], 0
	je	SHORT $LN19@ProduceSup

; 79   : 				power = po->GetObjectiveStatus();

	mov	ecx, DWORD PTR _po$[ebp]
	call	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveStatus
	movzx	eax, al
	mov	DWORD PTR _power$[ebp], eax
	jmp	SHORT $LN18@ProduceSup
$LN19@ProduceSup:

; 80   : 				else power = 0;

	mov	DWORD PTR _power$[ebp], 0
$LN18@ProduceSup:
	jmp	SHORT $LN17@ProduceSup
$LN20@ProduceSup:

; 81   : 			}
; 82   : 			else power = 100;

	mov	DWORD PTR _power$[ebp], 100		; 00000064H
$LN17@ProduceSup:

; 83   : 			
; 84   : 			s = o->GetObjectiveDataRate() * power / 100;

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveDataRate@ObjectiveClass@@QAEFXZ ; ObjectiveClass::GetObjectiveDataRate
	cwde
	imul	eax, DWORD PTR _power$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	DWORD PTR _s$[ebp], eax

; 85   : 			if (s)

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN15@ProduceSup

; 86   : 			{
; 87   : 				who = o->GetTeam(); 

	mov	edx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	mov	BYTE PTR _who$[ebp], al

; 88   : 
; 89   : 				supply[who] += FloatToInt32( (s * DataRateModSup) );        // A.S.  2001-12-09 DataRateModification for supply and fuel only 

	movzx	esi, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR tv646[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv646[ebp]
	mov	ecx, DWORD PTR tv646[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv650[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv650[ebp]
	mulss	xmm0, DWORD PTR ?DataRateModSup@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _supply$[ebp+esi*4]
	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _supply$[ebp+edx*4], eax

; 90   : 				replacements[who] += FloatToInt32( (s * DataRateModRepl) ); // A.S.  2001-12-09 DataRateModification for replacements only 

	movzx	esi, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR tv657[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv657[ebp]
	mov	ecx, DWORD PTR tv657[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv661[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv661[ebp]
	mulss	xmm0, DWORD PTR ?DataRateModRepl@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _replacements$[ebp+esi*4]
	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _replacements$[ebp+edx*4], eax

; 91   : 
; 92   : 				// *** old code ***
; 93   : 	//				supply[who] += s;
; 94   : 	//			    replacements[who] += s;
; 95   : 
; 96   : 			
; 97   : 				// Request an interdiction stike mission
; 98   : 				mis.requesterID = o->Id();

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 99   : 				o->GetLocation(&mis.tx,&mis.ty);

	lea	eax, DWORD PTR _mis$[ebp+42]
	push	eax
	lea	ecx, DWORD PTR _mis$[ebp+40]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 100  : 				mis.vs = who;

	mov	dl, BYTE PTR _who$[ebp]
	mov	BYTE PTR _mis$[ebp+33], dl

; 101  : 				mis.who = GetEnemyTeam(mis.vs);

	movzx	eax, BYTE PTR _mis$[ebp+33]
	push	eax
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 102  : 				mis.tot = Camp_GetCurrentTime() + rand()%deltaTime + 30*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	xor	edx, edx
	div	DWORD PTR _deltaTime$[ebp]
	lea	ecx, DWORD PTR [esi+edx+1800000]
	mov	DWORD PTR _mis$[ebp+36], ecx

; 103  : 				mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 104  : 				mis.targetID = o->Id();

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 105  : 				mis.mission = AMIS_INTSTRIKE;

	mov	BYTE PTR _mis$[ebp+60], 14		; 0000000eH

; 106  : 				mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 107  : 				mis.context = enemyProductionSource;

	mov	BYTE PTR _mis$[ebp+62], 35		; 00000023H

; 108  : 				mis.priority = 0;

	xor	eax, eax
	mov	WORD PTR _mis$[ebp+56], ax

; 109  : 				mis.RequestEnemyMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestEnemyMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestEnemyMission

; 110  : 				if (g_bPowerGrid) {

	movzx	ecx, BYTE PTR ?g_bPowerGrid@@3_NA	; g_bPowerGrid
	test	ecx, ecx
	je	$LN15@ProduceSup

; 111  : 				// Request an interdiction stike mission against the power station
; 112  : 				mis.requesterID = po->Id();

	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 113  : 				po->GetLocation(&mis.tx,&mis.ty);

	lea	eax, DWORD PTR _mis$[ebp+42]
	push	eax
	lea	ecx, DWORD PTR _mis$[ebp+40]
	push	ecx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 114  : 				mis.vs = who;

	mov	dl, BYTE PTR _who$[ebp]
	mov	BYTE PTR _mis$[ebp+33], dl

; 115  : 				mis.who = GetEnemyTeam(mis.vs);

	movzx	eax, BYTE PTR _mis$[ebp+33]
	push	eax
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 116  : 				mis.tot = Camp_GetCurrentTime() + rand()%deltaTime + 30*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	xor	edx, edx
	div	DWORD PTR _deltaTime$[ebp]
	lea	ecx, DWORD PTR [esi+edx+1800000]
	mov	DWORD PTR _mis$[ebp+36], ecx

; 117  : 				mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 118  : 				mis.targetID = po->Id();

	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 119  : 				mis.mission = AMIS_INTSTRIKE;

	mov	BYTE PTR _mis$[ebp+60], 14		; 0000000eH

; 120  : 				mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 121  : 				mis.context = enemyFuelSource;

	mov	BYTE PTR _mis$[ebp+62], 36		; 00000024H

; 122  : 				mis.priority = 0;

	xor	eax, eax
	mov	WORD PTR _mis$[ebp+56], ax

; 123  : 				mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission
$LN15@ProduceSup:

; 124  : 				}
; 125  : 			}
; 126  : 			}

	jmp	$LN7@ProduceSup
$LN22@ProduceSup:

; 127  : 			else if (type == TYPE_REFINERY && o->GetObjectiveOldown() == o->GetOwner())	// Fuel

	cmp	DWORD PTR _type$[ebp], 25		; 00000019H
	jne	$LN7@ProduceSup
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveOldown@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveOldown
	movzx	esi, al
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	cmp	esi, ecx
	jne	$LN7@ProduceSup

; 128  : 			{
; 129  : 			if (g_bPowerGrid) {

	movzx	edx, BYTE PTR ?g_bPowerGrid@@3_NA	; g_bPowerGrid
	test	edx, edx
	je	$LN12@ProduceSup

; 130  : 				o->GetLocation(&x, &y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 131  : 				po = FindNearestFriendlyPowerStation(AllObjList, o->GetTeam(), x, y);

	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR ?AllObjList@@3PAVVuLinkedList@@A ; AllObjList
	push	edx
	call	?FindNearestFriendlyPowerStation@@YAPAVObjectiveClass@@PAVVuLinkedList@@EFF@Z ; FindNearestFriendlyPowerStation
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax

; 132  : 				if (po) 

	cmp	DWORD PTR _po$[ebp], 0
	je	SHORT $LN11@ProduceSup

; 133  : 				power = po->GetObjectiveStatus();

	mov	ecx, DWORD PTR _po$[ebp]
	call	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveStatus
	movzx	eax, al
	mov	DWORD PTR _power$[ebp], eax
	jmp	SHORT $LN10@ProduceSup
$LN11@ProduceSup:

; 134  : 				else power = 0;

	mov	DWORD PTR _power$[ebp], 0
$LN10@ProduceSup:
	jmp	SHORT $LN9@ProduceSup
$LN12@ProduceSup:

; 135  : 			}
; 136  : 			else power = 100;

	mov	DWORD PTR _power$[ebp], 100		; 00000064H
$LN9@ProduceSup:

; 137  : 			f = o->GetObjectiveDataRate() * power / 100;

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveDataRate@ObjectiveClass@@QAEFXZ ; ObjectiveClass::GetObjectiveDataRate
	cwde
	imul	eax, DWORD PTR _power$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	DWORD PTR _f$[ebp], eax

; 138  : 			if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN7@ProduceSup

; 139  : 			{
; 140  : 				who = o->GetTeam(); 

	mov	edx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	mov	BYTE PTR _who$[ebp], al

; 141  : 				fuel[who] += f;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR _fuel$[ebp+eax*4]
	add	ecx, DWORD PTR _f$[ebp]
	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _fuel$[ebp+edx*4], ecx

; 142  : 				// Request an interdiction stike mission
; 143  : 				mis.requesterID = o->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 144  : 				o->GetLocation(&mis.tx,&mis.ty);

	lea	eax, DWORD PTR _mis$[ebp+42]
	push	eax
	lea	ecx, DWORD PTR _mis$[ebp+40]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 145  : 				mis.vs = who;

	mov	dl, BYTE PTR _who$[ebp]
	mov	BYTE PTR _mis$[ebp+33], dl

; 146  : 				mis.who = GetEnemyTeam(mis.vs);

	movzx	eax, BYTE PTR _mis$[ebp+33]
	push	eax
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 147  : 				mis.tot = Camp_GetCurrentTime() + rand()%deltaTime + 30*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	xor	edx, edx
	div	DWORD PTR _deltaTime$[ebp]
	lea	ecx, DWORD PTR [esi+edx+1800000]
	mov	DWORD PTR _mis$[ebp+36], ecx

; 148  : 				mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 149  : 				mis.targetID = o->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 150  : 				mis.mission = AMIS_INTSTRIKE;

	mov	BYTE PTR _mis$[ebp+60], 14		; 0000000eH

; 151  : 				mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 152  : 				mis.context = enemyFuelSource;

	mov	BYTE PTR _mis$[ebp+62], 36		; 00000024H

; 153  : 				mis.priority = 0;

	xor	eax, eax
	mov	WORD PTR _mis$[ebp+56], ax

; 154  : 				mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission

; 155  : 				if (g_bPowerGrid) {

	movzx	ecx, BYTE PTR ?g_bPowerGrid@@3_NA	; g_bPowerGrid
	test	ecx, ecx
	je	$LN7@ProduceSup

; 156  : 				// Request an interdiction stike mission against the power station
; 157  : 				mis.requesterID = po->Id();

	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 158  : 				po->GetLocation(&mis.tx,&mis.ty);

	lea	eax, DWORD PTR _mis$[ebp+42]
	push	eax
	lea	ecx, DWORD PTR _mis$[ebp+40]
	push	ecx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 159  : 				mis.vs = who;

	mov	dl, BYTE PTR _who$[ebp]
	mov	BYTE PTR _mis$[ebp+33], dl

; 160  : 				mis.who = GetEnemyTeam(mis.vs);

	movzx	eax, BYTE PTR _mis$[ebp+33]
	push	eax
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	BYTE PTR _mis$[ebp+32], al

; 161  : 				mis.tot = Camp_GetCurrentTime() + rand()%deltaTime + 30*CampaignMinutes;

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	call	_rand
	xor	edx, edx
	div	DWORD PTR _deltaTime$[ebp]
	lea	ecx, DWORD PTR [esi+edx+1800000]
	mov	DWORD PTR _mis$[ebp+36], ecx

; 162  : 				mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 163  : 				mis.targetID = po->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 164  : 				mis.mission = AMIS_INTSTRIKE;

	mov	BYTE PTR _mis$[ebp+60], 14		; 0000000eH

; 165  : 				mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 166  : 				mis.context = enemyFuelSource;

	mov	BYTE PTR _mis$[ebp+62], 36		; 00000024H

; 167  : 				mis.priority = 0;

	xor	eax, eax
	mov	WORD PTR _mis$[ebp+56], ax

; 168  : 				mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission
$LN7@ProduceSup:

; 169  : 				}
; 170  : 			}
; 171  : 			}
; 172  : 		    
; 173  : 			// NOTE: IF WE WANT SPECIAL SUPPLY SOURCES (OFF-MAP SUPPLY SOURCES), ADD THE
; 174  : 			// BONUS HERE.
; 175  : 			// if (o->IsBonusSupplySource())
; 176  : 			//		supply += 1000;
; 177  : 		    
; 178  : 			o = GetNextObjective(&myit);

	lea	ecx, DWORD PTR _myit$10[ebp]
	push	ecx
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax

; 179  : 		}

	jmp	$LN24@ProduceSup
$LN23@ProduceSup:

; 180  : 
; 181  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _myit$10[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 182  : 	// rates are per day - convert to this interval
; 183  : 	rate = (float)deltaTime/(float)CampaignDay;

	mov	edx, DWORD PTR _deltaTime$[ebp]
	mov	DWORD PTR tv785[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv785[ebp]
	mov	eax, DWORD PTR tv785[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv789[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv789[ebp]
	divss	xmm0, DWORD PTR __real@4ca4cb80
	movss	DWORD PTR _rate$[ebp], xmm0

; 184  : 
; 185  : 	for (who = 0; who < NUM_TEAMS; who++)

	mov	BYTE PTR _who$[ebp], 0
	jmp	SHORT $LN6@ProduceSup
$LN5@ProduceSup:
	mov	cl, BYTE PTR _who$[ebp]
	add	cl, 1
	mov	BYTE PTR _who$[ebp], cl
$LN6@ProduceSup:
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	edx, 8
	jge	$LN4@ProduceSup

; 186  : 		{
; 187  : 		int			actionBonus = TeamInfo[who]->GetGroundAction()->actionType;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	movzx	ecx, BYTE PTR [eax+16]
	mov	DWORD PTR _actionBonus$12[ebp], ecx

; 188  : 
; 189  : 		// A.S. 2001-12-09  No Action Type Bonus for production of supply, fuel and replacements
; 190  : 		if (NoActionBonusProd)

	cmp	DWORD PTR ?NoActionBonusProd@@3HA, 0	; NoActionBonusProd
	je	SHORT $LN3@ProduceSup

; 191  : 			actionBonus = 1;   

	mov	DWORD PTR _actionBonus$12[ebp], 1
$LN3@ProduceSup:

; 192  : 		// end added section
; 193  : 		
; 194  : 		supply[who] = AUTOMATIC_SUPPLY + FloatToInt32((supply[who]/5) * rate * actionBonus);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _supply$[ebp+edx*4]
	xor	edx, edx
	mov	ecx, 5
	div	ecx
	mov	DWORD PTR tv800[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv800[ebp]
	mov	edx, DWORD PTR tv800[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv803[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv803[ebp]
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvtsi2ss xmm1, DWORD PTR _actionBonus$12[ebp]
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 5
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _supply$[ebp+ecx*4], eax

; 195  : 		fuel[who] = AUTOMATIC_SUPPLY + FloatToInt32(fuel[who] * rate * actionBonus);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _fuel$[ebp+edx*4]
	mov	DWORD PTR tv810[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv810[ebp]
	mov	ecx, DWORD PTR tv810[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv814[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv814[ebp]
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvtsi2ss xmm1, DWORD PTR _actionBonus$12[ebp]
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 5
	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _fuel$[ebp+edx*4], eax

; 196  : 		replacements[who] = AUTOMATIC_REPLACEMENTS + FloatToInt32((replacements[who]/40) * rate * actionBonus);

	movzx	eax, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _replacements$[ebp+eax*4]
	xor	edx, edx
	mov	ecx, 40					; 00000028H
	div	ecx
	mov	DWORD PTR tv825[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv825[ebp]
	mov	edx, DWORD PTR tv825[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv828[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv828[ebp]
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvtsi2ss xmm1, DWORD PTR _actionBonus$12[ebp]
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 1
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _replacements$[ebp+ecx*4], eax

; 197  : 
; 198  : #ifdef DEBUG
; 199  : 		gSupplyFromProduction[who] += supply[who];
; 200  : 		gFuelFromProduction[who] += fuel[who];
; 201  : 		gReplacmentsFromProduction[who] += replacements[who];
; 202  : #endif
; 203  : 
; 204  : 		// Deplete unused extra supplies and move supplies to team supply pools
; 205  : 		supply[who] = (TeamInfo[who]->GetSupplyAvail()/2) + supply[who];

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetSupplyAvail@TeamClass@@QAEGXZ	; TeamClass::GetSupplyAvail
	movzx	eax, ax
	cdq
	sub	eax, edx
	sar	eax, 1
	movzx	ecx, BYTE PTR _who$[ebp]
	add	eax, DWORD PTR _supply$[ebp+ecx*4]
	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _supply$[ebp+edx*4], eax

; 206  : 		fuel[who] = (TeamInfo[who]->GetFuelAvail()/2) + fuel[who];

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetFuelAvail@TeamClass@@QAEGXZ		; TeamClass::GetFuelAvail
	movzx	eax, ax
	cdq
	sub	eax, edx
	sar	eax, 1
	movzx	ecx, BYTE PTR _who$[ebp]
	add	eax, DWORD PTR _fuel$[ebp+ecx*4]
	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _fuel$[ebp+edx*4], eax

; 207  : 		replacements[who] = TeamInfo[who]->GetReplacementsAvail() + replacements[who];

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	ecx, ax
	movzx	edx, BYTE PTR _who$[ebp]
	add	ecx, DWORD PTR _replacements$[ebp+edx*4]
	movzx	eax, BYTE PTR _who$[ebp]
	mov	DWORD PTR _replacements$[ebp+eax*4], ecx

; 208  : 
; 209  : 		if (supply[who] > MAX_SUPPLIES)

	movzx	ecx, BYTE PTR _who$[ebp]
	cmp	DWORD PTR _supply$[ebp+ecx*4], 60000	; 0000ea60H
	jbe	SHORT $LN2@ProduceSup

; 210  : 			supply[who] = MAX_SUPPLIES;

	movzx	edx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _supply$[ebp+edx*4], 60000	; 0000ea60H
$LN2@ProduceSup:

; 211  : 		TeamInfo[who]->SetSupplyAvail(supply[who]);

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR _supply$[ebp+eax*4]
	push	ecx
	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetSupplyAvail@TeamClass@@QAEXH@Z	; TeamClass::SetSupplyAvail

; 212  : 		if (fuel[who] > MAX_SUPPLIES)

	movzx	eax, BYTE PTR _who$[ebp]
	cmp	DWORD PTR _fuel$[ebp+eax*4], 60000	; 0000ea60H
	jbe	SHORT $LN1@ProduceSup

; 213  : 			fuel[who] = MAX_SUPPLIES;

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	DWORD PTR _fuel$[ebp+ecx*4], 60000	; 0000ea60H
$LN1@ProduceSup:

; 214  : 		TeamInfo[who]->SetFuelAvail(fuel[who]);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _fuel$[ebp+edx*4]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetFuelAvail@TeamClass@@QAEXH@Z	; TeamClass::SetFuelAvail

; 215  : 		TeamInfo[who]->SetReplacementsAvail(replacements[who]);

	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR _replacements$[ebp+edx*4]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail

; 216  : 		}

	jmp	$LN5@ProduceSup
$LN4@ProduceSup:

; 217  : 	return 1;

	mov	DWORD PTR $T11[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T11[ebp]

; 218  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProduceSupplies@@YAHK@Z$0:
	lea	ecx, DWORD PTR _mis$[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__unwindfunclet$?ProduceSupplies@@YAHK@Z$1:
	lea	ecx, DWORD PTR _myit$10[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?ProduceSupplies@@YAHK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProduceSupplies@@YAHK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProduceSupplies@@YAHK@Z ENDP				; ProduceSupplies
; Function compile flags: /Odtp
;	COMDAT ??1PathClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathClass@@QAE@XZ PROC				; PathClass::~PathClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BasePathClass@@QAE@XZ		; BasePathClass::~BasePathClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathClass@@QAE@XZ ENDP				; PathClass::~PathClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\asearch.h
;	COMDAT ?GetLength@BasePathClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLength@BasePathClass@@QAEHXZ PROC			; BasePathClass::GetLength, COMDAT
; _this$ = ecx

; 77   : 		int GetLength (void)					{ return length; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLength@BasePathClass@@QAEHXZ ENDP			; BasePathClass::GetLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ PROC ; TeamClass::GetGroundAction, COMDAT
; _this$ = ecx

; 277  : 	TeamGndActionType *GetGroundAction (void) { return &groundAction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ENDP ; TeamClass::GetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetReplacementsAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReplacementsAvail@TeamClass@@QAEGXZ PROC		; TeamClass::GetReplacementsAvail, COMDAT
; _this$ = ecx

; 271  : 	ushort GetReplacementsAvail (void) { return replacementsAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+150]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReplacementsAvail@TeamClass@@QAEGXZ ENDP		; TeamClass::GetReplacementsAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetFuelAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelAvail@TeamClass@@QAEGXZ PROC			; TeamClass::GetFuelAvail, COMDAT
; _this$ = ecx

; 270  : 	ushort GetFuelAvail (void) { return fuelAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelAvail@TeamClass@@QAEGXZ ENDP			; TeamClass::GetFuelAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetSupplyAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSupplyAvail@TeamClass@@QAEGXZ PROC			; TeamClass::GetSupplyAvail, COMDAT
; _this$ = ecx

; 269  : 	ushort GetSupplyAvail (void) { return supplyAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+146]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSupplyAvail@TeamClass@@QAEGXZ ENDP			; TeamClass::GetSupplyAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveSupplyLosses@ObjectiveClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveSupplyLosses@ObjectiveClass@@QAEFXZ PROC	; ObjectiveClass::GetObjectiveSupplyLosses, COMDAT
; _this$ = ecx

; 275  : 	short GetObjectiveSupplyLosses (void)					{	return obj_data.losses; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ax, BYTE PTR [eax+198]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveSupplyLosses@ObjectiveClass@@QAEFXZ ENDP	; ObjectiveClass::GetObjectiveSupplyLosses
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveStatus@ObjectiveClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveStatus@ObjectiveClass@@QAEEXZ PROC		; ObjectiveClass::GetObjectiveStatus, COMDAT
; _this$ = ecx

; 270  : 	uchar GetObjectiveStatus (void)							{	return obj_data.status; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+199]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ENDP		; ObjectiveClass::GetObjectiveStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveOldown@ObjectiveClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveOldown@ObjectiveClass@@QAEEXZ PROC		; ObjectiveClass::GetObjectiveOldown, COMDAT
; _this$ = ecx

; 262  : 	Control GetObjectiveOldown (void)						{	return static_data.first_owner; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+224]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveOldown@ObjectiveClass@@QAEEXZ ENDP		; ObjectiveClass::GetObjectiveOldown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?ceil@@YAMM@Z PROC					; ceil, COMDAT

; 509  :         {return (ceilf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_ceilf
	add	esp, 4
	pop	ebp
	ret	0
?ceil@@YAMM@Z ENDP					; ceil
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 408  :         {return ((float)ceil((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ceil
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_ceilf	ENDP
_TEXT	ENDS
END
