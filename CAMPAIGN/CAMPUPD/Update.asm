; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUPD\Update.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?ProcessedCount@@3HA				; ProcessedCount
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
_BSS	SEGMENT
?ProcessedCount@@3HA DD 01H DUP (?)			; ProcessedCount
_BSS	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsCampaign@FalconEntity@@QAEHXZ		; FalconEntity::IsCampaign
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?IsTacan@CampBaseClass@@QAEHXZ			; CampBaseClass::IsTacan
PUBLIC	?UnsetChecked@CampBaseClass@@QAEXXZ		; CampBaseClass::UnsetChecked
PUBLIC	?GetLastCheck@UnitClass@@QAEKXZ			; UnitClass::GetLastCheck
PUBLIC	?GetRoster@UnitClass@@QAEJXZ			; UnitClass::GetRoster
PUBLIC	?Engaged@UnitClass@@QBEHXZ			; UnitClass::Engaged
PUBLIC	?Moving@UnitClass@@QBEHXZ			; UnitClass::Moving
PUBLIC	?Cargo@UnitClass@@QBEHXZ			; UnitClass::Cargo
PUBLIC	?Diverted@UnitClass@@QAEHXZ			; UnitClass::Diverted
PUBLIC	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z	; UnitClass::SetTarget
PUBLIC	?UpdateUnit@@YAHPAVUnitClass@@K@Z		; UpdateUnit
PUBLIC	?DoWPAction@@YAHPAVFlightClass@@@Z		; DoWPAction
PUBLIC	?TimeToMove@@YAKPAVUnitClass@@E@Z		; TimeToMove
PUBLIC	?EngageParent@@YAHPAVUnitClass@@PAVFalconEntity@@@Z ; EngageParent
PUBLIC	?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z ; Detected
PUBLIC	?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z ; DoCombat
PUBLIC	?GetSupplyAvail@TeamClass@@QAEGXZ		; TeamClass::GetSupplyAvail
PUBLIC	?GetFuelAvail@TeamClass@@QAEGXZ			; TeamClass::GetFuelAvail
PUBLIC	?GetReplacementsAvail@TeamClass@@QAEGXZ		; TeamClass::GetReplacementsAvail
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?DetectOneWay@@YAXPAVCampBaseClass@@PAVFalconEntity@@HPAH2@Z ; DetectOneWay
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3c23d70a
PUBLIC	__real@3f800000
PUBLIC	__real@454cffae
PUBLIC	__real@c59c4000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Remove
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	??0FalconCampWeaponsFire@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconCampWeaponsFire::FalconCampWeaponsFire
EXTRN	?FireOnSimEntity@@YAXPAVCampBaseClass@@0QAFQAEE@Z:PROC ; FireOnSimEntity
EXTRN	?FireOnSimEntity@@YAXPAVCampBaseClass@@PAVSimBaseClass@@F@Z:PROC ; FireOnSimEntity
EXTRN	?GetComponentLead@CampBaseClass@@QAEPAVSimBaseClass@@XZ:PROC ; CampBaseClass::GetComponentLead
EXTRN	?SetTacan@CampBaseClass@@QAEXH@Z:PROC		; CampBaseClass::SetTacan
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?SetLastCheck@UnitClass@@QAEXK@Z:PROC		; UnitClass::SetLastCheck
EXTRN	?UpdateTime@UnitClass@@QBEKXZ:PROC		; UnitClass::UpdateTime
EXTRN	?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z:PROC ; UnitClass::SendUnitMessage
EXTRN	?SetEngaged@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetEngaged
EXTRN	?SetDiverted@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetDiverted
EXTRN	?SetFired@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetFired
EXTRN	?GetCruiseSpeed@UnitClass@@QBEHXZ:PROC		; UnitClass::GetCruiseSpeed
EXTRN	?CountUnitElements@UnitClass@@QAEHXZ:PROC	; UnitClass::CountUnitElements
EXTRN	?KillUnit@UnitClass@@QAEXXZ:PROC		; UnitClass::KillUnit
EXTRN	?GetUnitMovementCost@UnitClass@@QAEMFFE@Z:PROC	; UnitClass::GetUnitMovementCost
EXTRN	?LoadUnit@UnitClass@@QAEXPAV1@@Z:PROC		; UnitClass::LoadUnit
EXTRN	?UnloadUnit@UnitClass@@QAEXXZ:PROC		; UnitClass::UnloadUnit
EXTRN	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z:PROC ; UnitClass::AddUnitWP
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z:PROC ; UnitClass::SetCurrentUnitWP
EXTRN	?AdjustWayPoints@UnitClass@@QAEXXZ:PROC		; UnitClass::AdjustWayPoints
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?Distance@@YAMMMMM@Z:PROC			; Distance
EXTRN	?TimeToArrive@@YAKMM@Z:PROC			; TimeToArrive
EXTRN	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ:PROC ; FlightClass::GetFlightLeadCallNumber
EXTRN	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ:PROC	; FlightClass::GetFlightLeadVoiceID
EXTRN	?GetFACFlight@FlightClass@@QAEPAV1@XZ:PROC	; FlightClass::GetFACFlight
EXTRN	?UpdateSquadronStatus@@YAXPAVFlightClass@@HH@Z:PROC ; UpdateSquadronStatus
EXTRN	?SetSupplyAvail@TeamClass@@QAEXH@Z:PROC		; TeamClass::SetSupplyAvail
EXTRN	?SetFuelAvail@TeamClass@@QAEXH@Z:PROC		; TeamClass::SetFuelAvail
EXTRN	?SetReplacementsAvail@TeamClass@@QAEXH@Z:PROC	; TeamClass::SetReplacementsAvail
EXTRN	?AirExperienceAdjustment@@YAME@Z:PROC		; AirExperienceAdjustment
EXTRN	?CombatBonus@@YAMEVVU_ID@@@Z:PROC		; CombatBonus
EXTRN	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconRadioChatterMessage::FalconRadioChatterMessage
EXTRN	?SendCallToAWACS@@YAXPAVAircraftClass@@FPAVVuTargetEntity@@@Z:PROC ; SendCallToAWACS
EXTRN	?AircraftLaunch@@YAXPAVFlightClass@@@Z:PROC	; AircraftLaunch
EXTRN	?GoHome@@YAXPAVFlightClass@@@Z:PROC		; GoHome
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?Map_Max_X@@3FA:WORD				; Map_Max_X
EXTRN	?Map_Max_Y@@3FA:WORD				; Map_Max_Y
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?dx@@3PAFA:BYTE					; dx
EXTRN	?dy@@3PAFA:BYTE					; dy
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@c59c4000
CONST	SEGMENT
__real@c59c4000 DD 0c59c4000r			; -5000
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z$0
__ehfuncinfo$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DoWPAction@@YAHPAVFlightClass@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?DoWPAction@@YAHPAVFlightClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoWPAction@@YAHPAVFlightClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
_am$ = -8						; size = 4
_em$ = -4						; size = 4
_a$ = 8							; size = 4
_e$ = 12						; size = 4
_d$ = 16						; size = 4
_det$ = 20						; size = 4
_ran$ = 24						; size = 4
?DetectOneWay@@YAXPAVCampBaseClass@@PAVFalconEntity@@HPAH2@Z PROC ; DetectOneWay

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 165  : 	int		em /* ADDED BY S.G. TO GET THE SHOOTERS OBJECT TYPE */, am = a->GetMovementType();

	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _am$[ebp], eax

; 166  : 
; 167  : 	em = e->GetMovementType();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _em$[ebp], eax

; 168  : 	if (a->CanDetect(e))

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+424]
	call	edx
	test	eax, eax
	je	SHORT $LN4@DetectOneW

; 169  : 		*det = 1;

	mov	eax, DWORD PTR _det$[ebp]
	mov	DWORD PTR [eax], 1
$LN4@DetectOneW:

; 170  : //	if (a->IsUnit() && a->GetAproxWeaponRange(em) >= d && a->GetWeaponRange(em) >= d) // REMOVED BY S.G.
; 171  : 	// WILL MAKE SURE BOTH OBJECTS ARE PLANE, SHOOTER HAS MORE THEN JUST GUN (1 NM) AND TARGET WITHIN AT LEAST 20 NM OF US
; 172  : 	//Cobra changed to d <= 100 from 37 (only 20 nm)
; 173  : 	if (a->IsUnit() && a->GetAproxWeaponRange(em) >= d && ((am == Air && em == Air && d <= 100  && a->GetWeaponRange(em) > 1) || a->GetWeaponRange(em, e) >= d)) // 2002-03-08 MODIFIED BY S.G. Added 'e' at the end of a->GetWeaponRange so we test the min/max weapon range against this guy

	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN5@DetectOneW
	mov	ecx, DWORD PTR _em$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+412]
	call	edx
	cmp	eax, DWORD PTR _d$[ebp]
	jl	SHORT $LN5@DetectOneW
	cmp	DWORD PTR _am$[ebp], 5
	jne	SHORT $LN1@DetectOneW
	cmp	DWORD PTR _em$[ebp], 5
	jne	SHORT $LN1@DetectOneW
	cmp	DWORD PTR _d$[ebp], 100			; 00000064H
	jg	SHORT $LN1@DetectOneW
	push	0
	mov	eax, DWORD PTR _em$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx+408]
	call	eax
	cmp	eax, 1
	jg	SHORT $LN2@DetectOneW
$LN1@DetectOneW:
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _em$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx+408]
	call	eax
	cmp	eax, DWORD PTR _d$[ebp]
	jl	SHORT $LN5@DetectOneW
$LN2@DetectOneW:

; 174  : 		*ran = 1;

	mov	ecx, DWORD PTR _ran$[ebp]
	mov	DWORD PTR [ecx], 1
$LN5@DetectOneW:

; 175  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?DetectOneWay@@YAXPAVCampBaseClass@@PAVFalconEntity@@HPAH2@Z ENDP ; DetectOneWay
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetReplacementsAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReplacementsAvail@TeamClass@@QAEGXZ PROC		; TeamClass::GetReplacementsAvail, COMDAT
; _this$ = ecx

; 271  : 	ushort GetReplacementsAvail (void) { return replacementsAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+150]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReplacementsAvail@TeamClass@@QAEGXZ ENDP		; TeamClass::GetReplacementsAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetFuelAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelAvail@TeamClass@@QAEGXZ PROC			; TeamClass::GetFuelAvail, COMDAT
; _this$ = ecx

; 270  : 	ushort GetFuelAvail (void) { return fuelAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelAvail@TeamClass@@QAEGXZ ENDP			; TeamClass::GetFuelAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetSupplyAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSupplyAvail@TeamClass@@QAEGXZ PROC			; TeamClass::GetSupplyAvail, COMDAT
; _this$ = ecx

; 269  : 	ushort GetSupplyAvail (void) { return supplyAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+146]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSupplyAvail@TeamClass@@QAEGXZ ENDP			; TeamClass::GetSupplyAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
$T2 = -136						; size = 8
$T3 = -128						; size = 8
$T4 = -120						; size = 8
_id$ = -112						; size = 4
tv628 = -108						; size = 4
_damageMods$ = -104					; size = 4
tv640 = -100						; size = 4
$T5 = -96						; size = 4
_defmt$ = -92						; size = 4
tv442 = -88						; size = 4
_d$ = -84						; size = 4
tv453 = -80						; size = 4
$T6 = -76						; size = 4
_atty$ = -72						; size = 2
_attx$ = -68						; size = 2
_defy$ = -64						; size = 2
_defx$ = -60						; size = 2
_shot$ = -56						; size = 4
_cwfm$7 = -52						; size = 4
_bonus$ = -48						; size = 4
_i$ = -44						; size = 4
_weapon$ = -40						; size = 16
_wcount$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_att$ = 8						; size = 4
_def$ = 12						; size = 4
?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z PROC ; DoCombat

; 221  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 222  : 	uchar*		damageMods;
; 223  : 	MoveType	defmt;
; 224  : 	short		weapon[MAX_TYPES_PER_CAMP_FIRE_MESSAGE];
; 225  : 	uchar wcount[MAX_TYPES_PER_CAMP_FIRE_MESSAGE];
; 226  : 	int			d,i,id=255,shot=0;

	mov	DWORD PTR _id$[ebp], 255		; 000000ffH
	mov	DWORD PTR _shot$[ebp], 0

; 227  : 	float		bonus = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bonus$[ebp], xmm0

; 228  : 	GridIndex   defx,defy,attx,atty;
; 229  : 
; 230  : 	if (!att || !def)

	cmp	DWORD PTR _att$[ebp], 0
	je	SHORT $LN22@DoCombat
	cmp	DWORD PTR _def$[ebp], 0
	jne	SHORT $LN23@DoCombat
$LN22@DoCombat:

; 231  : 		return -1;

	or	eax, -1
	jmp	$LN24@DoCombat
$LN23@DoCombat:

; 232  : 
; 233  : // 2001-06-13 ADDED BY S.G. BEFORE WE CAN REALLY COMBAT, WE MUST SEE BE ABLE TO DETECT THE TARGET OURSELF BUT ONLY IF WE ARE A BATTALION
; 234  : 	// This is only called by aggregated UNITS so I safely call CanDetect from att as a unit against def
; 235  : 	// Since this is for SOJ, limit it to battalions...
; 236  : 	if (((UnitClass *)att)->IsBattalion() && !((UnitClass *)att)->CanDetect (def))

	mov	eax, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN21@DoCombat
	mov	ecx, DWORD PTR _def$[ebp]
	push	ecx
	mov	edx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax+424]
	call	edx
	test	eax, eax
	jne	SHORT $LN21@DoCombat

; 237  : 	{
; 238  : 		att->StepRadar(0, 0, 1);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	push	0
	mov	eax, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+428]
	call	eax

; 239  : 		return 0;

	xor	eax, eax
	jmp	$LN24@DoCombat
$LN21@DoCombat:

; 240  : 	}
; 241  : // END OF ADDED SECTION
; 242  : 
; 243  : 	// We need to collect a weapon list, and send a firedOn message for each type
; 244  : 	def->GetLocation(&defx,&defy);

	lea	ecx, DWORD PTR _defy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _defx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _def$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 245  : 	att->GetLocation(&attx,&atty);

	lea	eax, DWORD PTR _atty$[ebp]
	push	eax
	lea	ecx, DWORD PTR _attx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _att$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 246  : 	d = FloatToInt32(Distance(attx,atty,defx,defy));

	movzx	edx, WORD PTR _defy$[ebp]
	push	edx
	movzx	eax, WORD PTR _defx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _atty$[ebp]
	push	ecx
	movzx	edx, WORD PTR _attx$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 247  : 	damageMods = def->GetDamageModifiers();

	mov	eax, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [edx+296]
	call	eax
	mov	DWORD PTR _damageMods$[ebp], eax

; 248  : 	defmt = def->GetMovementType();

	mov	ecx, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _defmt$[ebp], eax

; 249  : 	if (def->IsFlight() && !((Flight)def)->Moving())

	mov	ecx, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN20@DoCombat
	mov	ecx, DWORD PTR _def$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	jne	SHORT $LN20@DoCombat

; 250  : 		defmt = NoMove;							// Aircraft on the ground! bomb away!

	mov	DWORD PTR _defmt$[ebp], 0
$LN20@DoCombat:

; 251  : 	memset(weapon,0,sizeof(weapon));

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _weapon$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 252  : 	memset(wcount,0,sizeof(wcount));

	push	8
	push	0
	lea	edx, DWORD PTR _wcount$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 253  : 
; 254  : 	// We may want to support Sim entities at some point, but for now, attacker is assumed to be a unit
; 255  : 	ShiAssert (att->IsUnit());
; 256  : 
; 257  : 	// Step our radar if we're shoot'n at them flying thingys..
; 258  : 	if (!def->OnGround())

	mov	eax, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN17@DoCombat

; 259  : 		{
; 260  : 			if (att->IsAggregate() )

	mov	ecx, DWORD PTR _att$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	$LN17@DoCombat

; 261  : 			{	
; 262  : 				 att->StepRadar(1, 1, (float) d);

	cvtsi2ss xmm0, DWORD PTR _d$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+428]
	call	eax

; 263  : 				if (att->GetRadarMode() == FEC_RADAR_AQUIRE)//me123 

	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN17@DoCombat

; 264  : 				{
; 265  : 					// Shortern our next combat interval if we're aquiring
; 266  : 					// 2002-03-22 MODIFIED BY S.G. Combat time will happen using the experience of the shooter as well (3 to 8 seconds)
; 267  : 					// ((Unit)att)->SetCombatTime(TheCampaign.CurrentTime - ((GROUND_COMBAT_CHECK_INTERVAL-rand()%3-2)*CampaignSeconds));
; 268  : 					((Unit)att)->SetCombatTime(TheCampaign.CurrentTime - (((BattalionClass *)att)->CombatTime() - (rand() % 4 + 6 - (TeamInfo[att->GetOwner()]->airDefenseExperience >> 5)) * CampaignSeconds));

	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+532]
	call	eax
	mov	esi, eax
	call	_rand
	mov	edi, eax
	and	edi, -2147483645			; 80000003H
	jns	SHORT $LN32@DoCombat
	dec	edi
	or	edi, -4					; fffffffcH
	inc	edi
$LN32@DoCombat:
	add	edi, 6
	mov	ecx, DWORD PTR _att$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, BYTE PTR [edx+613]
	sar	eax, 5
	sub	edi, eax
	imul	edi, 1000				; 000003e8H
	sub	esi, edi
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, esi
	push	ecx
	mov	edx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax+596]
	call	edx
$LN17@DoCombat:

; 269  : 				}
; 270  : 			}
; 271  : 		}
; 272  : 
; 273  : 	((Unit)att)->CollectWeapons(damageMods,defmt,weapon,wcount,d);

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wcount$[ebp]
	push	ecx
	lea	edx, DWORD PTR _weapon$[ebp]
	push	edx
	mov	eax, DWORD PTR _defmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _damageMods$[ebp]
	push	ecx
	mov	edx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax+376]
	call	edx

; 274  : 	if (!weapon[0])

	mov	eax, 2
	imul	eax, 0
	movsx	ecx, WORD PTR _weapon$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN16@DoCombat

; 275  : 		return 0;								// We have no weapons to shoot

	xor	eax, eax
	jmp	$LN24@DoCombat
$LN16@DoCombat:

; 276  : 
; 277  : 	// Apply combat related bonuses
; 278  : 	bonus = CombatBonus(att->GetTeam(),((Unit)att)->GetUnitPrimaryObjID());

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+868]
	call	eax
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?CombatBonus@@YAMEVVU_ID@@@Z		; CombatBonus
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _bonus$[ebp]

; 279  : 
; 280  : 	// Unit type specific stuff
; 281  : 	if (att->IsFlight())

	mov	edx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN15@DoCombat

; 282  : 		{
; 283  : 		bonus *= AirExperienceAdjustment(att->GetCountry());

	mov	eax, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+120]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?AirExperienceAdjustment@@YAME@Z	; AirExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv628[ebp]
	movss	xmm0, DWORD PTR tv628[ebp]
	mulss	xmm0, DWORD PTR _bonus$[ebp]
	movss	DWORD PTR _bonus$[ebp], xmm0

; 284  : 		((Flight)att)->UseFuel(100);

	push	100					; 00000064H
	mov	edx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax+740]
	call	edx
	jmp	SHORT $LN13@DoCombat
$LN15@DoCombat:

; 285  : 		}
; 286  : 	else if (att->IsBattalion())

	mov	eax, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN13@DoCombat

; 287  : 		{
; 288  : 		bonus *= ((Battalion)att)->AdjustForSupply();

	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+512]
	call	eax
	fstp	DWORD PTR tv640[ebp]
	movss	xmm0, DWORD PTR tv640[ebp]
	mulss	xmm0, DWORD PTR _bonus$[ebp]
	movss	DWORD PTR _bonus$[ebp], xmm0

; 289  : 		((Battalion)att)->SetUnitFatigue(((Battalion)att)->GetUnitFatigue() + 1);

	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+884]
	call	eax
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+836]
	call	eax
$LN13@DoCombat:

; 290  : 		}
; 291  : 
; 292  : 	// Minimum bonus
; 293  : 	if (bonus < 0.01F)

	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR _bonus$[ebp]
	jbe	SHORT $LN12@DoCombat

; 294  : 		bonus = 0.01F;

	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _bonus$[ebp], xmm0
$LN12@DoCombat:

; 295  : 
; 296  : 	// Adjust by combat bonus
; 297  : 	for (i=0; i<MAX_TYPES_PER_CAMP_FIRE_MESSAGE && weapon[i] && wcount[i]; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@DoCombat
$LN10@DoCombat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN11@DoCombat:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN9@DoCombat
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _weapon$[ebp+edx*2]
	test	eax, eax
	je	SHORT $LN9@DoCombat
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _wcount$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN9@DoCombat

; 298  : 		{
; 299  : 		wcount[i] = FloatToInt32(wcount[i] * bonus);

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _wcount$[ebp+eax]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _bonus$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _wcount$[ebp+edx], al

; 300  : 		if (!wcount[i])

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _wcount$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN8@DoCombat

; 301  : 			wcount[i] = 1;				// minimum of one shot, regardless of bonuses

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _wcount$[ebp+edx], 1
$LN8@DoCombat:

; 302  : 		shot++;

	mov	eax, DWORD PTR _shot$[ebp]
	add	eax, 1
	mov	DWORD PTR _shot$[ebp], eax

; 303  : 		}

	jmp	SHORT $LN10@DoCombat
$LN9@DoCombat:

; 304  : 
; 305  : 	if (!shot)

	cmp	DWORD PTR _shot$[ebp], 0
	jne	SHORT $LN7@DoCombat

; 306  : 		return 0;

	xor	eax, eax
	jmp	$LN24@DoCombat
$LN7@DoCombat:

; 307  : 
; 308  : 	// Mark us as taking a shot (only vs other air)
; 309  : 	if (att->IsFlight() && def->IsFlight())

	mov	ecx, DWORD PTR _att$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _att$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN6@DoCombat
	mov	ecx, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN6@DoCombat

; 310  : 		((Flight)att)->SetFired(1);

	push	1
	mov	ecx, DWORD PTR _att$[ebp]
	call	?SetFired@UnitClass@@QAEXH@Z		; UnitClass::SetFired
$LN6@DoCombat:

; 311  : 
; 312  : //	if (att->IsFlight() && def->Id() == ((Flight)att)->GetUnitMissionTargetID())
; 313  : //		SetAtTarget((Flight)att);
; 314  : 
; 315  : 	// Apply the damage
; 316  : 	if (def->IsCampaign()){

	mov	ecx, DWORD PTR _def$[ebp]
	call	?IsCampaign@FalconEntity@@QAEHXZ	; FalconEntity::IsCampaign
	test	eax, eax
	je	$LN5@DoCombat

; 317  : 		if (((CampEntity)def)->IsAggregate()){

	mov	ecx, DWORD PTR _def$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	$LN4@DoCombat

; 318  : 			FalconCampWeaponsFire	*cwfm = new FalconCampWeaponsFire(def->Id(), FalconLocalGame);

	push	96					; 00000060H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN28@DoCombat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@DoCombat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv442[ebp], eax
	jmp	SHORT $LN27@DoCombat
$LN26@DoCombat:
	mov	DWORD PTR tv442[ebp], 0
$LN27@DoCombat:
	push	1
	mov	edx, DWORD PTR tv442[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _def$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0FalconCampWeaponsFire@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconCampWeaponsFire::FalconCampWeaponsFire
	mov	DWORD PTR tv453[ebp], eax
	jmp	SHORT $LN29@DoCombat
$LN28@DoCombat:
	mov	DWORD PTR tv453[ebp], 0
$LN29@DoCombat:
	mov	eax, DWORD PTR tv453[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _cwfm$7[ebp], ecx

; 319  :             cwfm->dataBlock.shooterID = att->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _att$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _cwfm$7[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 320  :             memcpy(cwfm->dataBlock.weapon, weapon, sizeof cwfm->dataBlock.weapon);

	push	16					; 00000010H
	lea	ecx, DWORD PTR _weapon$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cwfm$7[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 321  :             memcpy(cwfm->dataBlock.shots, wcount, sizeof cwfm->dataBlock.shots);

	push	8
	lea	eax, DWORD PTR _wcount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cwfm$7[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 322  : 			((CampBaseClass*)def)->ApplyDamage(cwfm, 0);

	push	0
	mov	edx, DWORD PTR _cwfm$7[ebp]
	push	edx
	mov	eax, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _def$[ebp]
	mov	eax, DWORD PTR [edx+368]
	call	eax

; 323  : 		}
; 324  : 		else{

	jmp	SHORT $LN3@DoCombat
$LN4@DoCombat:

; 325  : 			FireOnSimEntity(att, (CampBaseClass*)def, weapon, wcount, 255);

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _wcount$[ebp]
	push	ecx
	lea	edx, DWORD PTR _weapon$[ebp]
	push	edx
	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _att$[ebp]
	push	ecx
	call	?FireOnSimEntity@@YAXPAVCampBaseClass@@0QAFQAEE@Z ; FireOnSimEntity
	add	esp, 20					; 00000014H
$LN3@DoCombat:

; 326  : 		}

	jmp	SHORT $LN1@DoCombat
$LN5@DoCombat:

; 327  : 	}
; 328  : 	else if (def->IsSim()){

	mov	ecx, DWORD PTR _def$[ebp]
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN1@DoCombat

; 329  : 		FireOnSimEntity(att, (SimBaseClass*)def, weapon[0]);

	mov	edx, 2
	imul	edx, 0
	movzx	eax, WORD PTR _weapon$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _def$[ebp]
	push	ecx
	mov	edx, DWORD PTR _att$[ebp]
	push	edx
	call	?FireOnSimEntity@@YAXPAVCampBaseClass@@PAVSimBaseClass@@F@Z ; FireOnSimEntity
	add	esp, 12					; 0000000cH
$LN1@DoCombat:

; 330  : 	}
; 331  : 
; 332  : 	return shot;

	mov	eax, DWORD PTR _shot$[ebp]
$LN24@DoCombat:

; 333  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z ENDP ; DoCombat
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
tv249 = -52						; size = 4
tv288 = -48						; size = 4
tv245 = -44						; size = 4
tv241 = -40						; size = 4
tv286 = -36						; size = 4
tv237 = -32						; size = 4
tv230 = -28						; size = 4
_uran$ = -24						; size = 4
_udet$ = -20						; size = 4
_eran$ = -16						; size = 4
_det$1 = -12						; size = 4
_edet$ = -8						; size = 4
_retval$ = -4						; size = 4
_u$ = 8							; size = 4
_e$ = 12						; size = 4
_range$ = 16						; size = 4
?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z PROC	; Detected

; 178  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 179  : 	int			udet,edet,uran,eran,retval=0;

	mov	DWORD PTR _retval$[ebp], 0

; 180  : 
; 181  : 	// KCK: Someday, I should make this range squared - but it'd affect a lot of shit
; 182  : 	*range = Distance(u->XPos(),u->YPos(),e->XPos(),e->YPos()) / GRID_SIZE_FT;

	mov	ecx, DWORD PTR _e$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _e$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _u$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _u$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Distance@@YAMMMMM@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv230[ebp]
	movss	xmm0, DWORD PTR tv230[ebp]
	divss	xmm0, DWORD PTR __real@454cffae
	mov	eax, DWORD PTR _range$[ebp]
	movss	DWORD PTR [eax], xmm0

; 183  : 	if (*range < 1.0F)

	mov	ecx, DWORD PTR _range$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx]
	jbe	$LN12@Detected

; 184  : // 2001-03-26 MODIFIED BY S.G. IF THE FIRST UNIT IS BELOW THE SECOND ONE AT ANY ALTITUDE SEPARATION), OR IF ABOVE WITH LESS THAN 5000 FEET ALTITUDE SEPARATION, RETURN 'DETECTION BASED ON WHO SAW WHO'
; 185  : //		return ALL_DETECTION;
; 186  : 	{
; 187  : 		int det = 0;

	mov	DWORD PTR _det$1[ebp], 0

; 188  : 		if (u->ZPos() - e->ZPos() > -5000.0f)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv237[ebp]
	movss	xmm0, DWORD PTR tv237[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	movss	DWORD PTR tv286[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	subss	xmm0, DWORD PTR tv241[ebp]
	comiss	xmm0, DWORD PTR __real@c59c4000
	jbe	SHORT $LN11@Detected

; 189  : 			det = ENEMY_SAME_HEX | ENEMY_IN_RANGE | ENEMY_DETECTED | FRIENDLY_IN_RANGE;

	mov	DWORD PTR _det$1[ebp], 27		; 0000001bH
$LN11@Detected:

; 190  : 		if (e->ZPos() - u->ZPos() > -5000.0f)

	mov	ecx, DWORD PTR _e$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv245[ebp]
	movss	xmm0, DWORD PTR tv245[ebp]
	mov	ecx, DWORD PTR _u$[ebp]
	movss	DWORD PTR tv288[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv249[ebp]
	movss	xmm0, DWORD PTR tv288[ebp]
	subss	xmm0, DWORD PTR tv249[ebp]
	comiss	xmm0, DWORD PTR __real@c59c4000
	jbe	SHORT $LN10@Detected

; 191  : 			det |= ENEMY_SAME_HEX | ENEMY_IN_RANGE | FRIENDLY_IN_RANGE | FRIENDLY_DETECTED;

	mov	edx, DWORD PTR _det$1[ebp]
	or	edx, 30					; 0000001eH
	mov	DWORD PTR _det$1[ebp], edx
$LN10@Detected:

; 192  : 		if (det)

	cmp	DWORD PTR _det$1[ebp], 0
	je	SHORT $LN9@Detected

; 193  : 			return(det);

	mov	eax, DWORD PTR _det$1[ebp]
	jmp	$LN13@Detected
$LN9@Detected:

; 194  : 
; 195  : 		// Need to say we're in range, even if it can't detect it because we are very close
; 196  : 		uran=eran=1;

	mov	DWORD PTR _eran$[ebp], 1
	mov	eax, DWORD PTR _eran$[ebp]
	mov	DWORD PTR _uran$[ebp], eax

; 197  : 		udet=edet=0;

	mov	DWORD PTR _edet$[ebp], 0
	mov	ecx, DWORD PTR _edet$[ebp]
	mov	DWORD PTR _udet$[ebp], ecx

; 198  : 	}
; 199  : 	else

	jmp	SHORT $LN8@Detected
$LN12@Detected:

; 200  : // END OF MODIFIED SECTION
; 201  : 		uran=eran=udet=edet=0;

	mov	DWORD PTR _edet$[ebp], 0
	mov	edx, DWORD PTR _edet$[ebp]
	mov	DWORD PTR _udet$[ebp], edx
	mov	eax, DWORD PTR _udet$[ebp]
	mov	DWORD PTR _eran$[ebp], eax
	mov	ecx, DWORD PTR _eran$[ebp]
	mov	DWORD PTR _uran$[ebp], ecx
$LN8@Detected:

; 202  : 
; 203  : 	DetectOneWay(u,e,FloatToInt32(*range),&udet,&uran);

	lea	edx, DWORD PTR _uran$[ebp]
	push	edx
	lea	eax, DWORD PTR _udet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?DetectOneWay@@YAXPAVCampBaseClass@@PAVFalconEntity@@HPAH2@Z ; DetectOneWay
	add	esp, 20					; 00000014H

; 204  : 	if (e->IsUnit())

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN7@Detected

; 205  : 		DetectOneWay((Unit)e,u,FloatToInt32(*range),&edet,&eran);

	lea	ecx, DWORD PTR _eran$[ebp]
	push	ecx
	lea	edx, DWORD PTR _edet$[ebp]
	push	edx
	mov	eax, DWORD PTR _range$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?DetectOneWay@@YAXPAVCampBaseClass@@PAVFalconEntity@@HPAH2@Z ; DetectOneWay
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@Detected
$LN7@Detected:

; 206  : 	else if (e->IsAirplane())

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	SHORT $LN5@Detected

; 207  : 		edet = udet;			// KCK hack- let players spot only what spots them

	mov	ecx, DWORD PTR _udet$[ebp]
	mov	DWORD PTR _edet$[ebp], ecx
$LN5@Detected:

; 208  : 
; 209  : 	if (edet)

	cmp	DWORD PTR _edet$[ebp], 0
	je	SHORT $LN4@Detected

; 210  : 		retval |= FRIENDLY_DETECTED;

	mov	edx, DWORD PTR _retval$[ebp]
	or	edx, 4
	mov	DWORD PTR _retval$[ebp], edx
$LN4@Detected:

; 211  : 	if (eran)

	cmp	DWORD PTR _eran$[ebp], 0
	je	SHORT $LN3@Detected

; 212  : 		retval |= FRIENDLY_IN_RANGE;

	mov	eax, DWORD PTR _retval$[ebp]
	or	eax, 8
	mov	DWORD PTR _retval$[ebp], eax
$LN3@Detected:

; 213  : 	if (udet)

	cmp	DWORD PTR _udet$[ebp], 0
	je	SHORT $LN2@Detected

; 214  : 		retval |= ENEMY_DETECTED;

	mov	ecx, DWORD PTR _retval$[ebp]
	or	ecx, 1
	mov	DWORD PTR _retval$[ebp], ecx
$LN2@Detected:

; 215  : 	if (uran)

	cmp	DWORD PTR _uran$[ebp], 0
	je	SHORT $LN1@Detected

; 216  : 		retval |= ENEMY_IN_RANGE;

	mov	edx, DWORD PTR _retval$[ebp]
	or	edx, 2
	mov	DWORD PTR _retval$[ebp], edx
$LN1@Detected:

; 217  : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN13@Detected:

; 218  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z ENDP	; Detected
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
_p$ = -4						; size = 4
_u$ = 8							; size = 4
_e$ = 12						; size = 4
?EngageParent@@YAHPAVUnitClass@@PAVFalconEntity@@@Z PROC ; EngageParent

; 644  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 645  : 	Unit			p;
; 646  : 
; 647  : 	p = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _p$[ebp], eax

; 648  : 	if (!p || p->Engaged())

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN1@EngagePare
	mov	ecx, DWORD PTR _p$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN2@EngagePare
$LN1@EngagePare:

; 649  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@EngagePare
$LN2@EngagePare:

; 650  : 	p->SetTarget(e);

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _p$[ebp]
	call	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ; UnitClass::SetTarget

; 651  : 	p->SetEngaged(1);

	push	1
	mov	ecx, DWORD PTR _p$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 652  : 	return 1;

	mov	eax, 1
$LN3@EngagePare:

; 653  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?EngageParent@@YAHPAVUnitClass@@PAVFalconEntity@@@Z ENDP ; EngageParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
_cost$ = -20						; size = 4
_speed$ = -16						; size = 4
_time$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
_u$ = 8							; size = 4
_h$ = 12						; size = 1
?TimeToMove@@YAKPAVUnitClass@@E@Z PROC			; TimeToMove

; 577  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 578  : 	GridIndex		x,y;
; 579  : 	float			cost;
; 580  : 	int				speed;
; 581  : 	CampaignTime	time;
; 582  : 
; 583  : 	speed = u->GetUnitSpeed();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+516]
	call	eax
	mov	DWORD PTR _speed$[ebp], eax

; 584  : 	if (h >= Here || speed < 1){

	movzx	ecx, BYTE PTR _h$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN6@TimeToMove
	cmp	DWORD PTR _speed$[ebp], 1
	jge	SHORT $LN7@TimeToMove
$LN6@TimeToMove:

; 585  : 		return u->GetMoveTime();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+644]
	call	edx
	jmp	$LN8@TimeToMove
$LN7@TimeToMove:

; 586  : 	}
; 587  : 	u->GetLocation(&x, &y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 588  : 	x += dx[h];

	movzx	edx, BYTE PTR _h$[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	movsx	ecx, WORD PTR _x$[ebp]
	add	ecx, eax
	mov	WORD PTR _x$[ebp], cx

; 589  : 	y += dy[h];

	movzx	edx, BYTE PTR _h$[ebp]
	movsx	eax, WORD PTR ?dy@@3PAFA[edx*2]
	movsx	ecx, WORD PTR _y$[ebp]
	add	ecx, eax
	mov	WORD PTR _y$[ebp], cx

; 590  : 	// This is our movement multiple
; 591  :  	// MLR - Bounds checking??? Derrrrr Timmmmmmeeeeeeey //Cobra 10/31/04 TJL
; 592  : 	if (x < 0){

	movsx	edx, WORD PTR _x$[ebp]
	test	edx, edx
	jge	SHORT $LN5@TimeToMove

; 593  :  		x = 0;

	xor	eax, eax
	mov	WORD PTR _x$[ebp], ax
$LN5@TimeToMove:

; 594  : 	}
; 595  : 	if (y < 0){

	movsx	ecx, WORD PTR _y$[ebp]
	test	ecx, ecx
	jge	SHORT $LN4@TimeToMove

; 596  :  		y = 0;

	xor	edx, edx
	mov	WORD PTR _y$[ebp], dx
$LN4@TimeToMove:

; 597  : 	}
; 598  : 	if (x >= Map_Max_X){

	movsx	eax, WORD PTR _x$[ebp]
	movsx	ecx, WORD PTR ?Map_Max_X@@3FA		; Map_Max_X
	cmp	eax, ecx
	jl	SHORT $LN3@TimeToMove

; 599  :  		x = (GridIndex)(Map_Max_X - 1);

	movsx	edx, WORD PTR ?Map_Max_X@@3FA		; Map_Max_X
	sub	edx, 1
	mov	WORD PTR _x$[ebp], dx
$LN3@TimeToMove:

; 600  : 	}
; 601  : 	if (y >= Map_Max_Y){

	movsx	eax, WORD PTR _y$[ebp]
	movsx	ecx, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	cmp	eax, ecx
	jl	SHORT $LN2@TimeToMove

; 602  :  		y = (GridIndex)(Map_Max_Y - 1);

	movsx	edx, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	sub	edx, 1
	mov	WORD PTR _y$[ebp], dx
$LN2@TimeToMove:

; 603  : 	}
; 604  : 	cost = u->GetUnitMovementCost(x,y,h);

	movzx	eax, BYTE PTR _h$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitMovementCost@UnitClass@@QAEMFFE@Z ; UnitClass::GetUnitMovementCost
	fstp	DWORD PTR _cost$[ebp]

; 605  : 	// Adjust by our speed.
; 606  : 	time = (CampaignTime)TimeToArrive(cost,(float)speed);

	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cost$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	mov	DWORD PTR _time$[ebp], eax

; 607  : 	if (time < CampaignSeconds){

	cmp	DWORD PTR _time$[ebp], 1000		; 000003e8H
	jae	SHORT $LN1@TimeToMove

; 608  : 		time = CampaignSeconds;

	mov	DWORD PTR _time$[ebp], 1000		; 000003e8H
$LN1@TimeToMove:

; 609  : 	}
; 610  : 	return time;

	mov	eax, DWORD PTR _time$[ebp]
$LN8@TimeToMove:

; 611  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TimeToMove@@YAKPAVUnitClass@@E@Z ENDP			; TimeToMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
$T2 = -276						; size = 8
$T3 = -268						; size = 8
$T4 = -260						; size = 8
$T5 = -252						; size = 8
$T6 = -244						; size = 8
$T7 = -236						; size = 8
$T8 = -228						; size = 8
$T9 = -220						; size = 8
$T10 = -212						; size = 8
$T11 = -204						; size = 8
$T12 = -196						; size = 8
$T13 = -188						; size = 8
$T14 = -180						; size = 8
_speed$ = -172						; size = 4
$T15 = -168						; size = 4
$T16 = -164						; size = 4
$T17 = -160						; size = 4
$T18 = -156						; size = 4
$T19 = -152						; size = 4
$T20 = -148						; size = 4
_fac$21 = -144						; size = 4
$T22 = -140						; size = 4
tv169 = -136						; size = 4
$T23 = -132						; size = 4
$T24 = -128						; size = 4
tv324 = -124						; size = 4
tv935 = -120						; size = 4
$T25 = -116						; size = 4
tv825 = -112						; size = 4
tv313 = -108						; size = 4
_action$ = -104						; size = 4
tv180 = -100						; size = 4
tv821 = -96						; size = 4
tv390 = -92						; size = 4
tv694 = -88						; size = 4
$T26 = -84						; size = 4
$T27 = -80						; size = 4
tv251 = -76						; size = 4
tv690 = -72						; size = 4
tv240 = -68						; size = 4
_lead$28 = -64						; size = 4
$T29 = -60						; size = 4
tv401 = -56						; size = 4
_sq$30 = -52						; size = 4
tv946 = -48						; size = 4
$T31 = -44						; size = 4
tv73 = -40						; size = 4
_team$32 = -36						; size = 4
_msg$33 = -32						; size = 4
_pw$ = -28						; size = 4
_msg$34 = -24						; size = 4
_w$ = -20						; size = 4
_msg$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
?DoWPAction@@YAHPAVFlightClass@@@Z PROC			; DoWPAction

; 343  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoWPAction@@YAHPAVFlightClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 344  :     int      	action = WP_NOTHING,speed;

	mov	DWORD PTR _action$[ebp], 0

; 345  : 	WayPoint	w,pw;
; 346  : 	FalconRadioChatterMessage	*msg;
; 347  : 
; 348  : 	w = u->GetCurrentUnitWP();									// Find this unit's WP action

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 349  : 	if (!w)

	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN38@DoWPAction

; 350  : 		return 0;

	xor	eax, eax
	jmp	$LN39@DoWPAction
$LN38@DoWPAction:

; 351  : 	action = w->GetWPAction();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	mov	DWORD PTR _action$[ebp], eax

; 352  : 
; 353  : 	// Check Actions
; 354  :     switch (action)

	mov	eax, DWORD PTR _action$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 24			; 00000018H
	ja	$LN36@DoWPAction
	mov	edx, DWORD PTR tv73[ebp]
	movzx	eax, BYTE PTR $LN76@DoWPAction[edx]
	jmp	DWORD PTR $LN78@DoWPAction[eax*4]
$LN35@DoWPAction:

; 355  : 		{
; 356  : 		case WP_TAKEOFF:
; 357  : 			{
; 358  : #ifdef KEV_DEBUG
; 359  : //noprint			MonoPrint("Unit %d taking off at time %d / %d.\n", u->GetCampID(), Camp_GetCurrentTime(), w->GetWPArrivalTime());
; 360  : #endif
; 361  : 			AircraftLaunch(u); // Tell UI

	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?AircraftLaunch@@YAXPAVFlightClass@@@Z	; AircraftLaunch
	add	esp, 4

; 362  : 			// Rack up a mission
; 363  : 			Squadron	sq = (Squadron) u->GetUnitSquadron();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+696]
	call	edx
	mov	DWORD PTR _sq$30[ebp], eax

; 364  : 			if (sq)

	cmp	DWORD PTR _sq$30[ebp], 0
	je	SHORT $LN34@DoWPAction

; 365  : 				sq->SendUnitMessage(u->Id(),FalconUnitMessage::unitStatistics,0,ASTAT_MISSIONS,1);

	push	1
	push	4
	push	0
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _sq$30[ebp]
	call	?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::SendUnitMessage
$LN34@DoWPAction:

; 366  : 			}
; 367  : 			break;

	jmp	$LN36@DoWPAction
$LN33@DoWPAction:

; 368  : 		case WP_ASSEMBLE:
; 369  : 			// Radio Chatter messages
; 370  : 			if (!u->GetUnitMissionID())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+688]
	call	eax
	test	eax, eax
	jne	$LN32@DoWPAction

; 371  : 				{
; 372  : 				// Main flight
; 373  : 				msg = new FalconRadioChatterMessage(u->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T29[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T29[ebp], 0
	je	SHORT $LN43@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN41@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN42@DoWPAction
$LN41@DoWPAction:
	mov	DWORD PTR tv169[ebp], 0
$LN42@DoWPAction:
	push	1
	mov	edx, DWORD PTR tv169[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T29[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN44@DoWPAction
$LN43@DoWPAction:
	mov	DWORD PTR tv180[ebp], 0
$LN44@DoWPAction:
	mov	eax, DWORD PTR tv180[ebp]
	mov	DWORD PTR $T22[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T22[ebp]
	mov	DWORD PTR _msg$[ebp], ecx

; 374  : 				msg->dataBlock.from = u->Id();

	lea	edx, DWORD PTR $T14[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 375  : 				msg->dataBlock.to = MESSAGE_FOR_PACKAGE;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [ecx+60], 2

; 376  : 				msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+61], al

; 377  : 				msg->dataBlock.message = rcPACKJOINED;

	mov	eax, 135				; 00000087H
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+62], ax

; 378  : 				msg->dataBlock.edata[0] = u->callsign_id;

	mov	edx, DWORD PTR _u$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 379  : 				msg->dataBlock.edata[1] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 380  : 				FalconSendMessage(msg, FALSE);

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 381  : 				msg = new FalconRadioChatterMessage(u->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T23[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T23[ebp], 0
	je	SHORT $LN47@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN45@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv240[ebp], eax
	jmp	SHORT $LN46@DoWPAction
$LN45@DoWPAction:
	mov	DWORD PTR tv240[ebp], 0
$LN46@DoWPAction:
	push	1
	mov	edx, DWORD PTR tv240[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T23[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv251[ebp], eax
	jmp	SHORT $LN48@DoWPAction
$LN47@DoWPAction:
	mov	DWORD PTR tv251[ebp], 0
$LN48@DoWPAction:
	mov	eax, DWORD PTR tv251[ebp]
	mov	DWORD PTR $T17[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR _msg$[ebp], ecx

; 382  : 				msg->dataBlock.from = u->Id();

	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 383  : 				msg->dataBlock.to = MESSAGE_FOR_PACKAGE;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [ecx+60], 2

; 384  : 				msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+61], al

; 385  : 				msg->dataBlock.message = rcPACKDEPARTING;

	mov	eax, 133				; 00000085H
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+62], ax

; 386  : 				msg->dataBlock.edata[0] = u->callsign_id;

	mov	edx, DWORD PTR _u$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 387  : 				msg->dataBlock.edata[1] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 388  : 				msg->dataBlock.time_to_play = 2 * CampaignSeconds;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [eax+56], 2000		; 000007d0H

; 389  : 				FalconSendMessage(msg, FALSE);

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 390  : 				FalconRadioChatterMessage *msg = new FalconRadioChatterMessage(u->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T26[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T26[ebp], 0
	je	SHORT $LN51@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN49@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv313[ebp], eax
	jmp	SHORT $LN50@DoWPAction
$LN49@DoWPAction:
	mov	DWORD PTR tv313[ebp], 0
$LN50@DoWPAction:
	push	1
	mov	eax, DWORD PTR tv313[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T26[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv324[ebp], eax
	jmp	SHORT $LN52@DoWPAction
$LN51@DoWPAction:
	mov	DWORD PTR tv324[ebp], 0
$LN52@DoWPAction:
	mov	ecx, DWORD PTR tv324[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T19[ebp]
	mov	DWORD PTR _msg$34[ebp], edx

; 391  : 				msg->dataBlock.from = u->Id();

	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$34[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 392  : 				msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	ecx, DWORD PTR _msg$34[ebp]
	mov	BYTE PTR [ecx+60], 1

; 393  : 				msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$34[ebp]
	mov	BYTE PTR [edx+61], al

; 394  : 				msg->dataBlock.message = rcFLIGHTIN;

	mov	eax, 74					; 0000004aH
	mov	ecx, DWORD PTR _msg$34[ebp]
	mov	WORD PTR [ecx+62], ax

; 395  : 				msg->dataBlock.edata[0] = u->callsign_id;

	mov	edx, DWORD PTR _u$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$34[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 396  : 				msg->dataBlock.edata[1] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$34[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 397  : 				//M.N. changed to 32767 -> flexibly use randomized value of max available eval indexes
; 398  : 				msg->dataBlock.edata[2] = 32767;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 32767				; 00007fffH
	mov	edx, DWORD PTR _msg$34[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 399  : 				msg->dataBlock.time_to_play = 4 * CampaignSeconds;

	mov	eax, DWORD PTR _msg$34[ebp]
	mov	DWORD PTR [eax+56], 4000		; 00000fa0H

; 400  : 				FalconSendMessage(msg, FALSE);

	push	0
	mov	ecx, DWORD PTR _msg$34[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 401  : 				}
; 402  : 			else

	jmp	$LN31@DoWPAction
$LN32@DoWPAction:

; 403  : 				{
; 404  : 				// non main flight arriving at assembly point
; 405  : 				// KCK: We may want to skip this if the package has already departed
; 406  : 				msg = new FalconRadioChatterMessage(u->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN55@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN53@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv390[ebp], eax
	jmp	SHORT $LN54@DoWPAction
$LN53@DoWPAction:
	mov	DWORD PTR tv390[ebp], 0
$LN54@DoWPAction:
	push	1
	mov	eax, DWORD PTR tv390[ebp]
	push	eax
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T25[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv401[ebp], eax
	jmp	SHORT $LN56@DoWPAction
$LN55@DoWPAction:
	mov	DWORD PTR tv401[ebp], 0
$LN56@DoWPAction:
	mov	ecx, DWORD PTR tv401[ebp]
	mov	DWORD PTR $T15[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T15[ebp]
	mov	DWORD PTR _msg$[ebp], edx

; 407  : 				msg->dataBlock.from = u->Id();

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 408  : 				msg->dataBlock.to = MESSAGE_FOR_PACKAGE;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [ecx+60], 2

; 409  : 				msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+61], al

; 410  : 				msg->dataBlock.message = rcPACKATJOIN;

	mov	eax, 129				; 00000081H
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+62], ax

; 411  : 				msg->dataBlock.edata[0] = -1;

	mov	edx, 2
	imul	edx, 0
	or	eax, -1
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 412  : 				msg->dataBlock.edata[1] = -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 413  : 				msg->dataBlock.edata[2] = u->callsign_id;

	mov	edx, DWORD PTR _u$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 414  : 				msg->dataBlock.edata[3] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 415  : 				FalconSendMessage(msg, FALSE);

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN31@DoWPAction:

; 416  : 				}
; 417  : 			break;

	jmp	$LN36@DoWPAction
$LN30@DoWPAction:

; 418  : 		case WP_POSTASSEMBLE:
; 419  : 			// We're done with our task, so we can now be reassigned
; 420  : 			u->SetUnitPriority(0);								

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+612]
	call	eax

; 421  : 			break;

	jmp	$LN36@DoWPAction
$LN29@DoWPAction:

; 422  : 		case WP_REARM:       
; 423  : 		case WP_REFUEL:
; 424  : 			u->SetBurntFuel(0);

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+600]
	call	eax

; 425  : 			pw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _pw$[ebp], eax

; 426  : 			if (!pw)

	cmp	DWORD PTR _pw$[ebp], 0
	jne	SHORT $LN28@DoWPAction

; 427  : 				GoHome((Flight)u);

	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?GoHome@@YAXPAVFlightClass@@@Z		; GoHome
	add	esp, 4
$LN28@DoWPAction:

; 428  : 			break;

	jmp	$LN36@DoWPAction
$LN27@DoWPAction:

; 429  : 		case WP_CASCP:
; 430  : 			{
; 431  : 			Flight		fac = u->GetFACFlight();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFACFlight@FlightClass@@QAEPAV1@XZ	; FlightClass::GetFACFlight
	mov	DWORD PTR _fac$21[ebp], eax

; 432  : 
; 433  : 			AircraftClass* lead = (AircraftClass*)u->GetComponentLead();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetComponentLead@CampBaseClass@@QAEPAVSimBaseClass@@XZ ; CampBaseClass::GetComponentLead
	mov	DWORD PTR _lead$28[ebp], eax

; 434  : 			// If we've got a FAC flight attached to us, send it a message
; 435  : 			// there has to be someone alive to talk
; 436  : 			if (fac && lead)

	cmp	DWORD PTR _fac$21[ebp], 0
	je	SHORT $LN26@DoWPAction
	cmp	DWORD PTR _lead$28[ebp], 0
	je	SHORT $LN26@DoWPAction

; 437  : 				{
; 438  : 				SendCallToAWACS(lead, rcFACCONTACT);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	push	69					; 00000045H
	mov	edx, DWORD PTR _lead$28[ebp]
	push	edx
	call	?SendCallToAWACS@@YAXPAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallToAWACS
	add	esp, 12					; 0000000cH
$LN26@DoWPAction:

; 439  : 				// SendCallToAWACS(lead, rcFACREADY); // JPO removed so it doesn't collide with previous - could delay instead.
; 440  : 				}
; 441  : 			}
; 442  : 			break;

	jmp	$LN36@DoWPAction
$LN25@DoWPAction:

; 443  : 		case WP_LAND:		
; 444  : 			// We're either landing mid-mission or as part of our mission -
; 445  : 			// Check if we're planning to take off again!
; 446  : 			pw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _pw$[ebp], eax

; 447  : 			if (!pw || (!(w->GetWPFlags() & WPF_TAKEOFF) && pw->GetWPAction() != WP_TAKEOFF))

	cmp	DWORD PTR _pw$[ebp], 0
	je	SHORT $LN23@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 128				; 00000080H
	jne	SHORT $LN24@DoWPAction
	mov	ecx, DWORD PTR _pw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	je	SHORT $LN24@DoWPAction
$LN23@DoWPAction:

; 448  : 				{
; 449  : 				UpdateSquadronStatus(u, TRUE, FALSE);

	push	0
	push	1
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?UpdateSquadronStatus@@YAXPAVFlightClass@@HH@Z ; UpdateSquadronStatus
	add	esp, 12					; 0000000cH

; 450  : 				return -1;

	or	eax, -1
	jmp	$LN39@DoWPAction
$LN24@DoWPAction:

; 451  : 				}
; 452  : 			// Check if this was an airlift mission, and give us supplies, if so
; 453  : 			if (u->GetUnitMission() == AMIS_AIRLIFT)

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 33					; 00000021H
	jne	$LN22@DoWPAction

; 454  : 				{
; 455  : 				int		team = u->GetTeam();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _team$32[ebp], ecx

; 456  : 				// RV - Biker - Make airlift supply dependent on package strength
; 457  : 				TeamInfo[team]->SetSupplyAvail(TeamInfo[team]->GetSupplyAvail() + AIRLIFT_SUPPLIES*u->CountUnitElements()/3);

	mov	edx, DWORD PTR _team$32[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetSupplyAvail@TeamClass@@QAEGXZ	; TeamClass::GetSupplyAvail
	movzx	esi, ax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?CountUnitElements@UnitClass@@QAEHXZ	; UnitClass::CountUnitElements
	imul	eax, 3
	cdq
	mov	ecx, 3
	idiv	ecx
	add	esi, eax
	push	esi
	mov	edx, DWORD PTR _team$32[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetSupplyAvail@TeamClass@@QAEXH@Z	; TeamClass::SetSupplyAvail

; 458  : 				TeamInfo[team]->SetFuelAvail(TeamInfo[team]->GetFuelAvail() + AIRLIFT_FUEL*u->CountUnitElements()/3);

	mov	eax, DWORD PTR _team$32[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetFuelAvail@TeamClass@@QAEGXZ		; TeamClass::GetFuelAvail
	movzx	esi, ax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?CountUnitElements@UnitClass@@QAEHXZ	; UnitClass::CountUnitElements
	imul	eax, 3
	cdq
	mov	ecx, 3
	idiv	ecx
	add	esi, eax
	push	esi
	mov	edx, DWORD PTR _team$32[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetFuelAvail@TeamClass@@QAEXH@Z	; TeamClass::SetFuelAvail

; 459  : 				TeamInfo[team]->SetReplacementsAvail(TeamInfo[team]->GetReplacementsAvail() + AIRLIFT_REPLACEMENTS*u->CountUnitElements()/3);

	mov	eax, DWORD PTR _team$32[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	esi, ax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?CountUnitElements@UnitClass@@QAEHXZ	; UnitClass::CountUnitElements
	imul	eax, 3
	cdq
	mov	ecx, 3
	idiv	ecx
	add	esi, eax
	push	esi
	mov	edx, DWORD PTR _team$32[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail
$LN22@DoWPAction:

; 460  : #ifdef DEBUG
; 461  : 				gSupplyFromAirlift[team] += AIRLIFT_SUPPLIES;
; 462  : 				gFuelFromAirlift[team] += AIRLIFT_FUEL;
; 463  : 				gReplacmentsFromAirlift[team] += AIRLIFT_REPLACEMENTS;
; 464  : #endif
; 465  : 			}
; 466  : 			if (pw->GetWPAction() == WP_TAKEOFF)

	mov	ecx, DWORD PTR _pw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN21@DoWPAction

; 467  : 				u->SetCurrentUnitWP(pw);

	mov	eax, DWORD PTR _pw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ; UnitClass::SetCurrentUnitWP
$LN21@DoWPAction:

; 468  : 			break;

	jmp	SHORT $LN36@DoWPAction
$LN20@DoWPAction:

; 469  : 		case WP_AIRDROP:
; 470  : 			if (u->Cargo())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	je	SHORT $LN19@DoWPAction

; 471  : 				{
; 472  : 				// Drop off our cargo unit
; 473  : 				u->UnloadUnit();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?UnloadUnit@UnitClass@@QAEXXZ		; UnitClass::UnloadUnit
$LN19@DoWPAction:

; 474  : 				}
; 475  : 			break;

	jmp	SHORT $LN36@DoWPAction
$LN18@DoWPAction:

; 476  : 		case WP_PICKUP:
; 477  : 			// Pick up a unit
; 478  : 			if (u->GetUnitMission() == AMIS_AIRCAV && !u->Cargo())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN36@DoWPAction
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	SHORT $LN36@DoWPAction

; 479  : 				u->LoadUnit(NULL);

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	call	?LoadUnit@UnitClass@@QAEXPAV1@@Z	; UnitClass::LoadUnit
$LN36@DoWPAction:

; 480  : 			break;
; 481  : 		default:
; 482  :             break;
; 483  : 		}
; 484  : 		
; 485  : 	// Check Flags
; 486  : 	if ((w->GetWPFlags() & WPF_REPEAT) || (w->GetWPFlags() & WPF_REPEAT_CONTINUOUS))

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 64					; 00000040H
	jne	SHORT $LN14@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 4096				; 00001000H
	je	$LN15@DoWPAction
$LN14@DoWPAction:

; 487  : 		{
; 488  : 		speed = u->GetCruiseSpeed();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	mov	DWORD PTR _speed$[ebp], eax

; 489  : 		// Check if we've been here long enough
; 490  : 		if (Camp_GetCurrentTime() > w->GetWPDepartureTime() && !(w->GetWPFlags() & WPF_REPEAT_CONTINUOUS))

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	esi, eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	cmp	esi, eax
	jbe	$LN13@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 4096				; 00001000H
	jne	$LN13@DoWPAction

; 491  : 			{
; 492  : 			// If so, go on to the next wp and adjust their times from now.
; 493  : 			u->SetCurrentUnitWP(w->GetNextWP());

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ; UnitClass::SetCurrentUnitWP

; 494  : 			u->AdjustWayPoints();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?AdjustWayPoints@UnitClass@@QAEXXZ	; UnitClass::AdjustWayPoints

; 495  : 			if (u->GetUnitMission() == AMIS_AWACS)

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 26					; 0000001aH
	jne	$LN12@DoWPAction

; 496  : 				{
; 497  : 				// AWACS off station
; 498  : 				msg = new FalconRadioChatterMessage(FalconNullId, FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T27[ebp], 0
	je	SHORT $LN59@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN57@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv690[ebp], eax
	jmp	SHORT $LN58@DoWPAction
$LN57@DoWPAction:
	mov	DWORD PTR tv690[ebp], 0
$LN58@DoWPAction:
	push	1
	mov	edx, DWORD PTR tv690[ebp]
	push	edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	ecx
	mov	ecx, DWORD PTR $T27[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv694[ebp], eax
	jmp	SHORT $LN60@DoWPAction
$LN59@DoWPAction:
	mov	DWORD PTR tv694[ebp], 0
$LN60@DoWPAction:
	mov	edx, DWORD PTR tv694[ebp]
	mov	DWORD PTR $T20[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T20[ebp]
	mov	DWORD PTR _msg$[ebp], eax

; 499  : 				msg->dataBlock.from = u->Id();

	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 500  : 				msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+60], 1

; 501  : 				msg->dataBlock.message = rcAWACSOFF;

	mov	eax, 23					; 00000017H
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+62], ax

; 502  : 				msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+61], al

; 503  : 				msg->dataBlock.edata[0] = u->callsign_id;

	mov	eax, DWORD PTR _u$[ebp]
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _msg$[ebp]
	mov	WORD PTR [eax+edx+64], cx

; 504  : 				msg->dataBlock.edata[1] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 505  : 				FalconSendMessage(msg, FALSE);

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN12@DoWPAction:

; 506  : 				}
; 507  : 			}
; 508  : 		else

	jmp	SHORT $LN15@DoWPAction
$LN13@DoWPAction:

; 509  : 			{
; 510  : 			// If not, restore previous WP and readjust times
; 511  : 			pw = w->GetPrevWP ();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _pw$[ebp], eax

; 512  : 			u->SetCurrentUnitWP (pw);

	mov	ecx, DWORD PTR _pw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ; UnitClass::SetCurrentUnitWP

; 513  : 			u->AdjustWayPoints();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?AdjustWayPoints@UnitClass@@QAEXXZ	; UnitClass::AdjustWayPoints
$LN15@DoWPAction:

; 514  : 			}
; 515  : 		}
; 516  : 	if (w->GetWPFlags() & WPF_CP)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 32					; 00000020H
	je	$LN10@DoWPAction

; 517  : 		{
; 518  : 		if (u->GetUnitPriority() > 0 && u->GetUnitMission() == AMIS_AWACS)

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+676]
	call	edx
	test	eax, eax
	jle	$LN9@DoWPAction
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 26					; 0000001aH
	jne	$LN9@DoWPAction

; 519  : 			{
; 520  : 			// AWACs on station
; 521  : 			msg = new FalconRadioChatterMessage(FalconNullId, FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T31[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T31[ebp], 0
	je	SHORT $LN63@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN61@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv821[ebp], eax
	jmp	SHORT $LN62@DoWPAction
$LN61@DoWPAction:
	mov	DWORD PTR tv821[ebp], 0
$LN62@DoWPAction:
	push	1
	mov	edx, DWORD PTR tv821[ebp]
	push	edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	ecx
	mov	ecx, DWORD PTR $T31[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv825[ebp], eax
	jmp	SHORT $LN64@DoWPAction
$LN63@DoWPAction:
	mov	DWORD PTR tv825[ebp], 0
$LN64@DoWPAction:
	mov	edx, DWORD PTR tv825[ebp]
	mov	DWORD PTR $T18[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR _msg$[ebp], eax

; 522  : 			msg->dataBlock.from = u->Id();

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 523  : 			msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+60], 1

; 524  : 			msg->dataBlock.message = rcAWACSON;

	mov	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [ecx+62], ax

; 525  : 			msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+61], al

; 526  : 			msg->dataBlock.edata[0] = u->callsign_id;

	mov	eax, DWORD PTR _u$[ebp]
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _msg$[ebp]
	mov	WORD PTR [eax+edx+64], cx

; 527  : 			msg->dataBlock.edata[1] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 528  : 			FalconSendMessage(msg, FALSE);

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
	jmp	SHORT $LN8@DoWPAction
$LN9@DoWPAction:

; 529  : 			}
; 530  : 		else if (u->GetUnitMission() == AMIS_TANKER && !u->IsTacan())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 28					; 0000001cH
	jne	SHORT $LN8@DoWPAction
	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsTacan@CampBaseClass@@QAEHXZ		; CampBaseClass::IsTacan
	test	eax, eax
	jne	SHORT $LN8@DoWPAction

; 531  : 			{
; 532  : 			// Tanker on station
; 533  : 			u->SetTacan(1);

	push	1
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetTacan@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetTacan
$LN8@DoWPAction:

; 534  : 			}
; 535  : 		u->SetUnitPriority(0);								// We're just hanging out here... waiting for something to do.

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+612]
	call	eax
$LN10@DoWPAction:

; 536  : 		}
; 537  : 	if (w->GetWPFlags() & WPF_TARGET && !(w->GetWPFlags() & WPF_LAND) && !(w->GetWPFlags() & WPF_TAKEOFF) && !(w->GetWPFlags() & WPF_CP) && !(w->GetWPFlags() & WPF_REPEAT))

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	$LN6@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 256				; 00000100H
	jne	$LN6@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 128				; 00000080H
	jne	$LN6@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 32					; 00000020H
	jne	$LN6@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 64					; 00000040H
	jne	$LN6@DoWPAction

; 538  : 		{
; 539  : 		// Radio Chatter message
; 540  : 		FalconRadioChatterMessage *msg = new FalconRadioChatterMessage(u->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN67@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN65@DoWPAction
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv935[ebp], eax
	jmp	SHORT $LN66@DoWPAction
$LN65@DoWPAction:
	mov	DWORD PTR tv935[ebp], 0
$LN66@DoWPAction:
	push	1
	mov	edx, DWORD PTR tv935[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv946[ebp], eax
	jmp	SHORT $LN68@DoWPAction
$LN67@DoWPAction:
	mov	DWORD PTR tv946[ebp], 0
$LN68@DoWPAction:
	mov	eax, DWORD PTR tv946[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR _msg$33[ebp], ecx

; 541  : 		msg->dataBlock.from = u->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$33[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 542  : 		msg->dataBlock.to = MESSAGE_FOR_PACKAGE;

	mov	ecx, DWORD PTR _msg$33[ebp]
	mov	BYTE PTR [ecx+60], 2

; 543  : 		msg->dataBlock.voice_id = u->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$33[ebp]
	mov	BYTE PTR [edx+61], al

; 544  : 		msg->dataBlock.message = rcFLIGHTOFF;

	mov	eax, 75					; 0000004bH
	mov	ecx, DWORD PTR _msg$33[ebp]
	mov	WORD PTR [ecx+62], ax

; 545  : 		msg->dataBlock.edata[0] = u->callsign_id;

	mov	edx, DWORD PTR _u$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$33[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 546  : 		msg->dataBlock.edata[1] = u->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$33[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 547  : 		FalconSendMessage(msg, FALSE);

	push	0
	mov	eax, DWORD PTR _msg$33[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN6@DoWPAction:

; 548  : 		}
; 549  : 	if (w->GetWPFlags() & WPF_DIVERT)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 512				; 00000200H
	je	SHORT $LN5@DoWPAction

; 550  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN39@DoWPAction
	jmp	SHORT $LN4@DoWPAction
$LN5@DoWPAction:

; 551  : 	else if (u->Diverted())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Diverted@UnitClass@@QAEHXZ		; UnitClass::Diverted
	test	eax, eax
	je	SHORT $LN4@DoWPAction

; 552  : 		{
; 553  : 		// We're back on our standard route
; 554  : 		u->SetDiverted(0);

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetDiverted@UnitClass@@QAEXH@Z		; UnitClass::SetDiverted
$LN4@DoWPAction:

; 555  : 		// KCK NOTE: We might want to check for abort here.
; 556  : 		}
; 557  : 	if (w->GetWPFlags() & WPF_TARGET || w->GetWPFlags() & WPF_TURNPOINT)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	jne	SHORT $LN1@DoWPAction
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 16					; 00000010H
	je	SHORT $LN2@DoWPAction
$LN1@DoWPAction:

; 558  : 		u->SetUnitPriority(0);								// We're done with our task, so we can now be reassigned

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+612]
	call	eax
$LN2@DoWPAction:

; 559  : 
; 560  : 	return 1;

	mov	eax, 1
$LN39@DoWPAction:

; 561  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN78@DoWPAction:
	DD	$LN35@DoWPAction
	DD	$LN33@DoWPAction
	DD	$LN30@DoWPAction
	DD	$LN29@DoWPAction
	DD	$LN18@DoWPAction
	DD	$LN25@DoWPAction
	DD	$LN27@DoWPAction
	DD	$LN20@DoWPAction
	DD	$LN36@DoWPAction
$LN76@DoWPAction:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	5
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$0:
	mov	eax, DWORD PTR $T29[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$1:
	mov	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$2:
	mov	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$3:
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$4:
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$5:
	mov	eax, DWORD PTR $T31[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoWPAction@@YAHPAVFlightClass@@@Z$6:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DoWPAction@@YAHPAVFlightClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoWPAction@@YAHPAVFlightClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoWPAction@@YAHPAVFlightClass@@@Z ENDP			; DoWPAction
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\update.cpp
_TEXT	SEGMENT
tv173 = -16						; size = 4
_lastCheck$ = -12					; size = 4
_x$1 = -8						; size = 2
_y$2 = -4						; size = 2
_u$ = 8							; size = 4
_DeltaTime$ = 12					; size = 4
?UpdateUnit@@YAHPAVUnitClass@@K@Z PROC			; UpdateUnit

; 87   : int UpdateUnit(Unit u, CampaignTime DeltaTime){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 88   : 	// Check for movement
; 89   : 
; 90   : 	//START_PROFILE("UU REMOVE");
; 91   : 	// sfr: real and father units never removed here
; 92   : 	// @todo remove
; 93   : 	if (u->IsDead() && !u->Real() && !u->Father()){

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	je	SHORT $LN8@UpdateUnit
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@UpdateUnit
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@UpdateUnit

; 94   : 		// Check if our death timeout is up
; 95   : 		// Otherwise, keep this guy around for a while - for new events or other stuff
; 96   : 		if (TheCampaign.CurrentTime - u->GetLastCheck() > DEATH_TIMEOUT_MS){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, eax
	cmp	ecx, 7200000				; 006ddd00H
	jbe	SHORT $LN7@UpdateUnit

; 97   : 			vuDatabase->Remove(u);

	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
$LN7@UpdateUnit:

; 98   : 		}
; 99   : 		return -1;

	or	eax, -1
	jmp	$LN9@UpdateUnit
$LN8@UpdateUnit:

; 100  : 	}
; 101  : 	//STOP_PROFILE("UU REMOVE");
; 102  : 
; 103  : 	//START_PROFILE("UU UNSET");
; 104  : 	u->UnsetChecked();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?UnsetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetChecked

; 105  : 	//STOP_PROFILE("UU UNSET");
; 106  : 
; 107  : #define FIX_RESET_UNIT 1
; 108  : 	CampaignTime lastCheck = u->GetLastCheck();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	mov	DWORD PTR _lastCheck$[ebp], eax

; 109  : 	if (
; 110  : #if FIX_RESET_UNIT
; 111  : 		(lastCheck == 0) || 
; 112  : #endif
; 113  : 		(TheCampaign.CurrentTime - lastCheck > u->UpdateTime())
; 114  : 	){

	cmp	DWORD PTR _lastCheck$[ebp], 0
	je	SHORT $LN5@UpdateUnit
	mov	esi, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	esi, DWORD PTR _lastCheck$[ebp]
	mov	ecx, DWORD PTR _u$[ebp]
	call	?UpdateTime@UnitClass@@QBEKXZ		; UnitClass::UpdateTime
	cmp	esi, eax
	jbe	$LN6@UpdateUnit
$LN5@UpdateUnit:

; 115  : 		//START_PROFILE("UU SET");
; 116  : 		u->SetLastCheck(TheCampaign.CurrentTime);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck

; 117  : 		//STOP_PROFILE("UU SET");
; 118  : 
; 119  : 		if (u->Real() && !u->GetRoster()){

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	je	SHORT $LN4@UpdateUnit
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetRoster@UnitClass@@QAEJXZ		; UnitClass::GetRoster
	test	eax, eax
	jne	SHORT $LN4@UpdateUnit

; 120  : 			//START_PROFILE("UU KILL");
; 121  : 			u->KillUnit();				// Unit is out of vehicles, kill it off

	mov	ecx, DWORD PTR _u$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit

; 122  : 			//STOP_PROFILE("UU KILL");
; 123  : 			return -1;

	or	eax, -1
	jmp	$LN9@UpdateUnit

; 124  : 		}
; 125  : 		else {

	jmp	SHORT $LN3@UpdateUnit
$LN4@UpdateUnit:

; 126  : 			//START_PROFILE("UU MOVE");
; 127  : 			u->MoveUnit(u->GetMoveTime());

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+644]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+488]
	call	eax
$LN3@UpdateUnit:

; 128  : 			//STOP_PROFILE("UU MOVE");
; 129  : 		}
; 130  : 
; 131  : 		
; 132  : 		//START_PROFILE("UU WP");
; 133  : 		// In tactical engagement, we want to make sure battalions always have a waypoint,
; 134  : 		// So they can be reordered
; 135  : 		if (
; 136  : 			u->IsBattalion() && 
; 137  : 			FalconLocalGame->GetGameType() == game_TacticalEngagement && 
; 138  : 			!u->GetCurrentUnitWP()
; 139  : 		){

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN6@UpdateUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@UpdateUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN12@UpdateUnit
$LN11@UpdateUnit:
	mov	DWORD PTR tv173[ebp], 0
$LN12@UpdateUnit:
	mov	ecx, DWORD PTR tv173[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN6@UpdateUnit
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	test	eax, eax
	jne	SHORT $LN6@UpdateUnit

; 140  : 			GridIndex		x,y;
; 141  : 			u->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$2[ebp]
	push	edx
	lea	eax, DWORD PTR _x$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 142  : 			u->AddUnitWP(x,y,0,0,0,0,WP_MOVEUNOPPOSED);

	push	41					; 00000029H
	push	0
	push	0
	push	0
	push	0
	movzx	ecx, WORD PTR _y$2[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP
$LN6@UpdateUnit:

; 143  : 		}
; 144  : 		//STOP_PROFILE("UU WP");
; 145  : 	}
; 146  : 
; 147  : 	//START_PROFILE("UU COMBAT");
; 148  : 	// Check for combat
; 149  : 	if (u->Real() && u->IsAggregate() && u->GetCombatTime() > u->CombatTime()){

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	je	SHORT $LN1@UpdateUnit
	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN1@UpdateUnit
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+648]
	call	eax
	mov	esi, eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+532]
	call	eax
	cmp	esi, eax
	jbe	SHORT $LN1@UpdateUnit

; 150  : 		u->ChooseTarget();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+524]
	call	eax

; 151  : 		u->DoCombat();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+492]
	call	eax
$LN1@UpdateUnit:

; 152  : 	}
; 153  : 	//STOP_PROFILE("UU COMBAT");
; 154  : 
; 155  : 	return 1;

	mov	eax, 1
$LN9@UpdateUnit:

; 156  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateUnit@@YAHPAVUnitClass@@K@Z ENDP			; UpdateUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_this$ = -12						; size = 4
$T3 = -8						; size = 4
tv73 = -4						; size = 4
_e$ = 8							; size = 4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z PROC	; UnitClass::SetTarget, COMDAT
; _this$ = ecx

; 359  : 	void SetTarget (FalconEntity *e)				{ target_id = (e)? e->Id() : FalconNullId; }

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN3@SetTarget
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@SetTarget
$LN3@SetTarget:
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR $T2[ebp+4], edx
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN4@SetTarget:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], eax
	mov	DWORD PTR [edx+216], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ENDP	; UnitClass::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Diverted@UnitClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Diverted@UnitClass@@QAEHXZ PROC			; UnitClass::Diverted, COMDAT
; _this$ = ecx

; 332  : 	int Diverted (void)								{ return (int)unit_flags & U_DIVERTED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 4194304				; 00400000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Diverted@UnitClass@@QAEHXZ ENDP			; UnitClass::Diverted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Cargo@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cargo@UnitClass@@QBEHXZ PROC				; UnitClass::Cargo, COMDAT
; _this$ = ecx

; 318  : 	int Cargo () const								{ return (int)unit_flags & U_CARGO; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 8192				; 00002000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Cargo@UnitClass@@QBEHXZ ENDP				; UnitClass::Cargo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Moving@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Moving@UnitClass@@QBEHXZ PROC				; UnitClass::Moving, COMDAT
; _this$ = ecx

; 316  : 	int Moving() const								{ return (int)unit_flags & U_MOVING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1024				; 00000400H
	mov	esp, ebp
	pop	ebp
	ret	0
?Moving@UnitClass@@QBEHXZ ENDP				; UnitClass::Moving
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Engaged@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Engaged@UnitClass@@QBEHXZ PROC				; UnitClass::Engaged, COMDAT
; _this$ = ecx

; 313  : 	int Engaged() const								{ return (int)unit_flags & U_ENGAGED; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 64					; 00000040H
	mov	esp, ebp
	pop	ebp
	ret	0
?Engaged@UnitClass@@QBEHXZ ENDP				; UnitClass::Engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetRoster@UnitClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoster@UnitClass@@QAEJXZ PROC			; UnitClass::GetRoster, COMDAT
; _this$ = ecx

; 147  : 	fourbyte GetRoster (void)			{ return roster; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRoster@UnitClass@@QAEJXZ ENDP			; UnitClass::GetRoster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastCheck@UnitClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastCheck@UnitClass@@QAEKXZ PROC			; UnitClass::GetLastCheck, COMDAT
; _this$ = ecx

; 146  : 	CampaignTime GetLastCheck (void)	{ return last_check; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastCheck@UnitClass@@QAEKXZ ENDP			; UnitClass::GetLastCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?UnsetChecked@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnsetChecked@CampBaseClass@@QAEXXZ PROC		; CampBaseClass::UnsetChecked, COMDAT
; _this$ = ecx

; 307  : 	void UnsetChecked (void)					{	local_flags &= ~CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetChecked@CampBaseClass@@QAEXXZ ENDP		; CampBaseClass::UnsetChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsTacan@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTacan@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsTacan, COMDAT
; _this$ = ecx

; 279  : 	int IsTacan (void)							{	return local_flags & CBC_HAS_TACAN; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 256				; 00000100H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTacan@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsTacan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampaign@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsCampaign@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsCampaign, COMDAT
; _this$ = ecx

; 101  : 		{return (falconType & FalconCampaignEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 1
	je	SHORT $LN3@IsCampaign
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsCampaign
$LN3@IsCampaign:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsCampaign:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampaign@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
END
