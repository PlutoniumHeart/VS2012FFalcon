; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUPD\Tactics.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?AirTactics@@3FA				; AirTactics
PUBLIC	?GroundTactics@@3FA				; GroundTactics
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?NavalTactics@@3FA				; NavalTactics
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?FirstAirTactic@@3FA				; FirstAirTactic
PUBLIC	?FirstGroundTactic@@3FA				; FirstGroundTactic
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?FirstNavalTactic@@3FA				; FirstNavalTactic
PUBLIC	?TotalTactics@@3FA				; TotalTactics
PUBLIC	?TacticsTable@@3PAUTacticData@@A		; TacticsTable
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?ReactionTable@@3PAUReactData@@A		; ReactionTable
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
_BSS	SEGMENT
?AirTactics@@3FA DW 01H DUP (?)				; AirTactics
	ALIGN	4

?GroundTactics@@3FA DW 01H DUP (?)			; GroundTactics
	ALIGN	4

?NavalTactics@@3FA DW 01H DUP (?)			; NavalTactics
	ALIGN	4

?FirstAirTactic@@3FA DW 01H DUP (?)			; FirstAirTactic
	ALIGN	4

?FirstGroundTactic@@3FA DW 01H DUP (?)			; FirstGroundTactic
	ALIGN	4

?FirstNavalTactic@@3FA DW 01H DUP (?)			; FirstNavalTactic
	ALIGN	4

?TotalTactics@@3FA DW 01H DUP (?)			; TotalTactics
	ALIGN	4

?TacticsTable@@3PAUTacticData@@A DD 01H DUP (?)		; TacticsTable
?ReactionTable@@3PAUReactData@@A DB 096H DUP (?)	; ReactionTable
_BSS	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	?LoadTactics@@YAHPAD@Z				; LoadTactics
PUBLIC	?FreeTactics@@YAXXZ				; FreeTactics
PUBLIC	?CheckTeam@@YAHHH@Z				; CheckTeam
PUBLIC	?CheckUnitType@@YAHHHH@Z			; CheckUnitType
PUBLIC	?CheckRange@@YAHHH@Z				; CheckRange
PUBLIC	?CheckDistToFront@@YAHHH@Z			; CheckDistToFront
PUBLIC	?CheckAction@@YAHHH@Z				; CheckAction
PUBLIC	?CheckStatus@@YAHHH@Z				; CheckStatus
PUBLIC	?CheckLosses@@YAHHH@Z				; CheckLosses
PUBLIC	?CheckEngaged@@YAHHH@Z				; CheckEngaged
PUBLIC	?CheckCombat@@YAHHH@Z				; CheckCombat
PUBLIC	?CheckRetreating@@YAHHH@Z			; CheckRetreating
PUBLIC	?CheckOwned@@YAHHH@Z				; CheckOwned
PUBLIC	?CheckAirborne@@YAHHH@Z				; CheckAirborne
PUBLIC	?CheckMarine@@YAHHH@Z				; CheckMarine
PUBLIC	?CheckOdds@@YAHHH@Z				; CheckOdds
PUBLIC	?CheckRole@@YAHHH@Z				; CheckRole
PUBLIC	?CheckSpecial@@YAHH@Z				; CheckSpecial
PUBLIC	?CheckFuel@@YAHHH@Z				; CheckFuel
PUBLIC	?CheckWeapons@@YAHH@Z				; CheckWeapons
PUBLIC	?GetTacticPriority@@YAHH@Z			; GetTacticPriority
PUBLIC	?GetTacticFormation@@YAHH@Z			; GetTacticFormation
PUBLIC	?CheckReaction@@YAHHH@Z				; CheckReaction
PUBLIC	??_C@_08KGGPJDOE@?$CFs?2?$CFs?4tt?$AA@		; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
EXTRN	_fclose:PROC
EXTRN	_fread:PROC
EXTRN	_sprintf:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?F4OpenFile@@YAPAU_iobuf@@PAD0@Z:PROC		; F4OpenFile
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?FalconCampaignSaveDirectory@@3PADA:BYTE	; FalconCampaignSaveDirectory
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KGGPJDOE@?$CFs?2?$CFs?4tt?$AA@
CONST	SEGMENT
??_C@_08KGGPJDOE@?$CFs?2?$CFs?4tt?$AA@ DB '%s\%s.tt', 00H ; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_awp$ = 8						; size = 4
_zone$ = 12						; size = 4
?CheckReaction@@YAHHH@Z PROC				; CheckReaction

; 52   : 	{

	push	ebp
	mov	ebp, esp

; 53   : 	return ReactionTable[awp].reaction[zone];

	mov	eax, DWORD PTR _awp$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _zone$[ebp]
	movzx	eax, BYTE PTR ?ReactionTable@@3PAUReactData@@A[eax+ecx]

; 54   : 	}

	pop	ebp
	ret	0
?CheckReaction@@YAHHH@Z ENDP				; CheckReaction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
?GetTacticFormation@@YAHH@Z PROC			; GetTacticFormation

; 269  : 	{

	push	ebp
	mov	ebp, esp

; 270  : 	return TacticsTable[tid].formation;

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	eax, BYTE PTR [ecx+eax+65]

; 271  : 	}

	pop	ebp
	ret	0
?GetTacticFormation@@YAHH@Z ENDP			; GetTacticFormation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
?GetTacticPriority@@YAHH@Z PROC				; GetTacticPriority

; 264  : 	{

	push	ebp
	mov	ebp, esp

; 265  : 	return TacticsTable[tid].priority;

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	eax, BYTE PTR [ecx+eax+64]

; 266  : 	}

	pop	ebp
	ret	0
?GetTacticPriority@@YAHH@Z ENDP				; GetTacticPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
?CheckWeapons@@YAHH@Z PROC				; CheckWeapons

; 259  : 	{

	push	ebp
	mov	ebp, esp

; 260  : 	return TacticsTable[tid].weapons;

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	eax, BYTE PTR [ecx+eax+63]

; 261  : 	}

	pop	ebp
	ret	0
?CheckWeapons@@YAHH@Z ENDP				; CheckWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_fuel$ = 12						; size = 4
?CheckFuel@@YAHHH@Z PROC				; CheckFuel

; 250  : 	{

	push	ebp
	mov	ebp, esp

; 251  : 	if (TacticsTable[tid].fuel == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+62]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN2@CheckFuel

; 252  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@CheckFuel
$LN2@CheckFuel:

; 253  : 	if (TacticsTable[tid].fuel > fuel)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+62]
	cmp	edx, DWORD PTR _fuel$[ebp]
	jle	SHORT $LN1@CheckFuel

; 254  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CheckFuel
$LN1@CheckFuel:

; 255  : 	return 1;

	mov	eax, 1
$LN3@CheckFuel:

; 256  : 	}

	pop	ebp
	ret	0
?CheckFuel@@YAHHH@Z ENDP				; CheckFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
?CheckSpecial@@YAHH@Z PROC				; CheckSpecial

; 245  : 	{

	push	ebp
	mov	ebp, esp

; 246  : 	return TacticsTable[tid].special;

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	eax, BYTE PTR [ecx+eax+66]

; 247  : 	}

	pop	ebp
	ret	0
?CheckSpecial@@YAHH@Z ENDP				; CheckSpecial
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_role$ = 12						; size = 4
?CheckRole@@YAHHH@Z PROC				; CheckRole

; 236  : 	{

	push	ebp
	mov	ebp, esp

; 237  : 	if (TacticsTable[tid].role == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+61]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN2@CheckRole

; 238  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@CheckRole
$LN2@CheckRole:

; 239  : 	if (TacticsTable[tid].role != role)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+61]
	cmp	edx, DWORD PTR _role$[ebp]
	je	SHORT $LN1@CheckRole

; 240  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CheckRole
$LN1@CheckRole:

; 241  : 	return 1;

	mov	eax, 1
$LN3@CheckRole:

; 242  : 	}

	pop	ebp
	ret	0
?CheckRole@@YAHHH@Z ENDP				; CheckRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_odds$ = 12						; size = 4
?CheckOdds@@YAHHH@Z PROC				; CheckOdds

; 227  : 	{

	push	ebp
	mov	ebp, esp

; 228  : 	if (TacticsTable[tid].minOdds == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+60]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN2@CheckOdds

; 229  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@CheckOdds
$LN2@CheckOdds:

; 230  : 	if (TacticsTable[tid].minOdds > odds)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+60]
	cmp	edx, DWORD PTR _odds$[ebp]
	jle	SHORT $LN1@CheckOdds

; 231  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CheckOdds
$LN1@CheckOdds:

; 232  : 	return 1;

	mov	eax, 1
$LN3@CheckOdds:

; 233  : 	}

	pop	ebp
	ret	0
?CheckOdds@@YAHHH@Z ENDP				; CheckOdds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_marine$ = 12						; size = 4
?CheckMarine@@YAHHH@Z PROC				; CheckMarine

; 216  : 	{

	push	ebp
	mov	ebp, esp

; 217  : 	if (TacticsTable[tid].marine == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+59]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckMarin

; 218  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckMarin
$LN3@CheckMarin:

; 219  : 	if (!TacticsTable[tid].marine && marine)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+59]
	test	edx, edx
	jne	SHORT $LN2@CheckMarin
	cmp	DWORD PTR _marine$[ebp], 0
	je	SHORT $LN2@CheckMarin

; 220  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckMarin
$LN2@CheckMarin:

; 221  : 	if (TacticsTable[tid].marine && !marine)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+59]
	test	edx, edx
	je	SHORT $LN1@CheckMarin
	cmp	DWORD PTR _marine$[ebp], 0
	jne	SHORT $LN1@CheckMarin

; 222  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckMarin
$LN1@CheckMarin:

; 223  : 	return 1;

	mov	eax, 1
$LN4@CheckMarin:

; 224  : 	}

	pop	ebp
	ret	0
?CheckMarine@@YAHHH@Z ENDP				; CheckMarine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_airborne$ = 12						; size = 4
?CheckAirborne@@YAHHH@Z PROC				; CheckAirborne

; 205  : 	{

	push	ebp
	mov	ebp, esp

; 206  : 	if (TacticsTable[tid].airborne == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+58]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckAirbo

; 207  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckAirbo
$LN3@CheckAirbo:

; 208  : 	if (!TacticsTable[tid].airborne && airborne)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+58]
	test	edx, edx
	jne	SHORT $LN2@CheckAirbo
	cmp	DWORD PTR _airborne$[ebp], 0
	je	SHORT $LN2@CheckAirbo

; 209  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckAirbo
$LN2@CheckAirbo:

; 210  : 	if (TacticsTable[tid].airborne && !airborne)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+58]
	test	edx, edx
	je	SHORT $LN1@CheckAirbo
	cmp	DWORD PTR _airborne$[ebp], 0
	jne	SHORT $LN1@CheckAirbo

; 211  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckAirbo
$LN1@CheckAirbo:

; 212  : 	return 1;

	mov	eax, 1
$LN4@CheckAirbo:

; 213  : 	}

	pop	ebp
	ret	0
?CheckAirborne@@YAHHH@Z ENDP				; CheckAirborne
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_o$ = 12						; size = 4
?CheckOwned@@YAHHH@Z PROC				; CheckOwned

; 194  : 	{

	push	ebp
	mov	ebp, esp

; 195  : 	if (TacticsTable[tid].owned == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+57]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckOwned

; 196  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckOwned
$LN3@CheckOwned:

; 197  : 	if (!TacticsTable[tid].owned && o)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+57]
	test	edx, edx
	jne	SHORT $LN2@CheckOwned
	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN2@CheckOwned

; 198  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckOwned
$LN2@CheckOwned:

; 199  : 	if (TacticsTable[tid].owned && !o)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+57]
	test	edx, edx
	je	SHORT $LN1@CheckOwned
	cmp	DWORD PTR _o$[ebp], 0
	jne	SHORT $LN1@CheckOwned

; 200  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckOwned
$LN1@CheckOwned:

; 201  : 	return 1;

	mov	eax, 1
$LN4@CheckOwned:

; 202  : 	}

	pop	ebp
	ret	0
?CheckOwned@@YAHHH@Z ENDP				; CheckOwned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_retreat$ = 12						; size = 4
?CheckRetreating@@YAHHH@Z PROC				; CheckRetreating

; 183  : 	{

	push	ebp
	mov	ebp, esp

; 184  : 	if (TacticsTable[tid].retreating == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+56]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckRetre

; 185  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckRetre
$LN3@CheckRetre:

; 186  : 	if (!TacticsTable[tid].retreating && retreat)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+56]
	test	edx, edx
	jne	SHORT $LN2@CheckRetre
	cmp	DWORD PTR _retreat$[ebp], 0
	je	SHORT $LN2@CheckRetre

; 187  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckRetre
$LN2@CheckRetre:

; 188  : 	if (TacticsTable[tid].retreating && !retreat)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+56]
	test	edx, edx
	je	SHORT $LN1@CheckRetre
	cmp	DWORD PTR _retreat$[ebp], 0
	jne	SHORT $LN1@CheckRetre

; 189  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckRetre
$LN1@CheckRetre:

; 190  : 	return 1;

	mov	eax, 1
$LN4@CheckRetre:

; 191  : 	}

	pop	ebp
	ret	0
?CheckRetreating@@YAHHH@Z ENDP				; CheckRetreating
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_combat$ = 12						; size = 4
?CheckCombat@@YAHHH@Z PROC				; CheckCombat

; 172  : 	{

	push	ebp
	mov	ebp, esp

; 173  : 	if (TacticsTable[tid].combat  == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+54]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckComba

; 174  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckComba
$LN3@CheckComba:

; 175  : 	if (!TacticsTable[tid].combat && combat)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+54]
	test	edx, edx
	jne	SHORT $LN2@CheckComba
	cmp	DWORD PTR _combat$[ebp], 0
	je	SHORT $LN2@CheckComba

; 176  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckComba
$LN2@CheckComba:

; 177  : 	if (TacticsTable[tid].combat && !combat)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+54]
	test	edx, edx
	je	SHORT $LN1@CheckComba
	cmp	DWORD PTR _combat$[ebp], 0
	jne	SHORT $LN1@CheckComba

; 178  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckComba
$LN1@CheckComba:

; 179  : 	return 1;

	mov	eax, 1
$LN4@CheckComba:

; 180  : 	}

	pop	ebp
	ret	0
?CheckCombat@@YAHHH@Z ENDP				; CheckCombat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_engaged$ = 12						; size = 4
?CheckEngaged@@YAHHH@Z PROC				; CheckEngaged

; 161  : 	{

	push	ebp
	mov	ebp, esp

; 162  : 	if (TacticsTable[tid].engaged  == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+53]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckEngag

; 163  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckEngag
$LN3@CheckEngag:

; 164  : 	if (!TacticsTable[tid].engaged && engaged)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+53]
	test	edx, edx
	jne	SHORT $LN2@CheckEngag
	cmp	DWORD PTR _engaged$[ebp], 0
	je	SHORT $LN2@CheckEngag

; 165  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckEngag
$LN2@CheckEngag:

; 166  : 	if (TacticsTable[tid].engaged && !engaged)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+53]
	test	edx, edx
	je	SHORT $LN1@CheckEngag
	cmp	DWORD PTR _engaged$[ebp], 0
	jne	SHORT $LN1@CheckEngag

; 167  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckEngag
$LN1@CheckEngag:

; 168  : 	return 1;

	mov	eax, 1
$LN4@CheckEngag:

; 169  : 	}

	pop	ebp
	ret	0
?CheckEngaged@@YAHHH@Z ENDP				; CheckEngaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_losses$ = 12						; size = 4
?CheckLosses@@YAHHH@Z PROC				; CheckLosses

; 150  : 	{

	push	ebp
	mov	ebp, esp

; 151  : 	if (TacticsTable[tid].losses  == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+55]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckLosse

; 152  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckLosse
$LN3@CheckLosse:

; 153  : 	if (!TacticsTable[tid].losses  && losses)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+55]
	test	edx, edx
	jne	SHORT $LN2@CheckLosse
	cmp	DWORD PTR _losses$[ebp], 0
	je	SHORT $LN2@CheckLosse

; 154  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckLosse
$LN2@CheckLosse:

; 155  : 	if (TacticsTable[tid].losses && !losses)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+55]
	test	edx, edx
	je	SHORT $LN1@CheckLosse
	cmp	DWORD PTR _losses$[ebp], 0
	jne	SHORT $LN1@CheckLosse

; 156  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckLosse
$LN1@CheckLosse:

; 157  : 	return 1;

	mov	eax, 1
$LN4@CheckLosse:

; 158  : 	}

	pop	ebp
	ret	0
?CheckLosses@@YAHHH@Z ENDP				; CheckLosses
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_status$ = 12						; size = 4
?CheckStatus@@YAHHH@Z PROC				; CheckStatus

; 139  : 	{

	push	ebp
	mov	ebp, esp

; 140  : 	if (TacticsTable[tid].broken  == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+52]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckStatu

; 141  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckStatu
$LN3@CheckStatu:

; 142  : 	if (!TacticsTable[tid].broken && status)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+52]
	test	edx, edx
	jne	SHORT $LN2@CheckStatu
	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN2@CheckStatu

; 143  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckStatu
$LN2@CheckStatu:

; 144  : 	if (TacticsTable[tid].broken && !status)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+52]
	test	edx, edx
	je	SHORT $LN1@CheckStatu
	cmp	DWORD PTR _status$[ebp], 0
	jne	SHORT $LN1@CheckStatu

; 145  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckStatu
$LN1@CheckStatu:

; 146  : 	return 1;

	mov	eax, 1
$LN4@CheckStatu:

; 147  : 	}

	pop	ebp
	ret	0
?CheckStatus@@YAHHH@Z ENDP				; CheckStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_tid$ = 8						; size = 4
_act$ = 12						; size = 4
?CheckAction@@YAHHH@Z PROC				; CheckAction

; 125  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 126  : 	int		i;
; 127  : 
; 128  : 	if (TacticsTable[tid].actionList[0] == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	add	eax, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	mov	ecx, 1
	imul	ecx, 0
	movzx	edx, BYTE PTR [eax+ecx+42]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN5@CheckActio

; 129  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN6@CheckActio
$LN5@CheckActio:

; 130  : 	for (i=0; i<10 && TacticsTable[tid].actionList[i] != CHECK_ANY; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CheckActio
$LN3@CheckActio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CheckActio:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	SHORT $LN2@CheckActio
	mov	ecx, DWORD PTR _tid$[ebp]
	imul	ecx, 68					; 00000044H
	add	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+42]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN2@CheckActio

; 131  : 		{
; 132  : 		if (TacticsTable[tid].actionList[i] == act)

	mov	ecx, DWORD PTR _tid$[ebp]
	imul	ecx, 68					; 00000044H
	add	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+42]
	cmp	eax, DWORD PTR _act$[ebp]
	jne	SHORT $LN1@CheckActio

; 133  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN6@CheckActio
$LN1@CheckActio:

; 134  : 		}

	jmp	SHORT $LN3@CheckActio
$LN2@CheckActio:

; 135  : 	return 0;

	xor	eax, eax
$LN6@CheckActio:

; 136  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAction@@YAHHH@Z ENDP				; CheckAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_dist$ = 12						; size = 4
?CheckDistToFront@@YAHHH@Z PROC				; CheckDistToFront

; 116  : 	{

	push	ebp
	mov	ebp, esp

; 117  : 	if (TacticsTable[tid].distToFront == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movsx	edx, WORD PTR [ecx+eax+40]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN2@CheckDistT

; 118  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@CheckDistT
$LN2@CheckDistT:

; 119  : 	if (TacticsTable[tid].distToFront > dist)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movsx	edx, WORD PTR [ecx+eax+40]
	cmp	edx, DWORD PTR _dist$[ebp]
	jle	SHORT $LN1@CheckDistT

; 120  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CheckDistT
$LN1@CheckDistT:

; 121  : 	return 1;

	mov	eax, 1
$LN3@CheckDistT:

; 122  : 	}

	pop	ebp
	ret	0
?CheckDistToFront@@YAHHH@Z ENDP				; CheckDistToFront
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_rng$ = 12						; size = 4
?CheckRange@@YAHHH@Z PROC				; CheckRange

; 107  : 	{

	push	ebp
	mov	ebp, esp

; 108  : 	if (TacticsTable[tid].minRangeToDest == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movsx	edx, WORD PTR [ecx+eax+36]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckRange

; 109  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckRange
$LN3@CheckRange:

; 110  : 	if (TacticsTable[tid].minRangeToDest > rng || TacticsTable[tid].maxRangeToDest < rng)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movsx	edx, WORD PTR [ecx+eax+36]
	cmp	edx, DWORD PTR _rng$[ebp]
	jg	SHORT $LN1@CheckRange
	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movsx	edx, WORD PTR [ecx+eax+38]
	cmp	edx, DWORD PTR _rng$[ebp]
	jge	SHORT $LN2@CheckRange
$LN1@CheckRange:

; 111  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckRange
$LN2@CheckRange:

; 112  : 	return 1;

	mov	eax, 1
$LN4@CheckRange:

; 113  : 	}

	pop	ebp
	ret	0
?CheckRange@@YAHHH@Z ENDP				; CheckRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_domain$ = 12						; size = 4
_type$ = 16						; size = 4
?CheckUnitType@@YAHHHH@Z PROC				; CheckUnitType

; 98   : 	{

	push	ebp
	mov	ebp, esp

; 99   : 	if (TacticsTable[tid].domainType == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+33]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN3@CheckUnitT

; 100  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckUnitT
$LN3@CheckUnitT:

; 101  : 	if (TacticsTable[tid].domainType != domain || TacticsTable[tid].unitSize != type)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+33]
	cmp	edx, DWORD PTR _domain$[ebp]
	jne	SHORT $LN1@CheckUnitT
	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+34]
	cmp	edx, DWORD PTR _type$[ebp]
	je	SHORT $LN2@CheckUnitT
$LN1@CheckUnitT:

; 102  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CheckUnitT
$LN2@CheckUnitT:

; 103  : 	return 1;

	mov	eax, 1
$LN4@CheckUnitT:

; 104  : 	}

	pop	ebp
	ret	0
?CheckUnitType@@YAHHHH@Z ENDP				; CheckUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_team$ = 12						; size = 4
?CheckTeam@@YAHHH@Z PROC				; CheckTeam

; 89   : 	{

	push	ebp
	mov	ebp, esp

; 90   : 	if (TacticsTable[tid].team == CHECK_ANY)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+32]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN2@CheckTeam

; 91   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@CheckTeam
$LN2@CheckTeam:

; 92   : 	if (TacticsTable[tid].team != team)

	mov	eax, DWORD PTR _tid$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	movzx	edx, BYTE PTR [ecx+eax+32]
	cmp	edx, DWORD PTR _team$[ebp]
	je	SHORT $LN1@CheckTeam

; 93   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CheckTeam
$LN1@CheckTeam:

; 94   : 	return 1;

	mov	eax, 1
$LN3@CheckTeam:

; 95   : 	}

	pop	ebp
	ret	0
?CheckTeam@@YAHHH@Z ENDP				; CheckTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
?FreeTactics@@YAXXZ PROC				; FreeTactics

; 83   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 84   : 	delete [] TacticsTable;

	mov	eax, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 85   : 	TacticsTable = NULL;

	mov	DWORD PTR ?TacticsTable@@3PAUTacticData@@A, 0 ; TacticsTable

; 86   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?FreeTactics@@YAXXZ ENDP				; FreeTactics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\tactics.cpp
_TEXT	SEGMENT
$T1 = -272						; size = 4
_fp$ = -268						; size = 4
_filename$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
?LoadTactics@@YAHPAD@Z PROC				; LoadTactics

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 63   : 	FILE*			fp;
; 64   : 	char			filename[MAX_PATH];
; 65   : 
; 66   : 	sprintf(filename,"%s\\%s.tt",FalconCampaignSaveDirectory,name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ?FalconCampaignSaveDirectory@@3PADA ; FalconCampaignSaveDirectory
	push	OFFSET ??_C@_08KGGPJDOE@?$CFs?2?$CFs?4tt?$AA@
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 67   : 	if ((fp = F4OpenFile(filename, "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?F4OpenFile@@YAPAU_iobuf@@PAD0@Z	; F4OpenFile
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN1@LoadTactic

; 68   : 		return 0;

	xor	eax, eax
	jmp	$LN2@LoadTactic
$LN1@LoadTactic:

; 69   : 	fread(&AirTactics,sizeof(short),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?AirTactics@@3FA			; AirTactics
	call	_fread
	add	esp, 16					; 00000010H

; 70   : 	fread(&GroundTactics,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	push	OFFSET ?GroundTactics@@3FA		; GroundTactics
	call	_fread
	add	esp, 16					; 00000010H

; 71   : 	fread(&NavalTactics,sizeof(short),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	2
	push	OFFSET ?NavalTactics@@3FA		; NavalTactics
	call	_fread
	add	esp, 16					; 00000010H

; 72   : 	FirstAirTactic = 1;

	mov	eax, 1
	mov	WORD PTR ?FirstAirTactic@@3FA, ax	; FirstAirTactic

; 73   : 	FirstGroundTactic = 1 + AirTactics;

	movsx	ecx, WORD PTR ?AirTactics@@3FA		; AirTactics
	add	ecx, 1
	mov	WORD PTR ?FirstGroundTactic@@3FA, cx	; FirstGroundTactic

; 74   : 	FirstNavalTactic = 1 + AirTactics + GroundTactics;

	movsx	edx, WORD PTR ?AirTactics@@3FA		; AirTactics
	movsx	eax, WORD PTR ?GroundTactics@@3FA	; GroundTactics
	lea	ecx, DWORD PTR [edx+eax+1]
	mov	WORD PTR ?FirstNavalTactic@@3FA, cx	; FirstNavalTactic

; 75   : 	TotalTactics = 1 + AirTactics + GroundTactics + NavalTactics;

	movsx	edx, WORD PTR ?AirTactics@@3FA		; AirTactics
	movsx	eax, WORD PTR ?GroundTactics@@3FA	; GroundTactics
	lea	ecx, DWORD PTR [edx+eax+1]
	movsx	edx, WORD PTR ?NavalTactics@@3FA	; NavalTactics
	add	ecx, edx
	mov	WORD PTR ?TotalTactics@@3FA, cx		; TotalTactics

; 76   : 	TacticsTable = new TacticData[TotalTactics];

	movsx	eax, WORD PTR ?TotalTactics@@3FA	; TotalTactics
	xor	ecx, ecx
	mov	edx, 68					; 00000044H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?TacticsTable@@3PAUTacticData@@A, eax ; TacticsTable

; 77   : 	fread(TacticsTable,sizeof(TacticData),TotalTactics,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?TotalTactics@@3FA	; TotalTactics
	push	edx
	push	68					; 00000044H
	mov	eax, DWORD PTR ?TacticsTable@@3PAUTacticData@@A ; TacticsTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 78   : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 79   : 	return 1;

	mov	eax, 1
$LN2@LoadTactic:

; 80   : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTactics@@YAHPAD@Z ENDP				; LoadTactics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
