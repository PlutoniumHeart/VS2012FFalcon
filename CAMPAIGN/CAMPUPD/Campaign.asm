; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUPD\Campaign.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?gLaunchTime@@3KA				; gLaunchTime
PUBLIC	?gOldCompressTillTime@@3KA			; gOldCompressTillTime
PUBLIC	?gOldCompressionRatio@@3KA			; gOldCompressionRatio
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?ReconLossTime@@3PAKA				; ReconLossTime
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?gCampTime@@3HA					; gCampTime
PUBLIC	?gAveCampTime@@3HA				; gAveCampTime
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?f@@3MA						; f
PUBLIC	?gLeftToDeaggregate@@3HC			; gLeftToDeaggregate
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?dx@@3PAFA					; dx
PUBLIC	?dy@@3PAFA					; dy
PUBLIC	?campCritical@@3PAUF4CSECTIONHANDLE@@A		; campCritical
PUBLIC	?VisualDetectionRange@@3PAHA			; VisualDetectionRange
PUBLIC	?DefaultDamageMods@@3PAEA			; DefaultDamageMods
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?AwakeCampaignEntities@@3HA			; AwakeCampaignEntities
PUBLIC	?gGameType@@3HA					; gGameType
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?gCompressTillTime@@3KA				; gCompressTillTime
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
_BSS	SEGMENT
?gLaunchTime@@3KA DD 01H DUP (?)			; gLaunchTime
?gOldCompressTillTime@@3KA DD 01H DUP (?)		; gOldCompressTillTime
?gCampTime@@3HA DD 01H DUP (?)				; gCampTime
?gAveCampTime@@3HA DD 01H DUP (?)			; gAveCampTime
?f@@3MA	DD	01H DUP (?)				; f
_sCampaignSleepRequested DD 01H DUP (?)
_sCampaignStartingUp DD 01H DUP (?)
_sTakeoffTime DD 01H DUP (?)
_FirstflightsTakeoffTime DD 01H DUP (?)
?gLeftToDeaggregate@@3HC DD 01H DUP (?)			; gLeftToDeaggregate
?campCritical@@3PAUF4CSECTIONHANDLE@@A DD 01H DUP (?)	; campCritical
?AwakeCampaignEntities@@3HA DD 01H DUP (?)		; AwakeCampaignEntities
?gCompressTillTime@@3KA DD 01H DUP (?)			; gCompressTillTime
_next_wch_file DD 01H DUP (?)
_wch_fp	DD	04H DUP (?)
_writing_campressed_file DD 01H DUP (?)
_reading_campressed_file DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
_DATA	SEGMENT
?gOldCompressionRatio@@3KA DD 0ffffffffH		; gOldCompressionRatio
?ReconLossTime@@3PAKA DD 036ee80H			; ReconLossTime
	DD	0124f80H
	DD	0927c0H
	DD	0927c0H
	DD	0ea60H
	DD	0ea60H
	DD	0927c0H
	DD	0927c0H
?dx@@3PAFA DW	00H					; dx
	DW	01H
	DW	01H
	DW	01H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	00H
	DW	02H
	DW	02H
	DW	02H
	DW	00H
	DW	0fffeH
	DW	0fffeH
	DW	0fffeH
	ORG $+2
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
?dy@@3PAFA DW	01H					; dy
	DW	01H
	DW	00H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	00H
	DW	01H
	DW	00H
	DW	02H
	DW	02H
	DW	00H
	DW	0fffeH
	DW	0fffeH
	DW	0fffeH
	DW	00H
	DW	02H
	ORG $+2
?VisualDetectionRange@@3PAHA DD 0cH			; VisualDetectionRange
	DD	04H
	DD	05H
	DD	05H
	DD	08H
	DD	010H
	DD	0aH
	DD	05H
	ORG $+8
?DefaultDamageMods@@3PAEA DB 00H			; DefaultDamageMods
	DB	064H
	DB	064H
	DB	00H
	DB	00H
	DB	064H
	DB	064H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+1
?gGameType@@3HA DD 0ffffffffH				; gGameType
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::OwnerId
PUBLIC	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ		; VuEntity::VuState
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?RequestReliableTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestReliableTransmit
PUBLIC	?SetFalcFlag@FalconEntity@@QAEXH@Z		; FalconEntity::SetFalcFlag
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z		; OpenCampFile
PUBLIC	?GetCost@BasePathClass@@QAEMXZ			; BasePathClass::GetCost
PUBLIC	??1PathClass@@QAE@XZ				; PathClass::~PathClass
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?AddObjectiveToCampaign@@YAPAVObjectiveClass@@FF@Z ; AddObjectiveToCampaign
PUBLIC	?LoadTheater@@YAHPAD@Z				; LoadTheater
PUBLIC	?SaveTheater@@YAHPAD@Z				; SaveTheater
PUBLIC	?LinkCampaignObjectives@@YAHPAVBasePathClass@@PAVObjectiveClass@@1@Z ; LinkCampaignObjectives
PUBLIC	?UnLinkCampaignObjectives@@YAHPAVObjectiveClass@@0@Z ; UnLinkCampaignObjectives
PUBLIC	?RecalculateLinks@@YAHPAVObjectiveClass@@@Z	; RecalculateLinks
PUBLIC	?AddUnit@@YAPAVUnitClass@@FFD@Z			; AddUnit
PUBLIC	?RemoveUnit@@YAXPAVUnitClass@@@Z		; RemoveUnit
PUBLIC	?TimeOfDayGeneral@@YAHK@Z			; TimeOfDayGeneral
PUBLIC	?TimeOfDayGeneral@@YAHXZ			; TimeOfDayGeneral
PUBLIC	?TimeOfDay@@YAKXZ				; TimeOfDay
PUBLIC	?CreateCampFile@@YAHPAD0@Z			; CreateCampFile
PUBLIC	?CloseCampFile@@YAXPAU_iobuf@@@Z		; CloseCampFile
PUBLIC	?StartReadCampFile@@YAXW4FalconGameType@@PAD@Z	; StartReadCampFile
PUBLIC	?ReadCampFile@@YA?AUCampaignData@@PAD0@Z	; ReadCampFile
PUBLIC	?EndReadCampFile@@YAXXZ				; EndReadCampFile
PUBLIC	?StartWriteCampFile@@YAXW4FalconGameType@@PAD@Z	; StartWriteCampFile
PUBLIC	?EndWriteCampFile@@YAXXZ			; EndWriteCampFile
PUBLIC	?CampaignRequestSleep@@YAXXZ			; CampaignRequestSleep
PUBLIC	?CampaignAllAsleep@@YAHXZ			; CampaignAllAsleep
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPArrivalTime@WayPointClass@@QAEKXZ		; WayPointClass::GetWPArrivalTime
PUBLIC	?IsSuspended@CampaignClass@@QAEHXZ		; CampaignClass::IsSuspended
PUBLIC	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ	; CampBaseClass::GetDeagOwner
PUBLIC	?IsChecked@CampBaseClass@@QAEHXZ		; CampBaseClass::IsChecked
PUBLIC	?IsAwake@CampBaseClass@@QAEHXZ			; CampBaseClass::IsAwake
PUBLIC	?IsInterested@CampBaseClass@@QAEHXZ		; CampBaseClass::IsInterested
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?SetChecked@CampBaseClass@@QAEXXZ		; CampBaseClass::SetChecked
PUBLIC	?UnsetChecked@CampBaseClass@@QAEXXZ		; CampBaseClass::UnsetChecked
PUBLIC	?SetInterest@CampBaseClass@@QAEXXZ		; CampBaseClass::SetInterest
PUBLIC	?UnsetInterest@CampBaseClass@@QAEXXZ		; CampBaseClass::UnsetInterest
PUBLIC	?MinDeagTime@ATCBrain@@QAEKXZ			; ATCBrain::MinDeagTime
PUBLIC	?GetNeighborId@ObjectiveClass@@QAE?AVVU_ID@@H@Z	; ObjectiveClass::GetNeighborId
PUBLIC	?NumLinks@ObjectiveClass@@QAEHXZ		; ObjectiveClass::NumLinks
PUBLIC	?GetLastCheck@UnitClass@@QAEKXZ			; UnitClass::GetLastCheck
PUBLIC	?Engaged@UnitClass@@QBEHXZ			; UnitClass::Engaged
PUBLIC	?Scripted@UnitClass@@QBEHXZ			; UnitClass::Scripted
PUBLIC	?Aborted@UnitClass@@QBEHXZ			; UnitClass::Aborted
PUBLIC	?Inactive@UnitClass@@QBEHXZ			; UnitClass::Inactive
PUBLIC	?Final@UnitClass@@QBEHXZ			; UnitClass::Final
PUBLIC	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
PUBLIC	?GetEvalFlags@FlightClass@@QAEEXZ		; FlightClass::GetEvalFlags
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?campaign_active@ThreadManager@@SAHXZ		; ThreadManager::campaign_active
PUBLIC	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
PUBLIC	?IsAwake@SimBaseClass@@QBEHXZ			; SimBaseClass::IsAwake
PUBLIC	?InSim@SimulationLoopControl@@SA_NXZ		; SimulationLoopControl::InSim
PUBLIC	?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ ; VuBin<FlightClass>::get
PUBLIC	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
PUBLIC	?GetAircraftNum@FalconSessionEntity@@QBEEXZ	; FalconSessionEntity::GetAircraftNum
PUBLIC	?GetFlyState@FalconSessionEntity@@QBEEXZ	; FalconSessionEntity::GetFlyState
PUBLIC	?GetBubbleRatio@FalconSessionEntity@@QBEMXZ	; FalconSessionEntity::GetBubbleRatio
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z	; FalconSessionEntity::SetBubbleRatio
PUBLIC	?InSim@SimulationDriver@@QBE_NXZ		; SimulationDriver::InSim
PUBLIC	?SetDrawFlag@C_Handler@@QAEXJ@Z			; C_Handler::SetDrawFlag
PUBLIC	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ		; C_Handler::GetAppWnd
PUBLIC	?Online@UIComms@@QAEHXZ				; UIComms::Online
PUBLIC	?ResumeTacticalEngagement@@YAXXZ		; ResumeTacticalEngagement
PUBLIC	?DoTacticalLoop@@YAXH@Z				; DoTacticalLoop
PUBLIC	?DoCampaignLoop@@YAXH@Z				; DoCampaignLoop
PUBLIC	?UpdateParentUnits@@YAXK@Z			; UpdateParentUnits
PUBLIC	?UpdateRealUnits@@YAXK@Z			; UpdateRealUnits
PUBLIC	?CheckNewDay@@YAXXZ				; CheckNewDay
PUBLIC	?PlanGroundAndNavalUnits@@YAXPAH@Z		; PlanGroundAndNavalUnits
PUBLIC	?OrderGroundAndNavalUnits@@YAXXZ		; OrderGroundAndNavalUnits
PUBLIC	?RallyUnits@@YAXH@Z				; RallyUnits
PUBLIC	?ResizeBubble@@YAXH@Z				; ResizeBubble
PUBLIC	?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z ; DeaggregationCheck
PUBLIC	?ChooseNewSession@@YAXPAVCampBaseClass@@@Z	; ChooseNewSession
PUBLIC	?RebuildBubble@@YAXH@Z				; RebuildBubble
PUBLIC	?InterestingSFX@@YAHMM@Z			; InterestingSFX
PUBLIC	?string_compare_extensions@@YAHPAD0@Z		; string_compare_extensions
PUBLIC	?ClearCampCache@@YAXXZ				; ClearCampCache
PUBLIC	?ChooseBullseye@@YAXXZ				; ChooseBullseye
PUBLIC	?SetEntryTime@@YAXPAVFlightClass@@@Z		; SetEntryTime
PUBLIC	?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z ; CompressCampaignUntilTakeoff
PUBLIC	?CancelCampaignCompression@@YAXXZ		; CancelCampaignCompression
PUBLIC	?DoCompressionLoop@@YAXXZ			; DoCompressionLoop
PUBLIC	?SetCampaignStartupMode@@YAXXZ			; SetCampaignStartupMode
PUBLIC	?UpdatePlayerSessions@@YAXXZ			; UpdatePlayerSessions
PUBLIC	?HandleCampaignThread@@YGIXZ			; HandleCampaignThread
PUBLIC	?CampaignThread@@YGIXZ				; CampaignThread
PUBLIC	?MakeTacticalEdit@@YAXXZ			; MakeTacticalEdit
PUBLIC	?RemoveTacticalEdit@@YAXXZ			; RemoveTacticalEdit
PUBLIC	?PauseTacticalEngagement@@YAXXZ			; PauseTacticalEngagement
PUBLIC	?OutputRef@@YAXPAVVuEntity@@H@Z			; OutputRef
PUBLIC	?OutputDeref@@YAXPAVVuEntity@@H@Z		; OutputDeref
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0DE@JKHCDKNK@Failed?5to?5open?5theater?3?5?$CFs?0?5usin@ ; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_09PDPMBAAN@?$CFs?2?$CFs?4tac?$AA@		; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_09FIDCHDGJ@?$CFs?2?$CFs?4trn?$AA@		; `string'
PUBLIC	??_C@_09KALBFCKF@?$CFs?2?$CFs?4cam?$AA@		; `string'
PUBLIC	??_C@_0CB@HFIHGAB@Already?5Reading?5Campressed?5File?6@ ; `string'
PUBLIC	??_C@_0BA@LLHKKLJD@Cannot?5Open?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_03MPOGCMBA@wch?$AA@			; `string'
PUBLIC	??_C@_0BH@JLPBKNLG@OpenCampFile?5?$CFs?4?$CFs?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_03JIBIFJIL@cmp?$AA@			; `string'
PUBLIC	??_C@_03GJLPFLNF@obj?$AA@			; `string'
PUBLIC	??_C@_03PHDMHGFL@obd?$AA@			; `string'
PUBLIC	??_C@_03HECMEGIJ@uni?$AA@			; `string'
PUBLIC	??_C@_03IBMEEAF@tea?$AA@			; `string'
PUBLIC	??_C@_03NGIPJJOF@wth?$AA@			; `string'
PUBLIC	??_C@_03LPBKAOMJ@plt?$AA@			; `string'
PUBLIC	??_C@_03JJLJNLDJ@mil?$AA@			; `string'
PUBLIC	??_C@_03NJKMHLPI@tri?$AA@			; `string'
PUBLIC	??_C@_03ELHHBHJL@evl?$AA@			; `string'
PUBLIC	??_C@_03OGKPNJEB@smd?$AA@			; `string'
PUBLIC	??_C@_03PDJDIDFF@sqd?$AA@			; `string'
PUBLIC	??_C@_03DPEHCIMJ@pol?$AA@			; `string'
PUBLIC	??_C@_02BHMOPGG@ct?$AA@				; `string'
PUBLIC	??_C@_03GOODKOKO@ini?$AA@			; `string'
PUBLIC	??_C@_03MJFKKLJH@ucd?$AA@			; `string'
PUBLIC	??_C@_03PGPOBMGM@ocd?$AA@			; `string'
PUBLIC	??_C@_03ILPGFDOG@fcd?$AA@			; `string'
PUBLIC	??_C@_03NLOPAEHJ@vcd?$AA@			; `string'
PUBLIC	??_C@_03GDFDGDBM@wcd?$AA@			; `string'
PUBLIC	??_C@_03FEINJDCO@rcd?$AA@			; `string'
PUBLIC	??_C@_03NDJFEDLA@icd?$AA@			; `string'
PUBLIC	??_C@_03EPKCJIIC@rwd?$AA@			; `string'
PUBLIC	??_C@_03MHMJKHAJ@vsd?$AA@			; `string'
PUBLIC	??_C@_03PHBOPPOH@swd?$AA@			; `string'
PUBLIC	??_C@_03BGCBGLFP@acd?$AA@			; `string'
PUBLIC	??_C@_03GIAPCECB@wld?$AA@			; `string'
PUBLIC	??_C@_03PCNBLEEE@phd?$AA@			; `string'
PUBLIC	??_C@_02FFNOOABO@pd?$AA@			; `string'
PUBLIC	??_C@_03IPHLCPFE@fed?$AA@			; `string'
PUBLIC	??_C@_03PABHFHDL@ssd?$AA@			; `string'
PUBLIC	??_C@_03BAFMNAMH@rkt?$AA@			; `string'
PUBLIC	??_C@_03KBOFKLN@ddp?$AA@			; `string'
PUBLIC	??_C@_08IEFAEBKE@?$CFs?2?$CFs?4?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BA@FMDFLPFF@Campaign?5Thread?$AA@	; `string'
PUBLIC	??_C@_0BC@HCOIBBLE@does?5this?5happen?$DP?$AA@	; `string'
PUBLIC	??_C@_0BL@BFGMPINB@Entering?5Campaign?5Day?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@KBGOGJHH@Refer?5?$CF08x?5?$CFd?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@NLIGDDPJ@DeRef?5?$CF08x?5?$CFd?5?$CFd?6?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3e800000
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@4479f99a
PUBLIC	__real@447a0000
PUBLIC	__real@47001fcd
PUBLIC	__real@47c35000
PUBLIC	__real@5127a358
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__controlfp:PROC
EXTRN	_memmove:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_stricmp:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_fwrite:PROC
EXTRN	_printf:PROC
EXTRN	_sprintf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	_MonoPrint:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Remove
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z:PROC ; VuSessionEntity::GetCameraEntity
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z:PROC ; VuGridIterator::VuGridIterator
EXTRN	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetFirst
EXTRN	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetNext
EXTRN	??0VuHashIterator@@QAE@PAVVuHashTable@@@Z:PROC	; VuHashIterator::VuHashIterator
EXTRN	??1VuHashIterator@@UAE@XZ:PROC			; VuHashIterator::~VuHashIterator
EXTRN	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ:PROC ; VuHashIterator::GetFirst
EXTRN	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ:PROC ; VuHashIterator::GetNext
EXTRN	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z:PROC ; VuSessionsIterator::VuSessionsIterator
EXTRN	??1VuSessionsIterator@@UAE@XZ:PROC		; VuSessionsIterator::~VuSessionsIterator
EXTRN	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetFirst
EXTRN	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetNext
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?DoCampaignDirtyData@FalconEntity@@SAXK@Z:PROC	; FalconEntity::DoCampaignDirtyData
EXTRN	?MakeFlagsDirty@FalconEntity@@QAEXXZ:PROC	; FalconEntity::MakeFlagsDirty
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?InitTheaterTerrain@@YAXXZ:PROC			; InitTheaterTerrain
EXTRN	?LoadTheaterTerrain@@YAHPAD@Z:PROC		; LoadTheaterTerrain
EXTRN	?SaveTheaterTerrain@@YAHPAD@Z:PROC		; SaveTheaterTerrain
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	??1BasePathClass@@QAE@XZ:PROC			; BasePathClass::~BasePathClass
EXTRN	??0PathClass@@QAE@XZ:PROC			; PathClass::PathClass
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?GetCurrentDay@CampaignClass@@QAEHXZ:PROC	; CampaignClass::GetCurrentDay
EXTRN	?IsMaster@CampaignClass@@QAEHXZ:PROC		; CampaignClass::IsMaster
EXTRN	?Resume@CampaignClass@@QAEXXZ:PROC		; CampaignClass::Resume
EXTRN	?SetBullseye@CampaignClass@@QAEXEFF@Z:PROC	; CampaignClass::SetBullseye
EXTRN	?Remove@CampBaseClass@@QAEHXZ:PROC		; CampBaseClass::Remove
EXTRN	?SetLocation@CampBaseClass@@QAEXFF@Z:PROC	; CampBaseClass::SetLocation
EXTRN	?RebuildObjectiveLists@@YAHXZ:PROC		; RebuildObjectiveLists
EXTRN	?RebuildParentsList@@YAHXZ:PROC			; RebuildParentsList
EXTRN	?StandardRebuild@@YAXXZ:PROC			; StandardRebuild
EXTRN	?InactivateUnit@@YAXPAVUnitClass@@@Z:PROC	; InactivateUnit
EXTRN	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z:PROC ; ATCBrain::InList
EXTRN	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z:PROC ; ATCBrain::AddTraffic
EXTRN	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z:PROC ; ATCBrain::FindFlightTakeoffTime
EXTRN	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z:PROC	; ATCBrain::FindBestTakeoffRunway
EXTRN	?AddObjectiveNeighbor@ObjectiveClass@@QAEXPAV1@QAE@Z:PROC ; ObjectiveClass::AddObjectiveNeighbor
EXTRN	?RemoveObjectiveNeighbor@ObjectiveClass@@QAEXH@Z:PROC ; ObjectiveClass::RemoveObjectiveNeighbor
EXTRN	?UpdateObjectiveLists@ObjectiveClass@@QAEXXZ:PROC ; ObjectiveClass::UpdateObjectiveLists
EXTRN	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z:PROC	; ObjectiveClass::GetNeighbor
EXTRN	?NewObjective@@YAPAVObjectiveClass@@XZ:PROC	; NewObjective
EXTRN	?RepairObjectives@@YAXXZ:PROC			; RepairObjectives
EXTRN	?SetFinal@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetFinal
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?ResetLocations@UnitClass@@QAEXFF@Z:PROC	; UnitClass::ResetLocations
EXTRN	?ResetDestinations@UnitClass@@QAEXFF@Z:PROC	; UnitClass::ResetDestinations
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetFirstUnit
EXTRN	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetNextUnit
EXTRN	?NewUnit@@YAPAVUnitClass@@HHHHPAV1@@Z:PROC	; NewUnit
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?SetEvalFlag@FlightClass@@QAEXEH@Z:PROC		; FlightClass::SetEvalFlag
EXTRN	?GetPilotCount@FlightClass@@QAEHXZ:PROC		; FlightClass::GetPilotCount
EXTRN	?GetACCount@FlightClass@@QAEHXZ:PROC		; FlightClass::GetACCount
EXTRN	?CancelFlight@@YAXPAVFlightClass@@@Z:PROC	; CancelFlight
EXTRN	?FindLinkPath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1W4MoveType@@@Z:PROC ; FindLinkPath
EXTRN	?SelectGroundAction@TeamClass@@QAEXXZ:PROC	; TeamClass::SelectGroundAction
EXTRN	?SelectAirActions@TeamClass@@QAEXXZ:PROC	; TeamClass::SelectAirActions
EXTRN	?GetTTRelations@@YAHEE@Z:PROC			; GetTTRelations
EXTRN	?AddReinforcements@@YAXEH@Z:PROC		; AddReinforcements
EXTRN	?UpdateTeamStatistics@@YAXXZ:PROC		; UpdateTeamStatistics
EXTRN	?BuildDivisionData@@YAXXZ:PROC			; BuildDivisionData
EXTRN	?ResetObjectiveAssignmentScores@@YAXXZ:PROC	; ResetObjectiveAssignmentScores
EXTRN	?UpdateUnit@@YAHPAVUnitClass@@K@Z:PROC		; UpdateUnit
EXTRN	?CheckTriggers@@YAHPAD@Z:PROC			; CheckTriggers
EXTRN	?LoadNames@@YAXPAD@Z:PROC			; LoadNames
EXTRN	?SaveNames@@YAHPAD@Z:PROC			; SaveNames
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?UpdateWeather@WeatherClass@@QAEXXZ:PROC	; WeatherClass::UpdateWeather
EXTRN	?ProduceSupplies@@YAHK@Z:PROC			; ProduceSupplies
EXTRN	?SupplyUnits@@YAHEK@Z:PROC			; SupplyUnits
EXTRN	?campaign_wait_for_sim@ThreadManager@@SA_NK@Z:PROC ; ThreadManager::campaign_wait_for_sim
EXTRN	?campaign_signal_sim@ThreadManager@@SAXXZ:PROC	; ThreadManager::campaign_signal_sim
EXTRN	?fast_campaign@ThreadManager@@SAXXZ:PROC	; ThreadManager::fast_campaign
EXTRN	?UpdatePlayer@FalconSessionEntity@@QAEXXZ:PROC	; FalconSessionEntity::UpdatePlayer
EXTRN	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z:PROC ; FalconSessionEntity::InSessionBubble
EXTRN	?UpdatePersistantObjectsWakeState@@YAXMMMK@Z:PROC ; UpdatePersistantObjectsWakeState
EXTRN	?UpdateNoCampaignParentObjectsWakeState@@YAXMMM@Z:PROC ; UpdateNoCampaignParentObjectsWakeState
EXTRN	?check_next_wave@instant_action@@SAXXZ:PROC	; instant_action::check_next_wave
EXTRN	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconSimCampMessage::FalconSimCampMessage
EXTRN	?CheckDivertStatus@@YAHH@Z:PROC			; CheckDivertStatus
EXTRN	?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z:PROC ; RecordExceptionInfo
EXTRN	?GetQueue@@YAHH@Z:PROC				; GetQueue
EXTRN	?SetTimeCompression@@YAXH@Z:PROC		; SetTimeCompression
EXTRN	?SetTemporaryCompression@@YAXH@Z:PROC		; SetTemporaryCompression
EXTRN	?PreEvalFlight@MissionEvaluationClass@@QAEXPAVFlightClass@@0@Z:PROC ; MissionEvaluationClass::PreEvalFlight
EXTRN	?CheckForVictory@@YAXXZ:PROC			; CheckForVictory
EXTRN	?SendRequestedData@@YAXXZ:PROC			; SendRequestedData
EXTRN	?CleanupCampaignUI@@YAXXZ:PROC			; CleanupCampaignUI
EXTRN	?CleanupTacticalEngagementUI@@YAXXZ:PROC	; CleanupTacticalEngagementUI
EXTRN	?RebuildATMLists@@YAXXZ:PROC			; RebuildATMLists
EXTRN	?UI_HandleFlightCancel@@YAXXZ:PROC		; UI_HandleFlightCancel
EXTRN	?UI_HandleAircraftDestroyed@@YAXXZ:PROC		; UI_HandleAircraftDestroyed
EXTRN	?UI_HandleFlightScrub@@YAXXZ:PROC		; UI_HandleFlightScrub
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuLocalSession@@3VVU_ID@@A:QWORD		; vuLocalSession
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?SimLibElapsedSeconds@@3MA:DWORD		; SimLibElapsedSeconds
EXTRN	?SimLibFrameElapsed@@3MA:DWORD			; SimLibFrameElapsed
EXTRN	?SimLibLastFrameTime@@3MA:DWORD			; SimLibLastFrameTime
EXTRN	?Map_Max_X@@3FA:WORD				; Map_Max_X
EXTRN	?Map_Max_Y@@3FA:WORD				; Map_Max_Y
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?AllParentList@@3PAVVuLinkedList@@A:DWORD	; AllParentList
EXTRN	?AllRealList@@3PAVVuLinkedList@@A:DWORD		; AllRealList
EXTRN	?FrontList@@3PAVFalconPrivateList@@A:DWORD	; FrontList
EXTRN	?deaggregatedEntities@@3PAVVuHashTable@@A:DWORD	; deaggregatedEntities
EXTRN	?ObjProxList@@3PAVVuGridTree@@A:DWORD		; ObjProxList
EXTRN	?RealUnitProxList@@3PAVVuGridTree@@A:DWORD	; RealUnitProxList
EXTRN	?VICTORY_CHECK_TIME@@3FA:WORD			; VICTORY_CHECK_TIME
EXTRN	?MIN_PLAN_GROUND@@3FA:WORD			; MIN_PLAN_GROUND
EXTRN	?REGAIN_RATE_MULTIPLIER_FOR_TE@@3FA:WORD	; REGAIN_RATE_MULTIPLIER_FOR_TE
EXTRN	?PLAYER_BUBBLE_MOVERS@@3FA:WORD			; PLAYER_BUBBLE_MOVERS
EXTRN	?REAGREGATION_RATIO@@3MA:DWORD			; REAGREGATION_RATIO
EXTRN	?SIM_BUBBLE_SIZE@@3MA:DWORD			; SIM_BUBBLE_SIZE
EXTRN	?TheaterXPosition@@3HA:DWORD			; TheaterXPosition
EXTRN	?TheaterYPosition@@3HA:DWORD			; TheaterYPosition
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?FalconObjectDataDir@@3PADA:BYTE		; FalconObjectDataDir
EXTRN	?FalconCampaignSaveDirectory@@3PADA:BYTE	; FalconCampaignSaveDirectory
EXTRN	?FalconCampUserSaveDirectory@@3PADA:BYTE	; FalconCampUserSaveDirectory
EXTRN	?realWeather@@3PAVRealWeather@@A:DWORD		; realWeather
EXTRN	?campaign_thread@ThreadManager@@0UThreadInfo@@A:BYTE ; ThreadManager::campaign_thread
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?currentMode@SimulationLoopControl@@1W4SimLoopControlMode@1@A:DWORD ; SimulationLoopControl::currentMode
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?gCommsMgr@@3PAVUIComms@@A:DWORD		; gCommsMgr
EXTRN	?FalconDisplay@@3VFalconDisplayConfiguration@@A:BYTE ; FalconDisplay
EXTRN	?gameCompressionRatio@@3HA:DWORD		; gameCompressionRatio
EXTRN	?targetCompressionRatio@@3HA:DWORD		; targetCompressionRatio
EXTRN	?g_bFloatingBullseye@@3_NA:BYTE			; g_bFloatingBullseye
EXTRN	?g_bServer@@3_NA:BYTE				; g_bServer
EXTRN	?g_bServerHostAll@@3_NA:BYTE			; g_bServerHostAll
EXTRN	?g_nDeagTimer@@3HA:DWORD			; g_nDeagTimer
EXTRN	?g_bMPStartRestricted@@3_NA:BYTE		; g_bMPStartRestricted
EXTRN	?g_nMPStartTime@@3HA:DWORD			; g_nMPStartTime
EXTRN	?g_nChooseBullseyeFix@@3HA:DWORD		; g_nChooseBullseyeFix
EXTRN	?g_nTaxiLaunchTime@@3HA:DWORD			; g_nTaxiLaunchTime
EXTRN	?doUI@@3HA:DWORD				; doUI
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?g_bSleepAll@@3_NA:BYTE				; g_bSleepAll
EXTRN	?g_brebuildbobbleFix@@3_NA:BYTE			; g_brebuildbobbleFix
EXTRN	?g_bLogEvents@@3_NA:BYTE			; g_bLogEvents
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?timer@?1??TimeOfDayGeneral@@YAHK@Z@4KA
_BSS	SEGMENT
?timer@?1??TimeOfDayGeneral@@YAHK@Z@4KA DD 01H DUP (?)	; `TimeOfDayGeneral'::`2'::timer
_BSS	ENDS
;	COMDAT ?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA
_BSS	SEGMENT
?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA DD 01H DUP (?)	; `TimeOfDayGeneral'::`2'::tod
_BSS	ENDS
;	COMDAT ?wokentotal@?L@??RebuildBubble@@YAXH@Z@4HA
_BSS	SEGMENT
?wokentotal@?L@??RebuildBubble@@YAXH@Z@4HA DD 01H DUP (?) ; `RebuildBubble'::`11'::wokentotal
_BSS	ENDS
;	COMDAT ?wokentotal@?DK@??RebuildBubble@@YAXH@Z@4HA
_BSS	SEGMENT
?wokentotal@?DK@??RebuildBubble@@YAXH@Z@4HA DD 01H DUP (?) ; `RebuildBubble'::`58'::wokentotal
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_wch_filename DB 0410H DUP (?)
_camp_fp DD	01H DUP (?)
_camp_names DB	01fe0H DUP (?)
_camp_file_name DB 0104H DUP (?)
_camp_num_files DD 01H DUP (?)
_camp_offset DD	020H DUP (?)
_camp_size DD	020H DUP (?)
_camp_game_type DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA
_BSS	SEGMENT
?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA DD 01H DUP (?) ; `SetEntryTime'::`2'::timer
_BSS	ENDS
;	COMDAT ?startvuxGameTime@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA
_BSS	SEGMENT
?startvuxGameTime@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA DD 01H DUP (?) ; `SetEntryTime'::`2'::startvuxGameTime
_BSS	ENDS
;	COMDAT ?starttimer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA
_BSS	SEGMENT
?starttimer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA DD 01H DUP (?) ; `SetEntryTime'::`2'::starttimer
_BSS	ENDS
;	COMDAT ?lastchoice@?O@??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA
_BSS	SEGMENT
?lastchoice@?O@??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA DD 01H DUP (?) ; `SetEntryTime'::`14'::lastchoice
_BSS	ENDS
;	COMDAT ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA
_BSS	SEGMENT
?stage@?1??DoTacticalLoop@@YAXH@Z@4HA DD 01H DUP (?)	; `DoTacticalLoop'::`2'::stage
_BSS	ENDS
;	COMDAT ?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA
_BSS	SEGMENT
?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA DD 01H DUP (?) ; `DoTacticalLoop'::`2'::lastStage
_BSS	ENDS
;	COMDAT ?lastCheck@?1??DoTacticalLoop@@YAXH@Z@4KA
_BSS	SEGMENT
?lastCheck@?1??DoTacticalLoop@@YAXH@Z@4KA DD 01H DUP (?) ; `DoTacticalLoop'::`2'::lastCheck
_BSS	ENDS
;	COMDAT ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA
_BSS	SEGMENT
?stage@?1??DoCampaignLoop@@YAXH@Z@4HA DD 01H DUP (?)	; `DoCampaignLoop'::`2'::stage
_BSS	ENDS
;	COMDAT ?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA
_BSS	SEGMENT
?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA DD 01H DUP (?) ; `DoCampaignLoop'::`2'::lastStage
_BSS	ENDS
;	COMDAT ?planCount@?1??DoCampaignLoop@@YAXH@Z@4HA
_BSS	SEGMENT
?planCount@?1??DoCampaignLoop@@YAXH@Z@4HA DD 01H DUP (?) ; `DoCampaignLoop'::`2'::planCount
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@5127a358
CONST	SEGMENT
__real@5127a358 DD 05127a358r			; 4.5e+010
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@47001fcd
CONST	SEGMENT
__real@47001fcd DD 047001fcdr			; 32799.8
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@4479f99a
CONST	SEGMENT
__real@4479f99a DD 04479f99ar			; 999.9
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLIGDDPJ@DeRef?5?$CF08x?5?$CFd?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@NLIGDDPJ@DeRef?5?$CF08x?5?$CFd?5?$CFd?6?$AA@ DB 'DeRef %08x %d '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBGOGJHH@Refer?5?$CF08x?5?$CFd?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@KBGOGJHH@Refer?5?$CF08x?5?$CFd?5?$CFd?6?$AA@ DB 'Refer %08x %d '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BFGMPINB@Entering?5Campaign?5Day?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@BFGMPINB@Entering?5Campaign?5Day?3?5?$CFd?6?$AA@ DB 'Entering C'
	DB	'ampaign Day: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HCOIBBLE@does?5this?5happen?$DP?$AA@
CONST	SEGMENT
??_C@_0BC@HCOIBBLE@does?5this?5happen?$DP?$AA@ DB 'does this happen?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMDFLPFF@Campaign?5Thread?$AA@
CONST	SEGMENT
??_C@_0BA@FMDFLPFF@Campaign?5Thread?$AA@ DB 'Campaign Thread', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IEFAEBKE@?$CFs?2?$CFs?4?$CFs?$AA@
CONST	SEGMENT
??_C@_08IEFAEBKE@?$CFs?2?$CFs?4?$CFs?$AA@ DB '%s\%s.%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KBOFKLN@ddp?$AA@
CONST	SEGMENT
??_C@_03KBOFKLN@ddp?$AA@ DB 'ddp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BAFMNAMH@rkt?$AA@
CONST	SEGMENT
??_C@_03BAFMNAMH@rkt?$AA@ DB 'rkt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PABHFHDL@ssd?$AA@
CONST	SEGMENT
??_C@_03PABHFHDL@ssd?$AA@ DB 'ssd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IPHLCPFE@fed?$AA@
CONST	SEGMENT
??_C@_03IPHLCPFE@fed?$AA@ DB 'fed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FFNOOABO@pd?$AA@
CONST	SEGMENT
??_C@_02FFNOOABO@pd?$AA@ DB 'pd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PCNBLEEE@phd?$AA@
CONST	SEGMENT
??_C@_03PCNBLEEE@phd?$AA@ DB 'phd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GIAPCECB@wld?$AA@
CONST	SEGMENT
??_C@_03GIAPCECB@wld?$AA@ DB 'wld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BGCBGLFP@acd?$AA@
CONST	SEGMENT
??_C@_03BGCBGLFP@acd?$AA@ DB 'acd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHBOPPOH@swd?$AA@
CONST	SEGMENT
??_C@_03PHBOPPOH@swd?$AA@ DB 'swd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHMJKHAJ@vsd?$AA@
CONST	SEGMENT
??_C@_03MHMJKHAJ@vsd?$AA@ DB 'vsd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EPKCJIIC@rwd?$AA@
CONST	SEGMENT
??_C@_03EPKCJIIC@rwd?$AA@ DB 'rwd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDJFEDLA@icd?$AA@
CONST	SEGMENT
??_C@_03NDJFEDLA@icd?$AA@ DB 'icd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEINJDCO@rcd?$AA@
CONST	SEGMENT
??_C@_03FEINJDCO@rcd?$AA@ DB 'rcd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GDFDGDBM@wcd?$AA@
CONST	SEGMENT
??_C@_03GDFDGDBM@wcd?$AA@ DB 'wcd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLOPAEHJ@vcd?$AA@
CONST	SEGMENT
??_C@_03NLOPAEHJ@vcd?$AA@ DB 'vcd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILPGFDOG@fcd?$AA@
CONST	SEGMENT
??_C@_03ILPGFDOG@fcd?$AA@ DB 'fcd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PGPOBMGM@ocd?$AA@
CONST	SEGMENT
??_C@_03PGPOBMGM@ocd?$AA@ DB 'ocd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJFKKLJH@ucd?$AA@
CONST	SEGMENT
??_C@_03MJFKKLJH@ucd?$AA@ DB 'ucd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOODKOKO@ini?$AA@
CONST	SEGMENT
??_C@_03GOODKOKO@ini?$AA@ DB 'ini', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BHMOPGG@ct?$AA@
CONST	SEGMENT
??_C@_02BHMOPGG@ct?$AA@ DB 'ct', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DPEHCIMJ@pol?$AA@
CONST	SEGMENT
??_C@_03DPEHCIMJ@pol?$AA@ DB 'pol', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDJDIDFF@sqd?$AA@
CONST	SEGMENT
??_C@_03PDJDIDFF@sqd?$AA@ DB 'sqd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OGKPNJEB@smd?$AA@
CONST	SEGMENT
??_C@_03OGKPNJEB@smd?$AA@ DB 'smd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELHHBHJL@evl?$AA@
CONST	SEGMENT
??_C@_03ELHHBHJL@evl?$AA@ DB 'evl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJKMHLPI@tri?$AA@
CONST	SEGMENT
??_C@_03NJKMHLPI@tri?$AA@ DB 'tri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JJLJNLDJ@mil?$AA@
CONST	SEGMENT
??_C@_03JJLJNLDJ@mil?$AA@ DB 'mil', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LPBKAOMJ@plt?$AA@
CONST	SEGMENT
??_C@_03LPBKAOMJ@plt?$AA@ DB 'plt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NGIPJJOF@wth?$AA@
CONST	SEGMENT
??_C@_03NGIPJJOF@wth?$AA@ DB 'wth', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IBMEEAF@tea?$AA@
CONST	SEGMENT
??_C@_03IBMEEAF@tea?$AA@ DB 'tea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HECMEGIJ@uni?$AA@
CONST	SEGMENT
??_C@_03HECMEGIJ@uni?$AA@ DB 'uni', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHDMHGFL@obd?$AA@
CONST	SEGMENT
??_C@_03PHDMHGFL@obd?$AA@ DB 'obd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLPFLNF@obj?$AA@
CONST	SEGMENT
??_C@_03GJLPFLNF@obj?$AA@ DB 'obj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIBIFJIL@cmp?$AA@
CONST	SEGMENT
??_C@_03JIBIFJIL@cmp?$AA@ DB 'cmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JLPBKNLG@OpenCampFile?5?$CFs?4?$CFs?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@JLPBKNLG@OpenCampFile?5?$CFs?4?$CFs?5?$CFs?6?$AA@ DB 'OpenCampF'
	DB	'ile %s.%s %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MPOGCMBA@wch?$AA@
CONST	SEGMENT
??_C@_03MPOGCMBA@wch?$AA@ DB 'wch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLHKKLJD@Cannot?5Open?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BA@LLHKKLJD@Cannot?5Open?5?$CFs?6?$AA@ DB 'Cannot Open %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HFIHGAB@Already?5Reading?5Campressed?5File?6@
CONST	SEGMENT
??_C@_0CB@HFIHGAB@Already?5Reading?5Campressed?5File?6@ DB 'Already Readi'
	DB	'ng Campressed File', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KALBFCKF@?$CFs?2?$CFs?4cam?$AA@
CONST	SEGMENT
??_C@_09KALBFCKF@?$CFs?2?$CFs?4cam?$AA@ DB '%s\%s.cam', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FIDCHDGJ@?$CFs?2?$CFs?4trn?$AA@
CONST	SEGMENT
??_C@_09FIDCHDGJ@?$CFs?2?$CFs?4trn?$AA@ DB '%s\%s.trn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDPMBAAN@?$CFs?2?$CFs?4tac?$AA@
CONST	SEGMENT
??_C@_09PDPMBAAN@?$CFs?2?$CFs?4tac?$AA@ DB '%s\%s.tac', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JKHCDKNK@Failed?5to?5open?5theater?3?5?$CFs?0?5usin@
CONST	SEGMENT
??_C@_0DE@JKHCDKNK@Failed?5to?5open?5theater?3?5?$CFs?0?5usin@ DB 'Failed'
	DB	' to open theater: %s, using default theater.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?UpdatePlayerSessions@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayerSessions@@YAXXZ$0
__unwindtable$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z$0
__unwindtable$?ChooseBullseye@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseBullseye@@YAXXZ$0
__unwindtable$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z$0
__unwindtable$?RallyUnits@@YAXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RallyUnits@@YAXH@Z$0
__unwindtable$?UpdateRealUnits@@YAXK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateRealUnits@@YAXK@Z$0
__unwindtable$?UpdateParentUnits@@YAXK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateParentUnits@@YAXK@Z$0
__unwindtable$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z$0
__unwindtable$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z$1
__sehtable$?CampaignThread@@YGIXZ DD 0fffffffeH
	DD	00H
	DD	0ffffffd4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN10@CampaignTh
	DD	FLAT:$LN6@CampaignTh
__ehfuncinfo$?UpdatePlayerSessions@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdatePlayerSessions@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ChooseBullseye@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChooseBullseye@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RebuildBubble@@YAXH@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?RebuildBubble@@YAXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RallyUnits@@YAXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RallyUnits@@YAXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?UpdateRealUnits@@YAXK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateRealUnits@@YAXK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?UpdateParentUnits@@YAXK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateParentUnits@@YAXK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RebuildBubble@@YAXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$14
	DD	01H
	DD	FLAT:__unwindfunclet$?RebuildBubble@@YAXH@Z$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_refs$ = 12						; size = 4
?OutputDeref@@YAXPAVVuEntity@@H@Z PROC			; OutputDeref

; 2863 : {

	push	ebp
	mov	ebp, esp

; 2864 : 	MonoPrint ("DeRef %08x %d %d\n", ent, ent->Type(), refs - 1);

	mov	eax, DWORD PTR _refs$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@NLIGDDPJ@DeRef?5?$CF08x?5?$CFd?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 16					; 00000010H

; 2865 : }

	pop	ebp
	ret	0
?OutputDeref@@YAXPAVVuEntity@@H@Z ENDP			; OutputDeref
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_refs$ = 12						; size = 4
?OutputRef@@YAXPAVVuEntity@@H@Z PROC			; OutputRef

; 2858 : {

	push	ebp
	mov	ebp, esp

; 2859 : 	MonoPrint ("Refer %08x %d %d\n", ent, ent->Type(), refs + 1);

	mov	eax, DWORD PTR _refs$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@KBGOGJHH@Refer?5?$CF08x?5?$CFd?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 16					; 00000010H

; 2860 : }

	pop	ebp
	ret	0
?OutputRef@@YAXPAVVuEntity@@H@Z ENDP			; OutputRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?PauseTacticalEngagement@@YAXXZ PROC			; PauseTacticalEngagement

; 2848 : {

	push	ebp
	mov	ebp, esp

; 2849 : 	TheCampaign.Flags |= CAMP_TACTICAL_PAUSE;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	or	eax, 262144				; 00040000H
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, eax

; 2850 : }

	pop	ebp
	ret	0
?PauseTacticalEngagement@@YAXXZ ENDP			; PauseTacticalEngagement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?RemoveTacticalEdit@@YAXXZ PROC				; RemoveTacticalEdit

; 2843 : {

	push	ebp
	mov	ebp, esp

; 2844 : 	TheCampaign.Flags &= ~CAMP_TACTICAL_EDIT;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, -524289				; fff7ffffH
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, eax

; 2845 : }

	pop	ebp
	ret	0
?RemoveTacticalEdit@@YAXXZ ENDP				; RemoveTacticalEdit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?MakeTacticalEdit@@YAXXZ PROC				; MakeTacticalEdit

; 2838 : {

	push	ebp
	mov	ebp, esp

; 2839 : 	TheCampaign.Flags |= CAMP_TACTICAL_EDIT;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	or	eax, 524288				; 00080000H
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, eax

; 2840 : }

	pop	ebp
	ret	0
?MakeTacticalEdit@@YAXXZ ENDP				; MakeTacticalEdit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_Result$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?CampaignThread@@YGIXZ PROC				; CampaignThread

; 2460 : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?CampaignThread@@YGIXZ
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -12				; fffffff4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 2461 : 	int Result = 0;

	mov	DWORD PTR _Result$[ebp], 0

; 2462 : 	__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 2463 : 	{
; 2464 : 		Result = HandleCampaignThread();

	call	?HandleCampaignThread@@YGIXZ		; HandleCampaignThread
	mov	DWORD PTR _Result$[ebp], eax

; 2465 : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN8@CampaignTh
$LN5@CampaignTh:
$LN10@CampaignTh:

; 2466 : 	__except(RecordExceptionInfo(GetExceptionInformation(), "Campaign Thread"))

	push	OFFSET ??_C@_0BA@FMDFLPFF@Campaign?5Thread?$AA@
	mov	eax, DWORD PTR __$SEHRec$[ebp+4]
	push	eax
	call	?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z ; RecordExceptionInfo
	add	esp, 8
$LN7@CampaignTh:
$LN9@CampaignTh:
	ret	0
$LN6@CampaignTh:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 2467 : 	{
; 2468 : 		// Do nothing here - RecordExceptionInfo() has already done
; 2469 : 		// everything that is needed. Actually this code won't even
; 2470 : 		// get called unless you return EXCEPTION_EXECUTE_HANDLER from
; 2471 : 		// the __except clause.
; 2472 : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN8@CampaignTh:

; 2473 : 	return Result;

	mov	eax, DWORD PTR _Result$[ebp]
$LN4@CampaignTh:

; 2474 : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CampaignThread@@YGIXZ ENDP				; CampaignThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
tv205 = -24						; size = 4
tv170 = -20						; size = 4
tv140 = -16						; size = 4
_sleepTic$ = -12					; size = 4
_startup$ = -8						; size = 4
_deltatime$ = -4					; size = 4
?HandleCampaignThread@@YGIXZ PROC			; HandleCampaignThread

; 2288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2289 : 	CampaignTime	deltatime;
; 2290 : 	int				sleepTic;
; 2291 : 	int startup=0;

	mov	DWORD PTR _startup$[ebp], 0

; 2292 : 
; 2293 : #if defined(_MSC_VER)
; 2294 : 	// Set the FPU to Truncate
; 2295 : 	_controlfp( _RC_CHOP, MCW_RC );

	push	768					; 00000300H
	push	768					; 00000300H
	call	__controlfp
	add	esp, 8

; 2296 : 
; 2297 : 	// Set the FPU to 24 bit precision
; 2298 : 	_controlfp( _PC_24, MCW_PC );

	push	196608					; 00030000H
	push	131072					; 00020000H
	call	__controlfp
	add	esp, 8

; 2299 : #endif
; 2300 : 
; 2301 : 	TheCampaign.Flags |= CAMP_RUNNING;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	or	eax, 1
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, eax
$LN19@HandleCamp:

; 2302 : 	while (ThreadManager::campaign_active()){

	call	?campaign_active@ThreadManager@@SAHXZ	; ThreadManager::campaign_active
	test	eax, eax
	je	$LN18@HandleCamp

; 2303 : 		sleepTic = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _sleepTic$[ebp], eax

; 2304 : 
; 2305 : 		//START_PROFILE("CA VU UPD");
; 2306 : 		CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2307 : #if CAP_DISPATCH
; 2308 : 		// sfr: theres a duplicate call at the end. I think this one should be removed
; 2309 : 		// 20 ms at most
; 2310 : 		TheCampaign.vuThread->Update(20);

	push	20					; 00000014H
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+264
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+264
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 2311 : #else
; 2312 : 		TheCampaign.vuThread->Update();
; 2313 : #endif
; 2314 : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2315 : 		//STOP_PROFILE("CA VU UPD");
; 2316 : 
; 2317 : 		if (TheCampaign.Flags & CAMP_SUSPEND_REQUEST){

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	ecx, 8
	je	SHORT $LN17@HandleCamp

; 2318 : 			// Someone's asked us to suspend
; 2319 : 			TheCampaign.Flags |= CAMP_SUSPENDED;

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	or	edx, 16					; 00000010H
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, edx

; 2320 : 			TheCampaign.Flags ^= CAMP_SUSPEND_REQUEST;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	xor	eax, 8
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, eax
$LN17@HandleCamp:

; 2321 : 		}
; 2322 : 
; 2323 : 		//START_PROFILE("CA SENDDATA");
; 2324 : 		// Send any data that's been requested of us.
; 2325 : 		SendRequestedData();

	call	?SendRequestedData@@YAXXZ		; SendRequestedData

; 2326 : 		//STOP_PROFILE("CA SENDDATA");
; 2327 : 
; 2328 : 		// sfr: if we do this here, we risk processing it while 
; 2329 : 		// the UI is closing. This is wrong, passing to after the suspended stuff
; 2330 : #define NEW_UPDATE_HANDLE_CAMPAIGN 1
; 2331 : #if !NEW_UPDATE_HANDLE_CAMPAIGN
; 2332 : 		UpdatePlayerSessions();
; 2333 : 		// Send Dirty Campaign Objects
; 2334 : 		FalconEntity::DoCampaignDirtyData(vuxRealTime);
; 2335 : #endif
; 2336 : 
; 2337 : 		if ((TheCampaign.Flags & CAMP_SUSPENDED) || (TheCampaign.Flags & CAMP_TACTICAL_PAUSE)){

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	ecx, 16					; 00000010H
	jne	SHORT $LN15@HandleCamp
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 262144				; 00040000H
	je	$LN16@HandleCamp
$LN15@HandleCamp:

; 2338 : 			// sfr: placed this one inside cs like the others
; 2339 : 			CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2340 : #if CAP_DISPATCH
; 2341 : 			TheCampaign.vuThread->Update(-1);

	push	-1
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+264
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+264
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 2342 : #else
; 2343 : 			TheCampaign.vuThread->Update();
; 2344 : #endif
; 2345 : 			CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2346 : 			gCampTime = GetTickCount() - sleepTic;

	call	DWORD PTR __imp__GetTickCount@0
	sub	eax, DWORD PTR _sleepTic$[ebp]
	mov	DWORD PTR ?gCampTime@@3HA, eax		; gCampTime

; 2347 : 			gAveCampTime = (gAveCampTime * 7 + gCampTime)/8;

	mov	eax, DWORD PTR ?gAveCampTime@@3HA	; gAveCampTime
	imul	eax, 7
	add	eax, DWORD PTR ?gCampTime@@3HA		; gCampTime
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR ?gAveCampTime@@3HA, eax	; gAveCampTime

; 2348 : 			sleepTic = 100 * 100 / max(gAveCampTime,10);

	cmp	DWORD PTR ?gAveCampTime@@3HA, 10	; gAveCampTime, 0000000aH
	jle	SHORT $LN22@HandleCamp
	mov	ecx, DWORD PTR ?gAveCampTime@@3HA	; gAveCampTime
	mov	DWORD PTR tv140[ebp], ecx
	jmp	SHORT $LN23@HandleCamp
$LN22@HandleCamp:
	mov	DWORD PTR tv140[ebp], 10		; 0000000aH
$LN23@HandleCamp:
	mov	eax, 10000				; 00002710H
	cdq
	idiv	DWORD PTR tv140[ebp]
	mov	DWORD PTR _sleepTic$[ebp], eax

; 2349 : 			ThreadManager::campaign_signal_sim();

	call	?campaign_signal_sim@ThreadManager@@SAXXZ ; ThreadManager::campaign_signal_sim

; 2350 : #if NEW_SYNC
; 2351 : 			ThreadManager::campaign_wait_for_sim(INFINITE);

	push	-1
	call	?campaign_wait_for_sim@ThreadManager@@SA_NK@Z ; ThreadManager::campaign_wait_for_sim
	add	esp, 4

; 2352 : #else
; 2353 : 			ThreadManager::campaign_wait_for_sim(max(sleepTic,300));
; 2354 : #endif
; 2355 : 			continue;

	jmp	$LN19@HandleCamp
$LN16@HandleCamp:

; 2356 : 		}
; 2357 : 
; 2358 : #if NEW_UPDATE_HANDLE_CAMPAIGN
; 2359 : 		UpdatePlayerSessions();

	call	?UpdatePlayerSessions@@YAXXZ		; UpdatePlayerSessions

; 2360 : 		// Send Dirty Campaign Objects
; 2361 : 		FalconEntity::DoCampaignDirtyData(vuxRealTime);

	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	push	edx
	call	?DoCampaignDirtyData@FalconEntity@@SAXK@Z ; FalconEntity::DoCampaignDirtyData
	add	esp, 4

; 2362 : #endif
; 2363 : 
; 2364 : 		// Do any time compression stuff (i.e: For takeoff) and launch the sim, if necessary
; 2365 : 		DoCompressionLoop();

	call	?DoCompressionLoop@@YAXXZ		; DoCompressionLoop

; 2366 : 
; 2367 : 		ShiAssert (TheCampaign.CurrentTime <= vuxGameTime);
; 2368 : 
; 2369 : 		// Update our time (1 minute max delta)
; 2370 : 		deltatime = vuxGameTime - TheCampaign.CurrentTime;

	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	sub	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR _deltatime$[ebp], eax

; 2371 : 		if (deltatime > CampaignMinutes){

	cmp	DWORD PTR _deltatime$[ebp], 60000	; 0000ea60H
	jbe	SHORT $LN14@HandleCamp

; 2372 : 			// 1 minute maximum time delta
; 2373 : 			deltatime = CampaignMinutes;

	mov	DWORD PTR _deltatime$[ebp], 60000	; 0000ea60H

; 2374 : 			if (gameCompressionRatio > 0 /*1*/){

	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 0	; gameCompressionRatio
	jle	SHORT $LN13@HandleCamp

; 2375 : 				SetTemporaryCompression (gameCompressionRatio / 2);	// Slow things down

	mov	eax, DWORD PTR ?gameCompressionRatio@@3HA ; gameCompressionRatio
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	call	?SetTemporaryCompression@@YAXH@Z	; SetTemporaryCompression
	add	esp, 4
$LN13@HandleCamp:

; 2376 : 			}
; 2377 : 		}

	jmp	SHORT $LN12@HandleCamp
$LN14@HandleCamp:

; 2378 : 		else if (gameCompressionRatio != targetCompressionRatio){

	mov	ecx, DWORD PTR ?gameCompressionRatio@@3HA ; gameCompressionRatio
	cmp	ecx, DWORD PTR ?targetCompressionRatio@@3HA ; targetCompressionRatio
	je	SHORT $LN12@HandleCamp

; 2379 : 			SetTemporaryCompression (targetCompressionRatio);		// Back to full speed

	mov	edx, DWORD PTR ?targetCompressionRatio@@3HA ; targetCompressionRatio
	push	edx
	call	?SetTemporaryCompression@@YAXH@Z	; SetTemporaryCompression
	add	esp, 4
$LN12@HandleCamp:

; 2380 : 		}
; 2381 : 
; 2382 : 		TheCampaign.CurrentTime += deltatime;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	add	eax, DWORD PTR _deltatime$[ebp]
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A, eax

; 2383 : 		TheCampaign.TimeOfDay = TheCampaign.CurrentTime % CampaignDay;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	xor	edx, edx
	mov	ecx, 86400000				; 05265c00H
	div	ecx
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+12, edx

; 2384 : 
; 2385 : 		if (deltatime > 0 && (TheCampaign.Flags & CAMP_LOADED)){

	cmp	DWORD PTR _deltatime$[ebp], 0
	jbe	$LN10@HandleCamp
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 2
	je	$LN10@HandleCamp

; 2386 : 			if (sCampaignStartingUp == CAMP_STARTING_UP){

	cmp	DWORD PTR _sCampaignStartingUp, 1
	jne	SHORT $LN9@HandleCamp

; 2387 : 				startup=1;

	mov	DWORD PTR _startup$[ebp], 1
$LN9@HandleCamp:

; 2388 : 			}
; 2389 : 
; 2390 : 			// Check for instant action's next wave time
; 2391 : 			if (FalconLocalGame->GetGameType () == game_InstantAction){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@HandleCamp
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $LN25@HandleCamp
$LN24@HandleCamp:
	mov	DWORD PTR tv170[ebp], 0
$LN25@HandleCamp:
	mov	ecx, DWORD PTR tv170[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	jne	SHORT $LN8@HandleCamp

; 2392 : 				instant_action::check_next_wave ();

	call	?check_next_wave@instant_action@@SAXXZ	; instant_action::check_next_wave
$LN8@HandleCamp:

; 2393 : 			}
; 2394 : 
; 2395 : 			//START_PROFILE("CAMPLOOP");
; 2396 : 			if (!(TheCampaign.Flags & CAMP_LIGHT) && TheCampaign.IsMaster()){

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	ecx, 128				; 00000080H
	jne	SHORT $LN7@HandleCamp
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?IsMaster@CampaignClass@@QAEHXZ		; CampaignClass::IsMaster
	test	eax, eax
	je	SHORT $LN7@HandleCamp

; 2397 : 				if (TheCampaign.Flags & CAMP_TACTICAL){

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 1024				; 00000400H
	je	SHORT $LN6@HandleCamp

; 2398 : 					DoTacticalLoop(startup);

	mov	eax, DWORD PTR _startup$[ebp]
	push	eax
	call	?DoTacticalLoop@@YAXH@Z			; DoTacticalLoop
	add	esp, 4

; 2399 : 				}
; 2400 : 				else {

	jmp	SHORT $LN7@HandleCamp
$LN6@HandleCamp:

; 2401 : 					DoCampaignLoop(startup);

	mov	ecx, DWORD PTR _startup$[ebp]
	push	ecx
	call	?DoCampaignLoop@@YAXH@Z			; DoCampaignLoop
	add	esp, 4
$LN7@HandleCamp:

; 2402 : 				}
; 2403 : 			}
; 2404 : 			//STOP_PROFILE("CAMPLOOP");
; 2405 : 
; 2406 : 			// sfr: this is duplicated from above.
; 2407 : 			// maybe we should leave only one
; 2408 : 			// Process any events which we've collected, and do vu cleanup
; 2409 : 			CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2410 : #if CAP_DISPATCH
; 2411 : 			// 20 ms at most
; 2412 : 			TheCampaign.vuThread->Update(20);

	push	20					; 00000014H
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+264
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+264
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 2413 : #else
; 2414 : 			TheCampaign.vuThread->Update();
; 2415 : #endif
; 2416 : 			CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2417 : 
; 2418 : 			//START_PROFILE("CA UPDATE ALL REAL");
; 2419 : 			if (TheCampaign.IsMaster())	{

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?IsMaster@CampaignClass@@QAEHXZ		; CampaignClass::IsMaster
	test	eax, eax
	je	SHORT $LN10@HandleCamp

; 2420 : 				// Move our units
; 2421 : 				UpdateRealUnits(deltatime);

	mov	eax, DWORD PTR _deltatime$[ebp]
	push	eax
	call	?UpdateRealUnits@@YAXK@Z		; UpdateRealUnits
	add	esp, 4
$LN10@HandleCamp:

; 2422 : 			}
; 2423 : 			//STOP_PROFILE("CA UPDATE ALL REAL");
; 2424 : 		}
; 2425 : 
; 2426 : 		if (startup){

	cmp	DWORD PTR _startup$[ebp], 0
	je	SHORT $LN3@HandleCamp

; 2427 : 			ThreadManager::fast_campaign ();

	call	?fast_campaign@ThreadManager@@SAXXZ	; ThreadManager::fast_campaign

; 2428 : 			sCampaignStartingUp = CAMP_NORMAL_MODE;

	mov	DWORD PTR _sCampaignStartingUp, 0

; 2429 : 			startup = 0;

	mov	DWORD PTR _startup$[ebp], 0
$LN3@HandleCamp:

; 2430 : 		}
; 2431 : 
; 2432 : 		if (!doUI){

	cmp	DWORD PTR ?doUI@@3HA, 0			; doUI
	jne	SHORT $LN2@HandleCamp

; 2433 : 			gCampTime = GetTickCount() - sleepTic;

	call	DWORD PTR __imp__GetTickCount@0
	sub	eax, DWORD PTR _sleepTic$[ebp]
	mov	DWORD PTR ?gCampTime@@3HA, eax		; gCampTime

; 2434 : 			gAveCampTime = (gAveCampTime * 7 + gCampTime)/8;

	mov	eax, DWORD PTR ?gAveCampTime@@3HA	; gAveCampTime
	imul	eax, 7
	add	eax, DWORD PTR ?gCampTime@@3HA		; gCampTime
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR ?gAveCampTime@@3HA, eax	; gAveCampTime

; 2435 : 			sleepTic = 100 * 100 / max(gAveCampTime,10);

	cmp	DWORD PTR ?gAveCampTime@@3HA, 10	; gAveCampTime, 0000000aH
	jle	SHORT $LN26@HandleCamp
	mov	ecx, DWORD PTR ?gAveCampTime@@3HA	; gAveCampTime
	mov	DWORD PTR tv205[ebp], ecx
	jmp	SHORT $LN27@HandleCamp
$LN26@HandleCamp:
	mov	DWORD PTR tv205[ebp], 10		; 0000000aH
$LN27@HandleCamp:
	mov	eax, 10000				; 00002710H
	cdq
	idiv	DWORD PTR tv205[ebp]
	mov	DWORD PTR _sleepTic$[ebp], eax

; 2436 : #if !NEW_SYNC
; 2437 : 			ThreadManager::campaign_signal_sim();
; 2438 : 			ThreadManager::campaign_wait_for_sim (max(sleepTic,300));
; 2439 : #endif
; 2440 : 		}
; 2441 : 		else {

	jmp	SHORT $LN1@HandleCamp
$LN2@HandleCamp:

; 2442 : 			// sfr: this thread needs sleep, otherwise it will suck CPU
; 2443 : 			// I dont know what is the ideal time here though. This is just a test value
; 2444 : 			Sleep(1);

	push	1
	call	DWORD PTR __imp__Sleep@4
$LN1@HandleCamp:

; 2445 : 		}
; 2446 : #if NEW_SYNC
; 2447 : 		ThreadManager::campaign_signal_sim();

	call	?campaign_signal_sim@ThreadManager@@SAXXZ ; ThreadManager::campaign_signal_sim

; 2448 : 		ThreadManager::campaign_wait_for_sim(INFINITE);

	push	-1
	call	?campaign_wait_for_sim@ThreadManager@@SA_NK@Z ; ThreadManager::campaign_wait_for_sim
	add	esp, 4

; 2449 : #endif
; 2450 : 
; 2451 : 	}

	jmp	$LN19@HandleCamp
$LN18@HandleCamp:

; 2452 : 	TheCampaign.Flags ^= CAMP_RUNNING;

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	xor	edx, 1
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, edx

; 2453 : 	return (0);

	xor	eax, eax

; 2454 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HandleCampaignThread@@YGIXZ ENDP			; HandleCampaignThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_sit$ = -36						; size = 12
_nextSession$ = -24					; size = 4
tv81 = -20						; size = 4
_session$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?UpdatePlayerSessions@@YAXXZ PROC			; UpdatePlayerSessions

; 2244 : void UpdatePlayerSessions(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdatePlayerSessions@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2245 : #define NEW_UPDATE_PLAYER_SESSION 1
; 2246 : #if NO_CAMP_LOCK && NEW_UPDATE_PLAYER_SESSION
; 2247 : #else
; 2248 : 	CampEnterCriticalSection();
; 2249 : #endif
; 2250 : #if NO_VU_LOCK && NEW_UPDATE_PLAYER_SESSION
; 2251 : #else
; 2252 : 	VuEnterCriticalSection();
; 2253 : #endif
; 2254 : 
; 2255 : 	VuSessionsIterator	sit(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@UpdatePlay
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN7@UpdatePlay
$LN6@UpdatePlay:
	mov	DWORD PTR tv81[ebp], 0
$LN7@UpdatePlay:
	mov	ecx, DWORD PTR tv81[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2256 : 	FalconSessionEntity *session, *nextSession;
; 2257 : 	for (

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax

; 2258 : 		session = (FalconSessionEntity*)sit.GetFirst();
; 2259 : 		session != NULL;

	jmp	SHORT $LN3@UpdatePlay
$LN2@UpdatePlay:

; 2260 : 		session = nextSession
; 2261 : 	){

	mov	edx, DWORD PTR _nextSession$[ebp]
	mov	DWORD PTR _session$[ebp], edx
$LN3@UpdatePlay:
	cmp	DWORD PTR _session$[ebp], 0
	je	SHORT $LN1@UpdatePlay

; 2262 : 		nextSession = static_cast<FalconSessionEntity*>(sit.GetNext());

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _nextSession$[ebp], eax

; 2263 : 		session->UpdatePlayer();

	mov	ecx, DWORD PTR _session$[ebp]
	call	?UpdatePlayer@FalconSessionEntity@@QAEXXZ ; FalconSessionEntity::UpdatePlayer

; 2264 : 	}

	jmp	SHORT $LN2@UpdatePlay
$LN1@UpdatePlay:

; 2265 : 
; 2266 : #if NO_VU_LOCK && NEW_UPDATE_PLAYER_SESSION
; 2267 : #else
; 2268 : 	VuExitCriticalSection();
; 2269 : #endif
; 2270 : #if NO_CAMP_LOCK && NEW_UPDATE_PLAYER_SESSION
; 2271 : #else
; 2272 : 	CampLeaveCriticalSection();
; 2273 : #endif
; 2274 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UpdatePlayerSessions@@YAXXZ$0:
	lea	ecx, DWORD PTR _sit$[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__ehhandler$?UpdatePlayerSessions@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdatePlayerSessions@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdatePlayerSessions@@YAXXZ ENDP			; UpdatePlayerSessions
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?SetCampaignStartupMode@@YAXXZ PROC			; SetCampaignStartupMode

; 2231 : {

	push	ebp
	mov	ebp, esp

; 2232 : 	sCampaignStartingUp = CAMP_STARTING_UP;

	mov	DWORD PTR _sCampaignStartingUp, 1

; 2233 : 	ThreadManager::fast_campaign ();

	call	?fast_campaign@ThreadManager@@SAXXZ	; ThreadManager::fast_campaign

; 2234 : }

	pop	ebp
	ret	0
?SetCampaignStartupMode@@YAXXZ ENDP			; SetCampaignStartupMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
tv258 = -28						; size = 8
tv162 = -20						; size = 4
tv254 = -16						; size = 4
tv165 = -12						; size = 4
_diff$1 = -8						; size = 4
_pf$2 = -4						; size = 4
?DoCompressionLoop@@YAXXZ PROC				; DoCompressionLoop

; 2115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 2116 : 	if (gCompressTillTime > 0)

	cmp	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime
	jbe	$LN4@DoCompress

; 2117 : 	{
; 2118 : 		Flight		pf = FalconLocalSession->GetPlayerFlight();

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	mov	DWORD PTR _pf$2[ebp], eax

; 2119 : 
; 2120 : 		// Reset gCompressTillTime, in case player has changed options
; 2121 : 		if (sTakeoffTime)

	cmp	DWORD PTR _sTakeoffTime, 0
	je	SHORT $LN22@DoCompress

; 2122 : 			CompressCampaignUntilTakeoff(pf);

	mov	eax, DWORD PTR _pf$2[ebp]
	push	eax
	call	?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z ; CompressCampaignUntilTakeoff
	add	esp, 4
$LN22@DoCompress:

; 2123 : 
; 2124 : 		// Validate that the flight/ac combination the player is entering is still valid
; 2125 : 		if (!pf || pf->IsDead() || pf->Aborted())

	cmp	DWORD PTR _pf$2[ebp], 0
	je	SHORT $LN20@DoCompress
	mov	ecx, DWORD PTR _pf$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pf$2[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN20@DoCompress
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?Aborted@UnitClass@@QBEHXZ		; UnitClass::Aborted
	test	eax, eax
	je	SHORT $LN21@DoCompress
$LN20@DoCompress:

; 2126 : 		{
; 2127 : 			gCompressTillTime = 0;

	mov	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime

; 2128 : 			UI_HandleFlightCancel();

	call	?UI_HandleFlightCancel@@YAXXZ		; UI_HandleFlightCancel

; 2129 : 			return;

	jmp	$LN24@DoCompress
$LN21@DoCompress:

; 2130 : 		}
; 2131 : 		if (pf->plane_stats[FalconLocalSession->GetAircraftNum()] != AIRCRAFT_AVAILABLE)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetAircraftNum@FalconSessionEntity@@QBEEXZ ; FalconSessionEntity::GetAircraftNum
	movzx	ecx, al
	mov	edx, DWORD PTR _pf$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx+416]
	cmp	eax, 4
	je	SHORT $LN19@DoCompress

; 2132 : 		{
; 2133 : 			gCompressTillTime = 0;

	mov	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime

; 2134 : 			UI_HandleAircraftDestroyed();

	call	?UI_HandleAircraftDestroyed@@YAXXZ	; UI_HandleAircraftDestroyed

; 2135 : 			return;

	jmp	$LN24@DoCompress
$LN19@DoCompress:

; 2136 : 		}
; 2137 : 		/*		if ()
; 2138 : 				{
; 2139 : 				gCompressTillTime = 0;
; 2140 : 				UI_HandleAirbaseDestroyed();
; 2141 : 				return;
; 2142 : 				}
; 2143 : 		 */
; 2144 : 
; 2145 : 		// Check for sim entry
; 2146 : 		if (gLaunchTime <= vuxGameTime  && gCompressTillTime <= vuxGameTime)

	mov	ecx, DWORD PTR ?gLaunchTime@@3KA	; gLaunchTime
	cmp	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	ja	$LN18@DoCompress
	mov	edx, DWORD PTR ?gCompressTillTime@@3KA	; gCompressTillTime
	cmp	edx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	ja	$LN18@DoCompress

; 2147 : 		{
; 2148 : 			// Now stop moving time forward and resync the campaign
; 2149 : 			SetTimeCompression(0);

	push	0
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 2150 : 
; 2151 : 			if (Camp_GetCurrentTime() >= vuxGameTime)

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	cmp	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	jb	$LN14@DoCompress

; 2152 : 			{
; 2153 : 				// We've reached our takeoff time, now takeoff
; 2154 : 				// Minimize bubble ratio for our session
; 2155 : 				SimLibElapsedTime = vuxGameTime;

	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR ?SimLibElapsedTime@@3KA, eax	; SimLibElapsedTime

; 2156 : 				UPDATE_SIM_ELAPSED_SECONDS;								// COBRA - RED - Scale Elapsed Seconds

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv254[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv254[ebp]
	mov	edx, DWORD PTR tv254[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv258[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv258[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR ?SimLibElapsedSeconds@@3MA, xmm0
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	subss	xmm0, DWORD PTR ?SimLibLastFrameTime@@3MA
	movss	DWORD PTR ?SimLibFrameElapsed@@3MA, xmm0
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR ?SimLibLastFrameTime@@3MA, xmm0

; 2157 : 				gCompressTillTime = 0;

	mov	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime

; 2158 : 
; 2159 : 				// OW FIXME: sometimes gets called when mainhandler is already freed!				
; 2160 : 				//				if (gMainHandler->GetAppWnd ())
; 2161 : 				if (gMainHandler && gMainHandler->GetAppWnd())

	cmp	DWORD PTR ?gMainHandler@@3PAVC_Handler@@A, 0 ; gMainHandler
	je	$LN14@DoCompress
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ	; C_Handler::GetAppWnd
	test	eax, eax
	je	$LN14@DoCompress

; 2162 : 				{
; 2163 : 					switch (FalconLocalGame->GetGameType())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@DoCompress
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN27@DoCompress
$LN26@DoCompress:
	mov	DWORD PTR tv162[ebp], 0
$LN27@DoCompress:
	mov	ecx, DWORD PTR tv162[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv165[ebp], ecx
	cmp	DWORD PTR tv165[ebp], 3
	ja	$LN14@DoCompress
	mov	edx, DWORD PTR tv165[ebp]
	jmp	DWORD PTR $LN28@DoCompress[edx*4]
$LN13@DoCompress:

; 2164 : 					{
; 2165 : 							case game_InstantAction:
; 2166 : 							case game_Dogfight:
; 2167 : 									gMainHandler->SetDrawFlag(0); // Hack to keep the UI from drawing

	push	0
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?SetDrawFlag@C_Handler@@QAEXJ@Z		; C_Handler::SetDrawFlag

; 2168 : 									PostMessage(gMainHandler->GetAppWnd(),FM_START_DOGFIGHT,0,0);

	push	0
	push	0
	push	1031					; 00000407H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ	; C_Handler::GetAppWnd
	push	eax
	call	DWORD PTR __imp__PostMessageA@16

; 2169 : 									break;

	jmp	$LN14@DoCompress
$LN12@DoCompress:

; 2170 : 
; 2171 : 							case game_TacticalEngagement:
; 2172 : 									if(pf->GetFirstUnitWP() == pf->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	esi, eax
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	esi, eax
	jne	SHORT $LN10@DoCompress

; 2173 : 									{
; 2174 : 										if((pf->GetPilotCount() < pf->GetACCount()) || !pf->GetACCount())

	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetPilotCount@FlightClass@@QAEHXZ	; FlightClass::GetPilotCount
	mov	esi, eax
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetACCount@FlightClass@@QAEHXZ		; FlightClass::GetACCount
	cmp	esi, eax
	jl	SHORT $LN9@DoCompress
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetACCount@FlightClass@@QAEHXZ		; FlightClass::GetACCount
	test	eax, eax
	jne	SHORT $LN10@DoCompress
$LN9@DoCompress:

; 2175 : 										{
; 2176 : 											gCompressTillTime = 0;

	mov	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime

; 2177 : 											UI_HandleFlightScrub();

	call	?UI_HandleFlightScrub@@YAXXZ		; UI_HandleFlightScrub

; 2178 : 											return;

	jmp	$LN24@DoCompress
$LN10@DoCompress:

; 2179 : 										}
; 2180 : 									}
; 2181 : 									gMainHandler->SetDrawFlag(0); // Hack to keep the UI from drawing

	push	0
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?SetDrawFlag@C_Handler@@QAEXJ@Z		; C_Handler::SetDrawFlag

; 2182 : 									CleanupTacticalEngagementUI();

	call	?CleanupTacticalEngagementUI@@YAXXZ	; CleanupTacticalEngagementUI

; 2183 : 									PostMessage(gMainHandler->GetAppWnd(),FM_START_TACTICAL,0,0);

	push	0
	push	0
	push	1033					; 00000409H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ	; C_Handler::GetAppWnd
	push	eax
	call	DWORD PTR __imp__PostMessageA@16

; 2184 : 									ResumeTacticalEngagement();

	call	?ResumeTacticalEngagement@@YAXXZ	; ResumeTacticalEngagement

; 2185 : 									break;

	jmp	SHORT $LN14@DoCompress
$LN8@DoCompress:

; 2186 : 
; 2187 : 							case game_Campaign:
; 2188 : 									// Check if player is only one in the flight... if so... abort (assuming there is supposed to be
; 2189 : 									// more than 1 pilot... also only do this check if flight is taking off
; 2190 : 									if(pf->GetFirstUnitWP() == pf->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	esi, eax
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	esi, eax
	jne	SHORT $LN6@DoCompress

; 2191 : 									{
; 2192 : 										if((pf->GetPilotCount() < pf->GetACCount()) || !pf->GetACCount())

	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetPilotCount@FlightClass@@QAEHXZ	; FlightClass::GetPilotCount
	mov	esi, eax
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetACCount@FlightClass@@QAEHXZ		; FlightClass::GetACCount
	cmp	esi, eax
	jl	SHORT $LN5@DoCompress
	mov	ecx, DWORD PTR _pf$2[ebp]
	call	?GetACCount@FlightClass@@QAEHXZ		; FlightClass::GetACCount
	test	eax, eax
	jne	SHORT $LN6@DoCompress
$LN5@DoCompress:

; 2193 : 										{
; 2194 : 											gCompressTillTime = 0;

	mov	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime

; 2195 : 											UI_HandleFlightScrub();

	call	?UI_HandleFlightScrub@@YAXXZ		; UI_HandleFlightScrub

; 2196 : 											return;

	jmp	SHORT $LN24@DoCompress
$LN6@DoCompress:

; 2197 : 										}
; 2198 : 									}
; 2199 : 									gMainHandler->SetDrawFlag(0); // Hack to keep the UI from drawing

	push	0
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?SetDrawFlag@C_Handler@@QAEXJ@Z		; C_Handler::SetDrawFlag

; 2200 : 									CleanupCampaignUI();

	call	?CleanupCampaignUI@@YAXXZ		; CleanupCampaignUI

; 2201 : 									PostMessage(gMainHandler->GetAppWnd(),FM_START_CAMPAIGN,0,0);

	push	0
	push	0
	push	1034					; 0000040aH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ	; C_Handler::GetAppWnd
	push	eax
	call	DWORD PTR __imp__PostMessageA@16
$LN14@DoCompress:

; 2202 : 									break;
; 2203 : 					}
; 2204 : 				}
; 2205 : 			}
; 2206 : 		}
; 2207 : 		else

	jmp	SHORT $LN4@DoCompress
$LN18@DoCompress:

; 2208 : 		{
; 2209 : 			int
; 2210 : 					diff;
; 2211 : 
; 2212 : 			diff = gCompressTillTime - vuxGameTime;

	mov	eax, DWORD PTR ?gCompressTillTime@@3KA	; gCompressTillTime
	sub	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _diff$1[ebp], eax

; 2213 : 
; 2214 : 			diff = diff / 2500;	// two 1/2 minutes away - start reducing compression ratio

	mov	eax, DWORD PTR _diff$1[ebp]
	cdq
	mov	ecx, 2500				; 000009c4H
	idiv	ecx
	mov	DWORD PTR _diff$1[ebp], eax

; 2215 : 
; 2216 : 			if (diff > 64) // Are we a few minutes away

	cmp	DWORD PTR _diff$1[ebp], 64		; 00000040H
	jle	SHORT $LN3@DoCompress

; 2217 : 			{
; 2218 : 				diff = 64;

	mov	DWORD PTR _diff$1[ebp], 64		; 00000040H
	jmp	SHORT $LN1@DoCompress
$LN3@DoCompress:

; 2219 : 			}
; 2220 : 			else if (diff <= 0)	// Don't just stop however

	cmp	DWORD PTR _diff$1[ebp], 0
	jg	SHORT $LN1@DoCompress

; 2221 : 			{
; 2222 : 				diff = 1;

	mov	DWORD PTR _diff$1[ebp], 1
$LN1@DoCompress:

; 2223 : 			}
; 2224 : 
; 2225 : 			SetTimeCompression(diff);

	mov	edx, DWORD PTR _diff$1[ebp]
	push	edx
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4
$LN4@DoCompress:
$LN24@DoCompress:

; 2226 : 		}
; 2227 : 	}
; 2228 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@DoCompress:
	DD	$LN13@DoCompress
	DD	$LN13@DoCompress
	DD	$LN12@DoCompress
	DD	$LN8@DoCompress
?DoCompressionLoop@@YAXXZ ENDP				; DoCompressionLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?CancelCampaignCompression@@YAXXZ PROC			; CancelCampaignCompression

; 2108 : {

	push	ebp
	mov	ebp, esp

; 2109 : 	gCompressTillTime = 0;

	mov	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime

; 2110 : 	gOldCompressTillTime = 0;

	mov	DWORD PTR ?gOldCompressTillTime@@3KA, 0	; gOldCompressTillTime

; 2111 : 	SetTimeCompression(1);

	push	1
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 2112 : }

	pop	ebp
	ret	0
?CancelCampaignCompression@@YAXXZ ENDP			; CancelCampaignCompression
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_sessionWalker$2 = -60					; size = 12
tv245 = -48						; size = 4
tv148 = -44						; size = 4
tv93 = -40						; size = 4
tv76 = -36						; size = 4
tv257 = -32						; size = 4
_sess$3 = -28						; size = 4
_w$ = -24						; size = 4
_firstentrytime$ = -20					; size = 4
_flt$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flight$ = 8						; size = 4
?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z PROC ; CompressCampaignUntilTakeoff

; 2028 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2029 : 	WayPoint		w;
; 2030 : 
; 2031 : 	ShiAssert( flight );
; 2032 : 	/////////////////me123 check all clients takeoff time if we are host
; 2033 : 	int firstentrytime = 0;

	mov	DWORD PTR _firstentrytime$[ebp], 0

; 2034 : 	if (FalconLocalGame && FalconLocalGame->IsLocal())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@CompressCa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN24@CompressCa
$LN23@CompressCa:
	mov	DWORD PTR tv76[ebp], 0
$LN24@CompressCa:
	cmp	DWORD PTR tv76[ebp], 0
	je	$LN12@CompressCa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@CompressCa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN26@CompressCa
$LN25@CompressCa:
	mov	DWORD PTR tv93[ebp], 0
$LN26@CompressCa:
	mov	ecx, DWORD PTR tv93[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	$LN12@CompressCa

; 2035 : 	{
; 2036 : 		VuSessionsIterator	sessionWalker(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@CompressCa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $LN28@CompressCa
$LN27@CompressCa:
	mov	DWORD PTR tv148[ebp], 0
$LN28@CompressCa:
	mov	ecx, DWORD PTR tv148[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sessionWalker$2[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2037 : 		FalconSessionEntity *sess;
; 2038 : 		sess = (FalconSessionEntity*)sessionWalker.GetFirst();

	lea	ecx, DWORD PTR _sessionWalker$2[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _sess$3[ebp], eax
$LN19@CompressCa:

; 2039 : 
; 2040 : 		while (sess)

	cmp	DWORD PTR _sess$3[ebp], 0
	je	$LN18@CompressCa

; 2041 : 		{
; 2042 : 
; 2043 : 			Flight flt = sess->GetPlayerFlight();

	mov	ecx, DWORD PTR _sess$3[ebp]
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	mov	DWORD PTR _flt$4[ebp], eax

; 2044 : 			if (flt) {

	cmp	DWORD PTR _flt$4[ebp], 0
	je	SHORT $LN17@CompressCa

; 2045 : 				if (flt->GetCurrentUnitWP() && 
; 2046 : 								( flt->GetCurrentUnitWP()->GetWPAction() == WP_TAKEOFF)) {

	mov	ecx, DWORD PTR _flt$4[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	test	eax, eax
	je	SHORT $LN17@CompressCa
	mov	ecx, DWORD PTR _flt$4[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	ecx, eax
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN17@CompressCa

; 2047 : 
; 2048 : 					if (!firstentrytime){

	cmp	DWORD PTR _firstentrytime$[ebp], 0
	jne	SHORT $LN15@CompressCa

; 2049 : 						firstentrytime = flt->GetCurrentUnitWP()->GetWPArrivalTime();

	mov	ecx, DWORD PTR _flt$4[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	ecx, eax
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _firstentrytime$[ebp], eax
	jmp	SHORT $LN17@CompressCa
$LN15@CompressCa:

; 2050 : 					}
; 2051 : 					else if (flt->GetCurrentUnitWP()->GetWPArrivalTime() < (CampaignTime)firstentrytime){

	mov	ecx, DWORD PTR _flt$4[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	ecx, eax
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	cmp	eax, DWORD PTR _firstentrytime$[ebp]
	jae	SHORT $LN17@CompressCa

; 2052 : 						firstentrytime = flt->GetCurrentUnitWP()->GetWPArrivalTime();

	mov	ecx, DWORD PTR _flt$4[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	ecx, eax
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _firstentrytime$[ebp], eax
$LN17@CompressCa:

; 2053 : 					}				
; 2054 : 				}
; 2055 : 			}
; 2056 : 			sess = (FalconSessionEntity*)sessionWalker.GetNext ();

	lea	ecx, DWORD PTR _sessionWalker$2[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _sess$3[ebp], eax

; 2057 : 		}

	jmp	$LN19@CompressCa
$LN18@CompressCa:

; 2058 : 
; 2059 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sessionWalker$2[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
$LN12@CompressCa:

; 2060 : 	else
; 2061 : 	{// we are a client
; 2062 : 
; 2063 : 	}
; 2064 : 
; 2065 : 	/////////////////me123
; 2066 : 	if (TheCampaign.IsSuspended())

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?IsSuspended@CampaignClass@@QAEHXZ	; CampaignClass::IsSuspended
	test	eax, eax
	je	SHORT $LN11@CompressCa

; 2067 : 		TheCampaign.Resume();

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?Resume@CampaignClass@@QAEXXZ		; CampaignClass::Resume
$LN11@CompressCa:

; 2068 : 
; 2069 : 	w = flight->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 2070 : 	if (w && w->GetWPAction() == WP_TAKEOFF)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN10@CompressCa
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	$LN10@CompressCa

; 2071 : 	{
; 2072 : 		// Tell the flight to hold short if we're coming into the sim.
; 2073 : 		flight->SetFalcFlag(FEC_HOLDSHORT);

	push	1
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?SetFalcFlag@FalconEntity@@QAEXH@Z	; FalconEntity::SetFalcFlag

; 2074 : 		if (FalconLocalGame->IsLocal()) 	sTakeoffTime = firstentrytime;

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@CompressCa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv245[ebp], eax
	jmp	SHORT $LN30@CompressCa
$LN29@CompressCa:
	mov	DWORD PTR tv245[ebp], 0
$LN30@CompressCa:
	mov	ecx, DWORD PTR tv245[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@CompressCa
	mov	ecx, DWORD PTR _firstentrytime$[ebp]
	mov	DWORD PTR _sTakeoffTime, ecx
	jmp	SHORT $LN8@CompressCa
$LN9@CompressCa:

; 2075 : 		else 	sTakeoffTime = w->GetWPArrivalTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _sTakeoffTime, eax
$LN8@CompressCa:

; 2076 : 		gLaunchTime = w->GetWPArrivalTime() ;

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR ?gLaunchTime@@3KA, eax	; gLaunchTime

; 2077 : 
; 2078 : 		switch (PlayerOptions.GetStartFlag()) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	mov	DWORD PTR tv257[ebp], eax
	cmp	DWORD PTR tv257[ebp], 0
	je	SHORT $LN3@CompressCa
	cmp	DWORD PTR tv257[ebp], 1
	je	SHORT $LN4@CompressCa
	cmp	DWORD PTR tv257[ebp], 2
	je	SHORT $LN5@CompressCa
	jmp	SHORT $LN6@CompressCa
$LN5@CompressCa:

; 2079 : 				case PlayerOptionsClass::START_RAMP:
; 2080 : 						gLaunchTime -= PlayerOptionsClass::RAMP_MINUTES * CampaignMinutes;

	mov	edx, DWORD PTR ?gLaunchTime@@3KA	; gLaunchTime
	sub	edx, 1200000				; 00124f80H
	mov	DWORD PTR ?gLaunchTime@@3KA, edx	; gLaunchTime

; 2081 : 						break;

	jmp	SHORT $LN6@CompressCa
$LN4@CompressCa:

; 2082 : 				case PlayerOptionsClass::START_TAXI:
; 2083 : 						gLaunchTime -= g_nTaxiLaunchTime * CampaignMinutes;	// Booster 2004/10/12 Taxi takeoff time option	

	mov	eax, DWORD PTR ?g_nTaxiLaunchTime@@3HA	; g_nTaxiLaunchTime
	imul	eax, 60000				; 0000ea60H
	mov	ecx, DWORD PTR ?gLaunchTime@@3KA	; gLaunchTime
	sub	ecx, eax
	mov	DWORD PTR ?gLaunchTime@@3KA, ecx	; gLaunchTime

; 2084 : 						break;

	jmp	SHORT $LN6@CompressCa
$LN3@CompressCa:

; 2085 : 				case PlayerOptionsClass::START_RUNWAY:
; 2086 : 						if (gCommsMgr && gCommsMgr->Online())

	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	SHORT $LN6@CompressCa
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	je	SHORT $LN6@CompressCa

; 2087 : 							gLaunchTime -= CampaignMinutes;

	mov	edx, DWORD PTR ?gLaunchTime@@3KA	; gLaunchTime
	sub	edx, 60000				; 0000ea60H
	mov	DWORD PTR ?gLaunchTime@@3KA, edx	; gLaunchTime
$LN6@CompressCa:

; 2088 : 						break;
; 2089 : 		}
; 2090 : 
; 2091 : 
; 2092 : 		SetEntryTime(flight);

	mov	eax, DWORD PTR _flight$[ebp]
	push	eax
	call	?SetEntryTime@@YAXPAVFlightClass@@@Z	; SetEntryTime
	add	esp, 4

; 2093 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN21@CompressCa

; 2094 : 	}
; 2095 : 	else

	jmp	SHORT $LN21@CompressCa
$LN10@CompressCa:

; 2096 : 	{
; 2097 : 		sTakeoffTime = 0;

	mov	DWORD PTR _sTakeoffTime, 0

; 2098 : 		gCompressTillTime = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR ?gCompressTillTime@@3KA, eax	; gCompressTillTime

; 2099 : 		// 2002-04-06 MN also set gLaunchTime to current time, or we'll use the launch time of 
; 2100 : 		// the mission we've run previously, if our current waypoint is not the takeoff waypoint
; 2101 : 		// So - let us into the sim immediately.
; 2102 : 		gLaunchTime = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR ?gLaunchTime@@3KA, eax	; gLaunchTime

; 2103 : 		return 1;

	mov	eax, 1
$LN21@CompressCa:

; 2104 : 	}
; 2105 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z$0:
	lea	ecx, DWORD PTR _sessionWalker$2[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__ehhandler$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CompressCampaignUntilTakeoff@@YAHPAVFlightClass@@@Z ENDP ; CompressCampaignUntilTakeoff
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
tv142 = -8						; size = 4
tv83 = -4						; size = 4
_flight$ = 8						; size = 4
?SetEntryTime@@YAXPAVFlightClass@@@Z PROC		; SetEntryTime

; 1960 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1961 : 
; 1962 : 
; 1963 : 	static VU_TIME timer = NULL;
; 1964 : 	static VU_TIME  startvuxGameTime = NULL;
; 1965 : 	static int starttimer = FALSE;
; 1966 : 
; 1967 : 	if (timer)

	cmp	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 0
	je	SHORT $LN18@SetEntryTi

; 1968 : 	{
; 1969 : 		timer = vuxGameTime - startvuxGameTime;

	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	sub	eax, DWORD PTR ?startvuxGameTime@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA
	mov	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, eax

; 1970 : 		if (!timer) timer =1;

	jne	SHORT $LN17@SetEntryTi
	mov	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 1
$LN17@SetEntryTi:

; 1971 : 	}

	jmp	SHORT $LN16@SetEntryTi
$LN18@SetEntryTi:

; 1972 : 	else if (starttimer)

	cmp	DWORD PTR ?starttimer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA, 0
	je	SHORT $LN16@SetEntryTi

; 1973 : 	{
; 1974 : 		startvuxGameTime = vuxGameTime;

	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR ?startvuxGameTime@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, ecx

; 1975 : 		timer = 1;

	mov	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 1
$LN16@SetEntryTi:

; 1976 : 	}
; 1977 : 	if (timer > 3 * CampaignSeconds)

	cmp	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 3000 ; 00000bb8H
	jbe	SHORT $LN14@SetEntryTi

; 1978 : 	{
; 1979 : 		timer = NULL;

	mov	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 0

; 1980 : 		starttimer = FALSE;

	mov	DWORD PTR ?starttimer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA, 0
$LN14@SetEntryTi:

; 1981 : 	}
; 1982 : 
; 1983 : 	static int lastchoice = 0;
; 1984 : 	if (g_bMPStartRestricted && gCommsMgr && gCommsMgr->Online ())

	movzx	edx, BYTE PTR ?g_bMPStartRestricted@@3_NA ; g_bMPStartRestricted
	test	edx, edx
	je	SHORT $LN13@SetEntryTi
	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	SHORT $LN13@SetEntryTi
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	je	SHORT $LN13@SetEntryTi

; 1985 : 	{
; 1986 : 		gCompressTillTime = sTakeoffTime - g_nMPStartTime * CampaignMinutes;

	mov	eax, DWORD PTR ?g_nMPStartTime@@3HA	; g_nMPStartTime
	imul	eax, 60000				; 0000ea60H
	mov	ecx, DWORD PTR _sTakeoffTime
	sub	ecx, eax
	mov	DWORD PTR ?gCompressTillTime@@3KA, ecx	; gCompressTillTime
	jmp	$LN12@SetEntryTi
$LN13@SetEntryTi:

; 1987 : 	}
; 1988 : 
; 1989 : 
; 1990 : 	else if (!gCompressTillTime || lastchoice != PlayerOptions.GetStartFlag())

	cmp	DWORD PTR ?gCompressTillTime@@3KA, 0	; gCompressTillTime
	je	SHORT $LN10@SetEntryTi
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	cmp	DWORD PTR ?lastchoice@?O@??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA, eax
	je	$LN12@SetEntryTi
$LN10@SetEntryTi:

; 1991 : 	{
; 1992 : 		// JPO - decide where we start
; 1993 : 		switch (PlayerOptions.GetStartFlag()) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 0
	je	SHORT $LN5@SetEntryTi
	cmp	DWORD PTR tv83[ebp], 1
	je	SHORT $LN6@SetEntryTi
	cmp	DWORD PTR tv83[ebp], 2
	je	SHORT $LN7@SetEntryTi
	jmp	SHORT $LN8@SetEntryTi
$LN7@SetEntryTi:

; 1994 : 				case PlayerOptionsClass::START_RAMP:
; 1995 : 						gCompressTillTime = sTakeoffTime - PlayerOptionsClass::RAMP_MINUTES * CampaignMinutes;

	mov	edx, DWORD PTR _sTakeoffTime
	sub	edx, 1200000				; 00124f80H
	mov	DWORD PTR ?gCompressTillTime@@3KA, edx	; gCompressTillTime

; 1996 : 						flight->SetEvalFlag(FEVAL_START_COLD);

	push	0
	push	16					; 00000010H
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?SetEvalFlag@FlightClass@@QAEXEH@Z	; FlightClass::SetEvalFlag

; 1997 : 						break;

	jmp	SHORT $LN8@SetEntryTi
$LN6@SetEntryTi:

; 1998 : 				case PlayerOptionsClass::START_TAXI:
; 1999 : 						// Booster 2004/10/12 Taxi takeoff time option
; 2000 : 						gCompressTillTime = sTakeoffTime - g_nTaxiLaunchTime * CampaignMinutes;  

	mov	eax, DWORD PTR ?g_nTaxiLaunchTime@@3HA	; g_nTaxiLaunchTime
	imul	eax, 60000				; 0000ea60H
	mov	ecx, DWORD PTR _sTakeoffTime
	sub	ecx, eax
	mov	DWORD PTR ?gCompressTillTime@@3KA, ecx	; gCompressTillTime

; 2001 : 						break;

	jmp	SHORT $LN8@SetEntryTi
$LN5@SetEntryTi:

; 2002 : 				case PlayerOptionsClass::START_RUNWAY:
; 2003 : 						if (gCommsMgr && gCommsMgr->Online())

	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	SHORT $LN4@SetEntryTi
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	je	SHORT $LN4@SetEntryTi

; 2004 : 							gCompressTillTime = sTakeoffTime - CampaignMinutes;

	mov	edx, DWORD PTR _sTakeoffTime
	sub	edx, 60000				; 0000ea60H
	mov	DWORD PTR ?gCompressTillTime@@3KA, edx	; gCompressTillTime

; 2005 : 						else

	jmp	SHORT $LN8@SetEntryTi
$LN4@SetEntryTi:

; 2006 : 							gCompressTillTime = sTakeoffTime;

	mov	eax, DWORD PTR _sTakeoffTime
	mov	DWORD PTR ?gCompressTillTime@@3KA, eax	; gCompressTillTime
$LN8@SetEntryTi:

; 2007 : 						break;
; 2008 : 				default:
; 2009 : 						ShiWarning("Undefined Start time");
; 2010 : 		}
; 2011 : 		starttimer = TRUE;

	mov	DWORD PTR ?starttimer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA, 1
$LN12@SetEntryTi:

; 2012 : 	}
; 2013 : 	lastchoice = PlayerOptions.GetStartFlag();

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	mov	DWORD PTR ?lastchoice@?O@??SetEntryTime@@YAXPAVFlightClass@@@Z@4HA, eax

; 2014 : 
; 2015 : 
; 2016 : 	//me123 give the player a few sec to make a change.
; 2017 : 	if ((PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RUNWAY) &&  timer && 
; 2018 : 					(timer < (VU_TIME)(3 * CampaignSeconds)) &&  
; 2019 : 					(gLaunchTime <  (CampaignTime)(vuxGameTime + 3 * CampaignSeconds) )) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	test	eax, eax
	je	SHORT $LN19@SetEntryTi
	cmp	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 0
	je	SHORT $LN19@SetEntryTi
	cmp	DWORD PTR ?timer@?1??SetEntryTime@@YAXPAVFlightClass@@@Z@4KA, 3000 ; 00000bb8H
	jae	SHORT $LN19@SetEntryTi
	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	add	ecx, 3000				; 00000bb8H
	cmp	DWORD PTR ?gLaunchTime@@3KA, ecx	; gLaunchTime
	jae	SHORT $LN19@SetEntryTi

; 2020 : 
; 2021 : 		gLaunchTime = min( ((VU_TIME)sTakeoffTime) , (vuxGameTime + 3 * CampaignSeconds)); 

	mov	edx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	add	edx, 3000				; 00000bb8H
	cmp	DWORD PTR _sTakeoffTime, edx
	jae	SHORT $LN21@SetEntryTi
	mov	eax, DWORD PTR _sTakeoffTime
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN22@SetEntryTi
$LN21@SetEntryTi:
	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	add	ecx, 3000				; 00000bb8H
	mov	DWORD PTR tv142[ebp], ecx
$LN22@SetEntryTi:
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR ?gLaunchTime@@3KA, edx	; gLaunchTime
$LN19@SetEntryTi:

; 2022 : 	}
; 2023 : 
; 2024 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetEntryTime@@YAXPAVFlightClass@@@Z ENDP		; SetEntryTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_frontit$2 = -60					; size = 12
_bestd$ = -48						; size = 4
_d$ = -44						; size = 4
_o$ = -40						; size = 4
_besty$ = -36						; size = 2
_y$ = -32						; size = 2
_x$ = -28						; size = 2
_cx$ = -24						; size = 2
_cy$ = -20						; size = 2
_bestx$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
?ChooseBullseye@@YAXXZ PROC				; ChooseBullseye

; 1900 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChooseBullseye@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1901 : 	if (!g_bFloatingBullseye) // JB/Codec 010115

	movzx	eax, BYTE PTR ?g_bFloatingBullseye@@3_NA ; g_bFloatingBullseye
	test	eax, eax
	jne	SHORT $LN8@ChooseBull

; 1902 : 		return; // JB/Codec 010115

	jmp	$LN9@ChooseBull
$LN8@ChooseBull:

; 1903 : 
; 1904 : 	// 2000-11-27 REMOVED BY S.G. SORRY KEVIN, NO MORE HARDCODED BULLSEYE :-)
; 1905 : 	// KCK: They want a fixed Bullseye.. So.. here it is:
; 1906 : 	//	TheCampaign.SetBullseye(1,390,464);
; 1907 : 	// END OF REMOVED SECTION
; 1908 : 	// This code will pick the best frontline objective as a bullseye
; 1909 : 	//reenabled by me123	
; 1910 : 	Objective		o;
; 1911 : 	GridIndex		cx,cy,x,y,bestx=-1,besty=-1;

	or	ecx, -1
	mov	WORD PTR _bestx$[ebp], cx
	or	edx, -1
	mov	WORD PTR _besty$[ebp], dx

; 1912 : 	float			d,bestd=999.9F;

	movss	xmm0, DWORD PTR __real@4479f99a
	movss	DWORD PTR _bestd$[ebp], xmm0

; 1913 : 
; 1914 : 	if (g_nChooseBullseyeFix & 0x01)

	mov	eax, DWORD PTR ?g_nChooseBullseyeFix@@3HA ; g_nChooseBullseyeFix
	and	eax, 1
	je	SHORT $LN7@ChooseBull

; 1915 : 	{
; 1916 : 		cx = TheaterXPosition;	// from falcon4.aii - theater dependant

	mov	cx, WORD PTR ?TheaterXPosition@@3HA
	mov	WORD PTR _cx$[ebp], cx

; 1917 : 		cy = TheaterYPosition;

	mov	dx, WORD PTR ?TheaterYPosition@@3HA
	mov	WORD PTR _cy$[ebp], dx

; 1918 : 	}
; 1919 : 	else

	jmp	SHORT $LN6@ChooseBull
$LN7@ChooseBull:

; 1920 : 	{
; 1921 : 		cx = Map_Max_X / 2;

	movsx	eax, WORD PTR ?Map_Max_X@@3FA		; Map_Max_X
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	WORD PTR _cx$[ebp], ax

; 1922 : 		cy = Map_Max_Y / 2;

	movsx	eax, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	WORD PTR _cy$[ebp], ax
$LN6@ChooseBull:

; 1923 : 	}
; 1924 : 
; 1925 : 	// Choose the best frontline objective as a bullseye
; 1926 : 	{
; 1927 : 		VuListIterator	frontit(FrontList);

	mov	eax, DWORD PTR ?FrontList@@3PAVFalconPrivateList@@A ; FrontList
	push	eax
	lea	ecx, DWORD PTR _frontit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1928 : 		o = (Objective) frontit.GetFirst();

	lea	ecx, DWORD PTR _frontit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _o$[ebp], eax
$LN5@ChooseBull:

; 1929 : 		while (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN4@ChooseBull

; 1930 : 		{
; 1931 : 			o->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1932 : 			d = Distance(x,y,cx,cy);

	movzx	eax, WORD PTR _cy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _cx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]

; 1933 : 			if (d < bestd)

	movss	xmm0, DWORD PTR _bestd$[ebp]
	comiss	xmm0, DWORD PTR _d$[ebp]
	jbe	SHORT $LN3@ChooseBull

; 1934 : 			{
; 1935 : 				bestx = x;

	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR _bestx$[ebp], cx

; 1936 : 				besty = y;

	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR _besty$[ebp], dx

; 1937 : 				bestd = d;

	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _bestd$[ebp], xmm0
$LN3@ChooseBull:

; 1938 : 			}
; 1939 : 			o = (Objective) frontit.GetNext();

	lea	ecx, DWORD PTR _frontit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _o$[ebp], eax

; 1940 : 		}

	jmp	SHORT $LN5@ChooseBull
$LN4@ChooseBull:

; 1941 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _frontit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1942 : 
; 1943 : 	if (bestx >= 0)

	movsx	eax, WORD PTR _bestx$[ebp]
	test	eax, eax
	jl	SHORT $LN2@ChooseBull

; 1944 : 		TheCampaign.SetBullseye(1,bestx,besty);

	movzx	ecx, WORD PTR _besty$[ebp]
	push	ecx
	movzx	edx, WORD PTR _bestx$[ebp]
	push	edx
	push	1
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?SetBullseye@CampaignClass@@QAEXEFF@Z	; CampaignClass::SetBullseye

; 1945 : 	else

	jmp	SHORT $LN1@ChooseBull
$LN2@ChooseBull:

; 1946 : 		TheCampaign.SetBullseye(1,390,464);//me123 from 0,0,0

	push	464					; 000001d0H
	push	390					; 00000186H
	push	1
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?SetBullseye@CampaignClass@@QAEXEFF@Z	; CampaignClass::SetBullseye
$LN1@ChooseBull:
$LN9@ChooseBull:

; 1947 : 
; 1948 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ChooseBullseye@@YAXXZ$0:
	lea	ecx, DWORD PTR _frontit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?ChooseBullseye@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChooseBullseye@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseBullseye@@YAXXZ ENDP				; ChooseBullseye
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_index$1 = -4						; size = 4
?ClearCampCache@@YAXXZ PROC				; ClearCampCache

; 1882 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1883 : 	for (int index = 0; index < MAX_WCH_FILES; index ++)

	mov	DWORD PTR _index$1[ebp], 0
	jmp	SHORT $LN4@ClearCampC
$LN3@ClearCampC:
	mov	eax, DWORD PTR _index$1[ebp]
	add	eax, 1
	mov	DWORD PTR _index$1[ebp], eax
$LN4@ClearCampC:
	cmp	DWORD PTR _index$1[ebp], 4
	jge	SHORT $LN5@ClearCampC

; 1884 : 	{
; 1885 : 		if (wch_fp[index])

	mov	ecx, DWORD PTR _index$1[ebp]
	cmp	DWORD PTR _wch_fp[ecx*4], 0
	je	SHORT $LN1@ClearCampC

; 1886 : 		{
; 1887 : 			fclose(wch_fp[index]);

	mov	edx, DWORD PTR _index$1[ebp]
	mov	eax, DWORD PTR _wch_fp[edx*4]
	push	eax
	call	_fclose
	add	esp, 4

; 1888 : 			wch_fp[index] = NULL;

	mov	ecx, DWORD PTR _index$1[ebp]
	mov	DWORD PTR _wch_fp[ecx*4], 0

; 1889 : 			strcpy(wch_filename[index], "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _index$1[ebp]
	imul	edx, 260				; 00000104H
	add	edx, OFFSET _wch_filename
	push	edx
	call	_strcpy
	add	esp, 8

; 1890 : 			next_wch_file--;

	mov	eax, DWORD PTR _next_wch_file
	sub	eax, 1
	mov	DWORD PTR _next_wch_file, eax
$LN1@ClearCampC:

; 1891 : 		}
; 1892 : 	}

	jmp	SHORT $LN3@ClearCampC
$LN5@ClearCampC:

; 1893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearCampCache@@YAXXZ ENDP				; ClearCampCache
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_one_ext$ = -8						; size = 4
_two_ext$ = -4						; size = 4
_one$ = 8						; size = 4
_two$ = 12						; size = 4
?string_compare_extensions@@YAHPAD0@Z PROC		; string_compare_extensions

; 1421 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1422 : 	char
; 1423 : 			*one_ext,
; 1424 : 			*two_ext;
; 1425 : 
; 1426 : 	one_ext = one;

	mov	eax, DWORD PTR _one$[ebp]
	mov	DWORD PTR _one_ext$[ebp], eax

; 1427 : 	two_ext = two;

	mov	ecx, DWORD PTR _two$[ebp]
	mov	DWORD PTR _two_ext$[ebp], ecx
$LN6@string_com:

; 1428 : 
; 1429 : 	while (*one)

	mov	edx, DWORD PTR _one$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@string_com

; 1430 : 	{
; 1431 : 		if (*one == '.')

	mov	ecx, DWORD PTR _one$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN4@string_com

; 1432 : 		{
; 1433 : 			one_ext = one;

	mov	eax, DWORD PTR _one$[ebp]
	mov	DWORD PTR _one_ext$[ebp], eax
$LN4@string_com:

; 1434 : 		}
; 1435 : 
; 1436 : 		one ++;

	mov	ecx, DWORD PTR _one$[ebp]
	add	ecx, 1
	mov	DWORD PTR _one$[ebp], ecx

; 1437 : 	}

	jmp	SHORT $LN6@string_com
$LN3@string_com:

; 1438 : 
; 1439 : 	while (*two)

	mov	edx, DWORD PTR _two$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN2@string_com

; 1440 : 	{
; 1441 : 		if (*two == '.')

	mov	ecx, DWORD PTR _two$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN1@string_com

; 1442 : 		{
; 1443 : 			two_ext = two;

	mov	eax, DWORD PTR _two$[ebp]
	mov	DWORD PTR _two_ext$[ebp], eax
$LN1@string_com:

; 1444 : 		}
; 1445 : 
; 1446 : 		two ++;

	mov	ecx, DWORD PTR _two$[ebp]
	add	ecx, 1
	mov	DWORD PTR _two$[ebp], ecx

; 1447 : 	}

	jmp	SHORT $LN3@string_com
$LN2@string_com:

; 1448 : 
; 1449 : 	return stricmp (one_ext, two_ext);

	mov	edx, DWORD PTR _two_ext$[ebp]
	push	edx
	mov	eax, DWORD PTR _one_ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8

; 1450 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?string_compare_extensions@@YAHPAD0@Z ENDP		; string_compare_extensions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_fp$ = -268						; size = 4
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_filename$ = 12						; size = 4
?IsCampFile@@YAHW4FalconGameType@@PAD@Z PROC		; IsCampFile

; 1404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1405 : 	char
; 1406 : 			path[MAX_PATH];
; 1407 : 	FILE
; 1408 : 			*fp;
; 1409 : 
; 1410 : 	GetCampFilePath(type,filename,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	?GetCampFilePath@@YAXW4FalconGameType@@PAD1@Z ; GetCampFilePath
	add	esp, 12					; 0000000cH

; 1411 : 
; 1412 : 	fp = fopen(path,"rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1413 : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN1@IsCampFile

; 1414 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@IsCampFile
$LN1@IsCampFile:

; 1415 : 
; 1416 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1417 : 	return 1;

	mov	eax, 1
$LN2@IsCampFile:

; 1418 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampFile@@YAHW4FalconGameType@@PAD@Z ENDP		; IsCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_fp$ = -4						; size = 4
_type$ = 8						; size = 4
_filename$ = 12						; size = 4
_path$ = 16						; size = 4
?GetCampFilePath@@YAXW4FalconGameType@@PAD1@Z PROC	; GetCampFilePath

; 1379 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1380 : 	FILE
; 1381 : 			*fp;
; 1382 : 
; 1383 : 	if (type == game_TacticalEngagement)

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN4@GetCampFil

; 1384 : 	{
; 1385 : 		sprintf (path, "%s\\%s.tac", FalconCampUserSaveDirectory, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	push	OFFSET ??_C@_09PDPMBAAN@?$CFs?2?$CFs?4tac?$AA@
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1386 : 
; 1387 : 		fp = fopen (path, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1388 : 		if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN3@GetCampFil

; 1389 : 		{
; 1390 : 			fclose (fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1391 : 		}
; 1392 : 		else

	jmp	SHORT $LN2@GetCampFil
$LN3@GetCampFil:

; 1393 : 		{
; 1394 : 			sprintf (path, "%s\\%s.trn", FalconCampUserSaveDirectory, filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	push	OFFSET ??_C@_09FIDCHDGJ@?$CFs?2?$CFs?4trn?$AA@
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN2@GetCampFil:

; 1395 : 		}
; 1396 : 	}
; 1397 : 	else

	jmp	SHORT $LN5@GetCampFil
$LN4@GetCampFil:

; 1398 : 	{
; 1399 : 		sprintf (path, "%s\\%s.cam", FalconCampUserSaveDirectory, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	push	OFFSET ??_C@_09KALBFCKF@?$CFs?2?$CFs?4cam?$AA@
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN5@GetCampFil:

; 1400 : 	}
; 1401 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampFilePath@@YAXW4FalconGameType@@PAD1@Z ENDP	; GetCampFilePath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_d$ = -24						; size = 4
tv131 = -20						; size = 4
tv95 = -16						; size = 4
_yd$ = -12						; size = 4
_xd$ = -8						; size = 4
_player$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?InterestingSFX@@YAHMM@Z PROC				; InterestingSFX

; 1284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1285 : 	float		d,xd,yd;
; 1286 : 	VuEntity	*player;
; 1287 : 
; 1288 : 	player = FalconLocalSession->GetCameraEntity(0);

	push	0
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	mov	DWORD PTR _player$[ebp], eax

; 1289 : 
; 1290 : 	if (!player)        // || not in the cockpit

	cmp	DWORD PTR _player$[ebp], 0
	jne	SHORT $LN2@Interestin

; 1291 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@Interestin
$LN2@Interestin:

; 1292 : 
; 1293 : 	xd = player->XPos() - x;

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv95[ebp]
	movss	xmm0, DWORD PTR tv95[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 1294 : 	yd = player->YPos() - y;

	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv131[ebp]
	movss	xmm0, DWORD PTR tv131[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _yd$[ebp], xmm0

; 1295 : 	d = xd*xd + yd*yd;

	movss	xmm0, DWORD PTR _xd$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	movss	xmm1, DWORD PTR _yd$[ebp]
	mulss	xmm1, DWORD PTR _yd$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _d$[ebp], xmm0

; 1296 : 	if (d < MAX_DISTANT_EFFECT_DIST_SQ)

	movss	xmm0, DWORD PTR __real@5127a358
	comiss	xmm0, DWORD PTR _d$[ebp]
	jbe	SHORT $LN1@Interestin

; 1297 : 	{
; 1298 : #ifndef NDEBUG
; 1299 : 		//		MonoPrint("Firing distant visual effect at %f,%f.\n",x,y);
; 1300 : #endif
; 1301 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@Interestin
$LN1@Interestin:

; 1302 : 	}
; 1303 : 	return 0;

	xor	eax, eax
$LN3@Interestin:

; 1304 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InterestingSFX@@YAHMM@Z ENDP				; InterestingSFX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
$T2 = -536						; size = 8
$T3 = -528						; size = 8
$T4 = -520						; size = 8
$T5 = -512						; size = 8
$T6 = -504						; size = 8
$T7 = -496						; size = 8
_deagIt$8 = -488					; size = 24
_deagIt$9 = -464					; size = 24
_deagIt$10 = -440					; size = 24
_deagIt$ = -416						; size = 24
_cit$11 = -392						; size = 12
_cit$12 = -380						; size = 12
_sit$13 = -368						; size = 12
_cit$14 = -356						; size = 12
_dit$15 = -344						; size = 12
_cit$16 = -332						; size = 12
_dit$17 = -320						; size = 12
$T18 = -308						; size = 4
_info$19 = -304						; size = 4
$T20 = -300						; size = 4
$T21 = -296						; size = 4
$T22 = -292						; size = 4
$T23 = -288						; size = 4
tv982 = -284						; size = 4
$T24 = -280						; size = 4
tv963 = -276						; size = 4
_next$25 = -272						; size = 4
_numVeh$26 = -268					; size = 4
tv590 = -264						; size = 4
$T27 = -260						; size = 4
_target$28 = -256					; size = 4
tv1109 = -252						; size = 4
$T29 = -248						; size = 4
_next$30 = -244						; size = 4
$T31 = -240						; size = 4
tv1255 = -236						; size = 4
_wokenthiscycle$32 = -232				; size = 4
$T33 = -228						; size = 4
tv245 = -224						; size = 4
tv1231 = -220						; size = 4
tv393 = -216						; size = 4
_ok$ = -212						; size = 4
tv128 = -208						; size = 4
tv1178 = -204						; size = 4
tv396 = -200						; size = 4
tv1125 = -196						; size = 4
tv348 = -192						; size = 4
tv1029 = -188						; size = 4
_wokenthiscycle$34 = -184				; size = 4
$T35 = -180						; size = 4
_numberofobjects$36 = -176				; size = 4
tv1026 = -172						; size = 4
tv468 = -168						; size = 4
tv998 = -164						; size = 4
$T37 = -160						; size = 4
tv77 = -156						; size = 4
tv365 = -152						; size = 4
tv771 = -148						; size = 4
tv260 = -144						; size = 4
tv603 = -140						; size = 4
_numberofobjects$38 = -136				; size = 4
$T39 = -132						; size = 4
tv149 = -128						; size = 4
tv551 = -124						; size = 4
$T40 = -120						; size = 4
_rwindex$41 = -116					; size = 4
_msg$42 = -112						; size = 4
_i$43 = -108						; size = 4
_reag_ents$ = -104					; size = 4
$T44 = -100						; size = 4
$T45 = -96						; size = 4
$T46 = -92						; size = 4
$T47 = -88						; size = 4
_w$48 = -84						; size = 4
_deag$ = -80						; size = 4
_nextTOTime$49 = -76					; size = 4
_sy$ = -72						; size = 4
_sx$ = -68						; size = 4
_myit$ = -64						; size = 4
_deag_ents$ = -60					; size = 4
_c$50 = -56						; size = 4
_sit$ = -52						; size = 4
_player$ = -48						; size = 4
_object$51 = -44					; size = 4
_object$52 = -40					; size = 4
_airbase$53 = -36					; size = 4
_o$ = -32						; size = 4
_c$ = -28						; size = 4
_minDeagTime$54 = -24					; size = 4
_session$ = -20						; size = 4
_u$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_forced$ = 8						; size = 4
?RebuildBubble@@YAXH@Z PROC				; RebuildBubble

; 661  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RebuildBubble@@YAXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 524				; 0000020cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 662  : 	float			sx,sy;
; 663  : 	//	float			sx2,sy2;
; 664  : 	VuGridIterator	*myit;
; 665  : 	Objective		o;
; 666  : 	Unit			u;
; 667  : 	CampEntity		c;
; 668  : 	VuEntity		*player;
; 669  : 	//	VuEntity		*camera2;
; 670  : 	//	int				airm = 0,gndm = 0,moversInBubble;
; 671  : 	int				deag_ents=0,reag_ents=0,deag;

	mov	DWORD PTR _deag_ents$[ebp], 0
	mov	DWORD PTR _reag_ents$[ebp], 0

; 672  : 	int				ok;
; 673  : 	VuSessionsIterator	*sit;
; 674  : 	FalconSessionEntity  *session;
; 675  : 
; 676  : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 677  : 
; 678  : 
; 679  : 	if (forced && FalconLocalGame && g_brebuildbobbleFix){

	cmp	DWORD PTR _forced$[ebp], 0
	je	$LN122@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN125@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN126@RebuildBub
$LN125@RebuildBub:
	mov	DWORD PTR tv77[ebp], 0
$LN126@RebuildBub:
	cmp	DWORD PTR tv77[ebp], 0
	je	$LN122@RebuildBub
	movzx	ecx, BYTE PTR ?g_brebuildbobbleFix@@3_NA ; g_brebuildbobbleFix
	test	ecx, ecx
	je	$LN122@RebuildBub

; 680  : 		// host wake missiles and bombs 
; 681  : 		//MonoPrint ("FORCED SHORT REBUILD");
; 682  : 		if (FalconLocalGame->IsLocal()){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN127@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN128@RebuildBub
$LN127@RebuildBub:
	mov	DWORD PTR tv128[ebp], 0
$LN128@RebuildBub:
	mov	ecx, DWORD PTR tv128[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN121@RebuildBub

; 683  : 			// wake all missiles & bombs
; 684  : 			if (FalconLocalGame->IsLocal()){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN129@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN130@RebuildBub
$LN129@RebuildBub:
	mov	DWORD PTR tv149[ebp], 0
$LN130@RebuildBub:
	mov	ecx, DWORD PTR tv149[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	$LN120@RebuildBub

; 685  : 				// host wake missiles and bombs so we can drive them
; 686  : 				SimBaseClass	*object;
; 687  : 				VuListIterator	dit(SimDriver.ObjsWithNoCampaignParentList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+24
	push	eax
	lea	ecx, DWORD PTR _dit$17[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 688  : 				object = (SimBaseClass*)dit.GetFirst();

	lea	ecx, DWORD PTR _dit$17[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _object$51[ebp], eax

; 689  : 				int numberofobjects =0;

	mov	DWORD PTR _numberofobjects$38[ebp], 0

; 690  : 				int wokenthiscycle =0;

	mov	DWORD PTR _wokenthiscycle$34[ebp], 0
$LN119@RebuildBub:

; 691  : 				static int wokentotal =0;
; 692  : 				while (object)

	cmp	DWORD PTR _object$51[ebp], 0
	je	$LN118@RebuildBub

; 693  : 				{
; 694  : 					if (!object->IsAwake() && 
; 695  : 									!object->IsDead() &&
; 696  : 									(object->IsBomb()||object->IsMissile()))

	mov	ecx, DWORD PTR _object$51[ebp]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN117@RebuildBub
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	SHORT $LN117@RebuildBub
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	jne	SHORT $LN116@RebuildBub
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	SHORT $LN117@RebuildBub
$LN116@RebuildBub:

; 697  : 					{
; 698  : 						object->Wake();

	mov	ecx, DWORD PTR _object$51[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$51[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 699  : 						wokenthiscycle++;

	mov	ecx, DWORD PTR _wokenthiscycle$34[ebp]
	add	ecx, 1
	mov	DWORD PTR _wokenthiscycle$34[ebp], ecx

; 700  : 						wokentotal++;

	mov	edx, DWORD PTR ?wokentotal@?L@??RebuildBubble@@YAXH@Z@4HA
	add	edx, 1
	mov	DWORD PTR ?wokentotal@?L@??RebuildBubble@@YAXH@Z@4HA, edx
$LN117@RebuildBub:

; 701  : 					}
; 702  : 					object = (SimBaseClass*)dit.GetNext();

	lea	ecx, DWORD PTR _dit$17[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _object$51[ebp], eax

; 703  : 					numberofobjects++;

	mov	eax, DWORD PTR _numberofobjects$38[ebp]
	add	eax, 1
	mov	DWORD PTR _numberofobjects$38[ebp], eax

; 704  : 
; 705  : 				}

	jmp	$LN119@RebuildBub
$LN118@RebuildBub:

; 706  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dit$17[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN120@RebuildBub:

; 707  : 		}
; 708  : 		else// just wake the missiles and bombs in our bobble

	jmp	SHORT $LN114@RebuildBub
$LN121@RebuildBub:

; 709  : 		{	
; 710  : 			player = FalconLocalSession->GetCameraEntity(0);

	push	0
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	mov	DWORD PTR _player$[ebp], eax

; 711  : 			if (player)

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN114@RebuildBub

; 712  : 			{
; 713  : 				sx = player->XPos();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _sx$[ebp]

; 714  : 				sy = player->YPos();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _sy$[ebp]

; 715  : 				UpdateNoCampaignParentObjectsWakeState(sx, sy, 100000);

	push	ecx
	movss	xmm0, DWORD PTR __real@47c35000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?UpdateNoCampaignParentObjectsWakeState@@YAXMMM@Z ; UpdateNoCampaignParentObjectsWakeState
	add	esp, 12					; 0000000cH
$LN114@RebuildBub:

; 716  : 			}
; 717  : 		}
; 718  : 
; 719  : 
; 720  : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 721  : 		return;

	jmp	$LN123@RebuildBub
$LN122@RebuildBub:

; 722  : 	}
; 723  : 
; 724  : 
; 725  : 
; 726  : 
; 727  : 	gGameType = -1;

	mov	DWORD PTR ?gGameType@@3HA, -1		; gGameType

; 728  : 
; 729  : #if USE_VU_COLL_FOR_CAMPAIGN
; 730  : 	if ((!FalconLocalGame) || (!deaggregatedEntities)){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN131@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv245[ebp], eax
	jmp	SHORT $LN132@RebuildBub
$LN131@RebuildBub:
	mov	DWORD PTR tv245[ebp], 0
$LN132@RebuildBub:
	cmp	DWORD PTR tv245[ebp], 0
	je	SHORT $LN112@RebuildBub
	cmp	DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A, 0 ; deaggregatedEntities
	jne	SHORT $LN113@RebuildBub
$LN112@RebuildBub:

; 731  : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 732  : 		return;

	jmp	$LN123@RebuildBub
$LN113@RebuildBub:

; 733  : 	}
; 734  : #else
; 735  : 	if ((!FalconLocalGame) || (!deaggregatedMap)){
; 736  : 		CampLeaveCriticalSection();
; 737  : 		return;
; 738  : 	}
; 739  : #endif
; 740  : 
; 741  : 	// Check for dogfight game (special case in which flights always deaggregate)
; 742  : 	gGameType = FalconLocalGame->GetGameType();

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN133@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv260[ebp], eax
	jmp	SHORT $LN134@RebuildBub
$LN133@RebuildBub:
	mov	DWORD PTR tv260[ebp], 0
$LN134@RebuildBub:
	mov	ecx, DWORD PTR tv260[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	mov	DWORD PTR ?gGameType@@3HA, eax		; gGameType

; 743  : 
; 744  : 	// sfr: What is this? SetInterest and UnsetInterest right after??
; 745  : 	// this is wrong, although Im not sure what the correct behavior is
; 746  : #if USE_VU_COLL_FOR_CAMPAIGN
; 747  : 	VuHashIterator deagIt(deaggregatedEntities);

	mov	eax, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	push	eax
	lea	ecx, DWORD PTR _deagIt$[ebp]
	call	??0VuHashIterator@@QAE@PAVVuHashTable@@@Z ; VuHashIterator::VuHashIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 748  : 	for (

	lea	ecx, DWORD PTR _deagIt$[ebp]
	call	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetFirst
	mov	DWORD PTR _c$[ebp], eax

; 749  : 		c = static_cast<CampEntity>(deagIt.GetFirst());
; 750  : 		c != NULL;

	jmp	SHORT $LN111@RebuildBub
$LN110@RebuildBub:

; 751  : 		c = static_cast<CampEntity>(deagIt.GetNext())
; 752  : 	){

	lea	ecx, DWORD PTR _deagIt$[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetNext
	mov	DWORD PTR _c$[ebp], eax
$LN111@RebuildBub:
	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN109@RebuildBub

; 753  : 		//if (c->IsFlight()){
; 754  : 		//	c->SetInterest();
; 755  : 		//}
; 756  : 		c->UnsetInterest();

	mov	ecx, DWORD PTR _c$[ebp]
	call	?UnsetInterest@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetInterest

; 757  : 		reag_ents++;

	mov	ecx, DWORD PTR _reag_ents$[ebp]
	add	ecx, 1
	mov	DWORD PTR _reag_ents$[ebp], ecx

; 758  : 	}

	jmp	SHORT $LN110@RebuildBub
$LN109@RebuildBub:

; 759  : #else
; 760  : 	// Mark all currently deaggregated campaign entities as uninteresting
; 761  : 	{
; 762  : 		F4ScopeLock l(deaggregatedMap->getMutex());
; 763  : 		for (
; 764  : 			CampBaseMap::iterator it = deaggregatedMap->begin(); 
; 765  : 			it != deaggregatedMap->end();
; 766  : 			++it
; 767  : 		){
; 768  : 			CampBaseBin cb = it->second;
; 769  : 			//if (cb->IsFlight()){
; 770  : 			//	cb->SetInterest();
; 771  : 			//}
; 772  : 			cb->UnsetInterest();
; 773  : 			reag_ents++;
; 774  : 		}
; 775  : 	}
; 776  : #endif
; 777  : 
; 778  : 	// Mark all entities in sim lists as unchecked
; 779  : 	if (SimDriver.campUnitList){

	cmp	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+8, 0
	je	SHORT $LN108@RebuildBub

; 780  : 		VuListIterator		cit(SimDriver.campUnitList);

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+8
	push	edx
	lea	ecx, DWORD PTR _cit$14[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 781  : 		u = (Unit) cit.GetFirst();

	lea	ecx, DWORD PTR _cit$14[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN107@RebuildBub:

; 782  : 		while (u){

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN106@RebuildBub

; 783  : 			u->UnsetChecked();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?UnsetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetChecked

; 784  : 			u = (Unit) cit.GetNext();

	lea	ecx, DWORD PTR _cit$14[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 785  : 		}

	jmp	SHORT $LN107@RebuildBub
$LN106@RebuildBub:

; 786  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cit$14[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN108@RebuildBub:

; 787  : 	if (SimDriver.campObjList){

	cmp	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+12, 0
	je	SHORT $LN105@RebuildBub

; 788  : 		VuListIterator		cit(SimDriver.campObjList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+12
	push	eax
	lea	ecx, DWORD PTR _cit$16[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 789  : 		o = (Objective) cit.GetFirst();

	lea	ecx, DWORD PTR _cit$16[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _o$[ebp], eax
$LN104@RebuildBub:

; 790  : 		while (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN103@RebuildBub

; 791  : 			o->UnsetChecked();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?UnsetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetChecked

; 792  : 			o = (Objective) cit.GetNext();

	lea	ecx, DWORD PTR _cit$16[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _o$[ebp], eax

; 793  : 		}

	jmp	SHORT $LN104@RebuildBub
$LN103@RebuildBub:

; 794  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cit$16[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN105@RebuildBub:

; 795  : 
; 796  : 	if ((FalconLocalGame) && (FalconLocalGame->IsLocal())){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN135@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv348[ebp], eax
	jmp	SHORT $LN136@RebuildBub
$LN135@RebuildBub:
	mov	DWORD PTR tv348[ebp], 0
$LN136@RebuildBub:
	cmp	DWORD PTR tv348[ebp], 0
	je	$LN102@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN137@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv365[ebp], eax
	jmp	SHORT $LN138@RebuildBub
$LN137@RebuildBub:
	mov	DWORD PTR tv365[ebp], 0
$LN138@RebuildBub:
	mov	ecx, DWORD PTR tv365[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN102@RebuildBub

; 797  : 		// Check all cameras
; 798  : 		sit = new VuSessionsIterator(FalconLocalGame);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T37[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T37[ebp], 0
	je	SHORT $LN141@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN139@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv393[ebp], eax
	jmp	SHORT $LN140@RebuildBub
$LN139@RebuildBub:
	mov	DWORD PTR tv393[ebp], 0
$LN140@RebuildBub:
	mov	edx, DWORD PTR tv393[ebp]
	push	edx
	mov	ecx, DWORD PTR $T37[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR tv396[ebp], eax
	jmp	SHORT $LN142@RebuildBub
$LN141@RebuildBub:
	mov	DWORD PTR tv396[ebp], 0
$LN142@RebuildBub:
	mov	eax, DWORD PTR tv396[ebp]
	mov	DWORD PTR $T23[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR _sit$[ebp], ecx

; 799  : 		session = (FalconSessionEntity*) sit->GetFirst();

	mov	ecx, DWORD PTR _sit$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax

; 800  : 	}
; 801  : 	else {

	jmp	SHORT $LN101@RebuildBub
$LN102@RebuildBub:

; 802  : 		// Check our camera only
; 803  : 		sit = NULL;

	mov	DWORD PTR _sit$[ebp], 0

; 804  : 		session = FalconLocalSession;

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	DWORD PTR _session$[ebp], eax
$LN101@RebuildBub:

; 805  : 	}
; 806  : 
; 807  : 	while (session){

	cmp	DWORD PTR _session$[ebp], 0
	je	$LN99@RebuildBub

; 808  : 		// Find the first camera
; 809  : 		player = session->GetCameraEntity(0);

	push	0
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	mov	DWORD PTR _player$[ebp], eax

; 810  : 
; 811  : 		/*		if (!player && FalconLocalGame->IsLocal() && gCommsMgr->Online()) 
; 812  : 				player = FalconLocalSession->GetPlayerFlight();
; 813  : 		 */
; 814  : 		if (player && (player != FalconLocalSession || !sCampaignSleepRequested)){

	cmp	DWORD PTR _player$[ebp], 0
	je	$LN154@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _player$[ebp], eax
	jne	SHORT $LN97@RebuildBub
	cmp	DWORD PTR _sCampaignSleepRequested, 0
	jne	$LN154@RebuildBub
$LN97@RebuildBub:

; 815  : 			u = session->GetPlayerFlight ();

	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	mov	DWORD PTR _u$[ebp], eax

; 816  : 
; 817  : 			if (u){

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN96@RebuildBub

; 818  : 				u->SetInterest ();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetInterest@CampBaseClass@@QAEXXZ	; CampBaseClass::SetInterest
$LN96@RebuildBub:

; 819  : 			}
; 820  : 
; 821  : 			// We're in the cockpit
; 822  : #ifdef CAMPTOOL
; 823  : 			if (PBubble && hMainWnd){
; 824  : 				PostMessage(hMainWnd,WM_COMMAND,ID_CAMP_REFRESHPB,ID_CAMP_REFRESHPB);
; 825  : 			}
; 826  : #endif
; 827  : 			if (player){

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN95@RebuildBub

; 828  : 				sx = player->XPos();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _sx$[ebp]

; 829  : 				sy = player->YPos();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _sy$[ebp]
$LN95@RebuildBub:

; 830  : 			}
; 831  : 
; 832  : 			/*
; 833  : 			   if (FalconLocalSession == session)
; 834  : 			   {
; 835  : 			   MonoPrint ("Player Bubble %08x: %f,%f\n", player, sx, sy);
; 836  : 			   }
; 837  : 			   else
; 838  : 			   {
; 839  : 			   MonoPrint ("Remote Bubble %08x: %f,%f\n", player, sx, sy);
; 840  : 			   }.
; 841  : 
; 842  : 			   camera2 = session->Camera(1);
; 843  : 
; 844  : 			   if (camera2)
; 845  : 			   {
; 846  : 			   sx2 = camera2->XPos ();
; 847  : 			   sy2 = camera2->YPos ();
; 848  : 			   if (FalconLocalSession == session)
; 849  : 			   {
; 850  : 			   MonoPrint ("Player Bubble %08x: %f,%f\n", camera2, sx2, sy2);
; 851  : 			   }
; 852  : 			   else
; 853  : 			   {
; 854  : 			   MonoPrint ("Remote Bubble %08x: %f,%f\n", camera2, sx2, sy2);
; 855  : 			   }
; 856  : 			   }
; 857  : 			 */
; 858  : 
; 859  : 			// Deaggregate persistant objects (This just creates/destroys a local drawable object)
; 860  : 			if (session == FalconLocalSession){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _session$[ebp], eax
	jne	$LN94@RebuildBub

; 861  : 				if (FalconLocalGame->IsLocal())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN143@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv468[ebp], eax
	jmp	SHORT $LN144@RebuildBub
$LN143@RebuildBub:
	mov	DWORD PTR tv468[ebp], 0
$LN144@RebuildBub:
	mov	ecx, DWORD PTR tv468[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN93@RebuildBub

; 862  : 				{// host wake missiles and bombs so we can drive them
; 863  : 					VuListIterator	dit(SimDriver.ObjsWithNoCampaignParentList);

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+24
	push	ecx
	lea	ecx, DWORD PTR _dit$15[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 864  : 					SimBaseClass	*object;
; 865  : 					object = (SimBaseClass*)dit.GetFirst();

	lea	ecx, DWORD PTR _dit$15[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _object$52[ebp], eax

; 866  : 					int numberofobjects =0;

	mov	DWORD PTR _numberofobjects$36[ebp], 0

; 867  : 					int wokenthiscycle =0;

	mov	DWORD PTR _wokenthiscycle$32[ebp], 0
$LN92@RebuildBub:

; 868  : 					static int wokentotal =0;
; 869  : 					while (object){

	cmp	DWORD PTR _object$52[ebp], 0
	je	$LN91@RebuildBub

; 870  : 						if (
; 871  : 							!object->IsAwake() && !object->IsDead() &&
; 872  : 							(object->IsBomb()||object->IsMissile())
; 873  : 						){

	mov	ecx, DWORD PTR _object$52[ebp]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN90@RebuildBub
	mov	edx, DWORD PTR _object$52[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _object$52[ebp]
	mov	edx, DWORD PTR [eax+340]
	call	edx
	test	eax, eax
	jne	SHORT $LN90@RebuildBub
	mov	eax, DWORD PTR _object$52[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _object$52[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	jne	SHORT $LN89@RebuildBub
	mov	ecx, DWORD PTR _object$52[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$52[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	SHORT $LN90@RebuildBub
$LN89@RebuildBub:

; 874  : 							object->Wake();

	mov	ecx, DWORD PTR _object$52[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$52[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 875  : 							wokenthiscycle++;

	mov	ecx, DWORD PTR _wokenthiscycle$32[ebp]
	add	ecx, 1
	mov	DWORD PTR _wokenthiscycle$32[ebp], ecx

; 876  : 							wokentotal++;

	mov	edx, DWORD PTR ?wokentotal@?DK@??RebuildBubble@@YAXH@Z@4HA
	add	edx, 1
	mov	DWORD PTR ?wokentotal@?DK@??RebuildBubble@@YAXH@Z@4HA, edx
$LN90@RebuildBub:

; 877  : 						}
; 878  : 						object = (SimBaseClass*)dit.GetNext();

	lea	ecx, DWORD PTR _dit$15[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _object$52[ebp], eax

; 879  : 						numberofobjects++;					

	mov	eax, DWORD PTR _numberofobjects$36[ebp]
	add	eax, 1
	mov	DWORD PTR _numberofobjects$36[ebp], eax

; 880  : 					}

	jmp	$LN92@RebuildBub
$LN91@RebuildBub:

; 881  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _dit$15[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN93@RebuildBub:

; 882  : 				UpdateNoCampaignParentObjectsWakeState(sx, sy, 100000);

	push	ecx
	movss	xmm0, DWORD PTR __real@47c35000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?UpdateNoCampaignParentObjectsWakeState@@YAXMMM@Z ; UpdateNoCampaignParentObjectsWakeState
	add	esp, 12					; 0000000cH

; 883  : 				UpdatePersistantObjectsWakeState (sx, sy, PERSIST_BUBBLE_MAX, Camp_GetCurrentTime());

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@47001fcd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?UpdatePersistantObjectsWakeState@@YAXMMMK@Z ; UpdatePersistantObjectsWakeState
	add	esp, 16					; 00000010H
$LN94@RebuildBub:

; 884  : 			}
; 885  : 
; 886  : 			// Let's do objectives (max dist = reasonable max deaggreation distance plus some leeway)
; 887  : 			if (ObjProxList){

	cmp	DWORD PTR ?ObjProxList@@3PAVVuGridTree@@A, 0 ; ObjProxList
	je	$LN148@RebuildBub

; 888  : #ifdef VU_GRID_TREE_Y_MAJOR
; 889  : 				myit = new VuGridIterator(ObjProxList,sy,sx,SIM_BUBBLE_SIZE);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T40[ebp], 0
	je	SHORT $LN145@RebuildBub
	push	ecx
	movss	xmm0, DWORD PTR ?SIM_BUBBLE_SIZE@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sx$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sy$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?ObjProxList@@3PAVVuGridTree@@A ; ObjProxList
	push	ecx
	mov	ecx, DWORD PTR $T40[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR tv551[ebp], eax
	jmp	SHORT $LN146@RebuildBub
$LN145@RebuildBub:
	mov	DWORD PTR tv551[ebp], 0
$LN146@RebuildBub:
	mov	edx, DWORD PTR tv551[ebp]
	mov	DWORD PTR $T24[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T24[ebp]
	mov	DWORD PTR _myit$[ebp], eax

; 890  : #else
; 891  : 				myit = new VuGridIterator(ObjProxList,sx,sy,SIM_BUBBLE_SIZE);
; 892  : #endif
; 893  : 				o = (Objective) myit->GetFirst();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _o$[ebp], eax
$LN87@RebuildBub:

; 894  : 				while (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN86@RebuildBub

; 895  : 					if (DeaggregationCheck(o, session)>0){

	mov	ecx, DWORD PTR _session$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o$[ebp]
	push	edx
	call	?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z ; DeaggregationCheck
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN84@RebuildBub

; 896  : 						if (o->IsAggregate())

	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN84@RebuildBub

; 897  : 							deag_ents ++;

	mov	eax, DWORD PTR _deag_ents$[ebp]
	add	eax, 1
	mov	DWORD PTR _deag_ents$[ebp], eax
$LN84@RebuildBub:

; 898  : 					}
; 899  : 					o = (Objective) myit->GetNext();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _o$[ebp], eax

; 900  : 				}

	jmp	SHORT $LN87@RebuildBub
$LN86@RebuildBub:

; 901  : 				delete myit;

	mov	ecx, DWORD PTR _myit$[ebp]
	mov	DWORD PTR $T31[ebp], ecx
	mov	edx, DWORD PTR $T31[ebp]
	mov	DWORD PTR $T46[ebp], edx
	cmp	DWORD PTR $T46[ebp], 0
	je	SHORT $LN147@RebuildBub
	push	1
	mov	eax, DWORD PTR $T46[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T46[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv590[ebp], eax
	jmp	SHORT $LN148@RebuildBub
$LN147@RebuildBub:
	mov	DWORD PTR tv590[ebp], 0
$LN148@RebuildBub:

; 902  : 			}
; 903  : 
; 904  : 			// Now units (max dist = reasonable max deaggreation distance plus some leeway)
; 905  : 			if (RealUnitProxList){

	cmp	DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A, 0 ; RealUnitProxList
	je	$LN154@RebuildBub

; 906  : #ifdef VU_GRID_TREE_Y_MAJOR
; 907  : 				myit = new VuGridIterator(RealUnitProxList,sy,sx,SIM_BUBBLE_SIZE);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T39[ebp], 0
	je	SHORT $LN149@RebuildBub
	push	ecx
	movss	xmm0, DWORD PTR ?SIM_BUBBLE_SIZE@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sx$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sy$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	push	ecx
	mov	ecx, DWORD PTR $T39[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR tv603[ebp], eax
	jmp	SHORT $LN150@RebuildBub
$LN149@RebuildBub:
	mov	DWORD PTR tv603[ebp], 0
$LN150@RebuildBub:
	mov	edx, DWORD PTR tv603[ebp]
	mov	DWORD PTR $T27[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T27[ebp]
	mov	DWORD PTR _myit$[ebp], eax

; 908  : #else
; 909  : 				myit = new VuGridIterator(RealUnitProxList,sx,sy,SIM_BUBBLE_SIZE);
; 910  : #endif
; 911  : 				u = (Unit) myit->GetFirst();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN82@RebuildBub:

; 912  : 				while (u){

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN81@RebuildBub

; 913  : 					if (u->IsFlight() && (u->Final() || u == player)){

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN80@RebuildBub
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Final@UnitClass@@QBEHXZ		; UnitClass::Final
	test	eax, eax
	jne	SHORT $LN79@RebuildBub
	mov	ecx, DWORD PTR _u$[ebp]
	cmp	ecx, DWORD PTR _player$[ebp]
	jne	$LN80@RebuildBub
$LN79@RebuildBub:

; 914  : 						if (!u->Final()){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Final@UnitClass@@QBEHXZ		; UnitClass::Final
	test	eax, eax
	jne	SHORT $LN78@RebuildBub

; 915  : 							u->SetFinal(1);

	push	1
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetFinal@UnitClass@@QAEXH@Z		; UnitClass::SetFinal
$LN78@RebuildBub:

; 916  : 						}
; 917  : 						WayPoint w = u->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$48[ebp], eax

; 918  : 						if (!w){

	cmp	DWORD PTR _w$48[ebp], 0
	jne	SHORT $LN77@RebuildBub

; 919  : 							deag = 0;

	mov	DWORD PTR _deag$[ebp], 0
	jmp	$LN48@RebuildBub
$LN77@RebuildBub:

; 920  : 						}
; 921  : 						else if (w->GetWPAction() != WP_TAKEOFF){

	mov	ecx, DWORD PTR _w$48[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	je	SHORT $LN75@RebuildBub

; 922  : 							deag = 1;

	mov	DWORD PTR _deag$[ebp], 1
	jmp	$LN48@RebuildBub
$LN75@RebuildBub:

; 923  : 						}
; 924  : 						else if (!u->IsAggregate()){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN73@RebuildBub

; 925  : 							deag = 1;

	mov	DWORD PTR _deag$[ebp], 1

; 926  : 						}
; 927  : 						else {

	jmp	$LN48@RebuildBub
$LN73@RebuildBub:

; 928  : 							CampaignTime	minDeagTime;
; 929  : 							Objective airbase = (Objective)u->GetUnitAirbase();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+704]
	call	edx
	mov	DWORD PTR _airbase$53[ebp], eax

; 930  : 							// We'll deaggregate a few minutes before takeoff for objective airbases
; 931  : 							if (airbase && airbase->IsObjective() && airbase->brain){

	cmp	DWORD PTR _airbase$53[ebp], 0
	je	$LN71@RebuildBub
	mov	eax, DWORD PTR _airbase$53[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _airbase$53[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	$LN71@RebuildBub
	mov	ecx, DWORD PTR _airbase$53[ebp]
	cmp	DWORD PTR [ecx+240], 0
	je	$LN71@RebuildBub

; 932  : 								if(GetTTRelations(airbase->GetTeam(), u->GetTeam()) <= Neutral){

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _airbase$53[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _airbase$53[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 3
	jg	$LN70@RebuildBub

; 933  : 									runwayQueueStruct *info = airbase->brain->InList(u->Id());

	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$19[ebp], eax

; 934  : 									if(info){

	cmp	DWORD PTR _info$19[ebp], 0
	je	SHORT $LN69@RebuildBub

; 935  : 										minDeagTime = 0;

	mov	DWORD PTR _minDeagTime$54[ebp], 0

; 936  : 									}
; 937  : 									else {								

	jmp	$LN56@RebuildBub
$LN69@RebuildBub:

; 938  : 										int rwindex = airbase->brain->FindBestTakeoffRunway(TRUE);

	push	1
	mov	ecx, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _rwindex$41[ebp], eax

; 939  : 										ulong nextTOTime = airbase->brain->FindFlightTakeoffTime(
; 940  : 											(Flight)u,GetQueue(rwindex)
; 941  : 										);

	mov	edx, DWORD PTR _rwindex$41[ebp]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z ; ATCBrain::FindFlightTakeoffTime
	mov	DWORD PTR _nextTOTime$49[ebp], eax

; 942  : 
; 943  : 										minDeagTime = w->GetWPArrivalTime() - airbase->brain->MinDeagTime();

	mov	ecx, DWORD PTR _w$48[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	esi, eax
	mov	edx, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?MinDeagTime@ATCBrain@@QAEKXZ		; ATCBrain::MinDeagTime
	sub	esi, eax
	mov	DWORD PTR _minDeagTime$54[ebp], esi

; 944  : 
; 945  : 										if (gCommsMgr && gCommsMgr->Online()){

	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	$LN67@RebuildBub
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	je	$LN67@RebuildBub

; 946  : 											//me123 
; 947  : 											if (!u->IsSetFalcFlag(FEC_PLAYER_ENTERING|FEC_HASPLAYERS)){

	push	20					; 00000014H
	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	SHORT $LN66@RebuildBub

; 948  : 												minDeagTime = max(
; 949  : 													minDeagTime, nextTOTime - airbase->brain->MinDeagTime()
; 950  : 												);

	mov	eax, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?MinDeagTime@ATCBrain@@QAEKXZ		; ATCBrain::MinDeagTime
	mov	ecx, DWORD PTR _nextTOTime$49[ebp]
	sub	ecx, eax
	cmp	DWORD PTR _minDeagTime$54[ebp], ecx
	jbe	SHORT $LN151@RebuildBub
	mov	edx, DWORD PTR _minDeagTime$54[ebp]
	mov	DWORD PTR tv771[ebp], edx
	jmp	SHORT $LN152@RebuildBub
$LN151@RebuildBub:
	mov	eax, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?MinDeagTime@ATCBrain@@QAEKXZ		; ATCBrain::MinDeagTime
	mov	ecx, DWORD PTR _nextTOTime$49[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv771[ebp], ecx
$LN152@RebuildBub:
	mov	edx, DWORD PTR tv771[ebp]
	mov	DWORD PTR _minDeagTime$54[ebp], edx

; 951  : 											}
; 952  : 											else if (

	jmp	SHORT $LN64@RebuildBub
$LN66@RebuildBub:

; 953  : 												u->IsFlight() && 
; 954  : 												(((Flight)u)->GetEvalFlags() & FEVAL_START_COLD)
; 955  : 											){

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN64@RebuildBub
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetEvalFlags@FlightClass@@QAEEXZ	; FlightClass::GetEvalFlags
	movzx	ecx, al
	and	ecx, 16					; 00000010H
	je	SHORT $LN64@RebuildBub

; 956  : 												minDeagTime -= CampaignMinutes * PlayerOptionsClass::RAMP_MINUTES;

	mov	edx, DWORD PTR _minDeagTime$54[ebp]
	sub	edx, 1200000				; 00124f80H
	mov	DWORD PTR _minDeagTime$54[ebp], edx
$LN64@RebuildBub:

; 957  : 											}
; 958  : 										}
; 959  : 										else if (

	jmp	SHORT $LN60@RebuildBub
$LN67@RebuildBub:

; 960  : 											u->IsSetFalcFlag(FEC_PLAYER_ENTERING|FEC_HASPLAYERS) && 
; 961  : 											u->IsFlight()
; 962  : 										){

	push	20					; 00000014H
	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN62@RebuildBub
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN62@RebuildBub

; 963  : 											//JPO we need some extra time before takeoff if starting cold.
; 964  : 											if (((Flight)u)->GetEvalFlags() & FEVAL_START_COLD){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetEvalFlags@FlightClass@@QAEEXZ	; FlightClass::GetEvalFlags
	movzx	ecx, al
	and	ecx, 16					; 00000010H
	je	SHORT $LN61@RebuildBub

; 965  : 												minDeagTime -= CampaignMinutes * PlayerOptionsClass::RAMP_MINUTES;

	mov	edx, DWORD PTR _minDeagTime$54[ebp]
	sub	edx, 1200000				; 00124f80H
	mov	DWORD PTR _minDeagTime$54[ebp], edx
$LN61@RebuildBub:

; 966  : 											}
; 967  : 										}
; 968  : 										else {

	jmp	SHORT $LN60@RebuildBub
$LN62@RebuildBub:

; 969  : 											minDeagTime -= CampaignMinutes * g_nDeagTimer;

	mov	eax, DWORD PTR ?g_nDeagTimer@@3HA	; g_nDeagTimer
	imul	eax, 60000				; 0000ea60H
	mov	ecx, DWORD PTR _minDeagTime$54[ebp]
	sub	ecx, eax
	mov	DWORD PTR _minDeagTime$54[ebp], ecx
$LN60@RebuildBub:

; 970  : 										}
; 971  : 
; 972  : 										if(TheCampaign.CurrentTime >= minDeagTime){

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	edx, DWORD PTR _minDeagTime$54[ebp]
	jb	SHORT $LN56@RebuildBub

; 973  : 											//if we will be deagg'ed we need to make sure the slot is filled so
; 974  : 											//another flight won't also think it's available
; 975  : 											int numVeh = u->GetTotalVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _numVeh$26[ebp], eax

; 976  : 											for(int i = 0; i < numVeh; i++){

	mov	DWORD PTR _i$43[ebp], 0
	jmp	SHORT $LN58@RebuildBub
$LN57@RebuildBub:
	mov	eax, DWORD PTR _i$43[ebp]
	add	eax, 1
	mov	DWORD PTR _i$43[ebp], eax
$LN58@RebuildBub:
	mov	ecx, DWORD PTR _i$43[ebp]
	cmp	ecx, DWORD PTR _numVeh$26[ebp]
	jge	SHORT $LN56@RebuildBub

; 977  : 												airbase->brain->AddTraffic(u->Id(), noATC, rwindex, nextTOTime);

	mov	edx, DWORD PTR _nextTOTime$49[ebp]
	push	edx
	mov	eax, DWORD PTR _rwindex$41[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _airbase$53[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic

; 978  : 												nextTOTime += TAKEOFF_TIME_DELTA/2;	  

	mov	edx, DWORD PTR _nextTOTime$49[ebp]
	add	edx, 5000				; 00001388H
	mov	DWORD PTR _nextTOTime$49[ebp], edx

; 979  : 												// 27JAN04 - FRB - Bunch flight TO's closer together
; 980  : 											}

	jmp	SHORT $LN57@RebuildBub
$LN56@RebuildBub:

; 981  : 										}
; 982  : 									}
; 983  : 								}
; 984  : 								else {

	jmp	SHORT $LN55@RebuildBub
$LN70@RebuildBub:

; 985  : 									//if we are trying to take off from a hostile airbase, cancel the flight
; 986  : 									minDeagTime = TheCampaign.CurrentTime + 1;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	add	eax, 1
	mov	DWORD PTR _minDeagTime$54[ebp], eax

; 987  : 									CancelFlight((Flight)u);

	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?CancelFlight@@YAXPAVFlightClass@@@Z	; CancelFlight
	add	esp, 4
$LN55@RebuildBub:

; 988  : 								}
; 989  : 							}
; 990  : 							else {

	jmp	SHORT $LN50@RebuildBub
$LN71@RebuildBub:

; 991  : 								minDeagTime = w->GetWPArrivalTime(); // Carrier takeoff

	mov	ecx, DWORD PTR _w$48[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _minDeagTime$54[ebp], eax

; 992  : 								// JB carrier start
; 993  : 								if (u->IsSetFalcFlag(FEC_PLAYER_ENTERING|FEC_HASPLAYERS) && u->IsFlight())

	push	20					; 00000014H
	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN50@RebuildBub
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN50@RebuildBub

; 994  : 								{
; 995  : 									//JPO we need some extra time before takeoff if starting cold.
; 996  : 									if (((Flight)u)->GetEvalFlags() & FEVAL_START_COLD){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetEvalFlags@FlightClass@@QAEEXZ	; FlightClass::GetEvalFlags
	movzx	eax, al
	and	eax, 16					; 00000010H
	je	SHORT $LN52@RebuildBub

; 997  : 										minDeagTime -= CampaignMinutes * PlayerOptionsClass::RAMP_MINUTES;

	mov	ecx, DWORD PTR _minDeagTime$54[ebp]
	sub	ecx, 1200000				; 00124f80H
	mov	DWORD PTR _minDeagTime$54[ebp], ecx
	jmp	SHORT $LN50@RebuildBub
$LN52@RebuildBub:

; 998  : 									}
; 999  : 									else if (PlayerOptions.GetStartFlag() == PlayerOptionsClass::START_TAXI){

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	cmp	eax, 1
	jne	SHORT $LN50@RebuildBub

; 1000 : 										minDeagTime -= CampaignMinutes * g_nTaxiLaunchTime;	

	mov	edx, DWORD PTR ?g_nTaxiLaunchTime@@3HA	; g_nTaxiLaunchTime
	imul	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _minDeagTime$54[ebp]
	sub	eax, edx
	mov	DWORD PTR _minDeagTime$54[ebp], eax
$LN50@RebuildBub:

; 1001 : 									}
; 1002 : 									// Booster 2004/10/12 Taxi takeoff time
; 1003 : 								}
; 1004 : 								// JB carrier end
; 1005 : 							}
; 1006 : 
; 1007 : 							if (TheCampaign.CurrentTime >= minDeagTime){

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	ecx, DWORD PTR _minDeagTime$54[ebp]
	jb	SHORT $LN49@RebuildBub

; 1008 : 								deag = 1;

	mov	DWORD PTR _deag$[ebp], 1

; 1009 : 							}
; 1010 : 							else {

	jmp	SHORT $LN48@RebuildBub
$LN49@RebuildBub:

; 1011 : 								deag = 0;

	mov	DWORD PTR _deag$[ebp], 0
$LN48@RebuildBub:

; 1012 : 							}
; 1013 : 						}
; 1014 : 
; 1015 : 						if (deag){

	cmp	DWORD PTR _deag$[ebp], 0
	je	SHORT $LN45@RebuildBub

; 1016 : 							if (!u->IsDead() && DeaggregationCheck(u, session)>0){

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+552]
	call	edx
	test	eax, eax
	jne	SHORT $LN45@RebuildBub
	mov	eax, DWORD PTR _session$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z ; DeaggregationCheck
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN45@RebuildBub

; 1017 : 								if (u->IsAggregate()){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN45@RebuildBub

; 1018 : 									deag_ents ++;

	mov	edx, DWORD PTR _deag_ents$[ebp]
	add	edx, 1
	mov	DWORD PTR _deag_ents$[ebp], edx
$LN45@RebuildBub:

; 1019 : 								}
; 1020 : 							}
; 1021 : 						}
; 1022 : 					}

	jmp	SHORT $LN40@RebuildBub
$LN80@RebuildBub:

; 1023 : 					else if ((u->IsBattalion() || u->IsTaskForce()) && !u->Inactive()){

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN42@RebuildBub
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN40@RebuildBub
$LN42@RebuildBub:
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Inactive@UnitClass@@QBEHXZ		; UnitClass::Inactive
	test	eax, eax
	jne	SHORT $LN40@RebuildBub

; 1024 : 						if (!u->IsDead() && !u->Inactive() && DeaggregationCheck(u, session)>0)	{

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN40@RebuildBub
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Inactive@UnitClass@@QBEHXZ		; UnitClass::Inactive
	test	eax, eax
	jne	SHORT $LN40@RebuildBub
	mov	ecx, DWORD PTR _session$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z ; DeaggregationCheck
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN40@RebuildBub

; 1025 : 							if (u->IsAggregate()){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN40@RebuildBub

; 1026 : 								deag_ents ++;

	mov	eax, DWORD PTR _deag_ents$[ebp]
	add	eax, 1
	mov	DWORD PTR _deag_ents$[ebp], eax
$LN40@RebuildBub:

; 1027 : 							}
; 1028 : 						}
; 1029 : 					}
; 1030 : 					u = (Unit)myit->GetNext();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 1031 : 				}

	jmp	$LN82@RebuildBub
$LN81@RebuildBub:

; 1032 : 				delete myit;

	mov	ecx, DWORD PTR _myit$[ebp]
	mov	DWORD PTR $T21[ebp], ecx
	mov	edx, DWORD PTR $T21[ebp]
	mov	DWORD PTR $T44[ebp], edx
	cmp	DWORD PTR $T44[ebp], 0
	je	SHORT $LN153@RebuildBub
	push	1
	mov	eax, DWORD PTR $T44[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T44[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv963[ebp], eax
	jmp	SHORT $LN154@RebuildBub
$LN153@RebuildBub:
	mov	DWORD PTR tv963[ebp], 0
$LN154@RebuildBub:

; 1033 : 			}
; 1034 : 		}
; 1035 : 
; 1036 : 		if (sit){

	cmp	DWORD PTR _sit$[ebp], 0
	je	SHORT $LN39@RebuildBub

; 1037 : 			session = (FalconSessionEntity*) sit->GetNext();

	mov	ecx, DWORD PTR _sit$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$[ebp], eax

; 1038 : 		}
; 1039 : 		else{

	jmp	SHORT $LN38@RebuildBub
$LN39@RebuildBub:

; 1040 : 			session = NULL;

	mov	DWORD PTR _session$[ebp], 0
$LN38@RebuildBub:

; 1041 : 		}
; 1042 : 	}

	jmp	$LN101@RebuildBub
$LN99@RebuildBub:

; 1043 : 
; 1044 : 	if (sit){

	cmp	DWORD PTR _sit$[ebp], 0
	je	SHORT $LN156@RebuildBub

; 1045 : 		delete sit;

	mov	ecx, DWORD PTR _sit$[ebp]
	mov	DWORD PTR $T20[ebp], ecx
	mov	edx, DWORD PTR $T20[ebp]
	mov	DWORD PTR $T47[ebp], edx
	cmp	DWORD PTR $T47[ebp], 0
	je	SHORT $LN155@RebuildBub
	push	1
	mov	eax, DWORD PTR $T47[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T47[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv982[ebp], eax
	jmp	SHORT $LN156@RebuildBub
$LN155@RebuildBub:
	mov	DWORD PTR tv982[ebp], 0
$LN156@RebuildBub:

; 1046 : 	}
; 1047 : 
; 1048 : 	///////////////////////////////////////////////////////////////////////////////
; 1049 : 	// This is how many Campaign entities we're going to deaggregate this cycle.
; 1050 : 	gLeftToDeaggregate = deag_ents;

	mov	ecx, DWORD PTR _deag_ents$[ebp]
	mov	DWORD PTR ?gLeftToDeaggregate@@3HC, ecx	; gLeftToDeaggregate

; 1051 : 
; 1052 : 	if (FalconLocalGame->IsLocal()){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN157@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv998[ebp], eax
	jmp	SHORT $LN158@RebuildBub
$LN157@RebuildBub:
	mov	DWORD PTR tv998[ebp], 0
$LN158@RebuildBub:
	mov	ecx, DWORD PTR tv998[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN164@RebuildBub

; 1053 : 		sit = new VuSessionsIterator (FalconLocalGame);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T35[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T35[ebp], 0
	je	SHORT $LN161@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN159@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv1026[ebp], eax
	jmp	SHORT $LN160@RebuildBub
$LN159@RebuildBub:
	mov	DWORD PTR tv1026[ebp], 0
$LN160@RebuildBub:
	mov	edx, DWORD PTR tv1026[ebp]
	push	edx
	mov	ecx, DWORD PTR $T35[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR tv1029[ebp], eax
	jmp	SHORT $LN162@RebuildBub
$LN161@RebuildBub:
	mov	DWORD PTR tv1029[ebp], 0
$LN162@RebuildBub:
	mov	eax, DWORD PTR tv1029[ebp]
	mov	DWORD PTR $T18[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T18[ebp]
	mov	DWORD PTR _sit$[ebp], ecx

; 1054 : 		session = (FalconSessionEntity *) sit->GetFirst ();

	mov	ecx, DWORD PTR _sit$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax
$LN35@RebuildBub:

; 1055 : 
; 1056 : 		while (session){

	cmp	DWORD PTR _session$[ebp], 0
	je	$LN34@RebuildBub

; 1057 : 			if (session != FalconLocalSession){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _session$[ebp], eax
	je	$LN33@RebuildBub

; 1058 : #if USE_VU_COLL_FOR_CAMPAIGN
; 1059 : 				VuHashIterator deagIt(deaggregatedEntities);

	mov	edx, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	push	edx
	lea	ecx, DWORD PTR _deagIt$9[ebp]
	call	??0VuHashIterator@@QAE@PAVVuHashTable@@@Z ; VuHashIterator::VuHashIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 1060 : 				for (

	lea	ecx, DWORD PTR _deagIt$9[ebp]
	call	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetFirst
	mov	DWORD PTR _c$[ebp], eax

; 1061 : 					c = static_cast<CampEntity>(deagIt.GetFirst ());
; 1062 : 					c != NULL;

	jmp	SHORT $LN32@RebuildBub
$LN31@RebuildBub:

; 1063 : 					c = static_cast<CampEntity>(deagIt.GetNext())
; 1064 : 				){

	lea	ecx, DWORD PTR _deagIt$9[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetNext
	mov	DWORD PTR _c$[ebp], eax
$LN32@RebuildBub:
	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN30@RebuildBub

; 1065 : 					if ((c->IsUnit ()) && (c->GetDeagOwner () == session->Id ())){

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN28@RebuildBub
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _c$[ebp]
	call	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ; CampBaseClass::GetDeagOwner
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@RebuildBub

; 1066 : 						if (!session->GetCameraEntity(0)){

	push	0
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	test	eax, eax
	jne	SHORT $LN28@RebuildBub

; 1067 : 							ChooseNewSession (c);

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	?ChooseNewSession@@YAXPAVCampBaseClass@@@Z ; ChooseNewSession
	add	esp, 4
$LN28@RebuildBub:

; 1068 : 						}
; 1069 : 					}					
; 1070 : 				}

	jmp	SHORT $LN31@RebuildBub
$LN30@RebuildBub:

; 1071 : #else
; 1072 : 				//me123 let the host own the ents even when he's in the ui
; 1073 : 				F4ScopeLock l(deaggregatedMap->getMutex());
; 1074 : 				for (
; 1075 : 					CampBaseMap::iterator it = deaggregatedMap->begin(); 
; 1076 : 					it != deaggregatedMap->end();
; 1077 : 					++it
; 1078 : 				){
; 1079 : 					CampBaseBin cb = it->second;
; 1080 : 					if ((cb->IsUnit ()) && (cb->GetDeagOwner () == session->Id())){
; 1081 : 						if (!session->GetCameraEntity(0)){
; 1082 : 							ChooseNewSession(cb.get());
; 1083 : 						}
; 1084 : 					}
; 1085 : 				}
; 1086 : #endif
; 1087 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _deagIt$9[ebp]
	call	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
$LN33@RebuildBub:

; 1088 : 			session = (FalconSessionEntity *) sit->GetNext ();

	mov	ecx, DWORD PTR _sit$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$[ebp], eax

; 1089 : 		}

	jmp	$LN35@RebuildBub
$LN34@RebuildBub:

; 1090 : 		delete sit; // JPO memory leak fix

	mov	edx, DWORD PTR _sit$[ebp]
	mov	DWORD PTR $T22[ebp], edx
	mov	eax, DWORD PTR $T22[ebp]
	mov	DWORD PTR $T45[ebp], eax
	cmp	DWORD PTR $T45[ebp], 0
	je	SHORT $LN163@RebuildBub
	push	1
	mov	ecx, DWORD PTR $T45[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T45[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv1109[ebp], eax
	jmp	SHORT $LN164@RebuildBub
$LN163@RebuildBub:
	mov	DWORD PTR tv1109[ebp], 0
$LN164@RebuildBub:

; 1091 : 	}
; 1092 : 
; 1093 : 	if (FalconLocalGame->IsLocal()){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN165@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv1125[ebp], eax
	jmp	SHORT $LN166@RebuildBub
$LN165@RebuildBub:
	mov	DWORD PTR tv1125[ebp], 0
$LN166@RebuildBub:
	mov	ecx, DWORD PTR tv1125[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	$LN27@RebuildBub

; 1094 : 		// Now Reaggregate any of our previous CampEntities which are no longer interesting
; 1095 : 		if (reag_ents){

	cmp	DWORD PTR _reag_ents$[ebp], 0
	je	$LN26@RebuildBub

; 1096 : #if USE_VU_COLL_FOR_CAMPAIGN
; 1097 : 			VuHashIterator deagIt(deaggregatedEntities);

	mov	eax, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	push	eax
	lea	ecx, DWORD PTR _deagIt$10[ebp]
	call	??0VuHashIterator@@QAE@PAVVuHashTable@@@Z ; VuHashIterator::VuHashIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 1098 : 			for (

	lea	ecx, DWORD PTR _deagIt$10[ebp]
	call	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetFirst
	mov	DWORD PTR _c$50[ebp], eax

; 1099 : 				CampEntity c = static_cast<CampEntity>(deagIt.GetFirst());
; 1100 : 				c != NULL;

	jmp	SHORT $LN25@RebuildBub
$LN24@RebuildBub:

; 1101 : 				c = static_cast<CampEntity>(deagIt.GetNext())
; 1102 : 			){

	lea	ecx, DWORD PTR _deagIt$10[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetNext
	mov	DWORD PTR _c$50[ebp], eax
$LN25@RebuildBub:
	cmp	DWORD PTR _c$50[ebp], 0
	je	$LN23@RebuildBub

; 1103 : 				if (!c->IsInterested()){

	mov	ecx, DWORD PTR _c$50[ebp]
	call	?IsInterested@CampBaseClass@@QAEHXZ	; CampBaseClass::IsInterested
	test	eax, eax
	jne	$LN15@RebuildBub

; 1104 : 					ok = TRUE;

	mov	DWORD PTR _ok$[ebp], 1

; 1105 : 					if (c->IsFlight()){

	mov	ecx, DWORD PTR _c$50[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _c$50[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN21@RebuildBub

; 1106 : 						VuSessionsIterator sit(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN167@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv1178[ebp], eax
	jmp	SHORT $LN168@RebuildBub
$LN167@RebuildBub:
	mov	DWORD PTR tv1178[ebp], 0
$LN168@RebuildBub:
	mov	edx, DWORD PTR tv1178[ebp]
	push	edx
	lea	ecx, DWORD PTR _sit$13[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 1107 : 						for (

	lea	ecx, DWORD PTR _sit$13[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax

; 1108 : 							session = static_cast<FalconSessionEntity*>(sit.GetFirst());
; 1109 : 							session != NULL;

	jmp	SHORT $LN20@RebuildBub
$LN19@RebuildBub:

; 1110 : 							session = static_cast<FalconSessionEntity*>(sit.GetNext())
; 1111 : 						){

	lea	ecx, DWORD PTR _sit$13[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$[ebp], eax
$LN20@RebuildBub:
	cmp	DWORD PTR _session$[ebp], 0
	je	SHORT $LN18@RebuildBub

; 1112 : 							if (session->GetPlayerFlight () == c){

	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	cmp	eax, DWORD PTR _c$50[ebp]
	jne	SHORT $LN16@RebuildBub

; 1113 : 								if (session->GetCameraEntity(0)){

	push	0
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	test	eax, eax
	je	SHORT $LN16@RebuildBub

; 1114 : 									ok = FALSE;

	mov	DWORD PTR _ok$[ebp], 0
$LN16@RebuildBub:

; 1115 : 								}
; 1116 : 							}	
; 1117 : 						}

	jmp	SHORT $LN19@RebuildBub
$LN18@RebuildBub:

; 1118 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR _sit$13[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
$LN21@RebuildBub:

; 1119 : 
; 1120 : 					if (ok){

	cmp	DWORD PTR _ok$[ebp], 0
	je	$LN15@RebuildBub

; 1121 : 						VuTargetEntity* target = (VuTargetEntity*) vuDatabase->Find(FalconLocalGame->OwnerId());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN169@RebuildBub
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv1231[ebp], eax
	jmp	SHORT $LN170@RebuildBub
$LN169@RebuildBub:
	mov	DWORD PTR tv1231[ebp], 0
$LN170@RebuildBub:
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv1231[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$28[ebp], eax

; 1122 : 						FalconSimCampMessage	*msg = new FalconSimCampMessage(c->Id(), target);

	push	66					; 00000042H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T33[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T33[ebp], 0
	je	SHORT $LN171@RebuildBub
	push	1
	mov	ecx, DWORD PTR _target$28[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _c$50[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T33[ebp]
	call	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconSimCampMessage::FalconSimCampMessage
	mov	DWORD PTR tv1255[ebp], eax
	jmp	SHORT $LN172@RebuildBub
$LN171@RebuildBub:
	mov	DWORD PTR tv1255[ebp], 0
$LN172@RebuildBub:
	mov	eax, DWORD PTR tv1255[ebp]
	mov	DWORD PTR $T29[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T29[ebp]
	mov	DWORD PTR _msg$42[ebp], ecx

; 1123 : 						msg->dataBlock.from = FalconLocalSessionId;

	mov	edx, DWORD PTR _msg$42[ebp]
	mov	eax, DWORD PTR ?vuLocalSession@@3VVU_ID@@A
	mov	DWORD PTR [edx+48], eax
	mov	ecx, DWORD PTR ?vuLocalSession@@3VVU_ID@@A+4
	mov	DWORD PTR [edx+52], ecx

; 1124 : 						msg->dataBlock.message = FalconSimCampMessage::simcampReaggregate;

	mov	edx, DWORD PTR _msg$42[ebp]
	mov	DWORD PTR [edx+56], 0

; 1125 : 						FalconSendMessage(msg);

	push	0
	mov	eax, DWORD PTR _msg$42[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN15@RebuildBub:

; 1126 : 					}
; 1127 : 				}
; 1128 : 			}

	jmp	$LN24@RebuildBub
$LN23@RebuildBub:

; 1129 : #else
; 1130 : 			F4ScopeLock l(deaggregatedMap->getMutex());
; 1131 : 			for (
; 1132 : 				CampBaseMap::iterator it = deaggregatedMap->begin(); 
; 1133 : 				it != deaggregatedMap->end();
; 1134 : 				++it
; 1135 : 			){
; 1136 : 				CampBaseBin cb = it->second;
; 1137 : 
; 1138 : 				if (!cb->IsInterested()){
; 1139 : 					ok = TRUE;
; 1140 : 					if (cb->IsFlight()){
; 1141 : 						sit = new VuSessionsIterator(FalconLocalGame);
; 1142 : 						session = (FalconSessionEntity*) sit->GetFirst();
; 1143 : 						while (session){
; 1144 : 							if (session->GetPlayerFlight () == cb){
; 1145 : 								if (session->GetCameraEntity(0)){
; 1146 : 									ok = FALSE;
; 1147 : 								}
; 1148 : 							}
; 1149 : 							session = (FalconSessionEntity *) sit->GetNext ();
; 1150 : 						}
; 1151 : 						delete sit; // JPO memory leak fix
; 1152 : 					}
; 1153 : 
; 1154 : 					if (ok){
; 1155 : 						VuTargetEntity* target = (VuTargetEntity*) vuDatabase->Find(FalconLocalGame->OwnerId());
; 1156 : 						FalconSimCampMessage	*msg = new FalconSimCampMessage (cb->Id(), target);
; 1157 : 						msg->dataBlock.from = FalconLocalSessionId;
; 1158 : 						msg->dataBlock.message = FalconSimCampMessage::simcampReaggregate;
; 1159 : 						FalconSendMessage(msg);
; 1160 : 					}
; 1161 : 				}
; 1162 : 			}
; 1163 : #endif
; 1164 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _deagIt$10[ebp]
	call	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
$LN26@RebuildBub:
$LN27@RebuildBub:

; 1165 : 	}
; 1166 : 	else
; 1167 : 	{
; 1168 : 		// Now Reaggregate any of our previous CampEntities which are no longer interesting
; 1169 : #if 0
; 1170 : 		if (reag_ents)
; 1171 : 		{
; 1172 : 			c = (CampEntity) deag_it.GetFirst();
; 1173 : 			while (c)
; 1174 : 			{
; 1175 : 				if (!c->IsInterested())
; 1176 : 				{
; 1177 : 					ok = TRUE;
; 1178 : 
; 1179 : 					if (c->IsFlight())
; 1180 : 					{
; 1181 : 						sit = new VuSessionsIterator(FalconLocalGame);
; 1182 : 						session = (FalconSessionEntity*) sit->GetFirst();
; 1183 : 
; 1184 : 						while (session)
; 1185 : 						{
; 1186 : 							if (session->GetPlayerFlight () == c)
; 1187 : 							{
; 1188 : 								ok = FALSE;
; 1189 : 							}
; 1190 : 							session = (FalconSessionEntity *) sit->GetNext ();
; 1191 : 						}
; 1192 : 						delete sit; //me123 memory leak
; 1193 : 						if (!ok)
; 1194 : 						{
; 1195 : 							//							MonoPrint ("Reaggregating Flight that is a player flight %08x\n", c);
; 1196 : 						}
; 1197 : 					}
; 1198 : 
; 1199 : 					if (ok)
; 1200 : 					{
; 1201 : 						//float
; 1202 : 						//	dist = 0.0;
; 1203 : 
; 1204 : 						//MonoPrint ("I WANT TO REAGGREGATE %08x %f\n", c, dist);
; 1205 : 					}
; 1206 : 				}
; 1207 : 				c = (CampEntity) deag_it.GetNext();
; 1208 : 			}
; 1209 : 		}
; 1210 : #endif
; 1211 : 	}
; 1212 : 
; 1213 : 	if (sCampaignSleepRequested)

	cmp	DWORD PTR _sCampaignSleepRequested, 0
	je	$LN13@RebuildBub

; 1214 : 	{
; 1215 : 		// Chill all persistant object draw pointers
; 1216 : 		UpdatePersistantObjectsWakeState (0,0,0,TheCampaign.CurrentTime);

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?UpdatePersistantObjectsWakeState@@YAXMMMK@Z ; UpdatePersistantObjectsWakeState

; 1217 : 		UpdateNoCampaignParentObjectsWakeState (0,0,0);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?UpdateNoCampaignParentObjectsWakeState@@YAXMMM@Z ; UpdateNoCampaignParentObjectsWakeState
	add	esp, 12					; 0000000cH

; 1218 : #if USE_VU_COLL_FOR_CAMPAIGN
; 1219 : 		VuHashIterator deagIt(deaggregatedEntities);

	mov	edx, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	push	edx
	lea	ecx, DWORD PTR _deagIt$8[ebp]
	call	??0VuHashIterator@@QAE@PAVVuHashTable@@@Z ; VuHashIterator::VuHashIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH

; 1220 : 		for (

	lea	ecx, DWORD PTR _deagIt$8[ebp]
	call	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetFirst
	mov	DWORD PTR _c$[ebp], eax

; 1221 : 			c = static_cast<CampEntity>(deagIt.GetFirst());
; 1222 : 			c != NULL;

	jmp	SHORT $LN12@RebuildBub
$LN11@RebuildBub:

; 1223 : 			c = static_cast<CampEntity>(deagIt.GetNext())
; 1224 : 		){

	lea	ecx, DWORD PTR _deagIt$8[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetNext
	mov	DWORD PTR _c$[ebp], eax
$LN12@RebuildBub:
	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN10@RebuildBub

; 1225 : 			if (c->IsAwake()){

	mov	ecx, DWORD PTR _c$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN9@RebuildBub

; 1226 : 				c->Sleep();

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax

; 1227 : 				c->UnsetChecked();

	mov	ecx, DWORD PTR _c$[ebp]
	call	?UnsetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetChecked
$LN9@RebuildBub:

; 1228 : 			}
; 1229 : 		}

	jmp	SHORT $LN11@RebuildBub
$LN10@RebuildBub:

; 1230 : #else
; 1231 : 		// Sleep all deaggregated campaign entities
; 1232 : 		F4ScopeLock l(deaggregatedMap->getMutex());
; 1233 : 		for_each(deaggregatedMap->begin(), deaggregatedMap->end(), CampBaseClass::SleepAndUnsetCheckedOp());
; 1234 : #endif
; 1235 : 	}	

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _deagIt$8[ebp]
	call	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
$LN13@RebuildBub:

; 1236 : 
; 1237 : 	// Now remove any CampEntities which we are no longer interested in
; 1238 : 	if (SimDriver.campUnitList){

	cmp	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+8, 0
	je	SHORT $LN8@RebuildBub

; 1239 : 		VuListIterator cit(SimDriver.campUnitList);

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+8
	push	ecx
	lea	ecx, DWORD PTR _cit$11[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH

; 1240 : 		u = (Unit) cit.GetFirst();

	lea	ecx, DWORD PTR _cit$11[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN7@RebuildBub:

; 1241 : 		while (u){

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN6@RebuildBub

; 1242 : 			Unit next = static_cast<Unit>(cit.GetNext());

	lea	ecx, DWORD PTR _cit$11[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _next$25[ebp], eax

; 1243 : 			if (!u->IsChecked()){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?IsChecked@CampBaseClass@@QAEHXZ	; CampBaseClass::IsChecked
	test	eax, eax
	jne	SHORT $LN5@RebuildBub

; 1244 : 				u->RemoveFromSimLists();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+348]
	call	edx
$LN5@RebuildBub:

; 1245 : 			}
; 1246 : 			u = next;

	mov	eax, DWORD PTR _next$25[ebp]
	mov	DWORD PTR _u$[ebp], eax

; 1247 : 		}

	jmp	SHORT $LN7@RebuildBub
$LN6@RebuildBub:

; 1248 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cit$11[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN8@RebuildBub:

; 1249 : 
; 1250 : 	if (SimDriver.campObjList){

	cmp	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+12, 0
	je	SHORT $LN4@RebuildBub

; 1251 : 		VuListIterator cit(SimDriver.campObjList);

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+12
	push	ecx
	lea	ecx, DWORD PTR _cit$12[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH

; 1252 : 		o = (Objective) cit.GetFirst();

	lea	ecx, DWORD PTR _cit$12[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _o$[ebp], eax
$LN3@RebuildBub:

; 1253 : 		while (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN2@RebuildBub

; 1254 : 			Objective next = static_cast<Objective>(cit.GetNext());

	lea	ecx, DWORD PTR _cit$12[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _next$30[ebp], eax

; 1255 : 			if (!o->IsChecked()){ o->RemoveFromSimLists(); }

	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsChecked@CampBaseClass@@QAEHXZ	; CampBaseClass::IsChecked
	test	eax, eax
	jne	SHORT $LN1@RebuildBub
	mov	edx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax+348]
	call	edx
$LN1@RebuildBub:

; 1256 : 			o = next;

	mov	eax, DWORD PTR _next$30[ebp]
	mov	DWORD PTR _o$[ebp], eax

; 1257 : 		}

	jmp	SHORT $LN3@RebuildBub
$LN2@RebuildBub:

; 1258 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cit$12[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN4@RebuildBub:

; 1259 : 
; 1260 : 	sCampaignSleepRequested = 0;

	mov	DWORD PTR _sCampaignSleepRequested, 0

; 1261 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 1262 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _deagIt$[ebp]
	call	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
$LN123@RebuildBub:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RebuildBubble@@YAXH@Z$0:
	lea	ecx, DWORD PTR _dit$17[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$1:
	lea	ecx, DWORD PTR _deagIt$[ebp]
	jmp	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$2:
	lea	ecx, DWORD PTR _cit$14[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$3:
	lea	ecx, DWORD PTR _cit$16[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$4:
	mov	eax, DWORD PTR $T37[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RebuildBubble@@YAXH@Z$5:
	lea	ecx, DWORD PTR _dit$15[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$6:
	mov	eax, DWORD PTR $T40[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RebuildBubble@@YAXH@Z$7:
	mov	eax, DWORD PTR $T39[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RebuildBubble@@YAXH@Z$8:
	mov	eax, DWORD PTR $T35[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RebuildBubble@@YAXH@Z$9:
	lea	ecx, DWORD PTR _deagIt$9[ebp]
	jmp	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$10:
	lea	ecx, DWORD PTR _deagIt$10[ebp]
	jmp	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$11:
	lea	ecx, DWORD PTR _sit$13[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$12:
	mov	eax, DWORD PTR $T33[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RebuildBubble@@YAXH@Z$13:
	lea	ecx, DWORD PTR _deagIt$8[ebp]
	jmp	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$14:
	lea	ecx, DWORD PTR _cit$11[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RebuildBubble@@YAXH@Z$15:
	lea	ecx, DWORD PTR _cit$12[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RebuildBubble@@YAXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-532]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RebuildBubble@@YAXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RebuildBubble@@YAXH@Z ENDP				; RebuildBubble
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_sit$ = -104						; size = 12
$T2 = -92						; size = 8
$T3 = -84						; size = 8
$T4 = -76						; size = 4
tv221 = -72						; size = 4
tv216 = -68						; size = 4
tv179 = -64						; size = 4
$T5 = -60						; size = 4
tv168 = -56						; size = 4
_best_dist$ = -52					; size = 4
_y$ = -48						; size = 4
_x$ = -44						; size = 4
_msg$6 = -40						; size = 4
_dist$ = -36						; size = 4
_dy$ = -32						; size = 4
_dx$ = -28						; size = 4
_player$ = -24						; size = 4
_best_session$ = -20					; size = 4
_session$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ent$ = 8						; size = 4
?ChooseNewSession@@YAXPAVCampBaseClass@@@Z PROC		; ChooseNewSession

; 615  : void ChooseNewSession(CampEntity ent){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 616  : 	FalconSessionEntity *session=NULL, *best_session=NULL;

	mov	DWORD PTR _session$[ebp], 0
	mov	DWORD PTR _best_session$[ebp], 0

; 617  : 	VuSessionsIterator sit;

	push	0
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 	VuEntity *player=NULL;

	mov	DWORD PTR _player$[ebp], 0

; 619  : 
; 620  : 	float x=0.0F, y=0.0F, dx=0.0F, dy=0.0F, dist=0.0F, best_dist=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dist$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _best_dist$[ebp], xmm0

; 621  : 
; 622  : 	session = (FalconSessionEntity *) sit.GetFirst ();

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax

; 623  : 	best_session = NULL;

	mov	DWORD PTR _best_session$[ebp], 0
$LN6@ChooseNewS:

; 624  : 	while (session){

	cmp	DWORD PTR _session$[ebp], 0
	je	$LN5@ChooseNewS

; 625  : 		player = session->GetCameraEntity(0);

	push	0
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	mov	DWORD PTR _player$[ebp], eax

; 626  : 		if (player) {

	cmp	DWORD PTR _player$[ebp], 0
	je	$LN3@ChooseNewS

; 627  : 			x = player->XPos ();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _x$[ebp]

; 628  : 			y = player->YPos ();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _y$[ebp]

; 629  : 			dx = x - ent->XPos ();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv216[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR tv216[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 630  : 			dy = y - ent->YPos ();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv221[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR tv221[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 631  : 			dist = dx * dx + dy * dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 632  : 			if ((!best_session) || (dist < best_dist)){

	cmp	DWORD PTR _best_session$[ebp], 0
	je	SHORT $LN2@ChooseNewS
	movss	xmm0, DWORD PTR _best_dist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN3@ChooseNewS
$LN2@ChooseNewS:

; 633  : 				best_dist = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _best_dist$[ebp], xmm0

; 634  : 				best_session = session;

	mov	eax, DWORD PTR _session$[ebp]
	mov	DWORD PTR _best_session$[ebp], eax
$LN3@ChooseNewS:

; 635  : 			}
; 636  : 		}
; 637  : 		session = (FalconSessionEntity *)sit.GetNext();

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$[ebp], eax

; 638  : 	}

	jmp	$LN6@ChooseNewS
$LN5@ChooseNewS:

; 639  : 
; 640  : 	if (best_session){

	cmp	DWORD PTR _best_session$[ebp], 0
	je	$LN1@ChooseNewS

; 641  : 		//VuTargetEntity* target = (VuTargetEntity*) vuDatabase->Find(FalconLocalGame->OwnerId());
; 642  : 		FalconSimCampMessage	*msg = new FalconSimCampMessage(ent->Id(), FalconLocalGame);

	push	66					; 00000042H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN11@ChooseNewS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@ChooseNewS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN10@ChooseNewS
$LN9@ChooseNewS:
	mov	DWORD PTR tv168[ebp], 0
$LN10@ChooseNewS:
	push	1
	mov	edx, DWORD PTR tv168[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconSimCampMessage::FalconSimCampMessage
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN12@ChooseNewS
$LN11@ChooseNewS:
	mov	DWORD PTR tv179[ebp], 0
$LN12@ChooseNewS:
	mov	eax, DWORD PTR tv179[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _msg$6[ebp], ecx

; 643  : 		msg->dataBlock.from = best_session->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _best_session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$6[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 644  : 		msg->dataBlock.message = FalconSimCampMessage::simcampChangeOwner;

	mov	ecx, DWORD PTR _msg$6[ebp]
	mov	DWORD PTR [ecx+56], 2

; 645  : 		FalconSendMessage(msg);

	push	0
	mov	edx, DWORD PTR _msg$6[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN1@ChooseNewS:

; 646  : 	}
; 647  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z$0:
	lea	ecx, DWORD PTR _sit$[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__unwindfunclet$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChooseNewSession@@YAXPAVCampBaseClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseNewSession@@YAXPAVCampBaseClass@@@Z ENDP		; ChooseNewSession
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
$T2 = -84						; size = 8
$T3 = -76						; size = 8
$T4 = -68						; size = 8
$T5 = -60						; size = 8
$T6 = -52						; size = 4
_target$7 = -48						; size = 4
_inbobble$ = -44					; size = 4
tv161 = -40						; size = 4
$T8 = -36						; size = 4
_player$9 = -32						; size = 4
_want_in_sim_list$ = -28				; size = 4
_want_deaggregate$ = -24				; size = 4
_msg$10 = -20						; size = 4
_didsimlistcrap$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_e$ = 8							; size = 4
_session$ = 12						; size = 4
?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z PROC ; DeaggregationCheck

; 468  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 469  : 	int	want_deaggregate = 0, want_in_sim_list =0;

	mov	DWORD PTR _want_deaggregate$[ebp], 0
	mov	DWORD PTR _want_in_sim_list$[ebp], 0

; 470  : 	bool didsimlistcrap = FALSE;

	mov	BYTE PTR _didsimlistcrap$[ebp], 0

; 471  : 	int inbobble = (session->InSessionBubble(e,REAGREGATION_RATIO));

	push	ecx
	movss	xmm0, DWORD PTR ?REAGREGATION_RATIO@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _session$[ebp]
	call	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z ; FalconSessionEntity::InSessionBubble
	mov	DWORD PTR _inbobble$[ebp], eax

; 472  : 	if (e->IsAggregate()){

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	$LN40@Deaggregat

; 473  : 		if (session->InSessionBubble(e,1.0F) && !g_bSleepAll){	

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _session$[ebp]
	call	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z ; FalconSessionEntity::InSessionBubble
	test	eax, eax
	je	$LN39@Deaggregat
	movzx	edx, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	edx, edx
	jne	$LN39@Deaggregat

; 474  : 			// It's in our bubble, post deaggregate message if host
; 475  : 			if (e->IsLocal())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN38@Deaggregat

; 476  : 			{
; 477  : 				VuTargetEntity* target = (VuTargetEntity*)
; 478  : 					vuDatabase->Find(vuLocalSessionEntity->Game()->OwnerId());

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$7[ebp], eax

; 479  : 				FalconSimCampMessage	*msg = new FalconSimCampMessage (e->Id(), target);

	push	66					; 00000042H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN43@Deaggregat
	push	1
	mov	ecx, DWORD PTR _target$7[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconSimCampMessage::FalconSimCampMessage
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN44@Deaggregat
$LN43@Deaggregat:
	mov	DWORD PTR tv161[ebp], 0
$LN44@Deaggregat:
	mov	eax, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _msg$10[ebp], ecx

; 480  : 				//me123 let the host own all the planes
; 481  : 				// sfr: host will own battallions too, since battallion 3d movement depends on 2d
; 482  : 				if ((e->IsBattalion()) || e->IsFlight() || (g_bServer && g_bServerHostAll)) {

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	jne	SHORT $LN36@Deaggregat
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	jne	SHORT $LN36@Deaggregat
	movzx	ecx, BYTE PTR ?g_bServer@@3_NA		; g_bServer
	test	ecx, ecx
	je	SHORT $LN37@Deaggregat
	movzx	edx, BYTE PTR ?g_bServerHostAll@@3_NA	; g_bServerHostAll
	test	edx, edx
	je	SHORT $LN37@Deaggregat
$LN36@Deaggregat:

; 483  : 					msg->dataBlock.from = vuLocalSessionEntity->Game()->OwnerId();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$10[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 484  : 					if (g_bLogEvents && e->IsSetFalcFlag(FEC_HASPLAYERS)){

	movzx	ecx, BYTE PTR ?g_bLogEvents@@3_NA	; g_bLogEvents
	test	ecx, ecx
	je	SHORT $LN35@Deaggregat
	push	4
	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN35@Deaggregat

; 485  : 						TheCampaign.MissionEvaluator->PreEvalFlight((Flight)e, NULL);

	push	0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+324
	call	?PreEvalFlight@MissionEvaluationClass@@QAEXPAVFlightClass@@0@Z ; MissionEvaluationClass::PreEvalFlight
$LN35@Deaggregat:

; 486  : 					}
; 487  : 				}
; 488  : 				else {

	jmp	SHORT $LN34@Deaggregat
$LN37@Deaggregat:

; 489  : 					msg->dataBlock.from = session->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$10[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx
$LN34@Deaggregat:

; 490  : 				}
; 491  : 				msg->dataBlock.message = FalconSimCampMessage::simcampDeaggregate;

	mov	ecx, DWORD PTR _msg$10[ebp]
	mov	DWORD PTR [ecx+56], 1

; 492  : 				msg->RequestReliableTransmit();

	mov	ecx, DWORD PTR _msg$10[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit

; 493  : 				FalconSendMessage(msg);

	push	0
	mov	edx, DWORD PTR _msg$10[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN38@Deaggregat:

; 494  : 			}
; 495  : 			e->SetInterest();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetInterest@CampBaseClass@@QAEXXZ	; CampBaseClass::SetInterest

; 496  : 			want_deaggregate = 1;

	mov	DWORD PTR _want_deaggregate$[ebp], 1

; 497  : 			want_in_sim_list = 1;

	mov	DWORD PTR _want_in_sim_list$[ebp], 1
$LN39@Deaggregat:

; 498  : 		}
; 499  : 	}
; 500  : 	else { 

	jmp	$LN7@Deaggregat
$LN40@Deaggregat:

; 501  : 		if (e == session->GetPlayerFlight() || inbobble ){

	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	cmp	DWORD PTR _e$[ebp], eax
	je	SHORT $LN31@Deaggregat
	cmp	DWORD PTR _inbobble$[ebp], 0
	je	SHORT $LN32@Deaggregat
$LN31@Deaggregat:

; 502  : 			// Mark this player entity to prevent reaggregation
; 503  : 			e->SetInterest();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetInterest@CampBaseClass@@QAEXXZ	; CampBaseClass::SetInterest

; 504  : 			want_deaggregate = 1;

	mov	DWORD PTR _want_deaggregate$[ebp], 1

; 505  : 			want_in_sim_list = 1;

	mov	DWORD PTR _want_in_sim_list$[ebp], 1
$LN32@Deaggregat:

; 506  : 		}
; 507  : 		if (session == FalconLocalSession ){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _session$[ebp], eax
	jne	$LN16@Deaggregat

; 508  : 			// Update local sleep/wake state
; 509  : 			// me123 this handles local wake/sleep
; 510  : 			// for the host dont' handle airplanes and helicopters
; 511  : 			if (e->IsUnit()  && !g_bSleepAll){

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN29@Deaggregat
	movzx	ecx, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	ecx, ecx
	jne	SHORT $LN29@Deaggregat

; 512  : 				want_in_sim_list = 1;

	mov	DWORD PTR _want_in_sim_list$[ebp], 1

; 513  : 				if (!e->IsAwake()){

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN28@Deaggregat

; 514  : 					e->Wake ();

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx
$LN28@Deaggregat:

; 515  : 				}
; 516  : 			}
; 517  : 			else {

	jmp	$LN16@Deaggregat
$LN29@Deaggregat:

; 518  : 				// Update local sleep/wake state
; 519  : 				if (e->IsAwake() && (!want_deaggregate || g_bSleepAll)){

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	$LN26@Deaggregat
	cmp	DWORD PTR _want_deaggregate$[ebp], 0
	je	SHORT $LN25@Deaggregat
	movzx	eax, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	eax, eax
	je	$LN26@Deaggregat
$LN25@Deaggregat:

; 520  : 					if (!vuLocalSessionEntity->Game()->IsLocal() || g_bSleepAll){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@Deaggregat
	movzx	edx, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	edx, edx
	je	SHORT $LN24@Deaggregat
$LN23@Deaggregat:

; 521  : 						e->Sleep();

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN24@Deaggregat:

; 522  : 					}
; 523  : 
; 524  : 					if (vuLocalSessionEntity->Game()->IsLocal()){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@Deaggregat

; 525  : 						if (!e->IsAirplane() && !e->IsHelicopter()){

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	jne	SHORT $LN21@Deaggregat
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	test	eax, eax
	jne	SHORT $LN21@Deaggregat

; 526  : 							e->Sleep();	

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax

; 527  : 						}
; 528  : 						else if (

	jmp	SHORT $LN19@Deaggregat
$LN21@Deaggregat:

; 529  : 							!e->IsObjective() || 
; 530  : 							(
; 531  : 								e->IsObjective() && (e->GetType () != TYPE_AIRBASE) && (e->GetType () != TYPE_AIRSTRIP)
; 532  : 							)
; 533  : 						)

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN18@Deaggregat
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN19@Deaggregat
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 1
	je	SHORT $LN19@Deaggregat
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 2
	je	SHORT $LN19@Deaggregat
$LN18@Deaggregat:

; 534  : 							e->Sleep();

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN19@Deaggregat:

; 535  : 					}
; 536  : 				}

	jmp	SHORT $LN16@Deaggregat
$LN26@Deaggregat:

; 537  : 				else if (!e->IsAwake() && inbobble && !g_bSleepAll){

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN16@Deaggregat
	cmp	DWORD PTR _inbobble$[ebp], 0
	je	SHORT $LN16@Deaggregat
	movzx	ecx, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	ecx, ecx
	jne	SHORT $LN16@Deaggregat

; 538  : 					e->Wake();

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx
$LN16@Deaggregat:

; 539  : 				}
; 540  : 			}
; 541  : 
; 542  : 		}
; 543  : 		// host wake/sleep all deaged flights
; 544  : 		if (
; 545  : 			vuLocalSessionEntity->Game()->IsLocal() && 
; 546  : 			( //me123 host wake/sleep stuff
; 547  : 			  //handle airplanes helicopters and airbases
; 548  : 				g_bSleepAll || 
; 549  : 				e->IsAirplane() || e->IsHelicopter()  || 
; 550  : 				(e->IsObjective() && ((e->GetType () == TYPE_AIRBASE) || (e->GetType () == TYPE_AIRSTRIP)) ) || 
; 551  : 				( g_bServer && g_bServerHostAll && e->IsUnit()) 
; 552  : 				//and airbases
; 553  : 			) 
; 554  : 		){ //dedicated host wake all ents

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN7@Deaggregat
	movzx	ecx, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	ecx, ecx
	jne	$LN14@Deaggregat
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	jne	SHORT $LN14@Deaggregat
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	test	eax, eax
	jne	SHORT $LN14@Deaggregat
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN13@Deaggregat
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 1
	je	SHORT $LN14@Deaggregat
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 2
	je	SHORT $LN14@Deaggregat
$LN13@Deaggregat:
	movzx	eax, BYTE PTR ?g_bServer@@3_NA		; g_bServer
	test	eax, eax
	je	$LN7@Deaggregat
	movzx	ecx, BYTE PTR ?g_bServerHostAll@@3_NA	; g_bServerHostAll
	test	ecx, ecx
	je	$LN7@Deaggregat
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+232]
	call	edx
	test	eax, eax
	je	$LN7@Deaggregat
$LN14@Deaggregat:

; 555  : 			didsimlistcrap = TRUE;

	mov	BYTE PTR _didsimlistcrap$[ebp], 1

; 556  : 			if (g_bSleepAll) // host sleep all and get rdy to enter 3d

	movzx	eax, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	eax, eax
	je	SHORT $LN12@Deaggregat

; 557  : 			{// this is the only case where a host wanna sleep ents
; 558  : 				// normaly the aggregate funktion wildo it
; 559  : 				if (e->IsAwake()) {

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN11@Deaggregat

; 560  : 					e->Sleep();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN11@Deaggregat:

; 561  : 				}
; 562  : 				e->SetChecked();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::SetChecked

; 563  : 			}
; 564  : 			else if (!g_bSleepAll && !e->IsSetFalcFlag(FEC_PLAYER_ENTERING) &&// we are not in sleep all mode

	jmp	$LN7@Deaggregat
$LN12@Deaggregat:

; 565  : 							(
; 566  : 							 !e->IsSetFalcFlag(FEC_PLAYERONLY) ||// not a human
; 567  : 							 (
; 568  : 							  //human but he's attached 
; 569  : 							  e->IsSetFalcFlag(FEC_PLAYERONLY) && e->IsSetFalcFlag(FEC_HASPLAYERS)
; 570  : 							 )
; 571  : 							)
; 572  : 					)

	movzx	ecx, BYTE PTR ?g_bSleepAll@@3_NA	; g_bSleepAll
	test	ecx, ecx
	jne	$LN7@Deaggregat
	push	16					; 00000010H
	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	$LN7@Deaggregat
	push	2
	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN8@Deaggregat
	push	2
	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	$LN7@Deaggregat
	push	4
	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN7@Deaggregat
$LN8@Deaggregat:

; 573  : 			{
; 574  : 				if ((FalconLocalSession->GetFlyState() == FLYSTATE_IN_UI || 
; 575  : 										FalconLocalSession->GetFlyState() == FLYSTATE_FLYING ||
; 576  : 										FalconLocalSession->GetFlyState() ==FLYSTATE_WAITING))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetFlyState@FalconSessionEntity@@QBEEXZ ; FalconSessionEntity::GetFlyState
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@Deaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetFlyState@FalconSessionEntity@@QBEEXZ ; FalconSessionEntity::GetFlyState
	movzx	eax, al
	cmp	eax, 3
	je	SHORT $LN6@Deaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetFlyState@FalconSessionEntity@@QBEEXZ ; FalconSessionEntity::GetFlyState
	movzx	ecx, al
	cmp	ecx, 2
	jne	SHORT $LN7@Deaggregat
$LN6@Deaggregat:

; 577  : 					// only wake if the server isn't transitign to/from ui
; 578  : 				{
; 579  : 					if (!e->IsAwake()){

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN5@Deaggregat

; 580  : 						e->Wake();

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx
$LN5@Deaggregat:

; 581  : 					}
; 582  : 					want_deaggregate = 1;

	mov	DWORD PTR _want_deaggregate$[ebp], 1

; 583  : 					e->RemoveFromSimLists();

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+348]
	call	eax
$LN7@Deaggregat:

; 584  : 				}
; 585  : 
; 586  : 			}
; 587  : 		}
; 588  : 
; 589  : 	}
; 590  : 	if (session == FalconLocalSession && !didsimlistcrap)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _session$[ebp], eax
	jne	SHORT $LN2@Deaggregat
	movzx	ecx, BYTE PTR _didsimlistcrap$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Deaggregat

; 591  : 	{
; 592  : 		// Update the entity's Sim List state
; 593  : 		if (want_in_sim_list)//me123 oldmp && InSimLists() )

	cmp	DWORD PTR _want_in_sim_list$[ebp], 0
	je	SHORT $LN3@Deaggregat

; 594  : 		{
; 595  : 			e->RemoveFromSimLists();

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+348]
	call	edx

; 596  : 		}
; 597  : 		else

	jmp	SHORT $LN2@Deaggregat
$LN3@Deaggregat:

; 598  : 		{
; 599  : 			VuEntity *player = session->GetCameraEntity(0);

	push	0
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetCameraEntity@VuSessionEntity@@QBEPAVVuEntity@@E@Z ; VuSessionEntity::GetCameraEntity
	mov	DWORD PTR _player$9[ebp], eax

; 600  : 			if (player)

	cmp	DWORD PTR _player$9[ebp], 0
	je	SHORT $LN1@Deaggregat

; 601  : 			{
; 602  : 				e->InsertInSimLists(player->XPos(),player->YPos());

	mov	ecx, DWORD PTR _player$9[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _player$9[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+344]
	call	eax
$LN1@Deaggregat:

; 603  : 			}
; 604  : 			e->SetChecked();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::SetChecked
$LN2@Deaggregat:

; 605  : 		}
; 606  : 	}
; 607  : 
; 608  : 	return want_deaggregate;

	mov	eax, DWORD PTR _want_deaggregate$[ebp]

; 609  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z$0:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeaggregationCheck@@YAHPAVCampBaseClass@@PAVFalconSessionEntity@@@Z ENDP ; DeaggregationCheck
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_br$ = -12						; size = 4
tv93 = -8						; size = 4
_new_ratio$ = -4					; size = 4
_moversInBubble$ = 8					; size = 4
?ResizeBubble@@YAXH@Z PROC				; ResizeBubble

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 434  : 	float		br,new_ratio;
; 435  : 
; 436  : 	br = (float)(PLAYER_BUBBLE_MOVERS - moversInBubble);

	movsx	eax, WORD PTR ?PLAYER_BUBBLE_MOVERS@@3FA ; PLAYER_BUBBLE_MOVERS
	sub	eax, DWORD PTR _moversInBubble$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _br$[ebp], xmm0

; 437  : 	//new_ratio = ((FalconSessionEntity*)vuLocalSessionEntity.get())->GetBubbleRatio() * 1.0F + (br * 0.01F);
; 438  : 	new_ratio = FalconLocalSession->GetBubbleRatio() * 1.0F + (br * 0.01F);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetBubbleRatio@FalconSessionEntity@@QBEMXZ ; FalconSessionEntity::GetBubbleRatio
	fstp	DWORD PTR tv93[ebp]
	movss	xmm0, DWORD PTR tv93[ebp]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR _br$[ebp]
	mulss	xmm1, DWORD PTR __real@3c23d70a
	addss	xmm0, xmm1
	movss	DWORD PTR _new_ratio$[ebp], xmm0

; 439  : 
; 440  : 	if (new_ratio > 1.2F)

	movss	xmm0, DWORD PTR _new_ratio$[ebp]
	comiss	xmm0, DWORD PTR __real@3f99999a
	jbe	SHORT $LN2@ResizeBubb

; 441  : 	{
; 442  : 		new_ratio = 1.2F;

	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR _new_ratio$[ebp], xmm0
$LN2@ResizeBubb:

; 443  : 	}
; 444  : 
; 445  : 	if (new_ratio < 0.25F)

	movss	xmm0, DWORD PTR __real@3e800000
	comiss	xmm0, DWORD PTR _new_ratio$[ebp]
	jbe	SHORT $LN1@ResizeBubb

; 446  : 	{
; 447  : 		new_ratio = 0.25F;

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _new_ratio$[ebp], xmm0
$LN1@ResizeBubb:

; 448  : 	}
; 449  : 
; 450  : 	//((FalconSessionEntity*)vuLocalSessionEntity)->SetBubbleRatio (new_ratio);
; 451  : 	FalconLocalSession->SetBubbleRatio (new_ratio);

	push	ecx
	movss	xmm0, DWORD PTR _new_ratio$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z ; FalconSessionEntity::SetBubbleRatio

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResizeBubble@@YAXH@Z ENDP				; ResizeBubble
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_myit$ = -28						; size = 12
_u$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_minutes$ = 8						; size = 4
?RallyUnits@@YAXH@Z PROC				; RallyUnits

; 2813 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RallyUnits@@YAXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2814 : 	Unit			u;
; 2815 : 	VuListIterator	myit(AllParentList);

	mov	eax, DWORD PTR ?AllParentList@@3PAVVuLinkedList@@A ; AllParentList
	push	eax
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2816 : 
; 2817 : 	// Create the unit lists
; 2818 : 	u = GetFirstUnit(&myit);

	lea	ecx, DWORD PTR _myit$[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax
$LN4@RallyUnits:

; 2819 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN3@RallyUnits

; 2820 : 	{
; 2821 : 		if (u->GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 3
	jne	SHORT $LN2@RallyUnits

; 2822 : 		{
; 2823 : 			if (!u->Scripted() && !u->Engaged() && u->GetUnitOrders() == GORD_RESERVE)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Scripted@UnitClass@@QBEHXZ		; UnitClass::Scripted
	test	eax, eax
	jne	SHORT $LN1@RallyUnits
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	jne	SHORT $LN1@RallyUnits
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@RallyUnits

; 2824 : 				u->RallyUnit(minutes);

	mov	ecx, DWORD PTR _minutes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+940]
	call	edx
$LN1@RallyUnits:

; 2825 : 			u->UpdateParentStatistics();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+988]
	call	eax
$LN2@RallyUnits:

; 2826 : 		}
; 2827 : 		u = GetNextUnit(&myit);

	lea	ecx, DWORD PTR _myit$[ebp]
	push	ecx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax

; 2828 : 	}

	jmp	SHORT $LN4@RallyUnits
$LN3@RallyUnits:

; 2829 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RallyUnits@@YAXH@Z$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RallyUnits@@YAXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RallyUnits@@YAXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RallyUnits@@YAXH@Z ENDP				; RallyUnits
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_t$ = -1						; size = 1
?OrderGroundAndNavalUnits@@YAXXZ PROC			; OrderGroundAndNavalUnits

; 2796 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2797 : 	Team	t;
; 2798 : 
; 2799 : 	ResetObjectiveAssignmentScores();

	call	?ResetObjectiveAssignmentScores@@YAXXZ	; ResetObjectiveAssignmentScores

; 2800 : 	BuildDivisionData();

	call	?BuildDivisionData@@YAXXZ		; BuildDivisionData

; 2801 : 	for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN4@OrderGroun
$LN3@OrderGroun:
	mov	al, BYTE PTR _t$[ebp]
	add	al, 1
	mov	BYTE PTR _t$[ebp], al
$LN4@OrderGroun:
	movzx	ecx, BYTE PTR _t$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN5@OrderGroun

; 2802 : 	{
; 2803 : 		if (TeamInfo[t])

	movzx	edx, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4], 0
	je	SHORT $LN1@OrderGroun

; 2804 : 		{
; 2805 : 			TeamInfo[t]->gtm->Task();

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [ecx+880]
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+880]
	mov	eax, DWORD PTR [edx+320]
	call	eax

; 2806 : 			TeamInfo[t]->ntm->Task();

	movzx	ecx, BYTE PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+884]
	movzx	ecx, BYTE PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+884]
	mov	edx, DWORD PTR [eax+320]
	call	edx
$LN1@OrderGroun:

; 2807 : 		}
; 2808 : 	}

	jmp	SHORT $LN3@OrderGroun
$LN5@OrderGroun:

; 2809 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OrderGroundAndNavalUnits@@YAXXZ ENDP			; OrderGroundAndNavalUnits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_t$ = -1						; size = 1
_planCount$ = 8						; size = 4
?PlanGroundAndNavalUnits@@YAXPAH@Z PROC			; PlanGroundAndNavalUnits

; 2772 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2773 : 	Team		t;
; 2774 : 
; 2775 : 	(*planCount)++;

	mov	eax, DWORD PTR _planCount$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _planCount$[ebp]
	mov	DWORD PTR [edx], ecx

; 2776 : 	if (*planCount >= (MIN_PLAN_GROUND/60))

	movsx	eax, WORD PTR ?MIN_PLAN_GROUND@@3FA	; MIN_PLAN_GROUND
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	edx, DWORD PTR _planCount$[ebp]
	cmp	DWORD PTR [edx], eax
	jl	$LN9@PlanGround

; 2777 : 	{
; 2778 : 		for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN8@PlanGround
$LN7@PlanGround:
	mov	al, BYTE PTR _t$[ebp]
	add	al, 1
	mov	BYTE PTR _t$[ebp], al
$LN8@PlanGround:
	movzx	ecx, BYTE PTR _t$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN6@PlanGround

; 2779 : 		{
; 2780 : 			if (TeamInfo[t])

	movzx	edx, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4], 0
	je	SHORT $LN5@PlanGround

; 2781 : 			{
; 2782 : 				TeamInfo[t]->gtm->DoCalculations();

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [ecx+880]
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+880]
	mov	eax, DWORD PTR [edx+324]
	call	eax

; 2783 : 				TeamInfo[t]->ntm->DoCalculations();

	movzx	ecx, BYTE PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+884]
	movzx	ecx, BYTE PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+884]
	mov	edx, DWORD PTR [eax+324]
	call	edx
$LN5@PlanGround:

; 2784 : 			}
; 2785 : 		}

	jmp	SHORT $LN7@PlanGround
$LN6@PlanGround:

; 2786 : 		*planCount=0;

	mov	eax, DWORD PTR _planCount$[ebp]
	mov	DWORD PTR [eax], 0
$LN9@PlanGround:

; 2787 : 	}
; 2788 : 	for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN4@PlanGround
$LN3@PlanGround:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN4@PlanGround:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN10@PlanGround

; 2789 : 	{
; 2790 : 		if (TeamInfo[t])

	movzx	eax, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN1@PlanGround

; 2791 : 			TeamInfo[t]->SelectGroundAction();

	movzx	ecx, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SelectGroundAction@TeamClass@@QAEXXZ	; TeamClass::SelectGroundAction
$LN1@PlanGround:

; 2792 : 	}

	jmp	SHORT $LN3@PlanGround
$LN10@PlanGround:

; 2793 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlanGroundAndNavalUnits@@YAXPAH@Z ENDP			; PlanGroundAndNavalUnits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?CheckNewDay@@YAXXZ PROC				; CheckNewDay

; 2757 : {

	push	ebp
	mov	ebp, esp

; 2758 : 	if (TheCampaign.CurrentTime > static_cast<CampaignTime>(CampaignDay*(TheCampaign.CurrentDay+1)))

	movzx	eax, BYTE PTR ?TheCampaign@@3VCampaignClass@@A+90
	add	eax, 1
	imul	eax, 86400000				; 05265c00H
	cmp	DWORD PTR ?TheCampaign@@3VCampaignClass@@A, eax
	jbe	SHORT $LN3@CheckNewDa

; 2759 : 	{
; 2760 : 		MonoPrint("Entering Campaign Day: %d\n",TheCampaign.CurrentDay);

	movzx	ecx, BYTE PTR ?TheCampaign@@3VCampaignClass@@A+90
	push	ecx
	push	OFFSET ??_C@_0BL@BFGMPINB@Entering?5Campaign?5Day?3?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 8

; 2761 : 		// 2002-04-02 MNLOOK does this make problems in MP ?
; 2762 : 		// Now that we've a floating bullseye, perhaps it should be put back in
; 2763 : 		// Also, what happens to SMS if Bullseye changes while in-flight ?
; 2764 : 		if (g_nChooseBullseyeFix & 0x02){

	mov	edx, DWORD PTR ?g_nChooseBullseyeFix@@3HA ; g_nChooseBullseyeFix
	and	edx, 2
	je	SHORT $LN1@CheckNewDa

; 2765 : 			ChooseBullseye();

	call	?ChooseBullseye@@YAXXZ			; ChooseBullseye
$LN1@CheckNewDa:

; 2766 : 		}
; 2767 : 		TheCampaign.GetCurrentDay();

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?GetCurrentDay@CampaignClass@@QAEHXZ	; CampaignClass::GetCurrentDay
$LN3@CheckNewDa:

; 2768 : 	}
; 2769 : }

	pop	ebp
	ret	0
?CheckNewDay@@YAXXZ ENDP				; CheckNewDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_rit$ = -36						; size = 12
_REAL_DEATH_TIMEOUT_MS$2 = -24				; size = 4
_next$3 = -20						; size = 4
_u$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_deltatime$ = 8						; size = 4
?UpdateRealUnits@@YAXK@Z PROC				; UpdateRealUnits

; 2721 : void UpdateRealUnits (CampaignTime deltatime){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateRealUnits@@YAXK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2722 : 	// Update all real units
; 2723 : 	//START_PROFILE("CA UPD REAL LOCK");
; 2724 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2725 : 	//STOP_PROFILE("CA UPD REAL LOCK");
; 2726 : 
; 2727 : 	VuListIterator	rit(AllRealList);

	mov	eax, DWORD PTR ?AllRealList@@3PAVVuLinkedList@@A ; AllRealList
	push	eax
	lea	ecx, DWORD PTR _rit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2728 : 
; 2729 : 	for (UnitClass *u = (UnitClass*)rit.GetFirst(), *next= NULL; u != NULL; u = next){

	lea	ecx, DWORD PTR _rit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$4[ebp], eax
	mov	DWORD PTR _next$3[ebp], 0
	jmp	SHORT $LN9@UpdateReal
$LN8@UpdateReal:
	mov	ecx, DWORD PTR _next$3[ebp]
	mov	DWORD PTR _u$4[ebp], ecx
$LN9@UpdateReal:
	cmp	DWORD PTR _u$4[ebp], 0
	je	$LN7@UpdateReal

; 2730 : 		next = static_cast<UnitClass*>(rit.GetNext());		

	lea	ecx, DWORD PTR _rit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _next$3[ebp], eax

; 2731 : 		if (u && u->Inactive()){

	cmp	DWORD PTR _u$4[ebp], 0
	je	SHORT $LN6@UpdateReal
	mov	ecx, DWORD PTR _u$4[ebp]
	call	?Inactive@UnitClass@@QBEHXZ		; UnitClass::Inactive
	test	eax, eax
	je	SHORT $LN6@UpdateReal

; 2732 : 			//START_PROFILE("CA UPD REAL INACTIVATE");
; 2733 : 			InactivateUnit(u);

	mov	edx, DWORD PTR _u$4[ebp]
	push	edx
	call	?InactivateUnit@@YAXPAVUnitClass@@@Z	; InactivateUnit
	add	esp, 4
	jmp	SHORT $LN5@UpdateReal
$LN6@UpdateReal:

; 2734 : 			//STOP_PROFILE("CA UPD REAL INACTIVATE");
; 2735 : 		}		
; 2736 : 		else if (u && u->IsDead()){

	cmp	DWORD PTR _u$4[ebp], 0
	je	SHORT $LN4@UpdateReal
	mov	eax, DWORD PTR _u$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$4[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	je	SHORT $LN4@UpdateReal

; 2737 : 			//START_PROFILE("CA UPD REAL DEAD");
; 2738 : 			// wait a bit before removing
; 2739 : 			const unsigned int REAL_DEATH_TIMEOUT_MS =		240000/*7200000*/;	

	mov	DWORD PTR _REAL_DEATH_TIMEOUT_MS$2[ebp], 240000 ; 0003a980H

; 2740 : 			if (TheCampaign.CurrentTime - u->GetLastCheck() > REAL_DEATH_TIMEOUT_MS){

	mov	ecx, DWORD PTR _u$4[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, eax
	cmp	ecx, 240000				; 0003a980H
	jbe	SHORT $LN3@UpdateReal

; 2741 : 				vuDatabase->Remove(u);

	mov	edx, DWORD PTR _u$4[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
$LN3@UpdateReal:

; 2742 : 			}
; 2743 : 			//STOP_PROFILE("CA UPD REAL DEAD");
; 2744 : 		}
; 2745 : 		else {

	jmp	SHORT $LN5@UpdateReal
$LN4@UpdateReal:

; 2746 : 			//START_PROFILE("CA UPD REAL UNIT");
; 2747 : 			if (u)

	cmp	DWORD PTR _u$4[ebp], 0
	je	SHORT $LN5@UpdateReal

; 2748 : 				UpdateUnit(u,deltatime);

	mov	eax, DWORD PTR _deltatime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$4[ebp]
	push	ecx
	call	?UpdateUnit@@YAHPAVUnitClass@@K@Z	; UpdateUnit
	add	esp, 8
$LN5@UpdateReal:

; 2749 : 			//STOP_PROFILE("CA UPD REAL UNIT");
; 2750 : 		}
; 2751 : 	}

	jmp	$LN8@UpdateReal
$LN7@UpdateReal:

; 2752 : 	
; 2753 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2754 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _rit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UpdateRealUnits@@YAXK@Z$0:
	lea	ecx, DWORD PTR _rit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?UpdateRealUnits@@YAXK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateRealUnits@@YAXK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateRealUnits@@YAXK@Z ENDP				; UpdateRealUnits
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_pit$ = -32						; size = 12
_next$ = -20						; size = 4
_u$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_deltatime$ = 8						; size = 4
?UpdateParentUnits@@YAXK@Z PROC				; UpdateParentUnits

; 2691 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateParentUnits@@YAXK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2692 : 	// Update parent units
; 2693 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2694 : 	VuListIterator pit(AllParentList);

	mov	eax, DWORD PTR ?AllParentList@@3PAVVuLinkedList@@A ; AllParentList
	push	eax
	lea	ecx, DWORD PTR _pit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2695 : 	Unit u, next;
; 2696 : 	for (u = (Unit) pit.GetFirst();u != NULL;u = next){

	lea	ecx, DWORD PTR _pit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
	jmp	SHORT $LN10@UpdatePare
$LN9@UpdatePare:
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _u$[ebp], ecx
$LN10@UpdatePare:
	cmp	DWORD PTR _u$[ebp], 0
	je	$LN8@UpdatePare

; 2697 : 		next = (Unit) pit.GetNext();

	lea	ecx, DWORD PTR _pit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _next$[ebp], eax

; 2698 : 		if (u->Father()){

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+504]
	call	edx
	test	eax, eax
	je	SHORT $LN7@UpdatePare

; 2699 : 			if (u->Inactive()){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Inactive@UnitClass@@QBEHXZ		; UnitClass::Inactive
	test	eax, eax
	je	SHORT $LN6@UpdatePare

; 2700 : 				InactivateUnit(u);

	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?InactivateUnit@@YAXPAVUnitClass@@@Z	; InactivateUnit
	add	esp, 4
	jmp	SHORT $LN5@UpdatePare
$LN6@UpdatePare:

; 2701 : 			}			
; 2702 : 			else if (u->IsDead()){

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	je	SHORT $LN4@UpdatePare

; 2703 : 				// wait a bit before removing
; 2704 : 				#define PARENT_DEATH_TIMEOUT_MS 240000/*7200000*/
; 2705 : 				if (TheCampaign.CurrentTime - u->GetLastCheck() > PARENT_DEATH_TIMEOUT_MS){

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, eax
	cmp	ecx, 240000				; 0003a980H
	jbe	SHORT $LN3@UpdatePare

; 2706 : 					vuDatabase->Remove(u);

	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
$LN3@UpdatePare:

; 2707 : 				}
; 2708 : 				#undef PARENT_DEATH_TIMEOUT_MS
; 2709 : 			}
; 2710 : 			else {

	jmp	SHORT $LN5@UpdatePare
$LN4@UpdatePare:

; 2711 : 				UpdateUnit(u,deltatime);

	mov	eax, DWORD PTR _deltatime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?UpdateUnit@@YAHPAVUnitClass@@K@Z	; UpdateUnit
	add	esp, 8
$LN5@UpdatePare:

; 2712 : 			}			
; 2713 : 		}
; 2714 : 		else {

	jmp	SHORT $LN1@UpdatePare
$LN7@UpdatePare:

; 2715 : 			printf("does this happen?");

	push	OFFSET ??_C@_0BC@HCOIBBLE@does?5this?5happen?$DP?$AA@
	call	_printf
	add	esp, 4
$LN1@UpdatePare:

; 2716 : 		}
; 2717 : 	}

	jmp	$LN9@UpdatePare
$LN8@UpdatePare:

; 2718 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2719 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UpdateParentUnits@@YAXK@Z$0:
	lea	ecx, DWORD PTR _pit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?UpdateParentUnits@@YAXK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateParentUnits@@YAXK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateParentUnits@@YAXK@Z ENDP				; UpdateParentUnits
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
tv138 = -8						; size = 4
_t$ = -1						; size = 1
_startup$ = 8						; size = 4
?DoCampaignLoop@@YAXH@Z PROC				; DoCampaignLoop

; 2562 : void DoCampaignLoop (int startup){

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2563 : 	static int	stage,lastStage,planCount;
; 2564 : 	Team		t;
; 2565 : 
; 2566 : 	// Calculate our current stage
; 2567 : 	stage = (TheCampaign.CurrentTime % CampaignHours) / (CAMPAIGN_STAGE_TIME_MINUTES*CampaignMinutes);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	xor	edx, edx
	mov	ecx, 3600000				; 0036ee80H
	div	ecx
	mov	eax, edx
	xor	edx, edx
	mov	ecx, 300000				; 000493e0H
	div	ecx
	mov	DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA, eax

; 2568 : 
; 2569 : 	// Keep from skipping stages
; 2570 : 	if (stage > lastStage+1)

	mov	edx, DWORD PTR ?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA
	add	edx, 1
	cmp	DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA, edx
	jle	SHORT $LN43@DoCampaign

; 2571 : 		stage = lastStage+1;

	mov	eax, DWORD PTR ?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA
	add	eax, 1
	mov	DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA, eax
$LN43@DoCampaign:

; 2572 : 	if (stage > STAGE_12)

	cmp	DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA, 12 ; 0000000cH
	jle	SHORT $LN42@DoCampaign

; 2573 : 		stage = STAGE_1;

	mov	DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA, 1
$LN42@DoCampaign:

; 2574 : 
; 2575 : 	if (startup){

	cmp	DWORD PTR _startup$[ebp], 0
	je	$LN41@DoCampaign

; 2576 : 		// Do all items
; 2577 : 		CheckNewDay();

	call	?CheckNewDay@@YAXXZ			; CheckNewDay

; 2578 : 		for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN40@DoCampaign
$LN39@DoCampaign:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN40@DoCampaign:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN38@DoCampaign

; 2579 : 			AddReinforcements(t,1);

	push	1
	movzx	eax, BYTE PTR _t$[ebp]
	push	eax
	call	?AddReinforcements@@YAXEH@Z		; AddReinforcements
	add	esp, 8
	jmp	SHORT $LN39@DoCampaign
$LN38@DoCampaign:

; 2580 : 		UpdateTeamStatistics();

	call	?UpdateTeamStatistics@@YAXXZ		; UpdateTeamStatistics

; 2581 : 		planCount = 100;

	mov	DWORD PTR ?planCount@?1??DoCampaignLoop@@YAXH@Z@4HA, 100 ; 00000064H

; 2582 : 		PlanGroundAndNavalUnits(&planCount);

	push	OFFSET ?planCount@?1??DoCampaignLoop@@YAXH@Z@4HA
	call	?PlanGroundAndNavalUnits@@YAXPAH@Z	; PlanGroundAndNavalUnits
	add	esp, 4

; 2583 : 		OrderGroundAndNavalUnits();

	call	?OrderGroundAndNavalUnits@@YAXXZ	; OrderGroundAndNavalUnits

; 2584 : 		StandardRebuild();

	call	?StandardRebuild@@YAXXZ			; StandardRebuild

; 2585 : 		CheckTriggers(TheCampaign.Scenario);

	push	OFFSET ?TheCampaign@@3VCampaignClass@@A+142
	call	?CheckTriggers@@YAHPAD@Z		; CheckTriggers
	add	esp, 4

; 2586 : 		RebuildATMLists();

	call	?RebuildATMLists@@YAXXZ			; RebuildATMLists

; 2587 : 		for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN37@DoCampaign
$LN36@DoCampaign:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN37@DoCampaign:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN35@DoCampaign

; 2588 : 			TeamInfo[t]->atm->DoCalculations();

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [ecx+876]
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+876]
	mov	eax, DWORD PTR [edx+324]
	call	eax
	jmp	SHORT $LN36@DoCampaign
$LN35@DoCampaign:

; 2589 : 		for (t=1; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 1
	jmp	SHORT $LN34@DoCampaign
$LN33@DoCampaign:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN34@DoCampaign:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN32@DoCampaign

; 2590 : 			TeamInfo[t]->SelectAirActions();

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SelectAirActions@TeamClass@@QAEXXZ	; TeamClass::SelectAirActions
	jmp	SHORT $LN33@DoCampaign
$LN32@DoCampaign:

; 2591 : 		lastStage = stage;

	mov	ecx, DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA
	mov	DWORD PTR ?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA, ecx
$LN41@DoCampaign:

; 2592 : 	}
; 2593 : 
; 2594 : 	// Do any stage actions on change
; 2595 : 	if (stage != lastStage)

	mov	edx, DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA
	cmp	edx, DWORD PTR ?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA
	je	$LN31@DoCampaign

; 2596 : 	{
; 2597 : 		switch (stage)

	mov	eax, DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR tv138[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv138[ebp], ecx
	cmp	DWORD PTR tv138[ebp], 9
	ja	$LN29@DoCampaign
	mov	edx, DWORD PTR tv138[ebp]
	movzx	eax, BYTE PTR $LN46@DoCampaign[edx]
	jmp	DWORD PTR $LN47@DoCampaign[eax*4]
$LN28@DoCampaign:

; 2598 : 		{
; 2599 : 				case STAGE_1:
; 2600 : 						// Check for new day
; 2601 : 						CheckNewDay();

	call	?CheckNewDay@@YAXXZ			; CheckNewDay

; 2602 : 						// Add new reinforcements
; 2603 : 						for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN27@DoCampaign
$LN26@DoCampaign:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN27@DoCampaign:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN25@DoCampaign

; 2604 : 							AddReinforcements(t,1);

	push	1
	movzx	eax, BYTE PTR _t$[ebp]
	push	eax
	call	?AddReinforcements@@YAXEH@Z		; AddReinforcements
	add	esp, 8
	jmp	SHORT $LN26@DoCampaign
$LN25@DoCampaign:

; 2605 : 						// calculate statistics
; 2606 : 						UpdateTeamStatistics();

	call	?UpdateTeamStatistics@@YAXXZ		; UpdateTeamStatistics

; 2607 : 						if (doUI)

	cmp	DWORD PTR ?doUI@@3HA, 0			; doUI
	je	SHORT $LN24@DoCampaign

; 2608 : 							SendMessage(FalconDisplay.appWin,FM_AUTOSAVE_CAMPAIGN,0,game_Campaign);

	push	4
	push	0
	push	1038					; 0000040eH
	mov	ecx, DWORD PTR ?FalconDisplay@@3VFalconDisplayConfiguration@@A+108
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
$LN24@DoCampaign:

; 2609 : 						break;

	jmp	$LN29@DoCampaign
$LN23@DoCampaign:

; 2610 : 				case STAGE_4:
; 2611 : 						// Supply and repair units
; 2612 : 						for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN22@DoCampaign
$LN21@DoCampaign:
	mov	dl, BYTE PTR _t$[ebp]
	add	dl, 1
	mov	BYTE PTR _t$[ebp], dl
$LN22@DoCampaign:
	movzx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 8
	jge	SHORT $LN20@DoCampaign

; 2613 : 							SupplyUnits(t,CampaignHours);

	push	3600000					; 0036ee80H
	movzx	ecx, BYTE PTR _t$[ebp]
	push	ecx
	call	?SupplyUnits@@YAHEK@Z			; SupplyUnits
	add	esp, 8
	jmp	SHORT $LN21@DoCampaign
$LN20@DoCampaign:

; 2614 : 						// Plan ground and naval units
; 2615 : 						PlanGroundAndNavalUnits(&planCount);

	push	OFFSET ?planCount@?1??DoCampaignLoop@@YAXH@Z@4HA
	call	?PlanGroundAndNavalUnits@@YAXPAH@Z	; PlanGroundAndNavalUnits
	add	esp, 4

; 2616 : 						break;

	jmp	SHORT $LN29@DoCampaign
$LN19@DoCampaign:

; 2617 : 				case STAGE_7:
; 2618 : 						// Order ground and naval units
; 2619 : 						OrderGroundAndNavalUnits();

	call	?OrderGroundAndNavalUnits@@YAXXZ	; OrderGroundAndNavalUnits

; 2620 : 						break;

	jmp	SHORT $LN29@DoCampaign
$LN18@DoCampaign:

; 2621 : 				case STAGE_10:
; 2622 : 						// Repair objectives
; 2623 : 						RepairObjectives();

	call	?RepairObjectives@@YAXXZ		; RepairObjectives

; 2624 : 						// Produce supplies
; 2625 : 						ProduceSupplies(CampaignHours);

	push	3600000					; 0036ee80H
	call	?ProduceSupplies@@YAHK@Z		; ProduceSupplies
	add	esp, 4

; 2626 : 						// Supply and repair units
; 2627 : 						for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN17@DoCampaign
$LN16@DoCampaign:
	mov	dl, BYTE PTR _t$[ebp]
	add	dl, 1
	mov	BYTE PTR _t$[ebp], dl
$LN17@DoCampaign:
	movzx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 8
	jge	SHORT $LN29@DoCampaign

; 2628 : 							SupplyUnits(t,CampaignHours);

	push	3600000					; 0036ee80H
	movzx	ecx, BYTE PTR _t$[ebp]
	push	ecx
	call	?SupplyUnits@@YAHEK@Z			; SupplyUnits
	add	esp, 8
	jmp	SHORT $LN16@DoCampaign
$LN29@DoCampaign:

; 2629 : 						break;
; 2630 : 				default:
; 2631 : 						break;
; 2632 : 		}
; 2633 : 
; 2634 : 		// Rebuild lists
; 2635 : 		StandardRebuild();

	call	?StandardRebuild@@YAXXZ			; StandardRebuild

; 2636 : 
; 2637 : 		// Check Triggers
; 2638 : 		CheckTriggers(TheCampaign.Scenario);

	push	OFFSET ?TheCampaign@@3VCampaignClass@@A+142
	call	?CheckTriggers@@YAHPAD@Z		; CheckTriggers
	add	esp, 4

; 2639 : 
; 2640 : 		// Plan Air
; 2641 : 		RebuildATMLists();

	call	?RebuildATMLists@@YAXXZ			; RebuildATMLists

; 2642 : 		for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN13@DoCampaign
$LN12@DoCampaign:
	mov	dl, BYTE PTR _t$[ebp]
	add	dl, 1
	mov	BYTE PTR _t$[ebp], dl
$LN13@DoCampaign:
	movzx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 8
	jge	SHORT $LN11@DoCampaign

; 2643 : 		{
; 2644 : 			if (TeamInfo[t])

	movzx	ecx, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN10@DoCampaign

; 2645 : 			{
; 2646 : 				TeamInfo[t]->atm->DoCalculations();

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR [eax+876]
	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+876]
	mov	eax, DWORD PTR [edx+324]
	call	eax
$LN10@DoCampaign:

; 2647 : 			}
; 2648 : 		}

	jmp	SHORT $LN12@DoCampaign
$LN11@DoCampaign:

; 2649 : 		for (t=1; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 1
	jmp	SHORT $LN9@DoCampaign
$LN8@DoCampaign:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN9@DoCampaign:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN7@DoCampaign

; 2650 : 		{
; 2651 : 			if (TeamInfo[t])

	movzx	eax, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN6@DoCampaign

; 2652 : 			{
; 2653 : 				TeamInfo[t]->SelectAirActions();

	movzx	ecx, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SelectAirActions@TeamClass@@QAEXXZ	; TeamClass::SelectAirActions
$LN6@DoCampaign:

; 2654 : 			}
; 2655 : 		}

	jmp	SHORT $LN8@DoCampaign
$LN7@DoCampaign:

; 2656 : 
; 2657 : 		// Order parent units
; 2658 : 		UpdateParentUnits(CAMPAIGN_STAGE_TIME_MINUTES*CampaignMinutes);

	push	300000					; 000493e0H
	call	?UpdateParentUnits@@YAXK@Z		; UpdateParentUnits
	add	esp, 4

; 2659 : 
; 2660 : 		lastStage = stage;

	mov	edx, DWORD PTR ?stage@?1??DoCampaignLoop@@YAXH@Z@4HA
	mov	DWORD PTR ?lastStage@?1??DoCampaignLoop@@YAXH@Z@4HA, edx
$LN31@DoCampaign:

; 2661 : 	}
; 2662 : 
; 2663 : 	// Check any pending divert missions
; 2664 : 	CheckDivertStatus (DIVERT_NO_DIVERT);

	push	0
	call	?CheckDivertStatus@@YAHH@Z		; CheckDivertStatus
	add	esp, 4

; 2665 : 
; 2666 : 	// Update weather when in UI
; 2667 : 	if (!SimDriver.InSim()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?InSim@SimulationDriver@@QBE_NXZ	; SimulationDriver::InSim
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@DoCampaign

; 2668 : 		((WeatherClass*)realWeather)->UpdateWeather();						// Sim calls this otherwise

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?UpdateWeather@WeatherClass@@QAEXXZ	; WeatherClass::UpdateWeather
$LN5@DoCampaign:

; 2669 : 	}
; 2670 : 
; 2671 : 	// Task air
; 2672 : 	for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN4@DoCampaign
$LN3@DoCampaign:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN4@DoCampaign:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN44@DoCampaign

; 2673 : 	{
; 2674 : 		if (TeamInfo[t] && TeamInfo[t]->atm){

	movzx	eax, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN1@DoCampaign
	movzx	ecx, BYTE PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	cmp	DWORD PTR [edx+876], 0
	je	SHORT $LN1@DoCampaign

; 2675 : 			TeamInfo[t]->atm->Task();

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [ecx+876]
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+876]
	mov	eax, DWORD PTR [edx+320]
	call	eax
$LN1@DoCampaign:

; 2676 : 		}
; 2677 : 	}

	jmp	SHORT $LN3@DoCampaign
$LN44@DoCampaign:

; 2678 : 
; 2679 : #ifdef DEBUG
; 2680 : 	CheckForCheatFlight(TheCampaign.CurrentTime);
; 2681 : #endif
; 2682 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@DoCampaign:
	DD	$LN28@DoCampaign
	DD	$LN23@DoCampaign
	DD	$LN19@DoCampaign
	DD	$LN18@DoCampaign
	DD	$LN29@DoCampaign
$LN46@DoCampaign:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	3
?DoCampaignLoop@@YAXH@Z ENDP				; DoCampaignLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
_t$ = -1						; size = 1
_startup$ = 8						; size = 4
?DoTacticalLoop@@YAXH@Z PROC				; DoTacticalLoop

; 2483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2484 : 	static int			stage,lastStage;
; 2485 : 	static CampaignTime	lastCheck;
; 2486 : 	Team		t;
; 2487 : 
; 2488 : 	// Calculate our current stage
; 2489 : 	stage = (TheCampaign.CurrentTime % CampaignHours) / (CAMPAIGN_STAGE_TIME_MINUTES*CampaignMinutes);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	xor	edx, edx
	mov	ecx, 3600000				; 0036ee80H
	div	ecx
	mov	eax, edx
	xor	edx, edx
	mov	ecx, 300000				; 000493e0H
	div	ecx
	mov	DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA, eax

; 2490 : 
; 2491 : 	// Keep from skipping stages
; 2492 : 	if (stage > lastStage+1)

	mov	edx, DWORD PTR ?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA
	add	edx, 1
	cmp	DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA, edx
	jle	SHORT $LN15@DoTactical

; 2493 : 		stage = lastStage+1;

	mov	eax, DWORD PTR ?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA
	add	eax, 1
	mov	DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA, eax
$LN15@DoTactical:

; 2494 : 	if (stage > STAGE_12)

	cmp	DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA, 12 ; 0000000cH
	jle	SHORT $LN14@DoTactical

; 2495 : 		stage = STAGE_1;

	mov	DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA, 1
$LN14@DoTactical:

; 2496 : 
; 2497 : 	if (startup)

	cmp	DWORD PTR _startup$[ebp], 0
	je	SHORT $LN13@DoTactical

; 2498 : 	{
; 2499 : 		// Do all items
; 2500 : 		CheckNewDay();

	call	?CheckNewDay@@YAXXZ			; CheckNewDay

; 2501 : 		UpdateTeamStatistics();

	call	?UpdateTeamStatistics@@YAXXZ		; UpdateTeamStatistics

; 2502 : 		RepairObjectives();

	call	?RepairObjectives@@YAXXZ		; RepairObjectives

; 2503 : 		StandardRebuild();

	call	?StandardRebuild@@YAXXZ			; StandardRebuild

; 2504 : 		lastStage = stage;

	mov	ecx, DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA
	mov	DWORD PTR ?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA, ecx

; 2505 : 		lastCheck = 0;

	mov	DWORD PTR ?lastCheck@?1??DoTacticalLoop@@YAXH@Z@4KA, 0
$LN13@DoTactical:

; 2506 : 	}
; 2507 : 
; 2508 : 	// Victory check
; 2509 : 	if ((TheCampaign.CurrentTime - lastCheck) > static_cast<CampaignTime>(VICTORY_CHECK_TIME*CampaignSeconds))

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	edx, DWORD PTR ?lastCheck@?1??DoTacticalLoop@@YAXH@Z@4KA
	movsx	eax, WORD PTR ?VICTORY_CHECK_TIME@@3FA	; VICTORY_CHECK_TIME
	imul	eax, 1000				; 000003e8H
	cmp	edx, eax
	jbe	SHORT $LN12@DoTactical

; 2510 : 	{
; 2511 : 		CheckForVictory();

	call	?CheckForVictory@@YAXXZ			; CheckForVictory

; 2512 : 		lastCheck = TheCampaign.CurrentTime;

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR ?lastCheck@?1??DoTacticalLoop@@YAXH@Z@4KA, ecx
$LN12@DoTactical:

; 2513 : 	}
; 2514 : 
; 2515 : 	// Do any stage actions on change
; 2516 : 	if (stage != lastStage)

	mov	edx, DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA
	cmp	edx, DWORD PTR ?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA
	je	$LN11@DoTactical

; 2517 : 	{
; 2518 : 		switch (stage)

	mov	eax, DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA
	mov	DWORD PTR tv76[ebp], eax
	cmp	DWORD PTR tv76[ebp], 1
	je	SHORT $LN8@DoTactical
	cmp	DWORD PTR tv76[ebp], 10			; 0000000aH
	je	SHORT $LN7@DoTactical
	jmp	SHORT $LN9@DoTactical
$LN8@DoTactical:

; 2519 : 		{
; 2520 : 				case STAGE_1:
; 2521 : 						// Check for new day
; 2522 : 						CheckNewDay();

	call	?CheckNewDay@@YAXXZ			; CheckNewDay

; 2523 : 						// calculate statistics
; 2524 : 						UpdateTeamStatistics();

	call	?UpdateTeamStatistics@@YAXXZ		; UpdateTeamStatistics

; 2525 : 						break;

	jmp	SHORT $LN9@DoTactical
$LN7@DoTactical:

; 2526 : 				case STAGE_10:
; 2527 : 						// Repair objectives
; 2528 : 						RepairObjectives();

	call	?RepairObjectives@@YAXXZ		; RepairObjectives
$LN9@DoTactical:

; 2529 : 						break;
; 2530 : 				default:
; 2531 : 						break;
; 2532 : 		}
; 2533 : 
; 2534 : 		// Rebuild lists
; 2535 : 		StandardRebuild();

	call	?StandardRebuild@@YAXXZ			; StandardRebuild

; 2536 : 
; 2537 : 		RebuildATMLists();

	call	?RebuildATMLists@@YAXXZ			; RebuildATMLists

; 2538 : 		for (t=0; t<NUM_TEAMS; t++){

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN5@DoTactical
$LN4@DoTactical:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN5@DoTactical:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	SHORT $LN3@DoTactical

; 2539 : 			// sfr: check vu state... 
; 2540 : 			if (TeamInfo[t] && TeamInfo[t]->VuState() == VU_MEM_ACTIVE){

	movzx	eax, BYTE PTR _t$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN2@DoTactical
	movzx	ecx, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	jne	SHORT $LN2@DoTactical

; 2541 : 				TeamInfo[t]->atm->DoCalculations();

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR [eax+876]
	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+876]
	mov	eax, DWORD PTR [edx+324]
	call	eax
$LN2@DoTactical:

; 2542 : 			}
; 2543 : 		}

	jmp	SHORT $LN4@DoTactical
$LN3@DoTactical:

; 2544 : 
; 2545 : 		// Rally units (2 times as fast as normal = 4 * 5 = 20 minutes)
; 2546 : 		RallyUnits(REGAIN_RATE_MULTIPLIER_FOR_TE * CAMPAIGN_STAGE_TIME_MINUTES);

	movsx	ecx, WORD PTR ?REGAIN_RATE_MULTIPLIER_FOR_TE@@3FA ; REGAIN_RATE_MULTIPLIER_FOR_TE
	imul	ecx, 5
	push	ecx
	call	?RallyUnits@@YAXH@Z			; RallyUnits
	add	esp, 4

; 2547 : 
; 2548 : 		lastStage = stage;

	mov	edx, DWORD PTR ?stage@?1??DoTacticalLoop@@YAXH@Z@4HA
	mov	DWORD PTR ?lastStage@?1??DoTacticalLoop@@YAXH@Z@4HA, edx
$LN11@DoTactical:

; 2549 : 	}
; 2550 : 
; 2551 : 	// Update weather when in UI
; 2552 : 	if (!SimDriver.InSim())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?InSim@SimulationDriver@@QBE_NXZ	; SimulationDriver::InSim
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@DoTactical

; 2553 : 		((WeatherClass*)realWeather)->UpdateWeather();						// Sim calls this otherwise

	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?UpdateWeather@WeatherClass@@QAEXXZ	; WeatherClass::UpdateWeather
$LN16@DoTactical:

; 2554 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTacticalLoop@@YAXH@Z ENDP				; DoTacticalLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?ResumeTacticalEngagement@@YAXXZ PROC			; ResumeTacticalEngagement

; 2853 : {

	push	ebp
	mov	ebp, esp

; 2854 : 	TheCampaign.Flags &= ~CAMP_TACTICAL_PAUSE;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, -262145				; fffbffffH
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, eax

; 2855 : }

	pop	ebp
	ret	0
?ResumeTacticalEngagement@@YAXXZ ENDP			; ResumeTacticalEngagement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\uicomms.h
;	COMDAT ?Online@UIComms@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Online@UIComms@@QAEHXZ PROC				; UIComms::Online, COMDAT
; _this$ = ecx

; 118  : 		BOOL Online()					{ return(Online_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Online@UIComms@@QAEHXZ ENDP				; UIComms::Online
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ PROC		; C_Handler::GetAppWnd, COMDAT
; _this$ = ecx

; 244  : 		HWND GetAppWnd() { return(AppWindow_);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ ENDP		; C_Handler::GetAppWnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?SetDrawFlag@C_Handler@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?SetDrawFlag@C_Handler@@QAEXJ@Z PROC			; C_Handler::SetDrawFlag, COMDAT
; _this$ = ecx

; 218  : 		void SetDrawFlag(long val) { DrawFlags=val; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+3476], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDrawFlag@C_Handler@@QAEXJ@Z ENDP			; C_Handler::SetDrawFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?InSim@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InSim@SimulationDriver@@QBE_NXZ PROC			; SimulationDriver::InSim, COMDAT
; _this$ = ecx

; 51   : 	bool InSim() const                 { return SimulationLoopControl::InSim(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	call	?InSim@SimulationLoopControl@@SA_NXZ	; SimulationLoopControl::InSim
	mov	esp, ebp
	pop	ebp
	ret	0
?InSim@SimulationDriver@@QBE_NXZ ENDP			; SimulationDriver::InSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ratio$ = 8						; size = 4
?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z PROC	; FalconSessionEntity::SetBubbleRatio, COMDAT
; _this$ = ecx

; 182  : 	void SetBubbleRatio (float ratio)	{ bubbleRatio = ratio;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ratio$[ebp]
	movss	DWORD PTR [eax+496], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z ENDP	; FalconSessionEntity::SetBubbleRatio
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetBubbleRatio@FalconSessionEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBubbleRatio@FalconSessionEntity@@QBEMXZ PROC	; FalconSessionEntity::GetBubbleRatio, COMDAT
; _this$ = ecx

; 149  : 	float GetBubbleRatio (void) const             { return bubbleRatio; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+496]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBubbleRatio@FalconSessionEntity@@QBEMXZ ENDP	; FalconSessionEntity::GetBubbleRatio
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetFlyState@FalconSessionEntity@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlyState@FalconSessionEntity@@QBEEXZ PROC		; FalconSessionEntity::GetFlyState, COMDAT
; _this$ = ecx

; 147  : 	uchar GetFlyState (void) const                { return flyState; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+513]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlyState@FalconSessionEntity@@QBEEXZ ENDP		; FalconSessionEntity::GetFlyState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetAircraftNum@FalconSessionEntity@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAircraftNum@FalconSessionEntity@@QBEEXZ PROC	; FalconSessionEntity::GetAircraftNum, COMDAT
; _this$ = ecx

; 145  : 	uchar GetAircraftNum (void) const             { return aircraftNum; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+511]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAircraftNum@FalconSessionEntity@@QBEEXZ ENDP	; FalconSessionEntity::GetAircraftNum
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ PROC ; FalconSessionEntity::GetPlayerFlight, COMDAT
; _this$ = ecx

; 139  : 	FlightClass* GetPlayerFlight(void) const      { return playerFlightPtr.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 480				; 000001e0H
	call	?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ ; VuBin<FlightClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ENDP ; FalconSessionEntity::GetPlayerFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ PROC	; VuBin<FlightClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ ENDP	; VuBin<FlightClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simloop.h
;	COMDAT ?InSim@SimulationLoopControl@@SA_NXZ
_TEXT	SEGMENT
tv65 = -4						; size = 4
?InSim@SimulationLoopControl@@SA_NXZ PROC		; SimulationLoopControl::InSim, COMDAT

; 27   : 	static bool InSim(void)			{ return currentMode == RunningGraphics; }

	push	ebp
	mov	ebp, esp
	push	ecx
	cmp	DWORD PTR ?currentMode@SimulationLoopControl@@1W4SimLoopControlMode@1@A, 6 ; SimulationLoopControl::currentMode
	jne	SHORT $LN3@InSim
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@InSim
$LN3@InSim:
	mov	DWORD PTR tv65[ebp], 0
$LN4@InSim:
	mov	al, BYTE PTR tv65[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?InSim@SimulationLoopControl@@SA_NXZ ENDP		; SimulationLoopControl::InSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsAwake@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 177  : 	int IsAwake() const { return localFlags & OBJ_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ PROC ; PlayerOptionsClass::GetStartFlag, COMDAT
; _this$ = ecx

; 201  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	jl	SHORT $LN2@GetStartFl
	cmp	DWORD PTR tv65[ebp], 2
	jle	SHORT $LN1@GetStartFl
	jmp	SHORT $LN2@GetStartFl
$LN1@GetStartFl:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	jmp	SHORT $LN4@GetStartFl
$LN2@GetStartFl:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	xor	eax, eax
$LN4@GetStartFl:

; 210  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ENDP ; PlayerOptionsClass::GetStartFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\threadmgr.h
;	COMDAT ?campaign_active@ThreadManager@@SAHXZ
_TEXT	SEGMENT
?campaign_active@ThreadManager@@SAHXZ PROC		; ThreadManager::campaign_active, COMDAT

; 40   : 	static BOOL campaign_active (void){ return campaign_thread.status & THREAD_STATUS_ACTIVE; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campaign_thread@ThreadManager@@0UThreadInfo@@A+4
	and	eax, 1
	pop	ebp
	ret	0
?campaign_active@ThreadManager@@SAHXZ ENDP		; ThreadManager::campaign_active
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\flight.h
;	COMDAT ?GetEvalFlags@FlightClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEvalFlags@FlightClass@@QAEEXZ PROC			; FlightClass::GetEvalFlags, COMDAT
; _this$ = ecx

; 104  : 		uchar GetEvalFlags (void)					{ return eval_flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+382]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEvalFlags@FlightClass@@QAEEXZ ENDP			; FlightClass::GetEvalFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC	; UnitClass::GetFirstUnitWP, COMDAT
; _this$ = ecx

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP	; UnitClass::GetFirstUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Final@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Final@UnitClass@@QBEHXZ PROC				; UnitClass::Final, COMDAT
; _this$ = ecx

; 330  : 	int Final () const								{ return (int)unit_flags & U_FINAL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1048576				; 00100000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Final@UnitClass@@QBEHXZ ENDP				; UnitClass::Final
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Inactive@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Inactive@UnitClass@@QBEHXZ PROC			; UnitClass::Inactive, COMDAT
; _this$ = ecx

; 323  : 	int Inactive () const								{ return (int)unit_flags & U_INACTIVE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 131072				; 00020000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Inactive@UnitClass@@QBEHXZ ENDP			; UnitClass::Inactive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Aborted@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Aborted@UnitClass@@QBEHXZ PROC				; UnitClass::Aborted, COMDAT
; _this$ = ecx

; 321  : 	int Aborted () const								{ return (int)unit_flags & U_BROKEN; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32768				; 00008000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Aborted@UnitClass@@QBEHXZ ENDP				; UnitClass::Aborted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Scripted@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Scripted@UnitClass@@QBEHXZ PROC			; UnitClass::Scripted, COMDAT
; _this$ = ecx

; 314  : 	int Scripted ()	 const							{ return (int)unit_flags & U_SCRIPTED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 256				; 00000100H
	mov	esp, ebp
	pop	ebp
	ret	0
?Scripted@UnitClass@@QBEHXZ ENDP			; UnitClass::Scripted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Engaged@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Engaged@UnitClass@@QBEHXZ PROC				; UnitClass::Engaged, COMDAT
; _this$ = ecx

; 313  : 	int Engaged() const								{ return (int)unit_flags & U_ENGAGED; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 64					; 00000040H
	mov	esp, ebp
	pop	ebp
	ret	0
?Engaged@UnitClass@@QBEHXZ ENDP				; UnitClass::Engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastCheck@UnitClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastCheck@UnitClass@@QAEKXZ PROC			; UnitClass::GetLastCheck, COMDAT
; _this$ = ecx

; 146  : 	CampaignTime GetLastCheck (void)	{ return last_check; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastCheck@UnitClass@@QAEKXZ ENDP			; UnitClass::GetLastCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?NumLinks@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumLinks@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::NumLinks, COMDAT
; _this$ = ecx

; 268  : 	int NumLinks(void)										{	return static_data.links; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+225]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumLinks@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::NumLinks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetNeighborId@ObjectiveClass@@QAE?AVVU_ID@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
?GetNeighborId@ObjectiveClass@@QAE?AVVU_ID@@H@Z PROC	; ObjectiveClass::GetNeighborId, COMDAT
; _this$ = ecx

; 259  : 	VU_ID GetNeighborId (int n)								{	return link_data[n].id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	ecx, DWORD PTR [edx+eax+8]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
?GetNeighborId@ObjectiveClass@@QAE?AVVU_ID@@H@Z ENDP	; ObjectiveClass::GetNeighborId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\atcbrain.h
;	COMDAT ?MinDeagTime@ATCBrain@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinDeagTime@ATCBrain@@QAEKXZ PROC			; ATCBrain::MinDeagTime, COMDAT
; _this$ = ecx

; 185  : 	ulong				MinDeagTime(void)				{return minDeagTime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?MinDeagTime@ATCBrain@@QAEKXZ ENDP			; ATCBrain::MinDeagTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?UnsetInterest@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnsetInterest@CampBaseClass@@QAEXXZ PROC		; CampBaseClass::UnsetInterest, COMDAT
; _this$ = ecx

; 309  : 	void UnsetInterest (void)					{	local_flags &= ~CBC_INTEREST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetInterest@CampBaseClass@@QAEXXZ ENDP		; CampBaseClass::UnsetInterest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?SetInterest@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetInterest@CampBaseClass@@QAEXXZ PROC			; CampBaseClass::SetInterest, COMDAT
; _this$ = ecx

; 308  : 	void SetInterest (void)						{	local_flags |= CBC_INTEREST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetInterest@CampBaseClass@@QAEXXZ ENDP			; CampBaseClass::SetInterest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?UnsetChecked@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnsetChecked@CampBaseClass@@QAEXXZ PROC		; CampBaseClass::UnsetChecked, COMDAT
; _this$ = ecx

; 307  : 	void UnsetChecked (void)					{	local_flags &= ~CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetChecked@CampBaseClass@@QAEXXZ ENDP		; CampBaseClass::UnsetChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?SetChecked@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetChecked@CampBaseClass@@QAEXXZ PROC			; CampBaseClass::SetChecked, COMDAT
; _this$ = ecx

; 306  : 	void SetChecked (void)						{	local_flags |= CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetChecked@CampBaseClass@@QAEXXZ ENDP			; CampBaseClass::SetChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsInterested@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInterested@CampBaseClass@@QAEHXZ PROC		; CampBaseClass::IsInterested, COMDAT
; _this$ = ecx

; 276  : 	int IsInterested (void)						{	return local_flags & CBC_INTEREST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 32					; 00000020H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsInterested@CampBaseClass@@QAEHXZ ENDP		; CampBaseClass::IsInterested
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAwake@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 273  : 	int IsAwake (void)							{	return local_flags & CBC_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsChecked@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsChecked@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsChecked, COMDAT
; _this$ = ecx

; 272  : 	int IsChecked (void)						{	return local_flags & CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsChecked@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ PROC	; CampBaseClass::GetDeagOwner, COMDAT
; _this$ = ecx

; 142  : 	VU_ID GetDeagOwner() const					{	return deag_owner; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ENDP	; CampBaseClass::GetDeagOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\cmpclass.h
;	COMDAT ?IsSuspended@CampaignClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSuspended@CampaignClass@@QAEHXZ PROC			; CampaignClass::IsSuspended, COMDAT
; _this$ = ecx

; 179  : 	int IsSuspended (void)									{ return Flags & CAMP_SUSPENDED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	and	eax, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSuspended@CampaignClass@@QAEHXZ ENDP			; CampaignClass::IsSuspended
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPArrivalTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPArrivalTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPArrivalTime, COMDAT
; _this$ = ecx

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPArrivalTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPArrivalTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?CampaignAllAsleep@@YAHXZ PROC				; CampaignAllAsleep

; 1278 : {

	push	ebp
	mov	ebp, esp

; 1279 : 	return 1 - sCampaignSleepRequested;

	mov	eax, 1
	sub	eax, DWORD PTR _sCampaignSleepRequested

; 1280 : }

	pop	ebp
	ret	0
?CampaignAllAsleep@@YAHXZ ENDP				; CampaignAllAsleep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?CampaignRequestSleep@@YAXXZ PROC			; CampaignRequestSleep

; 1269 : {

	push	ebp
	mov	ebp, esp

; 1270 : 	// This critical section wouldn't be necessary if it
; 1271 : 	// wasn't for the simloop shutdown thread.
; 1272 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 1273 : 	sCampaignSleepRequested = 1;

	mov	DWORD PTR _sCampaignSleepRequested, 1

; 1274 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 1275 : }

	pop	ebp
	ret	0
?CampaignRequestSleep@@YAXXZ ENDP			; CampaignRequestSleep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_str_len$ = -12						; size = 4
_offset$ = -8						; size = 4
_index$ = -4						; size = 4
?EndWriteCampFile@@YAXXZ PROC				; EndWriteCampFile

; 1627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1628 : 	int
; 1629 : 			str_len,
; 1630 : 			index,
; 1631 : 			offset;
; 1632 : 
; 1633 : 	if (camp_fp)

	cmp	DWORD PTR _camp_fp, 0
	je	$LN4@EndWriteCa

; 1634 : 	{
; 1635 : 		// MonoPrint ("Writing Campressed File\n");
; 1636 : 
; 1637 : 		fseek (camp_fp, 0, 2);

	push	2
	push	0
	mov	eax, DWORD PTR _camp_fp
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1638 : 
; 1639 : 		offset = ftell (camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _offset$[ebp], eax

; 1640 : 
; 1641 : 		fseek (camp_fp, 0, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _camp_fp
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1642 : 
; 1643 : 		fwrite (&offset, sizeof (int), 1, camp_fp);

	mov	eax, DWORD PTR _camp_fp
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 1644 : 
; 1645 : 		fseek (camp_fp, offset, 0);

	push	0
	mov	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _camp_fp
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1646 : 
; 1647 : 		fwrite (&camp_num_files, 4, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	push	4
	push	OFFSET _camp_num_files
	call	_fwrite
	add	esp, 16					; 00000010H

; 1648 : 
; 1649 : 		for (index = 0; index < camp_num_files; index ++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN3@EndWriteCa
$LN2@EndWriteCa:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN3@EndWriteCa:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _camp_num_files
	jge	$LN1@EndWriteCa

; 1650 : 		{
; 1651 : 			str_len = strlen (camp_names[index]);

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 255				; 000000ffH
	add	ecx, OFFSET _camp_names
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _str_len$[ebp], eax

; 1652 : 
; 1653 : 			fwrite (&str_len, 1, 1, camp_fp);

	mov	edx, DWORD PTR _camp_fp
	push	edx
	push	1
	push	1
	lea	eax, DWORD PTR _str_len$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 1654 : 
; 1655 : 			fwrite (camp_names[index], str_len, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	mov	edx, DWORD PTR _str_len$[ebp]
	push	edx
	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 255				; 000000ffH
	add	eax, OFFSET _camp_names
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 1656 : 
; 1657 : 			fwrite (&camp_offset[index], 4, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	push	4
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR _camp_offset[edx*4]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 1658 : 
; 1659 : 			fwrite (&camp_size[index], 4, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	push	4
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR _camp_size[edx*4]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 1660 : 
; 1661 : 			// MonoPrint ("  %s %d %d\n", camp_names[index], camp_offset[index], camp_size[index]);
; 1662 : 		}

	jmp	$LN2@EndWriteCa
$LN1@EndWriteCa:

; 1663 : 
; 1664 : 		fclose (camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	call	_fclose
	add	esp, 4

; 1665 : 
; 1666 : 		camp_fp = NULL;

	mov	DWORD PTR _camp_fp, 0
$LN4@EndWriteCa:

; 1667 : 	}
; 1668 : 
; 1669 : 	writing_campressed_file = FALSE;

	mov	DWORD PTR _writing_campressed_file, 0

; 1670 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndWriteCampFile@@YAXXZ ENDP				; EndWriteCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_filename$ = 12						; size = 4
?StartWriteCampFile@@YAXW4FalconGameType@@PAD@Z PROC	; StartWriteCampFile

; 1591 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1592 : 	char
; 1593 : 			path[MAX_PATH];
; 1594 : 
; 1595 : 	writing_campressed_file = TRUE;

	mov	DWORD PTR _writing_campressed_file, 1

; 1596 : 
; 1597 : 	if (type == game_TacticalEngagement)

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN4@StartWrite

; 1598 : 	{
; 1599 : 		sprintf (path, "%s\\%s.tac", FalconCampUserSaveDirectory, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	push	OFFSET ??_C@_09PDPMBAAN@?$CFs?2?$CFs?4tac?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1600 : 	}
; 1601 : 	else

	jmp	SHORT $LN3@StartWrite
$LN4@StartWrite:

; 1602 : 	{
; 1603 : 		sprintf (path, "%s\\%s.cam", FalconCampUserSaveDirectory, filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	push	OFFSET ??_C@_09KALBFCKF@?$CFs?2?$CFs?4cam?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN3@StartWrite:

; 1604 : 	}
; 1605 : 
; 1606 : 	camp_fp = fopen (path, "wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _camp_fp, eax

; 1607 : 
; 1608 : 	if (camp_fp)

	cmp	DWORD PTR _camp_fp, 0
	je	SHORT $LN2@StartWrite

; 1609 : 	{
; 1610 : 		camp_num_files = 0;

	mov	DWORD PTR _camp_num_files, 0

; 1611 : 
; 1612 : 		fwrite (&camp_num_files, sizeof (int), 1, camp_fp);

	mov	edx, DWORD PTR _camp_fp
	push	edx
	push	1
	push	4
	push	OFFSET _camp_num_files
	call	_fwrite
	add	esp, 16					; 00000010H

; 1613 : 	}
; 1614 : 	else

	jmp	SHORT $LN5@StartWrite
$LN2@StartWrite:

; 1615 : 	{
; 1616 : 		MonoPrint ("Cannot Open %s\n", path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@LLHKKLJD@Cannot?5Open?5?$CFs?6?$AA@
	call	_MonoPrint
	add	esp, 8
$LN5@StartWrite:

; 1617 : 
; 1618 : 		ShiWarning ("Cannot Open Campressed File\n");
; 1619 : 	}
; 1620 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?StartWriteCampFile@@YAXW4FalconGameType@@PAD@Z ENDP	; StartWriteCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?EndReadCampFile@@YAXXZ PROC				; EndReadCampFile

; 1573 : {

	push	ebp
	mov	ebp, esp

; 1574 : 	if (camp_fp)

	cmp	DWORD PTR _camp_fp, 0
	je	SHORT $LN1@EndReadCam

; 1575 : 	{
; 1576 : 		fclose (camp_fp);

	mov	eax, DWORD PTR _camp_fp
	push	eax
	call	_fclose
	add	esp, 4

; 1577 : 
; 1578 : 		camp_fp = NULL;

	mov	DWORD PTR _camp_fp, 0

; 1579 : 
; 1580 : 		camp_num_files = 0;

	mov	DWORD PTR _camp_num_files, 0
$LN1@EndReadCam:

; 1581 : 	}
; 1582 : 
; 1583 : 	reading_campressed_file = FALSE;

	mov	DWORD PTR _reading_campressed_file, 0

; 1584 : }

	pop	ebp
	ret	0
?EndReadCampFile@@YAXXZ ENDP				; EndReadCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
$T1 = -292						; size = 4
$T2 = -288						; size = 4
_size$ = -284						; size = 4
_fp$ = -280						; size = 4
_index$ = -276						; size = 4
_cd$ = -272						; size = 8
_buffer$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_ext$ = 12						; size = 4
?ReadCampFile@@YA?AUCampaignData@@PAD0@Z PROC		; ReadCampFile

; 1516 : CampaignData ReadCampFile (char *filename, char *ext){

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1517 : 	int	size, index;
; 1518 : 
; 1519 : 	CampaignData cd = {-1, NULL};

	mov	DWORD PTR _cd$[ebp], -1
	mov	DWORD PTR _cd$[ebp+4], 0

; 1520 : 	char /* *data,*/	buffer[MAX_PATH];
; 1521 : 
; 1522 : 	FILE *fp;
; 1523 : 
; 1524 : 	if (reading_campressed_file) {

	cmp	DWORD PTR _reading_campressed_file, 0
	je	$LN8@ReadCampFi

; 1525 : 		if ((strcmp (filename, camp_file_name) != 0) && IsCampFile(camp_game_type,filename)) {

	push	OFFSET _camp_file_name
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@ReadCampFi
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camp_game_type
	push	edx
	call	?IsCampFile@@YAHW4FalconGameType@@PAD@Z	; IsCampFile
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@ReadCampFi

; 1526 : 			EndReadCampFile ();

	call	?EndReadCampFile@@YAXXZ			; EndReadCampFile

; 1527 : 			StartReadCampFile (camp_game_type, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camp_game_type
	push	ecx
	call	?StartReadCampFile@@YAXW4FalconGameType@@PAD@Z ; StartReadCampFile
	add	esp, 8
$LN7@ReadCampFi:

; 1528 : 			ShiAssert (reading_campressed_file);
; 1529 : 		}
; 1530 : 		strcpy (buffer, filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1531 : 		strcat (buffer, ".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1532 : 		strcat (buffer, ext);

	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1533 : 
; 1534 : 		for (index = 0; index < camp_num_files; index ++) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN6@ReadCampFi
$LN5@ReadCampFi:
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
$LN6@ReadCampFi:
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _camp_num_files
	jge	$LN4@ReadCampFi

; 1535 : 			if (string_compare_extensions (buffer, camp_names[index]) == 0)	{

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 255				; 000000ffH
	add	eax, OFFSET _camp_names
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?string_compare_extensions@@YAHPAD0@Z	; string_compare_extensions
	add	esp, 8
	test	eax, eax
	jne	$LN3@ReadCampFi

; 1536 : 				fseek (camp_fp, camp_offset[index], 0);

	push	0
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _camp_offset[edx*4]
	push	eax
	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1537 : 				cd.dataSize = camp_size[index]+1;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _camp_size[edx*4]
	add	eax, 1
	mov	DWORD PTR _cd$[ebp], eax

; 1538 : 				cd.data = new char [cd.dataSize];

	mov	ecx, DWORD PTR _cd$[ebp]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _cd$[ebp+4], edx

; 1539 : 				fread(cd.data, camp_size[index], 1, camp_fp);

	mov	eax, DWORD PTR _camp_fp
	push	eax
	push	1
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _camp_size[ecx*4]
	push	edx
	mov	eax, DWORD PTR _cd$[ebp+4]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1540 : 				cd.data[camp_size[index]] = 0;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _camp_size[ecx*4]
	mov	eax, DWORD PTR _cd$[ebp+4]
	mov	BYTE PTR [eax+edx], 0

; 1541 : 				return cd;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR _cd$[ebp+4]
	jmp	$LN9@ReadCampFi
$LN3@ReadCampFi:

; 1542 : 			}
; 1543 : 		}

	jmp	$LN5@ReadCampFi
$LN4@ReadCampFi:

; 1544 : 
; 1545 : 		reading_campressed_file = FALSE;

	mov	DWORD PTR _reading_campressed_file, 0

; 1546 : 		fp = OpenCampFile (filename, ext, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1547 : 		reading_campressed_file = TRUE;

	mov	DWORD PTR _reading_campressed_file, 1

; 1548 : 	}
; 1549 : 	else {

	jmp	SHORT $LN2@ReadCampFi
$LN8@ReadCampFi:

; 1550 : 		fp = OpenCampFile (filename, ext, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
$LN2@ReadCampFi:

; 1551 : 	}
; 1552 : 
; 1553 : 	if (fp) {

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN1@ReadCampFi

; 1554 : 		fseek (fp, 0, 2);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1555 : 		size = ftell (fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1556 : 		fseek (fp, 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1557 : 		cd.dataSize = size+1;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 1
	mov	DWORD PTR _cd$[ebp], edx

; 1558 : 		cd.data = new char [cd.dataSize];

	mov	eax, DWORD PTR _cd$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _cd$[ebp+4], ecx

; 1559 : 		fread (cd.data, size, 1, fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cd$[ebp+4]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 1560 : 		cd.data[size] = 0;

	mov	edx, DWORD PTR _cd$[ebp+4]
	add	edx, DWORD PTR _size$[ebp]
	mov	BYTE PTR [edx], 0

; 1561 : 		fclose (fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1562 : 		return cd;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR _cd$[ebp+4]
	jmp	SHORT $LN9@ReadCampFi
$LN1@ReadCampFi:

; 1563 : 	}
; 1564 : 	return cd;

	mov	eax, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR _cd$[ebp+4]
$LN9@ReadCampFi:

; 1565 : 	//	return NULL;
; 1566 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadCampFile@@YA?AUCampaignData@@PAD0@Z ENDP		; ReadCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_offset$ = -276						; size = 4
_str_len$ = -272					; size = 4
_index$ = -268						; size = 4
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_filename$ = 12						; size = 4
?StartReadCampFile@@YAXW4FalconGameType@@PAD@Z PROC	; StartReadCampFile

; 1453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1454 : 	int
; 1455 : 			index,
; 1456 : 			str_len,
; 1457 : 			offset;
; 1458 : 
; 1459 : 	char
; 1460 : 			path[MAX_PATH];
; 1461 : 
; 1462 : 	if (reading_campressed_file)

	cmp	DWORD PTR _reading_campressed_file, 0
	je	SHORT $LN6@StartReadC

; 1463 : 	{
; 1464 : 		MonoPrint ("Already Reading Campressed File\n");

	push	OFFSET ??_C@_0CB@HFIHGAB@Already?5Reading?5Campressed?5File?6@
	call	_MonoPrint
	add	esp, 4

; 1465 : 		ShiAssert (!reading_campressed_file);
; 1466 : 		return;

	jmp	$LN7@StartReadC
$LN6@StartReadC:

; 1467 : 	}
; 1468 : 
; 1469 : 	reading_campressed_file = TRUE;

	mov	DWORD PTR _reading_campressed_file, 1

; 1470 : 
; 1471 : 	GetCampFilePath(type,filename,path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	?GetCampFilePath@@YAXW4FalconGameType@@PAD1@Z ; GetCampFilePath
	add	esp, 12					; 0000000cH

; 1472 : 
; 1473 : 	camp_game_type = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _camp_game_type, eax

; 1474 : 	strcpy(camp_file_name,filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET _camp_file_name
	call	_strcpy
	add	esp, 8

; 1475 : 
; 1476 : 	camp_fp = fopen (path, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _camp_fp, eax

; 1477 : 
; 1478 : 	if (camp_fp)

	cmp	DWORD PTR _camp_fp, 0
	je	$LN5@StartReadC

; 1479 : 	{
; 1480 : 		// MonoPrint ("Opening Campressed File %s\n", path);
; 1481 : 
; 1482 : 		fread (&offset, 4, 1, camp_fp);

	mov	eax, DWORD PTR _camp_fp
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 1483 : 
; 1484 : 		fseek (camp_fp, offset, 0);

	push	0
	mov	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _camp_fp
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1485 : 
; 1486 : 		fread (&camp_num_files, 4, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	push	4
	push	OFFSET _camp_num_files
	call	_fread
	add	esp, 16					; 00000010H

; 1487 : 
; 1488 : 		for (index = 0; index < camp_num_files; index ++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@StartReadC
$LN3@StartReadC:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN4@StartReadC:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _camp_num_files
	jge	$LN2@StartReadC

; 1489 : 		{
; 1490 : 			fread (&str_len, 1, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	push	1
	lea	edx, DWORD PTR _str_len$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1491 : 
; 1492 : 			str_len &= 0xff;

	mov	eax, DWORD PTR _str_len$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _str_len$[ebp], eax

; 1493 : 
; 1494 : 			fread (camp_names[index], str_len, 1, camp_fp);

	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	push	1
	mov	edx, DWORD PTR _str_len$[ebp]
	push	edx
	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 255				; 000000ffH
	add	eax, OFFSET _camp_names
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1495 : 
; 1496 : 			camp_names[index][str_len] = 0;

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _str_len$[ebp]
	mov	BYTE PTR _camp_names[ecx+edx], 0

; 1497 : 
; 1498 : 			fread (&camp_offset[index], 4, 1, camp_fp);

	mov	eax, DWORD PTR _camp_fp
	push	eax
	push	1
	push	4
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR _camp_offset[ecx*4]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1499 : 
; 1500 : 			fread (&camp_size[index], 4, 1, camp_fp);

	mov	eax, DWORD PTR _camp_fp
	push	eax
	push	1
	push	4
	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR _camp_size[ecx*4]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1501 : 
; 1502 : 			// MonoPrint ("  %s %d %d\n", camp_names[index], camp_offset[index], camp_size[index]);
; 1503 : 		}

	jmp	$LN3@StartReadC
$LN2@StartReadC:

; 1504 : 	}
; 1505 : 	else

	jmp	SHORT $LN7@StartReadC
$LN5@StartReadC:

; 1506 : 	{
; 1507 : 		MonoPrint ("Cannot Open %s\n", path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@LLHKKLJD@Cannot?5Open?5?$CFs?6?$AA@
	call	_MonoPrint
	add	esp, 8
$LN7@StartReadC:

; 1508 : 
; 1509 : 		ShiWarning ("Cannot Open Campressed File\n");
; 1510 : 	}
; 1511 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?StartReadCampFile@@YAXW4FalconGameType@@PAD@Z ENDP	; StartReadCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_index$ = -4						; size = 4
_fp$ = 8						; size = 4
?CloseCampFile@@YAXPAU_iobuf@@@Z PROC			; CloseCampFile

; 1843 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1844 : 	int
; 1845 : 			index;
; 1846 : 
; 1847 : 	for (index = 0; index < MAX_WCH_FILES; index ++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN10@CloseCampF
$LN9@CloseCampF:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN10@CloseCampF:
	cmp	DWORD PTR _index$[ebp], 4
	jge	SHORT $LN8@CloseCampF

; 1848 : 	{
; 1849 : 		if (fp == wch_fp[index])

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _fp$[ebp]
	cmp	edx, DWORD PTR _wch_fp[ecx*4]
	jne	SHORT $LN7@CloseCampF

; 1850 : 		{
; 1851 : 			// do nothing - we want to keep this file open...
; 1852 : 			// MonoPrint ("Keeping WCH File %s.wch\n", wch_filename);
; 1853 : 			return;

	jmp	SHORT $LN11@CloseCampF
$LN7@CloseCampF:

; 1854 : 		}
; 1855 : 	}

	jmp	SHORT $LN9@CloseCampF
$LN8@CloseCampF:

; 1856 : 
; 1857 : 	if (fp == camp_fp)

	mov	eax, DWORD PTR _fp$[ebp]
	cmp	eax, DWORD PTR _camp_fp
	jne	SHORT $LN6@CloseCampF

; 1858 : 	{
; 1859 : 		if (writing_campressed_file)

	cmp	DWORD PTR _writing_campressed_file, 0
	je	SHORT $LN4@CloseCampF

; 1860 : 		{
; 1861 : 			fseek (camp_fp, 0, 2);

	push	2
	push	0
	mov	ecx, DWORD PTR _camp_fp
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1862 : 
; 1863 : 			camp_size[camp_num_files] = ftell (camp_fp) - camp_offset[camp_num_files];

	mov	edx, DWORD PTR _camp_fp
	push	edx
	call	_ftell
	add	esp, 4
	mov	ecx, DWORD PTR _camp_num_files
	sub	eax, DWORD PTR _camp_offset[ecx*4]
	mov	edx, DWORD PTR _camp_num_files
	mov	DWORD PTR _camp_size[edx*4], eax

; 1864 : 
; 1865 : 			camp_num_files ++;

	mov	eax, DWORD PTR _camp_num_files
	add	eax, 1
	mov	DWORD PTR _camp_num_files, eax
$LN4@CloseCampF:

; 1866 : 		}
; 1867 : 		else if (reading_campressed_file)
; 1868 : 		{
; 1869 : 		}
; 1870 : 	}
; 1871 : 	else

	jmp	SHORT $LN11@CloseCampF
$LN6@CloseCampF:

; 1872 : 	{
; 1873 : 		if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN11@CloseCampF

; 1874 : 		{
; 1875 : 			fclose (fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN11@CloseCampF:

; 1876 : 		}
; 1877 : 	}
; 1878 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseCampFile@@YAXPAU_iobuf@@@Z ENDP			; CloseCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_fp$ = -268						; size = 4
_fullname$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_path$ = 12						; size = 4
?CreateCampFile@@YAHPAD0@Z PROC				; CreateCampFile

; 1311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1312 : 	char	fullname[MAX_PATH];
; 1313 : 	FILE*	fp;
; 1314 : 
; 1315 : 	// This filename doesn't exist yet (At least res manager doesn't think so)
; 1316 : 	// Create it, so that the manager can find it -
; 1317 : 	sprintf(fullname,"%s\\%s",path,filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	edx, DWORD PTR _fullname$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1318 : 	fp = fopen(fullname, "wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	lea	eax, DWORD PTR _fullname$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1319 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1320 : 	// Now add the current save directory path, if we still can't find this file
; 1321 : 	//	if (!ResExistFile(filename))
; 1322 : 	//		ResAddPath(path, FALSE);
; 1323 : 	return 1;

	mov	eax, 1

; 1324 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCampFile@@YAHPAD0@Z ENDP				; CreateCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?TimeOfDay@@YAKXZ PROC					; TimeOfDay

; 409  : {

	push	ebp
	mov	ebp, esp

; 410  : 	return TheCampaign.TimeOfDay;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+12

; 411  : }

	pop	ebp
	ret	0
?TimeOfDay@@YAKXZ ENDP					; TimeOfDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
?TimeOfDayGeneral@@YAHXZ PROC				; TimeOfDayGeneral

; 404  : {

	push	ebp
	mov	ebp, esp

; 405  : 	return TimeOfDayGeneral(TheCampaign.TimeOfDay);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+12
	push	eax
	call	?TimeOfDayGeneral@@YAHK@Z		; TimeOfDayGeneral
	add	esp, 4

; 406  : }

	pop	ebp
	ret	0
?TimeOfDayGeneral@@YAHXZ ENDP				; TimeOfDayGeneral
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_time$ = 8						; size = 4
?TimeOfDayGeneral@@YAHK@Z PROC				; TimeOfDayGeneral

; 364  : {

	push	ebp
	mov	ebp, esp

; 365  : 	// 2001-04-10 MODIFIED BY S.G. SO IT USES MILISECOND AND NOT MINUTES! 
; 366  : 	//I COULD CHANGE THE .H FILE BUT IT WOULD TAKE TOO LONG TO RECOMPILE :-(
; 367  : 	/*	if (time < TOD_SUNUP)
; 368  : 		return TOD_NIGHT;
; 369  : 		else if (time < TOD_SUNUP + 120*CampaignMinutes)
; 370  : 		return TOD_DAWNDUSK;
; 371  : 		else if (time < TOD_SUNDOWN - 120*CampaignMinutes)
; 372  : 		return TOD_DAY;
; 373  : 		else if (time < TOD_SUNDOWN)
; 374  : 		return TOD_DAWNDUSK;
; 375  : 		else
; 376  : 		return TOD_NIGHT;
; 377  : 	 */
; 378  : 	// time can be over one day so I need to keep just the time in the current day...
; 379  : 	
; 380  : 	//Cobra We get called a lot and we are expensive.  Nothing needs this immediately
; 381  : 	static SIM_ULONG timer = 0;
; 382  : 	static long tod = 0;
; 383  : 
; 384  : 	if ((timer == 0) || (SimLibElapsedTime > (SIM_ULONG)timer)){

	cmp	DWORD PTR ?timer@?1??TimeOfDayGeneral@@YAHK@Z@4KA, 0
	je	SHORT $LN9@TimeOfDayG
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR ?timer@?1??TimeOfDayGeneral@@YAHK@Z@4KA
	jbe	SHORT $LN10@TimeOfDayG
$LN9@TimeOfDayG:

; 385  : 		tod = time % CampaignDay;

	mov	eax, DWORD PTR _time$[ebp]
	xor	edx, edx
	mov	ecx, 86400000				; 05265c00H
	div	ecx
	mov	DWORD PTR ?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA, edx

; 386  : 		timer = SimLibElapsedTime + 900000;//15 minutes

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 900000				; 000dbba0H
	mov	DWORD PTR ?timer@?1??TimeOfDayGeneral@@YAHK@Z@4KA, edx
$LN10@TimeOfDayG:

; 387  : 	}
; 388  : 
; 389  : 	//time = time % CampaignDay;
; 390  : 	//Cobra changed time to tod
; 391  : 	if (tod < TOD_SUNUP*CampaignMinutes)

	cmp	DWORD PTR ?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA, 18000000 ; 0112a880H
	jge	SHORT $LN8@TimeOfDayG

; 392  : 		return TOD_NIGHT;

	mov	eax, 1
	jmp	SHORT $LN11@TimeOfDayG
	jmp	SHORT $LN11@TimeOfDayG
$LN8@TimeOfDayG:

; 393  : 	else if (tod < TOD_SUNUP*CampaignMinutes + 120*CampaignMinutes)

	cmp	DWORD PTR ?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA, 25200000 ; 01808580H
	jge	SHORT $LN6@TimeOfDayG

; 394  : 		return TOD_DAWNDUSK;

	mov	eax, 2
	jmp	SHORT $LN11@TimeOfDayG
	jmp	SHORT $LN11@TimeOfDayG
$LN6@TimeOfDayG:

; 395  : 	else if (tod < TOD_SUNDOWN*CampaignMinutes - 120*CampaignMinutes)

	cmp	DWORD PTR ?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA, 68400000 ; 0413b380H
	jge	SHORT $LN4@TimeOfDayG

; 396  : 		return TOD_DAY;

	mov	eax, 3
	jmp	SHORT $LN11@TimeOfDayG
	jmp	SHORT $LN11@TimeOfDayG
$LN4@TimeOfDayG:

; 397  : 	else if (tod < TOD_SUNDOWN*CampaignMinutes)

	cmp	DWORD PTR ?tod@?1??TimeOfDayGeneral@@YAHK@Z@4JA, 75600000 ; 04819080H
	jge	SHORT $LN2@TimeOfDayG

; 398  : 		return TOD_DAWNDUSK;

	mov	eax, 2
	jmp	SHORT $LN11@TimeOfDayG

; 399  : 	else

	jmp	SHORT $LN11@TimeOfDayG
$LN2@TimeOfDayG:

; 400  : 		return TOD_NIGHT;

	mov	eax, 1
$LN11@TimeOfDayG:

; 401  : }

	pop	ebp
	ret	0
?TimeOfDayGeneral@@YAHK@Z ENDP				; TimeOfDayGeneral
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_u$ = 8							; size = 4
?RemoveUnit@@YAXPAVUnitClass@@@Z PROC			; RemoveUnit

; 355  : {

	push	ebp
	mov	ebp, esp

; 356  : 	u->Remove();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Remove@CampBaseClass@@QAEHXZ		; CampBaseClass::Remove

; 357  : }

	pop	ebp
	ret	0
?RemoveUnit@@YAXPAVUnitClass@@@Z ENDP			; RemoveUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_nu$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
_Side$ = 16						; size = 1
?AddUnit@@YAPAVUnitClass@@FFD@Z PROC			; AddUnit

; 343  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 344  : 	Unit        nu;
; 345  : 
; 346  : 	nu = NewUnit(DOMAIN_LAND, TYPE_BRIGADE, STYPE_UNIT_ARMOR, 1, NULL);

	push	0
	push	1
	push	3
	push	2
	push	3
	call	?NewUnit@@YAPAVUnitClass@@HHHHPAV1@@Z	; NewUnit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _nu$[ebp], eax

; 347  : 	nu->SetOwner(Side);

	movzx	eax, BYTE PTR _Side$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _nu$[ebp]
	mov	eax, DWORD PTR [edx+320]
	call	eax

; 348  : 	nu->ResetLocations(x,y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?ResetLocations@UnitClass@@QAEXFF@Z	; UnitClass::ResetLocations

; 349  : 	nu->ResetDestinations(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?ResetDestinations@UnitClass@@QAEXFF@Z	; UnitClass::ResetDestinations

; 350  : 	nu->SetUnitOrders(GORD_DEFEND);

	push	6
	mov	edx, DWORD PTR _nu$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nu$[ebp]
	mov	edx, DWORD PTR [eax+832]
	call	edx

; 351  : 	return nu;

	mov	eax, DWORD PTR _nu$[ebp]

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddUnit@@YAPAVUnitClass@@FFD@Z ENDP			; AddUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
$T2 = -88						; size = 4
_n$ = -84						; size = 4
_nn$ = -77						; size = 1
_path$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_o$ = 8							; size = 4
?RecalculateLinks@@YAHPAVObjectiveClass@@@Z PROC	; RecalculateLinks

; 324  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 325  : 	PathClass   path;

	lea	ecx, DWORD PTR _path$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 326  : 	Objective	n;
; 327  : 	char        nn;
; 328  : 
; 329  : 	for (nn=0; nn<o->NumLinks(); nn++)

	mov	BYTE PTR _nn$[ebp], 0
	jmp	SHORT $LN4@Recalculat
$LN3@Recalculat:
	mov	al, BYTE PTR _nn$[ebp]
	add	al, 1
	mov	BYTE PTR _nn$[ebp], al
$LN4@Recalculat:
	movsx	esi, BYTE PTR _nn$[ebp]
	mov	ecx, DWORD PTR _o$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	esi, eax
	jge	SHORT $LN2@Recalculat

; 330  : 	{
; 331  : 		n = o->GetNeighbor(nn);

	movsx	ecx, BYTE PTR _nn$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _n$[ebp], eax

; 332  : 		if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN1@Recalculat

; 333  : 			LinkCampaignObjectives(&path, o, n);

	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?LinkCampaignObjectives@@YAHPAVBasePathClass@@PAVObjectiveClass@@1@Z ; LinkCampaignObjectives
	add	esp, 12					; 0000000cH
$LN1@Recalculat:

; 334  : 	}

	jmp	SHORT $LN3@Recalculat
$LN2@Recalculat:

; 335  : 	return 1;

	mov	DWORD PTR $T2[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 336  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z$0:
	lea	ecx, DWORD PTR _path$[ebp]
	jmp	??1PathClass@@QAE@XZ
__ehhandler$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RecalculateLinks@@YAHPAVObjectiveClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RecalculateLinks@@YAHPAVObjectiveClass@@@Z ENDP	; RecalculateLinks
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
$T1 = -40						; size = 8
$T2 = -32						; size = 8
$T3 = -24						; size = 8
$T4 = -16						; size = 8
_unlinked$ = -8						; size = 4
_i$ = -4						; size = 4
_O1$ = 8						; size = 4
_O2$ = 12						; size = 4
?UnLinkCampaignObjectives@@YAHPAVObjectiveClass@@0@Z PROC ; UnLinkCampaignObjectives

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 302  : 	int        i,unlinked=0;

	mov	DWORD PTR _unlinked$[ebp], 0

; 303  : 
; 304  : 	for (i=0; i<O1->NumLinks(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@UnLinkCamp
$LN7@UnLinkCamp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@UnLinkCamp:
	mov	ecx, DWORD PTR _O1$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN6@UnLinkCamp

; 305  : 	{
; 306  : 		if (O1->GetNeighborId(i) == O2->Id())

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _O2$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _O1$[ebp]
	call	?GetNeighborId@ObjectiveClass@@QAE?AVVU_ID@@H@Z ; ObjectiveClass::GetNeighborId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@UnLinkCamp

; 307  : 		{
; 308  : 			O1->RemoveObjectiveNeighbor(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _O1$[ebp]
	call	?RemoveObjectiveNeighbor@ObjectiveClass@@QAEXH@Z ; ObjectiveClass::RemoveObjectiveNeighbor

; 309  : 			unlinked = 1;

	mov	DWORD PTR _unlinked$[ebp], 1
$LN5@UnLinkCamp:

; 310  : 		}
; 311  : 	}

	jmp	SHORT $LN7@UnLinkCamp
$LN6@UnLinkCamp:

; 312  : 	for (i=0; i<O2->NumLinks(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@UnLinkCamp
$LN3@UnLinkCamp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@UnLinkCamp:
	mov	ecx, DWORD PTR _O2$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN2@UnLinkCamp

; 313  : 	{
; 314  : 		if (O2->GetNeighborId(i) == O1->Id())

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _O1$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _O2$[ebp]
	call	?GetNeighborId@ObjectiveClass@@QAE?AVVU_ID@@H@Z ; ObjectiveClass::GetNeighborId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@UnLinkCamp

; 315  : 		{
; 316  : 			O2->RemoveObjectiveNeighbor(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _O2$[ebp]
	call	?RemoveObjectiveNeighbor@ObjectiveClass@@QAEXH@Z ; ObjectiveClass::RemoveObjectiveNeighbor

; 317  : 			unlinked = 1;

	mov	DWORD PTR _unlinked$[ebp], 1
$LN1@UnLinkCamp:

; 318  : 		}
; 319  : 	}

	jmp	SHORT $LN3@UnLinkCamp
$LN2@UnLinkCamp:

; 320  : 	return unlinked;	

	mov	eax, DWORD PTR _unlinked$[ebp]

; 321  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UnLinkCampaignObjectives@@YAHPAVObjectiveClass@@0@Z ENDP ; UnLinkCampaignObjectives
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_found$ = -32						; size = 4
_y$ = -28						; size = 2
_x$ = -24						; size = 2
_cost$ = -20						; size = 4
_i$ = -16						; size = 4
_costs$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
_O1$ = 12						; size = 4
_O2$ = 16						; size = 4
?LinkCampaignObjectives@@YAHPAVBasePathClass@@PAVObjectiveClass@@1@Z PROC ; LinkCampaignObjectives

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 256  : 	int	        i=0,cost=0,found=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _cost$[ebp], 0
	mov	DWORD PTR _found$[ebp], 0

; 257  : 	uchar		costs[MOVEMENT_TYPES]={254};

	mov	BYTE PTR _costs$[ebp], 254		; 000000feH
	xor	eax, eax
	mov	DWORD PTR _costs$[ebp+1], eax
	mov	WORD PTR _costs$[ebp+5], ax
	mov	BYTE PTR _costs$[ebp+7], al

; 258  : 	GridIndex   x=0,y=0;

	xor	ecx, ecx
	mov	WORD PTR _x$[ebp], cx
	xor	edx, edx
	mov	WORD PTR _y$[ebp], dx

; 259  : 
; 260  : 	for (i=0; i<MOVEMENT_TYPES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@LinkCampai
$LN12@LinkCampai:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@LinkCampai:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN11@LinkCampai

; 261  : 	{
; 262  : 		if (FindLinkPath(path, O1,O2,(MoveType)i) < 1)

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _O2$[ebp]
	push	edx
	mov	eax, DWORD PTR _O1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?FindLinkPath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1W4MoveType@@@Z ; FindLinkPath
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jge	SHORT $LN10@LinkCampai

; 263  : 		{
; 264  : 			if (FindLinkPath(path,O2,O1,(MoveType)i) < 1)

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _O1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _O2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	?FindLinkPath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1W4MoveType@@@Z ; FindLinkPath
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jge	SHORT $LN9@LinkCampai

; 265  : 				costs[i] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _costs$[ebp+eax], 255		; 000000ffH

; 266  : 			else

	jmp	SHORT $LN8@LinkCampai
$LN9@LinkCampai:

; 267  : 			{
; 268  : 				O2->GetLocation(&x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _O2$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 269  : 				cost = (FloatToInt32(path->GetCost()) + cost)/2;

	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetCost@BasePathClass@@QAEMXZ		; BasePathClass::GetCost
	push	ecx
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _cost$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _cost$[ebp], eax

; 270  : 				if (cost > 254)

	cmp	DWORD PTR _cost$[ebp], 254		; 000000feH
	jle	SHORT $LN7@LinkCampai

; 271  : 					cost = 254;			// If it's possible to move, but very expensive, mark it as our max movable cost (254)

	mov	DWORD PTR _cost$[ebp], 254		; 000000feH
$LN7@LinkCampai:

; 272  : 				costs[i] = (uchar)cost;

	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _cost$[ebp]
	mov	BYTE PTR _costs$[ebp+eax], cl

; 273  : 				found = 1;

	mov	DWORD PTR _found$[ebp], 1
$LN8@LinkCampai:

; 274  : 			}
; 275  : 		}
; 276  : 		else

	jmp	SHORT $LN6@LinkCampai
$LN10@LinkCampai:

; 277  : 		{
; 278  : 			O1->GetLocation(&x, &y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _O1$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 279  : 			cost = FloatToInt32(path->GetCost());

	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetCost@BasePathClass@@QAEMXZ		; BasePathClass::GetCost
	push	ecx
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _cost$[ebp], eax

; 280  : 			if (cost > 254)

	cmp	DWORD PTR _cost$[ebp], 254		; 000000feH
	jle	SHORT $LN5@LinkCampai

; 281  : 				cost = 254;				// If it's possible to move, but very expensive, mark it as our max movable cost (254)

	mov	DWORD PTR _cost$[ebp], 254		; 000000feH
$LN5@LinkCampai:

; 282  : 			costs[i] = (uchar)cost;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _cost$[ebp]
	mov	BYTE PTR _costs$[ebp+ecx], dl

; 283  : 			found = 1;

	mov	DWORD PTR _found$[ebp], 1
$LN6@LinkCampai:

; 284  : 		}
; 285  : 		// KCK Hack: If we can get there by road, fool it into thinking it's a 254 cost link for
; 286  : 		// any otherwise unfound paths.
; 287  : 		if (costs[i] == 255 && (i == Foot || i == Wheeled || i == Tracked) && costs[NoMove] < 255)

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _costs$[ebp+eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN4@LinkCampai
	cmp	DWORD PTR _i$[ebp], 1
	je	SHORT $LN3@LinkCampai
	cmp	DWORD PTR _i$[ebp], 2
	je	SHORT $LN3@LinkCampai
	cmp	DWORD PTR _i$[ebp], 3
	jne	SHORT $LN4@LinkCampai
$LN3@LinkCampai:
	mov	edx, 1
	imul	edx, 0
	movzx	eax, BYTE PTR _costs$[ebp+edx]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN4@LinkCampai

; 288  : 			costs[i] = 254;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _costs$[ebp+ecx], 254		; 000000feH
$LN4@LinkCampai:

; 289  : 	}

	jmp	$LN12@LinkCampai
$LN11@LinkCampai:

; 290  : 	if (found)

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN2@LinkCampai

; 291  : 	{
; 292  : 		O1->AddObjectiveNeighbor(O2, costs);  

	lea	edx, DWORD PTR _costs$[ebp]
	push	edx
	mov	eax, DWORD PTR _O2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _O1$[ebp]
	call	?AddObjectiveNeighbor@ObjectiveClass@@QAEXPAV1@QAE@Z ; ObjectiveClass::AddObjectiveNeighbor

; 293  : 		O2->AddObjectiveNeighbor(O1, costs);  

	lea	ecx, DWORD PTR _costs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _O1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _O2$[ebp]
	call	?AddObjectiveNeighbor@ObjectiveClass@@QAEXPAV1@QAE@Z ; ObjectiveClass::AddObjectiveNeighbor

; 294  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@LinkCampai

; 295  : 	}
; 296  : 	else

	jmp	SHORT $LN1@LinkCampai
$LN2@LinkCampai:

; 297  : 		return 0;

	xor	eax, eax
$LN1@LinkCampai:

; 298  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LinkCampaignObjectives@@YAHPAVBasePathClass@@PAVObjectiveClass@@1@Z ENDP ; LinkCampaignObjectives
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_theater$ = 8						; size = 4
?SaveTheater@@YAHPAD@Z PROC				; SaveTheater

; 230  : {

	push	ebp
	mov	ebp, esp

; 231  : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 232  : 	SaveTheaterTerrain(theater);

	mov	eax, DWORD PTR _theater$[ebp]
	push	eax
	call	?SaveTheaterTerrain@@YAHPAD@Z		; SaveTheaterTerrain
	add	esp, 4

; 233  : 	SaveNames(theater);

	mov	ecx, DWORD PTR _theater$[ebp]
	push	ecx
	call	?SaveNames@@YAHPAD@Z			; SaveNames
	add	esp, 4

; 234  : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 235  : 	return 1;

	mov	eax, 1

; 236  : }

	pop	ebp
	ret	0
?SaveTheater@@YAHPAD@Z ENDP				; SaveTheater
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_theater$ = 8						; size = 4
?LoadTheater@@YAHPAD@Z PROC				; LoadTheater

; 213  : {

	push	ebp
	mov	ebp, esp

; 214  : 	// This assumes the Class Table was loaded elsewhere
; 215  : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 216  : 	if (!LoadTheaterTerrain(theater))

	mov	eax, DWORD PTR _theater$[ebp]
	push	eax
	call	?LoadTheaterTerrain@@YAHPAD@Z		; LoadTheaterTerrain
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@LoadTheate

; 217  : 	{
; 218  : 		MonoPrint("Failed to open theater: %s, using default theater.\n",theater);

	mov	ecx, DWORD PTR _theater$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DE@JKHCDKNK@Failed?5to?5open?5theater?3?5?$CFs?0?5usin@
	call	_MonoPrint
	add	esp, 8

; 219  : 		Map_Max_X = Map_Max_Y = 500;

	mov	edx, 500				; 000001f4H
	mov	WORD PTR ?Map_Max_Y@@3FA, dx		; Map_Max_Y
	mov	ax, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	mov	WORD PTR ?Map_Max_X@@3FA, ax		; Map_Max_X

; 220  : 		InitTheaterTerrain();

	call	?InitTheaterTerrain@@YAXXZ		; InitTheaterTerrain

; 221  : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 222  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@LoadTheate
$LN1@LoadTheate:

; 223  : 	}
; 224  : 	LoadNames(theater);

	mov	ecx, DWORD PTR _theater$[ebp]
	push	ecx
	call	?LoadNames@@YAXPAD@Z			; LoadNames
	add	esp, 4

; 225  : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 226  : 	return 1;

	mov	eax, 1
$LN2@LoadTheate:

; 227  : }

	pop	ebp
	ret	0
?LoadTheater@@YAHPAD@Z ENDP				; LoadTheater
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_o$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?AddObjectiveToCampaign@@YAPAVObjectiveClass@@FF@Z PROC	; AddObjectiveToCampaign

; 243  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 244  : 	Objective o;
; 245  : 
; 246  : 	o = NewObjective();

	call	?NewObjective@@YAPAVObjectiveClass@@XZ	; NewObjective
	mov	DWORD PTR _o$[ebp], eax

; 247  : 	o->SetLocation(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?SetLocation@CampBaseClass@@QAEXFF@Z	; CampBaseClass::SetLocation

; 248  : 	o->UpdateObjectiveLists();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?UpdateObjectiveLists@ObjectiveClass@@QAEXXZ ; ObjectiveClass::UpdateObjectiveLists

; 249  : 	RebuildObjectiveLists();

	call	?RebuildObjectiveLists@@YAHXZ		; RebuildObjectiveLists

; 250  : 	RebuildParentsList();

	call	?RebuildParentsList@@YAHXZ		; RebuildParentsList

; 251  : 	return o;

	mov	eax, DWORD PTR _o$[ebp]

; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddObjectiveToCampaign@@YAPAVObjectiveClass@@FF@Z ENDP	; AddObjectiveToCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1PathClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathClass@@QAE@XZ PROC				; PathClass::~PathClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BasePathClass@@QAE@XZ		; BasePathClass::~BasePathClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathClass@@QAE@XZ ENDP				; PathClass::~PathClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\asearch.h
;	COMDAT ?GetCost@BasePathClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCost@BasePathClass@@QAEMXZ PROC			; BasePathClass::GetCost, COMDAT
; _this$ = ecx

; 79   : 		costtype GetCost (void)					{ return cost; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCost@BasePathClass@@QAEMXZ ENDP			; BasePathClass::GetCost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campupd\campaign.cpp
_TEXT	SEGMENT
_fp$ = -792						; size = 4
_index$ = -788						; size = 4
_buffer$ = -784						; size = 260
_fullname$ = -524					; size = 260
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_ext$ = 12						; size = 4
_mode$ = 16						; size = 4
?OpenCampFile@@YAPAU_iobuf@@PAD00@Z PROC		; OpenCampFile

; 1677 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 792				; 00000318H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1678 : 	char	fullname[MAX_PATH],path[MAX_PATH];
; 1679 : 	int		index;
; 1680 : 
; 1681 : 	char
; 1682 : 			buffer[MAX_PATH];
; 1683 : 
; 1684 : 	FILE
; 1685 : 			*fp;
; 1686 : 
; 1687 : 	if (strcmp (ext, "wch") == 0)

	push	OFFSET ??_C@_03MPOGCMBA@wch?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN79@OpenCampFi

; 1688 : 	{
; 1689 : 		for (index = 0; index < MAX_WCH_FILES; index ++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN78@OpenCampFi
$LN77@OpenCampFi:
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
$LN78@OpenCampFi:
	cmp	DWORD PTR _index$[ebp], 4
	jge	SHORT $LN79@OpenCampFi

; 1690 : 		{
; 1691 : 			if ((wch_fp[index]) && (strcmp (wch_filename[index], filename) == 0))

	mov	edx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _wch_fp[edx*4], 0
	je	SHORT $LN75@OpenCampFi
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 260				; 00000104H
	add	ecx, OFFSET _wch_filename
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN75@OpenCampFi

; 1692 : 			{
; 1693 : 				fseek (wch_fp[index], 0, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _wch_fp[edx*4]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1694 : 
; 1695 : 				return wch_fp[index];

	mov	ecx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _wch_fp[ecx*4]
	jmp	$LN80@OpenCampFi
$LN75@OpenCampFi:

; 1696 : 			}
; 1697 : 		}

	jmp	SHORT $LN77@OpenCampFi
$LN79@OpenCampFi:

; 1698 : 	}
; 1699 : 
; 1700 : 	sprintf (buffer, "OpenCampFile %s.%s %s\n", filename, ext, mode);

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@JLPBKNLG@OpenCampFile?5?$CFs?4?$CFs?5?$CFs?6?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 1701 : 	// MonoPrint (buffer);
; 1702 : 	// OutputDebugString (buffer);
; 1703 : 
; 1704 : 	// 2002-03-25 MN added check for not being WCH file - otherwise can crash sometimes
; 1705 : 	// especially after theater switching situations !
; 1706 : 	if ((reading_campressed_file) && (mode[0] == 'r') && strcmp (ext, "wch") != 0)

	cmp	DWORD PTR _reading_campressed_file, 0
	je	$LN74@OpenCampFi
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _mode$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 114				; 00000072H
	jne	$LN74@OpenCampFi
	push	OFFSET ??_C@_03MPOGCMBA@wch?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$LN74@OpenCampFi

; 1707 : 	{
; 1708 : 		if (strcmp (filename, camp_file_name) != 0 && IsCampFile(camp_game_type,filename))

	push	OFFSET _camp_file_name
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN73@OpenCampFi
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _camp_game_type
	push	eax
	call	?IsCampFile@@YAHW4FalconGameType@@PAD@Z	; IsCampFile
	add	esp, 8
	test	eax, eax
	je	SHORT $LN73@OpenCampFi

; 1709 : 		{
; 1710 : 			EndReadCampFile ();

	call	?EndReadCampFile@@YAXXZ			; EndReadCampFile

; 1711 : 			StartReadCampFile (camp_game_type, filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camp_game_type
	push	edx
	call	?StartReadCampFile@@YAXW4FalconGameType@@PAD@Z ; StartReadCampFile
	add	esp, 8
$LN73@OpenCampFi:

; 1712 : 			ShiAssert (reading_campressed_file);
; 1713 : 		}
; 1714 : 
; 1715 : 		strcpy (fullname, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1716 : 		strcat (fullname, ".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	lea	edx, DWORD PTR _fullname$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1717 : 		strcat (fullname, ext);

	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1718 : 
; 1719 : 		for (index = 0; index < camp_num_files; index ++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN72@OpenCampFi
$LN71@OpenCampFi:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN72@OpenCampFi:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _camp_num_files
	jge	SHORT $LN74@OpenCampFi

; 1720 : 		{
; 1721 : 			if (string_compare_extensions (fullname, camp_names[index]) == 0)

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 255				; 000000ffH
	add	ecx, OFFSET _camp_names
	push	ecx
	lea	edx, DWORD PTR _fullname$[ebp]
	push	edx
	call	?string_compare_extensions@@YAHPAD0@Z	; string_compare_extensions
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN69@OpenCampFi

; 1722 : 			{
; 1723 : 				fseek (camp_fp, camp_offset[index], 0);

	push	0
	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _camp_offset[eax*4]
	push	ecx
	mov	edx, DWORD PTR _camp_fp
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1724 : 
; 1725 : 				return camp_fp;

	mov	eax, DWORD PTR _camp_fp
	jmp	$LN80@OpenCampFi
$LN69@OpenCampFi:

; 1726 : 			}
; 1727 : 		}

	jmp	SHORT $LN71@OpenCampFi
$LN74@OpenCampFi:

; 1728 : 
; 1729 : 		// MonoPrint ("Cannot OpenCampFile while we are reading a campressed file\n");
; 1730 : 	}
; 1731 : 
; 1732 : 	if ((writing_campressed_file) && (mode[0] == 'w'))

	cmp	DWORD PTR _writing_campressed_file, 0
	je	$LN68@OpenCampFi
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _mode$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 119				; 00000077H
	jne	$LN68@OpenCampFi

; 1733 : 	{
; 1734 : 		strcpy (fullname, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1735 : 		strcat (fullname, ".");

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	lea	edx, DWORD PTR _fullname$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1736 : 		strcat (fullname, ext);

	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1737 : 
; 1738 : 		fseek (camp_fp, 0, 2);

	push	2
	push	0
	mov	edx, DWORD PTR _camp_fp
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1739 : 
; 1740 : 		strcpy (camp_names[camp_num_files], fullname);

	lea	eax, DWORD PTR _fullname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camp_num_files
	imul	ecx, 255				; 000000ffH
	add	ecx, OFFSET _camp_names
	push	ecx
	call	_strcpy
	add	esp, 8

; 1741 : 
; 1742 : 		camp_offset[camp_num_files] = ftell (camp_fp);

	mov	edx, DWORD PTR _camp_fp
	push	edx
	call	_ftell
	add	esp, 4
	mov	ecx, DWORD PTR _camp_num_files
	mov	DWORD PTR _camp_offset[ecx*4], eax

; 1743 : 
; 1744 : 		camp_size[camp_num_files] = 0;

	mov	edx, DWORD PTR _camp_num_files
	mov	DWORD PTR _camp_size[edx*4], 0

; 1745 : 
; 1746 : 		return camp_fp;

	mov	eax, DWORD PTR _camp_fp
	jmp	$LN80@OpenCampFi
$LN68@OpenCampFi:

; 1747 : 	}
; 1748 : 
; 1749 : 	if (strcmp(ext,"cmp") == 0)

	push	OFFSET ??_C@_03JIBIFJIL@cmp?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN67@OpenCampFi

; 1750 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN67@OpenCampFi:

; 1751 : 	else if (stricmp(ext,"obj") == 0)

	push	OFFSET ??_C@_03GJLPFLNF@obj?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN65@OpenCampFi

; 1752 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN65@OpenCampFi:

; 1753 : 	else if (stricmp(ext,"obd") == 0)

	push	OFFSET ??_C@_03PHDMHGFL@obd?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN63@OpenCampFi

; 1754 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN63@OpenCampFi:

; 1755 : 	else if (stricmp(ext,"uni") == 0)

	push	OFFSET ??_C@_03HECMEGIJ@uni?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN61@OpenCampFi

; 1756 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN61@OpenCampFi:

; 1757 : 	else if (stricmp(ext,"tea") == 0)

	push	OFFSET ??_C@_03IBMEEAF@tea?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN59@OpenCampFi

; 1758 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN59@OpenCampFi:

; 1759 : 	else if (stricmp(ext,"wth") == 0)

	push	OFFSET ??_C@_03NGIPJJOF@wth?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@OpenCampFi

; 1760 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN57@OpenCampFi:

; 1761 : 	else if (stricmp(ext,"plt") == 0)

	push	OFFSET ??_C@_03LPBKAOMJ@plt?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN55@OpenCampFi

; 1762 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN55@OpenCampFi:

; 1763 : 	else if (stricmp(ext,"mil") == 0)

	push	OFFSET ??_C@_03JJLJNLDJ@mil?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN53@OpenCampFi

; 1764 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN53@OpenCampFi:

; 1765 : 	else if (stricmp(ext,"tri") == 0)

	push	OFFSET ??_C@_03NJKMHLPI@tri?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN51@OpenCampFi

; 1766 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN51@OpenCampFi:

; 1767 : 	else if (stricmp(ext,"evl") == 0)

	push	OFFSET ??_C@_03ELHHBHJL@evl?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN49@OpenCampFi

; 1768 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN49@OpenCampFi:

; 1769 : 	else if (stricmp(ext,"smd") == 0)

	push	OFFSET ??_C@_03OGKPNJEB@smd?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@OpenCampFi

; 1770 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN47@OpenCampFi:

; 1771 : 	else if (stricmp(ext,"sqd") == 0)

	push	OFFSET ??_C@_03PDJDIDFF@sqd?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@OpenCampFi

; 1772 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN45@OpenCampFi:

; 1773 : 	else if (stricmp(ext,"pol") == 0)

	push	OFFSET ??_C@_03DPEHCIMJ@pol?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN43@OpenCampFi

; 1774 : 		sprintf(path,FalconCampUserSaveDirectory);

	push	OFFSET ?FalconCampUserSaveDirectory@@3PADA ; FalconCampUserSaveDirectory
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN43@OpenCampFi:

; 1775 : 	else if (stricmp(ext,"ct") == 0)

	push	OFFSET ??_C@_02BHMOPGG@ct?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN41@OpenCampFi

; 1776 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN41@OpenCampFi:

; 1777 : 	else if (stricmp(ext,"ini") == 0)

	push	OFFSET ??_C@_03GOODKOKO@ini?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@OpenCampFi

; 1778 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN39@OpenCampFi:

; 1779 : 	else if (stricmp(ext,"ucd") == 0)

	push	OFFSET ??_C@_03MJFKKLJH@ucd?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN37@OpenCampFi

; 1780 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN37@OpenCampFi:

; 1781 : 	else if (stricmp(ext,"ocd") == 0)

	push	OFFSET ??_C@_03PGPOBMGM@ocd?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@OpenCampFi

; 1782 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN35@OpenCampFi:

; 1783 : 	else if (stricmp(ext,"fcd") == 0)

	push	OFFSET ??_C@_03ILPGFDOG@fcd?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@OpenCampFi

; 1784 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN33@OpenCampFi:

; 1785 : 	else if (stricmp(ext,"vcd") == 0)

	push	OFFSET ??_C@_03NLOPAEHJ@vcd?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@OpenCampFi

; 1786 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN31@OpenCampFi:

; 1787 : 	else if (stricmp(ext,"wcd") == 0)

	push	OFFSET ??_C@_03GDFDGDBM@wcd?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@OpenCampFi

; 1788 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN29@OpenCampFi:

; 1789 : 	else if (stricmp(ext,"rcd") == 0)

	push	OFFSET ??_C@_03FEINJDCO@rcd?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@OpenCampFi

; 1790 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN27@OpenCampFi:

; 1791 : 	else if (stricmp(ext,"icd") == 0)

	push	OFFSET ??_C@_03NDJFEDLA@icd?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@OpenCampFi

; 1792 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN25@OpenCampFi:

; 1793 : 	else if (stricmp(ext,"rwd") == 0)

	push	OFFSET ??_C@_03EPKCJIIC@rwd?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@OpenCampFi

; 1794 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN23@OpenCampFi:

; 1795 : 	else if (stricmp(ext,"vsd") == 0)

	push	OFFSET ??_C@_03MHMJKHAJ@vsd?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@OpenCampFi

; 1796 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN21@OpenCampFi:

; 1797 : 	else if (stricmp(ext,"swd") == 0)

	push	OFFSET ??_C@_03PHBOPPOH@swd?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@OpenCampFi

; 1798 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN19@OpenCampFi:

; 1799 : 	else if (stricmp(ext,"acd") == 0)

	push	OFFSET ??_C@_03BGCBGLFP@acd?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@OpenCampFi

; 1800 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN17@OpenCampFi:

; 1801 : 	else if (stricmp(ext,"wld") == 0)

	push	OFFSET ??_C@_03GIAPCECB@wld?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@OpenCampFi

; 1802 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN15@OpenCampFi:

; 1803 : 	else if (stricmp(ext,"phd") == 0)

	push	OFFSET ??_C@_03PCNBLEEE@phd?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@OpenCampFi

; 1804 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN13@OpenCampFi:

; 1805 : 	else if (stricmp(ext,"pd") == 0)

	push	OFFSET ??_C@_02FFNOOABO@pd?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@OpenCampFi

; 1806 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN11@OpenCampFi:

; 1807 : 	else if (stricmp(ext,"fed") == 0)

	push	OFFSET ??_C@_03IPHLCPFE@fed?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@OpenCampFi

; 1808 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	$LN66@OpenCampFi
$LN9@OpenCampFi:

; 1809 : 	else if (stricmp(ext,"ssd") == 0)

	push	OFFSET ??_C@_03PABHFHDL@ssd?$AA@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@OpenCampFi

; 1810 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN66@OpenCampFi
$LN7@OpenCampFi:

; 1811 : 	else if (stricmp(ext,"rkt") == 0)		// 2001-11-05 Added by M.N.

	push	OFFSET ??_C@_03BAFMNAMH@rkt?$AA@
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@OpenCampFi

; 1812 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN66@OpenCampFi
$LN5@OpenCampFi:

; 1813 : 	else if (stricmp(ext,"ddp") == 0)		// 2002-04-20 Added by M.N.

	push	OFFSET ??_C@_03KBOFKLN@ddp?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@OpenCampFi

; 1814 : 		sprintf(path,FalconObjectDataDir);

	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 1815 : 	else

	jmp	SHORT $LN66@OpenCampFi
$LN3@OpenCampFi:

; 1816 : 		sprintf(path,FalconCampaignSaveDirectory);

	push	OFFSET ?FalconCampaignSaveDirectory@@3PADA ; FalconCampaignSaveDirectory
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN66@OpenCampFi:

; 1817 : 
; 1818 : 	//	Outdated by resmgr:
; 1819 : 	//	if (!ResExistFile(filename))
; 1820 : 	//		ResAddPath(path, FALSE);
; 1821 : 
; 1822 : 	sprintf(fullname,"%s\\%s.%s",path,filename,ext);

	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_08IEFAEBKE@?$CFs?2?$CFs?4?$CFs?$AA@
	lea	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 1823 : 	fp = fopen(fullname,mode);

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	lea	eax, DWORD PTR _fullname$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1824 : 
; 1825 : 	if ((fp) && (strcmp (ext, "wch") == 0))

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN1@OpenCampFi
	push	OFFSET ??_C@_03MPOGCMBA@wch?$AA@
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@OpenCampFi

; 1826 : 	{
; 1827 : 		index = next_wch_file ++;

	mov	edx, DWORD PTR _next_wch_file
	mov	DWORD PTR _index$[ebp], edx
	mov	eax, DWORD PTR _next_wch_file
	add	eax, 1
	mov	DWORD PTR _next_wch_file, eax

; 1828 : 
; 1829 : 		F4Assert (next_wch_file <= MAX_WCH_FILES)
; 1830 : 
; 1831 : 				wch_fp[index] = fp;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _fp$[ebp]
	mov	DWORD PTR _wch_fp[ecx*4], edx

; 1832 : 		strcpy (wch_filename[index], filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 260				; 00000104H
	add	ecx, OFFSET _wch_filename
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@OpenCampFi:

; 1833 : 	}
; 1834 : 
; 1835 : 	return fp;

	mov	eax, DWORD PTR _fp$[ebp]
$LN80@OpenCampFi:

; 1836 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?OpenCampFile@@YAPAU_iobuf@@PAD00@Z ENDP		; OpenCampFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetFalcFlag@FalconEntity@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFalcFlag@FalconEntity@@QAEXH@Z PROC			; FalconEntity::SetFalcFlag, COMDAT
; _this$ = ecx

; 110  : 	void SetFalcFlag (int flag)					{ if (!(falconFlags & flag)) {falconFlags |= flag; MakeFlagsDirty();} };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+136]
	and	ecx, DWORD PTR _flag$[ebp]
	jne	SHORT $LN2@SetFalcFla
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+136]
	or	eax, DWORD PTR _flag$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+136], al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeFlagsDirty@FalconEntity@@QAEXXZ	; FalconEntity::MakeFlagsDirty
$LN2@SetFalcFla:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFalcFlag@FalconEntity@@QAEXH@Z ENDP			; FalconEntity::SetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestReliableTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestReliableTransmit@VuMessage@@QAEXXZ PROC		; VuMessage::RequestReliableTransmit, COMDAT
; _this$ = ecx

; 180  : 	void RequestReliableTransmit() { flags_ |= VU_RELIABLE_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestReliableTransmit@VuMessage@@QAEXXZ ENDP		; VuMessage::RequestReliableTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ PROC		; VuEntity::VuState, COMDAT
; _this$ = ecx

; 153  : 	VU_MEM VuState() const    { return vuState_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ ENDP		; VuEntity::VuState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::OwnerId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID OwnerId() const     { return share_.ownerId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::OwnerId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
