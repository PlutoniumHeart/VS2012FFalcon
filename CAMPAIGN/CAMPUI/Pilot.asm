; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUI\Pilot.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?CallsignData@@3PAEA				; CallsignData
PUBLIC	?PilotInfo@@3PAVPilotInfoClass@@A		; PilotInfo
PUBLIC	?NumPilots@@3HA					; NumPilots
PUBLIC	?NumCallsigns@@3HA				; NumCallsigns
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
_BSS	SEGMENT
?CallsignData@@3PAEA DD 01H DUP (?)			; CallsignData
?PilotInfo@@3PAVPilotInfoClass@@A DD 01H DUP (?)	; PilotInfo
?NumPilots@@3HA DD 01H DUP (?)				; NumPilots
?NumCallsigns@@3HA DD 01H DUP (?)			; NumCallsigns
_BSS	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0PilotClass@@QAE@XZ				; PilotClass::PilotClass
PUBLIC	?ResetStats@PilotClass@@QAEXE@Z			; PilotClass::ResetStats
PUBLIC	?SetTEPilotRating@PilotClass@@QAEXE@Z		; PilotClass::SetTEPilotRating
PUBLIC	??0PilotInfoClass@@QAE@XZ			; PilotInfoClass::PilotInfoClass
PUBLIC	?ResetStats@PilotInfoClass@@QAEXXZ		; PilotInfoClass::ResetStats
PUBLIC	?AssignVoice@PilotInfoClass@@QAEXH@Z		; PilotInfoClass::AssignVoice
PUBLIC	?NewPilotInfo@@YAXXZ				; NewPilotInfo
PUBLIC	?LoadPilotInfo@@YAHPAD@Z			; LoadPilotInfo
PUBLIC	?SavePilotInfo@@YAXPAD@Z			; SavePilotInfo
PUBLIC	?DisposePilotInfo@@YAXXZ			; DisposePilotInfo
PUBLIC	?GetAvailablePilot@@YAHHHH@Z			; GetAvailablePilot
PUBLIC	?GetPilotName@@YAXHPADH@Z			; GetPilotName
PUBLIC	?GetCallsignID@@YAXPAE0H@Z			; GetCallsignID
PUBLIC	?SetCallsignID@@YAXHH@Z				; SetCallsignID
PUBLIC	?UnsetCallsignID@@YAXHH@Z			; UnsetCallsignID
PUBLIC	?GetCallsign@@YAXHHPAD@Z			; GetCallsign
PUBLIC	?GetCallsign@@YAXPAVFlightClass@@PAD@Z		; GetCallsign
PUBLIC	?GetDogfightCallsign@@YAXPAVFlightClass@@@Z	; GetDogfightCallsign
PUBLIC	??_C@_03LPBKAOMJ@plt?$AA@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BM@BBAHDPDH@Flight?5?$CF08x?5Callsign?5?$CFd?3?$CFd?6?$AA@ ; `string'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_fwrite:PROC
EXTRN	_sprintf:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_MonoPrint:PROC
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	?CloseCampFile@@YAXPAU_iobuf@@@Z:PROC		; CloseCampFile
EXTRN	?ReadCampFile@@YA?AUCampaignData@@PAD0@Z:PROC	; ReadCampFile
EXTRN	?GetVehicleID@UnitClass@@QAEFH@Z:PROC		; UnitClass::GetVehicleID
EXTRN	?ReadIndexedString@@YAXHPADH@Z:PROC		; ReadIndexedString
EXTRN	?PickVoice@VoiceMapper@@QAEHHH@Z:PROC		; VoiceMapper::PickVoice
EXTRN	?AssignUIImageID@@YAEE@Z:PROC			; AssignUIImageID
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?gCampDataVersion@@3HA:DWORD			; gCampDataVersion
EXTRN	?g_voicemap@@3VVoiceMapper@@A:QWORD		; g_voicemap
EXTRN	?calltable@@3PAY04EA:BYTE			; calltable
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_0BM@BBAHDPDH@Flight?5?$CF08x?5Callsign?5?$CFd?3?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@BBAHDPDH@Flight?5?$CF08x?5Callsign?5?$CFd?3?$CFd?6?$AA@ DB 'Fli'
	DB	'ght %08x Callsign %d:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LPBKAOMJ@plt?$AA@
CONST	SEGMENT
??_C@_03LPBKAOMJ@plt?$AA@ DB 'plt', 00H			; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?LoadPilotInfo@@YAHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadPilotInfo@@YAHPAD@Z$0
__unwindtable$?NewPilotInfo@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewPilotInfo@@YAXXZ$0
__ehfuncinfo$?LoadPilotInfo@@YAHPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadPilotInfo@@YAHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?NewPilotInfo@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NewPilotInfo@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_checkid$ = -12						; size = 4
_i$ = -8						; size = 4
_num$ = -4						; size = 4
_flight$ = 8						; size = 4
?GetDogfightCallsign@@YAXPAVFlightClass@@@Z PROC	; GetDogfightCallsign

; 360  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 361  : 	int	num,i,checkid;
; 362  : 
; 363  : 	for (num=1; num<9; num++)

	mov	DWORD PTR _num$[ebp], 1
	jmp	SHORT $LN7@GetDogfigh
$LN6@GetDogfigh:
	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _num$[ebp], eax
$LN7@GetDogfigh:
	cmp	DWORD PTR _num$[ebp], 9
	jge	$LN8@GetDogfigh

; 364  : 		{
; 365  : 		for (i=0; i<5; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GetDogfigh
$LN3@GetDogfigh:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@GetDogfigh:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN2@GetDogfigh

; 366  : 			{
; 367  : 			checkid = calltable[flight->GetTeam()][i];

	mov	edx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR ?calltable@@3PAY04EA[eax+ecx]
	mov	DWORD PTR _checkid$[ebp], edx

; 368  : 			if (checkid < NumCallsigns && !((CallsignData[checkid] >> (num-1)) & 0x01))

	mov	eax, DWORD PTR _checkid$[ebp]
	cmp	eax, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	jge	SHORT $LN1@GetDogfigh
	mov	ecx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	add	ecx, DWORD PTR _checkid$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR _num$[ebp]
	sub	ecx, 1
	sar	edx, cl
	and	edx, 1
	jne	SHORT $LN1@GetDogfigh

; 369  : 				{
; 370  : 				flight->callsign_id = (uchar)checkid;

	mov	eax, DWORD PTR _flight$[ebp]
	mov	cl, BYTE PTR _checkid$[ebp]
	mov	BYTE PTR [eax+425], cl

; 371  : 				flight->callsign_num = (uchar)num;

	mov	edx, DWORD PTR _flight$[ebp]
	mov	al, BYTE PTR _num$[ebp]
	mov	BYTE PTR [edx+426], al

; 372  : 				MonoPrint ("Flight %08x Callsign %d:%d\n", flight, checkid, num);

	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _checkid$[ebp]
	push	edx
	mov	eax, DWORD PTR _flight$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@BBAHDPDH@Flight?5?$CF08x?5Callsign?5?$CFd?3?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 16					; 00000010H

; 373  : 				return;

	jmp	SHORT $LN8@GetDogfigh
$LN1@GetDogfigh:

; 374  : 				}
; 375  : 			}

	jmp	$LN3@GetDogfigh
$LN2@GetDogfigh:

; 376  : 		}

	jmp	$LN6@GetDogfigh
$LN8@GetDogfigh:

; 377  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDogfightCallsign@@YAXPAVFlightClass@@@Z ENDP	; GetDogfightCallsign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_vc$1 = -48						; size = 4
_id$ = -44						; size = 4
_num$ = -40						; size = 4
_wname$ = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
_fl$ = 8						; size = 4
_callsign$ = 12						; size = 4
?GetCallsign@@YAXPAVFlightClass@@PAD@Z PROC		; GetCallsign

; 339  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 340  : 	_TCHAR		wname[30];
; 341  : 	int			id, num;
; 342  : 
; 343  : 	id = fl->callsign_id;

	mov	eax, DWORD PTR _fl$[ebp]
	movzx	ecx, BYTE PTR [eax+425]
	mov	DWORD PTR _id$[ebp], ecx

; 344  : 	num = fl->callsign_num;

	mov	edx, DWORD PTR _fl$[ebp]
	movzx	eax, BYTE PTR [edx+426]
	mov	DWORD PTR _num$[ebp], eax

; 345  : 	if (num)

	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $LN2@GetCallsig

; 346  : 		{
; 347  : 		ReadIndexedString(FIRST_CALLSIGN_ID+id,callsign,29);

	push	29					; 0000001dH
	mov	ecx, DWORD PTR _callsign$[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	add	edx, 2000				; 000007d0H
	push	edx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 348  : 		ReadIndexedString(num,wname,29);

	push	29					; 0000001dH
	lea	eax, DWORD PTR _wname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 349  : 		_tcscat(callsign,wname);

	lea	edx, DWORD PTR _wname$[ebp]
	push	edx
	mov	eax, DWORD PTR _callsign$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 350  : 		}
; 351  : 	else

	jmp	SHORT $LN3@GetCallsig
$LN2@GetCallsig:

; 352  : 		{
; 353  : 		VehicleClassDataType *vc;
; 354  : 		vc = GetVehicleClassData(fl->GetVehicleID(0));

	push	0
	mov	ecx, DWORD PTR _fl$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$1[ebp], eax

; 355  : 		_stprintf(callsign,vc->Name);

	mov	edx, DWORD PTR _vc$1[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _callsign$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN3@GetCallsig:

; 356  : 		}
; 357  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCallsign@@YAXPAVFlightClass@@PAD@Z ENDP		; GetCallsign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_wname$ = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
_id$ = 8						; size = 4
_num$ = 12						; size = 4
_callsign$ = 16						; size = 4
?GetCallsign@@YAXHHPAD@Z PROC				; GetCallsign

; 327  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 328  : 	_TCHAR		wname[30];
; 329  : 
; 330  : 	if (num)

	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $LN2@GetCallsig

; 331  : 		{
; 332  : 		ReadIndexedString(FIRST_CALLSIGN_ID+id,callsign,29);

	push	29					; 0000001dH
	mov	eax, DWORD PTR _callsign$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	add	ecx, 2000				; 000007d0H
	push	ecx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 333  : 		ReadIndexedString(num,wname,29);

	push	29					; 0000001dH
	lea	edx, DWORD PTR _wname$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 334  : 		_tcscat(callsign,wname);

	lea	ecx, DWORD PTR _wname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _callsign$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN2@GetCallsig:

; 335  : 		}
; 336  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCallsign@@YAXHHPAD@Z ENDP				; GetCallsign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_temp$ = -4						; size = 4
_id$ = 8						; size = 4
_num$ = 12						; size = 4
?UnsetCallsignID@@YAXHH@Z PROC				; UnsetCallsignID

; 321  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 322  : 	int		temp = (0x01 << (num-1));

	mov	ecx, DWORD PTR _num$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _temp$[ebp], eax

; 323  : 	CallsignData[id] &= (uchar)(~temp);

	mov	ecx, DWORD PTR _temp$[ebp]
	not	ecx
	movzx	edx, cl
	mov	eax, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	add	eax, DWORD PTR _id$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, edx
	mov	edx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	add	edx, DWORD PTR _id$[ebp]
	mov	BYTE PTR [edx], cl

; 324  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetCallsignID@@YAXHH@Z ENDP				; UnsetCallsignID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_temp$ = -4						; size = 4
_id$ = 8						; size = 4
_num$ = 12						; size = 4
?SetCallsignID@@YAXHH@Z PROC				; SetCallsignID

; 315  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 316  : 	int		temp = (0x01 << (num-1));

	mov	ecx, DWORD PTR _num$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _temp$[ebp], eax

; 317  : 	CallsignData[id] |= (uchar)(temp);

	movzx	ecx, BYTE PTR _temp$[ebp]
	mov	edx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	add	edx, DWORD PTR _id$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, ecx
	mov	ecx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	add	ecx, DWORD PTR _id$[ebp]
	mov	BYTE PTR [ecx], al

; 318  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCallsignID@@YAXHH@Z ENDP				; SetCallsignID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_id$ = 8						; size = 4
_num$ = 12						; size = 4
_range$ = 16						; size = 4
?GetCallsignID@@YAXPAE0H@Z PROC				; GetCallsignID

; 287  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 288  : 	int			i,j;
; 289  : 
; 290  : 	for (j=1; j<9; j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN11@GetCallsig
$LN10@GetCallsig:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN11@GetCallsig:
	cmp	DWORD PTR _j$[ebp], 9
	jge	SHORT $LN9@GetCallsig

; 291  : 		{
; 292  : 		for (i=(int)*id; i<(int)*id+range; i++)

	mov	ecx, DWORD PTR _id$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN8@GetCallsig
$LN7@GetCallsig:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@GetCallsig:
	mov	ecx, DWORD PTR _id$[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	edx, DWORD PTR _range$[ebp]
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN6@GetCallsig

; 293  : 			{
; 294  : 			if (i < NumCallsigns && !((CallsignData[i] >> (j-1)) & 0x01))

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	jge	SHORT $LN5@GetCallsig
	mov	ecx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	sar	edx, cl
	and	edx, 1
	jne	SHORT $LN5@GetCallsig

; 295  : 				{
; 296  : 				*id = (uchar)i;

	mov	eax, DWORD PTR _id$[ebp]
	mov	cl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [eax], cl

; 297  : 				*num = (uchar)j;

	mov	edx, DWORD PTR _num$[ebp]
	mov	al, BYTE PTR _j$[ebp]
	mov	BYTE PTR [edx], al

; 298  : 				return;

	jmp	SHORT $LN12@GetCallsig
$LN5@GetCallsig:

; 299  : 				}
; 300  : 			}

	jmp	SHORT $LN7@GetCallsig
$LN6@GetCallsig:

; 301  : 		}

	jmp	SHORT $LN10@GetCallsig
$LN9@GetCallsig:

; 302  : 	// KCK: No callsigns left, pick one of the available ones with a '9'
; 303  : 	*num = 9;

	mov	ecx, DWORD PTR _num$[ebp]
	mov	BYTE PTR [ecx], 9

; 304  : 	for (i=(int)*id; i<(int)*id+range; i++)

	mov	edx, DWORD PTR _id$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@GetCallsig
$LN3@GetCallsig:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@GetCallsig:
	mov	edx, DWORD PTR _id$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	eax, DWORD PTR _range$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN12@GetCallsig

; 305  : 		{
; 306  : 		if (i < NumCallsigns && !(rand()%range))

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	jge	SHORT $LN1@GetCallsig
	call	_rand
	cdq
	idiv	DWORD PTR _range$[ebp]
	test	edx, edx
	jne	SHORT $LN1@GetCallsig

; 307  : 			{
; 308  : 			*id = (uchar)i;

	mov	edx, DWORD PTR _id$[ebp]
	mov	al, BYTE PTR _i$[ebp]
	mov	BYTE PTR [edx], al

; 309  : 			return;

	jmp	SHORT $LN12@GetCallsig
$LN1@GetCallsig:

; 310  : 			}
; 311  : 		}

	jmp	SHORT $LN3@GetCallsig
$LN12@GetCallsig:

; 312  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCallsignID@@YAXPAE0H@Z ENDP				; GetCallsignID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
_name$ = 12						; size = 4
_size$ = 16						; size = 4
?GetPilotName@@YAXHPADH@Z PROC				; GetPilotName

; 282  : 	{

	push	ebp
	mov	ebp, esp

; 283  : 	ReadIndexedString(FIRST_PILOT_ID+id,name,size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	add	edx, 2300				; 000008fcH
	push	edx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 284  : 	}

	pop	ebp
	ret	0
?GetPilotName@@YAXHPADH@Z ENDP				; GetPilotName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_best_pilot$ = -8					; size = 4
_best$ = -4						; size = 2
_first$ = 8						; size = 4
_last$ = 12						; size = 4
_owner$ = 16						; size = 4
?GetAvailablePilot@@YAHHHH@Z PROC			; GetAvailablePilot

; 216  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 217  : 	int		best_pilot = -1;

	mov	DWORD PTR _best_pilot$[ebp], -1

; 218  : 	ushort	best = ~0;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR _best$[ebp], ax

; 219  : 
; 220  : 	if (last > NumPilots)

	mov	ecx, DWORD PTR _last$[ebp]
	cmp	ecx, DWORD PTR ?NumPilots@@3HA		; NumPilots
	jle	SHORT $LN7@GetAvailab

; 221  : 		last = NumPilots;

	mov	edx, DWORD PTR ?NumPilots@@3HA		; NumPilots
	mov	DWORD PTR _last$[ebp], edx
$LN7@GetAvailab:

; 222  : 
; 223  : 	for (int i=first; i<last; i++)

	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN6@GetAvailab
$LN5@GetAvailab:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN6@GetAvailab:
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR _last$[ebp]
	jge	SHORT $LN4@GetAvailab

; 224  : 		{
; 225  : 		if (PilotInfo[i].usage < best)

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	movsx	edx, WORD PTR [ecx+eax*4]
	movzx	eax, WORD PTR _best$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@GetAvailab

; 226  : 			{
; 227  : 			best = PilotInfo[i].usage;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	ax, WORD PTR [edx+ecx*4]
	mov	WORD PTR _best$[ebp], ax

; 228  : 			best_pilot = i;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _best_pilot$[ebp], ecx
$LN3@GetAvailab:

; 229  : 			}
; 230  : 		}

	jmp	SHORT $LN5@GetAvailab
$LN4@GetAvailab:

; 231  : 	
; 232  : 	if (best_pilot > -1)

	cmp	DWORD PTR _best_pilot$[ebp], -1
	jle	SHORT $LN2@GetAvailab

; 233  : 		PilotInfo[best_pilot].usage++;

	mov	edx, DWORD PTR _best_pilot$[ebp]
	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	cx, WORD PTR [eax+edx*4]
	add	cx, 1
	mov	edx, DWORD PTR _best_pilot$[ebp]
	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	WORD PTR [eax+edx*4], cx
$LN2@GetAvailab:

; 234  : 
; 235  : 	if (PilotInfo[best_pilot].voice_id == 255) {

	mov	ecx, DWORD PTR _best_pilot$[ebp]
	mov	edx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	movzx	eax, BYTE PTR [edx+ecx*4+2]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN1@GetAvailab

; 236  : 	    PilotInfo[best_pilot].AssignVoice(owner);

	mov	ecx, DWORD PTR _owner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _best_pilot$[ebp]
	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	lea	ecx, DWORD PTR [eax+edx*4]
	call	?AssignVoice@PilotInfoClass@@QAEXH@Z	; PilotInfoClass::AssignVoice
$LN1@GetAvailab:

; 237  : 	}
; 238  : 	return best_pilot;

	mov	eax, DWORD PTR _best_pilot$[ebp]

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvailablePilot@@YAHHHH@Z ENDP			; GetAvailablePilot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?DisposePilotInfo@@YAXXZ PROC				; DisposePilotInfo

; 204  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 205  : 	if (PilotInfo)

	cmp	DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A, 0 ; PilotInfo
	je	SHORT $LN2@DisposePil

; 206  : 		delete[] PilotInfo;

	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DisposePil:

; 207  : 	PilotInfo = NULL;

	mov	DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A, 0 ; PilotInfo

; 208  : 	NumPilots = 0;

	mov	DWORD PTR ?NumPilots@@3HA, 0		; NumPilots

; 209  : 	if (CallsignData)

	cmp	DWORD PTR ?CallsignData@@3PAEA, 0	; CallsignData
	je	SHORT $LN1@DisposePil

; 210  : 		delete [] CallsignData;

	mov	edx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@DisposePil:

; 211  : 	CallsignData = NULL;

	mov	DWORD PTR ?CallsignData@@3PAEA, 0	; CallsignData

; 212  : 	NumCallsigns = 0;

	mov	DWORD PTR ?NumCallsigns@@3HA, 0		; NumCallsigns

; 213  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?DisposePilotInfo@@YAXXZ ENDP				; DisposePilotInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_fp$ = -4						; size = 4
_scenario$ = 8						; size = 4
?SavePilotInfo@@YAXPAD@Z PROC				; SavePilotInfo

; 191  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 192  : 	FILE	*fp;
; 193  : 
; 194  : 	if ((fp = OpenCampFile(scenario, "plt", "wb")) == NULL)

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	OFFSET ??_C@_03LPBKAOMJ@plt?$AA@
	mov	eax, DWORD PTR _scenario$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN1@SavePilotI

; 195  : 		return;

	jmp	SHORT $LN2@SavePilotI
$LN1@SavePilotI:

; 196  : 	fwrite(&NumPilots,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	push	OFFSET ?NumPilots@@3HA			; NumPilots
	call	_fwrite
	add	esp, 16					; 00000010H

; 197  : 	fwrite(PilotInfo,sizeof(PilotInfoClass),NumPilots,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	mov	eax, DWORD PTR ?NumPilots@@3HA		; NumPilots
	push	eax
	push	4
	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 198  : 	fwrite(&NumCallsigns,sizeof(short),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	2
	push	OFFSET ?NumCallsigns@@3HA		; NumCallsigns
	call	_fwrite
	add	esp, 16					; 00000010H

; 199  : 	fwrite(CallsignData,sizeof(uchar),NumCallsigns,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	push	ecx
	push	1
	mov	edx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 200  : 	CloseCampFile(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4
$LN2@SavePilotI:

; 201  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SavePilotInfo@@YAXPAD@Z ENDP				; SavePilotInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
$T2 = -76						; size = 8
_cd$ = -68						; size = 8
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
tv87 = -40						; size = 4
$T8 = -36						; size = 4
$T9 = -32						; size = 4
$T10 = -28						; size = 4
$T11 = -24						; size = 4
_data_ptr$ = -20					; size = 4
_max$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_scenario$ = 8						; size = 4
?LoadPilotInfo@@YAHPAD@Z PROC				; LoadPilotInfo

; 148  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadPilotInfo@@YAHPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 149  : 	char	/* *data,*/ *data_ptr;
; 150  : 	short	max;
; 151  : 
; 152  : 	if (gCampDataVersion < 60) {

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 60	; gCampDataVersion, 0000003cH
	jge	SHORT $LN4@LoadPilotI

; 153  : 		NewPilotInfo();

	call	?NewPilotInfo@@YAXXZ			; NewPilotInfo

; 154  : 		return 1;

	mov	eax, 1
	jmp	$LN5@LoadPilotI
$LN4@LoadPilotI:

; 155  : 	}
; 156  : 
; 157  : 	CampaignData cd = ReadCampFile(scenario, "plt");

	push	OFFSET ??_C@_03LPBKAOMJ@plt?$AA@
	mov	eax, DWORD PTR _scenario$[ebp]
	push	eax
	call	?ReadCampFile@@YA?AUCampaignData@@PAD0@Z ; ReadCampFile
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _cd$[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _cd$[ebp+4], edx

; 158  : 	if (cd.dataSize == -1){

	cmp	DWORD PTR _cd$[ebp], -1
	jne	SHORT $LN3@LoadPilotI

; 159  : 		return 0;

	xor	eax, eax
	jmp	$LN5@LoadPilotI
$LN3@LoadPilotI:

; 160  : 	}
; 161  : 
; 162  : 	data_ptr = cd.data;

	mov	eax, DWORD PTR _cd$[ebp+4]
	mov	DWORD PTR _data_ptr$[ebp], eax

; 163  : 
; 164  : 	// Pilot Data
; 165  : 	max = *((short *) data_ptr); data_ptr += sizeof (short);

	mov	ecx, DWORD PTR _data_ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _max$[ebp], dx
	mov	eax, DWORD PTR _data_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _data_ptr$[ebp], eax

; 166  : 
; 167  : 	if (PilotInfo)

	cmp	DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A, 0 ; PilotInfo
	je	SHORT $LN2@LoadPilotI

; 168  : 		delete [] PilotInfo;

	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@LoadPilotI:

; 169  : 
; 170  : 	NumPilots = max;

	movsx	eax, WORD PTR _max$[ebp]
	mov	DWORD PTR ?NumPilots@@3HA, eax		; NumPilots

; 171  : 	PilotInfo = new PilotInfoClass[NumPilots];

	mov	ecx, DWORD PTR ?NumPilots@@3HA		; NumPilots
	mov	DWORD PTR $T8[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T8[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN7@LoadPilotI
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T10[ebp], ecx
$LN11@LoadPilotI:
	mov	edx, DWORD PTR $T11[ebp]
	sub	edx, 1
	mov	DWORD PTR $T11[ebp], edx
	js	SHORT $LN12@LoadPilotI
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0PilotInfoClass@@QAE@XZ		; PilotInfoClass::PilotInfoClass
	mov	eax, DWORD PTR $T10[ebp]
	add	eax, 4
	mov	DWORD PTR $T10[ebp], eax
	jmp	SHORT $LN11@LoadPilotI
$LN12@LoadPilotI:
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR tv87[ebp], ecx
	jmp	SHORT $LN8@LoadPilotI
$LN7@LoadPilotI:
	mov	DWORD PTR tv87[ebp], 0
$LN8@LoadPilotI:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A, eax ; PilotInfo

; 172  : 
; 173  : 	memcpy (PilotInfo, data_ptr, sizeof (PilotInfoClass) * max); data_ptr += sizeof (PilotInfoClass) * max;

	movsx	ecx, WORD PTR _max$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _data_ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	movsx	ecx, WORD PTR _max$[ebp]
	mov	edx, DWORD PTR _data_ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _data_ptr$[ebp], eax

; 174  : 
; 175  : 	// Callsign Data
; 176  : 	max = *((short *) data_ptr); data_ptr += sizeof (short);

	mov	ecx, DWORD PTR _data_ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _max$[ebp], dx
	mov	eax, DWORD PTR _data_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _data_ptr$[ebp], eax

; 177  : 
; 178  : 	if (CallsignData)

	cmp	DWORD PTR ?CallsignData@@3PAEA, 0	; CallsignData
	je	SHORT $LN1@LoadPilotI

; 179  : 		delete [] CallsignData;

	mov	ecx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@LoadPilotI:

; 180  : 
; 181  : 	NumCallsigns = max;

	movsx	eax, WORD PTR _max$[ebp]
	mov	DWORD PTR ?NumCallsigns@@3HA, eax	; NumCallsigns

; 182  : 
; 183  : 	CallsignData = new unsigned char[NumCallsigns];

	mov	ecx, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR ?CallsignData@@3PAEA, edx	; CallsignData

; 184  : 	memcpy (CallsignData, data_ptr, sizeof (uchar) * NumCallsigns); data_ptr += sizeof (uchar) * NumCallsigns;

	mov	eax, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	push	eax
	mov	ecx, DWORD PTR _data_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _data_ptr$[ebp]
	add	eax, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	mov	DWORD PTR _data_ptr$[ebp], eax

; 185  : 
; 186  : 	delete cd.data;

	mov	ecx, DWORD PTR _cd$[ebp+4]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 187  : 	return 1;

	mov	eax, 1
$LN5@LoadPilotI:

; 188  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadPilotInfo@@YAHPAD@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?LoadPilotInfo@@YAHPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadPilotInfo@@YAHPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadPilotInfo@@YAHPAD@Z ENDP				; LoadPilotInfo
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 4
tv78 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
_i$8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?NewPilotInfo@@YAXXZ PROC				; NewPilotInfo

; 125  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NewPilotInfo@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 126  : 	NumPilots = NUM_PILOTS;

	mov	DWORD PTR ?NumPilots@@3HA, 686		; NumPilots, 000002aeH

; 127  : 	PilotInfo = new PilotInfoClass[NumPilots];

	mov	eax, DWORD PTR ?NumPilots@@3HA		; NumPilots
	mov	DWORD PTR $T4[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T4[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN6@NewPilotIn
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T6[ebp], ecx
$LN10@NewPilotIn:
	mov	edx, DWORD PTR $T7[ebp]
	sub	edx, 1
	mov	DWORD PTR $T7[ebp], edx
	js	SHORT $LN11@NewPilotIn
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0PilotInfoClass@@QAE@XZ		; PilotInfoClass::PilotInfoClass
	mov	eax, DWORD PTR $T6[ebp]
	add	eax, 4
	mov	DWORD PTR $T6[ebp], eax
	jmp	SHORT $LN10@NewPilotIn
$LN11@NewPilotIn:
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN7@NewPilotIn
$LN6@NewPilotIn:
	mov	DWORD PTR tv78[ebp], 0
$LN7@NewPilotIn:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A, eax ; PilotInfo

; 128  : 	for (int i=0; i<NumPilots; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN3@NewPilotIn
$LN2@NewPilotIn:
	mov	ecx, DWORD PTR _i$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$8[ebp], ecx
$LN3@NewPilotIn:
	mov	edx, DWORD PTR _i$8[ebp]
	cmp	edx, DWORD PTR ?NumPilots@@3HA		; NumPilots
	jge	SHORT $LN1@NewPilotIn

; 129  : 		PilotInfo[i].ResetStats();

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	?ResetStats@PilotInfoClass@@QAEXXZ	; PilotInfoClass::ResetStats
	jmp	SHORT $LN2@NewPilotIn
$LN1@NewPilotIn:

; 130  : 	// Some hard coded values (Because I'm vain)
; 131  : 	// Col. Klemmick
; 132  : 	PilotInfo[1].voice_id = 1;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	BYTE PTR [eax+edx+2], 1

; 133  : 	PilotInfo[1].photo_id = 55;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	BYTE PTR [edx+ecx+3], 55		; 00000037H

; 134  : 	// Col. Bonanni
; 135  : 	PilotInfo[2].voice_id = 2;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	BYTE PTR [ecx+eax+2], 2

; 136  : 	PilotInfo[2].photo_id = 102;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	BYTE PTR [eax+edx+3], 102		; 00000066H

; 137  : 	// Col. Reiner
; 138  : 	PilotInfo[3].voice_id = 3;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	BYTE PTR [edx+ecx+2], 3

; 139  : 	PilotInfo[3].photo_id = 77;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	BYTE PTR [ecx+eax+3], 77		; 0000004dH

; 140  : 	// Unassigned pilot (don't use)
; 141  : 	PilotInfo[255].usage = 32000;

	mov	edx, 4
	imul	edx, 255				; 000000ffH
	mov	eax, 32000				; 00007d00H
	mov	ecx, DWORD PTR ?PilotInfo@@3PAVPilotInfoClass@@A ; PilotInfo
	mov	WORD PTR [ecx+edx], ax

; 142  : 	NumCallsigns = NUM_CALLSIGNS;

	mov	DWORD PTR ?NumCallsigns@@3HA, 160	; NumCallsigns, 000000a0H

; 143  : 	CallsignData = new unsigned char[NumCallsigns];

	mov	edx, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?CallsignData@@3PAEA, eax	; CallsignData

; 144  : 	memset(CallsignData,0,sizeof(uchar)*NumCallsigns);

	mov	ecx, DWORD PTR ?NumCallsigns@@3HA	; NumCallsigns
	push	ecx
	push	0
	mov	edx, DWORD PTR ?CallsignData@@3PAEA	; CallsignData
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 145  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NewPilotInfo@@YAXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?NewPilotInfo@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NewPilotInfo@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?NewPilotInfo@@YAXXZ ENDP				; NewPilotInfo
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_owner$ = 8						; size = 4
?AssignVoice@PilotInfoClass@@QAEXH@Z PROC		; PilotInfoClass::AssignVoice
; _this$ = ecx

; 115  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  :     voice_id = g_voicemap.PickVoice(VoiceMapper::VOICE_PILOT, owner);

	mov	eax, DWORD PTR _owner$[ebp]
	push	eax
	push	1
	mov	ecx, OFFSET ?g_voicemap@@3VVoiceMapper@@A ; g_voicemap
	call	?PickVoice@VoiceMapper@@QAEHHH@Z	; VoiceMapper::PickVoice
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+2], al

; 117  :     photo_id = AssignUIImageID(voice_id); // UI will check if this is male or female (& keep track of images)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	?AssignUIImageID@@YAEE@Z		; AssignUIImageID
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+3], al

; 118  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AssignVoice@PilotInfoClass@@QAEXH@Z ENDP		; PilotInfoClass::AssignVoice
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetStats@PilotInfoClass@@QAEXXZ PROC			; PilotInfoClass::ResetStats
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  :     voice_id = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH

; 108  :     //g_voicemap.PickVoice(VoiceMapper::VOICE_PILOT, VoiceMapper::VOICE_SIDE_UNK);
; 109  :     photo_id = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+3], 0

; 110  :     //AssignUIImageID(voice_id); // UI will check if this is male or female (& keep track of images)
; 111  :     usage = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax], dx

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetStats@PilotInfoClass@@QAEXXZ ENDP			; PilotInfoClass::ResetStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PilotInfoClass@@QAE@XZ PROC				; PilotInfoClass::PilotInfoClass
; _this$ = ecx

; 102  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PilotInfoClass@@QAE@XZ ENDP				; PilotInfoClass::PilotInfoClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_skill$ = -8						; size = 4
_this$ = -4						; size = 4
_rating$ = 8						; size = 1
?SetTEPilotRating@PilotClass@@QAEXE@Z PROC		; PilotClass::SetTEPilotRating
; _this$ = ecx

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 	int skill;
; 82   : 	skill = ((rand() %2 - 1) + rating);	// randomize the squad's pilots a bit

	call	_rand
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN5@SetTEPilot
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN5@SetTEPilot:
	movzx	ecx, BYTE PTR _rating$[ebp]
	lea	edx, DWORD PTR [eax+ecx-1]
	mov	DWORD PTR _skill$[ebp], edx

; 83   : 	if (skill > 4)

	cmp	DWORD PTR _skill$[ebp], 4
	jle	SHORT $LN2@SetTEPilot

; 84   : 		skill = 4;

	mov	DWORD PTR _skill$[ebp], 4
$LN2@SetTEPilot:

; 85   : 	if (skill < 0)

	cmp	DWORD PTR _skill$[ebp], 0
	jge	SHORT $LN1@SetTEPilot

; 86   : 		skill = 0;

	mov	DWORD PTR _skill$[ebp], 0
$LN1@SetTEPilot:

; 87   : 	// pilot_id = 0; // 2002-01-24 REMOVED BY S.G. This is the pilot ID used to figure out the name of the pilot (and may be its voice). It's already set and if reset, it will remain at 0 (Unassigned).
; 88   : 	pilot_status = PILOT_AVAILABLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+3], 0

; 89   : 	pilot_skill_and_rating = skill;		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _skill$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 90   : 	aa_kills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 91   : 	ag_kills = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5], 0

; 92   : 	as_kills = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], 0

; 93   : 	an_kills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+7], 0

; 94   : 	missions_flown = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+8], cx

; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTEPilotRating@PilotClass@@QAEXE@Z ENDP		; PilotClass::SetTEPilotRating
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_airExperience$ = 8					; size = 1
?ResetStats@PilotClass@@QAEXE@Z PROC			; PilotClass::ResetStats
; _this$ = ecx

; 63   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 	pilot_id = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx], ax

; 65   : 	pilot_status = PILOT_AVAILABLE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+3], 0

; 66   : // MODIFIED BY S.G. SO PILOT SKILL ARE NOT JUST VETERAN AND ACE BUT BASED ON THE SQUADRON SKILL +-1
; 67   : //	pilot_skill_and_rating = 0x03 | (rand()%PILOT_SKILL_RANGE);
; 68   : 	airExperience -= 60; // From 60 to 100 (recruit to ace) down to 0 to 40

	movzx	eax, BYTE PTR _airExperience$[ebp]
	sub	eax, 60					; 0000003cH
	mov	BYTE PTR _airExperience$[ebp], al

; 69   : 	airExperience /= 10; // Now from 0 to 4 like 'pilot_skill_and_rating' likes it

	movzx	eax, BYTE PTR _airExperience$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	BYTE PTR _airExperience$[ebp], al

; 70   : 	pilot_skill_and_rating = 0x30 | ((rand() % 3 - 1) + airExperience); // pilot_skill_and_rating will have +-1 from 'airExperience' base level

	call	_rand
	cdq
	mov	ecx, 3
	idiv	ecx
	movzx	eax, BYTE PTR _airExperience$[ebp]
	lea	ecx, DWORD PTR [edx+eax-1]
	or	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+2], cl

; 71   : // END OF MODIFIED SECTION
; 72   : 	aa_kills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 73   : 	ag_kills = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5], 0

; 74   : 	as_kills = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], 0

; 75   : 	an_kills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+7], 0

; 76   : 	missions_flown = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+8], cx

; 77   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ResetStats@PilotClass@@QAEXE@Z ENDP			; PilotClass::ResetStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\pilot.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PilotClass@@QAE@XZ PROC				; PilotClass::PilotClass
; _this$ = ecx

; 57   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PilotClass@@QAE@XZ ENDP				; PilotClass::PilotClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
