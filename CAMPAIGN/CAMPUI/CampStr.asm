; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUI\CampStr.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?SpecialStr@@3PAY0P@DA				; SpecialStr
PUBLIC	?ObjectiveStr@@3PAY0BE@DA			; ObjectiveStr
PUBLIC	?MissStr@@3PAY0BE@DA				; MissStr
PUBLIC	?WPActStr@@3PAY0BE@DA				; WPActStr
PUBLIC	?CountryNameStr@@3PAY0BE@DA			; CountryNameStr
PUBLIC	?gUnitNameFormat@@3PADA				; gUnitNameFormat
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?AirSTypesStr@@3PAY0BE@DA			; AirSTypesStr
PUBLIC	?GroundSTypesStr@@3PAY0BE@DA			; GroundSTypesStr
PUBLIC	?NavalSTypesStr@@3PAY0BE@DA			; NavalSTypesStr
PUBLIC	?CompressionStr@@3PAY0BE@DA			; CompressionStr
PUBLIC	?CameraLabel@@3PAY0CI@DA			; CameraLabel
PUBLIC	?StringIndex@@3PAGA				; StringIndex
PUBLIC	?StringTable@@3PADA				; StringTable
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
_BSS	SEGMENT
?ObjectiveStr@@3PAY0BE@DA DB 0294H DUP (?)		; ObjectiveStr
?MissStr@@3PAY0BE@DA DB 0334H DUP (?)			; MissStr
?WPActStr@@3PAY0BE@DA DB 03e8H DUP (?)			; WPActStr
?CountryNameStr@@3PAY0BE@DA DB 0a0H DUP (?)		; CountryNameStr
?gUnitNameFormat@@3PADA DB 028H DUP (?)			; gUnitNameFormat
?AirSTypesStr@@3PAY0BE@DA DB 0190H DUP (?)		; AirSTypesStr
?GroundSTypesStr@@3PAY0BE@DA DB 0190H DUP (?)		; GroundSTypesStr
?NavalSTypesStr@@3PAY0BE@DA DB 0190H DUP (?)		; NavalSTypesStr
?CompressionStr@@3PAY0BE@DA DB 064H DUP (?)		; CompressionStr
?StringIndex@@3PAGA DD 01H DUP (?)			; StringIndex
?StringTable@@3PADA DD 01H DUP (?)			; StringTable
_BSS	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
_DATA	SEGMENT
?SpecialStr@@3PAY0P@DA DB 'General', 00H		; SpecialStr
	ORG $+7
	DB	'Air to Air', 00H
	ORG $+4
	DB	'Air to Ground', 00H
	ORG $+1
	ORG $+3
?CameraLabel@@3PAY0CI@DA DB 'FLY-BY CAMERA', 00H	; CameraLabel
	ORG $+26
	DB	'CHASE CAMERA', 00H
	ORG $+27
	DB	'ORBIT CAMERA', 00H
	ORG $+27
	DB	'SATELLITE CAMERA', 00H
	ORG $+23
	DB	'WEAPON CAMERA', 00H
	ORG $+26
	DB	'TARGET TO WEAPON CAMERA', 00H
	ORG $+16
	DB	'ENEMY AIRCRAFT CAMERA', 00H
	ORG $+18
	DB	'FRIENDLY AIRCRAFT CAMERA', 00H
	ORG $+15
	DB	'ENEMY GROUND UNIT CAMERA', 00H
	ORG $+15
	DB	'FRIENDLY GROUND UNIT CAMERA', 00H
	ORG $+12
	DB	'INCOMING MISSILE CAMERA', 00H
	ORG $+16
	DB	'TARGET CAMERA', 00H
	ORG $+26
	DB	'TARGET TO SELF CAMERA', 00H
	ORG $+18
	DB	'ACTION CAMERA', 00H
	ORG $+26
	DB	'RECORDING', 00H
	ORG $+30
	ORG $+40
_DATA	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	?GetSTypeName@@YAPADHHHQAD@Z			; GetSTypeName
PUBLIC	?GetNumberName@@YAPADHPAD@Z			; GetNumberName
PUBLIC	?GetTimeString@@YAPADKQADH@Z			; GetTimeString
PUBLIC	?ReadIndex@@YAXPAD@Z				; ReadIndex
PUBLIC	?FreeIndex@@YAXXZ				; FreeIndex
PUBLIC	?ReadIndexedString@@YAXHPADH@Z			; ReadIndexedString
PUBLIC	?ForeignToUpper@@YAXPAD@Z			; ForeignToUpper
PUBLIC	??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@		; `string'
PUBLIC	??_C@_05KECOGGGP@?$CF2?42d?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_03DAKNAIGI@idx?$AA@			; `string'
PUBLIC	??_C@_03MPOGCMBA@wch?$AA@			; `string'
EXTRN	_memcpy:PROC
EXTRN	__ismbclower:PROC
EXTRN	_fread:PROC
EXTRN	_sprintf:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?CloseCampFile@@YAXPAU_iobuf@@@Z:PROC		; CloseCampFile
EXTRN	?ConstructOrderedSentence@@YAXFPAD0ZZ:PROC	; ConstructOrderedSentence
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?NumObjectiveTypes@@3FA:WORD			; NumObjectiveTypes
EXTRN	?gLangIDNum@@3HA:DWORD				; gLangIDNum
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_03MPOGCMBA@wch?$AA@
CONST	SEGMENT
??_C@_03MPOGCMBA@wch?$AA@ DB 'wch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAKNAIGI@idx?$AA@
CONST	SEGMENT
??_C@_03DAKNAIGI@idx?$AA@ DB 'idx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KECOGGGP@?$CF2?42d?$AA@
CONST	SEGMENT
??_C@_05KECOGGGP@?$CF2?42d?$AA@ DB '%2.2d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@
CONST	SEGMENT
??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@ DB '%d%s', 00H		; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_buffer$ = 8						; size = 4
?ForeignToUpper@@YAXPAD@Z PROC				; ForeignToUpper

; 189  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 190  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN8@ForeignToU:

; 191  : 	while (buffer[i])

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN9@ForeignToU

; 192  : 		{
; 193  : 		if (gLangIDNum != F4LANG_ENGLISH)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 1		; gLangIDNum
	je	SHORT $LN6@ForeignToU

; 194  : 			{
; 195  : 			// Check for special characters
; 196  : 			if ((uchar)(buffer[i]) >= 224 && (uchar)(buffer[i]) <=253)

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 224				; 000000e0H
	jl	SHORT $LN5@ForeignToU
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 253				; 000000fdH
	jg	SHORT $LN5@ForeignToU

; 197  : 				buffer[i] -= 32;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN4@ForeignToU
$LN5@ForeignToU:

; 198  : 			else if (_istlower(buffer[i]))

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	__ismbclower
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@ForeignToU

; 199  : 				buffer[i] = _toupper(buffer[i]);

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
$LN4@ForeignToU:

; 200  : /*
; 201  : 			switch (buffer[i])
; 202  : 				{
; 203  : 				case 'è':
; 204  : 				case 'é':
; 205  : 				case 'ë':
; 206  : 				case 'ê':
; 207  : 					buffer[i] = 'E';
; 208  : 					break;
; 209  : 				case 'â':
; 210  : 				case 'à':
; 211  : 				case 'á':
; 212  : 				case 'ä':
; 213  : 					buffer[i] = 'A';
; 214  : 					break;
; 215  : 				case 'ì':
; 216  : 				case 'í':
; 217  : 				case 'î':
; 218  : 				case 'ï':
; 219  : 					buffer[i] = 'I';
; 220  : 					break;
; 221  : 				case 'û':
; 222  : 				case 'ú':
; 223  : 				case 'ù':
; 224  : 				case 'ü':
; 225  : 					buffer[i] = 'U';
; 226  : 					break;
; 227  : 				case 'ç':
; 228  : 					buffer[i] = 'C';
; 229  : 					break;
; 230  : 				case 'ñ':
; 231  : 					buffer[i] = 'N';
; 232  : 					break;
; 233  : 				case 'ô':
; 234  : 				case 'ö':
; 235  : 					buffer[i] = 'O';
; 236  : 					break;
; 237  : 				default:
; 238  : 					if (_istlower(buffer[i]))
; 239  : 						buffer[i] = _toupper(buffer[i]);
; 240  : 				}
; 241  : */
; 242  : 			}

	jmp	SHORT $LN2@ForeignToU
$LN6@ForeignToU:

; 243  : 		else if (_istlower(buffer[i]))

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	__ismbclower
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@ForeignToU

; 244  : 			buffer[i] = _toupper(buffer[i]);

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	edx, 32					; 00000020H
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], dl
$LN2@ForeignToU:

; 245  : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 246  : 		}

	jmp	$LN8@ForeignToU
$LN9@ForeignToU:

; 247  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ForeignToUpper@@YAXPAD@Z ENDP				; ForeignToUpper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
_size$ = -8						; size = 2
_rlen$ = -4						; size = 2
_sid$ = 8						; size = 4
_wstr$ = 12						; size = 4
_len$ = 16						; size = 4
?ReadIndexedString@@YAXHPADH@Z PROC			; ReadIndexedString

; 176  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 177  : 	ushort	size,rlen;
; 178  : 
; 179  : 	size = StringIndex[sid+1]-StringIndex[sid];

	mov	eax, DWORD PTR _sid$[ebp]
	mov	ecx, DWORD PTR ?StringIndex@@3PAGA	; StringIndex
	movzx	edx, WORD PTR [ecx+eax*2+2]
	mov	eax, DWORD PTR _sid$[ebp]
	mov	ecx, DWORD PTR ?StringIndex@@3PAGA	; StringIndex
	movzx	eax, WORD PTR [ecx+eax*2]
	sub	edx, eax
	mov	WORD PTR _size$[ebp], dx

; 180  : 	rlen = size / sizeof(_TCHAR);

	mov	cx, WORD PTR _size$[ebp]
	mov	WORD PTR _rlen$[ebp], cx

; 181  : 	if (rlen >= len)

	movzx	edx, WORD PTR _rlen$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jl	SHORT $LN1@ReadIndexe

; 182  : 		rlen = len - 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	WORD PTR _rlen$[ebp], ax
$LN1@ReadIndexe:

; 183  : 
; 184  : 	memcpy(wstr,&StringTable[StringIndex[sid]],rlen);

	movzx	ecx, WORD PTR _rlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sid$[ebp]
	mov	eax, DWORD PTR ?StringIndex@@3PAGA	; StringIndex
	movzx	ecx, WORD PTR [eax+edx*2]
	add	ecx, DWORD PTR ?StringTable@@3PADA	; StringTable
	push	ecx
	mov	edx, DWORD PTR _wstr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 185  : 	wstr[rlen] = 0;

	movzx	eax, WORD PTR _rlen$[ebp]
	mov	ecx, DWORD PTR _wstr$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 186  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadIndexedString@@YAXHPADH@Z ENDP			; ReadIndexedString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?FreeIndex@@YAXXZ PROC					; FreeIndex

; 168  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 169  : 	delete [] StringIndex;

	mov	eax, DWORD PTR ?StringIndex@@3PAGA	; StringIndex
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 170  : 	StringIndex = NULL;

	mov	DWORD PTR ?StringIndex@@3PAGA, 0	; StringIndex

; 171  : 	delete [] StringTable;

	mov	edx, DWORD PTR ?StringTable@@3PADA	; StringTable
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 172  : 	StringTable = NULL;

	mov	DWORD PTR ?StringTable@@3PADA, 0	; StringTable

; 173  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?FreeIndex@@YAXXZ ENDP					; FreeIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_max$ = -8						; size = 2
_i$ = -4						; size = 2
_filename$ = 8						; size = 4
?ReadIndex@@YAXPAD@Z PROC				; ReadIndex

; 126  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 127  : 	FILE	*fp;
; 128  : 	short	max,i;
; 129  : 	int		size;
; 130  : 
; 131  : 	if ((fp = OpenCampFile(filename,"idx","rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03DAKNAIGI@idx?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN29@ReadIndex

; 132  : 		return;

	jmp	$LN30@ReadIndex
$LN29@ReadIndex:

; 133  : 	fread(&max,sizeof(ushort),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 134  : 	StringIndex = new ushort[max];

	movsx	eax, WORD PTR _max$[ebp]
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?StringIndex@@3PAGA, eax	; StringIndex

; 135  : 	fread(StringIndex,sizeof(ushort),max,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _max$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR ?StringIndex@@3PAGA	; StringIndex
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 136  : 	CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 137  : 
; 138  : 	size = StringIndex[max-1];

	movsx	edx, WORD PTR _max$[ebp]
	mov	eax, DWORD PTR ?StringIndex@@3PAGA	; StringIndex
	movzx	ecx, WORD PTR [eax+edx*2-2]
	mov	DWORD PTR _size$[ebp], ecx

; 139  : 	if ((fp = OpenCampFile(filename,"wch","rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03MPOGCMBA@wch?$AA@
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN28@ReadIndex

; 140  : 		return;

	jmp	$LN30@ReadIndex
$LN28@ReadIndex:

; 141  : 	StringTable = new _TCHAR[size];

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?StringTable@@3PADA, ecx	; StringTable

; 142  : 	fread(StringTable,size,1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?StringTable@@3PADA	; StringTable
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 143  : 	CloseCampFile(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 144  : 
; 145  : 	// Now fill some of our string arrays.
; 146  : 	for (i=0; i<=NumObjectiveTypes; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN27@ReadIndex
$LN26@ReadIndex:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN27@ReadIndex:
	movsx	edx, WORD PTR _i$[ebp]
	movsx	eax, WORD PTR ?NumObjectiveTypes@@3FA	; NumObjectiveTypes
	cmp	edx, eax
	jg	SHORT $LN25@ReadIndex

; 147  : 		ReadIndexedString(500+i,ObjectiveStr[i],19);

	push	19					; 00000013H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, OFFSET ?ObjectiveStr@@3PAY0BE@DA	; ObjectiveStr
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	add	edx, 500				; 000001f4H
	push	edx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN26@ReadIndex
$LN25@ReadIndex:

; 148  : 	for (i=0; i<AMIS_OTHER; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN24@ReadIndex
$LN23@ReadIndex:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN24@ReadIndex:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 41					; 00000029H
	jge	SHORT $LN22@ReadIndex

; 149  : 		ReadIndexedString(300+i,MissStr[i],19);

	push	19					; 00000013H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, OFFSET ?MissStr@@3PAY0BE@DA	; MissStr
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN23@ReadIndex
$LN22@ReadIndex:

; 150  : 	for (i=0; i<WP_LAST; i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN21@ReadIndex
$LN20@ReadIndex:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN21@ReadIndex:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 50					; 00000032H
	jge	SHORT $LN19@ReadIndex

; 151  : 		ReadIndexedString(350+i,WPActStr[i],19);

	push	19					; 00000013H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET ?WPActStr@@3PAY0BE@DA	; WPActStr
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	add	eax, 350				; 0000015eH
	push	eax
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN20@ReadIndex
$LN19@ReadIndex:

; 152  : 	for (i=0; i<20; i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN18@ReadIndex
$LN17@ReadIndex:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN18@ReadIndex:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 20					; 00000014H
	jge	SHORT $LN16@ReadIndex

; 153  : 		ReadIndexedString(540+i,AirSTypesStr[i],19);

	push	19					; 00000013H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, OFFSET ?AirSTypesStr@@3PAY0BE@DA	; AirSTypesStr
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	add	edx, 540				; 0000021cH
	push	edx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN17@ReadIndex
$LN16@ReadIndex:

; 154  : 	for (i=0; i<20; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN15@ReadIndex
$LN14@ReadIndex:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN15@ReadIndex:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 20					; 00000014H
	jge	SHORT $LN13@ReadIndex

; 155  : 		ReadIndexedString(560+i,GroundSTypesStr[i],19);

	push	19					; 00000013H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, OFFSET ?GroundSTypesStr@@3PAY0BE@DA ; GroundSTypesStr
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN14@ReadIndex
$LN13@ReadIndex:

; 156  : 	for (i=0; i<20; i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN12@ReadIndex
$LN11@ReadIndex:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN12@ReadIndex:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 20					; 00000014H
	jge	SHORT $LN10@ReadIndex

; 157  : 		ReadIndexedString(580+i,NavalSTypesStr[i],19);

	push	19					; 00000013H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET ?NavalSTypesStr@@3PAY0BE@DA	; NavalSTypesStr
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@ReadIndex
$LN10@ReadIndex:

; 158  : 	for (i=0; i<NUM_COUNS; i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN9@ReadIndex
$LN8@ReadIndex:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN9@ReadIndex:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	SHORT $LN7@ReadIndex

; 159  : 		ReadIndexedString(40+i,CountryNameStr[i],19);

	push	19					; 00000013H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, OFFSET ?CountryNameStr@@3PAY0BE@DA	; CountryNameStr
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@ReadIndex
$LN7@ReadIndex:

; 160  : 	for (i=0; i<5; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@ReadIndex
$LN5@ReadIndex:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN6@ReadIndex:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 5
	jge	SHORT $LN4@ReadIndex

; 161  : 		ReadIndexedString(75+i,CompressionStr[i],19);

	push	19					; 00000013H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, OFFSET ?CompressionStr@@3PAY0BE@DA	; CompressionStr
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	add	ecx, 75					; 0000004bH
	push	ecx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@ReadIndex
$LN4@ReadIndex:

; 162  : 	for (i=0; i<NUM_CAMERA_LABELS; i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN3@ReadIndex
$LN2@ReadIndex:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@ReadIndex:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN1@ReadIndex

; 163  : 		ReadIndexedString(60+i,CameraLabel[i],39);

	push	39					; 00000027H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	add	edx, OFFSET ?CameraLabel@@3PAY0CI@DA	; CameraLabel
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@ReadIndex
$LN1@ReadIndex:

; 164  : 	ReadIndexedString(58,gUnitNameFormat,39);

	push	39					; 00000027H
	push	OFFSET ?gUnitNameFormat@@3PADA		; gUnitNameFormat
	push	58					; 0000003aH
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN30@ReadIndex:

; 165  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadIndex@@YAXPAD@Z ENDP				; ReadIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
_s$ = -288						; size = 4
_d$ = -284						; size = 4
_second$ = -280						; size = 3
_minute$ = -276						; size = 3
_hour$ = -272						; size = 3
_m$ = -268						; size = 4
_h$ = -264						; size = 4
_format$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_time$ = 8						; size = 4
_buffer$ = 12						; size = 4
_seconds$ = 16						; size = 4
?GetTimeString@@YAPADKQADH@Z PROC			; GetTimeString

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 99   : 	int		d,h,m,s;
; 100  : 	_TCHAR	format[MAX_STRLEN_PER_TOKEN],hour[3],minute[3],second[3];
; 101  : 
; 102  : 	d = (int)(time/CampaignDay);		

	mov	eax, DWORD PTR _time$[ebp]
	xor	edx, edx
	mov	ecx, 86400000				; 05265c00H
	div	ecx
	mov	DWORD PTR _d$[ebp], eax

; 103  : 	time -= d*CampaignDay;

	mov	edx, DWORD PTR _d$[ebp]
	imul	edx, 86400000				; 05265c00H
	mov	eax, DWORD PTR _time$[ebp]
	sub	eax, edx
	mov	DWORD PTR _time$[ebp], eax

; 104  : 	h = (int)(time/CampaignHours);

	mov	eax, DWORD PTR _time$[ebp]
	xor	edx, edx
	mov	ecx, 3600000				; 0036ee80H
	div	ecx
	mov	DWORD PTR _h$[ebp], eax

; 105  : 	_stprintf(hour,"%2.2d",h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	push	OFFSET ??_C@_05KECOGGGP@?$CF2?42d?$AA@
	lea	eax, DWORD PTR _hour$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 106  : 	time -= h*CampaignHours;

	mov	ecx, DWORD PTR _h$[ebp]
	imul	ecx, 3600000				; 0036ee80H
	mov	edx, DWORD PTR _time$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _time$[ebp], edx

; 107  : 	m = (int)(time/CampaignMinutes);

	mov	eax, DWORD PTR _time$[ebp]
	xor	edx, edx
	mov	ecx, 60000				; 0000ea60H
	div	ecx
	mov	DWORD PTR _m$[ebp], eax

; 108  : 	_stprintf(minute,"%2.2d",m);

	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	push	OFFSET ??_C@_05KECOGGGP@?$CF2?42d?$AA@
	lea	eax, DWORD PTR _minute$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 109  : 	if (seconds)

	cmp	DWORD PTR _seconds$[ebp], 0
	je	SHORT $LN3@GetTimeStr

; 110  : 		{
; 111  : 		time -= m*CampaignMinutes;

	mov	ecx, DWORD PTR _m$[ebp]
	imul	ecx, 60000				; 0000ea60H
	mov	edx, DWORD PTR _time$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _time$[ebp], edx

; 112  : 		s = (int)(time/CampaignSeconds);

	mov	eax, DWORD PTR _time$[ebp]
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR _s$[ebp], eax

; 113  : 		_stprintf(second,"%2.2d",s);

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET ??_C@_05KECOGGGP@?$CF2?42d?$AA@
	lea	eax, DWORD PTR _second$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN3@GetTimeStr:

; 114  : 		}
; 115  : 
; 116  : 	// Construct the string
; 117  : 	if (seconds)

	cmp	DWORD PTR _seconds$[ebp], 0
	je	SHORT $LN2@GetTimeStr

; 118  : 		ReadIndexedString(50, format, MAX_STRLEN_PER_TOKEN);

	push	256					; 00000100H
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	50					; 00000032H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 119  : 	else

	jmp	SHORT $LN1@GetTimeStr
$LN2@GetTimeStr:

; 120  : 		ReadIndexedString(57, format, MAX_STRLEN_PER_TOKEN);

	push	256					; 00000100H
	lea	edx, DWORD PTR _format$[ebp]
	push	edx
	push	57					; 00000039H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN1@GetTimeStr:

; 121  : 	ConstructOrderedSentence(10, buffer, format, hour, minute, second); // PJW: my size is 10 characters

	lea	eax, DWORD PTR _second$[ebp]
	push	eax
	lea	ecx, DWORD PTR _minute$[ebp]
	push	ecx
	lea	edx, DWORD PTR _hour$[ebp]
	push	edx
	lea	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	10					; 0000000aH
	call	?ConstructOrderedSentence@@YAXFPAD0ZZ	; ConstructOrderedSentence
	add	esp, 24					; 00000018H

; 122  : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 123  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTimeString@@YAPADKQADH@Z ENDP			; GetTimeString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
_tmp$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_nameid$ = 8						; size = 4
_buffer$ = 12						; size = 4
?GetNumberName@@YAPADHPAD@Z PROC			; GetNumberName

; 72   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 73   : 	_TCHAR	tmp[5];
; 74   : 
; 75   : 	if (nameid%10 == 1 && nameid != 11)

	mov	eax, DWORD PTR _nameid$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN10@GetNumberN
	cmp	DWORD PTR _nameid$[ebp], 11		; 0000000bH
	je	SHORT $LN10@GetNumberN

; 76   : 		{
; 77   : 		if (gLangIDNum == F4LANG_FRENCH)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 4		; gLangIDNum
	jne	SHORT $LN9@GetNumberN

; 78   : 			{
; 79   : 			if (nameid != 1)

	cmp	DWORD PTR _nameid$[ebp], 1
	je	SHORT $LN8@GetNumberN

; 80   : 				ReadIndexedString(16, tmp, 5);

	push	5
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	push	16					; 00000010H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 81   : 			else 

	jmp	SHORT $LN7@GetNumberN
$LN8@GetNumberN:

; 82   : 				ReadIndexedString(15, tmp, 5);

	push	5
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	15					; 0000000fH
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN7@GetNumberN:

; 83   : 			}
; 84   : 		else

	jmp	SHORT $LN6@GetNumberN
$LN9@GetNumberN:

; 85   : 			ReadIndexedString(15, tmp, 5);

	push	5
	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	push	15					; 0000000fH
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN6@GetNumberN:
	jmp	SHORT $LN5@GetNumberN
$LN10@GetNumberN:

; 86   : 		}
; 87   : 	else if (nameid%10 == 2 && nameid != 12)

	mov	eax, DWORD PTR _nameid$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	edx, 2
	jne	SHORT $LN4@GetNumberN
	cmp	DWORD PTR _nameid$[ebp], 12		; 0000000cH
	je	SHORT $LN4@GetNumberN

; 88   : 		ReadIndexedString(16, tmp, 5);

	push	5
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	push	16					; 00000010H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@GetNumberN
$LN4@GetNumberN:

; 89   : 	else if (nameid%10 == 3 && nameid != 13)

	mov	eax, DWORD PTR _nameid$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	edx, 3
	jne	SHORT $LN2@GetNumberN
	cmp	DWORD PTR _nameid$[ebp], 13		; 0000000dH
	je	SHORT $LN2@GetNumberN

; 90   : 		ReadIndexedString(17, tmp, 5);

	push	5
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	push	17					; 00000011H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 91   : 	else

	jmp	SHORT $LN5@GetNumberN
$LN2@GetNumberN:

; 92   : 		ReadIndexedString(18, tmp, 5);

	push	5
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	18					; 00000012H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN5@GetNumberN:

; 93   : 	_stprintf(buffer,"%d%s",nameid,tmp);

	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nameid$[ebp]
	push	edx
	push	OFFSET ??_C@_04LOCMGGPM@?$CFd?$CFs?$AA@
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 94   : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 95   : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberName@@YAPADHPAD@Z ENDP			; GetNumberName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\campstr.cpp
_TEXT	SEGMENT
_domain$ = 8						; size = 4
_type$ = 12						; size = 4
_stype$ = 16						; size = 4
_buffer$ = 20						; size = 4
?GetSTypeName@@YAPADHHHQAD@Z PROC			; GetSTypeName

; 59   : 	{

	push	ebp
	mov	ebp, esp

; 60   : 	if (domain == DOMAIN_AIR)

	cmp	DWORD PTR _domain$[ebp], 2
	jne	SHORT $LN6@GetSTypeNa

; 61   : 		_stprintf(buffer,AirSTypesStr[stype]);

	mov	eax, DWORD PTR _stype$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, OFFSET ?AirSTypesStr@@3PAY0BE@DA	; AirSTypesStr
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN5@GetSTypeNa
$LN6@GetSTypeNa:

; 62   : 	else if (domain == DOMAIN_LAND)

	cmp	DWORD PTR _domain$[ebp], 3
	jne	SHORT $LN4@GetSTypeNa

; 63   : 		_stprintf(buffer,GroundSTypesStr[stype]);

	mov	edx, DWORD PTR _stype$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET ?GroundSTypesStr@@3PAY0BE@DA ; GroundSTypesStr
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN5@GetSTypeNa
$LN4@GetSTypeNa:

; 64   : 	else if (domain == DOMAIN_SEA)

	cmp	DWORD PTR _domain$[ebp], 4
	jne	SHORT $LN2@GetSTypeNa

; 65   : 		_stprintf(buffer,NavalSTypesStr[stype]);

	mov	ecx, DWORD PTR _stype$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, OFFSET ?NavalSTypesStr@@3PAY0BE@DA	; NavalSTypesStr
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 66   : 	else

	jmp	SHORT $LN5@GetSTypeNa
$LN2@GetSTypeNa:

; 67   : 		_stprintf(buffer,AirSTypesStr[0]);

	mov	eax, 20					; 00000014H
	imul	eax, 0
	add	eax, OFFSET ?AirSTypesStr@@3PAY0BE@DA	; AirSTypesStr
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN5@GetSTypeNa:

; 68   : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 69   : 	}

	pop	ebp
	ret	0
?GetSTypeName@@YAPADHHHQAD@Z ENDP			; GetSTypeName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
