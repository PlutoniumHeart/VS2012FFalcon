; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPUI\Options.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?max_veh@@3PAEA					; max_veh
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
_DATA	SEGMENT
?max_veh@@3PAEA DB 08H					; max_veh
	DB	0cH
	DB	0cH
	DB	010H
	DB	010H
_DATA	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?SetNumVehicles@UnitClass@@QAEXHH@Z		; UnitClass::SetNumVehicles
PUBLIC	?CampaignEnemyAirExperience@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::CampaignEnemyAirExperience
PUBLIC	?CampaignEnemyGroundExperience@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::CampaignEnemyGroundExperience
PUBLIC	?AdjustCampaignOptions@@YAXXZ			; AdjustCampaignOptions
PUBLIC	?AdjustExperienceLevels@@YAXXZ			; AdjustExperienceLevels
PUBLIC	?AdjustForceRatios@@YAXXZ			; AdjustForceRatios
PUBLIC	?ChopCompany@@YAXPAVUnitClass@@H@Z		; ChopCompany
PUBLIC	?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z ; SquadronClass::GetPilotData
PUBLIC	?ClearMissionLists@@YAXXZ			; ClearMissionLists
PUBLIC	?ClearEventList@@YAXXZ				; ClearEventList
PUBLIC	?AdjustSquadronPilotSkills@@YAXPAVSquadronClass@@@Z ; AdjustSquadronPilotSkills
PUBLIC	__real@42c80000
EXTRN	_rand:PROC
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	?Purge@ListClass@@QAEXXZ:PROC			; ListClass::Purge
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	?DisposeEventLists@CampaignClass@@QAEXXZ:PROC	; CampaignClass::DisposeEventLists
EXTRN	?SetRoster@UnitClass@@QAEXJ@Z:PROC		; UnitClass::SetRoster
EXTRN	?SetLosses@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetLosses
EXTRN	?SetTempDest@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetTempDest
EXTRN	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ:PROC ; UnitClass::GetUnitClassData
EXTRN	?GetRClass@UnitClass@@QAEHXZ:PROC		; UnitClass::GetRClass
EXTRN	?GetTTRelations@@YAHEE@Z:PROC			; GetTTRelations
EXTRN	?GetEnemyTeam@@YAEE@Z:PROC			; GetEnemyTeam
EXTRN	?GetTeam@FalconSessionEntity@@QAEEXZ:PROC	; FalconSessionEntity::GetTeam
EXTRN	?SetRating@SquadronClass@@QAEXHE@Z:PROC		; SquadronClass::SetRating
EXTRN	?SetInitialEvents@@YAXPAD@Z:PROC		; SetInitialEvents
EXTRN	?ReadSpecialCampaignData@@YAXPAD@Z:PROC		; ReadSpecialCampaignData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A:DWORD ; SquadronStoresDataTable
EXTRN	?AllUnitList@@3PAVVuLinkedList@@A:DWORD		; AllUnitList
EXTRN	?campCritical@@3PAUF4CSECTIONHANDLE@@A:DWORD	; campCritical
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?AdjustForceRatios@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AdjustForceRatios@@YAXXZ$0
__ehfuncinfo$?AdjustForceRatios@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AdjustForceRatios@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
_skill$ = -8						; size = 4
_i$ = -4						; size = 4
_u$ = 8							; size = 4
?AdjustSquadronPilotSkills@@YAXPAVSquadronClass@@@Z PROC ; AdjustSquadronPilotSkills

; 76   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 77   : 	int		i,skill;
; 78   : 
; 79   : 	for (i=0; i<PILOTS_PER_SQUADRON; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@AdjustSqua
$LN4@AdjustSqua:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@AdjustSqua:
	cmp	DWORD PTR _i$[ebp], 48			; 00000030H
	jge	$LN6@AdjustSqua

; 80   : 		{
; 81   : 		skill = ((TeamInfo[u->GetOwner()]->airExperience - 60) / 10) + rand()%3 - 1;

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, BYTE PTR [edx+612]
	sub	eax, 60					; 0000003cH
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	esi, eax
	call	_rand
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [esi+edx-1]
	mov	DWORD PTR _skill$[ebp], edx

; 82   : 		if (skill > 4)

	cmp	DWORD PTR _skill$[ebp], 4
	jle	SHORT $LN2@AdjustSqua

; 83   : 			skill = 4;

	mov	DWORD PTR _skill$[ebp], 4
$LN2@AdjustSqua:

; 84   : 		if (skill < 0)

	cmp	DWORD PTR _skill$[ebp], 0
	jge	SHORT $LN1@AdjustSqua

; 85   : 			skill = 0;

	mov	DWORD PTR _skill$[ebp], 0
$LN1@AdjustSqua:

; 86   : 		u->GetPilotData(i)->pilot_skill_and_rating = 0x30 | skill;

	mov	ebx, DWORD PTR _skill$[ebp]
	or	ebx, 48					; 00000030H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z ; SquadronClass::GetPilotData
	mov	BYTE PTR [eax+2], bl

; 87   : 		u->GetPilotData(i)->pilot_status = PILOT_AVAILABLE;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z ; SquadronClass::GetPilotData
	mov	BYTE PTR [eax+3], 0

; 88   : 		u->GetPilotData(i)->missions_flown = 0;

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z ; SquadronClass::GetPilotData
	xor	ecx, ecx
	mov	WORD PTR [eax+8], cx

; 89   : 		}

	jmp	$LN4@AdjustSqua
$LN6@AdjustSqua:

; 90   : 	}

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustSquadronPilotSkills@@YAXPAVSquadronClass@@@Z ENDP ; AdjustSquadronPilotSkills
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
?ClearEventList@@YAXXZ PROC				; ClearEventList

; 54   : 	{

	push	ebp
	mov	ebp, esp

; 55   : 	TheCampaign.DisposeEventLists();

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?DisposeEventLists@CampaignClass@@QAEXXZ ; CampaignClass::DisposeEventLists

; 56   : 	}

	pop	ebp
	ret	0
?ClearEventList@@YAXXZ ENDP				; ClearEventList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
_i$1 = -4						; size = 4
?ClearMissionLists@@YAXXZ PROC				; ClearMissionLists

; 48   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 49   : 	for (int i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ClearMissi
$LN2@ClearMissi:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ClearMissi:
	cmp	DWORD PTR _i$1[ebp], 8
	jge	SHORT $LN4@ClearMissi

; 50   : 		TeamInfo[i]->atm->requestList->Purge();

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+876]
	mov	ecx, DWORD PTR [eax+180]
	call	?Purge@ListClass@@QAEXXZ		; ListClass::Purge
	jmp	SHORT $LN2@ClearMissi
$LN4@ClearMissi:

; 51   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearMissionLists@@YAXXZ ENDP				; ClearMissionLists
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\squadron.h
;	COMDAT ?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pilot$ = 8						; size = 4
?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z PROC	; SquadronClass::GetPilotData, COMDAT
; _this$ = ecx

; 146  : 	PilotClass* GetPilotData (int pilot)			{ return &pilot_data[pilot]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pilot$[ebp]
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+866]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPilotData@SquadronClass@@QAEPAVPilotClass@@H@Z ENDP	; SquadronClass::GetPilotData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
_slot$ = -4						; size = 4
_u$ = 8							; size = 4
_crating$ = 12						; size = 4
?ChopCompany@@YAXPAVUnitClass@@H@Z PROC			; ChopCompany

; 224  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	int		slot;
; 226  : 
; 227  : 	for (slot = max_veh[crating]; slot < VEHICLE_GROUPS_PER_UNIT; slot++)

	mov	eax, DWORD PTR _crating$[ebp]
	movzx	ecx, BYTE PTR ?max_veh@@3PAEA[eax]
	mov	DWORD PTR _slot$[ebp], ecx
	jmp	SHORT $LN3@ChopCompan
$LN2@ChopCompan:
	mov	edx, DWORD PTR _slot$[ebp]
	add	edx, 1
	mov	DWORD PTR _slot$[ebp], edx
$LN3@ChopCompan:
	cmp	DWORD PTR _slot$[ebp], 16		; 00000010H
	jge	SHORT $LN4@ChopCompan

; 228  : 		u->SetNumVehicles(slot,0);

	push	0
	mov	eax, DWORD PTR _slot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles
	jmp	SHORT $LN2@ChopCompan
$LN4@ChopCompan:

; 229  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ChopCompany@@YAXPAVUnitClass@@H@Z ENDP			; ChopCompany
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
_myit$ = -104						; size = 12
_ratio$2 = -92						; size = 4
_fuel$3 = -88						; size = 4
_uc$4 = -84						; size = 4
_uc$5 = -80						; size = 4
_ergu$ = -76						; size = 4
_erad$ = -72						; size = 4
_ernu$ = -68						; size = 4
_erau$ = -64						; size = 4
_prgu$ = -60						; size = 4
_prad$ = -56						; size = 4
_prnu$ = -52						; size = 4
_prau$ = -48						; size = 4
tv240 = -44						; size = 4
_j$6 = -40						; size = 4
_i$7 = -36						; size = 4
_eteam$ = -32						; size = 4
_slot$8 = -28						; size = 4
_pteam$ = -24						; size = 4
_t$ = -20						; size = 4
_u$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?AdjustForceRatios@@YAXXZ PROC				; AdjustForceRatios

; 93   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AdjustForceRatios@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 94   : 	Unit			u;
; 95   : 	int				eteam,pteam,prgu,ergu,prad,erad,prau,erau,prnu,ernu,t;
; 96   : 
; 97   : 	pteam = FalconLocalSession->GetTeam();

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	eax, al
	mov	DWORD PTR _pteam$[ebp], eax

; 98   : 	eteam = GetEnemyTeam(pteam);

	movzx	ecx, BYTE PTR _pteam$[ebp]
	push	ecx
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _eteam$[ebp], edx

; 99   : 	prgu = TheCampaign.GroundRatio;

	movsx	eax, WORD PTR ?TheCampaign@@3VCampaignClass@@A+74
	mov	DWORD PTR _prgu$[ebp], eax

; 100  : 	ergu = 4 - prgu;

	mov	ecx, 4
	sub	ecx, DWORD PTR _prgu$[ebp]
	mov	DWORD PTR _ergu$[ebp], ecx

; 101  : 	prad = TheCampaign.AirDefenseRatio;

	movsx	edx, WORD PTR ?TheCampaign@@3VCampaignClass@@A+78
	mov	DWORD PTR _prad$[ebp], edx

; 102  : 	erad = 4 - prad;

	mov	eax, 4
	sub	eax, DWORD PTR _prad$[ebp]
	mov	DWORD PTR _erad$[ebp], eax

; 103  : 	prau = TheCampaign.AirRatio;

	movsx	ecx, WORD PTR ?TheCampaign@@3VCampaignClass@@A+76
	mov	DWORD PTR _prau$[ebp], ecx

; 104  : 	erau = 4 - prau;

	mov	edx, 4
	sub	edx, DWORD PTR _prau$[ebp]
	mov	DWORD PTR _erau$[ebp], edx

; 105  : 	prnu = TheCampaign.NavalRatio;

	movsx	eax, WORD PTR ?TheCampaign@@3VCampaignClass@@A+80
	mov	DWORD PTR _prnu$[ebp], eax

; 106  : 	ernu = 4 - prnu;

	mov	ecx, 4
	sub	ecx, DWORD PTR _prnu$[ebp]
	mov	DWORD PTR _ernu$[ebp], ecx

; 107  : 
; 108  : 	// Set the max vehicle slot by team
; 109  : 	for (t=0; t<NUM_TEAMS; t++)

	mov	DWORD PTR _t$[ebp], 0
	jmp	SHORT $LN47@AdjustForc
$LN46@AdjustForc:
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
$LN47@AdjustForc:
	cmp	DWORD PTR _t$[ebp], 8
	jge	$LN45@AdjustForc

; 110  : 	{
; 111  : 		if (t == pteam)

	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _pteam$[ebp]
	jne	$LN44@AdjustForc

; 112  : 		{
; 113  : 			TeamInfo[t]->max_vehicle[RCLASS_AIR]		= max_veh[prau];

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _prau$[ebp]
	mov	cl, BYTE PTR ?max_veh@@3PAEA[ecx]
	mov	BYTE PTR [edx+eax+872], cl

; 114  : 			TeamInfo[t]->max_vehicle[RCLASS_GROUND]		= max_veh[prgu];

	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _prgu$[ebp]
	mov	dl, BYTE PTR ?max_veh@@3PAEA[edx]
	mov	BYTE PTR [eax+ecx+872], dl

; 115  : 			TeamInfo[t]->max_vehicle[RCLASS_AIRDEFENSE]	= max_veh[prad];

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _prad$[ebp]
	mov	al, BYTE PTR ?max_veh@@3PAEA[eax]
	mov	BYTE PTR [ecx+edx+872], al

; 116  : 			TeamInfo[t]->max_vehicle[RCLASS_NAVAL]		= max_veh[prnu];

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _prnu$[ebp]
	mov	cl, BYTE PTR ?max_veh@@3PAEA[ecx]
	mov	BYTE PTR [edx+eax+872], cl
	jmp	$LN41@AdjustForc
$LN44@AdjustForc:

; 117  : 		}
; 118  : 		else if (t == eteam)

	mov	edx, DWORD PTR _t$[ebp]
	cmp	edx, DWORD PTR _eteam$[ebp]
	jne	$LN42@AdjustForc

; 119  : 		{
; 120  : 			TeamInfo[t]->max_vehicle[RCLASS_AIR]		= max_veh[erau];

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _erau$[ebp]
	mov	al, BYTE PTR ?max_veh@@3PAEA[eax]
	mov	BYTE PTR [ecx+edx+872], al

; 121  : 			TeamInfo[t]->max_vehicle[RCLASS_GROUND]		= max_veh[ergu];

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ergu$[ebp]
	mov	cl, BYTE PTR ?max_veh@@3PAEA[ecx]
	mov	BYTE PTR [edx+eax+872], cl

; 122  : 			TeamInfo[t]->max_vehicle[RCLASS_AIRDEFENSE]	= max_veh[erad];

	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _erad$[ebp]
	mov	dl, BYTE PTR ?max_veh@@3PAEA[edx]
	mov	BYTE PTR [eax+ecx+872], dl

; 123  : 			TeamInfo[t]->max_vehicle[RCLASS_NAVAL]		= max_veh[ernu];

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _ernu$[ebp]
	mov	al, BYTE PTR ?max_veh@@3PAEA[eax]
	mov	BYTE PTR [ecx+edx+872], al

; 124  : 		}
; 125  : 		else

	jmp	SHORT $LN41@AdjustForc
$LN42@AdjustForc:

; 126  : 		{
; 127  : 			TeamInfo[t]->max_vehicle[RCLASS_AIR]		= VEHICLE_GROUPS_PER_UNIT;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR [edx+eax+872], 16		; 00000010H

; 128  : 			TeamInfo[t]->max_vehicle[RCLASS_GROUND]		= VEHICLE_GROUPS_PER_UNIT;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR [edx+eax+872], 16		; 00000010H

; 129  : 			TeamInfo[t]->max_vehicle[RCLASS_AIRDEFENSE]	= VEHICLE_GROUPS_PER_UNIT;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR [edx+eax+872], 16		; 00000010H

; 130  : 			TeamInfo[t]->max_vehicle[RCLASS_NAVAL]		= VEHICLE_GROUPS_PER_UNIT;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, 1
	imul	eax, 3
	mov	BYTE PTR [edx+eax+872], 16		; 00000010H
$LN41@AdjustForc:

; 131  : 		}
; 132  : 	}

	jmp	$LN46@AdjustForc
$LN45@AdjustForc:

; 133  : 
; 134  : 	// Traverse all our real units, adjusting force strengths as necessary
; 135  : 	VuListIterator	myit(AllUnitList);

	mov	ecx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	ecx
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 136  : 	u = (Unit) myit.GetFirst();

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN40@AdjustForc:

; 137  : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN39@AdjustForc

; 138  : 	{
; 139  : 		// Fill the unit to capacity before chopping shit - NOTE: this shouldn't be callled after a
; 140  : 		// LoadCampaign, so these are fresh scenarios - Also, flights shouldn't be filled.
; 141  : 		u->SetLosses (0);

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetLosses@UnitClass@@QAEXH@Z		; UnitClass::SetLosses

; 142  : 		if (!u->IsFlight())

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	jne	SHORT $LN35@AdjustForc

; 143  : 		{
; 144  : 			UnitClassDataType	*uc = u->GetUnitClassData();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$4[ebp], eax

; 145  : 			for (int slot=0; slot<VEHICLE_GROUPS_PER_UNIT; slot++)

	mov	DWORD PTR _slot$8[ebp], 0
	jmp	SHORT $LN37@AdjustForc
$LN36@AdjustForc:
	mov	eax, DWORD PTR _slot$8[ebp]
	add	eax, 1
	mov	DWORD PTR _slot$8[ebp], eax
$LN37@AdjustForc:
	cmp	DWORD PTR _slot$8[ebp], 16		; 00000010H
	jge	SHORT $LN35@AdjustForc

; 146  : 				u->SetNumVehicles(slot,uc->NumElements[slot]);

	mov	ecx, DWORD PTR _slot$8[ebp]
	mov	edx, DWORD PTR _uc$4[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR _slot$8[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles
	jmp	SHORT $LN36@AdjustForc
$LN35@AdjustForc:

; 147  : 		}
; 148  : 		if (u->GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 3
	jne	SHORT $LN34@AdjustForc

; 149  : 		{
; 150  : 			// KCK: This triggers recalculation of our final destination.
; 151  : 			// Only really usefull if our objective moves out from under us.
; 152  : 			u->SetTempDest(1);

	push	1
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest
$LN34@AdjustForc:

; 153  : 		}
; 154  : 		// Now chop companies
; 155  : 		switch (u->GetRClass())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	mov	DWORD PTR tv240[ebp], eax
	cmp	DWORD PTR tv240[ebp], 0
	je	SHORT $LN31@AdjustForc
	cmp	DWORD PTR tv240[ebp], 2
	je	$LN20@AdjustForc
	cmp	DWORD PTR tv240[ebp], 3
	je	$LN25@AdjustForc
	jmp	$LN15@AdjustForc
$LN31@AdjustForc:

; 156  : 		{
; 157  : 			case RCLASS_AIR:
; 158  : 				if (u->GetTeam() == pteam)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _pteam$[ebp]
	jne	SHORT $LN30@AdjustForc

; 159  : 					ChopCompany(u, prau);

	mov	edx, DWORD PTR _prau$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
	jmp	SHORT $LN27@AdjustForc
$LN30@AdjustForc:

; 160  : 				else if (u->GetTeam() == eteam)

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _eteam$[ebp]
	jne	SHORT $LN28@AdjustForc

; 161  : 					ChopCompany(u, erau);

	mov	edx, DWORD PTR _erau$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8

; 162  : 				else

	jmp	SHORT $LN27@AdjustForc
$LN28@AdjustForc:

; 163  : 					ChopCompany(u, DEFAULT_COMPANY_RATIO);

	push	2
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
$LN27@AdjustForc:

; 164  : 				if (u->IsSquadron())

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx
	test	eax, eax
	je	SHORT $LN26@AdjustForc

; 165  : 					AdjustSquadronPilotSkills((Squadron)u);

	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?AdjustSquadronPilotSkills@@YAXPAVSquadronClass@@@Z ; AdjustSquadronPilotSkills
	add	esp, 4
$LN26@AdjustForc:

; 166  : 			break;

	jmp	$LN32@AdjustForc
$LN25@AdjustForc:

; 167  : 			case RCLASS_NAVAL:
; 168  : 				if (u->GetTeam() == pteam)

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _pteam$[ebp]
	jne	SHORT $LN24@AdjustForc

; 169  : 					ChopCompany(u, prnu);

	mov	edx, DWORD PTR _prnu$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
	jmp	SHORT $LN21@AdjustForc
$LN24@AdjustForc:

; 170  : 				else if (u->GetTeam() == eteam)

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _eteam$[ebp]
	jne	SHORT $LN22@AdjustForc

; 171  : 					ChopCompany(u, ernu);

	mov	edx, DWORD PTR _ernu$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8

; 172  : 				else

	jmp	SHORT $LN21@AdjustForc
$LN22@AdjustForc:

; 173  : 					ChopCompany(u, DEFAULT_COMPANY_RATIO);

	push	2
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
$LN21@AdjustForc:

; 174  : 			break;

	jmp	$LN32@AdjustForc
$LN20@AdjustForc:

; 175  : 			case RCLASS_AIRDEFENSE:
; 176  : 				if (u->GetTeam() == pteam)

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	eax, DWORD PTR _pteam$[ebp]
	jne	SHORT $LN19@AdjustForc

; 177  : 					ChopCompany(u, prad);

	mov	ecx, DWORD PTR _prad$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
	jmp	SHORT $LN16@AdjustForc
$LN19@AdjustForc:

; 178  : 				else if (u->GetTeam() == eteam)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _eteam$[ebp]
	jne	SHORT $LN17@AdjustForc

; 179  : 					ChopCompany(u, erad);

	mov	edx, DWORD PTR _erad$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8

; 180  : 				else

	jmp	SHORT $LN16@AdjustForc
$LN17@AdjustForc:

; 181  : 					ChopCompany(u, DEFAULT_COMPANY_RATIO);

	push	2
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
$LN16@AdjustForc:

; 182  : 			break;

	jmp	SHORT $LN32@AdjustForc
$LN15@AdjustForc:

; 183  : 			default:
; 184  : 				if (u->GetTeam() == pteam)

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	eax, DWORD PTR _pteam$[ebp]
	jne	SHORT $LN14@AdjustForc

; 185  : 					ChopCompany(u, prgu);

	mov	ecx, DWORD PTR _prgu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
	jmp	SHORT $LN11@AdjustForc
$LN14@AdjustForc:

; 186  : 				else if (u->GetTeam() == eteam)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _eteam$[ebp]
	jne	SHORT $LN12@AdjustForc

; 187  : 					ChopCompany(u, ergu);

	mov	edx, DWORD PTR _ergu$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8

; 188  : 				else

	jmp	SHORT $LN11@AdjustForc
$LN12@AdjustForc:

; 189  : 					ChopCompany(u, DEFAULT_COMPANY_RATIO);

	push	2
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?ChopCompany@@YAXPAVUnitClass@@H@Z	; ChopCompany
	add	esp, 8
$LN11@AdjustForc:
$LN32@AdjustForc:

; 190  : 			break;
; 191  : 		}
; 192  : 		// Resupply to the team's supply level
; 193  : 		if (u->Real() && (u->GetDomain() == DOMAIN_LAND || u->GetDomain() == DOMAIN_SEA))

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+508]
	call	edx
	test	eax, eax
	je	SHORT $LN10@AdjustForc
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	je	SHORT $LN9@AdjustForc
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 4
	jne	SHORT $LN10@AdjustForc
$LN9@AdjustForc:

; 194  : 			u->SetUnitSupply(TeamInfo[u->GetTeam()]->startStats.supplyLevel);

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	edx, BYTE PTR [ecx+630]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+748]
	call	eax
	jmp	$LN1@AdjustForc
$LN10@AdjustForc:

; 195  : 		else if (u->IsSquadron())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	$LN1@AdjustForc

; 196  : 		{
; 197  : 			UnitClassDataType*	uc = u->GetUnitClassData();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$5[ebp], eax

; 198  : 			long				fuel;
; 199  : 			float				ratio;
; 200  : 
; 201  : 			ShiAssert( uc );
; 202  : 
; 203  : 			// Squadrons want enough fuel to load each plane SQUADRON_MISSIONS_PER_HOUR times per hour for 2 supply periods
; 204  : //			fuel = (((uc->Fuel * u->GetTotalVehicles() * SQUADRON_MISSIONS_PER_HOUR*2*MIN_RESUPPLY)/60) * TeamInfo[u->GetTeam()]->startStats.fuelLevel)/100;
; 205  : 			fuel = ((u->GetUnitFuelNeed(FALSE) + u->GetUnitFuelNeed(TRUE)) * TeamInfo[u->GetTeam()]->startStats.fuelLevel) / 100;

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	add	esi, eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, BYTE PTR [edx+631]
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _fuel$3[ebp], eax

; 206  : 			u->SetSquadronFuel(fuel*SUPPLY_PT_FUEL);

	mov	edx, DWORD PTR _fuel$3[ebp]
	imul	edx, 10000				; 00002710H
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+756]
	call	eax

; 207  : 
; 208  : 			// Now let's add our munititions
; 209  : 			ratio = (float)(TeamInfo[u->GetTeam()]->startStats.supplyLevel)/100.0F;

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, BYTE PTR [edx+630]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _ratio$2[ebp], xmm0

; 210  : 			for (int i=0; i<MAXIMUM_WEAPTYPES; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN6@AdjustForc
$LN5@AdjustForc:
	mov	ecx, DWORD PTR _i$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7[ebp], ecx
$LN6@AdjustForc:
	cmp	DWORD PTR _i$7[ebp], 600		; 00000258H
	jge	SHORT $LN4@AdjustForc

; 211  : 				u->SetUnitStores(i, FloatToInt32(ratio*SquadronStoresDataTable[uc->SpecialIndex].Stores[i]));

	mov	edx, DWORD PTR _uc$5[ebp]
	movsx	eax, WORD PTR [edx+330]
	imul	eax, 603				; 0000025bH
	add	eax, DWORD PTR ?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A ; SquadronStoresDataTable
	mov	ecx, DWORD PTR _i$7[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _ratio$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _i$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+760]
	call	eax
	jmp	SHORT $LN5@AdjustForc
$LN4@AdjustForc:

; 212  : 
; 213  : 			// Reset our stats
; 214  : 			for (int j=0; j<ARO_OTHER; j++)

	mov	DWORD PTR _j$6[ebp], 0
	jmp	SHORT $LN3@AdjustForc
$LN2@AdjustForc:
	mov	ecx, DWORD PTR _j$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$6[ebp], ecx
$LN3@AdjustForc:
	cmp	DWORD PTR _j$6[ebp], 16			; 00000010H
	jge	SHORT $LN1@AdjustForc

; 215  : 				((Squadron)u)->SetRating(j, uc->Scores[j]);

	mov	edx, DWORD PTR _uc$5[ebp]
	add	edx, DWORD PTR _j$6[ebp]
	movzx	eax, BYTE PTR [edx+268]
	push	eax
	mov	ecx, DWORD PTR _j$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetRating@SquadronClass@@QAEXHE@Z	; SquadronClass::SetRating
	jmp	SHORT $LN2@AdjustForc
$LN1@AdjustForc:

; 216  : 		}
; 217  : 
; 218  : 		u = (Unit) myit.GetNext();

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 219  : 	}

	jmp	$LN40@AdjustForc
$LN39@AdjustForc:

; 220  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AdjustForceRatios@@YAXXZ$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?AdjustForceRatios@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AdjustForceRatios@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AdjustForceRatios@@YAXXZ ENDP				; AdjustForceRatios
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
?AdjustExperienceLevels@@YAXXZ PROC			; AdjustExperienceLevels

; 59   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 60   : 	int i;
; 61   : 
; 62   : 	for (i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@AdjustExpe
$LN3@AdjustExpe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@AdjustExpe:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN2@AdjustExpe

; 63   : 		{
; 64   : 		if (GetTTRelations(FalconLocalSession->GetTeam(),i) == War)

	movzx	ecx, BYTE PTR _i$[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	edx, al
	push	edx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN1@AdjustExpe

; 65   : 			{
; 66   : 			TeamInfo[i]->airExperience = PlayerOptions.CampaignEnemyAirExperience() * 10 + 60;

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?CampaignEnemyAirExperience@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::CampaignEnemyAirExperience
	imul	eax, 10					; 0000000aH
	add	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	BYTE PTR [edx+612], al

; 67   : 			TeamInfo[i]->airDefenseExperience = PlayerOptions.CampaignEnemyGroundExperience() * 10 + 60;

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?CampaignEnemyGroundExperience@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::CampaignEnemyGroundExperience
	imul	eax, 10					; 0000000aH
	add	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	BYTE PTR [edx+613], al
$LN1@AdjustExpe:

; 68   : 			}
; 69   : 		}

	jmp	SHORT $LN3@AdjustExpe
$LN2@AdjustExpe:

; 70   : // 2002-04-16 MN place this here, so that the campaign data stuff
; 71   : // from trigger files is read in when starting a saved campaign, too..
; 72   : 	ReadSpecialCampaignData(TheCampaign.Scenario);

	push	OFFSET ?TheCampaign@@3VCampaignClass@@A+142
	call	?ReadSpecialCampaignData@@YAXPAD@Z	; ReadSpecialCampaignData
	add	esp, 4

; 73   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustExperienceLevels@@YAXXZ ENDP			; AdjustExperienceLevels
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\campui\options.cpp
_TEXT	SEGMENT
?AdjustCampaignOptions@@YAXXZ PROC			; AdjustCampaignOptions

; 34   : 	{

	push	ebp
	mov	ebp, esp

; 35   : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 36   : 	AdjustExperienceLevels();

	call	?AdjustExperienceLevels@@YAXXZ		; AdjustExperienceLevels

; 37   : 	AdjustForceRatios();

	call	?AdjustForceRatios@@YAXXZ		; AdjustForceRatios

; 38   : 	// KCK: Don't muck with the mission list on a non-campaign thread.
; 39   : 	// I'd rather be certain to clear them when saving new games
; 40   : //	ClearMissionLists();
; 41   : //	NukeHistoryFiles();
; 42   : 	ClearEventList();

	call	?ClearEventList@@YAXXZ			; ClearEventList

; 43   : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 44   : 	SetInitialEvents(TheCampaign.Scenario);

	push	OFFSET ?TheCampaign@@3VCampaignClass@@A+142
	call	?SetInitialEvents@@YAXPAD@Z		; SetInitialEvents
	add	esp, 4

; 45   : 	}

	pop	ebp
	ret	0
?AdjustCampaignOptions@@YAXXZ ENDP			; AdjustCampaignOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?CampaignEnemyGroundExperience@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CampaignEnemyGroundExperience@PlayerOptionsClass@@QAEHXZ PROC ; PlayerOptionsClass::CampaignEnemyGroundExperience, COMDAT
; _this$ = ecx

; 173  : 	int CampaignEnemyGroundExperience (void)				{ return CampEnemyGroundExperience; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+108]
	mov	esp, ebp
	pop	ebp
	ret	0
?CampaignEnemyGroundExperience@PlayerOptionsClass@@QAEHXZ ENDP ; PlayerOptionsClass::CampaignEnemyGroundExperience
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?CampaignEnemyAirExperience@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CampaignEnemyAirExperience@PlayerOptionsClass@@QAEHXZ PROC ; PlayerOptionsClass::CampaignEnemyAirExperience, COMDAT
; _this$ = ecx

; 172  : 	int CampaignEnemyAirExperience (void)					{ return CampEnemyAirExperience; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]
	mov	esp, ebp
	pop	ebp
	ret	0
?CampaignEnemyAirExperience@PlayerOptionsClass@@QAEHXZ ENDP ; PlayerOptionsClass::CampaignEnemyAirExperience
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetNumVehicles@UnitClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vg$ = 8						; size = 4
_n$ = 12						; size = 4
?SetNumVehicles@UnitClass@@QAEXHH@Z PROC		; UnitClass::SetNumVehicles, COMDAT
; _this$ = ecx

; 358  : 	void SetNumVehicles(int vg, int n)				{ SetRoster((roster & ~(3<<(vg*2))) | ((n & 0x03) << (vg*2))); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	mov	eax, 3
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _n$[ebp]
	and	edx, 3
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	shl	edx, cl
	or	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoster@UnitClass@@QAEXJ@Z		; UnitClass::SetRoster
	mov	esp, ebp
	pop	ebp
	ret	8
?SetNumVehicles@UnitClass@@QAEXHH@Z ENDP		; UnitClass::SetNumVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
END
