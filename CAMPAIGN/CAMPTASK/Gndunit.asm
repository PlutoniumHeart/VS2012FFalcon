; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPTASK\Gndunit.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?Offsets@@3PAY152EA				; Offsets
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?OrderPriority@@3PAHA				; OrderPriority
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
_DATA	SEGMENT
?Offsets@@3PAY152EA DB 00H				; Offsets
	DB	08H
	DB	08H
	DB	00H
	DB	07H
	DB	08H
	DB	00H
	DB	00H
	DB	08H
	DB	00H
	DB	01H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	01H
	DB	08H
	DB	08H
	DB	01H
	DB	00H
	DB	08H
	DB	01H
	DB	02H
	DB	08H
	DB	01H
	DB	01H
	DB	08H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	08H
	DB	08H
	DB	02H
	DB	01H
	DB	08H
	DB	02H
	DB	02H
	DB	08H
	DB	02H
	DB	03H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	03H
	DB	08H
	DB	08H
	DB	03H
	DB	02H
	DB	08H
	DB	03H
	DB	04H
	DB	08H
	DB	03H
	DB	03H
	DB	08H
	DB	03H
	DB	02H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	08H
	DB	04H
	DB	03H
	DB	08H
	DB	04H
	DB	04H
	DB	08H
	DB	04H
	DB	05H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	05H
	DB	08H
	DB	08H
	DB	05H
	DB	04H
	DB	08H
	DB	05H
	DB	06H
	DB	08H
	DB	05H
	DB	05H
	DB	08H
	DB	05H
	DB	04H
	DB	04H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	08H
	DB	08H
	DB	06H
	DB	05H
	DB	08H
	DB	06H
	DB	06H
	DB	08H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	07H
	DB	08H
	DB	08H
	DB	07H
	DB	08H
	DB	08H
	DB	07H
	DB	00H
	DB	08H
	DB	07H
	DB	07H
	DB	08H
	DB	07H
	DB	06H
	DB	06H
	DB	07H
	DB	00H
	DB	00H
?OrderPriority@@3PAHA DD 02H				; OrderPriority
	DD	0aH
	DD	09H
	DD	08H
	DD	08H
	DD	07H
	DD	06H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	03H
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??9VU_ID@@QBE_NABV0@@Z				; VU_ID::operator!=
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ		; VuEntity::VuState
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ	; VuBin<VuEntity>::get
PUBLIC	?IsSimBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsSimBase
PUBLIC	?GetRadarMode@FalconEntity@@UAEHXZ		; FalconEntity::GetRadarMode
PUBLIC	?SetRadarMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetRadarMode
PUBLIC	?ReturnToSearch@FalconEntity@@UAEXXZ		; FalconEntity::ReturnToSearch
PUBLIC	?SetSearchMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetSearchMode
PUBLIC	?CombatClass@FalconEntity@@UAEHXZ		; FalconEntity::CombatClass
PUBLIC	?IsMissile@FalconEntity@@UAEHXZ			; FalconEntity::IsMissile
PUBLIC	?IsLauncher@FalconEntity@@UAEHXZ		; FalconEntity::IsLauncher
PUBLIC	?IsBomb@FalconEntity@@UAEHXZ			; FalconEntity::IsBomb
PUBLIC	?IsGun@FalconEntity@@UAEHXZ			; FalconEntity::IsGun
PUBLIC	?IsMover@FalconEntity@@UAEHXZ			; FalconEntity::IsMover
PUBLIC	?IsVehicle@FalconEntity@@UAEHXZ			; FalconEntity::IsVehicle
PUBLIC	?IsStatic@FalconEntity@@UAEHXZ			; FalconEntity::IsStatic
PUBLIC	?IsHelicopter@FalconEntity@@UAEHXZ		; FalconEntity::IsHelicopter
PUBLIC	?IsEject@FalconEntity@@UAEHXZ			; FalconEntity::IsEject
PUBLIC	?IsAirplane@FalconEntity@@UAEHXZ		; FalconEntity::IsAirplane
PUBLIC	?IsGroundVehicle@FalconEntity@@UAEHXZ		; FalconEntity::IsGroundVehicle
PUBLIC	?IsShip@FalconEntity@@UAEHXZ			; FalconEntity::IsShip
PUBLIC	?IsWeapon@FalconEntity@@UAEHXZ			; FalconEntity::IsWeapon
PUBLIC	?IsExploding@FalconEntity@@UAEHXZ		; FalconEntity::IsExploding
PUBLIC	?IsDead@FalconEntity@@UAEHXZ			; FalconEntity::IsDead
PUBLIC	?IsObjective@FalconEntity@@UAEHXZ		; FalconEntity::IsObjective
PUBLIC	?IsBattalion@FalconEntity@@UAEHXZ		; FalconEntity::IsBattalion
PUBLIC	?IsBrigade@FalconEntity@@UAEHXZ			; FalconEntity::IsBrigade
PUBLIC	?IsFlight@FalconEntity@@UBEHXZ			; FalconEntity::IsFlight
PUBLIC	?IsSquadron@FalconEntity@@UAEHXZ		; FalconEntity::IsSquadron
PUBLIC	?IsPackage@FalconEntity@@UAEHXZ			; FalconEntity::IsPackage
PUBLIC	?IsTeam@FalconEntity@@UAEHXZ			; FalconEntity::IsTeam
PUBLIC	?IsTaskForce@FalconEntity@@UAEHXZ		; FalconEntity::IsTaskForce
PUBLIC	?IsSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsSPJamming
PUBLIC	?IsAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsAreaJamming
PUBLIC	?HasSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasSPJamming
PUBLIC	?HasAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasAreaJamming
PUBLIC	?SetAQUIREtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetAQUIREtimer
PUBLIC	?SetSEARCHtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetSEARCHtimer
PUBLIC	?SetStepSearchMode@FalconEntity@@UAEXE@Z	; FalconEntity::SetStepSearchMode
PUBLIC	?GetAQUIREtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetAQUIREtimer
PUBLIC	?GetSEARCHtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetSEARCHtimer
PUBLIC	?GetUserData@ListElementClass@@QAEPAXXZ		; ListElementClass::GetUserData
PUBLIC	?GetKey@ListElementClass@@QAEFXZ		; ListElementClass::GetKey
PUBLIC	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
PUBLIC	?GetLength@BasePathClass@@QAEHXZ		; BasePathClass::GetLength
PUBLIC	?GetCost@BasePathClass@@QAEMXZ			; BasePathClass::GetCost
PUBLIC	??1PathClass@@QAE@XZ				; PathClass::~PathClass
PUBLIC	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
PUBLIC	??1InvalidBufferException@@UAE@XZ		; InvalidBufferException::~InvalidBufferException
PUBLIC	??0InvalidBufferException@@QAE@ABV0@@Z		; InvalidBufferException::InvalidBufferException
PUBLIC	??_GInvalidBufferException@@UAEPAXI@Z		; InvalidBufferException::`scalar deleting destructor'
PUBLIC	?memcpychk@@YAXPAXPAPAEIPAJ@Z			; memcpychk
PUBLIC	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
PUBLIC	?GetCampID@CampBaseClass@@UAEFXZ		; CampBaseClass::GetCampID
PUBLIC	?GetTeam@CampBaseClass@@UAEEXZ			; CampBaseClass::GetTeam
PUBLIC	?GetCountry@CampBaseClass@@UAEEXZ		; CampBaseClass::GetCountry
PUBLIC	?StepRadar@CampBaseClass@@UAEHHHM@Z		; CampBaseClass::StepRadar
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?GetMissilesFlying@CampBaseClass@@UAEHXZ	; CampBaseClass::GetMissilesFlying
PUBLIC	?IsCampBase@CampBaseClass@@UAE_NXZ		; CampBaseClass::IsCampBase
PUBLIC	?IsEmitting@CampBaseClass@@UAEHXZ		; CampBaseClass::IsEmitting
PUBLIC	?IsChecked@CampBaseClass@@QAEHXZ		; CampBaseClass::IsChecked
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z	; CampBaseClass::HasEntity
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?SetChecked@CampBaseClass@@QAEXXZ		; CampBaseClass::SetChecked
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?IsFrontline@ObjectiveClass@@QAEHXZ		; ObjectiveClass::IsFrontline
PUBLIC	?IsSecondline@ObjectiveClass@@QAEHXZ		; ObjectiveClass::IsSecondline
PUBLIC	?IsThirdline@ObjectiveClass@@QAEHXZ		; ObjectiveClass::IsThirdline
PUBLIC	?SamSite@ObjectiveClass@@QAEHXZ			; ObjectiveClass::SamSite
PUBLIC	?Abandoned@ObjectiveClass@@QAEHXZ		; ObjectiveClass::Abandoned
PUBLIC	?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ; ObjectiveClass::GetNeighborCost
PUBLIC	?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ	; ObjectiveClass::GetObjectiveParent
PUBLIC	?GetObjectiveParentID@ObjectiveClass@@QAE?AVVU_ID@@XZ ; ObjectiveClass::GetObjectiveParentID
PUBLIC	?NumLinks@ObjectiveClass@@QAEHXZ		; ObjectiveClass::NumLinks
PUBLIC	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ	; ObjectiveClass::GetObjectiveStatus
PUBLIC	?GetObjectiveScore@ObjectiveClass@@QAEHXZ	; ObjectiveClass::GetObjectiveScore
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ		; UnitClass::GetCargoId
PUBLIC	?CanShootWeapon@UnitClass@@UAEHH@Z		; UnitClass::CanShootWeapon
PUBLIC	?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z ; UnitClass::GetDeaggregationPoint
PUBLIC	?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ ; UnitClass::GetUnitDeaggregationData
PUBLIC	?ShouldDeaggregate@UnitClass@@UAEHXZ		; UnitClass::ShouldDeaggregate
PUBLIC	?ClearDeaggregationData@UnitClass@@UAEXXZ	; UnitClass::ClearDeaggregationData
PUBLIC	?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z	; UnitClass::Reaction
PUBLIC	?MoveUnit@UnitClass@@UAEHK@Z			; UnitClass::MoveUnit
PUBLIC	?DoCombat@UnitClass@@UAEHXZ			; UnitClass::DoCombat
PUBLIC	?ChooseTactic@UnitClass@@UAEHXZ			; UnitClass::ChooseTactic
PUBLIC	?CheckTactic@UnitClass@@UAEHH@Z			; UnitClass::CheckTactic
PUBLIC	?Father@UnitClass@@UBEHXZ			; UnitClass::Father
PUBLIC	?Real@UnitClass@@UAEHXZ				; UnitClass::Real
PUBLIC	?AdjustForSupply@UnitClass@@UAEMXZ		; UnitClass::AdjustForSupply
PUBLIC	?GetUnitSpeed@UnitClass@@UBEHXZ			; UnitClass::GetUnitSpeed
PUBLIC	?CombatTime@UnitClass@@UAEKXZ			; UnitClass::CombatTime
PUBLIC	?GetUnitSupplyNeed@UnitClass@@UAEHH@Z		; UnitClass::GetUnitSupplyNeed
PUBLIC	?GetUnitFuelNeed@UnitClass@@UAEHH@Z		; UnitClass::GetUnitFuelNeed
PUBLIC	?SupplyUnit@UnitClass@@UAEXHH@Z			; UnitClass::SupplyUnit
PUBLIC	?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z ; UnitClass::GetVehicleDeagData
PUBLIC	?IsUnit@UnitClass@@UAEHXZ			; UnitClass::IsUnit
PUBLIC	?IsDead@UnitClass@@UBEHXZ			; UnitClass::IsDead
PUBLIC	?Assigned@UnitClass@@QBEHXZ			; UnitClass::Assigned
PUBLIC	?Parent@UnitClass@@QBEHXZ			; UnitClass::Parent
PUBLIC	?Engaged@UnitClass@@QBEHXZ			; UnitClass::Engaged
PUBLIC	?Moving@UnitClass@@QBEHXZ			; UnitClass::Moving
PUBLIC	?Combat@UnitClass@@QBEHXZ			; UnitClass::Combat
PUBLIC	?Broken@UnitClass@@QBEHXZ			; UnitClass::Broken
PUBLIC	?Targeted@UnitClass@@QBEHXZ			; UnitClass::Targeted
PUBLIC	?Retreating@UnitClass@@QBEHXZ			; UnitClass::Retreating
PUBLIC	?Detached@UnitClass@@QBEHXZ			; UnitClass::Detached
PUBLIC	?SimSetLocation@UnitClass@@UAEXMMM@Z		; UnitClass::SimSetLocation
PUBLIC	?SimSetOrientation@UnitClass@@UAEXMMM@Z		; UnitClass::SimSetOrientation
PUBLIC	?GetRealPosition@UnitClass@@UAEXPAM00@Z		; UnitClass::GetRealPosition
PUBLIC	?SetUnitDestination@UnitClass@@QAEXFF@Z		; UnitClass::SetUnitDestination
PUBLIC	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z	; UnitClass::SetTarget
PUBLIC	?GetNumVehicles@UnitClass@@QAEHH@Z		; UnitClass::GetNumVehicles
PUBLIC	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ	; UnitClass::GetTarget
PUBLIC	?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ		; UnitClass::GetTargetID
PUBLIC	?GetUnitMoved@UnitClass@@QBEHXZ			; UnitClass::GetUnitMoved
PUBLIC	?GetUnitTactic@UnitClass@@QBEHXZ		; UnitClass::GetUnitTactic
PUBLIC	?SetUnitLastMove@UnitClass@@UAEXK@Z		; UnitClass::SetUnitLastMove
PUBLIC	?SetCombatTime@UnitClass@@UAEXK@Z		; UnitClass::SetCombatTime
PUBLIC	?SetBurntFuel@UnitClass@@UAEXJ@Z		; UnitClass::SetBurntFuel
PUBLIC	?SetUnitMission@UnitClass@@UAEXE@Z		; UnitClass::SetUnitMission
PUBLIC	?SetUnitRole@UnitClass@@UAEXE@Z			; UnitClass::SetUnitRole
PUBLIC	?SetUnitPriority@UnitClass@@UAEXH@Z		; UnitClass::SetUnitPriority
PUBLIC	?SetUnitMissionID@UnitClass@@UAEXH@Z		; UnitClass::SetUnitMissionID
PUBLIC	?SetUnitMissionTarget@UnitClass@@UAEXH@Z	; UnitClass::SetUnitMissionTarget
PUBLIC	?SetUnitTOT@UnitClass@@UAEXK@Z			; UnitClass::SetUnitTOT
PUBLIC	?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitSquadron
PUBLIC	?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitAirbase
PUBLIC	?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z ; UnitClass::SetLoadout
PUBLIC	?GetNumberOfLoadouts@UnitClass@@UAEHXZ		; UnitClass::GetNumberOfLoadouts
PUBLIC	?GetMoveTime@UnitClass@@UAEKXZ			; UnitClass::GetMoveTime
PUBLIC	?GetCombatTime@UnitClass@@UAEKXZ		; UnitClass::GetCombatTime
PUBLIC	?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetAirTargetID
PUBLIC	?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ	; UnitClass::GetAirTarget
PUBLIC	?GetBurntFuel@UnitClass@@UAEHXZ			; UnitClass::GetBurntFuel
PUBLIC	?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ ; UnitClass::GetUnitMission
PUBLIC	?GetUnitPriority@UnitClass@@UAEHXZ		; UnitClass::GetUnitPriority
PUBLIC	?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ ; UnitClass::GetUnitMissionTarget
PUBLIC	?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ ; UnitClass::GetUnitMissionTargetID
PUBLIC	?GetUnitMissionID@UnitClass@@UAEHXZ		; UnitClass::GetUnitMissionID
PUBLIC	?GetUnitTOT@UnitClass@@UAEKXZ			; UnitClass::GetUnitTOT
PUBLIC	?GetUnitSquadron@UnitClass@@UAEPAV1@XZ		; UnitClass::GetUnitSquadron
PUBLIC	?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitSquadronID
PUBLIC	?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ ; UnitClass::GetUnitAirbase
PUBLIC	?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitAirbaseID
PUBLIC	?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z ; UnitClass::LoadWeapons
PUBLIC	?DumpWeapons@UnitClass@@UAEHXZ			; UnitClass::DumpWeapons
PUBLIC	?ETA@UnitClass@@UAEKXZ				; UnitClass::ETA
PUBLIC	?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ ; UnitClass::GetKnownEmitters
PUBLIC	?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z ; UnitClass::BuildMission
PUBLIC	?IncrementTime@UnitClass@@UAEXK@Z		; UnitClass::IncrementTime
PUBLIC	?UseFuel@UnitClass@@UAEXJ@Z			; UnitClass::UseFuel
PUBLIC	?SetUnitSpecialty@UnitClass@@UAEXH@Z		; UnitClass::SetUnitSpecialty
PUBLIC	?SetUnitSupply@UnitClass@@UAEXH@Z		; UnitClass::SetUnitSupply
PUBLIC	?SetUnitMorale@UnitClass@@UAEXH@Z		; UnitClass::SetUnitMorale
PUBLIC	?SetSquadronFuel@UnitClass@@UAEXJ@Z		; UnitClass::SetSquadronFuel
PUBLIC	?SetUnitStores@UnitClass@@UAEXHE@Z		; UnitClass::SetUnitStores
PUBLIC	?SetLastResupply@UnitClass@@UAEXH@Z		; UnitClass::SetLastResupply
PUBLIC	?SetLastResupplyTime@UnitClass@@UAEXK@Z		; UnitClass::SetLastResupplyTime
PUBLIC	?GetUnitSpecialty@UnitClass@@UAEHXZ		; UnitClass::GetUnitSpecialty
PUBLIC	?GetUnitSupply@UnitClass@@UAEHXZ		; UnitClass::GetUnitSupply
PUBLIC	?GetUnitMorale@UnitClass@@UAEHXZ		; UnitClass::GetUnitMorale
PUBLIC	?GetSquadronFuel@UnitClass@@UAEJXZ		; UnitClass::GetSquadronFuel
PUBLIC	?GetUnitStores@UnitClass@@UAEEH@Z		; UnitClass::GetUnitStores
PUBLIC	?GetLastResupplyTime@UnitClass@@UAEKXZ		; UnitClass::GetLastResupplyTime
PUBLIC	?GetLastResupply@UnitClass@@UAEHXZ		; UnitClass::GetLastResupply
PUBLIC	?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z ; UnitClass::BuildPackage
PUBLIC	?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z ; UnitClass::HandleRequestReceipt
PUBLIC	?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z	; UnitClass::SetUnitAssemblyPoint
PUBLIC	?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z	; UnitClass::GetUnitAssemblyPoint
PUBLIC	?SetUnitOrders@UnitClass@@UAEXH@Z		; UnitClass::SetUnitOrders
PUBLIC	?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z	; UnitClass::SetUnitOrders
PUBLIC	?SetUnitFatigue@UnitClass@@UAEXH@Z		; UnitClass::SetUnitFatigue
PUBLIC	?SetUnitMode@UnitClass@@UAEXH@Z			; UnitClass::SetUnitMode
PUBLIC	?SetUnitPosition@UnitClass@@UAEXH@Z		; UnitClass::SetUnitPosition
PUBLIC	?SetUnitDivision@UnitClass@@UAEXH@Z		; UnitClass::SetUnitDivision
PUBLIC	?SetUnitHeading@UnitClass@@UAEXH@Z		; UnitClass::SetUnitHeading
PUBLIC	?GetUnitFatigue@UnitClass@@UAEHXZ		; UnitClass::GetUnitFatigue
PUBLIC	?GetUnitElement@UnitClass@@UAEHXZ		; UnitClass::GetUnitElement
PUBLIC	?GetUnitMode@UnitClass@@UAEHXZ			; UnitClass::GetUnitMode
PUBLIC	?GetUnitPosition@UnitClass@@UAEHXZ		; UnitClass::GetUnitPosition
PUBLIC	?GetUnitHeading@UnitClass@@UAEHXZ		; UnitClass::GetUnitHeading
PUBLIC	?SetUnitNextMove@UnitClass@@UAEXXZ		; UnitClass::SetUnitNextMove
PUBLIC	?ClearUnitPath@UnitClass@@UAEXXZ		; UnitClass::ClearUnitPath
PUBLIC	?GetNextMoveDirection@UnitClass@@UAEHXZ		; UnitClass::GetNextMoveDirection
PUBLIC	?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z	; UnitClass::SetUnitCurrentDestination
PUBLIC	?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z ; UnitClass::GetUnitCurrentDestination
PUBLIC	?RallyUnit@UnitClass@@UAEHH@Z			; UnitClass::RallyUnit
PUBLIC	?GetUnitParent@UnitClass@@UBEPAV1@XZ		; UnitClass::GetUnitParent
PUBLIC	?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitParentID
PUBLIC	?SetUnitParent@UnitClass@@UAEXPAV1@@Z		; UnitClass::SetUnitParent
PUBLIC	?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ	; UnitClass::GetFirstUnitElement
PUBLIC	?GetNextUnitElement@UnitClass@@UBEPAV1@XZ	; UnitClass::GetNextUnitElement
PUBLIC	?GetUnitElement@UnitClass@@UAEPAV1@H@Z		; UnitClass::GetUnitElement
PUBLIC	?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z	; UnitClass::GetUnitElementByID
PUBLIC	?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z	; UnitClass::GetPrevUnitElement
PUBLIC	?AddUnitChild@UnitClass@@UAEXPAV1@@Z		; UnitClass::AddUnitChild
PUBLIC	?DisposeChildren@UnitClass@@UAEXXZ		; UnitClass::DisposeChildren
PUBLIC	?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z		; UnitClass::RemoveChild
PUBLIC	?ReorganizeUnit@UnitClass@@UAEXXZ		; UnitClass::ReorganizeUnit
PUBLIC	?UpdateParentStatistics@UnitClass@@UAEHXZ	; UnitClass::UpdateParentStatistics
PUBLIC	??0GroundUnitClass@@QAE@GK@Z			; GroundUnitClass::GroundUnitClass
PUBLIC	??0GroundUnitClass@@QAE@PAPAEPAJ@Z		; GroundUnitClass::GroundUnitClass
PUBLIC	??1GroundUnitClass@@UAE@XZ			; GroundUnitClass::~GroundUnitClass
PUBLIC	?SaveSize@GroundUnitClass@@UAEHXZ		; GroundUnitClass::SaveSize
PUBLIC	?Save@GroundUnitClass@@UAEHPAPAE@Z		; GroundUnitClass::Save
PUBLIC	?Handle@GroundUnitClass@@UAEHPAVVuFullUpdateEvent@@@Z ; GroundUnitClass::Handle
PUBLIC	?GetMovementType@GroundUnitClass@@UAE?AW4MoveType@@XZ ; GroundUnitClass::GetMovementType
PUBLIC	?GetObjMovementType@GroundUnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z ; GroundUnitClass::GetObjMovementType
PUBLIC	?DetectOnMove@GroundUnitClass@@UAEHXZ		; GroundUnitClass::DetectOnMove
PUBLIC	?ChooseTarget@GroundUnitClass@@UAEHXZ		; GroundUnitClass::ChooseTarget
PUBLIC	?MaxUpdateTime@GroundUnitClass@@UBEKXZ		; GroundUnitClass::MaxUpdateTime
PUBLIC	?OnGround@GroundUnitClass@@UAEHXZ		; GroundUnitClass::OnGround
PUBLIC	?GetVt@GroundUnitClass@@UBEMXZ			; GroundUnitClass::GetVt
PUBLIC	?GetKias@GroundUnitClass@@UBEMXZ		; GroundUnitClass::GetKias
PUBLIC	?SetOrders@GroundUnitClass@@QAEXE@Z		; GroundUnitClass::SetOrders
PUBLIC	?SetDivision@GroundUnitClass@@QAEXF@Z		; GroundUnitClass::SetDivision
PUBLIC	?SetPObj@GroundUnitClass@@QAEXVVU_ID@@@Z	; GroundUnitClass::SetPObj
PUBLIC	?SetSObj@GroundUnitClass@@QAEXVVU_ID@@@Z	; GroundUnitClass::SetSObj
PUBLIC	?SetAObj@GroundUnitClass@@QAEXVVU_ID@@@Z	; GroundUnitClass::SetAObj
PUBLIC	?DetectVs@GroundUnitClass@@QAEHPAVAircraftClass@@PAMPAH2222@Z ; GroundUnitClass::DetectVs
PUBLIC	?DetectVs@GroundUnitClass@@QAEHPAVCampBaseClass@@PAMPAH2222@Z ; GroundUnitClass::DetectVs
PUBLIC	?SetUnitOrders@GroundUnitClass@@UAEXE@Z		; GroundUnitClass::SetUnitOrders
PUBLIC	?SetUnitDivision@GroundUnitClass@@UAEXF@Z	; GroundUnitClass::SetUnitDivision
PUBLIC	?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ; GroundUnitClass::SetUnitPrimaryObj
PUBLIC	?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ; GroundUnitClass::SetUnitSecondaryObj
PUBLIC	?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z ; GroundUnitClass::SetUnitObjective
PUBLIC	?GetUnitOrders@GroundUnitClass@@UAEHXZ		; GroundUnitClass::GetUnitOrders
PUBLIC	?GetUnitDivision@GroundUnitClass@@UAEHXZ	; GroundUnitClass::GetUnitDivision
PUBLIC	?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ; GroundUnitClass::GetUnitPrimaryObj
PUBLIC	?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ; GroundUnitClass::GetUnitSecondaryObj
PUBLIC	?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ; GroundUnitClass::GetUnitObjective
PUBLIC	?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ; GroundUnitClass::GetUnitPrimaryObjID
PUBLIC	?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ; GroundUnitClass::GetUnitSecondaryObjID
PUBLIC	?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ ; GroundUnitClass::GetUnitObjectiveID
PUBLIC	?CheckForSurrender@GroundUnitClass@@UAEHXZ	; GroundUnitClass::CheckForSurrender
PUBLIC	?GetUnitNormalRole@GroundUnitClass@@UAEHXZ	; GroundUnitClass::GetUnitNormalRole
PUBLIC	?GetUnitCurrentRole@GroundUnitClass@@UBEHXZ	; GroundUnitClass::GetUnitCurrentRole
PUBLIC	?BuildMission@GroundUnitClass@@UAEHXZ		; GroundUnitClass::BuildMission
PUBLIC	?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ; GroundUnitClass::MakeGndUnitDirty
PUBLIC	?WriteDirty@GroundUnitClass@@QAEXPAPAE@Z	; GroundUnitClass::WriteDirty
PUBLIC	?ReadDirty@GroundUnitClass@@QAEXPAPAEPAJ@Z	; GroundUnitClass::ReadDirty
PUBLIC	??_GGroundUnitClass@@UAEPAXI@Z			; GroundUnitClass::`scalar deleting destructor'
PUBLIC	?BestElement@@YAPAVUnitClass@@PAV1@HH@Z		; BestElement
PUBLIC	?FindNextBest@@YAHHQAH@Z			; FindNextBest
PUBLIC	?BuildGroundWP@@YAHPAVUnitClass@@@Z		; BuildGroundWP
PUBLIC	?GetActionFromOrders@@YAHH@Z			; GetActionFromOrders
PUBLIC	?CheckReady@@YAHPAVUnitClass@@@Z		; CheckReady
PUBLIC	?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z ; CalculateOpposingStrength
PUBLIC	?SOSecured@@YAHPAVObjectiveClass@@E@Z		; SOSecured
PUBLIC	?ClassifyUnitElements@@YAXPAVUnitClass@@PAH111@Z ; ClassifyUnitElements
PUBLIC	?GetPositionOrders@@YAHPAVUnitClass@@@Z		; GetPositionOrders
PUBLIC	?FindBestCover@@YAXFFEPAF0H@Z			; FindBestCover
PUBLIC	?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z ; FindRetreatPath
PUBLIC	?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z ; RequestArtillerySupport
PUBLIC	?RequestCAS@@YAHHPAVUnitClass@@@Z		; RequestCAS
PUBLIC	?RequestSupport@@YAHPAVUnitClass@@0@Z		; RequestSupport
PUBLIC	?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z		; RequestOCCAS
PUBLIC	?RequestBAI@@YAXPAVUnitClass@@FFK@Z		; RequestBAI
PUBLIC	?GetGroundRole@@YAHH@Z				; GetGroundRole
PUBLIC	?GetGroundOrders@@YAHH@Z			; GetGroundOrders
PUBLIC	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
PUBLIC	?MinAdjustLevel@@YAHPAVUnitClass@@@Z		; MinAdjustLevel
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?RequestAirborneTransport@@YAHPAVUnitClass@@@Z	; RequestAirborneTransport
PUBLIC	?RequestMarineTransport@@YAHPAVUnitClass@@@Z	; RequestMarineTransport
PUBLIC	?GetThisWPAction@@YAHPAVUnitClass@@PAVObjectiveClass@@1HEPAM@Z ; GetThisWPAction
PUBLIC	?GetAverageHeading@@YAEPAVBasePathClass@@@Z	; GetAverageHeading
PUBLIC	?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z ; PositionToSupportUnit
PUBLIC	?ScorePosition@@YAHPAVUnitClass@@HHPAVObjectiveClass@@FFH@Z ; ScorePosition
PUBLIC	?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z ; FindBestPosition
PUBLIC	?CoverValue@@YAMFFH@Z				; CoverValue
PUBLIC	?FindUnitSupportRole@@YAHPAVUnitClass@@@Z	; FindUnitSupportRole
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_7InvalidBufferException@@6B@			; InvalidBufferException::`vftable'
PUBLIC	??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ ; `string'
PUBLIC	__TI4?AVInvalidBufferException@@
PUBLIC	__CTA4?AVInvalidBufferException@@
PUBLIC	??_R0?AVInvalidBufferException@@@8		; InvalidBufferException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7GroundUnitClass@@6B@			; GroundUnitClass::`vftable'
PUBLIC	??_C@_0BG@ILCOIOOM@?$CF08x?5GroundUnitClass?5?$AA@ ; `string'
PUBLIC	??_C@_09LAFEABCL@?5?5GU?5?$CF08x?$AA@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4InvalidBufferException@@6B@		; InvalidBufferException::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidBufferException@@8			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidBufferException@@8			; InvalidBufferException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidBufferException@@8		; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4GroundUnitClass@@6B@			; GroundUnitClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVGroundUnitClass@@@8			; GroundUnitClass `RTTI Type Descriptor'
PUBLIC	??_R3GroundUnitClass@@8				; GroundUnitClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2GroundUnitClass@@8				; GroundUnitClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@GroundUnitClass@@8		; GroundUnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@UnitClass@@8			; UnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVUnitClass@@@8				; UnitClass `RTTI Type Descriptor'
PUBLIC	??_R3UnitClass@@8				; UnitClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UnitClass@@8				; UnitClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CampBaseClass@@8			; CampBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCampBaseClass@@@8			; CampBaseClass `RTTI Type Descriptor'
PUBLIC	??_R3CampBaseClass@@8				; CampBaseClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CampBaseClass@@8				; CampBaseClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FalconEntity@@8			; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFalconEntity@@@8			; FalconEntity `RTTI Type Descriptor'
PUBLIC	??_R3FalconEntity@@8				; FalconEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FalconEntity@@8				; FalconEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuEntity@@8			; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuEntity@@@8				; VuEntity `RTTI Type Descriptor'
PUBLIC	??_R3VuEntity@@8				; VuEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuEntity@@8				; VuEntity::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41c80000
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@461c3c00
PUBLIC	__real@7f7fffff
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_fflush:PROC
EXTRN	_fprintf:PROC
EXTRN	_sprintf:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z:PROC ; VuEntity::CustomCollisionCheck
EXTRN	?TerrainCollisionCheck@VuEntity@@UAEEXZ:PROC	; VuEntity::TerrainCollisionCheck
EXTRN	?IsTarget@VuEntity@@UAEEXZ:PROC			; VuEntity::IsTarget
EXTRN	?IsSession@VuEntity@@UAEEXZ:PROC		; VuEntity::IsSession
EXTRN	?IsGroup@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGroup
EXTRN	?IsGame@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGame
EXTRN	?IsCamera@VuEntity@@UBEEXZ:PROC			; VuEntity::IsCamera
EXTRN	?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?InsertionCallback@VuEntity@@MAEHXZ:PROC	; VuEntity::InsertionCallback
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z:PROC	; VuCollection::Remove
EXTRN	?Find@VuCollection@@QBE_NPAVVuEntity@@@Z:PROC	; VuCollection::Find
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z:PROC ; VuGridIterator::VuGridIterator
EXTRN	??1VuGridIterator@@UAE@XZ:PROC			; VuGridIterator::~VuGridIterator
EXTRN	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetFirst
EXTRN	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetNext
EXTRN	?Save@FalconEntity@@UAEHPAU_iobuf@@@Z:PROC	; FalconEntity::Save
EXTRN	?CleanupData@FalconEntity@@UAEXXZ:PROC		; FalconEntity::CleanupData
EXTRN	?RemovalCallback@FalconEntity@@UAEHXZ:PROC	; FalconEntity::RemovalCallback
EXTRN	?GetDomain@FalconEntity@@UAEEXZ:PROC		; FalconEntity::GetDomain
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z:PROC ; FalconEntity::MakeDirty
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?GetRelief@@YA?AW4ReliefType@@FF@Z:PROC		; GetRelief
EXTRN	?GetCover@@YA?AW4CoverType@@FF@Z:PROC		; GetCover
EXTRN	?GetRoad@@YADFF@Z:PROC				; GetRoad
EXTRN	??0ListClass@@QAE@E@Z:PROC			; ListClass::ListClass
EXTRN	??1ListClass@@QAE@XZ:PROC			; ListClass::~ListClass
EXTRN	?Remove@ListClass@@QAEXPAVListElementClass@@@Z:PROC ; ListClass::Remove
EXTRN	?InsertNewElement@ListClass@@QAEXFPAXE@Z:PROC	; ListClass::InsertNewElement
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	??1BasePathClass@@QAE@XZ:PROC			; BasePathClass::~BasePathClass
EXTRN	?GetDirection@BasePathClass@@QAEHH@Z:PROC	; BasePathClass::GetDirection
EXTRN	?CopyPath@BasePathClass@@QAEHPAV1@@Z:PROC	; BasePathClass::CopyPath
EXTRN	??0PathClass@@QAE@XZ:PROC			; PathClass::PathClass
EXTRN	??0MissionRequestClass@@QAE@XZ:PROC		; MissionRequestClass::MissionRequestClass
EXTRN	??1MissionRequestClass@@QAE@XZ:PROC		; MissionRequestClass::~MissionRequestClass
EXTRN	?RequestMission@MissionRequestClass@@QAEHXZ:PROC ; MissionRequestClass::RequestMission
EXTRN	?RequestEnemyMission@MissionRequestClass@@QAEHXZ:PROC ; MissionRequestClass::RequestEnemyMission
EXTRN	??_EInvalidBufferException@@UAEPAXI@Z:PROC	; InvalidBufferException::`vector deleting destructor'
EXTRN	?GetTeam@@YAEE@Z:PROC				; GetTeam
EXTRN	?SetOwner@CampBaseClass@@UAEXE@Z:PROC		; CampBaseClass::SetOwner
EXTRN	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z:PROC ; CampBaseClass::MakeCampBaseDirty
EXTRN	?InitData@CampBaseClass@@UAEXXZ:PROC		; CampBaseClass::InitData
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuEvent@@@Z:PROC	; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuPositionUpdateEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuEntityCollisionEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuTransferEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuSessionEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?GetSpotted@CampBaseClass@@QAEHE@Z:PROC		; CampBaseClass::GetSpotted
EXTRN	?SetSpotted@CampBaseClass@@QAEXEKH@Z:PROC	; CampBaseClass::SetSpotted
EXTRN	?SetEmitting@CampBaseClass@@QAEXH@Z:PROC	; CampBaseClass::SetEmitting
EXTRN	?FindObjective@@YAPAVObjectiveClass@@VVU_ID@@@Z:PROC ; FindObjective
EXTRN	?IsPrimary@ObjectiveClass@@QAEHXZ:PROC		; ObjectiveClass::IsPrimary
EXTRN	?IsSecondary@ObjectiveClass@@QAEHXZ:PROC	; ObjectiveClass::IsSecondary
EXTRN	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z:PROC	; ObjectiveClass::GetNeighbor
EXTRN	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z:PROC ; GetFirstObjective
EXTRN	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z:PROC ; GetNextObjective
EXTRN	?CaptureObjective@@YAXPAVObjectiveClass@@EPAVUnitClass@@@Z:PROC ; CaptureObjective
EXTRN	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z:PROC	; UnitClass::SetCargoId
EXTRN	?SetOdds@UnitClass@@QAEXF@Z:PROC		; UnitClass::SetOdds
EXTRN	??0UnitClass@@QAE@GK@Z:PROC			; UnitClass::UnitClass
EXTRN	??0UnitClass@@QAE@PAPAEPAJ@Z:PROC		; UnitClass::UnitClass
EXTRN	??1UnitClass@@UAE@XZ:PROC			; UnitClass::~UnitClass
EXTRN	?SaveSize@UnitClass@@UAEHXZ:PROC		; UnitClass::SaveSize
EXTRN	?Save@UnitClass@@UAEHPAPAE@Z:PROC		; UnitClass::Save
EXTRN	?Handle@UnitClass@@UAEHPAVVuFullUpdateEvent@@@Z:PROC ; UnitClass::Handle
EXTRN	?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z:PROC ; UnitClass::SendDeaggregateData
EXTRN	?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z:PROC ; UnitClass::RecordCurrentState
EXTRN	?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:PROC ; UnitClass::Deaggregate
EXTRN	?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:PROC ; UnitClass::Reaggregate
EXTRN	?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:PROC ; UnitClass::TransferOwnership
EXTRN	?Wake@UnitClass@@UAEHXZ:PROC			; UnitClass::Wake
EXTRN	?Sleep@UnitClass@@UAEHXZ:PROC			; UnitClass::Sleep
EXTRN	?InsertInSimLists@UnitClass@@UAEXMM@Z:PROC	; UnitClass::InsertInSimLists
EXTRN	?RemoveFromSimLists@UnitClass@@UAEXXZ:PROC	; UnitClass::RemoveFromSimLists
EXTRN	?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z:PROC	; UnitClass::DeaggregateFromData
EXTRN	?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z:PROC	; UnitClass::ReaggregateFromData
EXTRN	?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z:PROC ; UnitClass::TransferOwnershipFromData
EXTRN	?ResetPlayerStatus@UnitClass@@UAEHXZ:PROC	; UnitClass::ResetPlayerStatus
EXTRN	?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z:PROC ; UnitClass::ApplyDamage
EXTRN	?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z:PROC ; UnitClass::ApplyDamage
EXTRN	?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z:PROC ; UnitClass::DecodeDamageData
EXTRN	?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z:PROC ; UnitClass::CollectWeapons
EXTRN	?GetDamageModifiers@UnitClass@@UAEPAEXZ:PROC	; UnitClass::GetDamageModifiers
EXTRN	?GetName@UnitClass@@UAEPADPADHH@Z:PROC		; UnitClass::GetName
EXTRN	?GetFullName@UnitClass@@UAEPADPADHH@Z:PROC	; UnitClass::GetFullName
EXTRN	?GetDivisionName@UnitClass@@UAEPADPADHH@Z:PROC	; UnitClass::GetDivisionName
EXTRN	?GetHitChance@UnitClass@@UAEHHH@Z:PROC		; UnitClass::GetHitChance
EXTRN	?GetAproxHitChance@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetAproxHitChance
EXTRN	?GetCombatStrength@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetCombatStrength
EXTRN	?GetAproxCombatStrength@UnitClass@@UAEHHH@Z:PROC ; UnitClass::GetAproxCombatStrength
EXTRN	?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z:PROC ; UnitClass::GetWeaponRange
EXTRN	?GetAproxWeaponRange@UnitClass@@UAEHH@Z:PROC	; UnitClass::GetAproxWeaponRange
EXTRN	?GetDetectionRange@UnitClass@@UAEHH@Z:PROC	; UnitClass::GetDetectionRange
EXTRN	?GetElectronicDetectionRange@UnitClass@@UAEHH@Z:PROC ; UnitClass::GetElectronicDetectionRange
EXTRN	?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z:PROC ; UnitClass::CanDetect
EXTRN	?GetComponentLocation@UnitClass@@UAEXPAF0H@Z:PROC ; UnitClass::GetComponentLocation
EXTRN	?GetComponentAltitude@UnitClass@@UAEHH@Z:PROC	; UnitClass::GetComponentAltitude
EXTRN	?GetRCSFactor@UnitClass@@UAEMXZ:PROC		; UnitClass::GetRCSFactor
EXTRN	?GetIRFactor@UnitClass@@UAEMXZ:PROC		; UnitClass::GetIRFactor
EXTRN	?GetNumberOfArcs@UnitClass@@UAEHXZ:PROC		; UnitClass::GetNumberOfArcs
EXTRN	?GetArcRatio@UnitClass@@UAEMH@Z:PROC		; UnitClass::GetArcRatio
EXTRN	?GetArcRange@UnitClass@@UAEMH@Z:PROC		; UnitClass::GetArcRange
EXTRN	?GetArcAngle@UnitClass@@UAEXHPAM0@Z:PROC	; UnitClass::GetArcAngle
EXTRN	?GetRadarType@UnitClass@@UAEHXZ:PROC		; UnitClass::GetRadarType
EXTRN	?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z:PROC ; UnitClass::SendUnitMessage
EXTRN	?MoraleCheck@UnitClass@@QAEHHH@Z:PROC		; UnitClass::MoraleCheck
EXTRN	?SetAssigned@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetAssigned
EXTRN	?SetOrdered@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetOrdered
EXTRN	?SetEngaged@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetEngaged
EXTRN	?SetCombat@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetCombat
EXTRN	?SetTargeted@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetTargeted
EXTRN	?SetTempDest@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetTempDest
EXTRN	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ:PROC ; UnitClass::GetUnitClassData
EXTRN	?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z:PROC ; UnitClass::GetBestVehicleWeapon
EXTRN	?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z:PROC ; UnitClass::GetVehicleHitChance
EXTRN	?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z:PROC ; UnitClass::GetVehicleCombatStrength
EXTRN	?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z:PROC ; UnitClass::GetVehicleRange
EXTRN	?GetUnitWeaponId@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetUnitWeaponId
EXTRN	?GetUnitWeaponCount@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetUnitWeaponCount
EXTRN	?GetUnitDestination@UnitClass@@QAEXPAF0@Z:PROC	; UnitClass::GetUnitDestination
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetMaxSpeed@UnitClass@@QBEHXZ:PROC		; UnitClass::GetMaxSpeed
EXTRN	?KillUnit@UnitClass@@QAEXXZ:PROC		; UnitClass::KillUnit
EXTRN	?GetUnitRoleScore@UnitClass@@QAEHHHH@Z:PROC	; UnitClass::GetUnitRoleScore
EXTRN	?GetUnitObjectivePath@UnitClass@@QAEHPAVBasePathClass@@PAVObjectiveClass@@1@Z:PROC ; UnitClass::GetUnitObjectivePath
EXTRN	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z:PROC ; UnitClass::GetUnitGridPath
EXTRN	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z:PROC ; UnitClass::AddUnitWP
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?DisposeWayPoints@UnitClass@@QAEXXZ:PROC	; UnitClass::DisposeWayPoints
EXTRN	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetFirstUnit
EXTRN	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetNextUnit
EXTRN	?GetMovementCost@@YAMFFW4MoveType@@HE@Z:PROC	; GetMovementCost
EXTRN	?DistSqu@@YAHFFFF@Z:PROC			; DistSqu
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?DistSqu@@YAMMMMM@Z:PROC			; DistSqu
EXTRN	?DistanceToFront@@YAMFF@Z:PROC			; DistanceToFront
EXTRN	?TimeToArrive@@YAKMM@Z:PROC			; TimeToArrive
EXTRN	?FindNearestEnemyUnit@@YAPAVUnitClass@@FFF@Z:PROC ; FindNearestEnemyUnit
EXTRN	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAM@Z:PROC ; FindNearestObjective
EXTRN	?FindNearestFriendlyObjective@@YAPAVObjectiveClass@@EPAF0H@Z:PROC ; FindNearestFriendlyObjective
EXTRN	?GridToSim@@YAMF@Z:PROC				; GridToSim
EXTRN	?EngageParent@@YAHPAVUnitClass@@PAVFalconEntity@@@Z:PROC ; EngageParent
EXTRN	?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z:PROC ; Detected
EXTRN	??_EGroundUnitClass@@UAEPAXI@Z:PROC		; GroundUnitClass::`vector deleting destructor'
EXTRN	?GetRoE@@YAHEEH@Z:PROC				; GetRoE
EXTRN	?FriendlyTerritory@@YAHFFH@Z:PROC		; FriendlyTerritory
EXTRN	?CheckValidType@@YAHPAVCampBaseClass@@0@Z:PROC	; CheckValidType
EXTRN	?CanItIdentify@@YAHPAVCampBaseClass@@0MH@Z:PROC	; CanItIdentify
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?DDP@@3PAUDirtyDataClassType@@A:DWORD		; DDP
EXTRN	?MissionData@@3PAUMissionDataType@@A:BYTE	; MissionData
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?CampSearch@@3PAEA:BYTE				; CampSearch
EXTRN	?ObjProxList@@3PAVVuGridTree@@A:DWORD		; ObjProxList
EXTRN	?RealUnitProxList@@3PAVVuGridTree@@A:DWORD	; RealUnitProxList
EXTRN	?dx@@3PAFA:BYTE					; dx
EXTRN	?dy@@3PAFA:BYTE					; dy
EXTRN	?campCritical@@3PAUF4CSECTIONHANDLE@@A:DWORD	; campCritical
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?ReliefCost@@3PAMA:BYTE				; ReliefCost
EXTRN	?MAX_BAI_DIST@@3FA:WORD				; MAX_BAI_DIST
EXTRN	?GROUND_UPDATE_CHECK_INTERVAL@@3FA:WORD		; GROUND_UPDATE_CHECK_INTERVAL
EXTRN	?MAX_GROUND_SEARCH@@3FA:WORD			; MAX_GROUND_SEARCH
EXTRN	?MAX_AIR_SEARCH@@3FA:WORD			; MAX_AIR_SEARCH
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?save_log@@3PAU_iobuf@@A:DWORD			; save_log
EXTRN	?load_log@@3PAU_iobuf@@A:DWORD			; load_log
EXTRN	?start_save_stream@@3HA:DWORD			; start_save_stream
EXTRN	?start_load_stream@@3HA:DWORD			; start_load_stream
EXTRN	?CoverValues@@3PAMA:BYTE			; CoverValues
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2VuEntity@@8
rdata$r	SEGMENT
??_R2VuEntity@@8 DD FLAT:??_R1A@?0A@EA@VuEntity@@8	; VuEntity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuEntity@@8
rdata$r	SEGMENT
??_R3VuEntity@@8 DD 00H					; VuEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuEntity@@@8
_DATA	SEGMENT
??_R0?AVVuEntity@@@8 DD FLAT:??_7type_info@@6B@		; VuEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuEntity@@8 DD FLAT:??_R0?AVVuEntity@@@8	; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FalconEntity@@8
rdata$r	SEGMENT
??_R2FalconEntity@@8 DD FLAT:??_R1A@?0A@EA@FalconEntity@@8 ; FalconEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3FalconEntity@@8
rdata$r	SEGMENT
??_R3FalconEntity@@8 DD 00H				; FalconEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFalconEntity@@@8
_DATA	SEGMENT
??_R0?AVFalconEntity@@@8 DD FLAT:??_7type_info@@6B@	; FalconEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFalconEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FalconEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FalconEntity@@8 DD FLAT:??_R0?AVFalconEntity@@@8 ; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2CampBaseClass@@8
rdata$r	SEGMENT
??_R2CampBaseClass@@8 DD FLAT:??_R1A@?0A@EA@CampBaseClass@@8 ; CampBaseClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3CampBaseClass@@8
rdata$r	SEGMENT
??_R3CampBaseClass@@8 DD 00H				; CampBaseClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CampBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCampBaseClass@@@8
_DATA	SEGMENT
??_R0?AVCampBaseClass@@@8 DD FLAT:??_7type_info@@6B@	; CampBaseClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCampBaseClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CampBaseClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CampBaseClass@@8 DD FLAT:??_R0?AVCampBaseClass@@@8 ; CampBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CampBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R2UnitClass@@8
rdata$r	SEGMENT
??_R2UnitClass@@8 DD FLAT:??_R1A@?0A@EA@UnitClass@@8	; UnitClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CampBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3UnitClass@@8
rdata$r	SEGMENT
??_R3UnitClass@@8 DD 00H				; UnitClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUnitClass@@@8
_DATA	SEGMENT
??_R0?AVUnitClass@@@8 DD FLAT:??_7type_info@@6B@	; UnitClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUnitClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@UnitClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UnitClass@@8 DD FLAT:??_R0?AVUnitClass@@@8 ; UnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@GroundUnitClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@GroundUnitClass@@8 DD FLAT:??_R0?AVGroundUnitClass@@@8 ; GroundUnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3GroundUnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R2GroundUnitClass@@8
rdata$r	SEGMENT
??_R2GroundUnitClass@@8 DD FLAT:??_R1A@?0A@EA@GroundUnitClass@@8 ; GroundUnitClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@UnitClass@@8
	DD	FLAT:??_R1A@?0A@EA@CampBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3GroundUnitClass@@8
rdata$r	SEGMENT
??_R3GroundUnitClass@@8 DD 00H				; GroundUnitClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2GroundUnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVGroundUnitClass@@@8
_DATA	SEGMENT
??_R0?AVGroundUnitClass@@@8 DD FLAT:??_7type_info@@6B@	; GroundUnitClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGroundUnitClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4GroundUnitClass@@6B@
rdata$r	SEGMENT
??_R4GroundUnitClass@@6B@ DD 00H			; GroundUnitClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVGroundUnitClass@@@8
	DD	FLAT:??_R3GroundUnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidBufferException@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidBufferException@@8 DD FLAT:??_R0?AVInvalidBufferException@@@8 ; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidBufferException@@8
rdata$r	SEGMENT
??_R2InvalidBufferException@@8 DD FLAT:??_R1A@?0A@EA@InvalidBufferException@@8 ; InvalidBufferException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@out_of_range@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidBufferException@@8
rdata$r	SEGMENT
??_R3InvalidBufferException@@8 DD 00H			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidBufferException@@6B@
rdata$r	SEGMENT
??_R4InvalidBufferException@@6B@ DD 00H			; InvalidBufferException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LAFEABCL@?5?5GU?5?$CF08x?$AA@
CONST	SEGMENT
??_C@_09LAFEABCL@?5?5GU?5?$CF08x?$AA@ DB '  GU %08x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ILCOIOOM@?$CF08x?5GroundUnitClass?5?$AA@
CONST	SEGMENT
??_C@_0BG@ILCOIOOM@?$CF08x?5GroundUnitClass?5?$AA@ DB '%08x GroundUnitCla'
	DB	'ss ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7GroundUnitClass@@6B@
CONST	SEGMENT
??_7GroundUnitClass@@6B@ DD FLAT:??_R4GroundUnitClass@@6B@ ; GroundUnitClass::`vftable'
	DD	FLAT:?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z
	DD	FLAT:?TerrainCollisionCheck@VuEntity@@UAEEXZ
	DD	FLAT:?IsTarget@VuEntity@@UAEEXZ
	DD	FLAT:?IsSession@VuEntity@@UAEEXZ
	DD	FLAT:?IsGroup@VuEntity@@UAEEXZ
	DD	FLAT:?IsGame@VuEntity@@UAEEXZ
	DD	FLAT:?IsCamera@VuEntity@@UBEEXZ
	DD	FLAT:?SaveSize@GroundUnitClass@@UAEHXZ
	DD	FLAT:?Save@FalconEntity@@UAEHPAU_iobuf@@@Z
	DD	FLAT:?Save@GroundUnitClass@@UAEHPAPAE@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuSessionEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuTransferEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuEntityCollisionEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@GroundUnitClass@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z
	DD	FLAT:??_EGroundUnitClass@@UAEPAXI@Z
	DD	FLAT:?InsertionCallback@VuEntity@@MAEHXZ
	DD	FLAT:?RemovalCallback@FalconEntity@@UAEHXZ
	DD	FLAT:?InitData@CampBaseClass@@UAEXXZ
	DD	FLAT:?CleanupData@FalconEntity@@UAEXXZ
	DD	FLAT:?IsSimBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?IsCampBase@CampBaseClass@@UAE_NXZ
	DD	FLAT:?Wake@UnitClass@@UAEHXZ
	DD	FLAT:?Sleep@UnitClass@@UAEHXZ
	DD	FLAT:?GetCampID@CampBaseClass@@UAEFXZ
	DD	FLAT:?GetTeam@CampBaseClass@@UAEEXZ
	DD	FLAT:?GetCountry@CampBaseClass@@UAEEXZ
	DD	FLAT:?GetDomain@FalconEntity@@UAEEXZ
	DD	FLAT:?GetRadarMode@FalconEntity@@UAEHXZ
	DD	FLAT:?SetRadarMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?ReturnToSearch@FalconEntity@@UAEXXZ
	DD	FLAT:?SetSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?CombatClass@FalconEntity@@UAEHXZ
	DD	FLAT:?OnGround@GroundUnitClass@@UAEHXZ
	DD	FLAT:?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z
	DD	FLAT:?IsMissile@FalconEntity@@UAEHXZ
	DD	FLAT:?IsLauncher@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBomb@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGun@FalconEntity@@UAEHXZ
	DD	FLAT:?IsMover@FalconEntity@@UAEHXZ
	DD	FLAT:?IsVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsStatic@FalconEntity@@UAEHXZ
	DD	FLAT:?IsHelicopter@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEject@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAirplane@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGroundVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsShip@FalconEntity@@UAEHXZ
	DD	FLAT:?IsWeapon@FalconEntity@@UAEHXZ
	DD	FLAT:?IsExploding@FalconEntity@@UAEHXZ
	DD	FLAT:?IsDead@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEmitting@CampBaseClass@@UAEHXZ
	DD	FLAT:?GetVt@GroundUnitClass@@UBEMXZ
	DD	FLAT:?GetKias@GroundUnitClass@@UBEMXZ
	DD	FLAT:?GetMovementType@GroundUnitClass@@UAE?AW4MoveType@@XZ
	DD	FLAT:?IsUnit@UnitClass@@UAEHXZ
	DD	FLAT:?IsObjective@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBattalion@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBrigade@FalconEntity@@UAEHXZ
	DD	FLAT:?IsFlight@FalconEntity@@UBEHXZ
	DD	FLAT:?IsSquadron@FalconEntity@@UAEHXZ
	DD	FLAT:?IsPackage@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTeam@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTaskForce@FalconEntity@@UAEHXZ
	DD	FLAT:?IsSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?GetRCSFactor@UnitClass@@UAEMXZ
	DD	FLAT:?GetIRFactor@UnitClass@@UAEMXZ
	DD	FLAT:?GetRadarType@UnitClass@@UAEHXZ
	DD	FLAT:?GetDamageModifiers@UnitClass@@UAEPAEXZ
	DD	FLAT:?SetAQUIREtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetSEARCHtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetStepSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?GetAQUIREtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?GetSEARCHtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?SetOwner@CampBaseClass@@UAEXE@Z
	DD	FLAT:?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z
	DD	FLAT:?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z
	DD	FLAT:?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?InsertInSimLists@UnitClass@@UAEXMM@Z
	DD	FLAT:?RemoveFromSimLists@UnitClass@@UAEXXZ
	DD	FLAT:?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z
	DD	FLAT:?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z
	DD	FLAT:?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z
	DD	FLAT:?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z
	DD	FLAT:?GetName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetFullName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetDivisionName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetHitChance@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetAproxHitChance@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetCombatStrength@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetAproxCombatStrength@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z
	DD	FLAT:?GetAproxWeaponRange@UnitClass@@UAEHH@Z
	DD	FLAT:?GetDetectionRange@UnitClass@@UAEHH@Z
	DD	FLAT:?GetElectronicDetectionRange@UnitClass@@UAEHH@Z
	DD	FLAT:?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z
	DD	FLAT:?StepRadar@CampBaseClass@@UAEHHHM@Z
	DD	FLAT:?GetNumberOfArcs@UnitClass@@UAEHXZ
	DD	FLAT:?GetArcRatio@UnitClass@@UAEMH@Z
	DD	FLAT:?GetArcRange@UnitClass@@UAEMH@Z
	DD	FLAT:?GetArcAngle@UnitClass@@UAEXHPAM0@Z
	DD	FLAT:?GetMissilesFlying@CampBaseClass@@UAEHXZ
	DD	FLAT:?ResetPlayerStatus@UnitClass@@UAEHXZ
	DD	FLAT:?GetComponentLocation@UnitClass@@UAEXPAF0H@Z
	DD	FLAT:?GetComponentAltitude@UnitClass@@UAEHH@Z
	DD	FLAT:?CanShootWeapon@UnitClass@@UAEHH@Z
	DD	FLAT:?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z
	DD	FLAT:?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ
	DD	FLAT:?ShouldDeaggregate@UnitClass@@UAEHXZ
	DD	FLAT:?ClearDeaggregationData@UnitClass@@UAEXXZ
	DD	FLAT:?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z
	DD	FLAT:?MoveUnit@UnitClass@@UAEHK@Z
	DD	FLAT:?DoCombat@UnitClass@@UAEHXZ
	DD	FLAT:?ChooseTactic@UnitClass@@UAEHXZ
	DD	FLAT:?CheckTactic@UnitClass@@UAEHH@Z
	DD	FLAT:?Father@UnitClass@@UBEHXZ
	DD	FLAT:?Real@UnitClass@@UAEHXZ
	DD	FLAT:?AdjustForSupply@UnitClass@@UAEMXZ
	DD	FLAT:?GetUnitSpeed@UnitClass@@UBEHXZ
	DD	FLAT:?DetectOnMove@GroundUnitClass@@UAEHXZ
	DD	FLAT:?ChooseTarget@GroundUnitClass@@UAEHXZ
	DD	FLAT:?MaxUpdateTime@GroundUnitClass@@UBEKXZ
	DD	FLAT:?CombatTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetUnitSupplyNeed@UnitClass@@UAEHH@Z
	DD	FLAT:?GetUnitFuelNeed@UnitClass@@UAEHH@Z
	DD	FLAT:?SupplyUnit@UnitClass@@UAEXHH@Z
	DD	FLAT:?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z
	DD	FLAT:?IsDead@UnitClass@@UBEHXZ
	DD	FLAT:?SimSetLocation@UnitClass@@UAEXMMM@Z
	DD	FLAT:?SimSetOrientation@UnitClass@@UAEXMMM@Z
	DD	FLAT:?GetRealPosition@UnitClass@@UAEXPAM00@Z
	DD	FLAT:?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z
	DD	FLAT:?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z
	DD	FLAT:?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z
	DD	FLAT:?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z
	DD	FLAT:?GetUnitWeaponId@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetUnitWeaponCount@UnitClass@@UAEHHH@Z
	DD	FLAT:?SetUnitLastMove@UnitClass@@UAEXK@Z
	DD	FLAT:?SetCombatTime@UnitClass@@UAEXK@Z
	DD	FLAT:?SetBurntFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitMission@UnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitRole@UnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitPriority@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMissionID@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMissionTarget@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitTOT@UnitClass@@UAEXK@Z
	DD	FLAT:?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z
	DD	FLAT:?GetNumberOfLoadouts@UnitClass@@UAEHXZ
	DD	FLAT:?GetMoveTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetCombatTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ
	DD	FLAT:?GetBurntFuel@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ
	DD	FLAT:?GetUnitNormalRole@GroundUnitClass@@UAEHXZ
	DD	FLAT:?GetUnitCurrentRole@GroundUnitClass@@UBEHXZ
	DD	FLAT:?GetUnitPriority@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ
	DD	FLAT:?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitMissionID@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitTOT@UnitClass@@UAEKXZ
	DD	FLAT:?GetUnitSquadron@UnitClass@@UAEPAV1@XZ
	DD	FLAT:?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ
	DD	FLAT:?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z
	DD	FLAT:?DumpWeapons@UnitClass@@UAEHXZ
	DD	FLAT:?ETA@UnitClass@@UAEKXZ
	DD	FLAT:?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ
	DD	FLAT:?BuildMission@GroundUnitClass@@UAEHXZ
	DD	FLAT:?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z
	DD	FLAT:?IncrementTime@UnitClass@@UAEXK@Z
	DD	FLAT:?UseFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitSpecialty@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitSupply@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMorale@UnitClass@@UAEXH@Z
	DD	FLAT:?SetSquadronFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitStores@UnitClass@@UAEXHE@Z
	DD	FLAT:?SetLastResupply@UnitClass@@UAEXH@Z
	DD	FLAT:?SetLastResupplyTime@UnitClass@@UAEXK@Z
	DD	FLAT:?GetUnitSpecialty@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitSupply@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMorale@UnitClass@@UAEHXZ
	DD	FLAT:?GetSquadronFuel@UnitClass@@UAEJXZ
	DD	FLAT:?GetUnitStores@UnitClass@@UAEEH@Z
	DD	FLAT:?GetLastResupplyTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetLastResupply@UnitClass@@UAEHXZ
	DD	FLAT:?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z
	DD	FLAT:?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z
	DD	FLAT:?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z
	DD	FLAT:?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z
	DD	FLAT:?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z
	DD	FLAT:?SetUnitOrders@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitFatigue@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMode@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitPosition@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitDivision@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitHeading@UnitClass@@UAEXH@Z
	DD	FLAT:?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitOrders@GroundUnitClass@@UAEHXZ
	DD	FLAT:?GetUnitFatigue@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitElement@UnitClass@@UAEPAV1@H@Z
	DD	FLAT:?GetUnitElement@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMode@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitPosition@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitDivision@GroundUnitClass@@UAEHXZ
	DD	FLAT:?GetUnitHeading@UnitClass@@UAEHXZ
	DD	FLAT:?SetUnitNextMove@UnitClass@@UAEXXZ
	DD	FLAT:?ClearUnitPath@UnitClass@@UAEXXZ
	DD	FLAT:?GetNextMoveDirection@UnitClass@@UAEHXZ
	DD	FLAT:?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z
	DD	FLAT:?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z
	DD	FLAT:?GetObjMovementType@GroundUnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z
	DD	FLAT:?CheckForSurrender@GroundUnitClass@@UAEHXZ
	DD	FLAT:?RallyUnit@UnitClass@@UAEHH@Z
	DD	FLAT:?GetUnitParent@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetUnitParent@UnitClass@@UAEXPAV1@@Z
	DD	FLAT:?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetNextUnitElement@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z
	DD	FLAT:?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z
	DD	FLAT:?AddUnitChild@UnitClass@@UAEXPAV1@@Z
	DD	FLAT:?DisposeChildren@UnitClass@@UAEXXZ
	DD	FLAT:?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?ReorganizeUnit@UnitClass@@UAEXXZ
	DD	FLAT:?UpdateParentStatistics@UnitClass@@UAEHXZ
	DD	FLAT:?SetUnitOrders@GroundUnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitDivision@GroundUnitClass@@UAEXF@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0InvalidBufferException@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVInvalidBufferException@@@8
_DATA	SEGMENT
??_R0?AVInvalidBufferException@@@8 DD FLAT:??_7type_info@@6B@ ; InvalidBufferException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidBufferException@@', 00H
_DATA	ENDS
;	COMDAT __CTA4?AVInvalidBufferException@@
xdata$x	SEGMENT
__CTA4?AVInvalidBufferException@@ DD 04H
	DD	FLAT:__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVInvalidBufferException@@
xdata$x	SEGMENT
__TI4?AVInvalidBufferException@@ DD 00H
	DD	FLAT:??1InvalidBufferException@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVInvalidBufferException@@
xdata$x	ENDS
;	COMDAT ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
CONST	SEGMENT
??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ DB 'Tryi'
	DB	'ng to write %lu bytes to %ld buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7InvalidBufferException@@6B@
CONST	SEGMENT
??_7InvalidBufferException@@6B@ DD FLAT:??_R4InvalidBufferException@@6B@ ; InvalidBufferException::`vftable'
	DD	FLAT:??_EInvalidBufferException@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z$0
__unwindtable$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z$0
__unwindtable$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z$0
__unwindtable$?RequestBAI@@YAXPAVUnitClass@@FFK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestBAI@@YAXPAVUnitClass@@FFK@Z$0
__unwindtable$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z$0
__unwindtable$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z$0
__unwindtable$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z$0
__unwindtable$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z$0
__unwindtable$?DetectOnMove@GroundUnitClass@@UAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DetectOnMove@GroundUnitClass@@UAEHXZ$0
__unwindtable$??0GroundUnitClass@@QAE@PAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0GroundUnitClass@@QAE@PAPAEPAJ@Z$0
__unwindtable$??0GroundUnitClass@@QAE@GK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0GroundUnitClass@@QAE@GK@Z$0
__unwindtable$?RequestSupport@@YAHPAVUnitClass@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestSupport@@YAHPAVUnitClass@@0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestSupport@@YAHPAVUnitClass@@0@Z$1
__unwindtable$?RequestCAS@@YAHHPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestCAS@@YAHHPAVUnitClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestCAS@@YAHHPAVUnitClass@@@Z$1
__unwindtable$?ChooseTarget@GroundUnitClass@@UAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseTarget@GroundUnitClass@@UAEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ChooseTarget@GroundUnitClass@@UAEHXZ$1
__unwindtable$?BuildGroundWP@@YAHPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildGroundWP@@YAHPAVUnitClass@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?BuildGroundWP@@YAHPAVUnitClass@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?BuildGroundWP@@YAHPAVUnitClass@@@Z$2
__ehfuncinfo$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestBAI@@YAXPAVUnitClass@@FFK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RequestBAI@@YAXPAVUnitClass@@FFK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestSupport@@YAHPAVUnitClass@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RequestSupport@@YAHPAVUnitClass@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestCAS@@YAHHPAVUnitClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RequestCAS@@YAHHPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildGroundWP@@YAHPAVUnitClass@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?BuildGroundWP@@YAHPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ChooseTarget@GroundUnitClass@@UAEHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ChooseTarget@GroundUnitClass@@UAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DetectOnMove@GroundUnitClass@@UAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DetectOnMove@GroundUnitClass@@UAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0GroundUnitClass@@QAE@PAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0GroundUnitClass@@QAE@PAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0GroundUnitClass@@QAE@GK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0GroundUnitClass@@QAE@GK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0
__ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_uc$ = -4						; size = 4
_u$ = 8							; size = 4
?FindUnitSupportRole@@YAHPAVUnitClass@@@Z PROC		; FindUnitSupportRole

; 1990 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1991 : 	UnitClassDataType*	uc;
; 1992 : 
; 1993 : 	uc = u->GetUnitClassData();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 1994 : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN3@FindUnitSu

; 1995 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@FindUnitSu
$LN3@FindUnitSu:

; 1996 : 	if (uc->Role == GRO_FIRESUPPORT || uc->Role == GRO_AIRDEFENSE || uc->Role == GRO_ENGINEER)

	mov	eax, DWORD PTR _uc$[ebp]
	movzx	ecx, BYTE PTR [eax+284]
	cmp	ecx, 6
	je	SHORT $LN1@FindUnitSu
	mov	edx, DWORD PTR _uc$[ebp]
	movzx	eax, BYTE PTR [edx+284]
	cmp	eax, 5
	je	SHORT $LN1@FindUnitSu
	mov	ecx, DWORD PTR _uc$[ebp]
	movzx	edx, BYTE PTR [ecx+284]
	cmp	edx, 7
	jne	SHORT $LN2@FindUnitSu
$LN1@FindUnitSu:

; 1997 : 		return uc->Role;

	mov	eax, DWORD PTR _uc$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	jmp	SHORT $LN4@FindUnitSu
$LN2@FindUnitSu:

; 1998 : 	return 0;

	xor	eax, eax
$LN4@FindUnitSu:

; 1999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindUnitSupportRole@@YAHPAVUnitClass@@@Z ENDP		; FindUnitSupportRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
tv132 = -8						; size = 4
_cov$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
_roadok$ = 16						; size = 4
?CoverValue@@YAMFFH@Z PROC				; CoverValue

; 1821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1822 : 	float	cov;
; 1823 : 	if (!roadok && GetRoad(x,y))

	cmp	DWORD PTR _roadok$[ebp], 0
	jne	SHORT $LN2@CoverValue
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?GetRoad@@YADFF@Z			; GetRoad
	add	esp, 8
	movsx	edx, al
	test	edx, edx
	je	SHORT $LN2@CoverValue

; 1824 : 		cov = 0.5F;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _cov$[ebp], xmm0

; 1825 : 	else

	jmp	SHORT $LN1@CoverValue
$LN2@CoverValue:

; 1826 : 		cov = CoverValues[GetCover(x,y)];

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?GetCover@@YA?AW4CoverType@@FF@Z	; GetCover
	add	esp, 8
	movss	xmm0, DWORD PTR ?CoverValues@@3PAMA[eax*4]
	movss	DWORD PTR _cov$[ebp], xmm0
$LN1@CoverValue:

; 1827 : 	return cov * ReliefCost[GetRelief(x,y)];

	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?GetRelief@@YA?AW4ReliefType@@FF@Z	; GetRelief
	add	esp, 8
	movss	xmm0, DWORD PTR _cov$[ebp]
	mulss	xmm0, DWORD PTR ?ReliefCost@@3PAMA[eax*4]
	movss	DWORD PTR tv132[ebp], xmm0
	fld	DWORD PTR tv132[ebp]

; 1828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CoverValue@@YAMFFH@Z ENDP				; CoverValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_myit$ = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 8
$T4 = -100						; size = 8
$T5 = -92						; size = 8
$T6 = -84						; size = 4
_other_score$7 = -80					; size = 4
_other_role_score$8 = -76				; size = 4
_role_score$ = -72					; size = 4
_besto$ = -68						; size = 4
_bests$ = -64						; size = 4
_our_team$ = -60					; size = 4
_no$ = -56						; size = 4
_other_role$9 = -52					; size = 4
_owned_by_us$ = -48					; size = 4
_p$ = -44						; size = 4
_score$ = -40						; size = 4
_other_battalion$ = -36					; size = 4
_o$ = -32						; size = 4
_oex$10 = -28						; size = 2
_oey$11 = -24						; size = 2
_x$ = -20						; size = 2
_y$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_battalion$ = 8						; size = 4
_brigade$ = 12						; size = 4
_role$ = 16						; size = 4
_nearlist$ = 20						; size = 4
?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z PROC ; FindBestPosition

; 1380 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1381 : 	int				owned_by_us,score,bests=-32000,our_team,role_score;

	mov	DWORD PTR _bests$[ebp], -32000		; ffff8300H

; 1382 : 	Objective		o,no,p,besto=NULL;

	mov	DWORD PTR _besto$[ebp], 0

; 1383 : 	GridIndex		x,y;
; 1384 : 	Battalion		other_battalion;
; 1385 : 
; 1386 : 	// Collect the data
; 1387 : 	role_score = battalion->GetUnitRoleScore(role, CALC_MAX, USE_VEH_COUNT);

	push	2
	push	3
	mov	eax, DWORD PTR _role$[ebp]
	push	eax
	mov	ecx, DWORD PTR _battalion$[ebp]
	call	?GetUnitRoleScore@UnitClass@@QAEHHHH@Z	; UnitClass::GetUnitRoleScore
	mov	DWORD PTR _role_score$[ebp], eax

; 1388 : 	battalion->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _battalion$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1389 : 	our_team = battalion->GetTeam();

	mov	eax, DWORD PTR _battalion$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _battalion$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _our_team$[ebp], ecx

; 1390 : 
; 1391 : 	// Traverse objective options
; 1392 : 	VuListIterator	myit(nearlist);

	mov	edx, DWORD PTR _nearlist$[ebp]
	push	edx
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1393 : 	no = GetFirstObjective(&myit);

	lea	eax, DWORD PTR _myit$[ebp]
	push	eax
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _no$[ebp], eax
$LN18@FindBestPo:

; 1394 : 	while (no)

	cmp	DWORD PTR _no$[ebp], 0
	je	$LN17@FindBestPo

; 1395 : 	{
; 1396 : 		o = no;

	mov	ecx, DWORD PTR _no$[ebp]
	mov	DWORD PTR _o$[ebp], ecx

; 1397 : 		no = GetNextObjective(&myit);

	lea	edx, DWORD PTR _myit$[ebp]
	push	edx
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _no$[ebp], eax

; 1398 : 
; 1399 : 		// Determine owner
; 1400 : 		if (o->GetTeam() == our_team)

	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _our_team$[ebp]
	jne	SHORT $LN16@FindBestPo

; 1401 : 			owned_by_us = 1;

	mov	DWORD PTR _owned_by_us$[ebp], 1

; 1402 : 		else

	jmp	SHORT $LN15@FindBestPo
$LN16@FindBestPo:

; 1403 : 			owned_by_us = 0;

	mov	DWORD PTR _owned_by_us$[ebp], 0
$LN15@FindBestPo:

; 1404 : 
; 1405 : 		// Check for invalid offensive objectives
; 1406 : 		if (!owned_by_us)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	jne	$LN14@FindBestPo

; 1407 : 		{
; 1408 : 			if (brigade->GetUnitCurrentRole() != GRO_ATTACK || !o->IsFrontline() || GetRoE(our_team,o->GetTeam(),ROE_GROUND_CAPTURE) != ROE_ALLOWED)

	mov	edx, DWORD PTR _brigade$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	edx, DWORD PTR [eax+672]
	call	edx
	cmp	eax, 1
	jne	SHORT $LN12@FindBestPo
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsFrontline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsFrontline
	test	eax, eax
	je	SHORT $LN12@FindBestPo
	push	3
	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	movzx	edx, BYTE PTR _our_team$[ebp]
	push	edx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN13@FindBestPo
$LN12@FindBestPo:

; 1409 : 			{
; 1410 : 				nearlist->Remove(o);

	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nearlist$[ebp]
	call	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Remove

; 1411 : 				continue;

	jmp	$LN18@FindBestPo
$LN13@FindBestPo:

; 1412 : 			}
; 1413 : 			p = o->GetObjectiveParent();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ ; ObjectiveClass::GetObjectiveParent
	mov	DWORD PTR _p$[ebp], eax

; 1414 : 			if (!o->IsSecondary() && (!p || (p->Id() != brigade->GetUnitObjectiveID() && p->GetTeam() != our_team)))

	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondary
	test	eax, eax
	jne	SHORT $LN14@FindBestPo
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN10@FindBestPo
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR _brigade$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	edx, DWORD PTR [eax+876]
	call	edx
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@FindBestPo
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	eax, DWORD PTR _our_team$[ebp]
	je	SHORT $LN14@FindBestPo
$LN10@FindBestPo:

; 1415 : 			{
; 1416 : 				nearlist->Remove(o);

	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nearlist$[ebp]
	call	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Remove

; 1417 : 				continue;

	jmp	$LN18@FindBestPo
$LN14@FindBestPo:

; 1418 : 			}
; 1419 : 		}
; 1420 : 
; 1421 : 		// Score this position
; 1422 : 		score = ScorePosition (battalion, role, role_score, o, x, y, owned_by_us);

	mov	edx, DWORD PTR _owned_by_us$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o$[ebp]
	push	edx
	mov	eax, DWORD PTR _role_score$[ebp]
	push	eax
	mov	ecx, DWORD PTR _role$[ebp]
	push	ecx
	mov	edx, DWORD PTR _battalion$[ebp]
	push	edx
	call	?ScorePosition@@YAHPAVUnitClass@@HHPAVObjectiveClass@@FFH@Z ; ScorePosition
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _score$[ebp], eax

; 1423 : 		if (score <= bests)

	mov	eax, DWORD PTR _score$[ebp]
	cmp	eax, DWORD PTR _bests$[ebp]
	jg	SHORT $LN9@FindBestPo

; 1424 : 			continue;

	jmp	$LN18@FindBestPo
$LN9@FindBestPo:

; 1425 : 
; 1426 : 		// Check if it's already assigned to another brigade member
; 1427 : 		// If so, we'll replace them if our score is higher && reassign them
; 1428 : 		// Fire support is allowed to double up on objectives with other non-fire support units
; 1429 : 		other_battalion = (Battalion) brigade->GetFirstUnitElement();

	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _other_battalion$[ebp], eax
$LN8@FindBestPo:

; 1430 : 		while (other_battalion)

	cmp	DWORD PTR _other_battalion$[ebp], 0
	je	$LN7@FindBestPo

; 1431 : 		{
; 1432 : 			if (other_battalion != battalion && other_battalion->Assigned() && other_battalion->GetUnitObjectiveID() == o->Id())

	mov	ecx, DWORD PTR _other_battalion$[ebp]
	cmp	ecx, DWORD PTR _battalion$[ebp]
	je	$LN6@FindBestPo
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	call	?Assigned@UnitClass@@QBEHXZ		; UnitClass::Assigned
	test	eax, eax
	je	$LN6@FindBestPo
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	mov	eax, DWORD PTR [edx+876]
	call	eax
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@FindBestPo

; 1433 : 			{
; 1434 : 				// This guy's already assigned - check his score
; 1435 : 				int			other_role,other_role_score,other_score;
; 1436 : 				GridIndex	oex,oey;
; 1437 : 				other_role = other_battalion->GetUnitCurrentRole();

	mov	edx, DWORD PTR _other_battalion$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	mov	edx, DWORD PTR [eax+672]
	call	edx
	mov	DWORD PTR _other_role$9[ebp], eax

; 1438 : 				other_role_score = other_battalion->GetUnitRoleScore(other_role, CALC_MAX, USE_VEH_COUNT);

	push	2
	push	3
	mov	eax, DWORD PTR _other_role$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	call	?GetUnitRoleScore@UnitClass@@QAEHHHH@Z	; UnitClass::GetUnitRoleScore
	mov	DWORD PTR _other_role_score$8[ebp], eax

; 1439 : 				other_battalion->GetLocation(&oex,&oey);

	lea	ecx, DWORD PTR _oey$11[ebp]
	push	ecx
	lea	edx, DWORD PTR _oex$10[ebp]
	push	edx
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1440 : 				if ((role != GRO_FIRESUPPORT && other_role != GRO_FIRESUPPORT) || role == other_role)

	cmp	DWORD PTR _role$[ebp], 6
	je	SHORT $LN3@FindBestPo
	cmp	DWORD PTR _other_role$9[ebp], 6
	jne	SHORT $LN4@FindBestPo
$LN3@FindBestPo:
	mov	eax, DWORD PTR _role$[ebp]
	cmp	eax, DWORD PTR _other_role$9[ebp]
	jne	SHORT $LN6@FindBestPo
$LN4@FindBestPo:

; 1441 : 				{
; 1442 : 					other_score = ScorePosition (other_battalion, other_role, other_role_score, o, oex, oey, owned_by_us);

	mov	ecx, DWORD PTR _owned_by_us$[ebp]
	push	ecx
	movzx	edx, WORD PTR _oey$11[ebp]
	push	edx
	movzx	eax, WORD PTR _oex$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	mov	edx, DWORD PTR _other_role_score$8[ebp]
	push	edx
	mov	eax, DWORD PTR _other_role$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _other_battalion$[ebp]
	push	ecx
	call	?ScorePosition@@YAHPAVUnitClass@@HHPAVObjectiveClass@@FFH@Z ; ScorePosition
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _other_score$7[ebp], eax

; 1443 : 					if (other_score >= score)

	mov	edx, DWORD PTR _other_score$7[ebp]
	cmp	edx, DWORD PTR _score$[ebp]
	jl	SHORT $LN6@FindBestPo

; 1444 : 						score = -32000;

	mov	DWORD PTR _score$[ebp], -32000		; ffff8300H
$LN6@FindBestPo:

; 1445 : 					// COBRA - RED - To avoid infinite loop bug - let both having same objective
; 1446 : 					/*else
; 1447 : 					  other_battalion->SetAssigned(0);*/
; 1448 : 				}
; 1449 : 			}
; 1450 : 			other_battalion = (Battalion) brigade->GetNextUnitElement();

	mov	eax, DWORD PTR _brigade$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _other_battalion$[ebp], eax

; 1451 : 		}

	jmp	$LN8@FindBestPo
$LN7@FindBestPo:

; 1452 : 		if (score > bests)

	mov	ecx, DWORD PTR _score$[ebp]
	cmp	ecx, DWORD PTR _bests$[ebp]
	jle	SHORT $LN1@FindBestPo

; 1453 : 		{
; 1454 : 			bests = score;

	mov	edx, DWORD PTR _score$[ebp]
	mov	DWORD PTR _bests$[ebp], edx

; 1455 : 			besto = o;

	mov	eax, DWORD PTR _o$[ebp]
	mov	DWORD PTR _besto$[ebp], eax
$LN1@FindBestPo:

; 1456 : 		}
; 1457 : 	}

	jmp	$LN18@FindBestPo
$LN17@FindBestPo:

; 1458 : 
; 1459 : 	return besto;

	mov	ecx, DWORD PTR _besto$[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T6[ebp]

; 1460 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestPosition@@YAPAVObjectiveClass@@PAVUnitClass@@PAVBrigadeClass@@HPAVFalconPrivateList@@@Z ENDP ; FindBestPosition
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
tv84 = -20						; size = 4
_dist_from_front$ = -16					; size = 4
_score$ = -12						; size = 4
_ox$ = -8						; size = 2
_oy$ = -4						; size = 2
_battalion$ = 8						; size = 4
_role$ = 12						; size = 4
_role_score$ = 16					; size = 4
_o$ = 20						; size = 4
_x$ = 24						; size = 2
_y$ = 28						; size = 2
_owned_by_us$ = 32					; size = 4
?ScorePosition@@YAHPAVUnitClass@@HHPAVObjectiveClass@@FFH@Z PROC ; ScorePosition

; 1302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 1303 : 	int			score,dist_from_front;
; 1304 : 	GridIndex	ox,oy;
; 1305 : 
; 1306 : 	o->GetLocation(&ox,&oy);

	lea	eax, DWORD PTR _oy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1307 : 	// Check if this is a busted bridge
; 1308 : 	if (role != GRO_ENGINEER && o->GetType() == TYPE_BRIDGE && !o->GetObjectiveStatus())

	cmp	DWORD PTR _role$[ebp], 7
	je	SHORT $LN30@ScorePosit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 6
	jne	SHORT $LN30@ScorePosit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveStatus
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN30@ScorePosit

; 1309 : 		return -32000;

	mov	eax, -32000				; ffff8300H
	jmp	$LN31@ScorePosit
$LN30@ScorePosit:

; 1310 : 
; 1311 : 	switch (role)

	mov	ecx, DWORD PTR _role$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 7
	ja	$LN1@ScorePosit
	mov	edx, DWORD PTR tv84[ebp]
	jmp	DWORD PTR $LN33@ScorePosit[edx*4]
$LN27@ScorePosit:

; 1312 : 	{
; 1313 : 			case GRO_ATTACK:
; 1314 : 					// Find a good offensive position
; 1315 : 					score = role_score/3 - FloatToInt32(DistanceToFront(ox,oy)) - FloatToInt32(Distance(ox,oy,x,y)) - o->GetObjectiveScore()*10;		

	mov	eax, DWORD PTR _role_score$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	esi, eax
	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveScore@ObjectiveClass@@QAEHXZ ; ObjectiveClass::GetObjectiveScore
	imul	eax, 10					; 0000000aH
	sub	esi, eax
	mov	DWORD PTR _score$[ebp], esi

; 1316 : 					if (owned_by_us)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	je	SHORT $LN26@ScorePosit

; 1317 : 						score = -32000;							// Don't assign

	mov	DWORD PTR _score$[ebp], -32000		; ffff8300H

; 1318 : 					else

	jmp	SHORT $LN25@ScorePosit
$LN26@ScorePosit:

; 1319 : 						score += 100;

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _score$[ebp], edx
$LN25@ScorePosit:

; 1320 : 					break;

	jmp	$LN28@ScorePosit
$LN24@ScorePosit:

; 1321 : 			case GRO_DEFENSE:
; 1322 : 					// Find a good defensive position
; 1323 : 					score = role_score/3 - FloatToInt32(DistanceToFront(ox,oy)) - FloatToInt32(Distance(ox,oy,x,y)) - o->GetObjectiveScore()*4;

	mov	eax, DWORD PTR _role_score$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	esi, eax
	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveScore@ObjectiveClass@@QAEHXZ ; ObjectiveClass::GetObjectiveScore
	shl	eax, 2
	sub	esi, eax
	mov	DWORD PTR _score$[ebp], esi

; 1324 : 					if (!owned_by_us)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	jne	SHORT $LN23@ScorePosit

; 1325 : 						score = -32000;							// Don't assign

	mov	DWORD PTR _score$[ebp], -32000		; ffff8300H
	jmp	SHORT $LN21@ScorePosit
$LN23@ScorePosit:

; 1326 : 					else if (o->Abandoned())

	mov	ecx, DWORD PTR _o$[ebp]
	call	?Abandoned@ObjectiveClass@@QAEHXZ	; ObjectiveClass::Abandoned
	test	eax, eax
	je	SHORT $LN21@ScorePosit

; 1327 : 						score -= 800;							// We're pulling out of here.

	mov	edx, DWORD PTR _score$[ebp]
	sub	edx, 800				; 00000320H
	mov	DWORD PTR _score$[ebp], edx
$LN21@ScorePosit:

; 1328 : 					break;

	jmp	$LN28@ScorePosit
$LN20@ScorePosit:

; 1329 : 			case GRO_RESERVE:
; 1330 : 					// Assign to an objective out of the way
; 1331 : 					dist_from_front = FloatToInt32(DistanceToFront(ox,oy));

	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist_from_front$[ebp], eax

; 1332 : 					score = dist_from_front - FloatToInt32(Distance(ox,oy,x,y));

	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	movzx	ecx, WORD PTR _oy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ox$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _dist_from_front$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _score$[ebp], ecx

; 1333 : 					if (!owned_by_us)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	jne	SHORT $LN19@ScorePosit

; 1334 : 						score = -32000;							// Don't assign

	mov	DWORD PTR _score$[ebp], -32000		; ffff8300H
	jmp	SHORT $LN15@ScorePosit
$LN19@ScorePosit:

; 1335 : 					else if (!dist_from_front)

	cmp	DWORD PTR _dist_from_front$[ebp], 0
	jne	SHORT $LN17@ScorePosit

; 1336 : 						score -= 200;							// We want at least a second-line objective.

	mov	edx, DWORD PTR _score$[ebp]
	sub	edx, 200				; 000000c8H
	mov	DWORD PTR _score$[ebp], edx
	jmp	SHORT $LN15@ScorePosit
$LN17@ScorePosit:

; 1337 : 					else if (battalion->Broken())

	mov	ecx, DWORD PTR _battalion$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	je	SHORT $LN15@ScorePosit

; 1338 : 						score += dist_from_front*5;

	mov	eax, DWORD PTR _dist_from_front$[ebp]
	imul	eax, 5
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN15@ScorePosit:

; 1339 : 					// Try to prevent ping-pinging reserve units
; 1340 : 					if (score > -32000 && o->Id() == battalion->GetUnitObjectiveID())

	cmp	DWORD PTR _score$[ebp], -32000		; ffff8300H
	jle	SHORT $LN14@ScorePosit
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _battalion$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _battalion$[ebp]
	mov	edx, DWORD PTR [eax+876]
	call	edx
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@ScorePosit

; 1341 : 						score += 25;

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 25					; 00000019H
	mov	DWORD PTR _score$[ebp], edx
$LN14@ScorePosit:

; 1342 : 					break;

	jmp	$LN28@ScorePosit
$LN13@ScorePosit:

; 1343 : 			case GRO_AIRDEFENSE:
; 1344 : 					// Assign to defend the primary objective, if possible
; 1345 : 					score = role_score/3 + FloatToInt32(DistanceToFront(ox,oy)) - FloatToInt32(Distance(ox,oy,x,y)) - o->GetObjectiveScore()*50;

	mov	eax, DWORD PTR _role_score$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	esi, eax
	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveScore@ObjectiveClass@@QAEHXZ ; ObjectiveClass::GetObjectiveScore
	imul	eax, 50					; 00000032H
	sub	esi, eax
	mov	DWORD PTR _score$[ebp], esi

; 1346 : 					if (!owned_by_us)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	jne	SHORT $LN12@ScorePosit

; 1347 : 						score -= 500;

	mov	edx, DWORD PTR _score$[ebp]
	sub	edx, 500				; 000001f4H
	mov	DWORD PTR _score$[ebp], edx
$LN12@ScorePosit:

; 1348 : 					if (o->Abandoned())

	mov	ecx, DWORD PTR _o$[ebp]
	call	?Abandoned@ObjectiveClass@@QAEHXZ	; ObjectiveClass::Abandoned
	test	eax, eax
	je	SHORT $LN11@ScorePosit

; 1349 : 						score -= 500;

	mov	eax, DWORD PTR _score$[ebp]
	sub	eax, 500				; 000001f4H
	mov	DWORD PTR _score$[ebp], eax
$LN11@ScorePosit:

; 1350 : 					if (o->IsSecondary() || o->SamSite())		// KCK: Sam site? It'll double up pretty often.

	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondary
	test	eax, eax
	jne	SHORT $LN9@ScorePosit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?SamSite@ObjectiveClass@@QAEHXZ		; ObjectiveClass::SamSite
	test	eax, eax
	je	SHORT $LN10@ScorePosit
$LN9@ScorePosit:

; 1351 : 						score += 100;

	mov	ecx, DWORD PTR _score$[ebp]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _score$[ebp], ecx
$LN10@ScorePosit:

; 1352 : 					break;

	jmp	$LN28@ScorePosit
$LN8@ScorePosit:

; 1353 : 			case GRO_FIRESUPPORT:
; 1354 : 					// Assign to support a good frontline objective (enemy if available)
; 1355 : 					score = role_score/3 - FloatToInt32(DistanceToFront(ox,oy)) - FloatToInt32(Distance(ox,oy,x,y)) - o->GetObjectiveScore()*10;

	mov	eax, DWORD PTR _role_score$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	esi, eax
	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveScore@ObjectiveClass@@QAEHXZ ; ObjectiveClass::GetObjectiveScore
	imul	eax, 10					; 0000000aH
	sub	esi, eax
	mov	DWORD PTR _score$[ebp], esi

; 1356 : 					if (!owned_by_us)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	jne	SHORT $LN7@ScorePosit

; 1357 : 						score += 500;

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 500				; 000001f4H
	mov	DWORD PTR _score$[ebp], edx
$LN7@ScorePosit:

; 1358 : 					if (owned_by_us && o->Abandoned())

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	je	SHORT $LN6@ScorePosit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Abandoned@ObjectiveClass@@QAEHXZ	; ObjectiveClass::Abandoned
	test	eax, eax
	je	SHORT $LN6@ScorePosit

; 1359 : 						score -= 500;

	mov	eax, DWORD PTR _score$[ebp]
	sub	eax, 500				; 000001f4H
	mov	DWORD PTR _score$[ebp], eax
$LN6@ScorePosit:

; 1360 : 					if (o->IsSecondary())

	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondary
	test	eax, eax
	je	SHORT $LN5@ScorePosit

; 1361 : 						score += 100;

	mov	ecx, DWORD PTR _score$[ebp]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _score$[ebp], ecx
$LN5@ScorePosit:

; 1362 : 					break;

	jmp	SHORT $LN28@ScorePosit
$LN4@ScorePosit:

; 1363 : 			case GRO_ENGINEER:
; 1364 : 					// Assign to any bridges we may want to cross, otherwise nothing
; 1365 : 					if (owned_by_us && o->GetType() == TYPE_BRIDGE && o->GetObjectiveStatus() < 50)

	cmp	DWORD PTR _owned_by_us$[ebp], 0
	je	SHORT $LN3@ScorePosit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 6
	jne	SHORT $LN3@ScorePosit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveStatus
	movzx	eax, al
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN3@ScorePosit

; 1366 : 						score = 1000;							// Bonus for a damaged bridge

	mov	DWORD PTR _score$[ebp], 1000		; 000003e8H

; 1367 : 					else

	jmp	SHORT $LN2@ScorePosit
$LN3@ScorePosit:

; 1368 : 						score = -32000;

	mov	DWORD PTR _score$[ebp], -32000		; ffff8300H
$LN2@ScorePosit:

; 1369 : 					break;

	jmp	SHORT $LN28@ScorePosit
$LN1@ScorePosit:

; 1370 : 			default:
; 1371 : 					//			MonoPrint ("ScorePosition() Error: We should never get here!\n");
; 1372 : 					score = -32000;

	mov	DWORD PTR _score$[ebp], -32000		; ffff8300H
$LN28@ScorePosit:

; 1373 : 					break;
; 1374 : 	}
; 1375 : 
; 1376 : 	return score;

	mov	eax, DWORD PTR _score$[ebp]
$LN31@ScorePosit:

; 1377 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN33@ScorePosit:
	DD	$LN20@ScorePosit
	DD	$LN27@ScorePosit
	DD	$LN1@ScorePosit
	DD	$LN1@ScorePosit
	DD	$LN24@ScorePosit
	DD	$LN13@ScorePosit
	DD	$LN8@ScorePosit
	DD	$LN4@ScorePosit
?ScorePosition@@YAHPAVUnitClass@@HHPAVObjectiveClass@@FFH@Z ENDP ; ScorePosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -172						; size = 4
_mt$ = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 4
$T6 = -152						; size = 4
$T7 = -148						; size = 4
$T8 = -144						; size = 4
_ret$ = -140						; size = 4
_o$9 = -136						; size = 4
_h$ = -132						; size = 4
_bp$ = -128						; size = 4
_ox$ = -124						; size = 2
_oy$ = -120						; size = 2
_range$ = -116						; size = 4
_bo$ = -112						; size = 4
_i$ = -108						; size = 4
_brigade$ = -104					; size = 4
_d$ = -100						; size = 4
_me$ = -96						; size = 4
_mex$ = -92						; size = 2
_mey$ = -88						; size = 2
_ey$ = -84						; size = 2
_ex$ = -80						; size = 2
_path$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_e$ = 8							; size = 4
?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z PROC	; PositionToSupportUnit

; 1217 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1218 : 	int			d,h,i=0,bp=-1;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _bp$[ebp], -1

; 1219 : 	int			range,ret;
; 1220 : 	GridIndex	mex,mey,ex,ey,ox,oy;
; 1221 : 	MoveType	mt;
; 1222 : 	PathClass	path;

	lea	ecx, DWORD PTR _path$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1223 : 	Brigade		brigade;
; 1224 : 	Unit		me;
; 1225 : 	Objective	bo=NULL;

	mov	DWORD PTR _bo$[ebp], 0

; 1226 : 
; 1227 : 	ShiAssert (e->GetUnitOrders() == GORD_SUPPORT);
; 1228 : 
; 1229 : 	// We need a minimal usefull range
; 1230 : 	mt = NoMove;

	mov	DWORD PTR _mt$[ebp], 0

; 1231 : 	range = e->GetAproxWeaponRange(mt);

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+412]
	call	eax
	mov	DWORD PTR _range$[ebp], eax

; 1232 : 	if (range < 5)

	cmp	DWORD PTR _range$[ebp], 5
	jge	SHORT $LN15@PositionTo

; 1233 : 		return 0;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN16@PositionTo
$LN15@PositionTo:

; 1234 : 
; 1235 : 	// Brigade elements only
; 1236 : 	brigade = (Brigade) e->GetUnitParent();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brigade$[ebp], eax

; 1237 : 	if (!brigade)

	cmp	DWORD PTR _brigade$[ebp], 0
	jne	SHORT $LN14@PositionTo

; 1238 : 		return 0;

	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T6[ebp]
	jmp	$LN16@PositionTo
$LN14@PositionTo:

; 1239 : 	me = brigade->GetFirstUnitElement();

	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _me$[ebp], eax
$LN13@PositionTo:

; 1240 : 	while (me)

	cmp	DWORD PTR _me$[ebp], 0
	je	SHORT $LN12@PositionTo

; 1241 : 	{
; 1242 : 		if (me->GetUnitOrders() != GORD_SUPPORT && OrderPriority[me->GetUnitOrders()] > bp)

	mov	ecx, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _me$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	cmp	eax, 7
	je	SHORT $LN11@PositionTo
	mov	ecx, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _me$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	mov	ecx, DWORD PTR ?OrderPriority@@3PAHA[eax*4]
	cmp	ecx, DWORD PTR _bp$[ebp]
	jle	SHORT $LN11@PositionTo

; 1243 : 		{
; 1244 : 			bp = OrderPriority[me->GetUnitOrders()];

	mov	edx, DWORD PTR _me$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR [eax+880]
	call	edx
	mov	eax, DWORD PTR ?OrderPriority@@3PAHA[eax*4]
	mov	DWORD PTR _bp$[ebp], eax

; 1245 : 			bo = me->GetUnitObjective();

	mov	ecx, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _me$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _bo$[ebp], eax
$LN11@PositionTo:

; 1246 : 		}
; 1247 : 		me = brigade->GetNextUnitElement();

	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _brigade$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _me$[ebp], eax

; 1248 : 	}

	jmp	SHORT $LN13@PositionTo
$LN12@PositionTo:

; 1249 : 	if (!bo)

	cmp	DWORD PTR _bo$[ebp], 0
	jne	SHORT $LN10@PositionTo

; 1250 : 		return 0;

	mov	DWORD PTR $T8[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN16@PositionTo
$LN10@PositionTo:

; 1251 : 
; 1252 : 	// Check tolerance
; 1253 : 	e->GetLocation(&ex,&ey);

	lea	ecx, DWORD PTR _ey$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1254 : 	bo->GetLocation(&mex,&mey);

	lea	eax, DWORD PTR _mey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1255 : 	d = FloatToInt32(Distance(ex,ey,mex,mey));

	movzx	edx, WORD PTR _mey$[ebp]
	push	edx
	movzx	eax, WORD PTR _mex$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ey$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ex$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 1256 : 	if (d > range-2)

	mov	eax, DWORD PTR _range$[ebp]
	sub	eax, 2
	cmp	DWORD PTR _d$[ebp], eax
	jle	SHORT $LN9@PositionTo

; 1257 : 	{
; 1258 : 		// Get closer - Find a path from here to the objective
; 1259 : 		ret = e->GetUnitGridPath(&path,ex,ey,mex,mey);

	movzx	ecx, WORD PTR _mey$[ebp]
	push	ecx
	movzx	edx, WORD PTR _mex$[ebp]
	push	edx
	movzx	eax, WORD PTR _ey$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath
	mov	DWORD PTR _ret$[ebp], eax
	jmp	$LN5@PositionTo
$LN9@PositionTo:

; 1260 : 	}
; 1261 : 	else if (d < 2)

	cmp	DWORD PTR _d$[ebp], 2
	jge	$LN7@PositionTo

; 1262 : 	{
; 1263 : 		// Back off - Find a path from the objective to a friendly secondline objective
; 1264 : 		Objective	o;
; 1265 : 		o = FindRetreatPath(e,3,0);

	push	0
	push	3
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z ; FindRetreatPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _o$9[ebp], eax

; 1266 : 		if (!o)

	cmp	DWORD PTR _o$9[ebp], 0
	jne	SHORT $LN6@PositionTo

; 1267 : 			return e->CheckForSurrender();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+936]
	call	eax
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN16@PositionTo
$LN6@PositionTo:

; 1268 : 		o->GetLocation(&ox,&oy);

	lea	ecx, DWORD PTR _oy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ox$[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$9[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1269 : 		ret = e->GetUnitGridPath(&path,mex,mey,ox,oy);

	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	movzx	edx, WORD PTR _mey$[ebp]
	push	edx
	movzx	eax, WORD PTR _mex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath
	mov	DWORD PTR _ret$[ebp], eax

; 1270 : 		ex = mex;

	mov	dx, WORD PTR _mex$[ebp]
	mov	WORD PTR _ex$[ebp], dx

; 1271 : 		ey = mey;

	mov	ax, WORD PTR _mey$[ebp]
	mov	WORD PTR _ey$[ebp], ax

; 1272 : 	}
; 1273 : 	else

	jmp	SHORT $LN5@PositionTo
$LN7@PositionTo:

; 1274 : 	{
; 1275 : 		// We're fine where we are
; 1276 : 		e->SetUnitDestination(ex,ey);

	movzx	ecx, WORD PTR _ey$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 1277 : 		e->SetTempDest(1);

	push	1
	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest

; 1278 : 		return 1;

	mov	DWORD PTR $T7[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN16@PositionTo
$LN5@PositionTo:

; 1279 : 	}
; 1280 : 
; 1281 : 	// Couldn't find a way there
; 1282 : 	if (ret < 1)

	cmp	DWORD PTR _ret$[ebp], 1
	jge	SHORT $LN4@PositionTo

; 1283 : 		return 0;

	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN16@PositionTo
$LN4@PositionTo:

; 1284 : 
; 1285 : 	// Now determine our new location
; 1286 : 	while (i < path.GetLength() && (d < 2 || d > range-2))

	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetLength@BasePathClass@@QAEHXZ	; BasePathClass::GetLength
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN2@PositionTo
	cmp	DWORD PTR _d$[ebp], 2
	jl	SHORT $LN1@PositionTo
	mov	eax, DWORD PTR _range$[ebp]
	sub	eax, 2
	cmp	DWORD PTR _d$[ebp], eax
	jle	SHORT $LN2@PositionTo
$LN1@PositionTo:

; 1287 : 	{
; 1288 : 		h = path.GetDirection(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	DWORD PTR _h$[ebp], eax

; 1289 : 		ex += dx[h];

	mov	edx, DWORD PTR _h$[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	movsx	ecx, WORD PTR _ex$[ebp]
	add	ecx, eax
	mov	WORD PTR _ex$[ebp], cx

; 1290 : 		ey += dy[h];

	mov	edx, DWORD PTR _h$[ebp]
	movsx	eax, WORD PTR ?dy@@3PAFA[edx*2]
	movsx	ecx, WORD PTR _ey$[ebp]
	add	ecx, eax
	mov	WORD PTR _ey$[ebp], cx

; 1291 : 		d = FloatToInt32(Distance(ex,ey,mex,mey));

	movzx	edx, WORD PTR _mey$[ebp]
	push	edx
	movzx	eax, WORD PTR _mex$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ey$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ex$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 1292 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1293 : 	}

	jmp	$LN4@PositionTo
$LN2@PositionTo:

; 1294 : 
; 1295 : 	// Copy in new data
; 1296 : 	e->SetUnitDestination(ex,ey);

	movzx	ecx, WORD PTR _ey$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 1297 : 	e->SetTempDest(1);

	push	1
	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest

; 1298 : 	return 1;

	mov	DWORD PTR $T3[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
$LN16@PositionTo:

; 1299 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z$0:
	lea	ecx, DWORD PTR _path$[ebp]
	jmp	??1PathClass@@QAE@XZ
__ehhandler$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z ENDP	; PositionToSupportUnit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_num$ = -28						; size = 4
_total$ = -24						; size = 4
_bonus$ = -20						; size = 4
_i$ = -16						; size = 4
_dir$ = -12						; size = 4
_cur$ = -8						; size = 4
_h$ = -2						; size = 1
_first$ = -1						; size = 1
_path$ = 8						; size = 4
?GetAverageHeading@@YAEPAVBasePathClass@@@Z PROC	; GetAverageHeading

; 1029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1030 : 	CampaignHeading h,first;
; 1031 : 	int             total, cur, i=0, bonus=0, num=1;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _bonus$[ebp], 0
	mov	DWORD PTR _num$[ebp], 1

; 1032 : 	float           dir;
; 1033 : 
; 1034 : 	if (path == NULL)

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN12@GetAverage

; 1035 : 		return Here;

	mov	al, 8
	jmp	$LN13@GetAverage
$LN12@GetAverage:

; 1036 : 	first = (CampaignHeading) path->GetDirection(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	BYTE PTR _first$[ebp], al

; 1037 : 	total = (int) first;

	movzx	ecx, BYTE PTR _first$[ebp]
	mov	DWORD PTR _total$[ebp], ecx

; 1038 : 	for (i=1; i<4; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN11@GetAverage
$LN10@GetAverage:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN11@GetAverage:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN9@GetAverage

; 1039 : 	{
; 1040 : 		cur = (int) path->GetDirection(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	DWORD PTR _cur$[ebp], eax

; 1041 : 		if (cur >= 0)

	cmp	DWORD PTR _cur$[ebp], 0
	jl	SHORT $LN8@GetAverage

; 1042 : 		{
; 1043 : 			if ((cur-first) > 4)

	movzx	ecx, BYTE PTR _first$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, ecx
	cmp	edx, 4
	jle	SHORT $LN7@GetAverage

; 1044 : 				cur -=8;

	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN7@GetAverage:

; 1045 : 			if ((first-cur) > 4)

	movzx	ecx, BYTE PTR _first$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 4
	jle	SHORT $LN6@GetAverage

; 1046 : 				cur +=8;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 8
	mov	DWORD PTR _cur$[ebp], edx
$LN6@GetAverage:

; 1047 : 			if (cur > first)

	movzx	eax, BYTE PTR _first$[ebp]
	cmp	DWORD PTR _cur$[ebp], eax
	jle	SHORT $LN5@GetAverage

; 1048 : 				bonus++;

	mov	ecx, DWORD PTR _bonus$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bonus$[ebp], ecx
$LN5@GetAverage:

; 1049 : 			if (cur < first)

	movzx	edx, BYTE PTR _first$[ebp]
	cmp	DWORD PTR _cur$[ebp], edx
	jge	SHORT $LN4@GetAverage

; 1050 : 				bonus--;

	mov	eax, DWORD PTR _bonus$[ebp]
	sub	eax, 1
	mov	DWORD PTR _bonus$[ebp], eax
$LN4@GetAverage:

; 1051 : 			total += cur;

	mov	ecx, DWORD PTR _total$[ebp]
	add	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _total$[ebp], ecx

; 1052 : 			num++;

	mov	edx, DWORD PTR _num$[ebp]
	add	edx, 1
	mov	DWORD PTR _num$[ebp], edx
$LN8@GetAverage:

; 1053 : 		}
; 1054 : 	}

	jmp	$LN10@GetAverage
$LN9@GetAverage:

; 1055 : 	dir = (float) total/num;

	cvtsi2ss xmm0, DWORD PTR _total$[ebp]
	cvtsi2ss xmm1, DWORD PTR _num$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _dir$[ebp], xmm0

; 1056 : 	if (bonus < 0)

	cmp	DWORD PTR _bonus$[ebp], 0
	jge	SHORT $LN3@GetAverage

; 1057 : 		dir += 0.5F;

	movss	xmm0, DWORD PTR _dir$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _dir$[ebp], xmm0
$LN3@GetAverage:

; 1058 : 	if (dir < 0)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _dir$[ebp]
	jbe	SHORT $LN2@GetAverage

; 1059 : 		dir += 8;

	movss	xmm0, DWORD PTR _dir$[ebp]
	addss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _dir$[ebp], xmm0
$LN2@GetAverage:

; 1060 : 	if (dir > 7)

	movss	xmm0, DWORD PTR _dir$[ebp]
	comiss	xmm0, DWORD PTR __real@40e00000
	jbe	SHORT $LN1@GetAverage

; 1061 : 		dir -= 8;

	movss	xmm0, DWORD PTR _dir$[ebp]
	subss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _dir$[ebp], xmm0
$LN1@GetAverage:

; 1062 : 	h = (CampaignHeading) dir;

	cvttss2si eax, DWORD PTR _dir$[ebp]
	mov	BYTE PTR _h$[ebp], al

; 1063 : 	return h;

	mov	al, BYTE PTR _h$[ebp]
$LN13@GetAverage:

; 1064 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAverageHeading@@YAEPAVBasePathClass@@@Z ENDP	; GetAverageHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_action$ = -4						; size = 4
_u$ = 8							; size = 4
_o$ = 12						; size = 4
_n$ = 16						; size = 4
_d$ = 20						; size = 4
_us$ = 24						; size = 1
_cost$ = 28						; size = 4
?GetThisWPAction@@YAHPAVUnitClass@@PAVObjectiveClass@@1HEPAM@Z PROC ; GetThisWPAction

; 746  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 747  : 	int	action;
; 748  : 
; 749  : 	if (o->GetType() == TYPE_SEA || n->GetType() == TYPE_SEA)

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	eax, al
	cmp	eax, 27					; 0000001bH
	je	SHORT $LN6@GetThisWPA
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 27					; 0000001bH
	jne	SHORT $LN7@GetThisWPA
$LN6@GetThisWPA:

; 750  : 	{
; 751  : 		action = WP_AMPHIBIOUS;

	mov	DWORD PTR _action$[ebp], 43		; 0000002bH

; 752  : 		*cost = o->GetNeighborCost(d,Naval);

	push	6
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ; ObjectiveClass::GetNeighborCost
	mov	eax, DWORD PTR _cost$[ebp]
	fstp	DWORD PTR [eax]
	jmp	SHORT $LN1@GetThisWPA
$LN7@GetThisWPA:

; 753  : 	}
; 754  : 	else if (GetRoE(us,n->GetTeam(),ROE_GROUND_FIRE))

	push	1
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	movzx	edx, BYTE PTR _us$[ebp]
	push	edx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@GetThisWPA

; 755  : 		action = WP_MOVEOPPOSED;

	mov	DWORD PTR _action$[ebp], 40		; 00000028H
	jmp	SHORT $LN1@GetThisWPA
$LN4@GetThisWPA:

; 756  : 	else if (u->GetUnitNormalRole() == GRO_AIRBORNE)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 3
	jne	SHORT $LN2@GetThisWPA

; 757  : 	{
; 758  : 		action = WP_AIRBORNE;

	mov	DWORD PTR _action$[ebp], 42		; 0000002aH

; 759  : 		*cost = o->GetNeighborCost(d,LowAir);

	push	4
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ; ObjectiveClass::GetNeighborCost
	mov	edx, DWORD PTR _cost$[ebp]
	fstp	DWORD PTR [edx]

; 760  : 	}
; 761  : 	else

	jmp	SHORT $LN1@GetThisWPA
$LN2@GetThisWPA:

; 762  : 		action = WP_MOVEUNOPPOSED;

	mov	DWORD PTR _action$[ebp], 41		; 00000029H
$LN1@GetThisWPA:

; 763  : 	return action;

	mov	eax, DWORD PTR _action$[ebp]

; 764  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetThisWPAction@@YAHPAVUnitClass@@PAVObjectiveClass@@1HEPAM@Z ENDP ; GetThisWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_u$ = 8							; size = 4
?RequestMarineTransport@@YAHPAVUnitClass@@@Z PROC	; RequestMarineTransport

; 1802 : {

	push	ebp
	mov	ebp, esp

; 1803 : 	// KCK TODO!
; 1804 : 	return 1;

	mov	eax, 1

; 1805 : }

	pop	ebp
	ret	0
?RequestMarineTransport@@YAHPAVUnitClass@@@Z ENDP	; RequestMarineTransport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -124						; size = 8
$T3 = -116						; size = 8
$T4 = -108						; size = 8
$T5 = -100						; size = 4
$T6 = -96						; size = 4
_mis$ = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
?RequestAirborneTransport@@YAHPAVUnitClass@@@Z PROC	; RequestAirborneTransport

; 1767 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1768 : 	MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1769 : 
; 1770 : 	// Check if we've already made a request
; 1771 : 	if (u->GetCargoId() != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetCargoId
	mov	ecx, eax
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@RequestAir

; 1772 : 		return 1;

	mov	DWORD PTR $T5[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN4@RequestAir
$LN3@RequestAir:

; 1773 : 
; 1774 : 	// Mark unit as waiting for a transport reply. If we get a replay before we time out,
; 1775 : 	// we've got a ticket.
; 1776 : 	u->SetCargoId(u->Id());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z	; UnitClass::SetCargoId

; 1777 : 
; 1778 : 	// Make the request
; 1779 : 	mis.who = u->GetTeam();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$[ebp+32], al

; 1780 : 	mis.vs = 0;

	mov	BYTE PTR _mis$[ebp+33], 0

; 1781 : 	mis.flags = REQF_NEEDRESPONSE | REQF_ONETRY;

	mov	DWORD PTR _mis$[ebp+44], 260		; 00000104H

; 1782 : 	mis.tot = TheCampaign.CurrentTime + 10*CampaignMinutes;

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	add	ecx, 600000				; 000927c0H
	mov	DWORD PTR _mis$[ebp+36], ecx

; 1783 : 	mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$[ebp+58], 0

; 1784 : 	u->GetUnitDestination(&mis.tx,&mis.ty);

	lea	edx, DWORD PTR _mis$[ebp+42]
	push	edx
	lea	eax, DWORD PTR _mis$[ebp+40]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 1785 : 	mis.requesterID = u->Id();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], edx
	mov	DWORD PTR _mis$[ebp+4], eax

; 1786 : 	mis.mission = AMIS_AIRCAV;

	mov	BYTE PTR _mis$[ebp+60], 32		; 00000020H

; 1787 : 	mis.context = friendlyUnitAirborneMovement;

	mov	BYTE PTR _mis$[ebp+62], 11		; 0000000bH

; 1788 : 	// RV - Biker - 16 choppers for 16 soldiers... does this make sense???
; 1789 : 	// mis.aircraft = u->GetTotalVehicles();
; 1790 : 	mis.aircraft = rand()%6;

	call	_rand
	cdq
	mov	ecx, 6
	idiv	ecx
	mov	BYTE PTR _mis$[ebp+61], dl

; 1791 : 	
; 1792 : 	if (mis.aircraft < 2)

	movzx	edx, BYTE PTR _mis$[ebp+61]
	cmp	edx, 2
	jge	SHORT $LN2@RequestAir

; 1793 : 		mis.aircraft = 2;

	mov	BYTE PTR _mis$[ebp+61], 2
$LN2@RequestAir:

; 1794 : 	if (mis.aircraft > 4)

	movzx	eax, BYTE PTR _mis$[ebp+61]
	cmp	eax, 4
	jle	SHORT $LN1@RequestAir

; 1795 : 		mis.aircraft = 4;

	mov	BYTE PTR _mis$[ebp+61], 4
$LN1@RequestAir:

; 1796 : 
; 1797 : 	mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission

; 1798 : 	return 1;

	mov	DWORD PTR $T6[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T6[ebp]
$LN4@RequestAir:

; 1799 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z$0:
	lea	ecx, DWORD PTR _mis$[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__ehhandler$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestAirborneTransport@@YAHPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestAirborneTransport@@YAHPAVUnitClass@@@Z ENDP	; RequestAirborneTransport
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
tv154 = -20						; size = 4
tv142 = -16						; size = 4
_adjt$ = -12						; size = 4
_num$ = -8						; size = 4
_e$ = -4						; size = 4
_u$ = 8							; size = 4
?MinAdjustLevel@@YAHPAVUnitClass@@@Z PROC		; MinAdjustLevel

; 1970 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1971 : 	Unit		e;
; 1972 : 	int			adjt=0,num=0;

	mov	DWORD PTR _adjt$[ebp], 0
	mov	DWORD PTR _num$[ebp], 0

; 1973 : 
; 1974 : 	if (u->Real())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	je	SHORT $LN4@MinAdjustL

; 1975 : 		return FloatToInt32(u->AdjustForSupply()*100.0F);

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+512]
	call	eax
	fstp	DWORD PTR tv142[ebp]
	movss	xmm0, DWORD PTR tv142[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	jmp	SHORT $LN5@MinAdjustL
$LN4@MinAdjustL:

; 1976 : 
; 1977 : 	e = u->GetFirstUnitElement();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN3@MinAdjustL:

; 1978 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN2@MinAdjustL

; 1979 : 	{
; 1980 : 		adjt += FloatToInt32(e->AdjustForSupply()*100.0F);

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+512]
	call	eax
	fstp	DWORD PTR tv154[ebp]
	movss	xmm0, DWORD PTR tv154[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _adjt$[ebp]
	mov	DWORD PTR _adjt$[ebp], eax

; 1981 : 		num++;

	mov	ecx, DWORD PTR _num$[ebp]
	add	ecx, 1
	mov	DWORD PTR _num$[ebp], ecx

; 1982 : 		e = u->GetNextUnitElement();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+960]
	call	edx
	mov	DWORD PTR _e$[ebp], eax

; 1983 : 	}

	jmp	SHORT $LN3@MinAdjustL
$LN2@MinAdjustL:

; 1984 : 	if (!num)

	cmp	DWORD PTR _num$[ebp], 0
	jne	SHORT $LN1@MinAdjustL

; 1985 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN5@MinAdjustL
$LN1@MinAdjustL:

; 1986 : 	return adjt/num;

	mov	eax, DWORD PTR _adjt$[ebp]
	cdq
	idiv	DWORD PTR _num$[ebp]
$LN5@MinAdjustL:

; 1987 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MinAdjustLevel@@YAHPAVUnitClass@@@Z ENDP		; MinAdjustLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ PROC ; TeamClass::GetGroundAction, COMDAT
; _this$ = ecx

; 277  : 	TeamGndActionType *GetGroundAction (void) { return &groundAction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ENDP ; TeamClass::GetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_orders$ = -8						; size = 4
tv64 = -4						; size = 4
_role$ = 8						; size = 4
?GetGroundOrders@@YAHH@Z PROC				; GetGroundOrders

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2049 : 	int orders = GRO_RESERVE;

	mov	DWORD PTR _orders$[ebp], 0

; 2050 : 
; 2051 : 	switch (role)

	mov	eax, DWORD PTR _role$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 7
	ja	SHORT $LN1@GetGroundO
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@GetGroundO[edx*4]
$LN9@GetGroundO:

; 2052 : 	{
; 2053 : 			case GRO_ATTACK:
; 2054 : 					return GORD_CAPTURE;

	mov	eax, 1
	jmp	SHORT $LN12@GetGroundO

; 2055 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN8@GetGroundO:

; 2056 : 			case GRO_ASSAULT:
; 2057 : 					return GORD_ASSAULT;

	mov	eax, 3
	jmp	SHORT $LN12@GetGroundO

; 2058 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN7@GetGroundO:

; 2059 : 			case GRO_AIRBORNE:
; 2060 : 					return GORD_AIRBORNE;

	mov	eax, 4
	jmp	SHORT $LN12@GetGroundO

; 2061 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN6@GetGroundO:

; 2062 : 			case GRO_DEFENSE:
; 2063 : 					return GORD_DEFEND;

	mov	eax, 6
	jmp	SHORT $LN12@GetGroundO

; 2064 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN5@GetGroundO:

; 2065 : 			case GRO_AIRDEFENSE:
; 2066 : 					return GORD_AIRDEFENSE;

	mov	eax, 9
	jmp	SHORT $LN12@GetGroundO

; 2067 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN4@GetGroundO:

; 2068 : 			case GRO_FIRESUPPORT:
; 2069 : 					return GORD_SUPPORT;

	mov	eax, 7
	jmp	SHORT $LN12@GetGroundO

; 2070 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN3@GetGroundO:

; 2071 : 			case GRO_ENGINEER:
; 2072 : 					return GORD_REPAIR;

	mov	eax, 8
	jmp	SHORT $LN12@GetGroundO

; 2073 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN2@GetGroundO:

; 2074 : 			case GRO_RECON:
; 2075 : 					return GORD_RADAR;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN12@GetGroundO

; 2076 : 					break;

	jmp	SHORT $LN10@GetGroundO
$LN1@GetGroundO:

; 2077 : 			case GRO_RESERVE:
; 2078 : 			default:
; 2079 : 					return GORD_RESERVE;

	xor	eax, eax
	jmp	SHORT $LN12@GetGroundO
$LN10@GetGroundO:

; 2080 : 					break;
; 2081 : 	}
; 2082 : 	return 0;

	xor	eax, eax
$LN12@GetGroundO:

; 2083 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@GetGroundO:
	DD	$LN9@GetGroundO
	DD	$LN8@GetGroundO
	DD	$LN7@GetGroundO
	DD	$LN6@GetGroundO
	DD	$LN5@GetGroundO
	DD	$LN4@GetGroundO
	DD	$LN3@GetGroundO
	DD	$LN2@GetGroundO
?GetGroundOrders@@YAHH@Z ENDP				; GetGroundOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_role$ = -4						; size = 4
_orders$ = 8						; size = 4
?GetGroundRole@@YAHH@Z PROC				; GetGroundRole

; 2002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2003 : 	int role = GRO_RESERVE;

	mov	DWORD PTR _role$[ebp], 0

; 2004 : 
; 2005 : 	switch (orders)

	mov	eax, DWORD PTR _orders$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 10			; 0000000aH
	ja	SHORT $LN1@GetGroundR
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN15@GetGroundR[edx*4]
$LN10@GetGroundR:

; 2006 : 	{
; 2007 : 			case GORD_CAPTURE:
; 2008 : 			case GORD_SECURE:
; 2009 : 					role = GRO_ATTACK;

	mov	DWORD PTR _role$[ebp], 1

; 2010 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN9@GetGroundR:

; 2011 : 			case GORD_ASSAULT:
; 2012 : 					role = GRO_ATTACK;

	mov	DWORD PTR _role$[ebp], 1

; 2013 : 					//			role = GRO_ASSAULT;			// We need GRO_ASSAULT to do this, but the role is attack
; 2014 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN8@GetGroundR:

; 2015 : 			case GORD_AIRBORNE:
; 2016 : 					role = GRO_ATTACK;

	mov	DWORD PTR _role$[ebp], 1

; 2017 : 					//			role = GRO_AIRBORNE;		// We need GRO_AIRBORNE to do this, but the role is attack
; 2018 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN7@GetGroundR:

; 2019 : 			case GORD_COMMANDO:
; 2020 : 					role = GRO_AIRDEFENSE;

	mov	DWORD PTR _role$[ebp], 5

; 2021 : 					//			role = GRO_AIRBORNE;		// We need GRO_AIRBORNE to do this, but the role is air defense
; 2022 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN6@GetGroundR:

; 2023 : 			case GORD_DEFEND:
; 2024 : 					role = GRO_DEFENSE;

	mov	DWORD PTR _role$[ebp], 4

; 2025 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN5@GetGroundR:

; 2026 : 			case GORD_SUPPORT:
; 2027 : 					role = GRO_FIRESUPPORT;

	mov	DWORD PTR _role$[ebp], 6

; 2028 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN4@GetGroundR:

; 2029 : 			case GORD_REPAIR:
; 2030 : 					role = GRO_ENGINEER;

	mov	DWORD PTR _role$[ebp], 7

; 2031 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN3@GetGroundR:

; 2032 : 			case GORD_AIRDEFENSE:
; 2033 : 					role = GRO_AIRDEFENSE;

	mov	DWORD PTR _role$[ebp], 5

; 2034 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN2@GetGroundR:

; 2035 : 			case GORD_RADAR:
; 2036 : 			case GORD_RECON:
; 2037 : 					role = GRO_RECON;

	mov	DWORD PTR _role$[ebp], 8

; 2038 : 					break;

	jmp	SHORT $LN11@GetGroundR
$LN1@GetGroundR:

; 2039 : 			case GORD_RESERVE:
; 2040 : 			default:
; 2041 : 					role = GRO_RESERVE;

	mov	DWORD PTR _role$[ebp], 0
$LN11@GetGroundR:

; 2042 : 					break;
; 2043 : 	}
; 2044 : 	return role;

	mov	eax, DWORD PTR _role$[ebp]

; 2045 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@GetGroundR:
	DD	$LN10@GetGroundR
	DD	$LN10@GetGroundR
	DD	$LN9@GetGroundR
	DD	$LN8@GetGroundR
	DD	$LN7@GetGroundR
	DD	$LN6@GetGroundR
	DD	$LN5@GetGroundR
	DD	$LN4@GetGroundR
	DD	$LN3@GetGroundR
	DD	$LN2@GetGroundR
	DD	$LN2@GetGroundR
?GetGroundRole@@YAHH@Z ENDP				; GetGroundRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -124						; size = 8
$T3 = -116						; size = 8
$T4 = -108						; size = 8
_timeleft$ = -100					; size = 4
_brig$ = -96						; size = 4
_mis$ = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
_x$ = 12						; size = 2
_y$ = 16						; size = 2
_time$ = 20						; size = 4
?RequestBAI@@YAXPAVUnitClass@@FFK@Z PROC		; RequestBAI

; 1733 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestBAI@@YAXPAVUnitClass@@FFK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1734 : 	MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1735 : 	int					timeleft;
; 1736 : 	Brigade				brig = (Brigade) u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brig$[ebp], eax

; 1737 : 
; 1738 : 	timeleft = (int) ((time - Camp_GetCurrentTime())/CampaignMinutes);

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, eax
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 60000				; 0000ea60H
	div	ecx
	mov	DWORD PTR _timeleft$[ebp], eax

; 1739 : 	if (timeleft < MissionData[AMIS_BAI].min_time || timeleft > MissionData[AMIS_BAI].max_time)

	mov	edx, 32					; 00000020H
	imul	edx, 25					; 00000019H
	movzx	eax, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[edx+19]
	cmp	DWORD PTR _timeleft$[ebp], eax
	jl	SHORT $LN5@RequestBAI
	mov	ecx, 32					; 00000020H
	imul	ecx, 25					; 00000019H
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+20]
	cmp	DWORD PTR _timeleft$[ebp], edx
	jle	SHORT $LN6@RequestBAI
$LN5@RequestBAI:

; 1740 : 		return;		// Not in required time parameters

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	jmp	$LN7@RequestBAI
$LN6@RequestBAI:

; 1741 : 	mis.tot = time;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _mis$[ebp+36], eax

; 1742 : 	mis.vs = u->GetTeam();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$[ebp+33], al

; 1743 : 	mis.tot_type = TYPE_GE;

	mov	BYTE PTR _mis$[ebp+58], 4

; 1744 : 	mis.tx = x;

	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR _mis$[ebp+40], cx

; 1745 : 	mis.ty = y;

	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR _mis$[ebp+42], dx

; 1746 : 	if (brig)

	cmp	DWORD PTR _brig$[ebp], 0
	je	SHORT $LN4@RequestBAI

; 1747 : 	{
; 1748 : 		mis.requesterID = brig->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _brig$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 1749 : 		//		mis.targetID = brig->Id();
; 1750 : 	}
; 1751 : 	else

	jmp	SHORT $LN3@RequestBAI
$LN4@RequestBAI:

; 1752 : 	{
; 1753 : 		mis.requesterID = u->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx
$LN3@RequestBAI:

; 1754 : 		//		mis.targetID = u->Id();
; 1755 : 	}
; 1756 : 	mis.targetID = u->Id();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 1757 : 	mis.mission = AMIS_BAI;

	mov	BYTE PTR _mis$[ebp+60], 25		; 00000019H

; 1758 : 	if (u->GetUnitCurrentRole() == GRO_ATTACK)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN2@RequestBAI

; 1759 : 		mis.context = enemyUnitAdvance;

	mov	BYTE PTR _mis$[ebp+62], 3

; 1760 : 	else

	jmp	SHORT $LN1@RequestBAI
$LN2@RequestBAI:

; 1761 : 		mis.context = enemyUnitMove;

	mov	BYTE PTR _mis$[ebp+62], 4
$LN1@RequestBAI:

; 1762 : 	mis.roe_check = ROE_GROUND_FIRE;

	mov	BYTE PTR _mis$[ebp+63], 1

; 1763 : 	mis.RequestEnemyMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestEnemyMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestEnemyMission

; 1764 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
$LN7@RequestBAI:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestBAI@@YAXPAVUnitClass@@FFK@Z$0:
	lea	ecx, DWORD PTR _mis$[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__ehhandler$?RequestBAI@@YAXPAVUnitClass@@FFK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestBAI@@YAXPAVUnitClass@@FFK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestBAI@@YAXPAVUnitClass@@FFK@Z ENDP		; RequestBAI
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -124						; size = 8
$T3 = -116						; size = 8
$T4 = -108						; size = 8
_timeleft$ = -100					; size = 4
_brig$ = -96						; size = 4
_mis$ = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
_x$ = 12						; size = 2
_y$ = 16						; size = 2
_time$ = 20						; size = 4
?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z PROC		; RequestOCCAS

; 1698 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1699 : 	MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1700 : 	int					timeleft;
; 1701 : 	Brigade				brig = (Brigade) u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brig$[ebp], eax

; 1702 : 
; 1703 : 	timeleft = (int) ((time - Camp_GetCurrentTime())/CampaignMinutes);

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, eax
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 60000				; 0000ea60H
	div	ecx
	mov	DWORD PTR _timeleft$[ebp], eax

; 1704 : 	if (timeleft < MissionData[AMIS_ONCALLCAS].min_time || timeleft > MissionData[AMIS_ONCALLCAS].max_time)

	mov	edx, 32					; 00000020H
	imul	edx, 20					; 00000014H
	movzx	eax, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[edx+19]
	cmp	DWORD PTR _timeleft$[ebp], eax
	jl	SHORT $LN5@RequestOCC
	mov	ecx, 32					; 00000020H
	imul	ecx, 20					; 00000014H
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+20]
	cmp	DWORD PTR _timeleft$[ebp], edx
	jle	SHORT $LN6@RequestOCC
$LN5@RequestOCC:

; 1705 : 		return;		// Not in required time parameters

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	jmp	$LN7@RequestOCC
$LN6@RequestOCC:

; 1706 : 	mis.tot = time;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _mis$[ebp+36], eax

; 1707 : 	mis.vs = u->GetTeam();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$[ebp+33], al

; 1708 : 	mis.tot_type = TYPE_GE;

	mov	BYTE PTR _mis$[ebp+58], 4

; 1709 : 	mis.tx = x;

	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR _mis$[ebp+40], cx

; 1710 : 	mis.ty = y;

	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR _mis$[ebp+42], dx

; 1711 : 	if (brig)

	cmp	DWORD PTR _brig$[ebp], 0
	je	SHORT $LN4@RequestOCC

; 1712 : 	{
; 1713 : 		mis.requesterID = brig->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _brig$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx

; 1714 : 		//		mis.targetID = brig->Id();
; 1715 : 	}
; 1716 : 	else

	jmp	SHORT $LN3@RequestOCC
$LN4@RequestOCC:

; 1717 : 	{
; 1718 : 		mis.requesterID = u->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp], ecx
	mov	DWORD PTR _mis$[ebp+4], edx
$LN3@RequestOCC:

; 1719 : 		//		mis.targetID = u->Id();
; 1720 : 	}
; 1721 : 	mis.targetID = u->Id();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 1722 : 	mis.mission = AMIS_ONCALLCAS;

	mov	BYTE PTR _mis$[ebp+60], 20		; 00000014H

; 1723 : 	if (u->GetUnitCurrentRole() == GRO_ATTACK)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN2@RequestOCC

; 1724 : 		mis.context = enemyUnitAttacking;

	mov	BYTE PTR _mis$[ebp+62], 5

; 1725 : 	else

	jmp	SHORT $LN1@RequestOCC
$LN2@RequestOCC:

; 1726 : 		mis.context = enemyUnitDefending;

	mov	BYTE PTR _mis$[ebp+62], 6
$LN1@RequestOCC:

; 1727 : 	mis.roe_check = ROE_GROUND_FIRE;

	mov	BYTE PTR _mis$[ebp+63], 1

; 1728 : 	mis.RequestEnemyMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestEnemyMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestEnemyMission

; 1729 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
$LN7@RequestOCC:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z$0:
	lea	ecx, DWORD PTR _mis$[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__ehhandler$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z ENDP		; RequestOCCAS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -204						; size = 8
$T3 = -196						; size = 8
$T4 = -188						; size = 8
$T5 = -180						; size = 8
$T6 = -172						; size = 4
_mt$ = -168						; size = 4
$T7 = -164						; size = 4
tv359 = -160						; size = 4
_d$ = -156						; size = 4
tv138 = -152						; size = 4
_best$ = -148						; size = 4
$T8 = -144						; size = 4
_ty$ = -140						; size = 2
_y$ = -136						; size = 2
_foundcas$ = -132					; size = 4
_tx$ = -128						; size = 2
$T9 = -124						; size = 4
_x$ = -120						; size = 2
_myit$ = -116						; size = 4
_team$ = -112						; size = 4
_art$ = -108						; size = 4
_bonus$10 = -104					; size = 4
_score$ = -100						; size = 4
_u$ = -96						; size = 4
_mis$11 = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_req$ = 8						; size = 4
_target$ = 12						; size = 4
?RequestSupport@@YAHPAVUnitClass@@0@Z PROC		; RequestSupport

; 1618 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestSupport@@YAHPAVUnitClass@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1619 : 	VuGridIterator		*myit;
; 1620 : 	Unit				u,art=NULL;

	mov	DWORD PTR _art$[ebp], 0

; 1621 : 	GridIndex			tx,ty,x,y;
; 1622 : 	Int32				score,best=9999,d,foundcas=0,team = req->GetTeam();

	mov	DWORD PTR _best$[ebp], 9999		; 0000270fH
	mov	DWORD PTR _foundcas$[ebp], 0
	mov	eax, DWORD PTR _req$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _req$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _team$[ebp], ecx

; 1623 : 	MoveType			mt;
; 1624 : 
; 1625 : 	if (!target)

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN16@RequestSup

; 1626 : 		return NULL;

	xor	eax, eax
	jmp	$LN17@RequestSup
$LN16@RequestSup:

; 1627 : 	target->GetLocation(&tx,&ty);

	lea	edx, DWORD PTR _ty$[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1628 : #ifdef VU_GRID_TREE_Y_MAJOR
; 1629 : 	myit = new VuGridIterator(RealUnitProxList,target->YPos(),target->XPos(),(BIG_SCALAR)GridToSim((short)(MAX_AIR_SEARCH)));

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN19@RequestSup
	movzx	ecx, WORD PTR ?MAX_AIR_SEARCH@@3FA	; MAX_AIR_SEARCH
	push	ecx
	call	?GridToSim@@YAMF@Z			; GridToSim
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	push	edx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN20@RequestSup
$LN19@RequestSup:
	mov	DWORD PTR tv138[ebp], 0
$LN20@RequestSup:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _myit$[ebp], ecx

; 1630 : #else
; 1631 : 	myit = new VuGridIterator(RealUnitProxList,target->XPos(),target->YPos(),(BIG_SCALAR)GridToSim((short)(MAX_AIR_SEARCH)));
; 1632 : #endif
; 1633 : 	mt = target->GetMovementType();

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	mov	DWORD PTR _mt$[ebp], eax

; 1634 : 
; 1635 : 	// Try to find an available CAS flight or an artillery unit
; 1636 : 	u = (Unit) myit->GetFirst();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN15@RequestSup:

; 1637 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN14@RequestSup

; 1638 : 	{
; 1639 : 		if (!foundcas && u->GetDomain() == DOMAIN_AIR && u->GetTeam() == team && u->GetUnitCurrentRole() == ARO_GA && u->GetUnitPriority() == 0)

	cmp	DWORD PTR _foundcas$[ebp], 0
	jne	$LN13@RequestSup
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 2
	jne	$LN13@RequestSup
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _team$[ebp]
	jne	$LN13@RequestSup
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+672]
	call	edx
	cmp	eax, 4
	jne	$LN13@RequestSup
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+676]
	call	eax
	test	eax, eax
	jne	$LN13@RequestSup

; 1640 : 		{
; 1641 : 			// This is a reasonable enough flight to meet a CAS request, so request the support and stop looking
; 1642 : 			// The ATM will sort out the details of who actually gets it.
; 1643 : 			MissionRequestClass		mis;

	lea	ecx, DWORD PTR _mis$11[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1644 : 			int		bonus=0;

	mov	DWORD PTR _bonus$10[ebp], 0

; 1645 : 
; 1646 : 			mis.tot = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _mis$11[ebp+36], eax

; 1647 : 			mis.vs = target->GetTeam();

	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$11[ebp+33], al

; 1648 : 			mis.who = (uchar) team;

	mov	cl, BYTE PTR _team$[ebp]
	mov	BYTE PTR _mis$11[ebp+32], cl

; 1649 : 			mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$11[ebp+58], 0

; 1650 : 			mis.flags = AMIS_IMMEDIATE;

	mov	DWORD PTR _mis$11[ebp+44], 65536	; 00010000H

; 1651 : 			target->GetLocation(&mis.tx,&mis.ty);

	lea	edx, DWORD PTR _mis$11[ebp+42]
	push	edx
	lea	eax, DWORD PTR _mis$11[ebp+40]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1652 : 			mis.targetID = target->Id();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$11[ebp+8], edx
	mov	DWORD PTR _mis$11[ebp+12], eax

; 1653 : 			mis.mission = AMIS_CAS;

	mov	BYTE PTR _mis$11[ebp+60], 22		; 00000016H

; 1654 : 			if (target->Engaged())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN12@RequestSup

; 1655 : 				bonus += 20;

	mov	ecx, DWORD PTR _bonus$10[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _bonus$10[ebp], ecx
$LN12@RequestSup:

; 1656 : 			if (target->Combat())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?Combat@UnitClass@@QBEHXZ		; UnitClass::Combat
	test	eax, eax
	je	SHORT $LN11@RequestSup

; 1657 : 				bonus += 20;

	mov	edx, DWORD PTR _bonus$10[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _bonus$10[ebp], edx
$LN11@RequestSup:

; 1658 : 			mis.priority = bonus;

	mov	ax, WORD PTR _bonus$10[ebp]
	mov	WORD PTR _mis$11[ebp+56], ax

; 1659 : 			mis.roe_check = ROE_GROUND_FIRE;

	mov	BYTE PTR _mis$11[ebp+63], 1

; 1660 : 			mis.RequestMission();

	lea	ecx, DWORD PTR _mis$11[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission

; 1661 : 			foundcas = 1;

	mov	DWORD PTR _foundcas$[ebp], 1

; 1662 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$11[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	jmp	$LN4@RequestSup
$LN13@RequestSup:

; 1663 : 		else if (u->GetDomain() == DOMAIN_LAND && u->GetUnitNormalRole() == GRO_FIRESUPPORT && u->GetTeam() == team)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 3
	jne	$LN4@RequestSup
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 6
	jne	$LN4@RequestSup
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _team$[ebp]
	jne	$LN4@RequestSup

; 1664 : 		{
; 1665 : 			u->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1666 : 			d = FloatToInt32(Distance(x,y,tx,ty));

	movzx	ecx, WORD PTR _ty$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 1667 : 			if (u->GetAproxHitChance(mt,d))

	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+396]
	call	eax
	test	eax, eax
	je	$LN4@RequestSup

; 1668 : 			{
; 1669 : 				score = d;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _score$[ebp], ecx

; 1670 : 				if (u->GetUnitDivision() == req->GetUnitDivision())

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+904]
	call	edx
	mov	esi, eax
	mov	eax, DWORD PTR _req$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _req$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	cmp	esi, eax
	jne	SHORT $LN7@RequestSup

; 1671 : 					score -= 20;		// Bonus for same division

	mov	ecx, DWORD PTR _score$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR _score$[ebp], ecx
$LN7@RequestSup:

; 1672 : 				if (u->GetUnitParentID() == req->GetUnitParentID())

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	eax, DWORD PTR _req$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _req$[ebp]
	mov	eax, DWORD PTR [edx+948]
	call	eax
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+948]
	call	edx
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@RequestSup

; 1673 : 					score -= 20;		// Bonus for same brigade

	mov	ecx, DWORD PTR _score$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR _score$[ebp], ecx
$LN6@RequestSup:

; 1674 : 				if (u->Engaged())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN5@RequestSup

; 1675 : 					score += 50;		// Penalty for someone already shooting

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _score$[ebp], edx
$LN5@RequestSup:

; 1676 : 				if (score < best)

	mov	eax, DWORD PTR _score$[ebp]
	cmp	eax, DWORD PTR _best$[ebp]
	jge	SHORT $LN4@RequestSup

; 1677 : 				{
; 1678 : 					best = score;

	mov	ecx, DWORD PTR _score$[ebp]
	mov	DWORD PTR _best$[ebp], ecx

; 1679 : 					art = u;

	mov	edx, DWORD PTR _u$[ebp]
	mov	DWORD PTR _art$[ebp], edx
$LN4@RequestSup:

; 1680 : 				}
; 1681 : 			}
; 1682 : 		}
; 1683 : 		u = (Unit)myit->GetNext();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 1684 : 	}

	jmp	$LN15@RequestSup
$LN14@RequestSup:

; 1685 : 	if (art)

	cmp	DWORD PTR _art$[ebp], 0
	je	SHORT $LN3@RequestSup

; 1686 : 	{
; 1687 : 		// We need to actually send this unit a message
; 1688 : 		art->SendUnitMessage(target->Id(), FalconUnitMessage::unitSupport, 0, 0, 0);

	push	0
	push	0
	push	0
	push	8
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _art$[ebp]
	call	?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::SendUnitMessage
$LN3@RequestSup:

; 1689 : 	}
; 1690 : 	delete myit;

	mov	eax, DWORD PTR _myit$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN21@RequestSup
	push	1
	mov	edx, DWORD PTR $T9[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR tv359[ebp], eax
	jmp	SHORT $LN22@RequestSup
$LN21@RequestSup:
	mov	DWORD PTR tv359[ebp], 0
$LN22@RequestSup:

; 1691 : 	if (art || foundcas)

	cmp	DWORD PTR _art$[ebp], 0
	jne	SHORT $LN1@RequestSup
	cmp	DWORD PTR _foundcas$[ebp], 0
	je	SHORT $LN2@RequestSup
$LN1@RequestSup:

; 1692 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN17@RequestSup
$LN2@RequestSup:

; 1693 : 	return 0;

	xor	eax, eax
$LN17@RequestSup:

; 1694 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestSupport@@YAHPAVUnitClass@@0@Z$0:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RequestSupport@@YAHPAVUnitClass@@0@Z$1:
	lea	ecx, DWORD PTR _mis$11[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__ehhandler$?RequestSupport@@YAHPAVUnitClass@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestSupport@@YAHPAVUnitClass@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestSupport@@YAHPAVUnitClass@@0@Z ENDP		; RequestSupport
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -148						; size = 8
$T3 = -140						; size = 4
_tx$ = -136						; size = 2
_ty$ = -132						; size = 2
tv216 = -128						; size = 4
$T4 = -124						; size = 4
$T5 = -120						; size = 4
tv129 = -116						; size = 4
$T6 = -112						; size = 4
$T7 = -108						; size = 4
_myit$ = -104						; size = 4
_bonus$8 = -100						; size = 4
_u$ = -96						; size = 4
_mis$9 = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_team$ = 8						; size = 4
_target$ = 12						; size = 4
?RequestCAS@@YAHHPAVUnitClass@@@Z PROC			; RequestCAS

; 1567 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestCAS@@YAHHPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1568 : 	VuGridIterator		*myit;
; 1569 : 	Unit				u;
; 1570 : 	GridIndex			tx,ty;
; 1571 : 
; 1572 : 	if (!target)

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN6@RequestCAS

; 1573 : 		return NULL;

	xor	eax, eax
	jmp	$LN7@RequestCAS
$LN6@RequestCAS:

; 1574 : 	target->GetLocation(&tx,&ty);

	lea	eax, DWORD PTR _ty$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1575 : #ifdef VU_GRID_TREE_Y_MAJOR
; 1576 : 	myit = new VuGridIterator(RealUnitProxList,target->YPos(),target->XPos(),(BIG_SCALAR)GridToSim((short)(MAX_AIR_SEARCH)));

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN9@RequestCAS
	movzx	edx, WORD PTR ?MAX_AIR_SEARCH@@3FA	; MAX_AIR_SEARCH
	push	edx
	call	?GridToSim@@YAMF@Z			; GridToSim
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	push	eax
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN10@RequestCAS
$LN9@RequestCAS:
	mov	DWORD PTR tv129[ebp], 0
$LN10@RequestCAS:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _myit$[ebp], edx

; 1577 : #else
; 1578 : 	myit = new VuGridIterator(RealUnitProxList,target->XPos(),target->YPos(),(BIG_SCALAR)GridToSim((short)(MAX_AIR_SEARCH)));
; 1579 : #endif
; 1580 : 
; 1581 : 	// Try to find an available CAS flight
; 1582 : 	u = (Unit) myit->GetFirst();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN5@RequestCAS:

; 1583 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN4@RequestCAS

; 1584 : 	{
; 1585 : 		if (u->GetDomain() == DOMAIN_AIR && u->GetTeam() == team && u->GetUnitCurrentRole() == ARO_GA && u->GetUnitPriority() == 0)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 2
	jne	$LN3@RequestCAS
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _team$[ebp]
	jne	$LN3@RequestCAS
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+672]
	call	edx
	cmp	eax, 4
	jne	$LN3@RequestCAS
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+676]
	call	eax
	test	eax, eax
	jne	$LN3@RequestCAS

; 1586 : 		{
; 1587 : 			// This is a reasonable enough flight to meet a CAS request, so request the support and return 1.
; 1588 : 			// The ATM will sort out the details of who actually gets it.
; 1589 : 			MissionRequestClass		mis;

	lea	ecx, DWORD PTR _mis$9[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1590 : 			int		bonus=0;

	mov	DWORD PTR _bonus$8[ebp], 0

; 1591 : 
; 1592 : 			mis.tot = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _mis$9[ebp+36], eax

; 1593 : 			mis.vs = target->GetTeam();

	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$9[ebp+33], al

; 1594 : 			mis.who = team;

	mov	cl, BYTE PTR _team$[ebp]
	mov	BYTE PTR _mis$9[ebp+32], cl

; 1595 : 			mis.tot_type = TYPE_NE;

	mov	BYTE PTR _mis$9[ebp+58], 0

; 1596 : 			mis.flags = AMIS_IMMEDIATE;

	mov	DWORD PTR _mis$9[ebp+44], 65536		; 00010000H

; 1597 : 			target->GetLocation(&mis.tx,&mis.ty);

	lea	edx, DWORD PTR _mis$9[ebp+42]
	push	edx
	lea	eax, DWORD PTR _mis$9[ebp+40]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1598 : 			mis.targetID = target->Id();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$9[ebp+8], edx
	mov	DWORD PTR _mis$9[ebp+12], eax

; 1599 : 			mis.mission = AMIS_CAS;

	mov	BYTE PTR _mis$9[ebp+60], 22		; 00000016H

; 1600 : 			if (target->Engaged())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN2@RequestCAS

; 1601 : 				bonus += 20;

	mov	ecx, DWORD PTR _bonus$8[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _bonus$8[ebp], ecx
$LN2@RequestCAS:

; 1602 : 			if (target->Combat())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?Combat@UnitClass@@QBEHXZ		; UnitClass::Combat
	test	eax, eax
	je	SHORT $LN1@RequestCAS

; 1603 : 				bonus += 20;

	mov	edx, DWORD PTR _bonus$8[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _bonus$8[ebp], edx
$LN1@RequestCAS:

; 1604 : 			mis.priority = bonus;

	mov	ax, WORD PTR _bonus$8[ebp]
	mov	WORD PTR _mis$9[ebp+56], ax

; 1605 : 			mis.roe_check = ROE_GROUND_FIRE;

	mov	BYTE PTR _mis$9[ebp+63], 1

; 1606 : 			mis.RequestMission();

	lea	ecx, DWORD PTR _mis$9[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission

; 1607 : 			return 1;						// We'll assume CAS will arrive

	mov	DWORD PTR $T5[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$9[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T5[ebp]
	jmp	SHORT $LN7@RequestCAS
$LN3@RequestCAS:

; 1608 : 		}
; 1609 : 		u = (Unit)myit->GetNext();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 1610 : 	}

	jmp	$LN5@RequestCAS
$LN4@RequestCAS:

; 1611 : 	delete myit;

	mov	ecx, DWORD PTR _myit$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T7[ebp], edx
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN11@RequestCAS
	push	1
	mov	eax, DWORD PTR $T7[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv216[ebp], eax
	jmp	SHORT $LN12@RequestCAS
$LN11@RequestCAS:
	mov	DWORD PTR tv216[ebp], 0
$LN12@RequestCAS:

; 1612 : 	return 0;

	xor	eax, eax
$LN7@RequestCAS:

; 1613 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestCAS@@YAHHPAVUnitClass@@@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RequestCAS@@YAHHPAVUnitClass@@@Z$1:
	lea	ecx, DWORD PTR _mis$9[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__ehhandler$?RequestCAS@@YAHHPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestCAS@@YAHHPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestCAS@@YAHHPAVUnitClass@@@Z ENDP			; RequestCAS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -108						; size = 8
$T3 = -100						; size = 8
$T4 = -92						; size = 8
tv254 = -84						; size = 4
$T5 = -80						; size = 4
_mt$ = -76						; size = 4
_team$ = -72						; size = 4
$T6 = -68						; size = 4
_best$ = -64						; size = 4
_d$ = -60						; size = 4
tv138 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
_myit$ = -44						; size = 4
_art$ = -40						; size = 4
_score$ = -36						; size = 4
_u$ = -32						; size = 4
_x$ = -28						; size = 2
_y$ = -24						; size = 2
_tx$ = -20						; size = 2
_ty$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_req$ = 8						; size = 4
_target$ = 12						; size = 4
?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z PROC	; RequestArtillerySupport

; 1512 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1513 : 	VuGridIterator		*myit;
; 1514 : 	Unit				u,art=NULL;

	mov	DWORD PTR _art$[ebp], 0

; 1515 : 	GridIndex			tx,ty,x,y;
; 1516 : 	int					score,best=9999,team = req->GetTeam(),d;

	mov	DWORD PTR _best$[ebp], 9999		; 0000270fH
	mov	eax, DWORD PTR _req$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _req$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _team$[ebp], ecx

; 1517 : 	MoveType			mt;
; 1518 : 
; 1519 : 	if (!target)

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN10@RequestArt

; 1520 : 		return NULL;

	xor	eax, eax
	jmp	$LN11@RequestArt
$LN10@RequestArt:

; 1521 : 	target->GetLocation(&tx,&ty);

	lea	edx, DWORD PTR _ty$[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1522 : #ifdef VU_GRID_TREE_Y_MAJOR
; 1523 : 	myit = new VuGridIterator(RealUnitProxList,target->YPos(),target->XPos(),(BIG_SCALAR)GridToSim((short)(MAX_GROUND_SEARCH)));

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN13@RequestArt
	movzx	ecx, WORD PTR ?MAX_GROUND_SEARCH@@3FA	; MAX_GROUND_SEARCH
	push	ecx
	call	?GridToSim@@YAMF@Z			; GridToSim
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN14@RequestArt
$LN13@RequestArt:
	mov	DWORD PTR tv138[ebp], 0
$LN14@RequestArt:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _myit$[ebp], ecx

; 1524 : #else
; 1525 : 	myit = new VuGridIterator(RealUnitProxList,target->XPos(),target->YPos(),(BIG_SCALAR)GridToSim((short)(MAX_GROUND_SEARCH)));
; 1526 : #endif
; 1527 : 	mt = target->GetMovementType();

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	mov	DWORD PTR _mt$[ebp], eax

; 1528 : 
; 1529 : 	// Try to find an artillery unit
; 1530 : 	u = (Unit) myit->GetFirst();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN9@RequestArt:

; 1531 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN8@RequestArt

; 1532 : 	{
; 1533 : 		//		if (u->GetSType() == STYPE_UNIT_TOWED_ARTILLERY || u->GetSType() == STYPE_UNIT_SP_ARTILLERY)
; 1534 : 		if (u->GetUnitNormalRole() == GRO_FIRESUPPORT && u->GetTeam() == team)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 6
	jne	$LN2@RequestArt
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	ecx, DWORD PTR _team$[ebp]
	jne	$LN2@RequestArt

; 1535 : 		{
; 1536 : 			u->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1537 : 			d = FloatToInt32(Distance(x,y,tx,ty));

	movzx	ecx, WORD PTR _ty$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 1538 : 			if (u->GetAproxHitChance(mt,d))

	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+396]
	call	eax
	test	eax, eax
	je	$LN2@RequestArt

; 1539 : 			{
; 1540 : 				score = d;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _score$[ebp], ecx

; 1541 : 				if (u->GetUnitDivision() == req->GetUnitDivision())

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+904]
	call	edx
	mov	esi, eax
	mov	eax, DWORD PTR _req$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _req$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	cmp	esi, eax
	jne	SHORT $LN5@RequestArt

; 1542 : 					score -= 20;		// Bonus for same division

	mov	ecx, DWORD PTR _score$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR _score$[ebp], ecx
$LN5@RequestArt:

; 1543 : 				if (u->GetUnitParentID() == req->GetUnitParentID())

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _req$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _req$[ebp]
	mov	eax, DWORD PTR [edx+948]
	call	eax
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+948]
	call	edx
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@RequestArt

; 1544 : 					score -= 20;		// Bonus for same brigade

	mov	ecx, DWORD PTR _score$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR _score$[ebp], ecx
$LN4@RequestArt:

; 1545 : 				if (u->Engaged())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN3@RequestArt

; 1546 : 					score += 50;		// Penalty for someone already shooting

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _score$[ebp], edx
$LN3@RequestArt:

; 1547 : 				if (score < best)

	mov	eax, DWORD PTR _score$[ebp]
	cmp	eax, DWORD PTR _best$[ebp]
	jge	SHORT $LN2@RequestArt

; 1548 : 				{
; 1549 : 					best = score;

	mov	ecx, DWORD PTR _score$[ebp]
	mov	DWORD PTR _best$[ebp], ecx

; 1550 : 					art = u;

	mov	edx, DWORD PTR _u$[ebp]
	mov	DWORD PTR _art$[ebp], edx
$LN2@RequestArt:

; 1551 : 				}
; 1552 : 			}
; 1553 : 		}
; 1554 : 		u = (Unit)myit->GetNext();

	mov	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 1555 : 	}

	jmp	$LN9@RequestArt
$LN8@RequestArt:

; 1556 : 	if (art)

	cmp	DWORD PTR _art$[ebp], 0
	je	SHORT $LN1@RequestArt

; 1557 : 	{
; 1558 : 		// We need to actually send this unit a message
; 1559 : 		art->SendUnitMessage(target->Id(), FalconUnitMessage::unitSupport, 0, 0, 0);

	push	0
	push	0
	push	0
	push	8
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _art$[ebp]
	call	?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::SendUnitMessage
$LN1@RequestArt:

; 1560 : 	}
; 1561 : 	delete myit;

	mov	eax, DWORD PTR _myit$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN15@RequestArt
	push	1
	mov	edx, DWORD PTR $T8[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR tv254[ebp], eax
	jmp	SHORT $LN16@RequestArt
$LN15@RequestArt:
	mov	DWORD PTR tv254[ebp], 0
$LN16@RequestArt:

; 1562 : 	return art;

	mov	eax, DWORD PTR _art$[ebp]
$LN11@RequestArt:

; 1563 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestArtillerySupport@@YAPAVUnitClass@@PAV1@0@Z ENDP	; RequestArtillerySupport
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_looklist$ = -80					; size = 12
$T2 = -68						; size = 4
$T3 = -64						; size = 4
_odist$ = -60						; size = 4
$T4 = -56						; size = 4
_lp$ = -52						; size = 4
_dist$ = -48						; size = 4
_n$ = -44						; size = 4
_s$ = -40						; size = 4
_o$ = -36						; size = 4
_sx$ = -32						; size = 2
_sy$ = -28						; size = 2
_x$ = -24						; size = 2
_y$ = -20						; size = 2
_team$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
_depth$ = 12						; size = 4
_flags$ = 16						; size = 4
?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z PROC ; FindRetreatPath

; 1866 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1867 : 	ListClass			looklist;

	push	0
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	??0ListClass@@QAE@E@Z			; ListClass::ListClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1868 : 	ListNode			lp;	
; 1869 : 	Objective			s,o;
; 1870 : 	GridIndex			x,y,sx,sy;
; 1871 : 	int					n,dist,odist;
; 1872 : 	uchar				team;
; 1873 : 
; 1874 : 	// Reset search array
; 1875 : 	memset(CampSearch,0,sizeof(uchar)*MAX_CAMP_ENTITIES);

	push	28000					; 00006d60H
	push	0
	push	OFFSET ?CampSearch@@3PAEA		; CampSearch
	call	_memset
	add	esp, 12					; 0000000cH

; 1876 : 	u->GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1877 : 	team = u->GetTeam();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	mov	BYTE PTR _team$[ebp], al

; 1878 : 	sx = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _sx$[ebp], ax

; 1879 : 	sy = y;

	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _sy$[ebp], cx

; 1880 : 	s = FindNearestFriendlyObjective(team, &sx, &sy, 0);

	push	0
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sx$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _team$[ebp]
	push	ecx
	call	?FindNearestFriendlyObjective@@YAPAVObjectiveClass@@EPAF0H@Z ; FindNearestFriendlyObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s$[ebp], eax

; 1881 : 	if (s){

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN13@FindRetrea

; 1882 : 		dist = FloatToInt32(Distance(x,y,sx,sy));

	movzx	edx, WORD PTR _sy$[ebp]
	push	edx
	movzx	eax, WORD PTR _sx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist$[ebp], eax

; 1883 : 		if (dist > MIN_RETREAT_DISTANCE_IF_BEHIND_LINES){

	cmp	DWORD PTR _dist$[ebp], 20		; 00000014H
	jle	SHORT $LN15@FindRetrea

; 1884 : 			// Shucks, we're probably gonna surrender.
; 1885 : 			return NULL;

	mov	DWORD PTR $T4[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	??1ListClass@@QAE@XZ			; ListClass::~ListClass
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN17@FindRetrea
$LN15@FindRetrea:

; 1886 : 		}
; 1887 : 		looklist.InsertNewElement(dist,s,LADT_SORTED_LIST);

	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	movzx	ecx, WORD PTR _dist$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	?InsertNewElement@ListClass@@QAEXFPAXE@Z ; ListClass::InsertNewElement
$LN14@FindRetrea:

; 1888 : 
; 1889 : 		while (lp = looklist.GetFirstElement()){

	lea	ecx, DWORD PTR _looklist$[ebp]
	call	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
	mov	DWORD PTR _lp$[ebp], eax
	cmp	DWORD PTR _lp$[ebp], 0
	je	$LN13@FindRetrea

; 1890 : 			CampSearch[s->GetCampID()] = 1;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	mov	BYTE PTR ?CampSearch@@3PAEA[eax], 1

; 1891 : 			dist = lp->GetKey();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetKey@ListElementClass@@QAEFXZ	; ListElementClass::GetKey
	movsx	ecx, ax
	mov	DWORD PTR _dist$[ebp], ecx

; 1892 : 			s = (Objective) lp->GetUserData();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetUserData@ListElementClass@@QAEPAXXZ	; ListElementClass::GetUserData
	mov	DWORD PTR _s$[ebp], eax

; 1893 : 
; 1894 : 			// Add all our neighbors to the list
; 1895 : 			for (n=0; n<s->NumLinks(); n++){

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN12@FindRetrea
$LN11@FindRetrea:
	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx
$LN12@FindRetrea:
	mov	ecx, DWORD PTR _s$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	DWORD PTR _n$[ebp], eax
	jge	$LN10@FindRetrea

; 1896 : 				o = s->GetNeighbor(n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _o$[ebp], eax

; 1897 : 				if (o && !CampSearch[o->GetCampID()] && team == o->GetTeam()){

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN9@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	movzx	edx, BYTE PTR ?CampSearch@@3PAEA[ecx]
	test	edx, edx
	jne	$LN9@FindRetrea
	movzx	esi, BYTE PTR _team$[ebp]
	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	jne	$LN9@FindRetrea

; 1898 : 					o->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1899 : 					odist = dist + FloatToInt32(Distance(x,y,sx,sy)); 

	movzx	ecx, WORD PTR _sy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _sx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _odist$[ebp], eax

; 1900 : 					looklist.InsertNewElement(odist,o,LADT_SORTED_LIST);

	push	1
	mov	edx, DWORD PTR _o$[ebp]
	push	edx
	movzx	eax, WORD PTR _odist$[ebp]
	push	eax
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	?InsertNewElement@ListClass@@QAEXFPAXE@Z ; ListClass::InsertNewElement

; 1901 : 					if (flags & FIND_SECONDARYONLY && !o->IsSecondary())

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN8@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondary
	test	eax, eax
	jne	SHORT $LN8@FindRetrea

; 1902 : 						continue;

	jmp	$LN11@FindRetrea
$LN8@FindRetrea:

; 1903 : 					if (depth > 2 && (o->IsFrontline() || o->IsSecondline() || o->IsThirdline()))

	cmp	DWORD PTR _depth$[ebp], 2
	jle	SHORT $LN7@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsFrontline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsFrontline
	test	eax, eax
	jne	SHORT $LN6@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondline
	test	eax, eax
	jne	SHORT $LN6@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsThirdline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsThirdline
	test	eax, eax
	je	SHORT $LN7@FindRetrea
$LN6@FindRetrea:

; 1904 : 						continue;

	jmp	$LN11@FindRetrea
	jmp	SHORT $LN1@FindRetrea
$LN7@FindRetrea:

; 1905 : 					else if (depth == 2 && (o->IsFrontline() || o->IsSecondline()))

	cmp	DWORD PTR _depth$[ebp], 2
	jne	SHORT $LN4@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsFrontline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsFrontline
	test	eax, eax
	jne	SHORT $LN3@FindRetrea
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondline
	test	eax, eax
	je	SHORT $LN4@FindRetrea
$LN3@FindRetrea:

; 1906 : 						continue;

	jmp	$LN11@FindRetrea
	jmp	SHORT $LN1@FindRetrea
$LN4@FindRetrea:

; 1907 : 					else if (o->IsFrontline())

	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsFrontline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsFrontline
	test	eax, eax
	je	SHORT $LN1@FindRetrea

; 1908 : 						continue;

	jmp	$LN11@FindRetrea
$LN1@FindRetrea:

; 1909 : 					// The list should purge itself here, when it gets deleted
; 1910 : 					return o;

	mov	edx, DWORD PTR _o$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	??1ListClass@@QAE@XZ			; ListClass::~ListClass
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN17@FindRetrea
$LN9@FindRetrea:

; 1911 : 				}
; 1912 : 			}

	jmp	$LN11@FindRetrea
$LN10@FindRetrea:

; 1913 : 			looklist.Remove(lp);

	mov	eax, DWORD PTR _lp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	?Remove@ListClass@@QAEXPAVListElementClass@@@Z ; ListClass::Remove

; 1914 : 		}

	jmp	$LN14@FindRetrea
$LN13@FindRetrea:

; 1915 : 	}
; 1916 : 	// Shucks, we're probably gonna surrender.
; 1917 : 	return NULL;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _looklist$[ebp]
	call	??1ListClass@@QAE@XZ			; ListClass::~ListClass
	mov	eax, DWORD PTR $T2[ebp]
$LN17@FindRetrea:

; 1918 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z$0:
	lea	ecx, DWORD PTR _looklist$[ebp]
	jmp	??1ListClass@@QAE@XZ			; ListClass::~ListClass
__ehhandler$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z ENDP ; FindRetreatPath
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
tv256 = -32						; size = 4
tv241 = -28						; size = 4
_bcov$ = -24						; size = 4
_cov$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_ty$ = -8						; size = 2
_tx$ = -4						; size = 2
_x$ = 8							; size = 2
_y$ = 12						; size = 2
_h$ = 16						; size = 1
_cx$ = 20						; size = 4
_cy$ = 24						; size = 4
_roadok$ = 28						; size = 4
?FindBestCover@@YAXFFEPAF0H@Z PROC			; FindBestCover

; 1832 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1833 : 	GridIndex	tx,ty;
; 1834 : 	float		cov,bcov=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _bcov$[ebp], xmm0

; 1835 : 	int			i,j;
; 1836 : 
; 1837 : 	// default location
; 1838 : 	*cx = x;

	mov	eax, DWORD PTR _cx$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax], cx

; 1839 : 	*cy = y;

	mov	edx, DWORD PTR _cy$[ebp]
	mov	ax, WORD PTR _y$[ebp]
	mov	WORD PTR [edx], ax

; 1840 : 	if (h < 0 || h > 7)

	movzx	ecx, BYTE PTR _h$[ebp]
	test	ecx, ecx
	jl	SHORT $LN9@FindBestCo
	movzx	edx, BYTE PTR _h$[ebp]
	cmp	edx, 7
	jle	SHORT $LN10@FindBestCo
$LN9@FindBestCo:

; 1841 : 		return;

	jmp	$LN11@FindBestCo
$LN10@FindBestCo:

; 1842 : 
; 1843 : 	// Traverse possible locations, adding up cover values (1/2 value for surrounding terrain)
; 1844 : 	for (i=0; i<4+2*(h%2); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@FindBestCo
$LN7@FindBestCo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@FindBestCo:
	movzx	ecx, BYTE PTR _h$[ebp]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN13@FindBestCo
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN13@FindBestCo:
	lea	edx, DWORD PTR [ecx+ecx+4]
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN6@FindBestCo

; 1845 : 	{
; 1846 : 		tx = x + dx[Offsets[h][i][0]] + dx[Offsets[h][i][1]] + dx[Offsets[h][i][2]];

	movsx	eax, WORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR _h$[ebp]
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	lea	ecx, DWORD PTR ?Offsets@@3PAY152EA[ecx+edx]
	mov	edx, 1
	imul	edx, 0
	movzx	ecx, BYTE PTR [ecx+edx]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	add	eax, edx
	movzx	ecx, BYTE PTR _h$[ebp]
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	lea	ecx, DWORD PTR ?Offsets@@3PAY152EA[ecx+edx]
	mov	edx, 1
	shl	edx, 0
	movzx	ecx, BYTE PTR [ecx+edx]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	add	eax, edx
	movzx	ecx, BYTE PTR _h$[ebp]
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	lea	ecx, DWORD PTR ?Offsets@@3PAY152EA[ecx+edx]
	mov	edx, 1
	shl	edx, 1
	movzx	ecx, BYTE PTR [ecx+edx]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	add	eax, edx
	mov	WORD PTR _tx$[ebp], ax

; 1847 : 		ty = y + dy[Offsets[h][i][0]] + dy[Offsets[h][i][1]] + dy[Offsets[h][i][2]];

	movsx	eax, WORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR _h$[ebp]
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	lea	ecx, DWORD PTR ?Offsets@@3PAY152EA[ecx+edx]
	mov	edx, 1
	imul	edx, 0
	movzx	ecx, BYTE PTR [ecx+edx]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	add	eax, edx
	movzx	ecx, BYTE PTR _h$[ebp]
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	lea	ecx, DWORD PTR ?Offsets@@3PAY152EA[ecx+edx]
	mov	edx, 1
	shl	edx, 0
	movzx	ecx, BYTE PTR [ecx+edx]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	add	eax, edx
	movzx	ecx, BYTE PTR _h$[ebp]
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 3
	lea	ecx, DWORD PTR ?Offsets@@3PAY152EA[ecx+edx]
	mov	edx, 1
	shl	edx, 1
	movzx	ecx, BYTE PTR [ecx+edx]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	add	eax, edx
	mov	WORD PTR _ty$[ebp], ax

; 1848 : 		if (GetMovementCost(tx,ty,Foot,0,Here) > MAX_COST)

	push	8
	push	0
	push	1
	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	call	?GetMovementCost@@YAMFFW4MoveType@@HE@Z	; GetMovementCost
	add	esp, 20					; 00000014H
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	comiss	xmm0, DWORD PTR __real@42480000
	jbe	SHORT $LN5@FindBestCo

; 1849 : 			continue;

	jmp	$LN7@FindBestCo
$LN5@FindBestCo:

; 1850 : 		cov = CoverValue (tx, ty, roadok);

	mov	edx, DWORD PTR _roadok$[ebp]
	push	edx
	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	call	?CoverValue@@YAMFFH@Z			; CoverValue
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _cov$[ebp]

; 1851 : 		for (j=0; j<8; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@FindBestCo
$LN3@FindBestCo:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@FindBestCo:
	cmp	DWORD PTR _j$[ebp], 8
	jge	SHORT $LN2@FindBestCo

; 1852 : 			cov += CoverValue (tx+dx[j], ty+dy[j], roadok) / 2.0F;

	mov	eax, DWORD PTR _roadok$[ebp]
	push	eax
	movsx	ecx, WORD PTR _ty$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR ?dy@@3PAFA[edx*2]
	add	ecx, eax
	push	ecx
	movsx	ecx, WORD PTR _tx$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	add	ecx, eax
	push	ecx
	call	?CoverValue@@YAMFFH@Z			; CoverValue
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR tv256[ebp]
	movss	xmm0, DWORD PTR tv256[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _cov$[ebp]
	movss	DWORD PTR _cov$[ebp], xmm0
	jmp	SHORT $LN3@FindBestCo
$LN2@FindBestCo:

; 1853 : 		if (cov > bcov)

	movss	xmm0, DWORD PTR _cov$[ebp]
	comiss	xmm0, DWORD PTR _bcov$[ebp]
	jbe	SHORT $LN1@FindBestCo

; 1854 : 		{
; 1855 : 			bcov = cov;

	movss	xmm0, DWORD PTR _cov$[ebp]
	movss	DWORD PTR _bcov$[ebp], xmm0

; 1856 : 			*cx = tx;

	mov	ecx, DWORD PTR _cx$[ebp]
	mov	dx, WORD PTR _tx$[ebp]
	mov	WORD PTR [ecx], dx

; 1857 : 			*cy = ty;

	mov	eax, DWORD PTR _cy$[ebp]
	mov	cx, WORD PTR _ty$[ebp]
	mov	WORD PTR [eax], cx
$LN1@FindBestCo:

; 1858 : 		}
; 1859 : 	}

	jmp	$LN7@FindBestCo
$LN6@FindBestCo:
$LN11@FindBestCo:

; 1860 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestCover@@YAXFFEPAF0H@Z ENDP			; FindBestCover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
tv73 = -4						; size = 4
_e$ = 8							; size = 4
?GetPositionOrders@@YAHPAVUnitClass@@@Z PROC		; GetPositionOrders

; 1492 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1493 : 	if (e->GetUnitPosition() >= GPOS_SUPPORT1)

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+900]
	call	eax
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN6@GetPositio

; 1494 : 	{
; 1495 : 		switch(e->GetUnitNormalRole())

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 5
	je	SHORT $LN2@GetPositio
	cmp	DWORD PTR tv73[ebp], 6
	je	SHORT $LN3@GetPositio
	jmp	SHORT $LN1@GetPositio
$LN3@GetPositio:

; 1496 : 		{
; 1497 : 				case GRO_FIRESUPPORT:
; 1498 : 						return GORD_SUPPORT;

	mov	eax, 7
	jmp	SHORT $LN7@GetPositio
$LN2@GetPositio:

; 1499 : 				case GRO_AIRDEFENSE:
; 1500 : 						return GORD_AIRDEFENSE;

	mov	eax, 9
	jmp	SHORT $LN7@GetPositio
$LN1@GetPositio:

; 1501 : 				default:
; 1502 : 						return GORD_RESERVE;

	xor	eax, eax
	jmp	SHORT $LN7@GetPositio
$LN6@GetPositio:

; 1503 : 		}
; 1504 : 	}
; 1505 : 	return GORD_RESERVE;

	xor	eax, eax
$LN7@GetPositio:

; 1506 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPositionOrders@@YAHPAVUnitClass@@@Z ENDP		; GetPositionOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_rc$ = -24						; size = 4
_su$ = -20						; size = 4
_re$ = -16						; size = 4
_cb$ = -12						; size = 4
_e$ = -8						; size = 4
_pos$ = -4						; size = 4
_u$ = 8							; size = 4
_recon$ = 12						; size = 4
_combat$ = 16						; size = 4
_reserve$ = 20						; size = 4
_support$ = 24						; size = 4
?ClassifyUnitElements@@YAXPAVUnitClass@@PAH111@Z PROC	; ClassifyUnitElements

; 1463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1464 : 	Unit		e;
; 1465 : 	int		pos;
; 1466 : 	int		rc,cb,re,su;
; 1467 : 
; 1468 : 	rc = cb = re = su = 0;

	mov	DWORD PTR _su$[ebp], 0
	mov	eax, DWORD PTR _su$[ebp]
	mov	DWORD PTR _re$[ebp], eax
	mov	ecx, DWORD PTR _re$[ebp]
	mov	DWORD PTR _cb$[ebp], ecx
	mov	edx, DWORD PTR _cb$[ebp]
	mov	DWORD PTR _rc$[ebp], edx

; 1469 : 	e = u->GetFirstUnitElement();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN9@ClassifyUn:

; 1470 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN8@ClassifyUn

; 1471 : 	{
; 1472 : 		pos = e->GetUnitPosition();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+900]
	call	eax
	mov	DWORD PTR _pos$[ebp], eax

; 1473 : 		if (pos <= GPOS_RECON3)

	cmp	DWORD PTR _pos$[ebp], 3
	jg	SHORT $LN7@ClassifyUn

; 1474 : 			rc++;

	mov	ecx, DWORD PTR _rc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rc$[ebp], ecx
	jmp	SHORT $LN6@ClassifyUn
$LN7@ClassifyUn:

; 1475 : 		else if (pos >= GPOS_COMBAT1 && pos <= GPOS_COMBAT3)

	cmp	DWORD PTR _pos$[ebp], 4
	jl	SHORT $LN5@ClassifyUn
	cmp	DWORD PTR _pos$[ebp], 6
	jg	SHORT $LN5@ClassifyUn

; 1476 : 			cb++;

	mov	edx, DWORD PTR _cb$[ebp]
	add	edx, 1
	mov	DWORD PTR _cb$[ebp], edx
	jmp	SHORT $LN6@ClassifyUn
$LN5@ClassifyUn:

; 1477 : 		else if (pos >= GPOS_RESERVE1 && pos <= GPOS_RESERVE3)

	cmp	DWORD PTR _pos$[ebp], 7
	jl	SHORT $LN3@ClassifyUn
	cmp	DWORD PTR _pos$[ebp], 9
	jg	SHORT $LN3@ClassifyUn

; 1478 : 			re++;

	mov	eax, DWORD PTR _re$[ebp]
	add	eax, 1
	mov	DWORD PTR _re$[ebp], eax
	jmp	SHORT $LN6@ClassifyUn
$LN3@ClassifyUn:

; 1479 : 		else if (pos >= GPOS_SUPPORT1 && pos <= GPOS_SUPPORT3)

	cmp	DWORD PTR _pos$[ebp], 10		; 0000000aH
	jl	SHORT $LN6@ClassifyUn
	cmp	DWORD PTR _pos$[ebp], 12		; 0000000cH
	jg	SHORT $LN6@ClassifyUn

; 1480 : 			su++;

	mov	ecx, DWORD PTR _su$[ebp]
	add	ecx, 1
	mov	DWORD PTR _su$[ebp], ecx
$LN6@ClassifyUn:

; 1481 : 		e = u->GetNextUnitElement();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+960]
	call	edx
	mov	DWORD PTR _e$[ebp], eax

; 1482 : 	}

	jmp	$LN9@ClassifyUn
$LN8@ClassifyUn:

; 1483 : 	*recon = rc;

	mov	eax, DWORD PTR _recon$[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	mov	DWORD PTR [eax], ecx

; 1484 : 	*combat = cb;

	mov	edx, DWORD PTR _combat$[ebp]
	mov	eax, DWORD PTR _cb$[ebp]
	mov	DWORD PTR [edx], eax

; 1485 : 	*reserve = re;

	mov	ecx, DWORD PTR _reserve$[ebp]
	mov	edx, DWORD PTR _re$[ebp]
	mov	DWORD PTR [ecx], edx

; 1486 : 	*support = su;

	mov	eax, DWORD PTR _support$[ebp]
	mov	ecx, DWORD PTR _su$[ebp]
	mov	DWORD PTR [eax], ecx

; 1487 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClassifyUnitElements@@YAXPAVUnitClass@@PAH111@Z ENDP	; ClassifyUnitElements
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T1 = -48						; size = 8
$T2 = -40						; size = 8
$T3 = -32						; size = 8
$T4 = -24						; size = 8
_nn$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_n$ = -4						; size = 4
_o$ = 8							; size = 4
_who$ = 12						; size = 1
?SOSecured@@YAHPAVObjectiveClass@@E@Z PROC		; SOSecured

; 1067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1068 : 	Objective	n,nn;
; 1069 : 	int			i,j;
; 1070 : 
; 1071 : 	if (o->GetTeam() != who)

	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	je	SHORT $LN11@SOSecured

; 1072 : 		return 0;

	xor	eax, eax
	jmp	$LN12@SOSecured
$LN11@SOSecured:

; 1073 : 	for (i=0; i<o->NumLinks(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SOSecured
$LN9@SOSecured:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@SOSecured:
	mov	ecx, DWORD PTR _o$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN8@SOSecured

; 1074 : 	{
; 1075 : 		n = o->GetNeighbor(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _n$[ebp], eax

; 1076 : 		if (n && n->GetObjectiveParentID() == o->Id())

	cmp	DWORD PTR _n$[ebp], 0
	je	$LN7@SOSecured
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetObjectiveParentID@ObjectiveClass@@QAE?AVVU_ID@@XZ ; ObjectiveClass::GetObjectiveParentID
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@SOSecured

; 1077 : 		{
; 1078 : 			if (n->GetTeam() != who)

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	movzx	ecx, BYTE PTR _who$[ebp]
	cmp	eax, ecx
	je	SHORT $LN6@SOSecured

; 1079 : 				return 0;

	xor	eax, eax
	jmp	$LN12@SOSecured
$LN6@SOSecured:

; 1080 : 			for (j=0; j<n->NumLinks(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN5@SOSecured
$LN4@SOSecured:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN5@SOSecured:
	mov	ecx, DWORD PTR _n$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	DWORD PTR _j$[ebp], eax
	jge	SHORT $LN7@SOSecured

; 1081 : 			{
; 1082 : 				nn = n->GetNeighbor(j);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _nn$[ebp], eax

; 1083 : 				if (nn && nn->GetObjectiveParentID() == o->Id())

	cmp	DWORD PTR _nn$[ebp], 0
	je	SHORT $LN2@SOSecured
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _nn$[ebp]
	call	?GetObjectiveParentID@ObjectiveClass@@QAE?AVVU_ID@@XZ ; ObjectiveClass::GetObjectiveParentID
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@SOSecured

; 1084 : 				{
; 1085 : 					if (nn->GetTeam() != who)

	mov	ecx, DWORD PTR _nn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _nn$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	je	SHORT $LN2@SOSecured

; 1086 : 						return 0;

	xor	eax, eax
	jmp	SHORT $LN12@SOSecured
$LN2@SOSecured:

; 1087 : 				}
; 1088 : 			}

	jmp	SHORT $LN4@SOSecured
$LN7@SOSecured:

; 1089 : 		}
; 1090 : 	}

	jmp	$LN9@SOSecured
$LN8@SOSecured:

; 1091 : 	return 1;

	mov	eax, 1
$LN12@SOSecured:

; 1092 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SOSecured@@YAHPAVObjectiveClass@@E@Z ENDP		; SOSecured
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_myit$ = -60						; size = 12
$T2 = -48						; size = 8
$T3 = -40						; size = 8
$T4 = -32						; size = 4
_us$ = -28						; size = 4
_them$ = -24						; size = 4
_str$ = -20						; size = 4
_e$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
_list$ = 12						; size = 4
?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z PROC ; CalculateOpposingStrength

; 1095 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1096 : 	Unit			e;
; 1097 : 	int			us,them,str=0;

	mov	DWORD PTR _str$[ebp], 0

; 1098 : 
; 1099 : 	us = u->GetTeam();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _us$[ebp], ecx

; 1100 : 	VuListIterator	myit(list);

	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1101 : 	e = GetFirstUnit(&myit);

	lea	eax, DWORD PTR _myit$[ebp]
	push	eax
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax
$LN4@CalculateO:

; 1102 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN3@CalculateO

; 1103 : 	{
; 1104 : 		them = e->GetTeam();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _them$[ebp], ecx

; 1105 : 		if (GetRoE(us,them,ROE_GROUND_FIRE) && e->GetDomain() == DOMAIN_LAND && e->Combat())

	push	1
	movzx	edx, BYTE PTR _them$[ebp]
	push	edx
	movzx	eax, BYTE PTR _us$[ebp]
	push	eax
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@CalculateO
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 3
	jne	SHORT $LN2@CalculateO
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Combat@UnitClass@@QBEHXZ		; UnitClass::Combat
	test	eax, eax
	je	SHORT $LN2@CalculateO

; 1106 : 		{
; 1107 : 			if (e->GetTargetID() == u->Id())

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetTargetID
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@CalculateO

; 1108 : 				str += e->GetCombatStrength(Foot,0);

	push	0
	push	1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+400]
	call	edx
	add	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _str$[ebp], eax
$LN2@CalculateO:

; 1109 : 		}
; 1110 : 		e = GetNextUnit(&myit);

	lea	eax, DWORD PTR _myit$[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 1111 : 	}

	jmp	$LN4@CalculateO
$LN3@CalculateO:

; 1112 : 	return str;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T4[ebp]

; 1113 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CalculateOpposingStrength@@YAHPAVUnitClass@@PAVFalconPrivateList@@@Z ENDP ; CalculateOpposingStrength
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_w$ = -4						; size = 4
_u$ = 8							; size = 4
?CheckReady@@YAHPAVUnitClass@@@Z PROC			; CheckReady

; 1118 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1119 : 	WayPoint	w;
; 1120 : 
; 1121 : 	if (!u->Detached())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Detached@UnitClass@@QBEHXZ		; UnitClass::Detached
	test	eax, eax
	jne	SHORT $LN2@CheckReady

; 1122 : 	{
; 1123 : 		w = u->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 1124 : 		if (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN2@CheckReady

; 1125 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CheckReady
$LN2@CheckReady:

; 1126 : 	}
; 1127 : 	return 1;

	mov	eax, 1
$LN3@CheckReady:

; 1128 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckReady@@YAHPAVUnitClass@@@Z ENDP			; CheckReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_orders$ = 8						; size = 4
?GetActionFromOrders@@YAHH@Z PROC			; GetActionFromOrders

; 1190 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1191 : 	switch (orders)

	mov	eax, DWORD PTR _orders$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 8
	ja	SHORT $LN1@GetActionF
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN11@GetActionF[edx*4]
$LN6@GetActionF:

; 1192 : 	{
; 1193 : 			case GORD_CAPTURE:
; 1194 : 					return WP_DEFEND;

	mov	eax, 44					; 0000002cH
	jmp	SHORT $LN9@GetActionF

; 1195 : 					break;

	jmp	SHORT $LN9@GetActionF
$LN5@GetActionF:

; 1196 : 			case GORD_DEFEND:
; 1197 : 					return WP_DEFEND;

	mov	eax, 44					; 0000002cH
	jmp	SHORT $LN9@GetActionF

; 1198 : 					break;

	jmp	SHORT $LN9@GetActionF
$LN4@GetActionF:

; 1199 : 			case GORD_SUPPORT:
; 1200 : 					return WP_FIRESUPPORT;

	mov	eax, 48					; 00000030H
	jmp	SHORT $LN9@GetActionF

; 1201 : 					break;

	jmp	SHORT $LN9@GetActionF
$LN3@GetActionF:

; 1202 : 			case GORD_REPAIR:
; 1203 : 					return WP_REPAIR;

	mov	eax, 45					; 0000002dH
	jmp	SHORT $LN9@GetActionF

; 1204 : 					break;

	jmp	SHORT $LN9@GetActionF
$LN2@GetActionF:

; 1205 : 			case GORD_AIRDEFENSE:
; 1206 : 					return WP_AIRDEFENSE;

	mov	eax, 47					; 0000002fH
	jmp	SHORT $LN9@GetActionF

; 1207 : 					break;

	jmp	SHORT $LN9@GetActionF
$LN1@GetActionF:

; 1208 : 			default:
; 1209 : 					return WP_RESERVE;

	mov	eax, 46					; 0000002eH
$LN9@GetActionF:

; 1210 : 					break;
; 1211 : 	}
; 1212 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@GetActionF:
	DD	$LN6@GetActionF
	DD	$LN1@GetActionF
	DD	$LN1@GetActionF
	DD	$LN1@GetActionF
	DD	$LN1@GetActionF
	DD	$LN5@GetActionF
	DD	$LN4@GetActionF
	DD	$LN3@GetActionF
	DD	$LN2@GetActionF
?GetActionFromOrders@@YAHH@Z ENDP			; GetActionFromOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -388						; size = 8
$T3 = -380						; size = 8
$T4 = -372						; size = 8
_ok$5 = -364						; size = 4
_ok$6 = -360						; size = 4
$T7 = -356						; size = 4
$T8 = -352						; size = 4
$T9 = -348						; size = 4
$T10 = -344						; size = 4
$T11 = -340						; size = 4
$T12 = -336						; size = 4
$T13 = -332						; size = 4
$T14 = -328						; size = 4
$T15 = -324						; size = 4
$T16 = -320						; size = 4
_enemy$17 = -316					; size = 4
_bai_time$ = -312					; size = 4
_bai_dist$ = -308					; size = 4
_didcas$ = -304						; size = 4
_action$ = -300						; size = 4
_cost$ = -296						; size = 4
_i$ = -292						; size = 4
_bx$ = -288						; size = 2
_by$ = -284						; size = 2
_brig$ = -280						; size = 4
_t$ = -276						; size = 4
_us$ = -272						; size = 4
_d$ = -268						; size = 4
_nx$ = -264						; size = 2
_ny$ = -260						; size = 2
_speed$ = -256						; size = 4
_ux$ = -252						; size = 2
_uy$ = -248						; size = 2
_dist$ = -244						; size = 4
_tx$ = -240						; size = 2
_ty$ = -236						; size = 2
_n$ = -232						; size = 4
_o$ = -228						; size = 4
_time$ = -224						; size = 4
_oy$ = -220						; size = 2
_ox$ = -216						; size = 2
_path2$ = -212						; size = 60
_mis$18 = -152						; size = 76
_path$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
?BuildGroundWP@@YAHPAVUnitClass@@@Z PROC		; BuildGroundWP

; 767  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildGroundWP@@YAHPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 376				; 00000178H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 768  : 	PathClass		path,path2;

	lea	ecx, DWORD PTR _path$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 769  : 	Objective		n,o,t;
; 770  : 	GridIndex		ux,uy,ox,oy,nx,ny,tx,ty,bx=0,by=0;

	xor	eax, eax
	mov	WORD PTR _bx$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _by$[ebp], cx

; 771  : 	int				i,d,speed,us,action,didcas=0;

	mov	DWORD PTR _didcas$[ebp], 0

; 772  : 	float			cost,dist,bai_dist=MAX_BAI_DIST;

	movsx	edx, WORD PTR ?MAX_BAI_DIST@@3FA	; MAX_BAI_DIST
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _bai_dist$[ebp], xmm0

; 773  : 	CampaignTime	time,bai_time = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _bai_time$[ebp], eax

; 774  : 	Brigade			brig;
; 775  : 
; 776  : 	u->DisposeWayPoints();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints

; 777  : 	u->GetLocation(&ux,&uy);

	lea	eax, DWORD PTR _uy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ux$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 778  : 	u->GetUnitDestination(&tx,&ty);

	lea	edx, DWORD PTR _ty$[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 779  : 	dist = Distance (ux,uy,tx,ty);

	movzx	ecx, WORD PTR _ty$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tx$[ebp]
	push	edx
	movzx	eax, WORD PTR _uy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ux$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dist$[ebp]

; 780  : 	time = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _time$[ebp], eax

; 781  : 	brig = (Brigade)u->GetUnitParent();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+944]
	call	edx
	mov	DWORD PTR _brig$[ebp], eax

; 782  : 	if (brig)

	cmp	DWORD PTR _brig$[ebp], 0
	je	SHORT $LN40@BuildGroun

; 783  : 		speed = brig->GetUnitSpeed();

	mov	eax, DWORD PTR _brig$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _brig$[ebp]
	mov	eax, DWORD PTR [edx+516]
	call	eax
	mov	DWORD PTR _speed$[ebp], eax

; 784  : 	else

	jmp	SHORT $LN39@BuildGroun
$LN40@BuildGroun:

; 785  : 		speed = u->GetUnitSpeed();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+516]
	call	eax
	mov	DWORD PTR _speed$[ebp], eax
$LN39@BuildGroun:

; 786  : 	if (dist < 2.0F)

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN38@BuildGroun

; 787  : 	{
; 788  : 		// Just add one waypoint at our final destination
; 789  : 		u->AddUnitWP(tx,ty,0,speed,time,0,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _speed$[ebp]
	push	edx
	push	0
	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP

; 790  : 		return 1;

	mov	DWORD PTR $T15[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T15[ebp]
	jmp	$LN41@BuildGroun
$LN38@BuildGroun:

; 791  : 	}
; 792  : 	// RV - Biker - Only request air mobile if we have some dist to go
; 793  : 	if (u->GetUnitTactic() == GTACTIC_MOVE_AIRBORNE && dist > 25.0f)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN37@BuildGroun
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@41c80000
	jbe	SHORT $LN37@BuildGroun

; 794  : 	{
; 795  : 		// KCK: We assume we can always find transports.
; 796  : 		RequestAirborneTransport(u);

	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?RequestAirborneTransport@@YAHPAVUnitClass@@@Z ; RequestAirborneTransport
	add	esp, 4

; 797  : 		return 1;			// We've got a ticket to fly!

	mov	DWORD PTR $T9[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN41@BuildGroun
$LN37@BuildGroun:

; 798  : 	}
; 799  : 
; 800  : 	// RV - Biker - Enable infantry units to be carried from choppers
; 801  : 	if (u->GetSType() == STYPE_UNIT_INFANTRY && dist > 50.0f) {

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	cmp	eax, 7
	jne	SHORT $LN36@BuildGroun
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@42480000
	jbe	SHORT $LN36@BuildGroun

; 802  : 		RequestAirborneTransport(u);

	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?RequestAirborneTransport@@YAHPAVUnitClass@@@Z ; RequestAirborneTransport
	add	esp, 4

; 803  : 		return 1;

	mov	DWORD PTR $T7[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN41@BuildGroun
$LN36@BuildGroun:

; 804  : 	}
; 805  : 
; 806  : 	us = u->GetTeam();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	DWORD PTR _us$[ebp], eax

; 807  : 
; 808  : 	if (u->GetType() == TYPE_BATTALION && ((Battalion)u)->last_obj != FalconNullId)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN35@BuildGroun
	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _u$[ebp]
	add	ecx, 340				; 00000154H
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN35@BuildGroun

; 809  : 		o = FindObjective(((Battalion)u)->last_obj);

	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	push	ecx
	mov	edx, DWORD PTR [eax+340]
	push	edx
	call	?FindObjective@@YAPAVObjectiveClass@@VVU_ID@@@Z ; FindObjective
	add	esp, 8
	mov	DWORD PTR _o$[ebp], eax

; 810  : 	else

	jmp	SHORT $LN34@BuildGroun
$LN35@BuildGroun:

; 811  : 		o = FindNearestObjective (ux,uy,NULL);

	push	0
	movzx	eax, WORD PTR _uy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ux$[ebp]
	push	ecx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAM@Z ; FindNearestObjective
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _o$[ebp], eax
$LN34@BuildGroun:

; 812  : 
; 813  : 	if (u->GetUnitTactic() == GTACTIC_MOVE_MARINE)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 17					; 00000011H
	jne	$LN33@BuildGroun

; 814  : 	{
; 815  : 		if (o && o->GetType() == TYPE_PORT)

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN32@BuildGroun
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 19					; 00000013H
	jne	SHORT $LN32@BuildGroun

; 816  : 		{
; 817  : 			// KCK: We assume we can always find transports.
; 818  : 			RequestMarineTransport(u);

	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?RequestMarineTransport@@YAHPAVUnitClass@@@Z ; RequestMarineTransport
	add	esp, 4

; 819  : 			return 1;			// We've got a ticket to ride!

	mov	DWORD PTR $T14[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T14[ebp]
	jmp	$LN41@BuildGroun
$LN32@BuildGroun:

; 820  : 		}
; 821  : 		// KCK TODO: plan wp route to nearest port
; 822  : 		return 1;

	mov	DWORD PTR $T11[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T11[ebp]
	jmp	$LN41@BuildGroun
$LN33@BuildGroun:

; 823  : 	}
; 824  : 
; 825  : 	t = u->GetUnitObjective();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _t$[ebp], eax

; 826  : 	if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN31@BuildGroun

; 827  : 		t = FindNearestObjective (tx,ty,NULL);

	push	0
	movzx	ecx, WORD PTR _ty$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tx$[ebp]
	push	edx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAM@Z ; FindNearestObjective
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax
$LN31@BuildGroun:

; 828  : 	if (o==t || dist < 1.0)

	mov	eax, DWORD PTR _o$[ebp]
	cmp	eax, DWORD PTR _t$[ebp]
	je	SHORT $LN29@BuildGroun
	cvtss2sd xmm0, DWORD PTR _dist$[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN30@BuildGroun
$LN29@BuildGroun:

; 829  : 	{
; 830  : 		// Just add one waypoint at our final destination
; 831  : 		u->AddUnitWP(tx,ty,0,speed,time,0,WP_MOVEUNOPPOSED);

	push	41					; 00000029H
	push	0
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _speed$[ebp]
	push	edx
	push	0
	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP

; 832  : 		return 1;

	mov	DWORD PTR $T10[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T10[ebp]
	jmp	$LN41@BuildGroun
$LN30@BuildGroun:

; 833  : 	}
; 834  : 	if (!o || !t)

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN27@BuildGroun
	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN28@BuildGroun
$LN27@BuildGroun:

; 835  : 		return 0;

	mov	DWORD PTR $T12[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T12[ebp]
	jmp	$LN41@BuildGroun
$LN28@BuildGroun:

; 836  : 	if (u->GetUnitObjectivePath(&path,o,t) < 1)			// Avoid enemy objectives

	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitObjectivePath@UnitClass@@QAEHPAVBasePathClass@@PAVObjectiveClass@@1@Z ; UnitClass::GetUnitObjectivePath
	cmp	eax, 1
	jge	SHORT $LN26@BuildGroun

; 837  : 	{
; 838  : 		int	ok = u->CheckForSurrender();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+936]
	call	edx
	mov	DWORD PTR _ok$6[ebp], eax

; 839  : #ifdef LOG_ERRORS
; 840  : 		char	buffer[1280],name1[80],name2[80],name3[80],timestr[80];
; 841  : 		FILE	*fp;
; 842  : 
; 843  : 		sprintf(buffer,"campaign\\save\\dump\\errors.log");
; 844  : 		fp = fopen(buffer,"a");
; 845  : 		if (fp)
; 846  : 		{
; 847  : 			GridIndex		ex,ey;
; 848  : 			u->GetName(name1,79,FALSE);
; 849  : 			o->GetName(name2,79,FALSE);
; 850  : 			t->GetName(name3,79,FALSE);
; 851  : 			o->GetLocation(&ox,&oy);
; 852  : 			t->GetLocation(&ex,&ey);
; 853  : 			GetTimeString(TheCampaign.CurrentTime,timestr);
; 854  : 			sprintf(buffer,"%s (%d) %d,%d couldn't find obj path from %s (%d) %d,%d to %s (%d) %d,%d @ %s\n",name1,u->GetCampID(),ux,uy,name2,o->GetCampID(),ox,oy,name3,t->GetCampID(),ex,ey,timestr);
; 855  : 			fprintf(fp,buffer);
; 856  : 			if (!ok)
; 857  : 			{
; 858  : 				sprintf(buffer,"%s (%d) %d,%d surrendered @ %s\n",name1,u->GetCampID(),ux,uy,timestr);
; 859  : 				fprintf(fp,buffer);
; 860  : 			}
; 861  : 			fclose(fp);
; 862  : 		}
; 863  : #endif
; 864  : 		return -1;

	mov	DWORD PTR $T8[ebp], -1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN41@BuildGroun
$LN26@BuildGroun:

; 865  : 	}
; 866  : 
; 867  : 	// Find cost (in time) to get to the first WP, and determine which obj to use as start point
; 868  : 	o->GetLocation(&ox,&oy);

	lea	eax, DWORD PTR _oy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 869  : 	d = path.GetDirection(0);

	push	0
	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	DWORD PTR _d$[ebp], eax

; 870  : 	n = o->GetNeighbor(d);

	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _n$[ebp], eax

; 871  : 	n->GetLocation(&nx,&ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 872  : 	if (DistSqu(ux,uy,nx,ny) < DistSqu(ox,oy,nx,ny))

	movzx	edx, WORD PTR _ny$[ebp]
	push	edx
	movzx	eax, WORD PTR _nx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _uy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ux$[ebp]
	push	edx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	mov	esi, eax
	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jge	SHORT $LN25@BuildGroun

; 873  : 	{
; 874  : 		o = n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _o$[ebp], ecx

; 875  : 		ox = nx;

	mov	dx, WORD PTR _nx$[ebp]
	mov	WORD PTR _ox$[ebp], dx

; 876  : 		oy = ny;

	mov	ax, WORD PTR _ny$[ebp]
	mov	WORD PTR _oy$[ebp], ax

; 877  : 		i = 1;	// First step in path

	mov	DWORD PTR _i$[ebp], 1

; 878  : 	}
; 879  : 	else

	jmp	SHORT $LN24@BuildGroun
$LN25@BuildGroun:

; 880  : 	{
; 881  : 		i = 0;	// Zeroth step in path

	mov	DWORD PTR _i$[ebp], 0
$LN24@BuildGroun:

; 882  : 	}
; 883  : 	if (u->GetUnitGridPath(&path2,ux,uy,ox,oy) > 0)

	movzx	ecx, WORD PTR _oy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ox$[ebp]
	push	edx
	movzx	eax, WORD PTR _uy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ux$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath
	test	eax, eax
	jle	SHORT $LN23@BuildGroun

; 884  : 	{
; 885  : 		if (u->IsBattalion())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN22@BuildGroun

; 886  : 			((Battalion)u)->path->CopyPath(&path2);		// Might as well use the path.

	lea	ecx, DWORD PTR _path2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [edx+356]
	call	?CopyPath@BasePathClass@@QAEHPAV1@@Z	; BasePathClass::CopyPath
$LN22@BuildGroun:

; 887  : 		cost = path2.GetCost();

	lea	ecx, DWORD PTR _path2$[ebp]
	call	?GetCost@BasePathClass@@QAEMXZ		; BasePathClass::GetCost
	fstp	DWORD PTR _cost$[ebp]

; 888  : 		time += TimeToArrive(cost,(float)speed);

	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cost$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	add	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _time$[ebp], eax

; 889  : 	}
; 890  : 	else

	jmp	SHORT $LN21@BuildGroun
$LN23@BuildGroun:

; 891  : 	{
; 892  : 		int ok = u->CheckForSurrender();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+936]
	call	eax
	mov	DWORD PTR _ok$5[ebp], eax

; 893  : #ifdef LOG_ERRORS
; 894  : 		char	buffer[1280],name1[80],name2[80],timestr[80];
; 895  : 		FILE	*fp;
; 896  : 
; 897  : 		sprintf(buffer,"campaign\\save\\dump\\errors.log");
; 898  : 		fp = fopen(buffer,"a");
; 899  : 		if (fp)
; 900  : 		{
; 901  : 			u->GetName(name1,79,FALSE);
; 902  : 			o->GetName(name2,79,FALSE);
; 903  : 			GetTimeString(TheCampaign.CurrentTime,timestr);
; 904  : 			sprintf(buffer,"%s (%d) couldn't move to %s (%d) %d,%d from %d,%d @ %s\n",name1,u->GetCampID(),name2,o->GetCampID(),ox,oy,ux,uy,timestr);
; 905  : 			fprintf(fp,buffer);
; 906  : 			fclose(fp);
; 907  : 			if (!ok)
; 908  : 			{
; 909  : 				sprintf(buffer,"%s (%d) %d,%d surrendered @ %s\n",name1,u->GetCampID(),ux,uy,timestr);
; 910  : 				fprintf(fp,buffer);
; 911  : 			}
; 912  : 		}
; 913  : #endif
; 914  : 		return -1;

	mov	DWORD PTR $T16[ebp], -1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T16[ebp]
	jmp	$LN41@BuildGroun
$LN21@BuildGroun:

; 915  : 	}
; 916  : 
; 917  : 	// Add our first WP
; 918  : 	action = GetThisWPAction (u,o,o,0,us,&cost);

	lea	ecx, DWORD PTR _cost$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _us$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?GetThisWPAction@@YAHPAVUnitClass@@PAVObjectiveClass@@1HEPAM@Z ; GetThisWPAction
	add	esp, 24					; 00000018H
	mov	DWORD PTR _action$[ebp], eax

; 919  : 	u->AddUnitWP(ox,oy,0,speed,time,0,action);

	movzx	eax, BYTE PTR _action$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _speed$[ebp]
	push	edx
	push	0
	movzx	eax, WORD PTR _oy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP

; 920  : 
; 921  : 	// Now set the rest of the path
; 922  : 	for (;i<path.GetLength(); i++){

	jmp	SHORT $LN20@BuildGroun
$LN19@BuildGroun:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN20@BuildGroun:
	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetLength@BasePathClass@@QAEHXZ	; BasePathClass::GetLength
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN18@BuildGroun

; 923  : 		d = path.GetDirection(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	DWORD PTR _d$[ebp], eax

; 924  : 		n = o->GetNeighbor(d);

	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _n$[ebp], eax

; 925  : 		n->GetLocation(&ox,&oy);

	lea	edx, DWORD PTR _oy$[ebp]
	push	edx
	lea	eax, DWORD PTR _ox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 926  : 		cost = o->GetNeighborCost(d,u->GetObjMovementType(o,d));

	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+932]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ; ObjectiveClass::GetNeighborCost
	fstp	DWORD PTR _cost$[ebp]

; 927  : 		action = GetThisWPAction (u,o,n,d,us,&cost);

	lea	edx, DWORD PTR _cost$[ebp]
	push	edx
	movzx	eax, BYTE PTR _us$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?GetThisWPAction@@YAHPAVUnitClass@@PAVObjectiveClass@@1HEPAM@Z ; GetThisWPAction
	add	esp, 24					; 00000018H
	mov	DWORD PTR _action$[ebp], eax

; 928  : 		time += TimeToArrive(cost,(float)speed);

	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cost$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	add	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _time$[ebp], eax

; 929  : 		if (!didcas && (time - Camp_GetCurrentTime())/CampaignMinutes < MissionData[AMIS_BAI].max_time){

	cmp	DWORD PTR _didcas$[ebp], 0
	jne	$LN16@BuildGroun
	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	edx, DWORD PTR _time$[ebp]
	sub	edx, eax
	mov	eax, edx
	xor	edx, edx
	mov	ecx, 60000				; 0000ea60H
	div	ecx
	mov	edx, 32					; 00000020H
	imul	edx, 25					; 00000019H
	movzx	ecx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[edx+20]
	cmp	eax, ecx
	jae	$LN16@BuildGroun

; 930  : 			dist = DistanceToFront(ox,oy);

	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 931  : 			if (dist > MAX_BAI_DIST/5 && dist < bai_dist){

	movsx	eax, WORD PTR ?MAX_BAI_DIST@@3FA	; MAX_BAI_DIST
	cdq
	mov	ecx, 5
	idiv	ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@BuildGroun
	movss	xmm0, DWORD PTR _bai_dist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN16@BuildGroun

; 932  : 				bai_time = time;

	mov	edx, DWORD PTR _time$[ebp]
	mov	DWORD PTR _bai_time$[ebp], edx

; 933  : 				bai_dist = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _bai_dist$[ebp], xmm0

; 934  : 				bx = ox;

	mov	ax, WORD PTR _ox$[ebp]
	mov	WORD PTR _bx$[ebp], ax

; 935  : 				by = oy;

	mov	cx, WORD PTR _oy$[ebp]
	mov	WORD PTR _by$[ebp], cx
$LN16@BuildGroun:

; 936  : 			}
; 937  : 		}
; 938  : 
; 939  : 		// Check to see if we're aproaching the enemy
; 940  : 		if (n->IsFrontline() && GetRoE(us,n->GetTeam(),ROE_GROUND_CAPTURE) == ROE_ALLOWED){

	mov	ecx, DWORD PTR _n$[ebp]
	call	?IsFrontline@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsFrontline
	test	eax, eax
	je	$LN13@BuildGroun
	push	3
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	movzx	ecx, BYTE PTR _us$[ebp]
	push	ecx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN13@BuildGroun

; 941  : 			// Set our time to our offensive time, if our offensive hasn't started yet
; 942  : 			if (time < TeamInfo[us]->GetGroundAction()->actionTime){

	mov	edx, DWORD PTR _us$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN14@BuildGroun

; 943  : 				time = TeamInfo[us]->GetGroundAction()->actionTime;

	mov	edx, DWORD PTR _us$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _time$[ebp], eax
$LN14@BuildGroun:

; 944  : 			}
; 945  : 
; 946  : 			if (!didcas){

	cmp	DWORD PTR _didcas$[ebp], 0
	jne	SHORT $LN13@BuildGroun

; 947  : 				Unit enemy = FindNearestEnemyUnit(ox, oy, 10);

	push	10					; 0000000aH
	movzx	ecx, WORD PTR _oy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ox$[ebp]
	push	edx
	call	?FindNearestEnemyUnit@@YAPAVUnitClass@@FFF@Z ; FindNearestEnemyUnit
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _enemy$17[ebp], eax

; 948  : 				// Request CAS vs enemy unit nearest to our destination
; 949  : 				if (enemy){

	cmp	DWORD PTR _enemy$17[ebp], 0
	je	SHORT $LN12@BuildGroun

; 950  : 					// M.N. Doesn't make sense to make two CASRequests vs us....
; 951  : 					RequestOCCAS(/*u*/ enemy, ox, oy, time);	

	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	movzx	ecx, WORD PTR _oy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ox$[ebp]
	push	edx
	mov	eax, DWORD PTR _enemy$17[ebp]
	push	eax
	call	?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z	; RequestOCCAS
	add	esp, 16					; 00000010H

; 952  : 					// Request CAS vs us as well
; 953  : 					RequestOCCAS(u, ox, oy, time);	// added {} so that only cas against us if enemy unit was found

	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	movzx	edx, WORD PTR _oy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?RequestOCCAS@@YAXPAVUnitClass@@FFK@Z	; RequestOCCAS
	add	esp, 16					; 00000010H
$LN12@BuildGroun:

; 954  : 				}
; 955  : 				didcas = 1;

	mov	DWORD PTR _didcas$[ebp], 1
$LN13@BuildGroun:

; 956  : 			}
; 957  : 		}
; 958  : 		
; 959  : 		// RV - Biker - Don't do this
; 960  : 		//// KCK Hackish: limit these sort of plans to 60 minutes in the future. Hope we don't
; 961  : 		//// Change them before then..
; 962  : 		//// Also - limit to first unit element if moving in brigade column,
; 963  : 		//// so we don't generate a request for every battalion in a brigade
; 964  : 		if (time - Camp_GetCurrentTime() < 60*CampaignMinutes && 
; 965  : 						(!u->GetUnitElement() || u->GetUnitTactic() != GTACTIC_MOVE_BRIGADE_COLUMN))

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	edx, DWORD PTR _time$[ebp]
	sub	edx, eax
	cmp	edx, 3600000				; 0036ee80H
	jae	$LN9@BuildGroun
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+892]
	call	eax
	test	eax, eax
	je	SHORT $LN10@BuildGroun
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 18					; 00000012H
	je	$LN9@BuildGroun
$LN10@BuildGroun:

; 966  : 		{
; 967  : 		//	if (n->GetType() == TYPE_BRIDGE && (n->GetTeam() == us || TeamInfo[n->GetTeam()]->GetInitiative() < 40))
; 968  : 		//	{
; 969  : 		//		// Send request for bridge interdiction
; 970  : 		//		MissionRequestClass	mis;
; 971  : 		//		mis.requesterID = u->Id();
; 972  : 		//		mis.tot = time;
; 973  : 		//		mis.vs = us;
; 974  : 		//		mis.tot_type = TYPE_LT;
; 975  : 		//		mis.tx = ox;
; 976  : 		//		mis.ty = oy;
; 977  : 		//		mis.targetID = n->Id();
; 978  : 		//		mis.mission = AMIS_INTSTRIKE;
; 979  : 		//		mis.roe_check = ROE_AIR_ATTACK;
; 980  : 		//		if (n->IsNearfront())
; 981  : 		//			mis.priority = 50;
; 982  : 		//		if (u->GetUnitOrders() == GORD_CAPTURE)
; 983  : 		//			mis.context = enemyUnitAdvanceBridge;
; 984  : 		//		else
; 985  : 		//			mis.context = enemyUnitMoveBridge;
; 986  : 		//		mis.RequestEnemyMission();
; 987  : 		//	}
; 988  : 			if (n->GetType() == TYPE_ROAD || n->GetType() == TYPE_INTERSECT)

	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 26					; 0000001aH
	je	SHORT $LN8@BuildGroun
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 15					; 0000000fH
	jne	$LN9@BuildGroun
$LN8@BuildGroun:

; 989  : 			{
; 990  : 				// Send request for interdiction
; 991  : 				MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$18[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 992  : 				if (brig)

	cmp	DWORD PTR _brig$[ebp], 0
	je	SHORT $LN7@BuildGroun

; 993  : 					mis.requesterID = brig->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _brig$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$18[ebp], ecx
	mov	DWORD PTR _mis$18[ebp+4], edx

; 994  : 				else

	jmp	SHORT $LN6@BuildGroun
$LN7@BuildGroun:

; 995  : 					mis.requesterID = u->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$18[ebp], ecx
	mov	DWORD PTR _mis$18[ebp+4], edx
$LN6@BuildGroun:

; 996  : 				mis.tot = time;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _mis$18[ebp+36], eax

; 997  : 				mis.vs = us;

	mov	cl, BYTE PTR _us$[ebp]
	mov	BYTE PTR _mis$18[ebp+33], cl

; 998  : 				mis.tot_type = TYPE_EQ;

	mov	BYTE PTR _mis$18[ebp+58], 3

; 999  : 				mis.tx = ox;

	mov	dx, WORD PTR _ox$[ebp]
	mov	WORD PTR _mis$18[ebp+40], dx

; 1000 : 				mis.ty = oy;

	mov	ax, WORD PTR _oy$[ebp]
	mov	WORD PTR _mis$18[ebp+42], ax

; 1001 : 				//				if (brig)
; 1002 : 				//					mis.targetID = brig->Id();
; 1003 : 				//				else
; 1004 : 				mis.targetID = u->Id();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$18[ebp+8], edx
	mov	DWORD PTR _mis$18[ebp+12], eax

; 1005 : 				mis.mission = AMIS_INT;

	mov	BYTE PTR _mis$18[ebp+60], 24		; 00000018H

; 1006 : 				mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$18[ebp+63], 8

; 1007 : 				if (u->GetUnitOrders() == GORD_CAPTURE)

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN5@BuildGroun

; 1008 : 					mis.context = enemyUnitAdvance;

	mov	BYTE PTR _mis$18[ebp+62], 3

; 1009 : 				else

	jmp	SHORT $LN4@BuildGroun
$LN5@BuildGroun:

; 1010 : 					mis.context = enemyUnitMove;

	mov	BYTE PTR _mis$18[ebp+62], 4
$LN4@BuildGroun:

; 1011 : 				mis.RequestEnemyMission();

	lea	ecx, DWORD PTR _mis$18[ebp]
	call	?RequestEnemyMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestEnemyMission

; 1012 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _mis$18[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
$LN9@BuildGroun:

; 1013 : 		}
; 1014 : 		
; 1015 : 		// If it's the last step in path, let's set it to our actual destination
; 1016 : 		if (n == t)

	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR _t$[ebp]
	jne	SHORT $LN3@BuildGroun

; 1017 : 			u->AddUnitWP(tx,ty,0,speed,time,0,action);

	movzx	edx, BYTE PTR _action$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _speed$[ebp]
	push	ecx
	push	0
	movzx	edx, WORD PTR _ty$[ebp]
	push	edx
	movzx	eax, WORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP

; 1018 : 		else

	jmp	SHORT $LN2@BuildGroun
$LN3@BuildGroun:

; 1019 : 			u->AddUnitWP(ox,oy,0,speed,time,0,action);

	movzx	ecx, BYTE PTR _action$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _time$[ebp]
	push	edx
	mov	eax, DWORD PTR _speed$[ebp]
	push	eax
	push	0
	movzx	ecx, WORD PTR _oy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ox$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP
$LN2@BuildGroun:

; 1020 : 		o = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _o$[ebp], eax

; 1021 : 	}

	jmp	$LN19@BuildGroun
$LN18@BuildGroun:

; 1022 : 	// Check for any BAI missions we can fly
; 1023 : 	if (!didcas && bai_dist < MAX_BAI_DIST && dist > MAX_BAI_DIST/5)

	cmp	DWORD PTR _didcas$[ebp], 0
	jne	SHORT $LN1@BuildGroun
	movsx	ecx, WORD PTR ?MAX_BAI_DIST@@3FA	; MAX_BAI_DIST
	cvtsi2ss xmm0, ecx
	comiss	xmm0, DWORD PTR _bai_dist$[ebp]
	jbe	SHORT $LN1@BuildGroun
	movsx	eax, WORD PTR ?MAX_BAI_DIST@@3FA	; MAX_BAI_DIST
	cdq
	mov	ecx, 5
	idiv	ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@BuildGroun

; 1024 : 		RequestBAI(u, bx, by, bai_time);

	mov	edx, DWORD PTR _bai_time$[ebp]
	push	edx
	movzx	eax, WORD PTR _by$[ebp]
	push	eax
	movzx	ecx, WORD PTR _bx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?RequestBAI@@YAXPAVUnitClass@@FFK@Z	; RequestBAI
	add	esp, 16					; 00000010H
$LN1@BuildGroun:

; 1025 : 	return 1;

	mov	DWORD PTR $T13[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _path2$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T13[ebp]
$LN41@BuildGroun:

; 1026 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildGroundWP@@YAHPAVUnitClass@@@Z$0:
	lea	ecx, DWORD PTR _path$[ebp]
	jmp	??1PathClass@@QAE@XZ
__unwindfunclet$?BuildGroundWP@@YAHPAVUnitClass@@@Z$1:
	lea	ecx, DWORD PTR _path2$[ebp]
	jmp	??1PathClass@@QAE@XZ
__unwindfunclet$?BuildGroundWP@@YAHPAVUnitClass@@@Z$2:
	lea	ecx, DWORD PTR _mis$18[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__ehhandler$?BuildGroundWP@@YAHPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildGroundWP@@YAHPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildGroundWP@@YAHPAVUnitClass@@@Z ENDP		; BuildGroundWP
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_d$ = 8							; size = 4
_pos$ = 12						; size = 4
?FindNextBest@@YAHHQAH@Z PROC				; FindNextBest

; 726  : {

	push	ebp
	mov	ebp, esp

; 727  : 	if (d%2)		// if diagonal

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN10@FindNextBe
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN10@FindNextBe:
	test	eax, eax
	je	SHORT $LN7@FindNextBe

; 728  : 	{
; 729  : 		if (!pos[(d+10)%16])

	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 10					; 0000000aH
	and	ecx, -2147483633			; 8000000fH
	jns	SHORT $LN11@FindNextBe
	dec	ecx
	or	ecx, -16				; fffffff0H
	inc	ecx
$LN11@FindNextBe:
	mov	edx, DWORD PTR _pos$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN6@FindNextBe

; 730  : 			return (d+10)%16;

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 10					; 0000000aH
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN12@FindNextBe
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN12@FindNextBe:
	jmp	$LN8@FindNextBe
$LN6@FindNextBe:

; 731  : 		if (!pos[d+8])

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	cmp	DWORD PTR [edx+ecx*4+32], 0
	jne	SHORT $LN7@FindNextBe

; 732  : 			return d+8;

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 8
	jmp	$LN8@FindNextBe
$LN7@FindNextBe:

; 733  : 	}
; 734  : 	if (!pos[(d+1)%8])

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN13@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN13@FindNextBe:
	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN4@FindNextBe

; 735  : 		return (d+1)%8;

	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 1
	mov	eax, edx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN14@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN14@FindNextBe:
	jmp	$LN8@FindNextBe
$LN4@FindNextBe:

; 736  : 	if (!pos[(d+7)%8])

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 7
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN15@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN15@FindNextBe:
	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN3@FindNextBe

; 737  : 		return (d+7)%8;

	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 7
	mov	eax, edx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN16@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN16@FindNextBe:
	jmp	SHORT $LN8@FindNextBe
$LN3@FindNextBe:

; 738  : 	if (!pos[(d+2)%8])

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 2
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN17@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN17@FindNextBe:
	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN2@FindNextBe

; 739  : 		return (d+2)%8;

	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 2
	mov	eax, edx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN18@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN18@FindNextBe:
	jmp	SHORT $LN8@FindNextBe
$LN2@FindNextBe:

; 740  : 	if (!pos[(d+6)%8])

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 6
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN19@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN19@FindNextBe:
	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@FindNextBe

; 741  : 		return (d+6)%8;

	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 6
	mov	eax, edx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN20@FindNextBe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN20@FindNextBe:
	jmp	SHORT $LN8@FindNextBe
$LN1@FindNextBe:

; 742  : 	return Here;

	mov	eax, 8
$LN8@FindNextBe:

; 743  : }

	pop	ebp
	ret	0
?FindNextBest@@YAHHQAH@Z ENDP				; FindNextBest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_bs$ = -24						; size = 4
tv72 = -20						; size = 4
_be$ = -16						; size = 4
_uc$ = -12						; size = 4
_e$ = -8						; size = 4
_s$ = -4						; size = 4
_u$ = 8							; size = 4
_at$ = 12						; size = 4
_role$ = 16						; size = 4
?BestElement@@YAPAVUnitClass@@PAV1@HH@Z PROC		; BestElement

; 674  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 675  : 	Unit	e,be=NULL;

	mov	DWORD PTR _be$[ebp], 0

; 676  : 	int		s,bs = -1;

	mov	DWORD PTR _bs$[ebp], -1

; 677  : 	UnitClassDataType	*uc;
; 678  : 
; 679  : 	e = u->GetFirstUnitElement();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN17@BestElemen:

; 680  : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN16@BestElemen

; 681  : 	{
; 682  : 		//		s = e->GetCombatStrength(at,0) * (e->GetUnitClassData())->Scores[role];
; 683  : 		uc = e->GetUnitClassData();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 684  : 		if (uc)

	cmp	DWORD PTR _uc$[ebp], 0
	je	$LN15@BestElemen

; 685  : 		{
; 686  : 			switch (role)

	mov	ecx, DWORD PTR _role$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 5
	jl	SHORT $LN9@BestElemen
	cmp	DWORD PTR tv72[ebp], 7
	jle	SHORT $LN12@BestElemen
	jmp	SHORT $LN9@BestElemen
$LN12@BestElemen:

; 687  : 			{
; 688  : 					case GRO_AIRDEFENSE:
; 689  : 					case GRO_FIRESUPPORT:
; 690  : 					case GRO_ENGINEER:
; 691  : 							if (uc->Role != role)

	mov	edx, DWORD PTR _uc$[ebp]
	movzx	eax, BYTE PTR [edx+284]
	cmp	eax, DWORD PTR _role$[ebp]
	je	SHORT $LN11@BestElemen

; 692  : 								s = -1;

	mov	DWORD PTR _s$[ebp], -1

; 693  : 							else

	jmp	SHORT $LN10@BestElemen
$LN11@BestElemen:

; 694  : 								s = e->GetTotalVehicles() * uc->Scores[role];  // s = e->GetUnitGROScore(role)

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	ecx, DWORD PTR _uc$[ebp]
	add	ecx, DWORD PTR _role$[ebp]
	movzx	edx, BYTE PTR [ecx+268]
	imul	eax, edx
	mov	DWORD PTR _s$[ebp], eax
$LN10@BestElemen:

; 695  : 							break;

	jmp	SHORT $LN13@BestElemen
$LN9@BestElemen:

; 696  : 					case GRO_RESERVE:
; 697  : 					case GRO_ATTACK:
; 698  : 					case GRO_DEFENSE:
; 699  : 					case GRO_RECON:
; 700  : 					default:
; 701  : 							if (uc->Role == GRO_AIRDEFENSE || uc->Role == GRO_FIRESUPPORT || uc->Role == GRO_ENGINEER)

	mov	eax, DWORD PTR _uc$[ebp]
	movzx	ecx, BYTE PTR [eax+284]
	cmp	ecx, 5
	je	SHORT $LN7@BestElemen
	mov	edx, DWORD PTR _uc$[ebp]
	movzx	eax, BYTE PTR [edx+284]
	cmp	eax, 6
	je	SHORT $LN7@BestElemen
	mov	ecx, DWORD PTR _uc$[ebp]
	movzx	edx, BYTE PTR [ecx+284]
	cmp	edx, 7
	jne	SHORT $LN8@BestElemen
$LN7@BestElemen:

; 702  : 								s = -1;

	mov	DWORD PTR _s$[ebp], -1

; 703  : 							else

	jmp	SHORT $LN6@BestElemen
$LN8@BestElemen:

; 704  : 								s = e->GetTotalVehicles() * uc->Scores[role];

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	ecx, DWORD PTR _uc$[ebp]
	add	ecx, DWORD PTR _role$[ebp]
	movzx	edx, BYTE PTR [ecx+268]
	imul	eax, edx
	mov	DWORD PTR _s$[ebp], eax
$LN6@BestElemen:
$LN13@BestElemen:

; 705  : 							break;
; 706  : 			}
; 707  : 		}
; 708  : 		else

	jmp	SHORT $LN5@BestElemen
$LN15@BestElemen:

; 709  : 			s = 0;

	mov	DWORD PTR _s$[ebp], 0
$LN5@BestElemen:

; 710  : 		s -= FloatToInt32(0.1F*s)*e->GetUnitElement();		// Keep elements from switching friviously

	cvtsi2ss xmm0, DWORD PTR _s$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+892]
	call	eax
	imul	esi, eax
	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, esi
	mov	DWORD PTR _s$[ebp], ecx

; 711  : 		if (e->Retreating())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?Retreating@UnitClass@@QBEHXZ		; UnitClass::Retreating
	test	eax, eax
	je	SHORT $LN4@BestElemen

; 712  : 			s /= 2;

	mov	eax, DWORD PTR _s$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN4@BestElemen:

; 713  : 		if (!e->Assigned() && s > bs && (role == GRO_RESERVE || !e->Broken()))

	mov	ecx, DWORD PTR _e$[ebp]
	call	?Assigned@UnitClass@@QBEHXZ		; UnitClass::Assigned
	test	eax, eax
	jne	SHORT $LN3@BestElemen
	mov	edx, DWORD PTR _s$[ebp]
	cmp	edx, DWORD PTR _bs$[ebp]
	jle	SHORT $LN3@BestElemen
	cmp	DWORD PTR _role$[ebp], 0
	je	SHORT $LN2@BestElemen
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	jne	SHORT $LN3@BestElemen
$LN2@BestElemen:

; 714  : 		{
; 715  : 			be = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _be$[ebp], eax

; 716  : 			bs = s;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _bs$[ebp], ecx
$LN3@BestElemen:

; 717  : 		}
; 718  : 		e = u->GetNextUnitElement();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+960]
	call	edx
	mov	DWORD PTR _e$[ebp], eax

; 719  : 	}

	jmp	$LN17@BestElemen
$LN16@BestElemen:

; 720  : 	if (be)

	cmp	DWORD PTR _be$[ebp], 0
	je	SHORT $LN1@BestElemen

; 721  : 		be->SetAssigned(1);

	push	1
	mov	ecx, DWORD PTR _be$[ebp]
	call	?SetAssigned@UnitClass@@QAEXH@Z		; UnitClass::SetAssigned
$LN1@BestElemen:

; 722  : 	return be;

	mov	eax, DWORD PTR _be$[ebp]

; 723  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?BestElement@@YAPAVUnitClass@@PAV1@HH@Z ENDP		; BestElement
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GGroundUnitClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GGroundUnitClass@@UAEPAXI@Z PROC			; GroundUnitClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1GroundUnitClass@@UAE@XZ		; GroundUnitClass::~GroundUnitClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GGroundUnitClass@@UAEPAXI@Z ENDP			; GroundUnitClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bits$ = -1						; size = 1
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
?ReadDirty@GroundUnitClass@@QAEXPAPAEPAJ@Z PROC		; GroundUnitClass::ReadDirty
; _this$ = ecx

; 2220 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2221 : 	unsigned char bits;
; 2222 : 	
; 2223 : 	memcpychk(&bits, stream, sizeof(unsigned char), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bits$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2224 : 
; 2225 : 	if (bits & DIRTY_ORDERS) {

	movzx	eax, BYTE PTR _bits$[ebp]
	and	eax, 1
	je	SHORT $LN5@ReadDirty

; 2226 : 		memcpychk(&orders, stream, sizeof(uchar), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN5@ReadDirty:

; 2227 : 	}
; 2228 : 
; 2229 : 	if (bits & DIRTY_DIVISION) {

	movzx	ecx, BYTE PTR _bits$[ebp]
	and	ecx, 2
	je	SHORT $LN4@ReadDirty

; 2230 : 		memcpychk(&division, stream, sizeof(short), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 262				; 00000106H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN4@ReadDirty:

; 2231 : 	}
; 2232 : 
; 2233 : 	if (bits & DIRTY_AOBJ) {

	movzx	edx, BYTE PTR _bits$[ebp]
	and	edx, 4
	je	SHORT $LN3@ReadDirty

; 2234 : 		memcpychk(&aobj, stream, sizeof(VU_ID), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 280				; 00000118H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN3@ReadDirty:

; 2235 : 	}
; 2236 : 
; 2237 : 	if (bits & DIRTY_SOBJ) {

	movzx	eax, BYTE PTR _bits$[ebp]
	and	eax, 8
	je	SHORT $LN2@ReadDirty

; 2238 : 		memcpychk(&sobj, stream, sizeof(VU_ID), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 272				; 00000110H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN2@ReadDirty:

; 2239 : 	}
; 2240 : 
; 2241 : 	if (bits & DIRTY_POBJ) {

	movzx	ecx, BYTE PTR _bits$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN6@ReadDirty

; 2242 : 		memcpychk(&pobj, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN6@ReadDirty:

; 2243 : 	}
; 2244 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ReadDirty@GroundUnitClass@@QAEXPAPAEPAJ@Z ENDP		; GroundUnitClass::ReadDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ptr$ = -4						; size = 4
_stream$ = 8						; size = 4
?WriteDirty@GroundUnitClass@@QAEXPAPAE@Z PROC		; GroundUnitClass::WriteDirty
; _this$ = ecx

; 2168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2169 : 	unsigned char
; 2170 : 			*ptr;
; 2171 : 
; 2172 : 	ptr = *stream;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptr$[ebp], ecx

; 2173 : 
; 2174 : 	MonoPrint ("  GU %08x", dirty_ground_unit);//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	push	OFFSET ??_C@_09LAFEABCL@?5?5GU?5?$CF08x?$AA@
	call	_MonoPrint
	add	esp, 8

; 2175 : 
; 2176 : 	// Encode it up
; 2177 : 	*(uchar*)ptr = (uchar) dirty_ground_unit;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+288]
	mov	BYTE PTR [ecx], al

; 2178 : 	ptr += sizeof (uchar);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 2179 : 
; 2180 : 	if (dirty_ground_unit & DIRTY_ORDERS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	and	eax, 1
	je	SHORT $LN5@WriteDirty

; 2181 : 	{
; 2182 : 		*(uchar*)ptr = orders;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+260]
	mov	BYTE PTR [ecx], al

; 2183 : 		ptr += sizeof (uchar);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
$LN5@WriteDirty:

; 2184 : 	}
; 2185 : 
; 2186 : 	if (dirty_ground_unit & DIRTY_DIVISION)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	and	eax, 2
	je	SHORT $LN4@WriteDirty

; 2187 : 	{
; 2188 : 		*(short*)ptr = division;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+262]
	mov	WORD PTR [ecx], ax

; 2189 : 		ptr += sizeof (short);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx
$LN4@WriteDirty:

; 2190 : 	}
; 2191 : 
; 2192 : 	if (dirty_ground_unit & DIRTY_AOBJ)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	and	eax, 4
	je	SHORT $LN3@WriteDirty

; 2193 : 	{
; 2194 : 		*(VU_ID*)ptr = aobj;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR [ecx+284]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 2195 : 		ptr += sizeof (VU_ID);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 8
	mov	DWORD PTR _ptr$[ebp], edx
$LN3@WriteDirty:

; 2196 : 	}
; 2197 : 
; 2198 : 	if (dirty_ground_unit & DIRTY_SOBJ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	and	ecx, 8
	je	SHORT $LN2@WriteDirty

; 2199 : 	{
; 2200 : 		*(VU_ID*)ptr = sobj;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+272]
	mov	ecx, DWORD PTR [edx+276]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 2201 : 		ptr += sizeof (VU_ID);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 8
	mov	DWORD PTR _ptr$[ebp], eax
$LN2@WriteDirty:

; 2202 : 	}
; 2203 : 
; 2204 : 	if (dirty_ground_unit & DIRTY_POBJ)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	and	edx, 16					; 00000010H
	je	SHORT $LN1@WriteDirty

; 2205 : 	{
; 2206 : 		*(VU_ID*)ptr = pobj;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	edx, DWORD PTR [eax+268]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 2207 : 		ptr += sizeof (VU_ID);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptr$[ebp], ecx
$LN1@WriteDirty:

; 2208 : 	}
; 2209 : 
; 2210 : 	dirty_ground_unit = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0

; 2211 : 	//sfr: was not updating stream, added here!
; 2212 : 	*stream = ptr;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WriteDirty@GroundUnitClass@@QAEXPAPAE@Z ENDP		; GroundUnitClass::WriteDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
_score$ = 12						; size = 4
?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z PROC ; GroundUnitClass::MakeGndUnitDirty
; _this$ = ecx

; 2150 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2151 : 	if ((!IsLocal()) || (VuState() != VU_MEM_ACTIVE)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@MakeGndUni
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	je	SHORT $LN3@MakeGndUni
$LN2@MakeGndUni:

; 2152 : 		return;

	jmp	SHORT $LN4@MakeGndUni
$LN3@MakeGndUni:

; 2153 : 	}
; 2154 : 
; 2155 : 	if (!IsAggregate() && (score != SEND_RELIABLEANDOOB)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN1@MakeGndUni
	cmp	DWORD PTR _score$[ebp], 268435456	; 10000000H
	je	SHORT $LN1@MakeGndUni

; 2156 : 		score = static_cast<Dirtyness>(score << 4);

	mov	ecx, DWORD PTR _score$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _score$[ebp], ecx
$LN1@MakeGndUni:

; 2157 : 	}
; 2158 : 	dirty_ground_unit |= bits;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	or	eax, DWORD PTR _bits$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 2159 : 
; 2160 : 	MakeDirty (DIRTY_GROUND_UNIT, score);

	mov	edx, DWORD PTR _score$[ebp]
	push	edx
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z ; FalconEntity::MakeDirty
$LN4@MakeGndUni:

; 2161 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ENDP ; GroundUnitClass::MakeGndUnitDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BuildMission@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::BuildMission
; _this$ = ecx

; 665  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 666  : 	return BuildGroundWP(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?BuildGroundWP@@YAHPAVUnitClass@@@Z	; BuildGroundWP
	add	esp, 4

; 667  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildMission@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::BuildMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitCurrentRole@GroundUnitClass@@UBEHXZ PROC	; GroundUnitClass::GetUnitCurrentRole
; _this$ = ecx

; 660  : int GroundUnitClass::GetUnitCurrentRole() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 	return GetGroundRole(orders);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+260]
	push	ecx
	call	?GetGroundRole@@YAHH@Z			; GetGroundRole
	add	esp, 4

; 662  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitCurrentRole@GroundUnitClass@@UBEHXZ ENDP	; GroundUnitClass::GetUnitCurrentRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uc$ = -4						; size = 4
?GetUnitNormalRole@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::GetUnitNormalRole
; _this$ = ecx

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 652  : 	UnitClassDataType*	uc;
; 653  : 
; 654  : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 655  : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN1@GetUnitNor

; 656  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetUnitNor
$LN1@GetUnitNor:

; 657  : 	return uc->Role;

	mov	eax, DWORD PTR _uc$[ebp]
	movzx	eax, BYTE PTR [eax+284]
$LN2@GetUnitNor:

; 658  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitNormalRole@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::GetUnitNormalRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
?CheckForSurrender@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::CheckForSurrender
; _this$ = ecx

; 631  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 	GridIndex	x,y;
; 633  : 
; 634  : 	// If we got here, we assume we're cut off.
; 635  : 	// What we do is sit tight and call for help.
; 636  : 	// However, if our morale breaks, we'll surrender
; 637  : 	if (Broken() || (IsBattalion() && !MoraleCheck(4,0)))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	jne	SHORT $LN1@CheckForSu
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN2@CheckForSu
	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoraleCheck@UnitClass@@QAEHHH@Z	; UnitClass::MoraleCheck
	test	eax, eax
	jne	SHORT $LN2@CheckForSu
$LN1@CheckForSu:

; 638  : 	{
; 639  : 		KillUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit

; 640  : 		return 0;			// Zero is we surrendered

	xor	eax, eax
	jmp	SHORT $LN3@CheckForSu
$LN2@CheckForSu:

; 641  : 	}
; 642  : 	// Otherwise, hang out until we're rescued
; 643  : 	GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 644  : 	SetUnitDestination(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 645  : 	SetTempDest(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest

; 646  : 	// KCK TODO: Request an air mission here with proper context
; 647  : 	return 1;

	mov	eax, 1
$LN3@CheckForSu:

; 648  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForSurrender@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::CheckForSurrender
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ PROC ; GroundUnitClass::GetUnitObjectiveID, COMDAT
; _this$ = ecx

; 148  : 	VU_ID GetUnitObjectiveID (void)					{ return aobj; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [eax+284]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ ENDP ; GroundUnitClass::GetUnitObjectiveID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ PROC ; GroundUnitClass::GetUnitSecondaryObjID, COMDAT
; _this$ = ecx

; 147  : 	VU_ID GetUnitSecondaryObjID (void)				{ return sobj; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	edx, DWORD PTR [eax+276]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ENDP ; GroundUnitClass::GetUnitSecondaryObjID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ PROC ; GroundUnitClass::GetUnitPrimaryObjID, COMDAT
; _this$ = ecx

; 146  : 	VU_ID GetUnitPrimaryObjID (void)				{ return pobj; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	edx, DWORD PTR [eax+268]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ENDP ; GroundUnitClass::GetUnitPrimaryObjID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ PROC ; GroundUnitClass::GetUnitObjective, COMDAT
; _this$ = ecx

; 145  : 	Objective GetUnitObjective (void)				{ return (Objective)vuDatabase->Find(aobj); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	push	ecx
	mov	edx, DWORD PTR [eax+280]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; GroundUnitClass::GetUnitObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ PROC ; GroundUnitClass::GetUnitSecondaryObj, COMDAT
; _this$ = ecx

; 144  : 	Objective GetUnitSecondaryObj (void)			{ return (Objective)vuDatabase->Find(sobj); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	mov	edx, DWORD PTR [eax+272]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; GroundUnitClass::GetUnitSecondaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ PROC ; GroundUnitClass::GetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 143  : 	Objective GetUnitPrimaryObj (void)				{ return (Objective)vuDatabase->Find(pobj); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	mov	edx, DWORD PTR [eax+264]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; GroundUnitClass::GetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitDivision@GroundUnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitDivision@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::GetUnitDivision, COMDAT
; _this$ = ecx

; 142  : 	virtual int GetUnitDivision (void)				{ return (int)division; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+262]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitDivision@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::GetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitOrders@GroundUnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitOrders@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::GetUnitOrders, COMDAT
; _this$ = ecx

; 141  : 	virtual int GetUnitOrders (void)				{ return (int)orders; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+260]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitOrders@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::GetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z PROC	; GroundUnitClass::SetUnitObjective, COMDAT
; _this$ = ecx

; 140  : 	void SetUnitObjective (VU_ID id)				{ aobj = id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+280], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+284], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z ENDP	; GroundUnitClass::SetUnitObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z PROC ; GroundUnitClass::SetUnitSecondaryObj, COMDAT
; _this$ = ecx

; 139  : 	void SetUnitSecondaryObj (VU_ID id)				{ sobj = id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+272], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+276], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ENDP ; GroundUnitClass::SetUnitSecondaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z PROC	; GroundUnitClass::SetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 138  : 	void SetUnitPrimaryObj (VU_ID id)				{ pobj = id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+264], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+268], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ENDP	; GroundUnitClass::SetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitDivision@GroundUnitClass@@UAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_d$ = 8							; size = 2
?SetUnitDivision@GroundUnitClass@@UAEXF@Z PROC		; GroundUnitClass::SetUnitDivision, COMDAT
; _this$ = ecx

; 137  : 	virtual void SetUnitDivision (short d)			{ division = d; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _d$[ebp]
	mov	WORD PTR [eax+262], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitDivision@GroundUnitClass@@UAEXF@Z ENDP		; GroundUnitClass::SetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitOrders@GroundUnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_o$ = 8							; size = 1
?SetUnitOrders@GroundUnitClass@@UAEXE@Z PROC		; GroundUnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 136  : 	virtual void SetUnitOrders (uchar o)			{ orders = o; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _o$[ebp]
	mov	BYTE PTR [eax+260], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitOrders@GroundUnitClass@@UAEXE@Z ENDP		; GroundUnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T1 = -44						; size = 8
$T2 = -36						; size = 8
_react$ = -28						; size = 4
tv214 = -24						; size = 4
tv154 = -20						; size = 4
tv128 = -16						; size = 4
_det$ = -12						; size = 4
_detTmp$ = -8						; size = 4
_this$ = -4						; size = 4
_e$ = 8							; size = 4
_d$ = 12						; size = 4
_combat$ = 16						; size = 4
_spot$ = 20						; size = 4
_capture$ = 24						; size = 4
_nomove$ = 28						; size = 4
_estr$ = 32						; size = 4
?DetectVs@GroundUnitClass@@QAEHPAVCampBaseClass@@PAMPAH2222@Z PROC ; GroundUnitClass::DetectVs
; _this$ = ecx

; 543  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 544  : 	int		react,det;
; 545  : 
; 546  : 	det = Detected(this,e,d);

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z ; Detected
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _det$[ebp], eax

; 547  : 
; 548  : 	int detTmp = det;

	mov	eax, DWORD PTR _det$[ebp]
	mov	DWORD PTR _detTmp$[ebp], eax

; 549  : 
; 550  : 	// Check type of entity before GCI is used
; 551  : 	if (CheckValidType(this, e))

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@DetectVs

; 552  : 		detTmp |= e->GetSpotted(GetTeam()) ? ENEMY_DETECTED : 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSpotted@CampBaseClass@@QAEHE@Z	; CampBaseClass::GetSpotted
	test	eax, eax
	je	SHORT $LN17@DetectVs
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN18@DetectVs
$LN17@DetectVs:
	mov	DWORD PTR tv128[ebp], 0
$LN18@DetectVs:
	mov	edx, DWORD PTR _detTmp$[ebp]
	or	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR _detTmp$[ebp], edx
$LN14@DetectVs:

; 553  : 
; 554  : 	// Check type of entity before GCI is used
; 555  : 	if (CheckValidType(e, this))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@DetectVs

; 556  : 		detTmp |= GetSpotted(e->GetTeam()) ? FRIENDLY_DETECTED : 0;

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSpotted@CampBaseClass@@QAEHE@Z	; CampBaseClass::GetSpotted
	test	eax, eax
	je	SHORT $LN19@DetectVs
	mov	DWORD PTR tv154[ebp], 4
	jmp	SHORT $LN20@DetectVs
$LN19@DetectVs:
	mov	DWORD PTR tv154[ebp], 0
$LN20@DetectVs:
	mov	ecx, DWORD PTR _detTmp$[ebp]
	or	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR _detTmp$[ebp], ecx
$LN13@DetectVs:

; 557  : 
; 558  : 	if (!(detTmp & REACTION_MASK))

	mov	edx, DWORD PTR _detTmp$[ebp]
	and	edx, 17					; 00000011H
	jne	SHORT $LN12@DetectVs

; 559  : 		return 0;

	xor	eax, eax
	jmp	$LN15@DetectVs
$LN12@DetectVs:

; 560  : 
; 561  : 	react = Reaction(e,detTmp,*d);

	mov	eax, DWORD PTR _d$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _detTmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+484]
	call	eax
	mov	DWORD PTR _react$[ebp], eax

; 562  : 
; 563  : 	// We'll spot our enemy if we're not broken
; 564  : 	if (det & ENEMY_DETECTED) {

	mov	ecx, DWORD PTR _det$[ebp]
	and	ecx, 1
	je	$LN10@DetectVs

; 565  : 		if (IsAggregate() && CheckValidType(this, e))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	$LN10@DetectVs
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@DetectVs

; 566  : 			e->SetSpotted(GetTeam(),TheCampaign.CurrentTime, (!e->IsFlight() || CanItIdentify(this, e, *d, e->GetMovementType()))); // 2002-02-11 MODIFIED BY S.G. Say 'identified if it's not a flight or it has the hability to identify

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN21@DetectVs
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?CanItIdentify@@YAHPAVCampBaseClass@@0MH@Z ; CanItIdentify
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN21@DetectVs
	mov	DWORD PTR tv214[ebp], 0
	jmp	SHORT $LN22@DetectVs
$LN21@DetectVs:
	mov	DWORD PTR tv214[ebp], 1
$LN22@DetectVs:
	mov	ecx, DWORD PTR tv214[ebp]
	push	ecx
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted
$LN10@DetectVs:

; 567  : 	}
; 568  : 	if (det & ENEMY_IN_RANGE && react)

	mov	edx, DWORD PTR _det$[ebp]
	and	edx, 2
	je	SHORT $LN9@DetectVs
	cmp	DWORD PTR _react$[ebp], 0
	je	SHORT $LN9@DetectVs

; 569  : 		*combat = 1;

	mov	eax, DWORD PTR _combat$[ebp]
	mov	DWORD PTR [eax], 1
$LN9@DetectVs:

; 570  : 	if (det & FRIENDLY_DETECTED) {

	mov	ecx, DWORD PTR _det$[ebp]
	and	ecx, 4
	je	SHORT $LN7@DetectVs

; 571  : 		// Spotting will be set only if our enemy is aggregated or if he's an AWAC. SensorFusion or GroundClass::Exec will hanlde deaggregated vehicles.
; 572  : 		if ((e->IsAggregate() && CheckValidType(e, this)) || (e->IsFlight() && e->GetSType() == STYPE_UNIT_AWACS)) {

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN5@DetectVs
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@DetectVs
$LN5@DetectVs:
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN7@DetectVs
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 5
	jne	SHORT $LN7@DetectVs
$LN6@DetectVs:

; 573  : 			SetSpotted(e->GetTeam(),TheCampaign.CurrentTime, 1); // 2002-02-11 Modified by S.G. Ground units are always identified (doesn't change a thing)

	push	1
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted

; 574  : 			*spot = 1;

	mov	edx, DWORD PTR _spot$[ebp]
	mov	DWORD PTR [edx], 1
$LN7@DetectVs:

; 575  : 		}
; 576  : 	}
; 577  : 	if (det & FRIENDLY_IN_RANGE && ((Unit)e)->GetTargetID() == Id())

	mov	eax, DWORD PTR _det$[ebp]
	and	eax, 8
	je	SHORT $LN4@DetectVs
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetTargetID
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@DetectVs

; 578  : 		*estr += ((Unit)e)->GetTotalVehicles();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	ecx, DWORD PTR _estr$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _estr$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@DetectVs:

; 579  : 	if (det & ENEMY_SAME_HEX)

	mov	eax, DWORD PTR _det$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN1@DetectVs

; 580  : 	{
; 581  : 		if (e->IsBattalion())

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN2@DetectVs

; 582  : 			*nomove = 1; // retval = -1;

	mov	ecx, DWORD PTR _nomove$[ebp]
	mov	DWORD PTR [ecx], 1
$LN2@DetectVs:

; 583  : 		if (e->IsObjective())

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	je	SHORT $LN1@DetectVs

; 584  : 			*capture = 1;

	mov	eax, DWORD PTR _capture$[ebp]
	mov	DWORD PTR [eax], 1
$LN1@DetectVs:

; 585  : 	}
; 586  : 
; 587  : 	return react;

	mov	eax, DWORD PTR _react$[ebp]
$LN15@DetectVs:

; 588  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DetectVs@GroundUnitClass@@QAEHPAVCampBaseClass@@PAMPAH2222@Z ENDP ; GroundUnitClass::DetectVs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_react$ = -28						; size = 4
tv160 = -24						; size = 4
tv134 = -20						; size = 4
_det$ = -16						; size = 4
_detTmp$ = -12						; size = 4
_this$ = -8						; size = 4
_e$ = -4						; size = 4
_ac$ = 8						; size = 4
_d$ = 12						; size = 4
_combat$ = 16						; size = 4
_spot$ = 20						; size = 4
_capture$ = 24						; size = 4
_nomove$ = 28						; size = 4
_estr$ = 32						; size = 4
?DetectVs@GroundUnitClass@@QAEHPAVAircraftClass@@PAMPAH2222@Z PROC ; GroundUnitClass::DetectVs
; _this$ = ecx

; 473  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 474  : 	int			react,det = Detected(this,ac,d);

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z ; Detected
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _det$[ebp], eax

; 475  : 	CampEntity	e;
; 476  : 
; 477  : 	e = ac->GetCampaignObject();

	mov	ecx, DWORD PTR _ac$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _e$[ebp], eax

; 478  : 
; 479  : 	// 2001-03-22 ADDED BY S.G. DETECTION DOESN'T INCLUDED SPOTTED, ONLY THAT THIS ENTITY DETECTED THE OTHER BY ITSELF.
; 480  : 	int detTmp = det;

	mov	eax, DWORD PTR _det$[ebp]
	mov	DWORD PTR _detTmp$[ebp], eax

; 481  : 
; 482  : 	// Check type of entity before GCI is used
; 483  : 	if (CheckValidType(this, e))

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@DetectVs

; 484  : 		detTmp |= e->GetSpotted(GetTeam()) ? ENEMY_DETECTED : 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSpotted@CampBaseClass@@QAEHE@Z	; CampBaseClass::GetSpotted
	test	eax, eax
	je	SHORT $LN11@DetectVs
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN12@DetectVs
$LN11@DetectVs:
	mov	DWORD PTR tv134[ebp], 0
$LN12@DetectVs:
	mov	edx, DWORD PTR _detTmp$[ebp]
	or	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _detTmp$[ebp], edx
$LN8@DetectVs:

; 485  : 
; 486  : 	// Check type of entity before GCI is used
; 487  : 	if (CheckValidType(e, this))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@DetectVs

; 488  : 		detTmp |= GetSpotted(e->GetTeam()) ? FRIENDLY_DETECTED : 0;

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSpotted@CampBaseClass@@QAEHE@Z	; CampBaseClass::GetSpotted
	test	eax, eax
	je	SHORT $LN13@DetectVs
	mov	DWORD PTR tv160[ebp], 4
	jmp	SHORT $LN14@DetectVs
$LN13@DetectVs:
	mov	DWORD PTR tv160[ebp], 0
$LN14@DetectVs:
	mov	ecx, DWORD PTR _detTmp$[ebp]
	or	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR _detTmp$[ebp], ecx
$LN7@DetectVs:

; 489  : 
; 490  : 	if (!(detTmp & REACTION_MASK))

	mov	edx, DWORD PTR _detTmp$[ebp]
	and	edx, 17					; 00000011H
	jne	SHORT $LN6@DetectVs

; 491  : 		return 0;

	xor	eax, eax
	jmp	$LN9@DetectVs
$LN6@DetectVs:

; 492  : 
; 493  : 	react = Reaction(e,detTmp,*d);

	mov	eax, DWORD PTR _d$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _detTmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+484]
	call	eax
	mov	DWORD PTR _react$[ebp], eax

; 494  : 
; 495  : 	if (det & ENEMY_IN_RANGE && react)

	mov	ecx, DWORD PTR _det$[ebp]
	and	ecx, 2
	je	SHORT $LN5@DetectVs
	cmp	DWORD PTR _react$[ebp], 0
	je	SHORT $LN5@DetectVs

; 496  : 		*combat = 1;

	mov	edx, DWORD PTR _combat$[ebp]
	mov	DWORD PTR [edx], 1
$LN5@DetectVs:

; 497  : 
; 498  : 	// Spotting will be set only if our enemy is aggregated or if he's an AWAC. SensorFusion or GroundClass::Exec will hanlde deaggregated vehicles.
; 499  : 	// I can't let SensorFusion handle the spotting for AWAC because this will put a too big toll on the CPU
; 500  : 	// e has to be a flight since it is derived from an aircraft class so less checks needs to be done here then against flights below
; 501  : 	if (det & FRIENDLY_DETECTED) {

	mov	eax, DWORD PTR _det$[ebp]
	and	eax, 4
	je	$LN3@DetectVs

; 502  : 		// Spotting will be set only if our enemy is aggregated or if he's an AWAC. SensorFusion or GroundClass::Exec will hanlde deaggregated vehicles.
; 503  : 		if ((e->IsAggregate() && CheckValidType(e, this)) || (e->IsFlight() && e->GetSType() == STYPE_UNIT_AWACS)) {

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN1@DetectVs
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?CheckValidType@@YAHPAVCampBaseClass@@0@Z ; CheckValidType
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@DetectVs
$LN1@DetectVs:
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN3@DetectVs
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 5
	jne	SHORT $LN3@DetectVs
$LN2@DetectVs:

; 504  : 			SetSpotted(e->GetTeam(),TheCampaign.CurrentTime, CanItIdentify(this, e, *d, e->GetMovementType())); // 2002-02-11 MODIFIED BY S.G. Added 'CanItIdentify' which query if the target can be identified

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	push	eax
	mov	eax, DWORD PTR _d$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?CanItIdentify@@YAHPAVCampBaseClass@@0MH@Z ; CanItIdentify
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted

; 505  : 			*spot = 1;

	mov	edx, DWORD PTR _spot$[ebp]
	mov	DWORD PTR [edx], 1
$LN3@DetectVs:

; 506  : 		}
; 507  : 	}
; 508  : 	return react;

	mov	eax, DWORD PTR _react$[ebp]
$LN9@DetectVs:

; 509  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DetectVs@GroundUnitClass@@QAEHPAVAircraftClass@@PAMPAH2222@Z ENDP ; GroundUnitClass::DetectVs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetAObj@GroundUnitClass@@QAEXVVU_ID@@@Z PROC		; GroundUnitClass::SetAObj
; _this$ = ecx

; 2114 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2115 : 	aobj = id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+280], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+284], edx

; 2116 : 
; 2117 : 	MakeGndUnitDirty (DIRTY_AOBJ, DDP[113].priority);

	mov	eax, 4
	imul	eax, 113				; 00000071H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ; GroundUnitClass::MakeGndUnitDirty

; 2118 : 	//	MakeGndUnitDirty (DIRTY_AOBJ, SEND_EVENTUALLY);
; 2119 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetAObj@GroundUnitClass@@QAEXVVU_ID@@@Z ENDP		; GroundUnitClass::SetAObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetSObj@GroundUnitClass@@QAEXVVU_ID@@@Z PROC		; GroundUnitClass::SetSObj
; _this$ = ecx

; 2126 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2127 : 	sobj = id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+272], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+276], edx

; 2128 : 
; 2129 : 	MakeGndUnitDirty (DIRTY_SOBJ, DDP[114].priority);

	mov	eax, 4
	imul	eax, 114				; 00000072H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ; GroundUnitClass::MakeGndUnitDirty

; 2130 : 	//	MakeGndUnitDirty (DIRTY_SOBJ, SEND_EVENTUALLY);
; 2131 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSObj@GroundUnitClass@@QAEXVVU_ID@@@Z ENDP		; GroundUnitClass::SetSObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetPObj@GroundUnitClass@@QAEXVVU_ID@@@Z PROC		; GroundUnitClass::SetPObj
; _this$ = ecx

; 2138 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2139 : 	pobj = id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+264], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+268], edx

; 2140 : 
; 2141 : 	MakeGndUnitDirty (DIRTY_POBJ, DDP[115].priority);

	mov	eax, 4
	imul	eax, 115				; 00000073H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ; GroundUnitClass::MakeGndUnitDirty

; 2142 : 	//	MakeGndUnitDirty (DIRTY_POBJ, SEND_EVENTUALLY);
; 2143 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetPObj@GroundUnitClass@@QAEXVVU_ID@@@Z ENDP		; GroundUnitClass::SetPObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_d$ = 8							; size = 2
?SetDivision@GroundUnitClass@@QAEXF@Z PROC		; GroundUnitClass::SetDivision
; _this$ = ecx

; 2102 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2103 : 	division = d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _d$[ebp]
	mov	WORD PTR [eax+262], cx

; 2104 : 
; 2105 : 	MakeGndUnitDirty (DIRTY_DIVISION, DDP[112].priority);

	mov	edx, 4
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ; GroundUnitClass::MakeGndUnitDirty

; 2106 : 	//	MakeGndUnitDirty (DIRTY_DIVISION, SEND_EVENTUALLY);
; 2107 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDivision@GroundUnitClass@@QAEXF@Z ENDP		; GroundUnitClass::SetDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_o$ = 8							; size = 1
?SetOrders@GroundUnitClass@@QAEXE@Z PROC		; GroundUnitClass::SetOrders
; _this$ = ecx

; 2090 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2091 : 	orders = o;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _o$[ebp]
	mov	BYTE PTR [eax+260], cl

; 2092 : 
; 2093 : 	MakeGndUnitDirty (DIRTY_ORDERS, DDP[111].priority);

	mov	edx, 4
	imul	edx, 111				; 0000006fH
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeGndUnitDirty@GroundUnitClass@@QAEXW4Dirty_Ground_Unit@@W4Dirtyness@@@Z ; GroundUnitClass::MakeGndUnitDirty

; 2094 : 	//	MakeGndUnitDirty (DIRTY_ORDERS, SEND_EVENTUALLY);
; 2095 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetOrders@GroundUnitClass@@QAEXE@Z ENDP		; GroundUnitClass::SetOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetKias@GroundUnitClass@@UBEMXZ
_TEXT	SEGMENT
tv82 = -12						; size = 4
tv80 = -8						; size = 4
_this$ = -4						; size = 4
?GetKias@GroundUnitClass@@UBEMXZ PROC			; GroundUnitClass::GetKias, COMDAT
; _this$ = ecx

; 121  :     virtual float GetKias() const					{ return GetVt()*FTPSEC_TO_KNOTS; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv80[ebp]
	movss	xmm0, DWORD PTR tv80[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	movss	DWORD PTR tv82[ebp], xmm0
	fld	DWORD PTR tv82[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKias@GroundUnitClass@@UBEMXZ ENDP			; GroundUnitClass::GetKias
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetVt@GroundUnitClass@@UBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
?GetVt@GroundUnitClass@@UBEMXZ PROC			; GroundUnitClass::GetVt, COMDAT
; _this$ = ecx

; 120  :     virtual float GetVt() const						{ return (Moving() ? 40.0F : 0.0F);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN3@GetVt
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR tv71[ebp], xmm0
	jmp	SHORT $LN4@GetVt
$LN3@GetVt:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv71[ebp], xmm0
$LN4@GetVt:
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVt@GroundUnitClass@@UBEMXZ ENDP			; GroundUnitClass::GetVt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?OnGround@GroundUnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnGround@GroundUnitClass@@UAEHXZ PROC			; GroundUnitClass::OnGround, COMDAT
; _this$ = ecx

; 119  :     virtual int OnGround (void)						{ return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGround@GroundUnitClass@@UAEHXZ ENDP			; GroundUnitClass::OnGround
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?MaxUpdateTime@GroundUnitClass@@UBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxUpdateTime@GroundUnitClass@@UBEKXZ PROC		; GroundUnitClass::MaxUpdateTime, COMDAT
; _this$ = ecx

; 115  : 	virtual CampaignTime MaxUpdateTime() const		{ return GROUND_UPDATE_CHECK_INTERVAL*CampaignSeconds; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR ?GROUND_UPDATE_CHECK_INTERVAL@@3FA ; GROUND_UPDATE_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxUpdateTime@GroundUnitClass@@UBEKXZ ENDP		; GroundUnitClass::MaxUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_detit$ = -188						; size = 60
_pass$ = -128						; size = 4
_cit$2 = -124						; size = 12
$T3 = -112						; size = 4
$T4 = -108						; size = 4
_capture$ = -104					; size = 4
$T5 = -100						; size = 4
_spot$ = -96						; size = 4
_react_distance$ = -92					; size = 4
_best_air_react$ = -88					; size = 4
_estr$ = -84						; size = 4
_brsq$6 = -80						; size = 4
_nomove$ = -76						; size = 4
_retval$ = -72						; size = 4
_rsq$7 = -68						; size = 4
_search_dist$ = -64					; size = 4
_combat$ = -60						; size = 4
_best_reaction$ = -56					; size = 4
_react_against$ = -52					; size = 4
_d$ = -48						; size = 4
_air_react_against$ = -44				; size = 4
_react$ = -40						; size = 4
_air_react_distance$ = -36				; size = 4
_fe$8 = -32						; size = 4
_artTarget$ = -28					; size = 4
_who$ = -21						; size = 1
_e$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ChooseTarget@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::ChooseTarget
; _this$ = ecx

; 278  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChooseTarget@GroundUnitClass@@UAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 	FalconEntity		*artTarget,*react_against=NULL,*air_react_against=NULL;

	mov	DWORD PTR _react_against$[ebp], 0
	mov	DWORD PTR _air_react_against$[ebp], 0

; 280  : 	CampEntity			e;
; 281  : 	float				d,react_distance,air_react_distance;
; 282  : 	int					react,best_reaction=1,best_air_react=1,combat,retval=0,pass=0,spot=0,estr=0,capture=0,nomove=0;

	mov	DWORD PTR _best_reaction$[ebp], 1
	mov	DWORD PTR _best_air_react$[ebp], 1
	mov	DWORD PTR _retval$[ebp], 0
	mov	DWORD PTR _pass$[ebp], 0
	mov	DWORD PTR _spot$[ebp], 0
	mov	DWORD PTR _estr$[ebp], 0
	mov	DWORD PTR _capture$[ebp], 0
	mov	DWORD PTR _nomove$[ebp], 0

; 283  : 	int					search_dist;
; 284  : 	Team				who;
; 285  : 
; 286  : 	if (IsChecked())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsChecked@CampBaseClass@@QAEHXZ	; CampBaseClass::IsChecked
	test	eax, eax
	je	SHORT $LN24@ChooseTarg

; 287  : 		return Engaged();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	jmp	$LN25@ChooseTarg
$LN24@ChooseTarg:

; 288  : 
; 289  : 	who = GetTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _who$[ebp], al

; 290  : 	react_distance = air_react_distance = 9999.0F;

	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR _air_react_distance$[ebp], xmm0
	movss	xmm0, DWORD PTR _air_react_distance$[ebp]
	movss	DWORD PTR _react_distance$[ebp], xmm0

; 291  : 
; 292  : #ifdef DEBUG
; 293  : 	DWORD				timec = GetTickCount();
; 294  : #endif
; 295  : 
; 296  : 	// Special case for fire support
; 297  : 	if (Targeted())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Targeted@UnitClass@@QBEHXZ		; UnitClass::Targeted
	test	eax, eax
	je	SHORT $LN23@ChooseTarg

; 298  : 		artTarget = GetTarget();					// Save our target

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _artTarget$[ebp], eax

; 299  : 	else

	jmp	SHORT $LN22@ChooseTarg
$LN23@ChooseTarg:

; 300  : 		artTarget = NULL;

	mov	DWORD PTR _artTarget$[ebp], 0
$LN22@ChooseTarg:

; 301  : 
; 302  : 	SetEngaged(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 303  : 	SetCombat(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCombat@UnitClass@@QAEXH@Z		; UnitClass::SetCombat

; 304  : 	SetChecked();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::SetChecked

; 305  : 
; 306  : 	search_dist = GetDetectionRange(Air);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+416]
	call	eax
	mov	DWORD PTR _search_dist$[ebp], eax

; 307  : 	if (search_dist < MAX_GROUND_SEARCH)

	movsx	ecx, WORD PTR ?MAX_GROUND_SEARCH@@3FA	; MAX_GROUND_SEARCH
	cmp	DWORD PTR _search_dist$[ebp], ecx
	jge	SHORT $LN21@ChooseTarg

; 308  : 		search_dist = MAX_GROUND_SEARCH;

	movsx	edx, WORD PTR ?MAX_GROUND_SEARCH@@3FA	; MAX_GROUND_SEARCH
	mov	DWORD PTR _search_dist$[ebp], edx
$LN21@ChooseTarg:

; 309  : #ifdef VU_GRID_TREE_Y_MAJOR
; 310  : 	VuGridIterator detit(RealUnitProxList,YPos(),XPos(),(BIG_SCALAR)GridToSim(search_dist));

	movzx	eax, WORD PTR _search_dist$[ebp]
	push	eax
	call	?GridToSim@@YAMF@Z			; GridToSim
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	push	ecx
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 311  : #else
; 312  : 	VuGridIterator detit(RealUnitProxList,XPos(),YPos(),(BIG_SCALAR)GridToSim(search_dist));
; 313  : #endif
; 314  : 	//	CalculateSOJ(detit); 2002-02-19 REMOVED BY S.G. eFalcon 1.10 SOJ code removed
; 315  : 
; 316  : 	e = (CampEntity)detit.GetFirst();

	lea	ecx, DWORD PTR _detit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _e$[ebp], eax
$LN20@ChooseTarg:

; 317  : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN19@ChooseTarg

; 318  : 	{
; 319  : 		if (GetRoE(who,e->GetTeam(),ROE_GROUND_FIRE) == ROE_ALLOWED)

	push	1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	push	ecx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN15@ChooseTarg

; 320  : 		{
; 321  : 			combat = 0;

	mov	DWORD PTR _combat$[ebp], 0

; 322  : 			react = DetectVs(e,&d,&combat,&spot,&capture,&nomove,&estr);

	lea	edx, DWORD PTR _estr$[ebp]
	push	edx
	lea	eax, DWORD PTR _nomove$[ebp]
	push	eax
	lea	ecx, DWORD PTR _capture$[ebp]
	push	ecx
	lea	edx, DWORD PTR _spot$[ebp]
	push	edx
	lea	eax, DWORD PTR _combat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetectVs@GroundUnitClass@@QAEHPAVCampBaseClass@@PAMPAH2222@Z ; GroundUnitClass::DetectVs
	mov	DWORD PTR _react$[ebp], eax

; 323  : 			if (!e->IsFlight() && react >= best_reaction && d < react_distance)

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	jne	SHORT $LN17@ChooseTarg
	mov	ecx, DWORD PTR _react$[ebp]
	cmp	ecx, DWORD PTR _best_reaction$[ebp]
	jl	SHORT $LN17@ChooseTarg
	movss	xmm0, DWORD PTR _react_distance$[ebp]
	comiss	xmm0, DWORD PTR _d$[ebp]
	jbe	SHORT $LN17@ChooseTarg

; 324  : 			{
; 325  : 				// React vs a ground/Naval target
; 326  : 				best_reaction = react;

	mov	edx, DWORD PTR _react$[ebp]
	mov	DWORD PTR _best_reaction$[ebp], edx

; 327  : 				react_distance = d;

	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _react_distance$[ebp], xmm0

; 328  : 				react_against = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _react_against$[ebp], eax

; 329  : 				SetEngaged(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 330  : 				SetCombat(combat);

	mov	ecx, DWORD PTR _combat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCombat@UnitClass@@QAEXH@Z		; UnitClass::SetCombat
	jmp	$LN15@ChooseTarg
$LN17@ChooseTarg:

; 331  : 			}
; 332  : 			else if (e->IsFlight() && react >= best_air_react && d < air_react_distance)

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	$LN15@ChooseTarg
	mov	eax, DWORD PTR _react$[ebp]
	cmp	eax, DWORD PTR _best_air_react$[ebp]
	jl	$LN15@ChooseTarg
	movss	xmm0, DWORD PTR _air_react_distance$[ebp]
	comiss	xmm0, DWORD PTR _d$[ebp]
	jbe	$LN15@ChooseTarg

; 333  : 			{
; 334  : 				// React vs an air target -
; 335  : 				best_air_react = react;

	mov	ecx, DWORD PTR _react$[ebp]
	mov	DWORD PTR _best_air_react$[ebp], ecx

; 336  : 				air_react_distance = d;

	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _air_react_distance$[ebp], xmm0

; 337  : 				air_react_against = e;

	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR _air_react_against$[ebp], edx

; 338  : 				if (!e->IsAggregate())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	$LN14@ChooseTarg

; 339  : 				{
; 340  : 					// Pick a specific aircraft in the flight if it's deaggregated
; 341  : 					CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 342  : 					if (e->GetComponents())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	$LN13@ChooseTarg

; 343  : 					{
; 344  : 						VuListIterator	cit(e->GetComponents());

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 345  : 						FalconEntity	*fe;
; 346  : 						float			rsq,brsq=FLT_MAX;

	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR _brsq$6[ebp], xmm0

; 347  : 
; 348  : 						fe = (FalconEntity *)cit.GetFirst();

	lea	ecx, DWORD PTR _cit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _fe$8[ebp], eax
$LN12@ChooseTarg:

; 349  : 						while (fe)

	cmp	DWORD PTR _fe$8[ebp], 0
	je	SHORT $LN11@ChooseTarg

; 350  : 						{
; 351  : 							rsq = DistSqu(XPos(),YPos(),fe->XPos(),fe->YPos());

	mov	ecx, DWORD PTR _fe$8[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _fe$8[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?DistSqu@@YAMMMMM@Z			; DistSqu
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _rsq$7[ebp]

; 352  : 							if (rsq < brsq)

	movss	xmm0, DWORD PTR _brsq$6[ebp]
	comiss	xmm0, DWORD PTR _rsq$7[ebp]
	jbe	SHORT $LN10@ChooseTarg

; 353  : 							{
; 354  : 								air_react_against = fe;

	mov	eax, DWORD PTR _fe$8[ebp]
	mov	DWORD PTR _air_react_against$[ebp], eax

; 355  : 								air_react_distance = (float)sqrt(rsq);

	push	ecx
	movss	xmm0, DWORD PTR _rsq$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _air_react_distance$[ebp]

; 356  : 								brsq = rsq;

	movss	xmm0, DWORD PTR _rsq$7[ebp]
	movss	DWORD PTR _brsq$6[ebp], xmm0
$LN10@ChooseTarg:

; 357  : 							}
; 358  : 							fe = (FalconEntity *)cit.GetNext();

	lea	ecx, DWORD PTR _cit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _fe$8[ebp], eax

; 359  : 						}

	jmp	SHORT $LN12@ChooseTarg
$LN11@ChooseTarg:

; 360  : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN13@ChooseTarg:

; 361  : 					CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection
$LN14@ChooseTarg:

; 362  : 				}
; 363  : 				// Make sure our radar is on (if we have one)
; 364  : 				if (!IsEmitting() && class_data->RadarVehicle < 255 && GetNumVehicles(class_data->RadarVehicle)) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	jne	$LN8@ChooseTarg
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	movzx	eax, BYTE PTR [edx+328]
	cmp	eax, 255				; 000000ffH
	jge	$LN8@ChooseTarg
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	movzx	eax, BYTE PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	je	$LN8@ChooseTarg

; 365  : 					SetEmitting(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEmitting@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetEmitting

; 366  : 
; 367  : 					// 2002-03-22 ADDED BY S.G. Since someone else was searching for us (that's why we were off), make sure the next radar step will be FEC_RADAR_AQUIRE
; 368  : 					if (GetRadarMode() < FEC_RADAR_AQUIRE && GetRadarMode() != FEC_RADAR_SEARCH_100) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 5
	jge	SHORT $LN8@ChooseTarg
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 1
	je	SHORT $LN8@ChooseTarg

; 369  : 						SetStepSearchMode(FEC_RADAR_AQUIRE);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+308]
	call	eax

; 370  : 						SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 371  : 						SetAQUIREtimer(SimLibElapsedTime);

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+300]
	call	edx

; 372  : 						SetSEARCHtimer(SimLibElapsedTime);

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	call	eax
$LN8@ChooseTarg:

; 373  : 					}
; 374  : 				}
; 375  : 				SetEngaged(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 376  : 				SetCombat(combat);

	mov	ecx, DWORD PTR _combat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCombat@UnitClass@@QAEXH@Z		; UnitClass::SetCombat
$LN15@ChooseTarg:

; 377  : 			}
; 378  : 		}
; 379  : 		e = (CampEntity)detit.GetNext();

	lea	ecx, DWORD PTR _detit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax

; 380  : 	}

	jmp	$LN20@ChooseTarg
$LN19@ChooseTarg:

; 381  : 	SetOdds ((GetTotalVehicles() * 10) / (estr+10));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _estr$[ebp]
	add	ecx, 10					; 0000000aH
	cdq
	idiv	ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOdds@UnitClass@@QAEXF@Z		; UnitClass::SetOdds

; 382  : 
; 383  : 	/*	This is outdated by the check vs deaggregated flights above
; 384  : 	// Check vs all players if we're an airdefense thingy, capible of at least some range
; 385  : 	if (GetAproxWeaponRange(LowAir))
; 386  : 	{
; 387  : 	FalconSessionEntity		*session;
; 388  : 	VuSessionsIterator		sit(FalconLocalGame);
; 389  : 	session = (FalconSessionEntity*) sit.GetFirst();
; 390  : 	while (session)
; 391  : 	{
; 392  : 	AircraftClass	*player = (AircraftClass*) session->GetPlayerEntity();
; 393  : 	if (player && GetRoE(who,session->GetTeam(),ROE_AIR_FIRE) == ROE_ALLOWED && player->IsAirplane())
; 394  : 	{
; 395  : 	combat = 0;
; 396  : 	react = DetectVs(player,&d,&combat,&spot,&capture,&nomove,&estr);
; 397  : 	if (react >= best_air_react && d < air_react_distance)
; 398  : 	{
; 399  : 	best_air_react = react;
; 400  : 	air_react_distance = d;
; 401  : 	air_react_against = player;
; 402  : 	SetEngaged(1);
; 403  : 	SetCombat(combat);
; 404  : 	}
; 405  : 	}
; 406  : 	session = (FalconSessionEntity*) sit.GetNext();
; 407  : 	}
; 408  : 	}
; 409  : 	 */
; 410  : 
; 411  : 	if (!Parent() && best_reaction > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	jne	SHORT $LN7@ChooseTarg
	cmp	DWORD PTR _best_reaction$[ebp], 1
	jle	SHORT $LN7@ChooseTarg

; 412  : 		EngageParent(this,react_against);

	mov	edx, DWORD PTR _react_against$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?EngageParent@@YAHPAVUnitClass@@PAVFalconEntity@@@Z ; EngageParent
	add	esp, 8
$LN7@ChooseTarg:

; 413  : 
; 414  : #ifdef DEBUG
; 415  : 	gBattalionDetects++;
; 416  : 	gAverageBattalionDetectionTime = (gAverageBattalionDetectionTime*(gBattalionDetects-1) + GetTickCount() - timec) / gBattalionDetects;
; 417  : #endif
; 418  : 
; 419  : 	if (air_react_against)

	cmp	DWORD PTR _air_react_against$[ebp], 0
	je	SHORT $LN6@ChooseTarg

; 420  : 	{
; 421  : 		// KCK: Yet another reason to make this whole function Battalion ONLY
; 422  : 		ShiAssert( IsBattalion() );
; 423  : 		((Battalion)this)->SetAirTarget(air_react_against);

	mov	ecx, DWORD PTR _air_react_against$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1024]
	call	edx

; 424  : 		retval = 1;

	mov	DWORD PTR _retval$[ebp], 1
$LN6@ChooseTarg:

; 425  : 	}
; 426  : 	if (react_against)

	cmp	DWORD PTR _react_against$[ebp], 0
	je	SHORT $LN5@ChooseTarg

; 427  : 	{
; 428  : 		SetTarget(react_against);

	mov	eax, DWORD PTR _react_against$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ; UnitClass::SetTarget

; 429  : 		SetTargeted(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargeted@UnitClass@@QAEXH@Z		; UnitClass::SetTargeted

; 430  : 		retval = 1;

	mov	DWORD PTR _retval$[ebp], 1
	jmp	SHORT $LN3@ChooseTarg
$LN5@ChooseTarg:

; 431  : 	}
; 432  : 	else if (artTarget && (!artTarget->IsUnit() || ((Unit)artTarget)->Engaged()) && orders == GORD_SUPPORT)

	cmp	DWORD PTR _artTarget$[ebp], 0
	je	SHORT $LN3@ChooseTarg
	mov	ecx, DWORD PTR _artTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _artTarget$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN2@ChooseTarg
	mov	ecx, DWORD PTR _artTarget$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN3@ChooseTarg
$LN2@ChooseTarg:
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+260]
	cmp	edx, 7
	jne	SHORT $LN3@ChooseTarg

; 433  : 	{
; 434  : 		// Keep blowing away this target until the target gets out of range, disengages, or we get new orders
; 435  : 		// (Target will get reset after a null DoCombat result)
; 436  : 		SetTarget(artTarget);

	mov	eax, DWORD PTR _artTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ; UnitClass::SetTarget

; 437  : 		SetTargeted(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargeted@UnitClass@@QAEXH@Z		; UnitClass::SetTargeted

; 438  : 		SetEngaged(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 439  : 		SetCombat(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCombat@UnitClass@@QAEXH@Z		; UnitClass::SetCombat

; 440  : 		return -1;			// We want to sit here and shoot until we can't any longer

	mov	DWORD PTR $T4[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN25@ChooseTarg
$LN3@ChooseTarg:

; 441  : 	}
; 442  : 	if (nomove)

	cmp	DWORD PTR _nomove$[ebp], 0
	je	SHORT $LN1@ChooseTarg

; 443  : 		return -1;

	mov	DWORD PTR $T3[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN25@ChooseTarg
$LN1@ChooseTarg:

; 444  : 	return retval;

	mov	ecx, DWORD PTR _retval$[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T5[ebp]
$LN25@ChooseTarg:

; 445  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ChooseTarget@GroundUnitClass@@UAEHXZ$0:
	lea	ecx, DWORD PTR _detit$[ebp]
	jmp	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
__unwindfunclet$?ChooseTarget@GroundUnitClass@@UAEHXZ$1:
	lea	ecx, DWORD PTR _cit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?ChooseTarget@GroundUnitClass@@UAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChooseTarget@GroundUnitClass@@UAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseTarget@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::ChooseTarget
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_detit$ = -132						; size = 60
_d$ = -72						; size = 4
$T2 = -68						; size = 4
$T3 = -64						; size = 4
_combat$ = -60						; size = 4
_spot$ = -56						; size = 4
_estr$ = -52						; size = 4
_parent$4 = -48						; size = 4
_capture$ = -44						; size = 4
_nomove$ = -40						; size = 4
_retval$ = -36						; size = 4
_o$ = -32						; size = 4
_this$ = -28						; size = 4
_x$ = -24						; size = 2
_y$ = -20						; size = 2
_who$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
?DetectOnMove@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::DetectOnMove
; _this$ = ecx

; 222  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DetectOnMove@GroundUnitClass@@UAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 223  : 	Objective			o;
; 224  : 	Team				who;
; 225  : 	float				d;
; 226  : 	int					combat=0,retval=0,spot=0,estr=0,capture,nomove=0;

	mov	DWORD PTR _combat$[ebp], 0
	mov	DWORD PTR _retval$[ebp], 0
	mov	DWORD PTR _spot$[ebp], 0
	mov	DWORD PTR _estr$[ebp], 0
	mov	DWORD PTR _nomove$[ebp], 0

; 227  : 	GridIndex			x,y;
; 228  : 
; 229  : 	// Check for collision vs enemy units
; 230  : 	retval = ChooseTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+524]
	call	eax
	mov	DWORD PTR _retval$[ebp], eax

; 231  : 	if (retval < 0)

	cmp	DWORD PTR _retval$[ebp], 0
	jge	SHORT $LN10@DetectOnMo

; 232  : 		return -1;

	or	eax, -1
	jmp	$LN11@DetectOnMo
$LN10@DetectOnMo:

; 233  : 
; 234  : 	// Check if our offensive has started yet
; 235  : 	if (retval && GetUnitCurrentRole() == GRO_ATTACK && TheCampaign.CurrentTime < TeamInfo[GetTeam()]->GetGroundAction()->actionTime)

	cmp	DWORD PTR _retval$[ebp], 0
	je	SHORT $LN9@DetectOnMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN9@DetectOnMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	edx, DWORD PTR [eax]
	jae	SHORT $LN9@DetectOnMo

; 236  : 		return -1;

	or	eax, -1
	jmp	$LN11@DetectOnMo
$LN9@DetectOnMo:

; 237  : 
; 238  : 	// Skip detection every third move until in enemy territory
; 239  : 	who = GetTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _who$[ebp], al

; 240  : 	GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 241  : 	if (!(GetUnitMoved()%3) && FriendlyTerritory(x,y,who))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitMoved@UnitClass@@QBEHXZ		; UnitClass::GetUnitMoved
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN8@DetectOnMo
	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?FriendlyTerritory@@YAHFFH@Z		; FriendlyTerritory
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@DetectOnMo

; 242  : 		return 0;

	xor	eax, eax
	jmp	$LN11@DetectOnMo
$LN8@DetectOnMo:

; 243  : 
; 244  : 	// Now check vs enemy objectives for detection purposes
; 245  : #ifdef VU_GRID_TREE_Y_MAJOR
; 246  : 	VuGridIterator	detit(ObjProxList,YPos(),XPos(),(BIG_SCALAR)GridToSim(MAX_GROUND_SEARCH));

	movzx	edx, WORD PTR ?MAX_GROUND_SEARCH@@3FA	; MAX_GROUND_SEARCH
	push	edx
	call	?GridToSim@@YAMF@Z			; GridToSim
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR ?ObjProxList@@3PAVVuGridTree@@A ; ObjProxList
	push	eax
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 247  : #else
; 248  : 	VuGridIterator	detit(ObjProxList,XPos(),YPos(),(BIG_SCALAR)GridToSim(MAX_GROUND_SEARCH));
; 249  : #endif
; 250  : 	o = (Objective) detit.GetFirst();

	lea	ecx, DWORD PTR _detit$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _o$[ebp], eax
$LN7@DetectOnMo:

; 251  : 	while (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN6@DetectOnMo

; 252  : 	{
; 253  : 		if (o->GetTeam() != who)

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	je	$LN1@DetectOnMo

; 254  : 		{
; 255  : 			capture = 0;

	mov	DWORD PTR _capture$[ebp], 0

; 256  : 			DetectVs(o,&d,&combat,&spot,&capture,&nomove,&estr);

	lea	eax, DWORD PTR _estr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nomove$[ebp]
	push	ecx
	lea	edx, DWORD PTR _capture$[ebp]
	push	edx
	lea	eax, DWORD PTR _spot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _combat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetectVs@GroundUnitClass@@QAEHPAVCampBaseClass@@PAMPAH2222@Z ; GroundUnitClass::DetectVs

; 257  : 			if (nomove)

	cmp	DWORD PTR _nomove$[ebp], 0
	je	SHORT $LN4@DetectOnMo

; 258  : 				return -1;

	mov	DWORD PTR $T3[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN11@DetectOnMo
$LN4@DetectOnMo:

; 259  : 			if (capture)

	cmp	DWORD PTR _capture$[ebp], 0
	je	SHORT $LN1@DetectOnMo

; 260  : 			{
; 261  : 				CaptureObjective(o, GetOwner(), this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	call	?CaptureObjective@@YAXPAVObjectiveClass@@EPAVUnitClass@@@Z ; CaptureObjective
	add	esp, 12					; 0000000cH

; 262  : 				if (!Parent())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	jne	SHORT $LN1@DetectOnMo

; 263  : 				{
; 264  : 					Unit parent = GetUnitParent();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _parent$4[ebp], eax

; 265  : 					ShiAssert(parent);
; 266  : 					if (parent) // JB 010710 CTD

	cmp	DWORD PTR _parent$4[ebp], 0
	je	SHORT $LN1@DetectOnMo

; 267  : 						parent->SetOrdered(1);

	push	1
	mov	ecx, DWORD PTR _parent$4[ebp]
	call	?SetOrdered@UnitClass@@QAEXH@Z		; UnitClass::SetOrdered
$LN1@DetectOnMo:

; 268  : 				}
; 269  : 			}
; 270  : 		}
; 271  : 		o = (Objective) detit.GetNext();

	lea	ecx, DWORD PTR _detit$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _o$[ebp], eax

; 272  : 	}

	jmp	$LN7@DetectOnMo
$LN6@DetectOnMo:

; 273  : 	return retval;

	mov	ecx, DWORD PTR _retval$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _detit$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T2[ebp]
$LN11@DetectOnMo:

; 274  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DetectOnMove@GroundUnitClass@@UAEHXZ$0:
	lea	ecx, DWORD PTR _detit$[ebp]
	jmp	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
__ehhandler$?DetectOnMove@GroundUnitClass@@UAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DetectOnMove@GroundUnitClass@@UAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DetectOnMove@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::DetectOnMove
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_acost$ = -20						; size = 4
_cost$ = -16						; size = 4
_uc$ = -12						; size = 4
_amt$ = -8						; size = 4
_this$ = -4						; size = 4
_o$ = 8							; size = 4
_n$ = 12						; size = 4
?GetObjMovementType@GroundUnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z PROC ; GroundUnitClass::GetObjMovementType
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	float				cost,acost;
; 199  : 	UnitClassDataType*	uc;
; 200  : 	MoveType			amt;
; 201  : 
; 202  : 	if (GetSType() != STYPE_UNIT_AIRMOBILE && GetSType() != STYPE_UNIT_MARINE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	cmp	eax, 2
	je	SHORT $LN5@GetObjMove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 8
	je	SHORT $LN5@GetObjMove

; 203  : 		return GetMovementType();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	jmp	$LN6@GetObjMove
$LN5@GetObjMove:

; 204  : 
; 205  : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 206  : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN4@GetObjMove

; 207  : 		return Tracked;

	mov	eax, 3
	jmp	SHORT $LN6@GetObjMove
$LN4@GetObjMove:

; 208  : 	amt = uc->MovementType;

	mov	eax, DWORD PTR _uc$[ebp]
	mov	ecx, DWORD PTR [eax+252]
	mov	DWORD PTR _amt$[ebp], ecx

; 209  : 	cost = o->GetNeighborCost(n,amt);

	mov	edx, DWORD PTR _amt$[ebp]
	push	edx
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ; ObjectiveClass::GetNeighborCost
	fstp	DWORD PTR _cost$[ebp]

; 210  : 	if (GetSType() == STYPE_UNIT_AIRMOBILE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 2
	jne	SHORT $LN3@GetObjMove

; 211  : 		amt = LowAir;

	mov	DWORD PTR _amt$[ebp], 4
$LN3@GetObjMove:

; 212  : 	if (GetSType() == STYPE_UNIT_MARINE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	cmp	edx, 8
	jne	SHORT $LN2@GetObjMove

; 213  : 		amt = Naval;

	mov	DWORD PTR _amt$[ebp], 6
$LN2@GetObjMove:

; 214  : 	acost = o->GetNeighborCost(n,amt);

	mov	eax, DWORD PTR _amt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ; ObjectiveClass::GetNeighborCost
	fstp	DWORD PTR _acost$[ebp]

; 215  : 	if (acost < cost)

	movss	xmm0, DWORD PTR _cost$[ebp]
	comiss	xmm0, DWORD PTR _acost$[ebp]
	jbe	SHORT $LN1@GetObjMove

; 216  : 		return amt;

	mov	eax, DWORD PTR _amt$[ebp]
	jmp	SHORT $LN6@GetObjMove
$LN1@GetObjMove:

; 217  : 	return uc->MovementType;

	mov	edx, DWORD PTR _uc$[ebp]
	mov	eax, DWORD PTR [edx+252]
$LN6@GetObjMove:

; 218  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetObjMovementType@GroundUnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z ENDP ; GroundUnitClass::GetObjMovementType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_uc$ = -8						; size = 4
_this$ = -4						; size = 4
?GetMovementType@GroundUnitClass@@UAE?AW4MoveType@@XZ PROC ; GroundUnitClass::GetMovementType
; _this$ = ecx

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 181  : 	UnitClassDataType*	uc;
; 182  : 
; 183  : 	/*	if (GetUnitTactic() == GTACTIC_MOVE_AIRBORNE)
; 184  : 		return LowAir;
; 185  : 		else if (GetUnitTactic() == GTACTIC_MOVE_MARINE)
; 186  : 		return Naval;
; 187  : 	 */	
; 188  : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 189  : 
; 190  : 	ShiAssert (uc);
; 191  : 
; 192  : 	return uc->MovementType;

	mov	eax, DWORD PTR _uc$[ebp]
	mov	eax, DWORD PTR [eax+252]

; 193  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMovementType@GroundUnitClass@@UAE?AW4MoveType@@XZ ENDP ; GroundUnitClass::GetMovementType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_tmp_ent$ = -8						; size = 4
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@GroundUnitClass@@UAEHPAVVuFullUpdateEvent@@@Z PROC ; GroundUnitClass::Handle
; _this$ = ecx

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 	// copy data from temp entity to current entity
; 170  : 	GroundUnitClass* tmp_ent = (GroundUnitClass*)(event->expandedData_.get());

	mov	ecx, DWORD PTR _event$[ebp]
	add	ecx, 48					; 00000030H
	call	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ; VuBin<VuEntity>::get
	mov	DWORD PTR _tmp_ent$[ebp], eax

; 171  : 
; 172  : 	orders = tmp_ent->orders;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+260]
	mov	BYTE PTR [eax+260], dl

; 173  : 	aobj = tmp_ent->aobj;

	mov	eax, DWORD PTR _tmp_ent$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [eax+284]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], ecx
	mov	DWORD PTR [eax+284], edx

; 174  : 	sobj = tmp_ent->sobj;

	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	eax, DWORD PTR [ecx+276]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], edx
	mov	DWORD PTR [ecx+276], eax

; 175  : 	pobj = tmp_ent->pobj;

	mov	edx, DWORD PTR _tmp_ent$[ebp]
	mov	eax, DWORD PTR [edx+264]
	mov	ecx, DWORD PTR [edx+268]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], eax
	mov	DWORD PTR [edx+268], ecx

; 176  : 	return (UnitClass::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@UnitClass@@UAEHPAVVuFullUpdateEvent@@@Z ; UnitClass::Handle

; 177  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@GroundUnitClass@@UAEHPAVVuFullUpdateEvent@@@Z ENDP ; GroundUnitClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_stream$ = 8						; size = 4
?Save@GroundUnitClass@@UAEHPAPAE@Z PROC			; GroundUnitClass::Save
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	UnitClass::Save(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Save@UnitClass@@UAEHPAPAE@Z		; UnitClass::Save

; 150  : 	if (save_log)

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN1@Save

; 151  : 	{
; 152  : 		fprintf (save_log, "%08x GroundUnitClass ", *stream - start_save_stream);

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR ?start_save_stream@@3HA	; start_save_stream
	push	edx
	push	OFFSET ??_C@_0BG@ILCOIOOM@?$CF08x?5GroundUnitClass?5?$AA@
	mov	eax, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 153  : 		fflush (save_log);

	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fflush
	add	esp, 4
$LN1@Save:

; 154  : 	}
; 155  : 
; 156  : 	memcpy(*stream, &orders, sizeof(uchar));				*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 157  : 	memcpy(*stream, &division, sizeof(short));				*stream += sizeof(short);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 262				; 00000106H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 158  : #ifdef CAMPTOOL
; 159  : 	if (gRenameIds)
; 160  : 		aobj.num_ = RenameTable[aobj.num_];
; 161  : #endif
; 162  : 	memcpy(*stream, &aobj, sizeof(VU_ID));					*stream += sizeof(VU_ID);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 280				; 00000118H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 163  : 	return GroundUnitClass::SaveSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveSize@GroundUnitClass@@UAEHXZ	; GroundUnitClass::SaveSize

; 164  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Save@GroundUnitClass@@UAEHPAPAE@Z ENDP			; GroundUnitClass::Save
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SaveSize@GroundUnitClass@@UAEHXZ PROC			; GroundUnitClass::SaveSize
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 	return UnitClass::SaveSize()
; 142  : 			+ sizeof(uchar)
; 143  : 			+ sizeof(VU_ID)
; 144  : 			+ sizeof(short);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveSize@UnitClass@@UAEHXZ		; UnitClass::SaveSize
	add	eax, 11					; 0000000bH

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveSize@GroundUnitClass@@UAEHXZ ENDP			; GroundUnitClass::SaveSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1GroundUnitClass@@UAE@XZ PROC				; GroundUnitClass::~GroundUnitClass
; _this$ = ecx

; 136  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7GroundUnitClass@@6B@

; 137  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UnitClass@@UAE@XZ			; UnitClass::~UnitClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1GroundUnitClass@@UAE@XZ ENDP				; GroundUnitClass::~GroundUnitClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 8
$T3 = -28						; size = 8
_o$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
??0GroundUnitClass@@QAE@PAPAEPAJ@Z PROC			; GroundUnitClass::GroundUnitClass
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0GroundUnitClass@@QAE@PAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0UnitClass@@QAE@PAPAEPAJ@Z		; UnitClass::UnitClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7GroundUnitClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 104  : 	Objective		o;
; 105  : 
; 106  : 	if (load_log) {

	cmp	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
	je	SHORT $LN7@GroundUnit

; 107  : 		fprintf (load_log, "%08x GroundUnitClass ", *stream - start_load_stream);

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR ?start_load_stream@@3HA	; start_load_stream
	push	ecx
	push	OFFSET ??_C@_0BG@ILCOIOOM@?$CF08x?5GroundUnitClass?5?$AA@
	mov	edx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 108  : 		fflush (load_log);

	mov	eax, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	eax
	call	_fflush
	add	esp, 4
$LN7@GroundUnit:

; 109  : 	}
; 110  : 
; 111  : 	dirty_ground_unit = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], 0

; 112  : 	memcpychk(&orders, stream, sizeof(uchar), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 113  : 	memcpychk(&division, stream, sizeof(short), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 262				; 00000106H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 114  : 	memcpychk(&aobj, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 115  : #ifdef DEBUG
; 116  : 	aobj.num_ &= 0xffff;
; 117  : #endif
; 118  : 	o = FindObjective(aobj);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	mov	ecx, DWORD PTR [edx+280]
	push	ecx
	call	?FindObjective@@YAPAVObjectiveClass@@VVU_ID@@@Z ; FindObjective
	add	esp, 8
	mov	DWORD PTR _o$[ebp], eax

; 119  : 	// Find Secondary objective from actual
; 120  : 	if (o && !o->IsSecondary() && !o->IsPrimary())

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN6@GroundUnit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsSecondary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsSecondary
	test	eax, eax
	jne	SHORT $LN6@GroundUnit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsPrimary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsPrimary
	test	eax, eax
	jne	SHORT $LN6@GroundUnit

; 121  : 		o = o->GetObjectiveParent();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ ; ObjectiveClass::GetObjectiveParent
	mov	DWORD PTR _o$[ebp], eax
$LN6@GroundUnit:

; 122  : 	if (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN5@GroundUnit

; 123  : 		sobj = o->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+272], ecx
	mov	DWORD PTR [eax+276], edx

; 124  : 	else

	jmp	SHORT $LN4@GroundUnit
$LN5@GroundUnit:

; 125  : 		sobj = FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+272], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+276], eax
$LN4@GroundUnit:

; 126  : 	// Find Primary objective from seconday
; 127  : 	if (o && !o->IsPrimary())

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN3@GroundUnit
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsPrimary@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsPrimary
	test	eax, eax
	jne	SHORT $LN3@GroundUnit

; 128  : 		o = o->GetObjectiveParent();

	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ ; ObjectiveClass::GetObjectiveParent
	mov	DWORD PTR _o$[ebp], eax
$LN3@GroundUnit:

; 129  : 	if (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN2@GroundUnit

; 130  : 		pobj = o->Id();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], edx
	mov	DWORD PTR [ecx+268], eax

; 131  : 	else

	jmp	SHORT $LN8@GroundUnit
$LN2@GroundUnit:

; 132  : 		pobj = FalconNullId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [edx+264], eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [edx+268], ecx
$LN8@GroundUnit:

; 133  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0GroundUnitClass@@QAE@PAPAEPAJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1UnitClass@@UAE@XZ			; UnitClass::~UnitClass
__ehhandler$??0GroundUnitClass@@QAE@PAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0GroundUnitClass@@QAE@PAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0GroundUnitClass@@QAE@PAPAEPAJ@Z ENDP			; GroundUnitClass::GroundUnitClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\gndunit.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 2
_id$ = 12						; size = 4
??0GroundUnitClass@@QAE@GK@Z PROC			; GroundUnitClass::GroundUnitClass
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0GroundUnitClass@@QAE@GK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	movzx	ecx, WORD PTR _type$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0UnitClass@@QAE@GK@Z			; UnitClass::UnitClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7GroundUnitClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 94   : 	orders = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+260], 0

; 95   : 	division = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+262], cx

; 96   : 	pobj = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+264], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+268], edx

; 97   : 	sobj = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+272], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+276], edx

; 98   : 	aobj = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+280], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+284], edx

; 99   : 	dirty_ground_unit = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+288], 0

; 100  : }	

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0GroundUnitClass@@QAE@GK@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1UnitClass@@UAE@XZ			; UnitClass::~UnitClass
__ehhandler$??0GroundUnitClass@@QAE@GK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0GroundUnitClass@@QAE@GK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0GroundUnitClass@@QAE@GK@Z ENDP			; GroundUnitClass::GroundUnitClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?UpdateParentStatistics@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateParentStatistics@UnitClass@@UAEHXZ PROC		; UnitClass::UpdateParentStatistics, COMDAT
; _this$ = ecx

; 559  : 	virtual int UpdateParentStatistics (void)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateParentStatistics@UnitClass@@UAEHXZ ENDP		; UnitClass::UpdateParentStatistics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ReorganizeUnit@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReorganizeUnit@UnitClass@@UAEXXZ PROC			; UnitClass::ReorganizeUnit, COMDAT
; _this$ = ecx

; 558  : 	virtual void ReorganizeUnit (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReorganizeUnit@UnitClass@@UAEXXZ ENDP			; UnitClass::ReorganizeUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::RemoveChild, COMDAT
; _this$ = ecx

; 557  : 	virtual void RemoveChild (VU_ID)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::RemoveChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DisposeChildren@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisposeChildren@UnitClass@@UAEXXZ PROC			; UnitClass::DisposeChildren, COMDAT
; _this$ = ecx

; 556  : 	virtual void DisposeChildren (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisposeChildren@UnitClass@@UAEXXZ ENDP			; UnitClass::DisposeChildren
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?AddUnitChild@UnitClass@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?AddUnitChild@UnitClass@@UAEXPAV1@@Z PROC		; UnitClass::AddUnitChild, COMDAT
; _this$ = ecx

; 555  : 	virtual void AddUnitChild (Unit)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddUnitChild@UnitClass@@UAEXPAV1@@Z ENDP		; UnitClass::AddUnitChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z PROC	; UnitClass::GetPrevUnitElement, COMDAT
; _this$ = ecx

; 554  : 	virtual Unit GetPrevUnitElement (Unit)						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z ENDP	; UnitClass::GetPrevUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z PROC		; UnitClass::GetUnitElementByID, COMDAT
; _this$ = ecx

; 553  : 	virtual Unit GetUnitElementByID (int)						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z ENDP		; UnitClass::GetUnitElementByID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElement@UnitClass@@UAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitElement@UnitClass@@UAEPAV1@H@Z PROC		; UnitClass::GetUnitElement, COMDAT
; _this$ = ecx

; 552  : 	virtual Unit GetUnitElement (int)							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitElement@UnitClass@@UAEPAV1@H@Z ENDP		; UnitClass::GetUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNextUnitElement@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextUnitElement@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetNextUnitElement, COMDAT
; _this$ = ecx

; 551  : 	virtual Unit GetNextUnitElement() const						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextUnitElement@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetNextUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetFirstUnitElement, COMDAT
; _this$ = ecx

; 550  : 	virtual Unit GetFirstUnitElement() const					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetFirstUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitParent@UnitClass@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitParent@UnitClass@@UAEXPAV1@@Z PROC		; UnitClass::SetUnitParent, COMDAT
; _this$ = ecx

; 543  : 	virtual void SetUnitParent (Unit)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitParent@UnitClass@@UAEXPAV1@@Z ENDP		; UnitClass::SetUnitParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitParentID, COMDAT
; _this$ = ecx

; 542  : 	virtual VU_ID GetUnitParentID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitParentID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitParent@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitParent@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetUnitParent, COMDAT
; _this$ = ecx

; 541  : 	virtual Unit GetUnitParent() const							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitParent@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetUnitParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?RallyUnit@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?RallyUnit@UnitClass@@UAEHH@Z PROC			; UnitClass::RallyUnit, COMDAT
; _this$ = ecx

; 538  : 	virtual int RallyUnit (int)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?RallyUnit@UnitClass@@UAEHH@Z ENDP			; UnitClass::RallyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z PROC	; UnitClass::GetUnitCurrentDestination, COMDAT
; _this$ = ecx

; 534  : 	virtual void GetUnitCurrentDestination(GridIndex*, GridIndex*)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z ENDP	; UnitClass::GetUnitCurrentDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 2
___formal$ = 12						; size = 2
?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z PROC	; UnitClass::SetUnitCurrentDestination, COMDAT
; _this$ = ecx

; 533  : 	virtual void SetUnitCurrentDestination(GridIndex, GridIndex)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z ENDP	; UnitClass::SetUnitCurrentDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNextMoveDirection@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextMoveDirection@UnitClass@@UAEHXZ PROC		; UnitClass::GetNextMoveDirection, COMDAT
; _this$ = ecx

; 532  : 	virtual int GetNextMoveDirection (void)						{ return Here; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextMoveDirection@UnitClass@@UAEHXZ ENDP		; UnitClass::GetNextMoveDirection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ClearUnitPath@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearUnitPath@UnitClass@@UAEXXZ PROC			; UnitClass::ClearUnitPath, COMDAT
; _this$ = ecx

; 531  : 	virtual void ClearUnitPath (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearUnitPath@UnitClass@@UAEXXZ ENDP			; UnitClass::ClearUnitPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitNextMove@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetUnitNextMove@UnitClass@@UAEXXZ PROC			; UnitClass::SetUnitNextMove, COMDAT
; _this$ = ecx

; 530  : 	virtual void SetUnitNextMove (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetUnitNextMove@UnitClass@@UAEXXZ ENDP			; UnitClass::SetUnitNextMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitHeading@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitHeading@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitHeading, COMDAT
; _this$ = ecx

; 529  : 	virtual int GetUnitHeading (void)							{ return Here; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitHeading@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPosition@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPosition@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitPosition, COMDAT
; _this$ = ecx

; 527  : 	virtual int GetUnitPosition (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPosition@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMode@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMode@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitMode, COMDAT
; _this$ = ecx

; 526  : 	virtual int GetUnitMode (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMode@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElement@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitElement@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitElement, COMDAT
; _this$ = ecx

; 525  : 	virtual int GetUnitElement (void) 							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitElement@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitFatigue@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitFatigue@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitFatigue, COMDAT
; _this$ = ecx

; 524  : 	virtual int GetUnitFatigue (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFatigue@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitFatigue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitHeading@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitHeading@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitHeading, COMDAT
; _this$ = ecx

; 516  : 	virtual void SetUnitHeading (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitHeading@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitDivision@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitDivision@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitDivision, COMDAT
; _this$ = ecx

; 515  : 	virtual void SetUnitDivision (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitDivision@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPosition@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitPosition@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitPosition, COMDAT
; _this$ = ecx

; 514  : 	virtual void SetUnitPosition (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPosition@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMode@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMode@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitMode, COMDAT
; _this$ = ecx

; 513  : 	virtual void SetUnitMode (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMode@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitFatigue@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitFatigue@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitFatigue, COMDAT
; _this$ = ecx

; 511  : 	virtual void SetUnitFatigue (int) 						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitFatigue@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitFatigue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z PROC		; UnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 510  : 	virtual void SetUnitOrders (int, VU_ID)				{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z ENDP		; UnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitOrders@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitOrders@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 509  : 	virtual void SetUnitOrders (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitOrders@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z PROC	; UnitClass::GetUnitAssemblyPoint, COMDAT
; _this$ = ecx

; 503  : 	virtual void GetUnitAssemblyPoint (int, GridIndex*, GridIndex*)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z ENDP	; UnitClass::GetUnitAssemblyPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 2
?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z PROC		; UnitClass::SetUnitAssemblyPoint, COMDAT
; _this$ = ecx

; 502  : 	virtual void SetUnitAssemblyPoint (int, GridIndex, GridIndex)		{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z ENDP		; UnitClass::SetUnitAssemblyPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 8
?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z PROC	; UnitClass::HandleRequestReceipt, COMDAT
; _this$ = ecx

; 501  : 	virtual void HandleRequestReceipt(int, int, VU_ID)			{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z ENDP	; UnitClass::HandleRequestReceipt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z PROC ; UnitClass::BuildPackage, COMDAT
; _this$ = ecx

; 500  : 	virtual int BuildPackage(MissionRequest, F4PFList)	{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z ENDP ; UnitClass::BuildPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastResupply@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastResupply@UnitClass@@UAEHXZ PROC			; UnitClass::GetLastResupply, COMDAT
; _this$ = ecx

; 497  : 	virtual int GetLastResupply (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastResupply@UnitClass@@UAEHXZ ENDP			; UnitClass::GetLastResupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastResupplyTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastResupplyTime@UnitClass@@UAEKXZ PROC		; UnitClass::GetLastResupplyTime, COMDAT
; _this$ = ecx

; 496  : 	virtual CampaignTime GetLastResupplyTime (void)				{ return TheCampaign.CurrentTime; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastResupplyTime@UnitClass@@UAEKXZ ENDP		; UnitClass::GetLastResupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitStores@UnitClass@@UAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitStores@UnitClass@@UAEEH@Z PROC			; UnitClass::GetUnitStores, COMDAT
; _this$ = ecx

; 495  : 	virtual uchar GetUnitStores (int)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitStores@UnitClass@@UAEEH@Z ENDP			; UnitClass::GetUnitStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetSquadronFuel@UnitClass@@UAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSquadronFuel@UnitClass@@UAEJXZ PROC			; UnitClass::GetSquadronFuel, COMDAT
; _this$ = ecx

; 494  : 	virtual long GetSquadronFuel (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSquadronFuel@UnitClass@@UAEJXZ ENDP			; UnitClass::GetSquadronFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMorale@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMorale@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitMorale, COMDAT
; _this$ = ecx

; 493  : 	virtual int GetUnitMorale (void) 							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMorale@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitMorale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSupply@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSupply@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitSupply, COMDAT
; _this$ = ecx

; 492  : 	virtual int GetUnitSupply (void) 							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSupply@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSpecialty@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSpecialty@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitSpecialty, COMDAT
; _this$ = ecx

; 491  : 	virtual int GetUnitSpecialty (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSpecialty@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitSpecialty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLastResupplyTime@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLastResupplyTime@UnitClass@@UAEXK@Z PROC		; UnitClass::SetLastResupplyTime, COMDAT
; _this$ = ecx

; 490  : 	virtual void SetLastResupplyTime (CampaignTime)			{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastResupplyTime@UnitClass@@UAEXK@Z ENDP		; UnitClass::SetLastResupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLastResupply@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLastResupply@UnitClass@@UAEXH@Z PROC		; UnitClass::SetLastResupply, COMDAT
; _this$ = ecx

; 489  : 	virtual void SetLastResupply (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastResupply@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetLastResupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitStores@UnitClass@@UAEXHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
?SetUnitStores@UnitClass@@UAEXHE@Z PROC			; UnitClass::SetUnitStores, COMDAT
; _this$ = ecx

; 488  : 	virtual void SetUnitStores (int, uchar)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitStores@UnitClass@@UAEXHE@Z ENDP			; UnitClass::SetUnitStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetSquadronFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetSquadronFuel@UnitClass@@UAEXJ@Z PROC		; UnitClass::SetSquadronFuel, COMDAT
; _this$ = ecx

; 487  : 	virtual void SetSquadronFuel (long)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSquadronFuel@UnitClass@@UAEXJ@Z ENDP		; UnitClass::SetSquadronFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMorale@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMorale@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitMorale, COMDAT
; _this$ = ecx

; 486  : 	virtual void SetUnitMorale (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMorale@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitMorale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSupply@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitSupply@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitSupply, COMDAT
; _this$ = ecx

; 485  : 	virtual void SetUnitSupply (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSupply@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSpecialty@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitSpecialty@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitSpecialty, COMDAT
; _this$ = ecx

; 484  : 	virtual void SetUnitSpecialty (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSpecialty@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitSpecialty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?UseFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?UseFuel@UnitClass@@UAEXJ@Z PROC			; UnitClass::UseFuel, COMDAT
; _this$ = ecx

; 481  : 	virtual void UseFuel (long)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?UseFuel@UnitClass@@UAEXJ@Z ENDP			; UnitClass::UseFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IncrementTime@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?IncrementTime@UnitClass@@UAEXK@Z PROC			; UnitClass::IncrementTime, COMDAT
; _this$ = ecx

; 480  : 	virtual void IncrementTime (CampaignTime) 				{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementTime@UnitClass@@UAEXK@Z ENDP			; UnitClass::IncrementTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z PROC ; UnitClass::BuildMission, COMDAT
; _this$ = ecx

; 479  : 	virtual int BuildMission(MissionRequestClass*)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z ENDP ; UnitClass::BuildMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ PROC ; UnitClass::GetKnownEmitters, COMDAT
; _this$ = ecx

; 478  : 	virtual F4PFList GetKnownEmitters (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ ENDP ; UnitClass::GetKnownEmitters
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ETA@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ETA@UnitClass@@UAEKXZ PROC				; UnitClass::ETA, COMDAT
; _this$ = ecx

; 477  : 	virtual CampaignTime ETA (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ETA@UnitClass@@UAEKXZ ENDP				; UnitClass::ETA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DumpWeapons@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DumpWeapons@UnitClass@@UAEHXZ PROC			; UnitClass::DumpWeapons, COMDAT
; _this$ = ecx

; 476  : 	virtual int DumpWeapons (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?DumpWeapons@UnitClass@@UAEHXZ ENDP			; UnitClass::DumpWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z PROC ; UnitClass::LoadWeapons, COMDAT
; _this$ = ecx

; 475  : 	virtual int LoadWeapons (void*, uchar*, MoveType, int, int, int)	{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z ENDP ; UnitClass::LoadWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitAirbaseID, COMDAT
; _this$ = ecx

; 474  : 	virtual VU_ID GetUnitAirbaseID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitAirbaseID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ PROC	; UnitClass::GetUnitAirbase, COMDAT
; _this$ = ecx

; 473  : 	virtual CampEntity GetUnitAirbase (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ ENDP	; UnitClass::GetUnitAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitSquadronID, COMDAT
; _this$ = ecx

; 472  : 	virtual VU_ID GetUnitSquadronID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitSquadronID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSquadron@UnitClass@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSquadron@UnitClass@@UAEPAV1@XZ PROC		; UnitClass::GetUnitSquadron, COMDAT
; _this$ = ecx

; 471  : 	virtual Unit GetUnitSquadron (void)							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSquadron@UnitClass@@UAEPAV1@XZ ENDP		; UnitClass::GetUnitSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTOT@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTOT@UnitClass@@UAEKXZ PROC			; UnitClass::GetUnitTOT, COMDAT
; _this$ = ecx

; 470  : 	virtual CampaignTime GetUnitTOT (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTOT@UnitClass@@UAEKXZ ENDP			; UnitClass::GetUnitTOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionID@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMissionID@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitMissionID, COMDAT
; _this$ = ecx

; 469  : 	virtual int GetUnitMissionID (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionID@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitMissionID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitMissionTargetID, COMDAT
; _this$ = ecx

; 468  : 	virtual VU_ID GetUnitMissionTargetID (void)					{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitMissionTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ PROC ; UnitClass::GetUnitMissionTarget, COMDAT
; _this$ = ecx

; 467  : 	virtual CampEntity GetUnitMissionTarget (void)				{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ ENDP ; UnitClass::GetUnitMissionTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPriority@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPriority@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitPriority, COMDAT
; _this$ = ecx

; 466  : 	virtual int GetUnitPriority (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPriority@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ PROC ; UnitClass::GetUnitMission, COMDAT
; _this$ = ecx

; 463  : 	virtual MissionTypeEnum GetUnitMission (void)							{ return (MissionTypeEnum)0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ ENDP ; UnitClass::GetUnitMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetBurntFuel@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBurntFuel@UnitClass@@UAEHXZ PROC			; UnitClass::GetBurntFuel, COMDAT
; _this$ = ecx

; 462  : 	virtual int GetBurntFuel (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBurntFuel@UnitClass@@UAEHXZ ENDP			; UnitClass::GetBurntFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ PROC	; UnitClass::GetAirTarget, COMDAT
; _this$ = ecx

; 461  : 	virtual FalconEntity* GetAirTarget (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetAirTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ PROC		; UnitClass::GetAirTargetID, COMDAT
; _this$ = ecx

; 460  : 	virtual VU_ID GetAirTargetID (void)							{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ ENDP		; UnitClass::GetAirTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetCombatTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatTime@UnitClass@@UAEKXZ PROC			; UnitClass::GetCombatTime, COMDAT
; _this$ = ecx

; 459  : 	virtual CampaignTime GetCombatTime (void)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatTime@UnitClass@@UAEKXZ ENDP			; UnitClass::GetCombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetMoveTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMoveTime@UnitClass@@UAEKXZ PROC			; UnitClass::GetMoveTime, COMDAT
; _this$ = ecx

; 458  : 	virtual CampaignTime GetMoveTime (void)						{ return TheCampaign.CurrentTime - last_check; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, DWORD PTR [eax+184]
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveTime@UnitClass@@UAEKXZ ENDP			; UnitClass::GetMoveTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNumberOfLoadouts@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumberOfLoadouts@UnitClass@@UAEHXZ PROC		; UnitClass::GetNumberOfLoadouts, COMDAT
; _this$ = ecx

; 457  : 	virtual int GetNumberOfLoadouts (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfLoadouts@UnitClass@@UAEHXZ ENDP		; UnitClass::GetNumberOfLoadouts
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z PROC	; UnitClass::SetLoadout, COMDAT
; _this$ = ecx

; 456  : 	virtual void SetLoadout (LoadoutStruct*, int)	{ ShiWarning("Shouldn't be here"); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z ENDP	; UnitClass::SetLoadout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::SetUnitAirbase, COMDAT
; _this$ = ecx

; 455  : 	virtual void SetUnitAirbase (VU_ID)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::SetUnitAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::SetUnitSquadron, COMDAT
; _this$ = ecx

; 454  : 	virtual void SetUnitSquadron (VU_ID)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::SetUnitSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitTOT@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitTOT@UnitClass@@UAEXK@Z PROC			; UnitClass::SetUnitTOT, COMDAT
; _this$ = ecx

; 453  : 	virtual void SetUnitTOT (CampaignTime)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitTOT@UnitClass@@UAEXK@Z ENDP			; UnitClass::SetUnitTOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMissionTarget@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMissionTarget@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitMissionTarget, COMDAT
; _this$ = ecx

; 452  : 	virtual void SetUnitMissionTarget (int)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMissionTarget@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitMissionTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMissionID@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMissionID@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitMissionID, COMDAT
; _this$ = ecx

; 451  : 	virtual void SetUnitMissionID (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMissionID@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitMissionID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPriority@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitPriority@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitPriority, COMDAT
; _this$ = ecx

; 450  : 	virtual void SetUnitPriority (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPriority@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitRole@UnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetUnitRole@UnitClass@@UAEXE@Z PROC			; UnitClass::SetUnitRole, COMDAT
; _this$ = ecx

; 449  : 	virtual void SetUnitRole (uchar)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitRole@UnitClass@@UAEXE@Z ENDP			; UnitClass::SetUnitRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMission@UnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetUnitMission@UnitClass@@UAEXE@Z PROC			; UnitClass::SetUnitMission, COMDAT
; _this$ = ecx

; 448  : 	virtual void SetUnitMission (uchar)						{}			

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMission@UnitClass@@UAEXE@Z ENDP			; UnitClass::SetUnitMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetBurntFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetBurntFuel@UnitClass@@UAEXJ@Z PROC			; UnitClass::SetBurntFuel, COMDAT
; _this$ = ecx

; 447  : 	virtual void SetBurntFuel (long)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBurntFuel@UnitClass@@UAEXJ@Z ENDP			; UnitClass::SetBurntFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetCombatTime@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetCombatTime@UnitClass@@UAEXK@Z PROC			; UnitClass::SetCombatTime, COMDAT
; _this$ = ecx

; 446  : 	virtual void SetCombatTime (CampaignTime)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCombatTime@UnitClass@@UAEXK@Z ENDP			; UnitClass::SetCombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitLastMove@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitLastMove@UnitClass@@UAEXK@Z PROC		; UnitClass::SetUnitLastMove, COMDAT
; _this$ = ecx

; 445  : 	virtual void SetUnitLastMove (CampaignTime)				{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitLastMove@UnitClass@@UAEXK@Z ENDP		; UnitClass::SetUnitLastMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTactic@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTactic@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitTactic, COMDAT
; _this$ = ecx

; 375  : 	int GetUnitTactic() const						{ return tactic; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+222]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTactic@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMoved@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMoved@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitMoved, COMDAT
; _this$ = ecx

; 374  : 	int GetUnitMoved() const						{ return moved; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+220]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMoved@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetTargetID, COMDAT
; _this$ = ecx

; 367  : 	VU_ID GetTargetID (void)						{ return target_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	edx, DWORD PTR [eax+216]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ PROC	; UnitClass::GetTarget, COMDAT
; _this$ = ecx

; 366  : 	FalconEntity* GetTarget (void)					{ return (FalconEntity*) vuDatabase->Find(target_id); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR [eax+212]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNumVehicles@UnitClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vg$ = 8						; size = 4
?GetNumVehicles@UnitClass@@QAEHH@Z PROC			; UnitClass::GetNumVehicles, COMDAT
; _this$ = ecx

; 365  : 	int GetNumVehicles (int vg)						{ return (int)((roster >> (vg*2)) & 0x03); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	sar	eax, cl
	and	eax, 3
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumVehicles@UnitClass@@QAEHH@Z ENDP			; UnitClass::GetNumVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_this$ = -12						; size = 4
$T3 = -8						; size = 4
tv73 = -4						; size = 4
_e$ = 8							; size = 4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z PROC	; UnitClass::SetTarget, COMDAT
; _this$ = ecx

; 359  : 	void SetTarget (FalconEntity *e)				{ target_id = (e)? e->Id() : FalconNullId; }

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN3@SetTarget
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@SetTarget
$LN3@SetTarget:
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR $T2[ebp+4], edx
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN4@SetTarget:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], eax
	mov	DWORD PTR [edx+216], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ENDP	; UnitClass::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitDestination@UnitClass@@QAEXFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?SetUnitDestination@UnitClass@@QAEXFF@Z PROC		; UnitClass::SetUnitDestination, COMDAT
; _this$ = ecx

; 356  : 	void SetUnitDestination (GridIndex x, GridIndex y)	{ 	dest_x = (GridIndex)(x+1); dest_y = (GridIndex)(y+1); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR _x$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+200], ax
	movsx	edx, WORD PTR _y$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+202], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitDestination@UnitClass@@QAEXFF@Z ENDP		; UnitClass::SetUnitDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetRealPosition@UnitClass@@UAEXPAM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetRealPosition@UnitClass@@UAEXPAM00@Z PROC		; UnitClass::GetRealPosition, COMDAT
; _this$ = ecx

; 347  : 	virtual void GetRealPosition (float*, float*, float*) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetRealPosition@UnitClass@@UAEXPAM00@Z ENDP		; UnitClass::GetRealPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SimSetOrientation@UnitClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSetOrientation@UnitClass@@UAEXMMM@Z PROC		; UnitClass::SimSetOrientation, COMDAT
; _this$ = ecx

; 346  : 	virtual void SimSetOrientation (float, float, float) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SimSetOrientation@UnitClass@@UAEXMMM@Z ENDP		; UnitClass::SimSetOrientation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SimSetLocation@UnitClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SimSetLocation@UnitClass@@UAEXMMM@Z PROC		; UnitClass::SimSetLocation, COMDAT
; _this$ = ecx

; 344  : 	virtual void SimSetLocation (float x, float y, float z)	{ SetPosition(x,y,z); MakeCampBaseDirty (DIRTY_POSITION, DDP[182].priority); MakeCampBaseDirty (DIRTY_ALTITUDE, DDP[183].priority); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
	mov	eax, 4
	imul	eax, 182				; 000000b6H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty
	mov	eax, 4
	imul	eax, 183				; 000000b7H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SimSetLocation@UnitClass@@UAEXMMM@Z ENDP		; UnitClass::SimSetLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Detached@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Detached@UnitClass@@QBEHXZ PROC			; UnitClass::Detached, COMDAT
; _this$ = ecx

; 327  : 	int Detached () const								{ return (int)unit_flags & U_DETACHED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 4194304				; 00400000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Detached@UnitClass@@QBEHXZ ENDP			; UnitClass::Detached
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Retreating@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Retreating@UnitClass@@QBEHXZ PROC			; UnitClass::Retreating, COMDAT
; _this$ = ecx

; 326  : 	int Retreating () const							{ return (int)unit_flags & U_RETREATING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 2097152				; 00200000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Retreating@UnitClass@@QBEHXZ ENDP			; UnitClass::Retreating
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Targeted@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Targeted@UnitClass@@QBEHXZ PROC			; UnitClass::Targeted, COMDAT
; _this$ = ecx

; 325  : 	int Targeted () const								{ return (int)unit_flags & U_TARGETED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1048576				; 00100000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Targeted@UnitClass@@QBEHXZ ENDP			; UnitClass::Targeted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Broken@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Broken@UnitClass@@QBEHXZ PROC				; UnitClass::Broken, COMDAT
; _this$ = ecx

; 320  : 	int Broken () const								{ return (int)unit_flags & U_BROKEN; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32768				; 00008000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Broken@UnitClass@@QBEHXZ ENDP				; UnitClass::Broken
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Combat@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Combat@UnitClass@@QBEHXZ PROC				; UnitClass::Combat, COMDAT
; _this$ = ecx

; 319  : 	int Combat () const								{ return (int)unit_flags & U_COMBAT; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 16384				; 00004000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Combat@UnitClass@@QBEHXZ ENDP				; UnitClass::Combat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Moving@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Moving@UnitClass@@QBEHXZ PROC				; UnitClass::Moving, COMDAT
; _this$ = ecx

; 316  : 	int Moving() const								{ return (int)unit_flags & U_MOVING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1024				; 00000400H
	mov	esp, ebp
	pop	ebp
	ret	0
?Moving@UnitClass@@QBEHXZ ENDP				; UnitClass::Moving
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Engaged@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Engaged@UnitClass@@QBEHXZ PROC				; UnitClass::Engaged, COMDAT
; _this$ = ecx

; 313  : 	int Engaged() const								{ return (int)unit_flags & U_ENGAGED; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 64					; 00000040H
	mov	esp, ebp
	pop	ebp
	ret	0
?Engaged@UnitClass@@QBEHXZ ENDP				; UnitClass::Engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Parent@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Parent@UnitClass@@QBEHXZ PROC				; UnitClass::Parent, COMDAT
; _this$ = ecx

; 312  : 	int Parent() const								{ return (int)unit_flags & U_PARENT; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32					; 00000020H
	mov	esp, ebp
	pop	ebp
	ret	0
?Parent@UnitClass@@QBEHXZ ENDP				; UnitClass::Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Assigned@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Assigned@UnitClass@@QBEHXZ PROC			; UnitClass::Assigned, COMDAT
; _this$ = ecx

; 309  : 	int Assigned() const							{ return (int)unit_flags & U_ASSIGNED; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?Assigned@UnitClass@@QBEHXZ ENDP			; UnitClass::Assigned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IsDead@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@UnitClass@@UBEHXZ PROC				; UnitClass::IsDead, COMDAT
; _this$ = ecx

; 307  : 	virtual int IsDead() const						{ return (int)unit_flags & U_DEAD; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@UnitClass@@UBEHXZ ENDP				; UnitClass::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IsUnit@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnit@UnitClass@@UAEHXZ PROC				; UnitClass::IsUnit, COMDAT
; _this$ = ecx

; 274  : 	virtual int IsUnit (void)										{ return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnit@UnitClass@@UAEHXZ ENDP				; UnitClass::IsUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z PROC ; UnitClass::GetVehicleDeagData, COMDAT
; _this$ = ecx

; 266  : 	virtual int GetVehicleDeagData(SimInitDataClass*, int)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z ENDP ; UnitClass::GetVehicleDeagData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SupplyUnit@UnitClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?SupplyUnit@UnitClass@@UAEXHH@Z PROC			; UnitClass::SupplyUnit, COMDAT
; _this$ = ecx

; 265  : 	virtual void SupplyUnit (int, int)								{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SupplyUnit@UnitClass@@UAEXHH@Z ENDP			; UnitClass::SupplyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitFuelNeed@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitFuelNeed@UnitClass@@UAEHH@Z PROC		; UnitClass::GetUnitFuelNeed, COMDAT
; _this$ = ecx

; 264  : 	virtual int GetUnitFuelNeed (int)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitFuelNeed@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetUnitFuelNeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSupplyNeed@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitSupplyNeed@UnitClass@@UAEHH@Z PROC		; UnitClass::GetUnitSupplyNeed, COMDAT
; _this$ = ecx

; 263  : 	virtual int GetUnitSupplyNeed (int)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSupplyNeed@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetUnitSupplyNeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CombatTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatTime@UnitClass@@UAEKXZ PROC			; UnitClass::CombatTime, COMDAT
; _this$ = ecx

; 262  : 	virtual CampaignTime CombatTime (void)							{ return CampaignDay; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 86400000				; 05265c00H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatTime@UnitClass@@UAEKXZ ENDP			; UnitClass::CombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSpeed@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSpeed@UnitClass@@UBEHXZ PROC			; UnitClass::GetUnitSpeed, COMDAT
; _this$ = ecx

; 251  : 	virtual int GetUnitSpeed() const								{ return GetMaxSpeed(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMaxSpeed@UnitClass@@QBEHXZ		; UnitClass::GetMaxSpeed
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSpeed@UnitClass@@UBEHXZ ENDP			; UnitClass::GetUnitSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?AdjustForSupply@UnitClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AdjustForSupply@UnitClass@@UAEMXZ PROC			; UnitClass::AdjustForSupply, COMDAT
; _this$ = ecx

; 250  : 	virtual float AdjustForSupply(void)								{ return 1.0F; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld1
	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustForSupply@UnitClass@@UAEMXZ ENDP			; UnitClass::AdjustForSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Real@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Real@UnitClass@@UAEHXZ PROC				; UnitClass::Real, COMDAT
; _this$ = ecx

; 249  : 	virtual int Real (void)											{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Real@UnitClass@@UAEHXZ ENDP				; UnitClass::Real
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Father@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Father@UnitClass@@UBEHXZ PROC				; UnitClass::Father, COMDAT
; _this$ = ecx

; 248  : 	virtual int Father() const										{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Father@UnitClass@@UBEHXZ ENDP				; UnitClass::Father
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CheckTactic@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?CheckTactic@UnitClass@@UAEHH@Z PROC			; UnitClass::CheckTactic, COMDAT
; _this$ = ecx

; 247  : 	virtual int CheckTactic (int)									{ return 1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckTactic@UnitClass@@UAEHH@Z ENDP			; UnitClass::CheckTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ChooseTactic@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ChooseTactic@UnitClass@@UAEHXZ PROC			; UnitClass::ChooseTactic, COMDAT
; _this$ = ecx

; 246  : 	virtual int ChooseTactic (void)									{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ChooseTactic@UnitClass@@UAEHXZ ENDP			; UnitClass::ChooseTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DoCombat@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoCombat@UnitClass@@UAEHXZ PROC			; UnitClass::DoCombat, COMDAT
; _this$ = ecx

; 245  : 	virtual int DoCombat (void)										{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?DoCombat@UnitClass@@UAEHXZ ENDP			; UnitClass::DoCombat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?MoveUnit@UnitClass@@UAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?MoveUnit@UnitClass@@UAEHK@Z PROC			; UnitClass::MoveUnit, COMDAT
; _this$ = ecx

; 244  : 	virtual int MoveUnit (CampaignTime)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?MoveUnit@UnitClass@@UAEHK@Z ENDP			; UnitClass::MoveUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z PROC	; UnitClass::Reaction, COMDAT
; _this$ = ecx

; 243  : 	virtual int Reaction (CampEntity, int, float)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z ENDP	; UnitClass::Reaction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ClearDeaggregationData@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDeaggregationData@UnitClass@@UAEXXZ PROC		; UnitClass::ClearDeaggregationData, COMDAT
; _this$ = ecx

; 242  : 	virtual void ClearDeaggregationData (void)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDeaggregationData@UnitClass@@UAEXXZ ENDP		; UnitClass::ClearDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ShouldDeaggregate@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShouldDeaggregate@UnitClass@@UAEHXZ PROC		; UnitClass::ShouldDeaggregate, COMDAT
; _this$ = ecx

; 241  : 	virtual int	ShouldDeaggregate(void)								{return TRUE;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldDeaggregate@UnitClass@@UAEHXZ ENDP		; UnitClass::ShouldDeaggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ PROC ; UnitClass::GetUnitDeaggregationData, COMDAT
; _this$ = ecx

; 240  : 	virtual UnitDeaggregationData* GetUnitDeaggregationData (void)	{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ ENDP ; UnitClass::GetUnitDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z PROC ; UnitClass::GetDeaggregationPoint, COMDAT
; _this$ = ecx

; 239  : 	virtual int GetDeaggregationPoint (int, CampEntity*)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z ENDP ; UnitClass::GetDeaggregationPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CanShootWeapon@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?CanShootWeapon@UnitClass@@UAEHH@Z PROC			; UnitClass::CanShootWeapon, COMDAT
; _this$ = ecx

; 238  : 	virtual int CanShootWeapon (int)								{ return TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?CanShootWeapon@UnitClass@@UAEHH@Z ENDP			; UnitClass::CanShootWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetCargoId, COMDAT
; _this$ = ecx

; 151  : 	VU_ID GetCargoId (void)				{ return cargo_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	edx, DWORD PTR [eax+208]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetCargoId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveScore@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveScore@ObjectiveClass@@QAEHXZ PROC		; ObjectiveClass::GetObjectiveScore, COMDAT
; _this$ = ecx

; 271  : 	int GetObjectiveScore (void)							{	return obj_data.aiscore; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+188]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveScore@ObjectiveClass@@QAEHXZ ENDP		; ObjectiveClass::GetObjectiveScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveStatus@ObjectiveClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveStatus@ObjectiveClass@@QAEEXZ PROC		; ObjectiveClass::GetObjectiveStatus, COMDAT
; _this$ = ecx

; 270  : 	uchar GetObjectiveStatus (void)							{	return obj_data.status; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+199]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ENDP		; ObjectiveClass::GetObjectiveStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?NumLinks@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumLinks@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::NumLinks, COMDAT
; _this$ = ecx

; 268  : 	int NumLinks(void)										{	return static_data.links; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+225]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumLinks@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::NumLinks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveParentID@ObjectiveClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetObjectiveParentID@ObjectiveClass@@QAE?AVVU_ID@@XZ PROC ; ObjectiveClass::GetObjectiveParentID, COMDAT
; _this$ = ecx

; 266  : 	VU_ID GetObjectiveParentID(void)						{ 	return static_data.parent; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	mov	edx, DWORD PTR [eax+220]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetObjectiveParentID@ObjectiveClass@@QAE?AVVU_ID@@XZ ENDP ; ObjectiveClass::GetObjectiveParentID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ PROC	; ObjectiveClass::GetObjectiveParent, COMDAT
; _this$ = ecx

; 263  : 	Objective GetObjectiveParent(void)						{ 	return FindObjective(static_data.parent); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	mov	edx, DWORD PTR [eax+216]
	push	edx
	call	?FindObjective@@YAPAVObjectiveClass@@VVU_ID@@@Z ; FindObjective
	add	esp, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveParent@ObjectiveClass@@QAEPAV1@XZ ENDP	; ObjectiveClass::GetObjectiveParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z
_TEXT	SEGMENT
tv77 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
_t$ = 12						; size = 4
?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z PROC ; ObjectiveClass::GetNeighborCost, COMDAT
; _this$ = ecx

; 261  : 	float GetNeighborCost (int n, MoveType t)				{ 	return link_data[n].costs[t]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	add	edx, eax
	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	DWORD PTR tv76[ebp], ecx
	fild	DWORD PTR tv76[ebp]
	fstp	DWORD PTR tv77[ebp]
	fld	DWORD PTR tv77[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
?GetNeighborCost@ObjectiveClass@@QAEMHW4MoveType@@@Z ENDP ; ObjectiveClass::GetNeighborCost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?Abandoned@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Abandoned@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::Abandoned, COMDAT
; _this$ = ecx

; 224  : 	int Abandoned (void)									{	return obj_data.obj_flags & O_ABANDONED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 1048576				; 00100000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Abandoned@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::Abandoned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?SamSite@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SamSite@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::SamSite, COMDAT
; _this$ = ecx

; 208  : 	int SamSite (void)										{	return obj_data.obj_flags & O_SAM_SITE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 1024				; 00000400H
	mov	esp, ebp
	pop	ebp
	ret	0
?SamSite@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::SamSite
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?IsThirdline@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsThirdline@ObjectiveClass@@QAEHXZ PROC		; ObjectiveClass::IsThirdline, COMDAT
; _this$ = ecx

; 188  : 	int IsThirdline (void)									{ return (int)(O_THIRDLINE & obj_data.obj_flags); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?IsThirdline@ObjectiveClass@@QAEHXZ ENDP		; ObjectiveClass::IsThirdline
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?IsSecondline@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSecondline@ObjectiveClass@@QAEHXZ PROC		; ObjectiveClass::IsSecondline, COMDAT
; _this$ = ecx

; 187  : 	int IsSecondline (void)									{ return (int)(O_SECONDLINE & obj_data.obj_flags); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSecondline@ObjectiveClass@@QAEHXZ ENDP		; ObjectiveClass::IsSecondline
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?IsFrontline@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFrontline@ObjectiveClass@@QAEHXZ PROC		; ObjectiveClass::IsFrontline, COMDAT
; _this$ = ecx

; 186  : 	int IsFrontline (void)									{ return (int)(O_FRONTLINE & obj_data.obj_flags); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFrontline@ObjectiveClass@@QAEHXZ ENDP		; ObjectiveClass::IsFrontline
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?SetChecked@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetChecked@CampBaseClass@@QAEXXZ PROC			; CampBaseClass::SetChecked, COMDAT
; _this$ = ecx

; 306  : 	void SetChecked (void)						{	local_flags |= CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetChecked@CampBaseClass@@QAEXXZ ENDP			; CampBaseClass::SetChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_e$ = 8							; size = 4
?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z PROC	; CampBaseClass::HasEntity, COMDAT
; _this$ = ecx

; 281  : 	virtual int HasEntity(VuEntity *e) const    {   

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		return ((components && (components->Find(e) != NULL)) || (this == e)); 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+160], 0
	je	SHORT $LN3@HasEntity
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?Find@VuCollection@@QBE_NPAVVuEntity@@@Z ; VuCollection::Find
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@HasEntity
$LN3@HasEntity:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	je	SHORT $LN4@HasEntity
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN5@HasEntity
$LN4@HasEntity:
	mov	DWORD PTR tv81[ebp], 1
$LN5@HasEntity:
	mov	eax, DWORD PTR tv81[ebp]

; 283  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z ENDP	; CampBaseClass::HasEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsChecked@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsChecked@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsChecked, COMDAT
; _this$ = ecx

; 272  : 	int IsChecked (void)						{	return local_flags & CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsChecked@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsEmitting@CampBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@CampBaseClass@@UAEHXZ PROC			; CampBaseClass::IsEmitting, COMDAT
; _this$ = ecx

; 269  : 	virtual int IsEmitting (void)				{	return base_flags & CBC_EMITTING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+150]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@CampBaseClass@@UAEHXZ ENDP			; CampBaseClass::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsCampBase@CampBaseClass@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCampBase@CampBaseClass@@UAE_NXZ PROC			; CampBaseClass::IsCampBase, COMDAT
; _this$ = ecx

; 268  : 	virtual bool IsCampBase() { return true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampBase@CampBaseClass@@UAE_NXZ ENDP			; CampBaseClass::IsCampBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetMissilesFlying@CampBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMissilesFlying@CampBaseClass@@UAEHXZ PROC		; CampBaseClass::GetMissilesFlying, COMDAT
; _this$ = ecx

; 249  : 	virtual int GetMissilesFlying (void)				{ return 0; } // MLR 10/3/2004 - finishing what //me123 started

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMissilesFlying@CampBaseClass@@UAEHXZ ENDP		; CampBaseClass::GetMissilesFlying
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?StepRadar@CampBaseClass@@UAEHHHM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
_d$ = 12						; size = 4
_range$ = 16						; size = 4
?StepRadar@CampBaseClass@@UAEHHHM@Z PROC		; CampBaseClass::StepRadar, COMDAT
; _this$ = ecx

; 240  : 	virtual int StepRadar (int t,int d, float range)								{	return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StepRadar@CampBaseClass@@UAEHHHM@Z ENDP		; CampBaseClass::StepRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCountry@CampBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCountry@CampBaseClass@@UAEEXZ PROC			; CampBaseClass::GetCountry, COMDAT
; _this$ = ecx

; 239  : 	virtual uchar GetCountry (void)								{	return owner; }		// New FalcEnt friendly form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCountry@CampBaseClass@@UAEEXZ ENDP			; CampBaseClass::GetCountry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetTeam@CampBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeam@CampBaseClass@@UAEEXZ PROC			; CampBaseClass::GetTeam, COMDAT
; _this$ = ecx

; 238  : 	virtual uchar GetTeam (void)								{	return ::GetTeam(owner); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+154]
	push	ecx
	call	?GetTeam@@YAEE@Z			; GetTeam
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeam@CampBaseClass@@UAEEXZ ENDP			; CampBaseClass::GetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCampID@CampBaseClass@@UAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampID@CampBaseClass@@UAEFXZ PROC			; CampBaseClass::GetCampID, COMDAT
; _this$ = ecx

; 237  : 	virtual short GetCampID (void)								{	return camp_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampID@CampBaseClass@@UAEFXZ ENDP			; CampBaseClass::GetCampID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ PROC ; CampBaseClass::GetComponents, COMDAT
; _this$ = ecx

; 141  : 	TailInsertList *GetComponents() const		{	return components; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ENDP ; CampBaseClass::GetComponents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ?memcpychk@@YAXPAXPAPAEIPAJ@Z
_TEXT	SEGMENT
$T2 = -152						; size = 12
_s$3 = -140						; size = 24
_err$4 = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_rem$ = 20						; size = 4
?memcpychk@@YAXPAXPAPAEIPAJ@Z PROC			; memcpychk, COMDAT

; 25   : inline void memcpychk(void *dst, VU_BYTE **src, size_t size, long *rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 26   : 	if ((size_t)*rem < size){

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN1@memcpychk

; 27   : 		char err[100];
; 28   : 		sprintf(err, "Trying to write %lu bytes to %ld buffer", static_cast<unsigned long>(size), *rem);

	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
	lea	edx, DWORD PTR _err$4[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 29   : 		std::string s(err);

	lea	eax, DWORD PTR _err$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 30   : 		throw InvalidBufferException(s);

	lea	ecx, DWORD PTR _s$3[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
	push	OFFSET __TI4?AVInvalidBufferException@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 31   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@memcpychk:

; 32   : 	memcpy(dst, *src, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 33   : 	*rem -= size;

	mov	ecx, DWORD PTR _rem$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [eax], edx

; 34   : 	*src += size;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax], edx
$LN3@memcpychk:

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0:
	lea	ecx, DWORD PTR _s$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?memcpychk@@YAXPAXPAPAEIPAJ@Z ENDP			; memcpychk
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidBufferException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidBufferException@@UAEPAXI@Z PROC		; InvalidBufferException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidBufferException@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidBufferException@@UAEPAXI@Z ENDP		; InvalidBufferException::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0InvalidBufferException@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV0@@Z PROC		; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV0@@Z ENDP		; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1InvalidBufferException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InvalidBufferException@@UAE@XZ PROC			; InvalidBufferException::~InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1InvalidBufferException@@UAE@XZ ENDP			; InvalidBufferException::~InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx

; 19   : 	InvalidBufferException(const std::string &msg) : out_of_range(msg){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1PathClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathClass@@QAE@XZ PROC				; PathClass::~PathClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BasePathClass@@QAE@XZ		; BasePathClass::~BasePathClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathClass@@QAE@XZ ENDP				; PathClass::~PathClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\asearch.h
;	COMDAT ?GetCost@BasePathClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCost@BasePathClass@@QAEMXZ PROC			; BasePathClass::GetCost, COMDAT
; _this$ = ecx

; 79   : 		costtype GetCost (void)					{ return cost; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCost@BasePathClass@@QAEMXZ ENDP			; BasePathClass::GetCost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\asearch.h
;	COMDAT ?GetLength@BasePathClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLength@BasePathClass@@QAEHXZ PROC			; BasePathClass::GetLength, COMDAT
; _this$ = ecx

; 77   : 		int GetLength (void)					{ return length; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLength@BasePathClass@@QAEHXZ ENDP			; BasePathClass::GetLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ PROC ; ListClass::GetFirstElement, COMDAT
; _this$ = ecx

; 82   : 		ListElementClass* GetFirstElement(void)		{ return front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ENDP ; ListClass::GetFirstElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetKey@ListElementClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKey@ListElementClass@@QAEFXZ PROC			; ListElementClass::GetKey, COMDAT
; _this$ = ecx

; 40   : 		short GetKey(void)							{ return key; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKey@ListElementClass@@QAEFXZ ENDP			; ListElementClass::GetKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetUserData@ListElementClass@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUserData@ListElementClass@@QAEPAXXZ PROC		; ListElementClass::GetUserData, COMDAT
; _this$ = ecx

; 39   : 		void* GetUserData(void)						{ return user_data; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUserData@ListElementClass@@QAEPAXXZ ENDP		; ListElementClass::GetUserData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetSEARCHtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSEARCHtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetSEARCHtimer, COMDAT
; _this$ = ecx

; 198  : 	virtual VU_TIME GetSEARCHtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSEARCHtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetAQUIREtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAQUIREtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetAQUIREtimer, COMDAT
; _this$ = ecx

; 197  : 	virtual VU_TIME GetAQUIREtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAQUIREtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetStepSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetStepSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetStepSearchMode, COMDAT
; _this$ = ecx

; 196  : 	virtual void SetStepSearchMode(uchar)					{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStepSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetStepSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSEARCHtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetSEARCHtimer, COMDAT
; _this$ = ecx

; 194  : 	virtual void SetSEARCHtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetAQUIREtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetAQUIREtimer, COMDAT
; _this$ = ecx

; 193  : 	virtual void SetAQUIREtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::HasAreaJamming, COMDAT
; _this$ = ecx

; 162  : 	virtual int HasAreaJamming (void)			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::HasAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::HasSPJamming, COMDAT
; _this$ = ecx

; 161  : 	virtual int HasSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::HasSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsAreaJamming, COMDAT
; _this$ = ecx

; 160  : 	virtual int IsAreaJamming (void)            { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSPJamming, COMDAT
; _this$ = ecx

; 159  : 	virtual int IsSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTaskForce@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTaskForce@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTaskForce, COMDAT
; _this$ = ecx

; 158  : 	virtual int IsTaskForce (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTaskForce@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTaskForce
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTeam@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeam@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTeam, COMDAT
; _this$ = ecx

; 157  : 	virtual int IsTeam (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeam@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPackage@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPackage@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsPackage, COMDAT
; _this$ = ecx

; 156  : 	virtual int IsPackage (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPackage@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSquadron@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSquadron@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSquadron, COMDAT
; _this$ = ecx

; 155  : 	virtual int IsSquadron (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSquadron@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsFlight@FalconEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlight@FalconEntity@@UBEHXZ PROC			; FalconEntity::IsFlight, COMDAT
; _this$ = ecx

; 154  : 	virtual int IsFlight() const				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlight@FalconEntity@@UBEHXZ ENDP			; FalconEntity::IsFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBrigade@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrigade@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBrigade, COMDAT
; _this$ = ecx

; 153  : 	virtual int IsBrigade (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrigade@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBrigade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBattalion@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBattalion@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBattalion, COMDAT
; _this$ = ecx

; 152  : 	virtual int IsBattalion (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBattalion@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBattalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsObjective@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjective@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsObjective, COMDAT
; _this$ = ecx

; 151  : 	virtual int IsObjective (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsObjective@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsDead@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsDead, COMDAT
; _this$ = ecx

; 144  : 	virtual int IsDead (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsExploding@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExploding@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsExploding, COMDAT
; _this$ = ecx

; 143  : 	virtual int IsExploding (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExploding@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsExploding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsWeapon@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWeapon@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsWeapon, COMDAT
; _this$ = ecx

; 142  : 	virtual int IsWeapon (void)   				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWeapon@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsShip@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShip@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsShip, COMDAT
; _this$ = ecx

; 141  : 	virtual int IsShip (void) 			        { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShip@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGroundVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGroundVehicle@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsGroundVehicle, COMDAT
; _this$ = ecx

; 140  : 	virtual int IsGroundVehicle (void) 			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGroundVehicle@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsGroundVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAirplane@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirplane@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsAirplane, COMDAT
; _this$ = ecx

; 139  : 	virtual int IsAirplane (void)	   			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirplane@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsAirplane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEject@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEject@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEject, COMDAT
; _this$ = ecx

; 138  : 	virtual int IsEject (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEject@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsHelicopter@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHelicopter@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsHelicopter, COMDAT
; _this$ = ecx

; 137  : 	virtual int IsHelicopter (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHelicopter@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsHelicopter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsStatic@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStatic@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsStatic, COMDAT
; _this$ = ecx

; 136  : 	virtual int IsStatic (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStatic@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsStatic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsVehicle@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsVehicle, COMDAT
; _this$ = ecx

; 135  : 	virtual int IsVehicle (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVehicle@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMover@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMover@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMover, COMDAT
; _this$ = ecx

; 134  : 	virtual int IsMover (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGun@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGun@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsGun, COMDAT
; _this$ = ecx

; 133  : 	virtual int IsGun (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGun@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBomb@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBomb@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBomb, COMDAT
; _this$ = ecx

; 132  : 	virtual int IsBomb (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBomb@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsLauncher@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsLauncher, COMDAT
; _this$ = ecx

; 131  : 	virtual int IsLauncher (void)               { return FALSE; } // MLR 3/4/2004 - rocket pods

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMissile@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMissile@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMissile, COMDAT
; _this$ = ecx

; 130  : 	virtual int IsMissile (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMissile@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?CombatClass@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatClass@FalconEntity@@UAEHXZ PROC			; FalconEntity::CombatClass, COMDAT
; _this$ = ecx

; 127  : 	virtual int CombatClass (void)				{ return 999; } // 2002-02-25 ADDED BY S.G. No combat class for non flight or non aircraft class

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 999				; 000003e7H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatClass@FalconEntity@@UAEHXZ ENDP			; FalconEntity::CombatClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetSearchMode, COMDAT
; _this$ = ecx

; 126  : 	virtual void SetSearchMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?ReturnToSearch@FalconEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReturnToSearch@FalconEntity@@UAEXXZ PROC		; FalconEntity::ReturnToSearch, COMDAT
; _this$ = ecx

; 124  : 	virtual void ReturnToSearch (void)			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReturnToSearch@FalconEntity@@UAEXXZ ENDP		; FalconEntity::ReturnToSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetRadarMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetRadarMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetRadarMode, COMDAT
; _this$ = ecx

; 123  : 	virtual void SetRadarMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRadarMode@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@FalconEntity@@UAEHXZ PROC			; FalconEntity::GetRadarMode, COMDAT
; _this$ = ecx

; 121  : 	virtual int GetRadarMode (void)				{ return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@FalconEntity@@UAEHXZ ENDP			; FalconEntity::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSimBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSimBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsSimBase, COMDAT
; _this$ = ecx

; 98   : 	virtual bool IsSimBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSimBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsSimBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ PROC	; VuBin<VuEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ENDP	; VuBin<VuEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@PBD@Z		; std::logic_error::logic_error
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 146  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1717 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1718 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1719 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 38   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@

; 39   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ PROC		; VuEntity::VuState, COMDAT
; _this$ = ecx

; 153  : 	VU_MEM VuState() const    { return vuState_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ ENDP		; VuEntity::VuState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??9VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator!=, COMDAT
; _this$ = ecx

; 111  : 	bool operator != (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 1
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 1
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
END
