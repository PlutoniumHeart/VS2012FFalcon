; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPTASK\Battalio.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ		; VuEntity::VuState
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ	; VuBin<VuEntity>::get
PUBLIC	?IsSimBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsSimBase
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?CombatClass@FalconEntity@@UAEHXZ		; FalconEntity::CombatClass
PUBLIC	?IsMissile@FalconEntity@@UAEHXZ			; FalconEntity::IsMissile
PUBLIC	?IsLauncher@FalconEntity@@UAEHXZ		; FalconEntity::IsLauncher
PUBLIC	?IsBomb@FalconEntity@@UAEHXZ			; FalconEntity::IsBomb
PUBLIC	?IsGun@FalconEntity@@UAEHXZ			; FalconEntity::IsGun
PUBLIC	?IsMover@FalconEntity@@UAEHXZ			; FalconEntity::IsMover
PUBLIC	?IsVehicle@FalconEntity@@UAEHXZ			; FalconEntity::IsVehicle
PUBLIC	?IsStatic@FalconEntity@@UAEHXZ			; FalconEntity::IsStatic
PUBLIC	?IsHelicopter@FalconEntity@@UAEHXZ		; FalconEntity::IsHelicopter
PUBLIC	?IsEject@FalconEntity@@UAEHXZ			; FalconEntity::IsEject
PUBLIC	?IsAirplane@FalconEntity@@UAEHXZ		; FalconEntity::IsAirplane
PUBLIC	?IsGroundVehicle@FalconEntity@@UAEHXZ		; FalconEntity::IsGroundVehicle
PUBLIC	?IsShip@FalconEntity@@UAEHXZ			; FalconEntity::IsShip
PUBLIC	?IsWeapon@FalconEntity@@UAEHXZ			; FalconEntity::IsWeapon
PUBLIC	?IsExploding@FalconEntity@@UAEHXZ		; FalconEntity::IsExploding
PUBLIC	?IsDead@FalconEntity@@UAEHXZ			; FalconEntity::IsDead
PUBLIC	?IsObjective@FalconEntity@@UAEHXZ		; FalconEntity::IsObjective
PUBLIC	?IsBrigade@FalconEntity@@UAEHXZ			; FalconEntity::IsBrigade
PUBLIC	?IsFlight@FalconEntity@@UBEHXZ			; FalconEntity::IsFlight
PUBLIC	?IsSquadron@FalconEntity@@UAEHXZ		; FalconEntity::IsSquadron
PUBLIC	?IsPackage@FalconEntity@@UAEHXZ			; FalconEntity::IsPackage
PUBLIC	?IsTeam@FalconEntity@@UAEHXZ			; FalconEntity::IsTeam
PUBLIC	?IsTaskForce@FalconEntity@@UAEHXZ		; FalconEntity::IsTaskForce
PUBLIC	?IsSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsSPJamming
PUBLIC	?IsAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsAreaJamming
PUBLIC	?HasSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasSPJamming
PUBLIC	?HasAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasAreaJamming
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	??1PathClass@@QAE@XZ				; PathClass::~PathClass
PUBLIC	??1SmallPathClass@@QAE@XZ			; SmallPathClass::~SmallPathClass
PUBLIC	??_GSmallPathClass@@QAEPAXI@Z			; SmallPathClass::`scalar deleting destructor'
PUBLIC	?GetWPLocation@WayPointClass@@QBEXPAF0@Z	; WayPointClass::GetWPLocation
PUBLIC	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
PUBLIC	??1InvalidBufferException@@UAE@XZ		; InvalidBufferException::~InvalidBufferException
PUBLIC	??0InvalidBufferException@@QAE@ABV0@@Z		; InvalidBufferException::InvalidBufferException
PUBLIC	??_GInvalidBufferException@@UAEPAXI@Z		; InvalidBufferException::`scalar deleting destructor'
PUBLIC	?memcpychk@@YAXPAXPAPAEIPAJ@Z			; memcpychk
PUBLIC	?GetCampID@CampBaseClass@@UAEFXZ		; CampBaseClass::GetCampID
PUBLIC	?GetTeam@CampBaseClass@@UAEEXZ			; CampBaseClass::GetTeam
PUBLIC	?GetCountry@CampBaseClass@@UAEEXZ		; CampBaseClass::GetCountry
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?IsCampBase@CampBaseClass@@UAE_NXZ		; CampBaseClass::IsCampBase
PUBLIC	?IsEmitting@CampBaseClass@@UAEHXZ		; CampBaseClass::IsEmitting
PUBLIC	?IsAwake@CampBaseClass@@QAEHXZ			; CampBaseClass::IsAwake
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z	; CampBaseClass::HasEntity
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?SetSpottedTime@CampBaseClass@@QAEXK@Z		; CampBaseClass::SetSpottedTime
PUBLIC	?SamSite@ObjectiveClass@@QAEHXZ			; ObjectiveClass::SamSite
PUBLIC	?ArtillerySite@ObjectiveClass@@QAEHXZ		; ObjectiveClass::ArtillerySite
PUBLIC	?RadarSite@ObjectiveClass@@QAEHXZ		; ObjectiveClass::RadarSite
PUBLIC	?NumLinks@ObjectiveClass@@QAEHXZ		; ObjectiveClass::NumLinks
PUBLIC	?GetLastCheck@UnitClass@@QAEKXZ			; UnitClass::GetLastCheck
PUBLIC	?GetUnitFlags@UnitClass@@QAEJXZ			; UnitClass::GetUnitFlags
PUBLIC	?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ		; UnitClass::GetCargoId
PUBLIC	?GetTactic@UnitClass@@QAEEXZ			; UnitClass::GetTactic
PUBLIC	?GetReinforcement@UnitClass@@QAEFXZ		; UnitClass::GetReinforcement
PUBLIC	?GetOdds@UnitClass@@QAEFXZ			; UnitClass::GetOdds
PUBLIC	?ShouldDeaggregate@UnitClass@@UAEHXZ		; UnitClass::ShouldDeaggregate
PUBLIC	?Father@UnitClass@@UBEHXZ			; UnitClass::Father
PUBLIC	?IsUnit@UnitClass@@UAEHXZ			; UnitClass::IsUnit
PUBLIC	?IsDead@UnitClass@@UBEHXZ			; UnitClass::IsDead
PUBLIC	?Ordered@UnitClass@@QBEHXZ			; UnitClass::Ordered
PUBLIC	?Parent@UnitClass@@QBEHXZ			; UnitClass::Parent
PUBLIC	?Engaged@UnitClass@@QBEHXZ			; UnitClass::Engaged
PUBLIC	?Moving@UnitClass@@QBEHXZ			; UnitClass::Moving
PUBLIC	?Refused@UnitClass@@QBEHXZ			; UnitClass::Refused
PUBLIC	?Combat@UnitClass@@QBEHXZ			; UnitClass::Combat
PUBLIC	?Broken@UnitClass@@QBEHXZ			; UnitClass::Broken
PUBLIC	?Losses@UnitClass@@QBEHXZ			; UnitClass::Losses
PUBLIC	?Targeted@UnitClass@@QBEHXZ			; UnitClass::Targeted
PUBLIC	?Retreating@UnitClass@@QBEHXZ			; UnitClass::Retreating
PUBLIC	?Supported@UnitClass@@QBEHXZ			; UnitClass::Supported
PUBLIC	?TempDest@UnitClass@@QBEHXZ			; UnitClass::TempDest
PUBLIC	?SimSetOrientation@UnitClass@@UAEXMMM@Z		; UnitClass::SimSetOrientation
PUBLIC	?SetUnitDestination@UnitClass@@QAEXFF@Z		; UnitClass::SetUnitDestination
PUBLIC	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z	; UnitClass::SetTarget
PUBLIC	?SetUnitMoved@UnitClass@@QAEXE@Z		; UnitClass::SetUnitMoved
PUBLIC	?SetUnitTactic@UnitClass@@QAEXE@Z		; UnitClass::SetUnitTactic
PUBLIC	?GetNumVehicles@UnitClass@@QAEHH@Z		; UnitClass::GetNumVehicles
PUBLIC	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ	; UnitClass::GetTarget
PUBLIC	?GetUnitMoved@UnitClass@@QBEHXZ			; UnitClass::GetUnitMoved
PUBLIC	?GetUnitTactic@UnitClass@@QBEHXZ		; UnitClass::GetUnitTactic
PUBLIC	?SetBurntFuel@UnitClass@@UAEXJ@Z		; UnitClass::SetBurntFuel
PUBLIC	?SetUnitMission@UnitClass@@UAEXE@Z		; UnitClass::SetUnitMission
PUBLIC	?SetUnitRole@UnitClass@@UAEXE@Z			; UnitClass::SetUnitRole
PUBLIC	?SetUnitPriority@UnitClass@@UAEXH@Z		; UnitClass::SetUnitPriority
PUBLIC	?SetUnitMissionID@UnitClass@@UAEXH@Z		; UnitClass::SetUnitMissionID
PUBLIC	?SetUnitMissionTarget@UnitClass@@UAEXH@Z	; UnitClass::SetUnitMissionTarget
PUBLIC	?SetUnitTOT@UnitClass@@UAEXK@Z			; UnitClass::SetUnitTOT
PUBLIC	?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitSquadron
PUBLIC	?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitAirbase
PUBLIC	?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z ; UnitClass::SetLoadout
PUBLIC	?GetNumberOfLoadouts@UnitClass@@UAEHXZ		; UnitClass::GetNumberOfLoadouts
PUBLIC	?GetBurntFuel@UnitClass@@UAEHXZ			; UnitClass::GetBurntFuel
PUBLIC	?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ ; UnitClass::GetUnitMission
PUBLIC	?GetUnitPriority@UnitClass@@UAEHXZ		; UnitClass::GetUnitPriority
PUBLIC	?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ ; UnitClass::GetUnitMissionTarget
PUBLIC	?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ ; UnitClass::GetUnitMissionTargetID
PUBLIC	?GetUnitMissionID@UnitClass@@UAEHXZ		; UnitClass::GetUnitMissionID
PUBLIC	?GetUnitTOT@UnitClass@@UAEKXZ			; UnitClass::GetUnitTOT
PUBLIC	?GetUnitSquadron@UnitClass@@UAEPAV1@XZ		; UnitClass::GetUnitSquadron
PUBLIC	?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitSquadronID
PUBLIC	?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ ; UnitClass::GetUnitAirbase
PUBLIC	?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitAirbaseID
PUBLIC	?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z ; UnitClass::LoadWeapons
PUBLIC	?DumpWeapons@UnitClass@@UAEHXZ			; UnitClass::DumpWeapons
PUBLIC	?ETA@UnitClass@@UAEKXZ				; UnitClass::ETA
PUBLIC	?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ ; UnitClass::GetKnownEmitters
PUBLIC	?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z ; UnitClass::BuildMission
PUBLIC	?UseFuel@UnitClass@@UAEXJ@Z			; UnitClass::UseFuel
PUBLIC	?SetUnitSpecialty@UnitClass@@UAEXH@Z		; UnitClass::SetUnitSpecialty
PUBLIC	?SetSquadronFuel@UnitClass@@UAEXJ@Z		; UnitClass::SetSquadronFuel
PUBLIC	?SetUnitStores@UnitClass@@UAEXHE@Z		; UnitClass::SetUnitStores
PUBLIC	?SetLastResupply@UnitClass@@UAEXH@Z		; UnitClass::SetLastResupply
PUBLIC	?GetUnitSpecialty@UnitClass@@UAEHXZ		; UnitClass::GetUnitSpecialty
PUBLIC	?GetSquadronFuel@UnitClass@@UAEJXZ		; UnitClass::GetSquadronFuel
PUBLIC	?GetUnitStores@UnitClass@@UAEEH@Z		; UnitClass::GetUnitStores
PUBLIC	?GetLastResupply@UnitClass@@UAEHXZ		; UnitClass::GetLastResupply
PUBLIC	?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z ; UnitClass::BuildPackage
PUBLIC	?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z	; UnitClass::SetUnitAssemblyPoint
PUBLIC	?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z	; UnitClass::GetUnitAssemblyPoint
PUBLIC	?SetUnitOrders@UnitClass@@UAEXH@Z		; UnitClass::SetUnitOrders
PUBLIC	?SetUnitMode@UnitClass@@UAEXH@Z			; UnitClass::SetUnitMode
PUBLIC	?SetUnitPosition@UnitClass@@UAEXH@Z		; UnitClass::SetUnitPosition
PUBLIC	?SetUnitDivision@UnitClass@@UAEXH@Z		; UnitClass::SetUnitDivision
PUBLIC	?SetUnitHeading@UnitClass@@UAEXH@Z		; UnitClass::SetUnitHeading
PUBLIC	?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ; UnitClass::GetUnitPrimaryObj
PUBLIC	?GetUnitMode@UnitClass@@UAEHXZ			; UnitClass::GetUnitMode
PUBLIC	?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z	; UnitClass::SetUnitCurrentDestination
PUBLIC	?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z ; UnitClass::GetUnitCurrentDestination
PUBLIC	?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ	; UnitClass::GetFirstUnitElement
PUBLIC	?GetNextUnitElement@UnitClass@@UBEPAV1@XZ	; UnitClass::GetNextUnitElement
PUBLIC	?GetUnitElement@UnitClass@@UAEPAV1@H@Z		; UnitClass::GetUnitElement
PUBLIC	?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z	; UnitClass::GetUnitElementByID
PUBLIC	?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z	; UnitClass::GetPrevUnitElement
PUBLIC	?AddUnitChild@UnitClass@@UAEXPAV1@@Z		; UnitClass::AddUnitChild
PUBLIC	?DisposeChildren@UnitClass@@UAEXXZ		; UnitClass::DisposeChildren
PUBLIC	?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z		; UnitClass::RemoveChild
PUBLIC	?ReorganizeUnit@UnitClass@@UAEXXZ		; UnitClass::ReorganizeUnit
PUBLIC	?UpdateParentStatistics@UnitClass@@UAEHXZ	; UnitClass::UpdateParentStatistics
PUBLIC	??_GUnitDeaggregationData@@QAEPAXI@Z		; UnitDeaggregationData::`scalar deleting destructor'
PUBLIC	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
PUBLIC	?OnGround@GroundUnitClass@@UAEHXZ		; GroundUnitClass::OnGround
PUBLIC	?GetVt@GroundUnitClass@@UBEMXZ			; GroundUnitClass::GetVt
PUBLIC	?GetKias@GroundUnitClass@@UBEMXZ		; GroundUnitClass::GetKias
PUBLIC	?GetOrders@GroundUnitClass@@QAEEXZ		; GroundUnitClass::GetOrders
PUBLIC	?SetUnitOrders@GroundUnitClass@@UAEXE@Z		; GroundUnitClass::SetUnitOrders
PUBLIC	?SetUnitDivision@GroundUnitClass@@UAEXF@Z	; GroundUnitClass::SetUnitDivision
PUBLIC	?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ; GroundUnitClass::SetUnitPrimaryObj
PUBLIC	?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ; GroundUnitClass::SetUnitSecondaryObj
PUBLIC	?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z ; GroundUnitClass::SetUnitObjective
PUBLIC	?GetUnitOrders@GroundUnitClass@@UAEHXZ		; GroundUnitClass::GetUnitOrders
PUBLIC	?GetUnitDivision@GroundUnitClass@@UAEHXZ	; GroundUnitClass::GetUnitDivision
PUBLIC	?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ; GroundUnitClass::GetUnitPrimaryObj
PUBLIC	?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ; GroundUnitClass::GetUnitSecondaryObj
PUBLIC	?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ; GroundUnitClass::GetUnitObjective
PUBLIC	?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ; GroundUnitClass::GetUnitPrimaryObjID
PUBLIC	?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ; GroundUnitClass::GetUnitSecondaryObjID
PUBLIC	?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ ; GroundUnitClass::GetUnitObjectiveID
PUBLIC	??0BattalionClass@@QAE@GPAVUnitClass@@@Z	; BattalionClass::BattalionClass
PUBLIC	??0BattalionClass@@QAE@PAPAEPAJ@Z		; BattalionClass::BattalionClass
PUBLIC	??1BattalionClass@@UAE@XZ			; BattalionClass::~BattalionClass
PUBLIC	?InitData@BattalionClass@@UAEXXZ		; BattalionClass::InitData
PUBLIC	?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z ; BattalionClass::InitLocalData
PUBLIC	?SaveSize@BattalionClass@@UAEHXZ		; BattalionClass::SaveSize
PUBLIC	?Save@BattalionClass@@UAEHPAPAE@Z		; BattalionClass::Save
PUBLIC	?Handle@BattalionClass@@UAEHPAVVuFullUpdateEvent@@@Z ; BattalionClass::Handle
PUBLIC	?IsBattalion@BattalionClass@@UAEHXZ		; BattalionClass::IsBattalion
PUBLIC	?SetFullStrength@BattalionClass@@QAEXE@Z	; BattalionClass::SetFullStrength
PUBLIC	?MoveUnit@BattalionClass@@UAEHK@Z		; BattalionClass::MoveUnit
PUBLIC	?DoCombat@BattalionClass@@UAEHXZ		; BattalionClass::DoCombat
PUBLIC	?GetUnitDeaggregationData@BattalionClass@@UAEPAVUnitDeaggregationData@@XZ ; BattalionClass::GetUnitDeaggregationData
PUBLIC	?ClearDeaggregationData@BattalionClass@@UAEXXZ	; BattalionClass::ClearDeaggregationData
PUBLIC	?GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z ; BattalionClass::GetDeaggregationPoint
PUBLIC	?Reaction@BattalionClass@@UAEHPAVCampBaseClass@@HM@Z ; BattalionClass::Reaction
PUBLIC	?ChooseTactic@BattalionClass@@UAEHXZ		; BattalionClass::ChooseTactic
PUBLIC	?CheckTactic@BattalionClass@@UAEHH@Z		; BattalionClass::CheckTactic
PUBLIC	?Real@BattalionClass@@UAEHXZ			; BattalionClass::Real
PUBLIC	?SetUnitOrders@BattalionClass@@UAEXHVVU_ID@@@Z	; BattalionClass::SetUnitOrders
PUBLIC	?PickFinalLocation@BattalionClass@@QAEXXZ	; BattalionClass::PickFinalLocation
PUBLIC	?GetCruiseSpeed@BattalionClass@@UBEHXZ		; BattalionClass::GetCruiseSpeed
PUBLIC	?GetCombatSpeed@BattalionClass@@UBEHXZ		; BattalionClass::GetCombatSpeed
PUBLIC	?GetMaxSpeed@BattalionClass@@UBEHXZ		; BattalionClass::GetMaxSpeed
PUBLIC	?GetUnitSpeed@BattalionClass@@UBEHXZ		; BattalionClass::GetUnitSpeed
PUBLIC	?MaxUpdateTime@BattalionClass@@UBEKXZ		; BattalionClass::MaxUpdateTime
PUBLIC	?CombatTime@BattalionClass@@UAEKXZ		; BattalionClass::CombatTime
PUBLIC	?GetUnitSupplyNeed@BattalionClass@@UAEHH@Z	; BattalionClass::GetUnitSupplyNeed
PUBLIC	?GetUnitFuelNeed@BattalionClass@@UAEHH@Z	; BattalionClass::GetUnitFuelNeed
PUBLIC	?SupplyUnit@BattalionClass@@UAEXHH@Z		; BattalionClass::SupplyUnit
PUBLIC	?GetDetectionRange@BattalionClass@@UAEHH@Z	; BattalionClass::GetDetectionRange
PUBLIC	?GetElectronicDetectionRange@BattalionClass@@UAEHH@Z ; BattalionClass::GetElectronicDetectionRange
PUBLIC	?GetRadarMode@BattalionClass@@UAEHXZ		; BattalionClass::GetRadarMode
PUBLIC	?GetSearchMode@BattalionClass@@UAEHXZ		; BattalionClass::GetSearchMode
PUBLIC	?SetRadarMode@BattalionClass@@UAEXE@Z		; BattalionClass::SetRadarMode
PUBLIC	?ReturnToSearch@BattalionClass@@UAEXXZ		; BattalionClass::ReturnToSearch
PUBLIC	?SetSearchMode@BattalionClass@@UAEXE@Z		; BattalionClass::SetSearchMode
PUBLIC	?CanShootWeapon@BattalionClass@@UAEHH@Z		; BattalionClass::CanShootWeapon
PUBLIC	?StepRadar@BattalionClass@@UAEHHHM@Z		; BattalionClass::StepRadar
PUBLIC	?GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z ; BattalionClass::GetVehicleDeagData
PUBLIC	?GetMissilesFlying@BattalionClass@@UAEHXZ	; BattalionClass::GetMissilesFlying
PUBLIC	?SetUnitLastMove@BattalionClass@@UAEXK@Z	; BattalionClass::SetUnitLastMove
PUBLIC	?SetCombatTime@BattalionClass@@UAEXK@Z		; BattalionClass::SetCombatTime
PUBLIC	?SetUnitParent@BattalionClass@@UAEXPAVUnitClass@@@Z ; BattalionClass::SetUnitParent
PUBLIC	?SetUnitSupply@BattalionClass@@UAEXH@Z		; BattalionClass::SetUnitSupply
PUBLIC	?SetUnitFatigue@BattalionClass@@UAEXH@Z		; BattalionClass::SetUnitFatigue
PUBLIC	?SetUnitMorale@BattalionClass@@UAEXH@Z		; BattalionClass::SetUnitMorale
PUBLIC	?SetUnitHeading@BattalionClass@@UAEXE@Z		; BattalionClass::SetUnitHeading
PUBLIC	?SetUnitNextMove@BattalionClass@@UAEXXZ		; BattalionClass::SetUnitNextMove
PUBLIC	?ClearUnitPath@BattalionClass@@UAEXXZ		; BattalionClass::ClearUnitPath
PUBLIC	?SetLastResupplyTime@BattalionClass@@UAEXK@Z	; BattalionClass::SetLastResupplyTime
PUBLIC	?SetUnitPosition@BattalionClass@@UAEXE@Z	; BattalionClass::SetUnitPosition
PUBLIC	?SimSetLocation@BattalionClass@@UAEXMMM@Z	; BattalionClass::SimSetLocation
PUBLIC	?GetRealPosition@BattalionClass@@UAEXPAM00@Z	; BattalionClass::GetRealPosition
PUBLIC	?HandleRequestReceipt@BattalionClass@@UAEXHHVVU_ID@@@Z ; BattalionClass::HandleRequestReceipt
PUBLIC	?GetMoveTime@BattalionClass@@UAEKXZ		; BattalionClass::GetMoveTime
PUBLIC	?GetCombatTime@BattalionClass@@UAEKXZ		; BattalionClass::GetCombatTime
PUBLIC	?GetUnitParent@BattalionClass@@UBEPAVUnitClass@@XZ ; BattalionClass::GetUnitParent
PUBLIC	?GetUnitParentID@BattalionClass@@UAE?AVVU_ID@@XZ ; BattalionClass::GetUnitParentID
PUBLIC	?GetAirTargetID@BattalionClass@@UAE?AVVU_ID@@XZ	; BattalionClass::GetAirTargetID
PUBLIC	?GetAirTarget@BattalionClass@@UAEPAVFalconEntity@@XZ ; BattalionClass::GetAirTarget
PUBLIC	?SetAirTarget@BattalionClass@@UAEXPAVFalconEntity@@@Z ; BattalionClass::SetAirTarget
PUBLIC	?GetUnitSupply@BattalionClass@@UAEHXZ		; BattalionClass::GetUnitSupply
PUBLIC	?GetUnitFatigue@BattalionClass@@UAEHXZ		; BattalionClass::GetUnitFatigue
PUBLIC	?GetUnitMorale@BattalionClass@@UAEHXZ		; BattalionClass::GetUnitMorale
PUBLIC	?GetUnitHeading@BattalionClass@@UAEHXZ		; BattalionClass::GetUnitHeading
PUBLIC	?GetNextMoveDirection@BattalionClass@@UAEHXZ	; BattalionClass::GetNextMoveDirection
PUBLIC	?GetUnitElement@BattalionClass@@UAEHXZ		; BattalionClass::GetUnitElement
PUBLIC	?GetUnitPosition@BattalionClass@@UAEHXZ		; BattalionClass::GetUnitPosition
PUBLIC	?RallyUnit@BattalionClass@@UAEHH@Z		; BattalionClass::RallyUnit
PUBLIC	?GetLastResupplyTime@BattalionClass@@UAEKXZ	; BattalionClass::GetLastResupplyTime
PUBLIC	?GetSpeedModifier@BattalionClass@@QBEMXZ	; BattalionClass::GetSpeedModifier
PUBLIC	?AdjustForSupply@BattalionClass@@UAEMXZ		; BattalionClass::AdjustForSupply
PUBLIC	?IncrementTime@BattalionClass@@UAEXK@Z		; BattalionClass::IncrementTime
PUBLIC	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty
PUBLIC	?WriteDirty@BattalionClass@@QAEXPAPAE@Z		; BattalionClass::WriteDirty
PUBLIC	?ReadDirty@BattalionClass@@QAEXPAPAEPAJ@Z	; BattalionClass::ReadDirty
PUBLIC	?SetAQUIREtimer@BattalionClass@@UAEXK@Z		; BattalionClass::SetAQUIREtimer
PUBLIC	?SetSEARCHtimer@BattalionClass@@UAEXK@Z		; BattalionClass::SetSEARCHtimer
PUBLIC	?SetStepSearchMode@BattalionClass@@UAEXE@Z	; BattalionClass::SetStepSearchMode
PUBLIC	?GetAQUIREtimer@BattalionClass@@UAEKXZ		; BattalionClass::GetAQUIREtimer
PUBLIC	?GetSEARCHtimer@BattalionClass@@UAEKXZ		; BattalionClass::GetSEARCHtimer
PUBLIC	??_GBattalionClass@@UAEPAXI@Z			; BattalionClass::`scalar deleting destructor'
PUBLIC	?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z ; NewBattalion
PUBLIC	?GetElement@BrigadeClass@@QAE?AVVU_ID@@H@Z	; BrigadeClass::GetElement
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?FindBestHeading@@YAEPAVObjectiveClass@@HH@Z	; FindBestHeading
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_7InvalidBufferException@@6B@			; InvalidBufferException::`vftable'
PUBLIC	??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ ; `string'
PUBLIC	__TI4?AVInvalidBufferException@@
PUBLIC	__CTA4?AVInvalidBufferException@@
PUBLIC	??_R0?AVInvalidBufferException@@@8		; InvalidBufferException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7BattalionClass@@6B@				; BattalionClass::`vftable'
PUBLIC	??_C@_0BF@NPAMKIGD@?$CF08x?5BattalionClass?5?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4InvalidBufferException@@6B@		; InvalidBufferException::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidBufferException@@8			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidBufferException@@8			; InvalidBufferException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidBufferException@@8		; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4BattalionClass@@6B@			; BattalionClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBattalionClass@@@8			; BattalionClass `RTTI Type Descriptor'
PUBLIC	??_R3BattalionClass@@8				; BattalionClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BattalionClass@@8				; BattalionClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BattalionClass@@8			; BattalionClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@GroundUnitClass@@8		; GroundUnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVGroundUnitClass@@@8			; GroundUnitClass `RTTI Type Descriptor'
PUBLIC	??_R3GroundUnitClass@@8				; GroundUnitClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2GroundUnitClass@@8				; GroundUnitClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UnitClass@@8			; UnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVUnitClass@@@8				; UnitClass `RTTI Type Descriptor'
PUBLIC	??_R3UnitClass@@8				; UnitClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UnitClass@@8				; UnitClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CampBaseClass@@8			; CampBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCampBaseClass@@@8			; CampBaseClass `RTTI Type Descriptor'
PUBLIC	??_R3CampBaseClass@@8				; CampBaseClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CampBaseClass@@8				; CampBaseClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FalconEntity@@8			; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFalconEntity@@@8			; FalconEntity `RTTI Type Descriptor'
PUBLIC	??_R3FalconEntity@@8				; FalconEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FalconEntity@@8				; FalconEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuEntity@@8			; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuEntity@@@8				; VuEntity `RTTI Type Descriptor'
PUBLIC	??_R3VuEntity@@8				; VuEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuEntity@@8				; VuEntity::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3c8efa34
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f19999a
PUBLIC	__real@3f333333
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f59999a
PUBLIC	__real@3f693e32
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42200000
PUBLIC	__real@42340000
PUBLIC	__real@42c80000
PUBLIC	__real@43480000
PUBLIC	__real@437a0000
PUBLIC	__real@447a0000
PUBLIC	__real@45bb8000
PUBLIC	__real@8000000000000000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_fflush:PROC
EXTRN	_fprintf:PROC
EXTRN	_sprintf:PROC
EXTRN	_abs:PROC
EXTRN	_rand:PROC
EXTRN	_atan:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z:PROC ; VuEntity::CustomCollisionCheck
EXTRN	?TerrainCollisionCheck@VuEntity@@UAEEXZ:PROC	; VuEntity::TerrainCollisionCheck
EXTRN	?IsTarget@VuEntity@@UAEEXZ:PROC			; VuEntity::IsTarget
EXTRN	?IsSession@VuEntity@@UAEEXZ:PROC		; VuEntity::IsSession
EXTRN	?IsGroup@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGroup
EXTRN	?IsGame@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGame
EXTRN	?IsCamera@VuEntity@@UBEEXZ:PROC			; VuEntity::IsCamera
EXTRN	?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?InsertionCallback@VuEntity@@MAEHXZ:PROC	; VuEntity::InsertionCallback
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Find@VuCollection@@QBE_NPAVVuEntity@@@Z:PROC	; VuCollection::Find
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?Save@FalconEntity@@UAEHPAU_iobuf@@@Z:PROC	; FalconEntity::Save
EXTRN	?CleanupData@FalconEntity@@UAEXXZ:PROC		; FalconEntity::CleanupData
EXTRN	?RemovalCallback@FalconEntity@@UAEHXZ:PROC	; FalconEntity::RemovalCallback
EXTRN	?GetDomain@FalconEntity@@UAEEXZ:PROC		; FalconEntity::GetDomain
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z:PROC ; FalconEntity::MakeDirty
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	??1BasePathClass@@QAE@XZ:PROC			; BasePathClass::~BasePathClass
EXTRN	?GetNextDirection@BasePathClass@@QAEHXZ:PROC	; BasePathClass::GetNextDirection
EXTRN	?StepPath@BasePathClass@@QAEXXZ:PROC		; BasePathClass::StepPath
EXTRN	?ClearPath@BasePathClass@@QAEXXZ:PROC		; BasePathClass::ClearPath
EXTRN	?CopyPath@BasePathClass@@QAEHPAV1@@Z:PROC	; BasePathClass::CopyPath
EXTRN	??0PathClass@@QAE@XZ:PROC			; PathClass::PathClass
EXTRN	??0SmallPathClass@@QAE@XZ:PROC			; SmallPathClass::SmallPathClass
EXTRN	??_EInvalidBufferException@@UAEPAXI@Z:PROC	; InvalidBufferException::`vector deleting destructor'
EXTRN	?GetIdFromNamespace@@YAKAAVIdNamespace@@@Z:PROC	; GetIdFromNamespace
EXTRN	?GetTeam@@YAEE@Z:PROC				; GetTeam
EXTRN	?SetOwner@CampBaseClass@@UAEXE@Z:PROC		; CampBaseClass::SetOwner
EXTRN	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z:PROC ; CampBaseClass::MakeCampBaseDirty
EXTRN	?InitData@CampBaseClass@@UAEXXZ:PROC		; CampBaseClass::InitData
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuEvent@@@Z:PROC	; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuPositionUpdateEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuEntityCollisionEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuTransferEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuSessionEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?SetEmitting@CampBaseClass@@QAEXH@Z:PROC	; CampBaseClass::SetEmitting
EXTRN	?GetVisualDetectionRange@@YAHH@Z:PROC		; GetVisualDetectionRange
EXTRN	?SetAbandoned@ObjectiveClass@@QAEXH@Z:PROC	; ObjectiveClass::SetAbandoned
EXTRN	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z:PROC	; ObjectiveClass::GetNeighbor
EXTRN	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ:PROC ; ObjectiveClass::GetObjectiveClassData
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?TimeOfDayGeneral@@YAHXZ:PROC			; TimeOfDayGeneral
EXTRN	?CheckTeam@@YAHHH@Z:PROC			; CheckTeam
EXTRN	?CheckUnitType@@YAHHHH@Z:PROC			; CheckUnitType
EXTRN	?CheckRange@@YAHHH@Z:PROC			; CheckRange
EXTRN	?CheckAction@@YAHHH@Z:PROC			; CheckAction
EXTRN	?CheckStatus@@YAHHH@Z:PROC			; CheckStatus
EXTRN	?CheckLosses@@YAHHH@Z:PROC			; CheckLosses
EXTRN	?CheckEngaged@@YAHHH@Z:PROC			; CheckEngaged
EXTRN	?CheckCombat@@YAHHH@Z:PROC			; CheckCombat
EXTRN	?CheckRetreating@@YAHHH@Z:PROC			; CheckRetreating
EXTRN	?CheckOwned@@YAHHH@Z:PROC			; CheckOwned
EXTRN	?CheckAirborne@@YAHHH@Z:PROC			; CheckAirborne
EXTRN	?CheckMarine@@YAHHH@Z:PROC			; CheckMarine
EXTRN	?CheckOdds@@YAHHH@Z:PROC			; CheckOdds
EXTRN	?CheckRole@@YAHHH@Z:PROC			; CheckRole
EXTRN	?CheckSpecial@@YAHH@Z:PROC			; CheckSpecial
EXTRN	?CheckWeapons@@YAHH@Z:PROC			; CheckWeapons
EXTRN	?GetTacticPriority@@YAHH@Z:PROC			; GetTacticPriority
EXTRN	?SetLastCheck@UnitClass@@QAEXK@Z:PROC		; UnitClass::SetLastCheck
EXTRN	?SetUnitFlags@UnitClass@@QAEXJ@Z:PROC		; UnitClass::SetUnitFlags
EXTRN	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z:PROC	; UnitClass::SetCargoId
EXTRN	?SetReinforcement@UnitClass@@QAEXF@Z:PROC	; UnitClass::SetReinforcement
EXTRN	?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z:PROC ; UnitClass::SendDeaggregateData
EXTRN	?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z:PROC ; UnitClass::RecordCurrentState
EXTRN	?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:PROC ; UnitClass::Deaggregate
EXTRN	?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:PROC ; UnitClass::Reaggregate
EXTRN	?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:PROC ; UnitClass::TransferOwnership
EXTRN	?Wake@UnitClass@@UAEHXZ:PROC			; UnitClass::Wake
EXTRN	?Sleep@UnitClass@@UAEHXZ:PROC			; UnitClass::Sleep
EXTRN	?InsertInSimLists@UnitClass@@UAEXMM@Z:PROC	; UnitClass::InsertInSimLists
EXTRN	?RemoveFromSimLists@UnitClass@@UAEXXZ:PROC	; UnitClass::RemoveFromSimLists
EXTRN	?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z:PROC	; UnitClass::DeaggregateFromData
EXTRN	?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z:PROC	; UnitClass::ReaggregateFromData
EXTRN	?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z:PROC ; UnitClass::TransferOwnershipFromData
EXTRN	?ResetPlayerStatus@UnitClass@@UAEHXZ:PROC	; UnitClass::ResetPlayerStatus
EXTRN	?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z:PROC ; UnitClass::ApplyDamage
EXTRN	?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z:PROC ; UnitClass::ApplyDamage
EXTRN	?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z:PROC ; UnitClass::DecodeDamageData
EXTRN	?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z:PROC ; UnitClass::CollectWeapons
EXTRN	?GetDamageModifiers@UnitClass@@UAEPAEXZ:PROC	; UnitClass::GetDamageModifiers
EXTRN	?GetName@UnitClass@@UAEPADPADHH@Z:PROC		; UnitClass::GetName
EXTRN	?GetFullName@UnitClass@@UAEPADPADHH@Z:PROC	; UnitClass::GetFullName
EXTRN	?GetDivisionName@UnitClass@@UAEPADPADHH@Z:PROC	; UnitClass::GetDivisionName
EXTRN	?GetHitChance@UnitClass@@UAEHHH@Z:PROC		; UnitClass::GetHitChance
EXTRN	?GetAproxHitChance@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetAproxHitChance
EXTRN	?GetCombatStrength@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetCombatStrength
EXTRN	?GetAproxCombatStrength@UnitClass@@UAEHHH@Z:PROC ; UnitClass::GetAproxCombatStrength
EXTRN	?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z:PROC ; UnitClass::GetWeaponRange
EXTRN	?GetAproxWeaponRange@UnitClass@@UAEHH@Z:PROC	; UnitClass::GetAproxWeaponRange
EXTRN	?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z:PROC ; UnitClass::CanDetect
EXTRN	?GetComponentLocation@UnitClass@@UAEXPAF0H@Z:PROC ; UnitClass::GetComponentLocation
EXTRN	?GetComponentAltitude@UnitClass@@UAEHH@Z:PROC	; UnitClass::GetComponentAltitude
EXTRN	?GetRCSFactor@UnitClass@@UAEMXZ:PROC		; UnitClass::GetRCSFactor
EXTRN	?GetIRFactor@UnitClass@@UAEMXZ:PROC		; UnitClass::GetIRFactor
EXTRN	?GetNumberOfArcs@UnitClass@@UAEHXZ:PROC		; UnitClass::GetNumberOfArcs
EXTRN	?GetArcRatio@UnitClass@@UAEMH@Z:PROC		; UnitClass::GetArcRatio
EXTRN	?GetArcRange@UnitClass@@UAEMH@Z:PROC		; UnitClass::GetArcRange
EXTRN	?GetArcAngle@UnitClass@@UAEXHPAM0@Z:PROC	; UnitClass::GetArcAngle
EXTRN	?GetRadarType@UnitClass@@UAEHXZ:PROC		; UnitClass::GetRadarType
EXTRN	?ChangeUnitLocation@UnitClass@@QAEHE@Z:PROC	; UnitClass::ChangeUnitLocation
EXTRN	?SetAssigned@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetAssigned
EXTRN	?SetOrdered@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetOrdered
EXTRN	?SetParent@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetParent
EXTRN	?SetEngaged@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetEngaged
EXTRN	?SetMoving@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetMoving
EXTRN	?SetRefused@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetRefused
EXTRN	?SetBroken@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetBroken
EXTRN	?SetLosses@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetLosses
EXTRN	?SetTargeted@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetTargeted
EXTRN	?SetRetreating@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetRetreating
EXTRN	?SetSupported@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetSupported
EXTRN	?SetTempDest@UnitClass@@QAEXH@Z:PROC		; UnitClass::SetTempDest
EXTRN	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ:PROC ; UnitClass::GetUnitClassData
EXTRN	?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z:PROC ; UnitClass::GetBestVehicleWeapon
EXTRN	?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z:PROC ; UnitClass::GetVehicleHitChance
EXTRN	?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z:PROC ; UnitClass::GetVehicleCombatStrength
EXTRN	?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z:PROC ; UnitClass::GetVehicleRange
EXTRN	?GetUnitWeaponId@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetUnitWeaponId
EXTRN	?GetUnitWeaponCount@UnitClass@@UAEHHH@Z:PROC	; UnitClass::GetUnitWeaponCount
EXTRN	?GetUnitDestination@UnitClass@@QAEXPAF0@Z:PROC	; UnitClass::GetUnitDestination
EXTRN	?GetCampTarget@UnitClass@@QAEPAVCampBaseClass@@XZ:PROC ; UnitClass::GetCampTarget
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetFullstrengthVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetFullstrengthVehicles
EXTRN	?KillUnit@UnitClass@@QAEXXZ:PROC		; UnitClass::KillUnit
EXTRN	?GetUnitFormation@UnitClass@@QBEHXZ:PROC	; UnitClass::GetUnitFormation
EXTRN	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z:PROC ; UnitClass::GetUnitGridPath
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?FinishUnitWP@UnitClass@@QAEXXZ:PROC		; UnitClass::FinishUnitWP
EXTRN	?DisposeWayPoints@UnitClass@@QAEXXZ:PROC	; UnitClass::DisposeWayPoints
EXTRN	??1UnitDeaggregationData@@QAE@XZ:PROC		; UnitDeaggregationData::~UnitDeaggregationData
EXTRN	?DistSqu@@YAHFFFF@Z:PROC			; DistSqu
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?DistanceToFront@@YAMFF@Z:PROC			; DistanceToFront
EXTRN	?DirectionTo@@YAEFFFF@Z:PROC			; DirectionTo
EXTRN	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z:PROC ; FindNearestObjective
EXTRN	?GetObjectiveByXY@@YAPAVObjectiveClass@@FF@Z:PROC ; GetObjectiveByXY
EXTRN	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z:PROC	; ConvertSimToGrid
EXTRN	?GroundExperienceAdjustment@@YAME@Z:PROC	; GroundExperienceAdjustment
EXTRN	?GetPOData@@YAPAUPrimaryObjectiveData@@PAVObjectiveClass@@@Z:PROC ; GetPOData
EXTRN	??0GroundUnitClass@@QAE@GK@Z:PROC		; GroundUnitClass::GroundUnitClass
EXTRN	??0GroundUnitClass@@QAE@PAPAEPAJ@Z:PROC		; GroundUnitClass::GroundUnitClass
EXTRN	??1GroundUnitClass@@UAE@XZ:PROC			; GroundUnitClass::~GroundUnitClass
EXTRN	?SaveSize@GroundUnitClass@@UAEHXZ:PROC		; GroundUnitClass::SaveSize
EXTRN	?Save@GroundUnitClass@@UAEHPAPAE@Z:PROC		; GroundUnitClass::Save
EXTRN	?Handle@GroundUnitClass@@UAEHPAVVuFullUpdateEvent@@@Z:PROC ; GroundUnitClass::Handle
EXTRN	?GetMovementType@GroundUnitClass@@UAE?AW4MoveType@@XZ:PROC ; GroundUnitClass::GetMovementType
EXTRN	?GetObjMovementType@GroundUnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z:PROC ; GroundUnitClass::GetObjMovementType
EXTRN	?DetectOnMove@GroundUnitClass@@UAEHXZ:PROC	; GroundUnitClass::DetectOnMove
EXTRN	?ChooseTarget@GroundUnitClass@@UAEHXZ:PROC	; GroundUnitClass::ChooseTarget
EXTRN	?CheckForSurrender@GroundUnitClass@@UAEHXZ:PROC	; GroundUnitClass::CheckForSurrender
EXTRN	?GetUnitNormalRole@GroundUnitClass@@UAEHXZ:PROC	; GroundUnitClass::GetUnitNormalRole
EXTRN	?GetUnitCurrentRole@GroundUnitClass@@UBEHXZ:PROC ; GroundUnitClass::GetUnitCurrentRole
EXTRN	?BuildMission@GroundUnitClass@@UAEHXZ:PROC	; GroundUnitClass::BuildMission
EXTRN	??_EBattalionClass@@UAEPAXI@Z:PROC		; BattalionClass::`vector deleting destructor'
EXTRN	?BuildGroundWP@@YAHPAVUnitClass@@@Z:PROC	; BuildGroundWP
EXTRN	?FindBestCover@@YAXFFEPAF0H@Z:PROC		; FindBestCover
EXTRN	?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z:PROC ; FindRetreatPath
EXTRN	?RequestSupport@@YAHPAVUnitClass@@0@Z:PROC	; RequestSupport
EXTRN	?IsValidObjective@GroundTaskingManagerClass@@QAEHHPAVObjectiveClass@@@Z:PROC ; GroundTaskingManagerClass::IsValidObjective
EXTRN	?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z:PROC ; DoCombat
EXTRN	?GetFirstPt@@YAHH@Z:PROC			; GetFirstPt
EXTRN	?GetNextPt@@YAHH@Z:PROC				; GetNextPt
EXTRN	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z:PROC ; TranslatePointData
EXTRN	?GetMEA@TMap@@QAEMMM@Z:PROC			; TMap::GetMEA
EXTRN	?GetArrivalSpeed@@YAHPBVUnitClass@@@Z:PROC	; GetArrivalSpeed
EXTRN	?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z:PROC ; PositionToSupportUnit
EXTRN	?FindVehiclePosition@@YAXPAVSimInitDataClass@@@Z:PROC ; FindVehiclePosition
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?PtHeaderDataTable@@3PAUPtHeaderDataType@@A:DWORD ; PtHeaderDataTable
EXTRN	?PtDataTable@@3PAUPtDataType@@A:DWORD		; PtDataTable
EXTRN	?DDP@@3PAUDirtyDataClassType@@A:DWORD		; DDP
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?NonVolatileNS@@3VIdNamespace@@A:BYTE		; NonVolatileNS
EXTRN	?dx@@3PAFA:BYTE					; dx
EXTRN	?dy@@3PAFA:BYTE					; dy
EXTRN	?VisualDetectionRange@@3PAHA:BYTE		; VisualDetectionRange
EXTRN	?GroundTactics@@3FA:WORD			; GroundTactics
EXTRN	?FirstGroundTactic@@3FA:WORD			; FirstGroundTactic
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?gCampDataVersion@@3HA:DWORD			; gCampDataVersion
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?FLIGHT_MOVE_CHECK_INTERVAL@@3FA:WORD		; FLIGHT_MOVE_CHECK_INTERVAL
EXTRN	?MORALE_REGAIN_RATE@@3FA:WORD			; MORALE_REGAIN_RATE
EXTRN	?REGAIN_RATE_MULTIPLIER_FOR_TE@@3FA:WORD	; REGAIN_RATE_MULTIPLIER_FOR_TE
EXTRN	?FOOT_MOVE_CHECK_INTERVAL@@3FA:WORD		; FOOT_MOVE_CHECK_INTERVAL
EXTRN	?TRACKED_MOVE_CHECK_INTERVAL@@3FA:WORD		; TRACKED_MOVE_CHECK_INTERVAL
EXTRN	?GROUND_COMBAT_CHECK_INTERVAL@@3FA:WORD		; GROUND_COMBAT_CHECK_INTERVAL
EXTRN	?GROUND_UPDATE_CHECK_INTERVAL@@3FA:WORD		; GROUND_UPDATE_CHECK_INTERVAL
EXTRN	?MINIMUM_EXP_TO_FIRE_PREGUIDE@@3FA:WORD		; MINIMUM_EXP_TO_FIRE_PREGUIDE
EXTRN	?NAVAL_MOVE_CHECK_INTERVAL@@3FA:WORD		; NAVAL_MOVE_CHECK_INTERVAL
EXTRN	?TheMap@@3VTMap@@A:BYTE				; TheMap
EXTRN	?radarDatFileTable@@3PAURadarDataSet@@A:DWORD	; radarDatFileTable
EXTRN	?g_bOldSamActivity@@3_NA:BYTE			; g_bOldSamActivity
EXTRN	?save_log@@3PAU_iobuf@@A:DWORD			; save_log
EXTRN	?start_save_stream@@3HA:DWORD			; start_save_stream
EXTRN	?haveWeaps@@3HA:DWORD				; haveWeaps
EXTRN	?ourObjDist@@3HA:DWORD				; ourObjDist
EXTRN	?ourObjOwner@@3HA:DWORD				; ourObjOwner
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
_BSS	SEGMENT
?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A DD 01H DUP (?) ; `BattalionClass::GetVehicleDeagData'::`2'::ent
_BSS	ENDS
;	COMDAT ?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA
_BSS	SEGMENT
?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetVehicleDeagData'::`2'::round
_BSS	ENDS
;	COMDAT ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
_BSS	SEGMENT
?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetDeaggregationPoint'::`2'::last_SAM_pt
_BSS	ENDS
;	COMDAT ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
_BSS	SEGMENT
?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetDeaggregationPoint'::`2'::last_AAA_pt
_BSS	ENDS
;	COMDAT ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
_BSS	SEGMENT
?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetDeaggregationPoint'::`2'::last_support_pt
_BSS	ENDS
;	COMDAT ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
_BSS	SEGMENT
?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetDeaggregationPoint'::`2'::last_art_pt
_BSS	ENDS
;	COMDAT ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
_BSS	SEGMENT
?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetDeaggregationPoint'::`2'::ptListType
_BSS	ENDS
;	COMDAT ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
_BSS	SEGMENT
?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA DD 01H DUP (?) ; `BattalionClass::GetDeaggregationPoint'::`2'::index
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f693e32
CONST	SEGMENT
__real@3f693e32 DD 03f693e32r			; 0.911105
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2VuEntity@@8
rdata$r	SEGMENT
??_R2VuEntity@@8 DD FLAT:??_R1A@?0A@EA@VuEntity@@8	; VuEntity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuEntity@@8
rdata$r	SEGMENT
??_R3VuEntity@@8 DD 00H					; VuEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuEntity@@@8
_DATA	SEGMENT
??_R0?AVVuEntity@@@8 DD FLAT:??_7type_info@@6B@		; VuEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuEntity@@8 DD FLAT:??_R0?AVVuEntity@@@8	; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FalconEntity@@8
rdata$r	SEGMENT
??_R2FalconEntity@@8 DD FLAT:??_R1A@?0A@EA@FalconEntity@@8 ; FalconEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3FalconEntity@@8
rdata$r	SEGMENT
??_R3FalconEntity@@8 DD 00H				; FalconEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFalconEntity@@@8
_DATA	SEGMENT
??_R0?AVFalconEntity@@@8 DD FLAT:??_7type_info@@6B@	; FalconEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFalconEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FalconEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FalconEntity@@8 DD FLAT:??_R0?AVFalconEntity@@@8 ; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2CampBaseClass@@8
rdata$r	SEGMENT
??_R2CampBaseClass@@8 DD FLAT:??_R1A@?0A@EA@CampBaseClass@@8 ; CampBaseClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3CampBaseClass@@8
rdata$r	SEGMENT
??_R3CampBaseClass@@8 DD 00H				; CampBaseClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CampBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCampBaseClass@@@8
_DATA	SEGMENT
??_R0?AVCampBaseClass@@@8 DD FLAT:??_7type_info@@6B@	; CampBaseClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCampBaseClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CampBaseClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CampBaseClass@@8 DD FLAT:??_R0?AVCampBaseClass@@@8 ; CampBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CampBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R2UnitClass@@8
rdata$r	SEGMENT
??_R2UnitClass@@8 DD FLAT:??_R1A@?0A@EA@UnitClass@@8	; UnitClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CampBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3UnitClass@@8
rdata$r	SEGMENT
??_R3UnitClass@@8 DD 00H				; UnitClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUnitClass@@@8
_DATA	SEGMENT
??_R0?AVUnitClass@@@8 DD FLAT:??_7type_info@@6B@	; UnitClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUnitClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@UnitClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UnitClass@@8 DD FLAT:??_R0?AVUnitClass@@@8 ; UnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R2GroundUnitClass@@8
rdata$r	SEGMENT
??_R2GroundUnitClass@@8 DD FLAT:??_R1A@?0A@EA@GroundUnitClass@@8 ; GroundUnitClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@UnitClass@@8
	DD	FLAT:??_R1A@?0A@EA@CampBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3GroundUnitClass@@8
rdata$r	SEGMENT
??_R3GroundUnitClass@@8 DD 00H				; GroundUnitClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2GroundUnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVGroundUnitClass@@@8
_DATA	SEGMENT
??_R0?AVGroundUnitClass@@@8 DD FLAT:??_7type_info@@6B@	; GroundUnitClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGroundUnitClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@GroundUnitClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@GroundUnitClass@@8 DD FLAT:??_R0?AVGroundUnitClass@@@8 ; GroundUnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3GroundUnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BattalionClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BattalionClass@@8 DD FLAT:??_R0?AVBattalionClass@@@8 ; BattalionClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BattalionClass@@8
rdata$r	ENDS
;	COMDAT ??_R2BattalionClass@@8
rdata$r	SEGMENT
??_R2BattalionClass@@8 DD FLAT:??_R1A@?0A@EA@BattalionClass@@8 ; BattalionClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GroundUnitClass@@8
	DD	FLAT:??_R1A@?0A@EA@UnitClass@@8
	DD	FLAT:??_R1A@?0A@EA@CampBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3BattalionClass@@8
rdata$r	SEGMENT
??_R3BattalionClass@@8 DD 00H				; BattalionClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2BattalionClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBattalionClass@@@8
_DATA	SEGMENT
??_R0?AVBattalionClass@@@8 DD FLAT:??_7type_info@@6B@	; BattalionClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBattalionClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BattalionClass@@6B@
rdata$r	SEGMENT
??_R4BattalionClass@@6B@ DD 00H				; BattalionClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBattalionClass@@@8
	DD	FLAT:??_R3BattalionClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidBufferException@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidBufferException@@8 DD FLAT:??_R0?AVInvalidBufferException@@@8 ; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidBufferException@@8
rdata$r	SEGMENT
??_R2InvalidBufferException@@8 DD FLAT:??_R1A@?0A@EA@InvalidBufferException@@8 ; InvalidBufferException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@out_of_range@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidBufferException@@8
rdata$r	SEGMENT
??_R3InvalidBufferException@@8 DD 00H			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidBufferException@@6B@
rdata$r	SEGMENT
??_R4InvalidBufferException@@6B@ DD 00H			; InvalidBufferException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPAMKIGD@?$CF08x?5BattalionClass?5?$AA@
CONST	SEGMENT
??_C@_0BF@NPAMKIGD@?$CF08x?5BattalionClass?5?$AA@ DB '%08x BattalionClass'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7BattalionClass@@6B@
CONST	SEGMENT
??_7BattalionClass@@6B@ DD FLAT:??_R4BattalionClass@@6B@ ; BattalionClass::`vftable'
	DD	FLAT:?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z
	DD	FLAT:?TerrainCollisionCheck@VuEntity@@UAEEXZ
	DD	FLAT:?IsTarget@VuEntity@@UAEEXZ
	DD	FLAT:?IsSession@VuEntity@@UAEEXZ
	DD	FLAT:?IsGroup@VuEntity@@UAEEXZ
	DD	FLAT:?IsGame@VuEntity@@UAEEXZ
	DD	FLAT:?IsCamera@VuEntity@@UBEEXZ
	DD	FLAT:?SaveSize@BattalionClass@@UAEHXZ
	DD	FLAT:?Save@FalconEntity@@UAEHPAU_iobuf@@@Z
	DD	FLAT:?Save@BattalionClass@@UAEHPAPAE@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuSessionEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuTransferEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuEntityCollisionEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@BattalionClass@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z
	DD	FLAT:??_EBattalionClass@@UAEPAXI@Z
	DD	FLAT:?InsertionCallback@VuEntity@@MAEHXZ
	DD	FLAT:?RemovalCallback@FalconEntity@@UAEHXZ
	DD	FLAT:?InitData@BattalionClass@@UAEXXZ
	DD	FLAT:?CleanupData@FalconEntity@@UAEXXZ
	DD	FLAT:?IsSimBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?IsCampBase@CampBaseClass@@UAE_NXZ
	DD	FLAT:?Wake@UnitClass@@UAEHXZ
	DD	FLAT:?Sleep@UnitClass@@UAEHXZ
	DD	FLAT:?GetCampID@CampBaseClass@@UAEFXZ
	DD	FLAT:?GetTeam@CampBaseClass@@UAEEXZ
	DD	FLAT:?GetCountry@CampBaseClass@@UAEEXZ
	DD	FLAT:?GetDomain@FalconEntity@@UAEEXZ
	DD	FLAT:?GetRadarMode@BattalionClass@@UAEHXZ
	DD	FLAT:?SetRadarMode@BattalionClass@@UAEXE@Z
	DD	FLAT:?ReturnToSearch@BattalionClass@@UAEXXZ
	DD	FLAT:?SetSearchMode@BattalionClass@@UAEXE@Z
	DD	FLAT:?CombatClass@FalconEntity@@UAEHXZ
	DD	FLAT:?OnGround@GroundUnitClass@@UAEHXZ
	DD	FLAT:?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z
	DD	FLAT:?IsMissile@FalconEntity@@UAEHXZ
	DD	FLAT:?IsLauncher@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBomb@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGun@FalconEntity@@UAEHXZ
	DD	FLAT:?IsMover@FalconEntity@@UAEHXZ
	DD	FLAT:?IsVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsStatic@FalconEntity@@UAEHXZ
	DD	FLAT:?IsHelicopter@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEject@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAirplane@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGroundVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsShip@FalconEntity@@UAEHXZ
	DD	FLAT:?IsWeapon@FalconEntity@@UAEHXZ
	DD	FLAT:?IsExploding@FalconEntity@@UAEHXZ
	DD	FLAT:?IsDead@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEmitting@CampBaseClass@@UAEHXZ
	DD	FLAT:?GetVt@GroundUnitClass@@UBEMXZ
	DD	FLAT:?GetKias@GroundUnitClass@@UBEMXZ
	DD	FLAT:?GetMovementType@GroundUnitClass@@UAE?AW4MoveType@@XZ
	DD	FLAT:?IsUnit@UnitClass@@UAEHXZ
	DD	FLAT:?IsObjective@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBattalion@BattalionClass@@UAEHXZ
	DD	FLAT:?IsBrigade@FalconEntity@@UAEHXZ
	DD	FLAT:?IsFlight@FalconEntity@@UBEHXZ
	DD	FLAT:?IsSquadron@FalconEntity@@UAEHXZ
	DD	FLAT:?IsPackage@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTeam@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTaskForce@FalconEntity@@UAEHXZ
	DD	FLAT:?IsSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?GetRCSFactor@UnitClass@@UAEMXZ
	DD	FLAT:?GetIRFactor@UnitClass@@UAEMXZ
	DD	FLAT:?GetRadarType@UnitClass@@UAEHXZ
	DD	FLAT:?GetDamageModifiers@UnitClass@@UAEPAEXZ
	DD	FLAT:?SetAQUIREtimer@BattalionClass@@UAEXK@Z
	DD	FLAT:?SetSEARCHtimer@BattalionClass@@UAEXK@Z
	DD	FLAT:?SetStepSearchMode@BattalionClass@@UAEXE@Z
	DD	FLAT:?GetAQUIREtimer@BattalionClass@@UAEKXZ
	DD	FLAT:?GetSEARCHtimer@BattalionClass@@UAEKXZ
	DD	FLAT:?SetOwner@CampBaseClass@@UAEXE@Z
	DD	FLAT:?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z
	DD	FLAT:?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z
	DD	FLAT:?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?InsertInSimLists@UnitClass@@UAEXMM@Z
	DD	FLAT:?RemoveFromSimLists@UnitClass@@UAEXXZ
	DD	FLAT:?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z
	DD	FLAT:?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z
	DD	FLAT:?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z
	DD	FLAT:?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z
	DD	FLAT:?GetName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetFullName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetDivisionName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetHitChance@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetAproxHitChance@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetCombatStrength@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetAproxCombatStrength@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z
	DD	FLAT:?GetAproxWeaponRange@UnitClass@@UAEHH@Z
	DD	FLAT:?GetDetectionRange@BattalionClass@@UAEHH@Z
	DD	FLAT:?GetElectronicDetectionRange@BattalionClass@@UAEHH@Z
	DD	FLAT:?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z
	DD	FLAT:?StepRadar@BattalionClass@@UAEHHHM@Z
	DD	FLAT:?GetNumberOfArcs@UnitClass@@UAEHXZ
	DD	FLAT:?GetArcRatio@UnitClass@@UAEMH@Z
	DD	FLAT:?GetArcRange@UnitClass@@UAEMH@Z
	DD	FLAT:?GetArcAngle@UnitClass@@UAEXHPAM0@Z
	DD	FLAT:?GetMissilesFlying@BattalionClass@@UAEHXZ
	DD	FLAT:?ResetPlayerStatus@UnitClass@@UAEHXZ
	DD	FLAT:?GetComponentLocation@UnitClass@@UAEXPAF0H@Z
	DD	FLAT:?GetComponentAltitude@UnitClass@@UAEHH@Z
	DD	FLAT:?CanShootWeapon@BattalionClass@@UAEHH@Z
	DD	FLAT:?GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z
	DD	FLAT:?GetUnitDeaggregationData@BattalionClass@@UAEPAVUnitDeaggregationData@@XZ
	DD	FLAT:?ShouldDeaggregate@UnitClass@@UAEHXZ
	DD	FLAT:?ClearDeaggregationData@BattalionClass@@UAEXXZ
	DD	FLAT:?Reaction@BattalionClass@@UAEHPAVCampBaseClass@@HM@Z
	DD	FLAT:?MoveUnit@BattalionClass@@UAEHK@Z
	DD	FLAT:?DoCombat@BattalionClass@@UAEHXZ
	DD	FLAT:?ChooseTactic@BattalionClass@@UAEHXZ
	DD	FLAT:?CheckTactic@BattalionClass@@UAEHH@Z
	DD	FLAT:?Father@UnitClass@@UBEHXZ
	DD	FLAT:?Real@BattalionClass@@UAEHXZ
	DD	FLAT:?AdjustForSupply@BattalionClass@@UAEMXZ
	DD	FLAT:?GetUnitSpeed@BattalionClass@@UBEHXZ
	DD	FLAT:?DetectOnMove@GroundUnitClass@@UAEHXZ
	DD	FLAT:?ChooseTarget@GroundUnitClass@@UAEHXZ
	DD	FLAT:?MaxUpdateTime@BattalionClass@@UBEKXZ
	DD	FLAT:?CombatTime@BattalionClass@@UAEKXZ
	DD	FLAT:?GetUnitSupplyNeed@BattalionClass@@UAEHH@Z
	DD	FLAT:?GetUnitFuelNeed@BattalionClass@@UAEHH@Z
	DD	FLAT:?SupplyUnit@BattalionClass@@UAEXHH@Z
	DD	FLAT:?GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z
	DD	FLAT:?IsDead@UnitClass@@UBEHXZ
	DD	FLAT:?SimSetLocation@BattalionClass@@UAEXMMM@Z
	DD	FLAT:?SimSetOrientation@UnitClass@@UAEXMMM@Z
	DD	FLAT:?GetRealPosition@BattalionClass@@UAEXPAM00@Z
	DD	FLAT:?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z
	DD	FLAT:?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z
	DD	FLAT:?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z
	DD	FLAT:?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z
	DD	FLAT:?GetUnitWeaponId@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetUnitWeaponCount@UnitClass@@UAEHHH@Z
	DD	FLAT:?SetUnitLastMove@BattalionClass@@UAEXK@Z
	DD	FLAT:?SetCombatTime@BattalionClass@@UAEXK@Z
	DD	FLAT:?SetBurntFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitMission@UnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitRole@UnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitPriority@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMissionID@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMissionTarget@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitTOT@UnitClass@@UAEXK@Z
	DD	FLAT:?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z
	DD	FLAT:?GetNumberOfLoadouts@UnitClass@@UAEHXZ
	DD	FLAT:?GetMoveTime@BattalionClass@@UAEKXZ
	DD	FLAT:?GetCombatTime@BattalionClass@@UAEKXZ
	DD	FLAT:?GetAirTargetID@BattalionClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetAirTarget@BattalionClass@@UAEPAVFalconEntity@@XZ
	DD	FLAT:?GetBurntFuel@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ
	DD	FLAT:?GetUnitNormalRole@GroundUnitClass@@UAEHXZ
	DD	FLAT:?GetUnitCurrentRole@GroundUnitClass@@UBEHXZ
	DD	FLAT:?GetUnitPriority@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ
	DD	FLAT:?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitMissionID@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitTOT@UnitClass@@UAEKXZ
	DD	FLAT:?GetUnitSquadron@UnitClass@@UAEPAV1@XZ
	DD	FLAT:?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ
	DD	FLAT:?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z
	DD	FLAT:?DumpWeapons@UnitClass@@UAEHXZ
	DD	FLAT:?ETA@UnitClass@@UAEKXZ
	DD	FLAT:?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ
	DD	FLAT:?BuildMission@GroundUnitClass@@UAEHXZ
	DD	FLAT:?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z
	DD	FLAT:?IncrementTime@BattalionClass@@UAEXK@Z
	DD	FLAT:?UseFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitSpecialty@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitSupply@BattalionClass@@UAEXH@Z
	DD	FLAT:?SetUnitMorale@BattalionClass@@UAEXH@Z
	DD	FLAT:?SetSquadronFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitStores@UnitClass@@UAEXHE@Z
	DD	FLAT:?SetLastResupply@UnitClass@@UAEXH@Z
	DD	FLAT:?SetLastResupplyTime@BattalionClass@@UAEXK@Z
	DD	FLAT:?GetUnitSpecialty@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitSupply@BattalionClass@@UAEHXZ
	DD	FLAT:?GetUnitMorale@BattalionClass@@UAEHXZ
	DD	FLAT:?GetSquadronFuel@UnitClass@@UAEJXZ
	DD	FLAT:?GetUnitStores@UnitClass@@UAEEH@Z
	DD	FLAT:?GetLastResupplyTime@BattalionClass@@UAEKXZ
	DD	FLAT:?GetLastResupply@UnitClass@@UAEHXZ
	DD	FLAT:?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z
	DD	FLAT:?HandleRequestReceipt@BattalionClass@@UAEXHHVVU_ID@@@Z
	DD	FLAT:?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z
	DD	FLAT:?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z
	DD	FLAT:?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitOrders@BattalionClass@@UAEXHVVU_ID@@@Z
	DD	FLAT:?SetUnitOrders@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitFatigue@BattalionClass@@UAEXH@Z
	DD	FLAT:?SetUnitMode@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitPosition@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitDivision@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitHeading@UnitClass@@UAEXH@Z
	DD	FLAT:?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitOrders@GroundUnitClass@@UAEHXZ
	DD	FLAT:?GetUnitFatigue@BattalionClass@@UAEHXZ
	DD	FLAT:?GetUnitElement@UnitClass@@UAEPAV1@H@Z
	DD	FLAT:?GetUnitElement@BattalionClass@@UAEHXZ
	DD	FLAT:?GetUnitMode@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitPosition@BattalionClass@@UAEHXZ
	DD	FLAT:?GetUnitDivision@GroundUnitClass@@UAEHXZ
	DD	FLAT:?GetUnitHeading@BattalionClass@@UAEHXZ
	DD	FLAT:?SetUnitNextMove@BattalionClass@@UAEXXZ
	DD	FLAT:?ClearUnitPath@BattalionClass@@UAEXXZ
	DD	FLAT:?GetNextMoveDirection@BattalionClass@@UAEHXZ
	DD	FLAT:?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z
	DD	FLAT:?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z
	DD	FLAT:?GetObjMovementType@GroundUnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z
	DD	FLAT:?CheckForSurrender@GroundUnitClass@@UAEHXZ
	DD	FLAT:?RallyUnit@BattalionClass@@UAEHH@Z
	DD	FLAT:?GetUnitParent@BattalionClass@@UBEPAVUnitClass@@XZ
	DD	FLAT:?GetUnitParentID@BattalionClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetUnitParent@BattalionClass@@UAEXPAVUnitClass@@@Z
	DD	FLAT:?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetNextUnitElement@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z
	DD	FLAT:?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z
	DD	FLAT:?AddUnitChild@UnitClass@@UAEXPAV1@@Z
	DD	FLAT:?DisposeChildren@UnitClass@@UAEXXZ
	DD	FLAT:?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?ReorganizeUnit@UnitClass@@UAEXXZ
	DD	FLAT:?UpdateParentStatistics@UnitClass@@UAEHXZ
	DD	FLAT:?SetUnitOrders@GroundUnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitDivision@GroundUnitClass@@UAEXF@Z
	DD	FLAT:?GetCruiseSpeed@BattalionClass@@UBEHXZ
	DD	FLAT:?GetCombatSpeed@BattalionClass@@UBEHXZ
	DD	FLAT:?GetMaxSpeed@BattalionClass@@UBEHXZ
	DD	FLAT:?GetSearchMode@BattalionClass@@UAEHXZ
	DD	FLAT:?SetUnitHeading@BattalionClass@@UAEXE@Z
	DD	FLAT:?SetUnitPosition@BattalionClass@@UAEXE@Z
	DD	FLAT:?SetAirTarget@BattalionClass@@UAEXPAVFalconEntity@@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0InvalidBufferException@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVInvalidBufferException@@@8
_DATA	SEGMENT
??_R0?AVInvalidBufferException@@@8 DD FLAT:??_7type_info@@6B@ ; InvalidBufferException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidBufferException@@', 00H
_DATA	ENDS
;	COMDAT __CTA4?AVInvalidBufferException@@
xdata$x	SEGMENT
__CTA4?AVInvalidBufferException@@ DD 04H
	DD	FLAT:__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVInvalidBufferException@@
xdata$x	SEGMENT
__TI4?AVInvalidBufferException@@ DD 00H
	DD	FLAT:??1InvalidBufferException@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVInvalidBufferException@@
xdata$x	ENDS
;	COMDAT ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
CONST	SEGMENT
??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ DB 'Tryi'
	DB	'ng to write %lu bytes to %ld buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7InvalidBufferException@@6B@
CONST	SEGMENT
??_7InvalidBufferException@@6B@ DD FLAT:??_R4InvalidBufferException@@6B@ ; InvalidBufferException::`vftable'
	DD	FLAT:??_EInvalidBufferException@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z$0
__unwindtable$?MoveUnit@BattalionClass@@UAEHK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveUnit@BattalionClass@@UAEHK@Z$0
__unwindtable$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z$0
__unwindtable$??1BattalionClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1BattalionClass@@UAE@XZ$0
__unwindtable$??0BattalionClass@@QAE@PAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BattalionClass@@QAE@PAPAEPAJ@Z$0
__unwindtable$??0BattalionClass@@QAE@GPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BattalionClass@@QAE@GPAVUnitClass@@@Z$0
__ehfuncinfo$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?MoveUnit@BattalionClass@@UAEHK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveUnit@BattalionClass@@UAEHK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1BattalionClass@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1BattalionClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0BattalionClass@@QAE@PAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0BattalionClass@@QAE@PAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0BattalionClass@@QAE@GPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0BattalionClass@@QAE@GPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0
__ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv192 = -44						; size = 4
_bd$ = -40						; size = 4
_count$ = -36						; size = 4
_n$ = -32						; size = 4
_i$ = -28						; size = 4
_d$ = -24						; size = 4
_x$ = -20						; size = 2
_y$ = -16						; size = 2
_nx$ = -12						; size = 2
_ny$ = -8						; size = 2
_nh$ = -2						; size = 1
_h$ = -1						; size = 1
_o$ = 8							; size = 4
_type$ = 12						; size = 4
_own$ = 16						; size = 4
?FindBestHeading@@YAEPAVObjectiveClass@@HH@Z PROC	; FindBestHeading

; 876  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 877  : 	Int32			bd=9999,d,i,count=0;

	mov	DWORD PTR _bd$[ebp], 9999		; 0000270fH
	mov	DWORD PTR _count$[ebp], 0

; 878  : 	GridIndex		x,y,nx,ny;
; 879  : 	CampaignHeading	h = 0,nh;

	mov	BYTE PTR _h$[ebp], 0

; 880  : 	Objective		n;
; 881  : 
; 882  : 	if (!o)

	cmp	DWORD PTR _o$[ebp], 0
	jne	SHORT $LN14@FindBestHe

; 883  : 		return Here;

	mov	al, 8
	jmp	$LN15@FindBestHe
$LN14@FindBestHe:

; 884  : 	o->GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 885  : 	// Collect neighbor information
; 886  : 	for (i=0; i<o->NumLinks(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@FindBestHe
$LN12@FindBestHe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@FindBestHe:
	mov	ecx, DWORD PTR _o$[ebp]
	call	?NumLinks@ObjectiveClass@@QAEHXZ	; ObjectiveClass::NumLinks
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN11@FindBestHe

; 887  : 	{
; 888  : 		n = o->GetNeighbor(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetNeighbor@ObjectiveClass@@QAEPAV1@H@Z ; ObjectiveClass::GetNeighbor
	mov	DWORD PTR _n$[ebp], eax

; 889  : 		if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	$LN1@FindBestHe

; 890  : 		{
; 891  : 			n->GetLocation(&nx,&ny);

	lea	ecx, DWORD PTR _ny$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _n$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 892  : 			d = FloatToInt32(DistanceToFront(nx,ny) * type);

	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR tv192[ebp]
	movss	xmm0, DWORD PTR tv192[ebp]
	cvtsi2ss xmm1, DWORD PTR _type$[ebp]
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 893  : 			if (n->GetTeam() == own)

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	eax, DWORD PTR _own$[ebp]
	jne	SHORT $LN9@FindBestHe

; 894  : 				d += type;

	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR _d$[ebp], ecx
$LN9@FindBestHe:

; 895  : 			if (d < bd)									// This objective is more important to face

	mov	edx, DWORD PTR _d$[ebp]
	cmp	edx, DWORD PTR _bd$[ebp]
	jge	SHORT $LN8@FindBestHe

; 896  : 			{
; 897  : 				h = DirectionTo(x,y,nx,ny);			

	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?DirectionTo@@YAEFFFF@Z			; DirectionTo
	add	esp, 16					; 00000010H
	mov	BYTE PTR _h$[ebp], al

; 898  : 				bd = d;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _bd$[ebp], ecx

; 899  : 				count = 1;

	mov	DWORD PTR _count$[ebp], 1
	jmp	$LN1@FindBestHe
$LN8@FindBestHe:

; 900  : 			}
; 901  : 			else if (d == bd)							// This objective is equally important to face

	mov	edx, DWORD PTR _d$[ebp]
	cmp	edx, DWORD PTR _bd$[ebp]
	jne	$LN1@FindBestHe

; 902  : 			{
; 903  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 904  : 				if (count > 2)							// To many choices, we're going to sit on the actual objective

	cmp	DWORD PTR _count$[ebp], 2
	jle	SHORT $LN5@FindBestHe

; 905  : 					return Here;

	mov	al, 8
	jmp	$LN15@FindBestHe
$LN5@FindBestHe:

; 906  : 				nh = DirectionTo(x,y,nx,ny);

	movzx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?DirectionTo@@YAEFFFF@Z			; DirectionTo
	add	esp, 16					; 00000010H
	mov	BYTE PTR _nh$[ebp], al

; 907  : 				if (abs(nh-h) <= 2)

	movzx	edx, BYTE PTR _nh$[ebp]
	movzx	eax, BYTE PTR _h$[ebp]
	sub	edx, eax
	push	edx
	call	_abs
	add	esp, 4
	cmp	eax, 2
	jg	SHORT $LN4@FindBestHe

; 908  : 					h = (CampaignHeading)((h+nh)/2);	// We can split the difference

	movzx	eax, BYTE PTR _h$[ebp]
	movzx	ecx, BYTE PTR _nh$[ebp]
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _h$[ebp], al
	jmp	SHORT $LN1@FindBestHe
$LN4@FindBestHe:

; 909  : 				else if (abs(nh-h) >= 6)

	movzx	edx, BYTE PTR _nh$[ebp]
	movzx	eax, BYTE PTR _h$[ebp]
	sub	edx, eax
	push	edx
	call	_abs
	add	esp, 4
	cmp	eax, 6
	jl	SHORT $LN2@FindBestHe

; 910  : 					h = (CampaignHeading)((((h+nh)/2) + 4)%8);

	movzx	eax, BYTE PTR _h$[ebp]
	movzx	ecx, BYTE PTR _nh$[ebp]
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 4
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN17@FindBestHe
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN17@FindBestHe:
	mov	BYTE PTR _h$[ebp], al

; 911  : 				else

	jmp	SHORT $LN1@FindBestHe
$LN2@FindBestHe:

; 912  : 					return Here;						// Fuck it - we're going to sit on the actual objective

	mov	al, 8
	jmp	SHORT $LN15@FindBestHe
$LN1@FindBestHe:

; 913  : 			}
; 914  : 		}
; 915  : 	}

	jmp	$LN12@FindBestHe
$LN11@FindBestHe:

; 916  : 	return h;

	mov	al, BYTE PTR _h$[ebp]
$LN15@FindBestHe:

; 917  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestHeading@@YAEPAVObjectiveClass@@HH@Z ENDP	; FindBestHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\brigade.h
;	COMDAT ?GetElement@BrigadeClass@@QAE?AVVU_ID@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?GetElement@BrigadeClass@@QAE?AVVU_ID@@H@Z PROC		; BrigadeClass::GetElement, COMDAT
; _this$ = ecx

; 47   : 	VU_ID GetElement (int i) { return element[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+296]
	mov	eax, DWORD PTR [ecx+eax*8+300]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
?GetElement@BrigadeClass@@QAE?AVVU_ID@@H@Z ENDP		; BrigadeClass::GetElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_new_battalion$ = -28					; size = 4
$T2 = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_parent$ = 12						; size = 4
?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z PROC ; NewBattalion

; 141  : BattalionClass* NewBattalion(int type, Unit parent){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 142  : 	BattalionClass	*new_battalion;
; 143  : 	/*VuEnterCriticalSection();
; 144  : 	lastVolatileId = vuAssignmentId;
; 145  : 	vuAssignmentId = lastNonVolatileId;
; 146  : 	vuLowWrapNumber = FIRST_NON_VOLATILE_VU_ID_NUMBER;
; 147  : 	vuHighWrapNumber = LAST_NON_VOLATILE_VU_ID_NUMBER;*/
; 148  : 	new_battalion = new BattalionClass (type, parent);

	push	364					; 0000016cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@NewBattali
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	movzx	ecx, WORD PTR _type$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0BattalionClass@@QAE@GPAVUnitClass@@@Z ; BattalionClass::BattalionClass
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@NewBattali
$LN3@NewBattali:
	mov	DWORD PTR tv73[ebp], 0
$LN4@NewBattali:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_battalion$[ebp], eax

; 149  : 	/*lastNonVolatileId = vuAssignmentId;
; 150  : 	vuAssignmentId = lastVolatileId;
; 151  : 	vuLowWrapNumber = FIRST_VOLATILE_VU_ID_NUMBER;
; 152  : 	vuHighWrapNumber = LAST_VOLATILE_VU_ID_NUMBER;
; 153  : 	VuExitCriticalSection();*/
; 154  : 	return new_battalion;

	mov	eax, DWORD PTR _new_battalion$[ebp]

; 155  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z ENDP ; NewBattalion
; Function compile flags: /Odtp
;	COMDAT ??_GBattalionClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBattalionClass@@UAEPAXI@Z PROC			; BattalionClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BattalionClass@@UAE@XZ		; BattalionClass::~BattalionClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBattalionClass@@UAEPAXI@Z ENDP			; BattalionClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetSEARCHtimer@BattalionClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSEARCHtimer@BattalionClass@@UAEKXZ PROC		; BattalionClass::GetSEARCHtimer, COMDAT
; _this$ = ecx

; 177  : 	virtual VU_TIME GetSEARCHtimer(void)				{ return SEARCHtimer; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSEARCHtimer@BattalionClass@@UAEKXZ ENDP		; BattalionClass::GetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetAQUIREtimer@BattalionClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAQUIREtimer@BattalionClass@@UAEKXZ PROC		; BattalionClass::GetAQUIREtimer, COMDAT
; _this$ = ecx

; 176  : 	virtual VU_TIME GetAQUIREtimer(void)				{ return AQUIREtimer; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAQUIREtimer@BattalionClass@@UAEKXZ ENDP		; BattalionClass::GetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetStepSearchMode@BattalionClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 1
?SetStepSearchMode@BattalionClass@@UAEXE@Z PROC		; BattalionClass::SetStepSearchMode, COMDAT
; _this$ = ecx

; 175  : 	virtual void SetStepSearchMode(uchar mode)			{ step_search_mode = mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _mode$[ebp]
	mov	BYTE PTR [eax+312], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStepSearchMode@BattalionClass@@UAEXE@Z ENDP		; BattalionClass::SetStepSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetSEARCHtimer@BattalionClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetSEARCHtimer@BattalionClass@@UAEXK@Z PROC		; BattalionClass::SetSEARCHtimer, COMDAT
; _this$ = ecx

; 174  : 	virtual void SetSEARCHtimer(VU_TIME newTime)		{ SEARCHtimer = newTime; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTime$[ebp]
	mov	DWORD PTR [eax+304], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSEARCHtimer@BattalionClass@@UAEXK@Z ENDP		; BattalionClass::SetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetAQUIREtimer@BattalionClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetAQUIREtimer@BattalionClass@@UAEXK@Z PROC		; BattalionClass::SetAQUIREtimer, COMDAT
; _this$ = ecx

; 173  : 	virtual void SetAQUIREtimer(VU_TIME newTime)		{ AQUIREtimer = newTime; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTime$[ebp]
	mov	DWORD PTR [eax+308], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAQUIREtimer@BattalionClass@@UAEXK@Z ENDP		; BattalionClass::SetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_x$1 = -20						; size = 2
_y$2 = -16						; size = 2
_nx$3 = -12						; size = 2
_ny$4 = -8						; size = 2
_bits$ = -1						; size = 1
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
?ReadDirty@BattalionClass@@QAEXPAPAEPAJ@Z PROC		; BattalionClass::ReadDirty
; _this$ = ecx

; 2266 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2267 : 	unsigned char bits;
; 2268 : 
; 2269 : 	memcpychk(&bits, stream, sizeof(unsigned char), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bits$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2270 : 
; 2271 : 
; 2272 : 	if (bits & DIRTY_SUPPLY) {

	movzx	eax, BYTE PTR _bits$[ebp]
	and	eax, 2
	je	SHORT $LN5@ReadDirty

; 2273 : 		memcpychk(&supply, stream, sizeof(Percentage), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 292				; 00000124H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN5@ReadDirty:

; 2274 : 	}
; 2275 : 
; 2276 : 	if (bits & DIRTY_MORALE) {

	movzx	ecx, BYTE PTR _bits$[ebp]
	and	ecx, 4
	je	SHORT $LN4@ReadDirty

; 2277 : 		memcpychk(&morale, stream, sizeof(Percentage), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 294				; 00000126H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN4@ReadDirty:

; 2278 : 	}
; 2279 : 
; 2280 : 	if (bits & DIRTY_FATIGUE) {

	movzx	edx, BYTE PTR _bits$[ebp]
	and	edx, 8
	je	SHORT $LN3@ReadDirty

; 2281 : 		memcpychk(&fatigue, stream, sizeof(Percentage), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 293				; 00000125H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN3@ReadDirty:

; 2282 : 	}
; 2283 : 
; 2284 : 	// sfr: dirty smallpath: recompute it
; 2285 : 	if (bits & DIRTY_SMALLPATH){

	movzx	eax, BYTE PTR _bits$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN6@ReadDirty

; 2286 : 		short x, y, nx, ny;
; 2287 : 		GetLocation(&x, &y);

	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2288 : 		GetUnitDestination(&nx, &ny);

	lea	eax, DWORD PTR _ny$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 2289 : 		if ((x != nx) && (y != ny)){

	movsx	edx, WORD PTR _x$1[ebp]
	movsx	eax, WORD PTR _nx$3[ebp]
	cmp	edx, eax
	je	SHORT $LN6@ReadDirty
	movsx	ecx, WORD PTR _y$2[ebp]
	movsx	edx, WORD PTR _ny$4[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@ReadDirty

; 2290 : 			GetUnitGridPath(path,x,y,nx,ny);

	movzx	eax, WORD PTR _ny$4[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$3[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$2[ebp]
	push	edx
	movzx	eax, WORD PTR _x$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath

; 2291 : 			SetMoving(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoving@UnitClass@@QAEXH@Z		; UnitClass::SetMoving
$LN6@ReadDirty:

; 2292 : 		}/*
; 2293 : 		delete path;
; 2294 : 		path = new SmallPathClass(stream, rem);
; 2295 : 		*/
; 2296 : 	}
; 2297 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ReadDirty@BattalionClass@@QAEXPAPAEPAJ@Z ENDP		; BattalionClass::ReadDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ptr$ = -4						; size = 4
_stream$ = 8						; size = 4
?WriteDirty@BattalionClass@@QAEXPAPAE@Z PROC		; BattalionClass::WriteDirty
; _this$ = ecx

; 2219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2220 : 	unsigned char
; 2221 : 		*ptr;
; 2222 : 
; 2223 : 	ptr = *stream;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptr$[ebp], ecx

; 2224 : 
; 2225 : 	//MonoPrint ("  BC %08x", dirty_battalion);
; 2226 : 
; 2227 : 	// Encode it up
; 2228 : 	// dirty bits
; 2229 : 	*(uchar*)ptr = (uchar) dirty_battalion;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+316]
	mov	BYTE PTR [edx], cl

; 2230 : 	ptr += sizeof (uchar);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 2231 : 
; 2232 : 	if (dirty_battalion & DIRTY_SUPPLY)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	and	ecx, 2
	je	SHORT $LN3@WriteDirty

; 2233 : 	{
; 2234 : 		*(Percentage*)ptr = supply;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+292]
	mov	BYTE PTR [edx], cl

; 2235 : 		ptr += sizeof (Percentage);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
$LN3@WriteDirty:

; 2236 : 	}
; 2237 : 
; 2238 : 	if (dirty_battalion & DIRTY_MORALE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	and	ecx, 4
	je	SHORT $LN2@WriteDirty

; 2239 : 	{
; 2240 : 		*(Percentage*)ptr = morale;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+294]
	mov	BYTE PTR [edx], cl

; 2241 : 		ptr += sizeof (Percentage);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
$LN2@WriteDirty:

; 2242 : 	}
; 2243 : 
; 2244 : 	if (dirty_battalion & DIRTY_FATIGUE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	and	ecx, 8
	je	SHORT $LN1@WriteDirty

; 2245 : 	{
; 2246 : 		*(Percentage*)ptr = fatigue;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+293]
	mov	BYTE PTR [edx], cl

; 2247 : 		ptr += sizeof (Percentage);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
$LN1@WriteDirty:

; 2248 : 	}
; 2249 : 
; 2250 : 	/*
; 2251 : 	if (dirty_battalion & DIRTY_SMALLPATH){
; 2252 : 		// this call updates stream
; 2253 : 		path->Save(stream);
; 2254 : 	}*/
; 2255 : 
; 2256 : 	dirty_battalion = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+316], 0

; 2257 : 	//sfr: was buggy here, were not updating stream
; 2258 : 	*stream = ptr;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 2259 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WriteDirty@BattalionClass@@QAEXPAPAE@Z ENDP		; BattalionClass::WriteDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
_score$ = 12						; size = 4
?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z PROC ; BattalionClass::MakeBattalionDirty
; _this$ = ecx

; 2200 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2201 : 	if ((!IsLocal()) ||  (VuState() != VU_MEM_ACTIVE)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@MakeBattal
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	je	SHORT $LN3@MakeBattal
$LN2@MakeBattal:

; 2202 : 		return;

	jmp	SHORT $LN4@MakeBattal
$LN3@MakeBattal:

; 2203 : 	}
; 2204 : 
; 2205 : 	if (!IsAggregate() && (score != SEND_RELIABLEANDOOB)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN1@MakeBattal
	cmp	DWORD PTR _score$[ebp], 268435456	; 10000000H
	je	SHORT $LN1@MakeBattal

; 2206 : 		score = static_cast<Dirtyness>(score << 4);

	mov	ecx, DWORD PTR _score$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _score$[ebp], ecx
$LN1@MakeBattal:

; 2207 : 	}
; 2208 : 
; 2209 : 	dirty_battalion |= bits;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+316]
	or	eax, DWORD PTR _bits$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 2210 : 
; 2211 : 	MakeDirty (DIRTY_BATTALION, score);

	mov	edx, DWORD PTR _score$[ebp]
	push	edx
	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z ; FalconEntity::MakeDirty
$LN4@MakeBattal:

; 2212 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ENDP ; BattalionClass::MakeBattalionDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?IncrementTime@BattalionClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dt$ = 8						; size = 4
?IncrementTime@BattalionClass@@UAEXK@Z PROC		; BattalionClass::IncrementTime, COMDAT
; _this$ = ecx

; 166  : 	virtual void IncrementTime (CampaignTime dt) 		{ last_move += dt; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+324]
	add	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementTime@BattalionClass@@UAEXK@Z ENDP		; BattalionClass::IncrementTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv135 = -16						; size = 4
tv133 = -12						; size = 4
tv139 = -8						; size = 4
_this$ = -4						; size = 4
?AdjustForSupply@BattalionClass@@UAEMXZ PROC		; BattalionClass::AdjustForSupply
; _this$ = ecx

; 2064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2065 : 	return (supply/100.0F) * ((100-fatigue)/100.0F) * (morale/100.0F) * GroundExperienceAdjustment(GetOwner());

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+292]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+293]
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	cvtsi2ss xmm1, ecx
	divss	xmm1, DWORD PTR __real@42c80000
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+294]
	cvtsi2ss xmm1, eax
	divss	xmm1, DWORD PTR __real@42c80000
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv139[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	push	ecx
	call	?GroundExperienceAdjustment@@YAME@Z	; GroundExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv133[ebp]
	movss	xmm0, DWORD PTR tv139[ebp]
	mulss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
	fld	DWORD PTR tv135[ebp]

; 2066 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustForSupply@BattalionClass@@UAEMXZ ENDP		; BattalionClass::AdjustForSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv65 = -12						; size = 4
tv74 = -8						; size = 4
_d$ = -4						; size = 4
?GetSpeedModifier@BattalionClass@@QBEMXZ PROC		; BattalionClass::GetSpeedModifier
; _this$ = ecx

; 1070 : float BattalionClass::GetSpeedModifier() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1071 : 	float	d;
; 1072 : 
; 1073 : 	// 2001-04-10 MODIFIED BY S.G. TimeOfDay RETURNS THE TIME OF THE DAY
; 1074 : 	// IN MILISECONDS! THAT'S NOT WHAT WE WANT... TimeOfDayGeneral WILL DO WHAT WE WANT
; 1075 : 	//	switch (TimeOfDay())			// Time of day modifiers
; 1076 : 	switch (TimeOfDayGeneral())		// Time of day modifiers

	call	?TimeOfDayGeneral@@YAHXZ		; TimeOfDayGeneral
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN8@GetSpeedMo
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN7@GetSpeedMo
	jmp	SHORT $LN6@GetSpeedMo
$LN8@GetSpeedMo:

; 1077 : 	{
; 1078 : 		case TOD_NIGHT:
; 1079 : 			d = 0.7F;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _d$[ebp], xmm0

; 1080 : 			break;

	jmp	SHORT $LN9@GetSpeedMo
$LN7@GetSpeedMo:

; 1081 : 		case TOD_DAWNDUSK:
; 1082 : 			d = 0.85F;

	movss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR _d$[ebp], xmm0

; 1083 : 			break;

	jmp	SHORT $LN9@GetSpeedMo
$LN6@GetSpeedMo:

; 1084 : 		default:
; 1085 : 			d = 1.0F;				

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _d$[ebp], xmm0
$LN9@GetSpeedMo:

; 1086 : 			break;
; 1087 : 	}
; 1088 : 	switch (GetUnitFormation())		// Unit's movement mode modifier

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 0
	je	SHORT $LN3@GetSpeedMo
	cmp	DWORD PTR tv74[ebp], 3
	jle	SHORT $LN1@GetSpeedMo
	cmp	DWORD PTR tv74[ebp], 5
	jle	SHORT $LN2@GetSpeedMo
	jmp	SHORT $LN1@GetSpeedMo
$LN3@GetSpeedMo:

; 1089 : 	{
; 1090 : 		case GFORM_DISPERSED:
; 1091 : 			d *= 1.5F;

	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR _d$[ebp], xmm0

; 1092 : 			break;

	jmp	SHORT $LN4@GetSpeedMo
$LN2@GetSpeedMo:

; 1093 : 		case GFORM_WEDGE:
; 1094 : 		case GFORM_ECHELON:
; 1095 : 			d *= 0.8F;

	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _d$[ebp], xmm0
$LN1@GetSpeedMo:
$LN4@GetSpeedMo:

; 1096 : 			break;
; 1097 : 		default:
; 1098 : 			break;
; 1099 : 	}
; 1100 : 	return d;

	fld	DWORD PTR _d$[ebp]

; 1101 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpeedModifier@BattalionClass@@QBEMXZ ENDP		; BattalionClass::GetSpeedModifier
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetLastResupplyTime@BattalionClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastResupplyTime@BattalionClass@@UAEKXZ PROC	; BattalionClass::GetLastResupplyTime, COMDAT
; _this$ = ecx

; 161  : 	virtual CampaignTime GetLastResupplyTime (void)		{ return last_resupply_time; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastResupplyTime@BattalionClass@@UAEKXZ ENDP	; BattalionClass::GetLastResupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_increase$ = -12					; size = 4
_maxMorale$ = -8					; size = 4
_this$ = -4						; size = 4
_minutes$ = 8						; size = 4
?RallyUnit@BattalionClass@@UAEHH@Z PROC			; BattalionClass::RallyUnit
; _this$ = ecx

; 1648 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1649 : 	int		maxMorale,increase;
; 1650 : 
; 1651 : 	if (!fullstrength)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+297]
	test	ecx, ecx
	jne	SHORT $LN6@RallyUnit

; 1652 : 		fullstrength = GetFullstrengthVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+297], al
$LN6@RallyUnit:

; 1653 : 
; 1654 : 	if(fullstrength)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+297]
	test	ecx, ecx
	je	SHORT $LN5@RallyUnit

; 1655 : 		maxMorale = (GetTotalVehicles() * 100) / fullstrength;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	imul	eax, 100				; 00000064H
	mov	edx, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [edx+297]
	cdq
	idiv	ecx
	mov	DWORD PTR _maxMorale$[ebp], eax

; 1656 : 	else

	jmp	SHORT $LN4@RallyUnit
$LN5@RallyUnit:

; 1657 : 		maxMorale = 0;  // MLR 6/26/2004 - 0 er?

	mov	DWORD PTR _maxMorale$[ebp], 0
$LN4@RallyUnit:

; 1658 : 
; 1659 : 	// Regain MORALE_REGAIN_RATE % of maxMorale each hour we've been waiting
; 1660 : 	if (/*!Engaged() &&*/ GetUnitMorale() < maxMorale)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+780]
	call	edx
	cmp	eax, DWORD PTR _maxMorale$[ebp]
	jge	SHORT $LN3@RallyUnit

; 1661 : 	{
; 1662 : 		increase = (MORALE_REGAIN_RATE * minutes * maxMorale) / 6000;

	movsx	eax, WORD PTR ?MORALE_REGAIN_RATE@@3FA	; MORALE_REGAIN_RATE
	imul	eax, DWORD PTR _minutes$[ebp]
	imul	eax, DWORD PTR _maxMorale$[ebp]
	cdq
	mov	ecx, 6000				; 00001770H
	idiv	ecx
	mov	DWORD PTR _increase$[ebp], eax

; 1663 : 		if (increase < 1)

	cmp	DWORD PTR _increase$[ebp], 1
	jge	SHORT $LN2@RallyUnit

; 1664 : 			increase = 1;

	mov	DWORD PTR _increase$[ebp], 1
$LN2@RallyUnit:

; 1665 : 		SetUnitMorale(GetUnitMorale() + increase);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+780]
	call	edx
	add	eax, DWORD PTR _increase$[ebp]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+752]
	call	eax
$LN3@RallyUnit:

; 1666 : 	}
; 1667 : 	if (GetUnitMorale() >= maxMorale)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+780]
	call	eax
	cmp	eax, DWORD PTR _maxMorale$[ebp]
	jl	SHORT $LN1@RallyUnit

; 1668 : 	{
; 1669 : 		SetUnitMorale(maxMorale);

	mov	ecx, DWORD PTR _maxMorale$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+752]
	call	edx

; 1670 : 		SetBroken(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBroken@UnitClass@@QAEXH@Z		; UnitClass::SetBroken
$LN1@RallyUnit:

; 1671 : 	}
; 1672 : 
; 1673 : 	return Broken();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken

; 1674 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RallyUnit@BattalionClass@@UAEHH@Z ENDP			; BattalionClass::RallyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitPosition@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPosition@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetUnitPosition, COMDAT
; _this$ = ecx

; 159  : 	virtual int GetUnitPosition (void)					{ return position; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+299]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPosition@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_brig$ = -12						; size = 4
_this$ = -8						; size = 4
_i$3 = -4						; size = 4
?GetUnitElement@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetUnitElement
; _this$ = ecx

; 1632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1633 : 	Brigade		brig = (Brigade)GetUnitParent();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brig$[ebp], eax

; 1634 : 
; 1635 : 	if (brig)

	cmp	DWORD PTR _brig$[ebp], 0
	je	SHORT $LN5@GetUnitEle

; 1636 : 	{
; 1637 : 		for (int i=0; i<MAX_UNIT_CHILDREN; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@GetUnitEle
$LN3@GetUnitEle:
	mov	ecx, DWORD PTR _i$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$3[ebp], ecx
$LN4@GetUnitEle:
	cmp	DWORD PTR _i$3[ebp], 5
	jge	SHORT $LN5@GetUnitEle

; 1638 : 		{
; 1639 : 			if (Id() == brig->GetElement(i))

	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _brig$[ebp]
	call	?GetElement@BrigadeClass@@QAE?AVVU_ID@@H@Z ; BrigadeClass::GetElement
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetUnitEle

; 1640 : 				return i;

	mov	eax, DWORD PTR _i$3[ebp]
	jmp	SHORT $LN6@GetUnitEle
$LN1@GetUnitEle:

; 1641 : 		}

	jmp	SHORT $LN3@GetUnitEle
$LN5@GetUnitEle:

; 1642 : 		ShiAssert ( 0 );
; 1643 : 	}
; 1644 : 	return 0;

	xor	eax, eax
$LN6@GetUnitEle:

; 1645 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitElement@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetNextMoveDirection@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextMoveDirection@BattalionClass@@UAEHXZ PROC	; BattalionClass::GetNextMoveDirection, COMDAT
; _this$ = ecx

; 157  : 	virtual int GetNextMoveDirection (void)				{ return path->GetNextDirection(); MakeBattalionDirty(DIRTY_SMALLPATH, SEND_SOON); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	call	?GetNextDirection@BasePathClass@@QAEHXZ	; BasePathClass::GetNextDirection
	jmp	SHORT $LN1@GetNextMov
	push	4096					; 00001000H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty
$LN1@GetNextMov:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextMoveDirection@BattalionClass@@UAEHXZ ENDP	; BattalionClass::GetNextMoveDirection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitHeading@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitHeading@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetUnitHeading, COMDAT
; _this$ = ecx

; 156  : 	virtual int GetUnitHeading (void)					{ return (int)heading; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+296]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitHeading@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitMorale@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMorale@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetUnitMorale, COMDAT
; _this$ = ecx

; 155  : 	virtual int GetUnitMorale (void)					{ return (int)morale; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+294]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMorale@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetUnitMorale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitFatigue@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitFatigue@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetUnitFatigue, COMDAT
; _this$ = ecx

; 154  : 	virtual int GetUnitFatigue (void)					{ return (int)fatigue; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+293]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFatigue@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetUnitFatigue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitSupply@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSupply@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetUnitSupply, COMDAT
; _this$ = ecx

; 153  : 	virtual int GetUnitSupply (void)					{ return (int)supply; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+292]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSupply@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetUnitSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetAirTarget@BattalionClass@@UAEXPAVFalconEntity@@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetAirTarget@BattalionClass@@UAEXPAVFalconEntity@@@Z PROC ; BattalionClass::SetAirTarget, COMDAT
; _this$ = ecx

; 146  : 	virtual void SetAirTarget (FalconEntity *t)			{ if (t) air_target = t->Id(); else air_target = FalconNullId; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN2@SetAirTarg
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+348], ecx
	mov	DWORD PTR [eax+352], edx
	jmp	SHORT $LN3@SetAirTarg
$LN2@SetAirTarg:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+348], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+352], eax
$LN3@SetAirTarg:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAirTarget@BattalionClass@@UAEXPAVFalconEntity@@@Z ENDP ; BattalionClass::SetAirTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetAirTarget@BattalionClass@@UAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirTarget@BattalionClass@@UAEPAVFalconEntity@@XZ PROC ; BattalionClass::GetAirTarget, COMDAT
; _this$ = ecx

; 145  : 	virtual FalconEntity* GetAirTarget (void)			{ return (FalconEntity*)vuDatabase->Find(air_target); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	push	ecx
	mov	edx, DWORD PTR [eax+348]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirTarget@BattalionClass@@UAEPAVFalconEntity@@XZ ENDP ; BattalionClass::GetAirTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetAirTargetID@BattalionClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetAirTargetID@BattalionClass@@UAE?AVVU_ID@@XZ PROC	; BattalionClass::GetAirTargetID, COMDAT
; _this$ = ecx

; 144  : 	virtual VU_ID GetAirTargetID (void)					{ return air_target; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	mov	edx, DWORD PTR [eax+352]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAirTargetID@BattalionClass@@UAE?AVVU_ID@@XZ ENDP	; BattalionClass::GetAirTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitParentID@BattalionClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitParentID@BattalionClass@@UAE?AVVU_ID@@XZ PROC	; BattalionClass::GetUnitParentID, COMDAT
; _this$ = ecx

; 143  : 	virtual VU_ID GetUnitParentID (void)				{ return parent_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	mov	edx, DWORD PTR [eax+336]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitParentID@BattalionClass@@UAE?AVVU_ID@@XZ ENDP	; BattalionClass::GetUnitParentID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetUnitParent@BattalionClass@@UBEPAVUnitClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitParent@BattalionClass@@UBEPAVUnitClass@@XZ PROC	; BattalionClass::GetUnitParent, COMDAT
; _this$ = ecx

; 142  : 	virtual Unit GetUnitParent() const					{ return (Unit)vuDatabase->Find(parent_id); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	push	ecx
	mov	edx, DWORD PTR [eax+332]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitParent@BattalionClass@@UBEPAVUnitClass@@XZ ENDP	; BattalionClass::GetUnitParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetCombatTime@BattalionClass@@UAEKXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?GetCombatTime@BattalionClass@@UAEKXZ PROC		; BattalionClass::GetCombatTime, COMDAT
; _this$ = ecx

; 141  : 	virtual CampaignTime GetCombatTime (void)			{ return (TheCampaign.CurrentTime>last_combat)? TheCampaign.CurrentTime - last_combat:0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	ecx, DWORD PTR [eax+328]
	jbe	SHORT $LN3@GetCombatT
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	eax, DWORD PTR [edx+328]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@GetCombatT
$LN3@GetCombatT:
	mov	DWORD PTR tv68[ebp], 0
$LN4@GetCombatT:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatTime@BattalionClass@@UAEKXZ ENDP		; BattalionClass::GetCombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMoveTime@BattalionClass@@UAEKXZ PROC		; BattalionClass::GetMoveTime
; _this$ = ecx

; 2132 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2133 : 	if (last_move && TheCampaign.CurrentTime > last_move)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+324], 0
	je	SHORT $LN1@GetMoveTim
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	edx, DWORD PTR [ecx+324]
	jbe	SHORT $LN1@GetMoveTim

; 2134 : 		return TheCampaign.CurrentTime - last_move;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, DWORD PTR [eax+324]
	mov	eax, ecx
	jmp	SHORT $LN2@GetMoveTim
$LN1@GetMoveTim:

; 2135 : 
; 2136 : 	last_move = TheCampaign.CurrentTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR [edx+324], eax

; 2137 : 
; 2138 : 	return 0;

	xor	eax, eax
$LN2@GetMoveTim:

; 2139 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveTime@BattalionClass@@UAEKXZ ENDP		; BattalionClass::GetMoveTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv64 = -4						; size = 4
_type$ = 8						; size = 4
_them$ = 12						; size = 4
_flight$ = 16						; size = 8
?HandleRequestReceipt@BattalionClass@@UAEXHHVVU_ID@@@Z PROC ; BattalionClass::HandleRequestReceipt
; _this$ = ecx

; 2120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2121 : 	switch (type)

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 32			; 00000020H
	je	SHORT $LN2@HandleRequ
	jmp	SHORT $LN5@HandleRequ
$LN2@HandleRequ:

; 2122 : 	{
; 2123 : 		case AMIS_AIRCAV:
; 2124 : 			SetCargoId (flight);

	mov	ecx, DWORD PTR _flight$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _flight$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z	; UnitClass::SetCargoId
$LN5@HandleRequ:

; 2125 : 			break;
; 2126 : 		default:
; 2127 : 			break;
; 2128 : 	}
; 2129 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?HandleRequestReceipt@BattalionClass@@UAEXHHVVU_ID@@@Z ENDP ; BattalionClass::HandleRequestReceipt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv185 = -52						; size = 8
_sincos$ = -44						; size = 8
tv227 = -36						; size = 4
tv221 = -32						; size = 4
_heading$ = -28						; size = 4
_movetime$ = -24					; size = 4
_speed$ = -20						; size = 4
_dist$ = -16						; size = 4
tv182 = -12						; size = 4
_h$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?GetRealPosition@BattalionClass@@UAEXPAM00@Z PROC	; BattalionClass::GetRealPosition
; _this$ = ecx

; 2093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 2094 : 	// This will use the last move time to determine the real x,y & z of the unit
; 2095 : 	float			movetime = (float)(SimLibElapsedTime - last_move) / VU_TICS_PER_SECOND;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR [eax+324]
	mov	DWORD PTR tv182[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR tv182[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv185[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv185[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _movetime$[ebp], xmm0

; 2096 : 	float			speed;
; 2097 : 	float			heading;
; 2098 : 	float			dist;
; 2099 : 	int				h = GetNextMoveDirection();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+920]
	call	eax
	mov	DWORD PTR _h$[ebp], eax

; 2100 : 	mlTrig			sincos;
; 2101 : 
; 2102 : 	if (h < 0 || h > 7 || SimLibElapsedTime < last_move)

	cmp	DWORD PTR _h$[ebp], 0
	jl	SHORT $LN1@GetRealPos
	cmp	DWORD PTR _h$[ebp], 7
	jg	SHORT $LN1@GetRealPos
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	edx, DWORD PTR [ecx+324]
	jae	SHORT $LN2@GetRealPos
$LN1@GetRealPos:

; 2103 : 	{
; 2104 : 		*x = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _x$[ebp]
	fstp	DWORD PTR [eax]

; 2105 : 		*y = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	ecx, DWORD PTR _y$[ebp]
	fstp	DWORD PTR [ecx]

; 2106 : 		*z = TheMap.GetMEA(XPos(),YPos());;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	mov	edx, DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx]

; 2107 : 		return;

	jmp	$LN3@GetRealPos
$LN2@GetRealPos:

; 2108 : 	}
; 2109 : 
; 2110 : 	speed = (float) GetUnitSpeed() * KPH_TO_FPS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+516]
	call	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f693e32
	movss	DWORD PTR _speed$[ebp], xmm0

; 2111 : 	dist = speed * movetime;

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR _dist$[ebp], xmm0

; 2112 : 	heading = h * 45.0F * DTR;

	cvtsi2ss xmm0, DWORD PTR _h$[ebp]
	mulss	xmm0, DWORD PTR __real@42340000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _heading$[ebp], xmm0

; 2113 : 	mlSinCos(&sincos, heading);

	push	ecx
	movss	xmm0, DWORD PTR _heading$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _sincos$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2114 : 	*x = XPos() + dist * sincos.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv221[ebp]
	movss	xmm0, DWORD PTR tv221[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp]
	mulss	xmm1, DWORD PTR _sincos$[ebp+4]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2115 : 	*y = YPos() + dist * sincos.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv227[ebp]
	movss	xmm0, DWORD PTR tv227[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp]
	mulss	xmm1, DWORD PTR _sincos$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2116 : 	*z = TheMap.GetMEA(*x,*y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _x$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	mov	eax, DWORD PTR _z$[ebp]
	fstp	DWORD PTR [eax]
$LN3@GetRealPos:

; 2117 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetRealPosition@BattalionClass@@UAEXPAM00@Z ENDP	; BattalionClass::GetRealPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_cx$ = -36						; size = 2
_ny$ = -32						; size = 2
_nx$ = -28						; size = 2
_cy$ = -24						; size = 2
_this$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SimSetLocation@BattalionClass@@UAEXMMM@Z PROC		; BattalionClass::SimSetLocation
; _this$ = ecx

; 2069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2070 : 	GridIndex cx, cy, nx, ny;
; 2071 : 
; 2072 : 	// Check if battalion has moved, or needs to do detection
; 2073 : 	GetLocation(&cx, &cy);

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2074 : 	// sfr: xy order
; 2075 : 	//nx = SimToGrid(y);
; 2076 : 	//ny = SimToGrid(x);
; 2077 : 	::vector pos = { x, y };

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _pos$[ebp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _pos$[ebp+4], xmm0
	xor	edx, edx
	mov	DWORD PTR _pos$[ebp+8], edx

; 2078 : 	ConvertSimToGrid(&pos, &nx, &ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH

; 2079 : 	if (cx != nx || cy != ny){

	movsx	eax, WORD PTR _cx$[ebp]
	movsx	ecx, WORD PTR _nx$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@SimSetLoca
	movsx	edx, WORD PTR _cy$[ebp]
	movsx	eax, WORD PTR _ny$[ebp]
	cmp	edx, eax
	je	SHORT $LN2@SimSetLoca
$LN1@SimSetLoca:

; 2080 : 		SetPosition(x, y, z);

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 2081 : 		//MakeCampBaseDirty (DIRTY_POSITION, DDP[90].priority);
; 2082 : 		MakeCampBaseDirty (DIRTY_POSITION, SEND_SOON);

	push	4096					; 00001000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty

; 2083 : 		//MakeCampBaseDirty (DIRTY_ALTITUDE, DDP[91].priority);
; 2084 : 		MakeCampBaseDirty (DIRTY_ALTITUDE, SEND_SOON);

	push	4096					; 00001000H
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty

; 2085 : 		SetUnitNextMove();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	call	eax

; 2086 : 		SetUnitLastMove(Camp_GetCurrentTime());

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	call	eax

; 2087 : 		DetectOnMove();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+520]
	call	eax
$LN2@SimSetLoca:

; 2088 : 	}
; 2089 : 	// Currently, we're going to assume we'll do detection on Campaign thread
; 2090 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SimSetLocation@BattalionClass@@UAEXMMM@Z ENDP		; BattalionClass::SimSetLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetUnitPosition@BattalionClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 1
?SetUnitPosition@BattalionClass@@UAEXE@Z PROC		; BattalionClass::SetUnitPosition, COMDAT
; _this$ = ecx

; 135  : 	virtual void SetUnitPosition (uchar p)				{ position = p; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _p$[ebp]
	mov	BYTE PTR [eax+299], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPosition@BattalionClass@@UAEXE@Z ENDP		; BattalionClass::SetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetLastResupplyTime@BattalionClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetLastResupplyTime@BattalionClass@@UAEXK@Z PROC	; BattalionClass::SetLastResupplyTime, COMDAT
; _this$ = ecx

; 134  : 	virtual void SetLastResupplyTime (CampaignTime t)	{ last_resupply_time = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+320], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastResupplyTime@BattalionClass@@UAEXK@Z ENDP	; BattalionClass::SetLastResupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?ClearUnitPath@BattalionClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearUnitPath@BattalionClass@@UAEXXZ PROC		; BattalionClass::ClearUnitPath, COMDAT
; _this$ = ecx

; 133  : 	virtual void ClearUnitPath (void)					{ path->ClearPath(); MakeBattalionDirty(DIRTY_SMALLPATH, SEND_SOON); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	call	?ClearPath@BasePathClass@@QAEXXZ	; BasePathClass::ClearPath
	push	4096					; 00001000H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearUnitPath@BattalionClass@@UAEXXZ ENDP		; BattalionClass::ClearUnitPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetUnitNextMove@BattalionClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetUnitNextMove@BattalionClass@@UAEXXZ PROC		; BattalionClass::SetUnitNextMove, COMDAT
; _this$ = ecx

; 132  : 	virtual void SetUnitNextMove (void)					{ path->StepPath(); MakeBattalionDirty(DIRTY_SMALLPATH, SEND_SOON); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	call	?StepPath@BasePathClass@@QAEXXZ		; BasePathClass::StepPath
	push	4096					; 00001000H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty
	mov	esp, ebp
	pop	ebp
	ret	0
?SetUnitNextMove@BattalionClass@@UAEXXZ ENDP		; BattalionClass::SetUnitNextMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetUnitHeading@BattalionClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 1
?SetUnitHeading@BattalionClass@@UAEXE@Z PROC		; BattalionClass::SetUnitHeading, COMDAT
; _this$ = ecx

; 131  : 	virtual void SetUnitHeading (uchar h)			 	{ heading = h; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _h$[ebp]
	mov	BYTE PTR [eax+296], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitHeading@BattalionClass@@UAEXE@Z ENDP		; BattalionClass::SetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m$ = 8							; size = 4
?SetUnitMorale@BattalionClass@@UAEXH@Z PROC		; BattalionClass::SetUnitMorale
; _this$ = ecx

; 2155 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2156 : 	if (m > 100)

	cmp	DWORD PTR _m$[ebp], 100			; 00000064H
	jle	SHORT $LN2@SetUnitMor

; 2157 : 		m = 100;

	mov	DWORD PTR _m$[ebp], 100			; 00000064H
$LN2@SetUnitMor:

; 2158 : 	if (m < 0)

	cmp	DWORD PTR _m$[ebp], 0
	jge	SHORT $LN1@SetUnitMor

; 2159 : 		m = 0;

	mov	DWORD PTR _m$[ebp], 0
$LN1@SetUnitMor:

; 2160 : 	morale = m;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _m$[ebp]
	mov	BYTE PTR [eax+294], cl

; 2161 : 	MakeBattalionDirty (DIRTY_MORALE, DDP[92].priority);

	mov	edx, 4
	imul	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty

; 2162 : 	//	MakeBattalionDirty (DIRTY_MORALE, SEND_EVENTUALLY);
; 2163 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMorale@BattalionClass@@UAEXH@Z ENDP		; BattalionClass::SetUnitMorale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?SetUnitFatigue@BattalionClass@@UAEXH@Z PROC		; BattalionClass::SetUnitFatigue
; _this$ = ecx

; 2170 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2171 : 	if (f > 100)

	cmp	DWORD PTR _f$[ebp], 100			; 00000064H
	jle	SHORT $LN2@SetUnitFat

; 2172 : 		f = 100;

	mov	DWORD PTR _f$[ebp], 100			; 00000064H
$LN2@SetUnitFat:

; 2173 : 	if (f < 0)

	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $LN1@SetUnitFat

; 2174 : 		f = 0;

	mov	DWORD PTR _f$[ebp], 0
$LN1@SetUnitFat:

; 2175 : 	fatigue = f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _f$[ebp]
	mov	BYTE PTR [eax+293], cl

; 2176 : 	MakeBattalionDirty (DIRTY_FATIGUE, DDP[93].priority);

	mov	edx, 4
	imul	edx, 93					; 0000005dH
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty

; 2177 : 	//	MakeBattalionDirty (DIRTY_FATIGUE, SEND_EVENTUALLY);
; 2178 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitFatigue@BattalionClass@@UAEXH@Z ENDP		; BattalionClass::SetUnitFatigue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?SetUnitSupply@BattalionClass@@UAEXH@Z PROC		; BattalionClass::SetUnitSupply
; _this$ = ecx

; 2185 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2186 : 	if (s > 100)

	cmp	DWORD PTR _s$[ebp], 100			; 00000064H
	jle	SHORT $LN2@SetUnitSup

; 2187 : 		s = 100;

	mov	DWORD PTR _s$[ebp], 100			; 00000064H
$LN2@SetUnitSup:

; 2188 : 	if (s < 0)

	cmp	DWORD PTR _s$[ebp], 0
	jge	SHORT $LN1@SetUnitSup

; 2189 : 		s = 0;

	mov	DWORD PTR _s$[ebp], 0
$LN1@SetUnitSup:

; 2190 : 	supply = s;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _s$[ebp]
	mov	BYTE PTR [eax+292], cl

; 2191 : 	MakeBattalionDirty (DIRTY_SUPPLY, DDP[94].priority);

	mov	edx, 4
	imul	edx, 94					; 0000005eH
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty

; 2192 : 	//	MakeBattalionDirty (DIRTY_SUPPLY, SEND_EVENTUALLY);
; 2193 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSupply@BattalionClass@@UAEXH@Z ENDP		; BattalionClass::SetUnitSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetUnitParent@BattalionClass@@UAEXPAVUnitClass@@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetUnitParent@BattalionClass@@UAEXPAVUnitClass@@@Z PROC ; BattalionClass::SetUnitParent, COMDAT
; _this$ = ecx

; 127  : 	virtual void SetUnitParent (Unit p)					{ parent_id = p->Id(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+332], ecx
	mov	DWORD PTR [eax+336], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitParent@BattalionClass@@UAEXPAVUnitClass@@@Z ENDP ; BattalionClass::SetUnitParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetCombatTime@BattalionClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetCombatTime@BattalionClass@@UAEXK@Z PROC		; BattalionClass::SetCombatTime, COMDAT
; _this$ = ecx

; 126  : 	virtual void SetCombatTime (CampaignTime t)			{ last_combat = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+328], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCombatTime@BattalionClass@@UAEXK@Z ENDP		; BattalionClass::SetCombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetUnitLastMove@BattalionClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetUnitLastMove@BattalionClass@@UAEXK@Z PROC		; BattalionClass::SetUnitLastMove, COMDAT
; _this$ = ecx

; 125  : 	virtual void SetUnitLastMove (CampaignTime t)		{ last_move = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+324], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitLastMove@BattalionClass@@UAEXK@Z ENDP		; BattalionClass::SetUnitLastMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetMissilesFlying@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMissilesFlying@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetMissilesFlying, COMDAT
; _this$ = ecx

; 122  : 	virtual int GetMissilesFlying (void)				{ return missiles_flying; }//me123

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+301]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMissilesFlying@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetMissilesFlying
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_bx$1 = -28						; size = 4
_by$2 = -24						; size = 4
tv531 = -20						; size = 4
tv529 = -16						; size = 4
_vis$3 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_simdata$ = 8						; size = 4
_remote$ = 12						; size = 4
?GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z PROC ; BattalionClass::GetVehicleDeagData
; _this$ = ecx

; 1516 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1517 : 	static CampEntity		ent;
; 1518 : 	static int				round;
; 1519 : 	int						i;
; 1520 : 
; 1521 : 	// Reinitialize static vars upon query of first vehicle
; 1522 : 	if (simdata->vehicleInUnit < 0)

	mov	eax, DWORD PTR _simdata$[ebp]
	movsx	ecx, WORD PTR [eax+42]
	test	ecx, ecx
	jge	$LN22@GetVehicle

; 1523 : 	{
; 1524 : 		simdata->vehicleInUnit = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [eax+42], dx

; 1525 : 		ent = NULL;

	mov	DWORD PTR ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A, 0

; 1526 : 		if (!remote)

	cmp	DWORD PTR _remote$[ebp], 0
	jne	$LN17@GetVehicle

; 1527 : 		{
; 1528 : 			simdata->ptIndex = GetDeaggregationPoint(0, &ent);

	push	OFFSET ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+468]
	call	eax
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 1529 : 			if (simdata->ptIndex) {

	mov	edx, DWORD PTR _simdata$[ebp]
	cmp	DWORD PTR [edx+84], 0
	je	SHORT $LN20@GetVehicle

; 1530 : 				// Yuck!  The first call returns only the list index, NOT a real point index.
; 1531 : 				// To ensure we have at least one point we have to actually query for it
; 1532 : 				// then reset again...
; 1533 : 				simdata->ptIndex = GetDeaggregationPoint(0, &ent);

	push	OFFSET ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+468]
	call	eax
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 1534 : 				ent = NULL;

	mov	DWORD PTR ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A, 0

; 1535 : 				GetDeaggregationPoint(0, &ent);

	push	OFFSET ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+468]
	call	edx
$LN20@GetVehicle:

; 1536 : 			}
; 1537 : 
; 1538 : 			round = 0;

	mov	DWORD PTR ?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA, 0

; 1539 : 			if (simdata->ptIndex == DPT_ERROR_NOT_READY)

	mov	eax, DWORD PTR _simdata$[ebp]
	cmp	DWORD PTR [eax+84], -1
	jne	SHORT $LN19@GetVehicle

; 1540 : 				return -1;

	or	eax, -1
	jmp	$LN23@GetVehicle
	jmp	SHORT $LN17@GetVehicle
$LN19@GetVehicle:

; 1541 : 			else if (simdata->ptIndex == DPT_ERROR_CANT_PLACE)

	mov	ecx, DWORD PTR _simdata$[ebp]
	cmp	DWORD PTR [ecx+84], -2			; fffffffeH
	jne	SHORT $LN17@GetVehicle

; 1542 : 			{
; 1543 : 				ShiAssert(0);
; 1544 : 				KillUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit

; 1545 : 				return -1;

	or	eax, -1
	jmp	$LN23@GetVehicle
$LN17@GetVehicle:

; 1546 : 			}
; 1547 : 		}
; 1548 : 	}
; 1549 : 	else

	jmp	SHORT $LN16@GetVehicle
$LN22@GetVehicle:

; 1550 : 		simdata->vehicleInUnit++;

	mov	edx, DWORD PTR _simdata$[ebp]
	mov	ax, WORD PTR [edx+42]
	add	ax, 1
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [ecx+42], ax
$LN16@GetVehicle:

; 1551 : 
; 1552 : 	// Three positioning schemes
; 1553 : 	if (!remote)

	cmp	DWORD PTR _remote$[ebp], 0
	jne	$LN8@GetVehicle

; 1554 : 	{
; 1555 : 		if (deag_data)						// Place in our last location

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+360], 0
	je	$LN14@GetVehicle

; 1556 : 		{
; 1557 : 			int				vis;
; 1558 : 			vis = GetNumVehicles(simdata->campSlot) - simdata->inSlot;

	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	edx, DWORD PTR _simdata$[ebp]
	sub	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _vis$3[ebp], eax

; 1559 : 			simdata->x = deag_data->position_data[simdata->campSlot*3 + vis-1].x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	mov	edx, DWORD PTR _simdata$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	mov	edx, DWORD PTR _vis$3[ebp]
	lea	eax, DWORD PTR [eax+edx-1]
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR _simdata$[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR [edx+56], eax

; 1560 : 			simdata->y = deag_data->position_data[simdata->campSlot*3 + vis-1].y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 3
	mov	eax, DWORD PTR _vis$3[ebp]
	lea	ecx, DWORD PTR [ecx+eax-1]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR [eax+60], ecx

; 1561 : 			simdata->z = 0.0F;				// We don't store data for air units

	mov	edx, DWORD PTR _simdata$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+64], xmm0

; 1562 : 			simdata->ptIndex = 0;

	mov	eax, DWORD PTR _simdata$[ebp]
	mov	DWORD PTR [eax+84], 0

; 1563 : 			simdata->heading = deag_data->position_data[simdata->campSlot*3 + vis-1].heading;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 3
	mov	eax, DWORD PTR _vis$3[ebp]
	lea	ecx, DWORD PTR [ecx+eax-1]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR [eax+68], ecx
	jmp	$LN8@GetVehicle
$LN14@GetVehicle:

; 1564 : 		}
; 1565 : 		else if (simdata->ptIndex)			// Place on a ground point, facing outward

	mov	edx, DWORD PTR _simdata$[ebp]
	cmp	DWORD PTR [edx+84], 0
	je	$LN12@GetVehicle

; 1566 : 		{
; 1567 : 			float	bx=simdata->x,by=simdata->y;

	mov	eax, DWORD PTR _simdata$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR _bx$1[ebp], xmm0
	mov	ecx, DWORD PTR _simdata$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR _by$2[ebp], xmm0

; 1568 : 			// Find the next point
; 1569 : 			simdata->ptIndex = GetDeaggregationPoint(simdata->campSlot, &ent);

	push	OFFSET ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	mov	edx, DWORD PTR _simdata$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+468]
	call	eax
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 1570 : 			if (!simdata->ptIndex)

	mov	edx, DWORD PTR _simdata$[ebp]
	cmp	DWORD PTR [edx+84], 0
	jne	SHORT $LN11@GetVehicle

; 1571 : 			{
; 1572 : 				// Reuse the old points, but with an offset
; 1573 : 				ent = NULL;

	mov	DWORD PTR ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A, 0

; 1574 : 				GetDeaggregationPoint(simdata->campSlot, &ent);		// Reset

	push	OFFSET ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+468]
	call	edx

; 1575 : 				simdata->ptIndex = GetDeaggregationPoint(simdata->campSlot, &ent);

	push	OFFSET ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+468]
	call	edx
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 1576 : 				round++;

	mov	edx, DWORD PTR ?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA
	add	edx, 1
	mov	DWORD PTR ?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA, edx
$LN11@GetVehicle:

; 1577 : 			}
; 1578 : 
; 1579 : 			//ShiAssert( simdata->ptIndex );	// Point list with none of the point we wanted!
; 1580 : 			// HACK to tolerate bad data -- Shouldn't have to test this.
; 1581 : 			if (simdata->ptIndex) {

	mov	eax, DWORD PTR _simdata$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	$LN10@GetVehicle

; 1582 : 				TranslatePointData(ent, simdata->ptIndex, &simdata->x, &simdata->y);

	mov	ecx, DWORD PTR _simdata$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _simdata$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR ?ent@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4PAVCampBaseClass@@A
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 1583 : 				// RV - Biker - Give some greater offset in X and Y
; 1584 : 				//simdata->y += round*50.0F;
; 1585 : 				simdata->y += round*((rand()% 50)+200.0f);

	cvtsi2ss xmm0, DWORD PTR ?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA
	movss	DWORD PTR tv529[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	cvtsi2ss xmm0, edx
	addss	xmm0, DWORD PTR __real@43480000
	movss	xmm1, DWORD PTR tv529[ebp]
	mulss	xmm1, xmm0
	mov	edx, DWORD PTR _simdata$[ebp]
	addss	xmm1, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _simdata$[ebp]
	movss	DWORD PTR [eax+60], xmm1

; 1586 : 				simdata->x += round*((rand()%500)-250.0f);

	cvtsi2ss xmm0, DWORD PTR ?round@?1??GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z@4HA
	movss	DWORD PTR tv531[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	cvtsi2ss xmm0, edx
	subss	xmm0, DWORD PTR __real@437a0000
	movss	xmm1, DWORD PTR tv531[ebp]
	mulss	xmm1, xmm0
	mov	edx, DWORD PTR _simdata$[ebp]
	addss	xmm1, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _simdata$[ebp]
	movss	DWORD PTR [eax+56], xmm1

; 1587 : 				// Face away from center - NOTE: may need to use different facing sceme by pt type
; 1588 : 				simdata->heading = (float)atan2(simdata->x-bx,simdata->y-by);

	mov	ecx, DWORD PTR _simdata$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	subss	xmm0, DWORD PTR _by$2[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _simdata$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	subss	xmm0, DWORD PTR _bx$1[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _simdata$[ebp]
	fstp	DWORD PTR [eax+68]

; 1589 : 			}
; 1590 : 			else 

	jmp	SHORT $LN9@GetVehicle
$LN10@GetVehicle:

; 1591 : 			{
; 1592 : 				// We're stuck -- no data for the points we needed, so let the ground AI decide...
; 1593 : 				simdata->heading = 45.0F * DTR * heading;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+296]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f490fd9
	mov	eax, DWORD PTR _simdata$[ebp]
	movss	DWORD PTR [eax+68], xmm0

; 1594 : 				FindVehiclePosition(simdata);

	mov	ecx, DWORD PTR _simdata$[ebp]
	push	ecx
	call	?FindVehiclePosition@@YAXPAVSimInitDataClass@@@Z ; FindVehiclePosition
	add	esp, 4
$LN9@GetVehicle:

; 1595 : 			}
; 1596 : 			simdata->z = 0.0F;

	mov	edx, DWORD PTR _simdata$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+64], xmm0

; 1597 : 		}
; 1598 : 		else								// KCK: Let the ground AI decide where to put them

	jmp	SHORT $LN8@GetVehicle
$LN12@GetVehicle:

; 1599 : 		{
; 1600 : 			simdata->heading = 45.0F * DTR * heading;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+296]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3f490fd9
	mov	edx, DWORD PTR _simdata$[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 1601 : 			FindVehiclePosition(simdata);

	mov	eax, DWORD PTR _simdata$[ebp]
	push	eax
	call	?FindVehiclePosition@@YAXPAVSimInitDataClass@@@Z ; FindVehiclePosition
	add	esp, 4
$LN8@GetVehicle:

; 1602 : 		}
; 1603 : 	}
; 1604 : 
; 1605 : 	// Determine skill (Sim only uses it for anti-air stuff right now, so bow to expedience)
; 1606 : 	//	if (GetRClass() == RCLASS_AIRDEFENSE)
; 1607 : 	simdata->skill = ((TeamInfo[GetOwner()]->airDefenseExperience - 60) / 10) + rand()%3 - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, BYTE PTR [edx+613]
	sub	eax, 60					; 0000003cH
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	esi, eax
	call	_rand
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [esi+edx-1]
	mov	eax, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [eax+44], dx

; 1608 : 	//	else
; 1609 : 	//		simdata->skill = ((TeamInfo[GetOwner()]->groundExperience - 60) / 10) + rand()%3 - 1;
; 1610 : 
; 1611 : 	// Clamp it to legal sim side values
; 1612 : 	if (simdata->skill > 4)

	mov	ecx, DWORD PTR _simdata$[ebp]
	movsx	edx, WORD PTR [ecx+44]
	cmp	edx, 4
	jle	SHORT $LN7@GetVehicle

; 1613 : 		simdata->skill = 4;

	mov	eax, 4
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [ecx+44], ax
$LN7@GetVehicle:

; 1614 : 	if (simdata->skill < 0)

	mov	edx, DWORD PTR _simdata$[ebp]
	movsx	eax, WORD PTR [edx+44]
	test	eax, eax
	jge	SHORT $LN6@GetVehicle

; 1615 : 		simdata->skill = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [edx+44], cx
$LN6@GetVehicle:

; 1616 : 
; 1617 : 	// Weapon loadout
; 1618 : 	for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@GetVehicle
$LN4@GetVehicle:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@GetVehicle:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@GetVehicle

; 1619 : 	{
; 1620 : 		simdata->weapon[i] = GetUnitWeaponId(i,simdata->campSlot);

	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+584]
	call	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [edx+ecx*2+96], ax

; 1621 : 		if (simdata->weapon[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _simdata$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+96]
	test	edx, edx
	je	SHORT $LN2@GetVehicle

; 1622 : 			simdata->weapons[i] = GetUnitWeaponCount(i,simdata->campSlot);

	mov	eax, DWORD PTR _simdata$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	call	eax
	mov	ecx, DWORD PTR _simdata$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+128], al

; 1623 : 		else

	jmp	SHORT $LN1@GetVehicle
$LN2@GetVehicle:

; 1624 : 			simdata->weapons[i] = 0;

	mov	edx, DWORD PTR _simdata$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx+128], 0
$LN1@GetVehicle:

; 1625 : 	}

	jmp	SHORT $LN4@GetVehicle
$LN3@GetVehicle:

; 1626 : 
; 1627 : 	simdata->playerSlot = NO_PILOT;

	mov	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _simdata$[ebp]
	mov	WORD PTR [ecx+40], ax

; 1628 : 	return  MOTION_GND_AI;

	mov	eax, 262144				; 00040000H
$LN23@GetVehicle:

; 1629 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?GetVehicleDeagData@BattalionClass@@UAEHPAVSimInitDataClass@@H@Z ENDP ; BattalionClass::GetVehicleDeagData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv712 = -108						; size = 8
tv683 = -100						; size = 8
tv656 = -92						; size = 8
tv634 = -84						; size = 8
tv612 = -76						; size = 8
tv598 = -68						; size = 8
_timetoaquire$ = -60					; size = 4
tv709 = -56						; size = 4
tv680 = -52						; size = 4
tv653 = -48						; size = 4
tv631 = -44						; size = 4
tv609 = -40						; size = 4
tv595 = -36						; size = 4
tv305 = -32						; size = 4
_out$ = -28						; size = 4
_newMode$ = -24						; size = 4
_radMode$ = -20						; size = 4
_timetosearch$ = -16					; size = 4
_skill$ = -12						; size = 4
_radarData$ = -8					; size = 4
_this$ = -4						; size = 4
_t$ = 8							; size = 4
_d$ = 12						; size = 4
_range$ = 16						; size = 4
?StepRadar@BattalionClass@@UAEHHHM@Z PROC		; BattalionClass::StepRadar
; _this$ = ecx

; 1290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1291 : #ifdef DEBUG
; 1292 : 	char label[40] = "AGG -";
; 1293 : #endif
; 1294 : 	int	radMode = GetRadarMode();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	mov	DWORD PTR _radMode$[ebp], eax

; 1295 : 	int newMode = FEC_RADAR_OFF; // 2002-03-21 ADDED BY S.G. In order to accomodate the radar label, I'm using a var to hold the return value instead of calling 'return' for the if body themself. 'else' were also added in front of the 'if' so they are exclusive

	mov	DWORD PTR _newMode$[ebp], 0

; 1296 : 	if (IsAggregate() || g_bOldSamActivity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN43@StepRadar
	movzx	ecx, BYTE PTR ?g_bOldSamActivity@@3_NA	; g_bOldSamActivity
	test	ecx, ecx
	je	$LN44@StepRadar
$LN43@StepRadar:

; 1297 : 	{
; 1298 : 		// Check if we still have any radar vehicles
; 1299 : 		if (class_data->RadarVehicle == 255 || !GetNumVehicles(class_data->RadarVehicle))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	movzx	ecx, BYTE PTR [eax+328]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN41@StepRadar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	movzx	ecx, BYTE PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	jne	SHORT $LN42@StepRadar
$LN41@StepRadar:

; 1300 : 			newMode = FEC_RADAR_OFF;

	mov	DWORD PTR _newMode$[ebp], 0
	jmp	$LN35@StepRadar
$LN42@StepRadar:

; 1301 : 
; 1302 : 		// Check if we're already in our fire state
; 1303 : 		else if (radMode == FEC_RADAR_GUIDE || radMode == FEC_RADAR_SEARCH_100)

	cmp	DWORD PTR _radMode$[ebp], 6
	je	SHORT $LN38@StepRadar
	cmp	DWORD PTR _radMode$[ebp], 1
	jne	SHORT $LN39@StepRadar
$LN38@StepRadar:

; 1304 : 			newMode = radMode;

	mov	edx, DWORD PTR _radMode$[ebp]
	mov	DWORD PTR _newMode$[ebp], edx
	jmp	$LN35@StepRadar
$LN39@StepRadar:

; 1305 : 
; 1306 : 		// Check for switch over to guide
; 1307 : 		else if (radMode == FEC_RADAR_AQUIRE)

	cmp	DWORD PTR _radMode$[ebp], 5
	jne	SHORT $LN36@StepRadar

; 1308 : 		{
; 1309 : 			SetRadarMode(FEC_RADAR_GUIDE);

	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1310 : 			newMode = FEC_RADAR_GUIDE;

	mov	DWORD PTR _newMode$[ebp], 6

; 1311 : 		}
; 1312 : 		else {

	jmp	$LN35@StepRadar
$LN36@StepRadar:

; 1313 : 			SetRadarMode(FEC_RADAR_AQUIRE);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1314 : 			// KCK: Good operators could shoot before going to guide mode. Check skill and return TRUE
; 1315 : 			if (
; 1316 : 				GetRadarMode() == FEC_RADAR_AQUIRE &&
; 1317 : 				rand()%100 < TeamInfo[GetOwner()]->airDefenseExperience - MINIMUM_EXP_TO_FIRE_PREGUIDE
; 1318 : 			){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN34@StepRadar
	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	esi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, BYTE PTR [eax+613]
	movsx	edx, WORD PTR ?MINIMUM_EXP_TO_FIRE_PREGUIDE@@3FA ; MINIMUM_EXP_TO_FIRE_PREGUIDE
	sub	ecx, edx
	cmp	esi, ecx
	jge	SHORT $LN34@StepRadar

; 1319 : 				SetRadarMode(FEC_RADAR_GUIDE);

	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
$LN34@StepRadar:

; 1320 : 			}
; 1321 : 			newMode = GetRadarMode();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	mov	DWORD PTR _newMode$[ebp], eax
$LN35@StepRadar:

; 1322 : 		}
; 1323 : 
; 1324 : #ifdef DEBUG
; 1325 : 		extern int g_nShowDebugLabels;
; 1326 : 
; 1327 : 		if (g_nShowDebugLabels & 0x04) {
; 1328 : 			switch (newMode) {
; 1329 : 				case FEC_RADAR_SEARCH_100:
; 1330 : 					strcat(label," S100");
; 1331 : 					break;
; 1332 : 				case FEC_RADAR_SEARCH_1:
; 1333 : 					strcat(label," S1");
; 1334 : 					break;
; 1335 : 				case FEC_RADAR_SEARCH_2:
; 1336 : 					strcat(label," S2");
; 1337 : 					break;
; 1338 : 				case FEC_RADAR_SEARCH_3:
; 1339 : 					strcat(label," S3");
; 1340 : 					break;
; 1341 : 				case FEC_RADAR_GUIDE:
; 1342 : 					strcat(label," Guide");
; 1343 : 					break;
; 1344 : 				case FEC_RADAR_AQUIRE:
; 1345 : 					strcat(label," Acquire");
; 1346 : 					break;
; 1347 : 				case FEC_RADAR_CHANGEMODE:// do nothing
; 1348 : 					strcat(label," Changemode");
; 1349 : 					break;
; 1350 : 				default:
; 1351 : 					// No emissions this time
; 1352 : 					strcat(label," OFF");
; 1353 : 					break;
; 1354 : 			}
; 1355 : 
; 1356 : 			if (draw_pointer) {
; 1357 : 				if (g_nShowDebugLabels & 0x04)
; 1358 : 					draw_pointer->SetLabel(label,draw_pointer->LabelColor());
; 1359 : 				else {
; 1360 : 					sprintf(label," ");
; 1361 : 					draw_pointer->SetLabel(label,draw_pointer->LabelColor());
; 1362 : 				}
; 1363 : 			}
; 1364 : 		}
; 1365 : #endif
; 1366 : 		return newMode;

	mov	eax, DWORD PTR _newMode$[ebp]
	jmp	$LN45@StepRadar
$LN44@StepRadar:

; 1367 : 	}
; 1368 : 
; 1369 : 	assert (range);
; 1370 : 
; 1371 : 	/*FEC_RADAR_OFF			0x00	   	// Radar always off
; 1372 : 	  FEC_RADAR_SEARCH_100	0x01	   	// Search Radar - 100 % of the time (always on)
; 1373 : 	  FEC_RADAR_SEARCH_1		0x02	   	// Search Sequence #1
; 1374 : 	  FEC_RADAR_SEARCH_2		0x03	   	// Search Sequence #2
; 1375 : 	  FEC_RADAR_SEARCH_3		0x04	   	// Search Sequence #3
; 1376 : 	  FEC_RADAR_AQUIRE		0x05	   	// Aquire Mode (looking for a target)
; 1377 : 	  FEC_RADAR_GUIDE			0x06	   	// Missile in flight. Death is imminent*/
; 1378 : 
; 1379 : 
; 1380 : 	// Check if we still have any radar vehicles
; 1381 : 	if (class_data->RadarVehicle == 255 || !GetNumVehicles(class_data->RadarVehicle ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	movzx	eax, BYTE PTR [edx+328]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN32@StepRadar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	movzx	eax, BYTE PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	jne	SHORT $LN33@StepRadar
$LN32@StepRadar:

; 1382 : 		return FEC_RADAR_OFF;

	xor	eax, eax
	jmp	$LN45@StepRadar
$LN33@StepRadar:

; 1383 : 
; 1384 : 	assert(radarDatFileTable != NULL);
; 1385 : 	RadarDataSet* radarData = &radarDatFileTable[((VehicleClassDataType *)Falcon4ClassTable[class_data->VehicleType[class_data->RadarVehicle]].dataPtr)->RadarType];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movzx	eax, BYTE PTR [ecx+328]
	movsx	ecx, WORD PTR [edx+eax*2+68]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	movsx	ecx, WORD PTR [eax+56]
	imul	ecx, 180				; 000000b4H
	add	ecx, DWORD PTR ?radarDatFileTable@@3PAURadarDataSet@@A ; radarDatFileTable
	mov	DWORD PTR _radarData$[ebp], ecx

; 1386 : 
; 1387 : 
; 1388 : 	// Check if we're already in our fire state
; 1389 : 	if (radMode == FEC_RADAR_SEARCH_100)

	cmp	DWORD PTR _radMode$[ebp], 1
	jne	SHORT $LN31@StepRadar

; 1390 : 		return radMode;

	mov	eax, DWORD PTR _radMode$[ebp]
	jmp	$LN45@StepRadar
$LN31@StepRadar:

; 1391 : 
; 1392 : 	// Check for switch over to guide
; 1393 : 	float skill = TeamInfo[GetOwner()]->airDefenseExperience/30.0f*1000; // from 1 - 3

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, BYTE PTR [eax+613]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@41f00000
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _skill$[ebp], xmm0

; 1394 : 	skill *= (float)radarData->Timeskillfactor;

	mov	edx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+84]
	mulss	xmm0, DWORD PTR _skill$[ebp]
	movss	DWORD PTR _skill$[ebp], xmm0

; 1395 : 	skill /=100.0f;

	movss	xmm0, DWORD PTR _skill$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _skill$[ebp], xmm0

; 1396 : 	float timetosearch ;
; 1397 : 	float timetoaquire ;
; 1398 : 	if (!d && !t) SetRadarMode(step_search_mode);

	cmp	DWORD PTR _d$[ebp], 0
	jne	SHORT $LN30@StepRadar
	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN30@StepRadar
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx
$LN30@StepRadar:

; 1399 : 
; 1400 : 	if (GetRadarMode() == FEC_RADAR_CHANGEMODE && step_search_mode >= FEC_RADAR_SEARCH_1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 7
	jne	SHORT $LN29@StepRadar
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+312]
	cmp	edx, 2
	jl	SHORT $LN29@StepRadar

; 1401 : 		SetRadarMode(step_search_mode);// we are changing mode.. realy not off

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx
$LN29@StepRadar:

; 1402 : 
; 1403 : 	switch (GetRadarMode())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	mov	DWORD PTR tv305[ebp], eax
	cmp	DWORD PTR tv305[ebp], 6
	ja	$LN27@StepRadar
	mov	ecx, DWORD PTR tv305[ebp]
	jmp	DWORD PTR $LN47@StepRadar[ecx*4]
$LN26@StepRadar:

; 1404 : 	{
; 1405 : 		case FEC_RADAR_OFF:
; 1406 : 			timetosearch = radarData->Timetosearch1 - skill;

	mov	edx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+16]
	subss	xmm0, DWORD PTR _skill$[ebp]
	movss	DWORD PTR _timetosearch$[ebp], xmm0

; 1407 : 			
; 1408 : 			if (range <= radarData->Rangetosearch1 && !SEARCHtimer){

	mov	eax, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR _range$[ebp]
	jb	SHORT $LN25@StepRadar
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	jne	SHORT $LN25@StepRadar

; 1409 : 				SEARCHtimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax
	jmp	SHORT $LN23@StepRadar
$LN25@StepRadar:

; 1410 : 			}
; 1411 : 			else if (range >= radarData->Rangetosearch1 || SimLibElapsedTime - SEARCHtimer > timetosearch+6000.0f){

	mov	ecx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+40]
	movss	xmm1, DWORD PTR _range$[ebp]
	comiss	xmm1, xmm0
	jae	SHORT $LN22@StepRadar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+304]
	mov	DWORD PTR tv595[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv595[ebp]
	mov	ecx, DWORD PTR tv595[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv598[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv598[ebp]
	movss	xmm1, DWORD PTR _timetosearch$[ebp]
	addss	xmm1, DWORD PTR __real@45bb8000
	comiss	xmm0, xmm1
	jbe	SHORT $LN23@StepRadar
$LN22@StepRadar:

; 1412 : 				SEARCHtimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], 0
$LN23@StepRadar:

; 1413 : 			}
; 1414 : 
; 1415 : 			if (range <= radarData->Rangetosearch1 && SEARCHtimer && SimLibElapsedTime - SEARCHtimer > timetosearch){

	mov	eax, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR _range$[ebp]
	jb	SHORT $LN21@StepRadar
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	je	SHORT $LN21@StepRadar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+304]
	mov	DWORD PTR tv609[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv609[ebp]
	mov	ecx, DWORD PTR tv609[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv612[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv612[ebp]
	comiss	xmm0, DWORD PTR _timetosearch$[ebp]
	jbe	SHORT $LN21@StepRadar

; 1416 : 				SEARCHtimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax

; 1417 : 				step_search_mode = FEC_RADAR_SEARCH_1 ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+312], 2

; 1418 : 				SetRadarMode(FEC_RADAR_SEARCH_1);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx
$LN21@StepRadar:

; 1419 : 			}
; 1420 : 		break;

	jmp	$LN27@StepRadar
$LN20@StepRadar:

; 1421 : 		case FEC_RADAR_SEARCH_1:
; 1422 : 			AQUIREtimer = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+308], ecx

; 1423 : 			if (!SEARCHtimer){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+304], 0
	jne	SHORT $LN19@StepRadar

; 1424 : 				SEARCHtimer = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+304], ecx
$LN19@StepRadar:

; 1425 : 			}
; 1426 : 			timetosearch = radarData->Timetosearch1 - skill;

	mov	edx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+16]
	subss	xmm0, DWORD PTR _skill$[ebp]
	movss	DWORD PTR _timetosearch$[ebp], xmm0

; 1427 : 
; 1428 : 			if (d && range <= radarData->Rangetosearch2 && SimLibElapsedTime - SEARCHtimer >= timetosearch){

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $LN18@StepRadar
	mov	eax, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+44]
	comiss	xmm0, DWORD PTR _range$[ebp]
	jb	SHORT $LN18@StepRadar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR tv631[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv631[ebp]
	mov	eax, DWORD PTR tv631[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv634[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv634[ebp]
	comiss	xmm0, DWORD PTR _timetosearch$[ebp]
	jb	SHORT $LN18@StepRadar

; 1429 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1430 : 				step_search_mode = FEC_RADAR_SEARCH_2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+312], 3

; 1431 : 				SEARCHtimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax
$LN18@StepRadar:

; 1432 : 			}
; 1433 : 		break;

	jmp	$LN27@StepRadar
$LN17@StepRadar:

; 1434 : 		case FEC_RADAR_SEARCH_2:
; 1435 : 			AQUIREtimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+308], edx

; 1436 : 			timetosearch = radarData->Timetosearch2 - skill;

	mov	eax, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+20]
	subss	xmm0, DWORD PTR _skill$[ebp]
	movss	DWORD PTR _timetosearch$[ebp], xmm0

; 1437 : 			if (!SEARCHtimer){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	jne	SHORT $LN16@StepRadar

; 1438 : 				SEARCHtimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax
$LN16@StepRadar:

; 1439 : 			}
; 1440 : 
; 1441 : 			if (d && range <= radarData->Rangetosearch3 &&  SimLibElapsedTime - SEARCHtimer >= timetosearch)

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $LN15@StepRadar
	mov	ecx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+48]
	comiss	xmm0, DWORD PTR _range$[ebp]
	jb	SHORT $LN15@StepRadar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+304]
	mov	DWORD PTR tv653[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv653[ebp]
	mov	ecx, DWORD PTR tv653[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv656[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv656[ebp]
	comiss	xmm0, DWORD PTR _timetosearch$[ebp]
	jb	SHORT $LN15@StepRadar

; 1442 : 			{
; 1443 : 				step_search_mode =FEC_RADAR_SEARCH_3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+312], 4

; 1444 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1445 : 				SEARCHtimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+304], edx
	jmp	SHORT $LN13@StepRadar
$LN15@StepRadar:

; 1446 : 			}
; 1447 : 			else if (!d)// no detection step search down

	cmp	DWORD PTR _d$[ebp], 0
	jne	SHORT $LN13@StepRadar

; 1448 : 			{
; 1449 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1450 : 				step_search_mode = FEC_RADAR_SEARCH_1 ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+312], 2

; 1451 : 				SEARCHtimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax
$LN13@StepRadar:

; 1452 : 			}
; 1453 : 			break;

	jmp	$LN27@StepRadar
$LN12@StepRadar:

; 1454 : 		case FEC_RADAR_SEARCH_3:
; 1455 : 			AQUIREtimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+308], edx

; 1456 : 			timetosearch = radarData->Timetosearch3 - skill;

	mov	eax, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+24]
	subss	xmm0, DWORD PTR _skill$[ebp]
	movss	DWORD PTR _timetosearch$[ebp], xmm0

; 1457 : 			if (!SEARCHtimer) SEARCHtimer = SimLibElapsedTime;		

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	jne	SHORT $LN11@StepRadar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax
$LN11@StepRadar:

; 1458 : 			// goto aquire ?
; 1459 : 			if (d && range <= radarData->Rangetoacuire && SimLibElapsedTime - SEARCHtimer >= timetosearch )

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $LN10@StepRadar
	mov	ecx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+52]
	comiss	xmm0, DWORD PTR _range$[ebp]
	jb	SHORT $LN10@StepRadar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+304]
	mov	DWORD PTR tv680[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv680[ebp]
	mov	ecx, DWORD PTR tv680[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv683[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv683[ebp]
	comiss	xmm0, DWORD PTR _timetosearch$[ebp]
	jb	SHORT $LN10@StepRadar

; 1460 : 			{
; 1461 : 				step_search_mode =FEC_RADAR_AQUIRE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+312], 5

; 1462 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1463 : 				AQUIREtimer = SimLibElapsedTime;		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+308], edx
	jmp	SHORT $LN8@StepRadar
$LN10@StepRadar:

; 1464 : 			}
; 1465 : 			else if(!d)//  no detection step search down

	cmp	DWORD PTR _d$[ebp], 0
	jne	SHORT $LN8@StepRadar

; 1466 : 			{
; 1467 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1468 : 				step_search_mode = FEC_RADAR_SEARCH_2 ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+312], 3

; 1469 : 				SEARCHtimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+304], eax
$LN8@StepRadar:

; 1470 : 			}
; 1471 : 			break;

	jmp	$LN27@StepRadar
$LN7@StepRadar:

; 1472 : 		case FEC_RADAR_AQUIRE:
; 1473 : 			SEARCHtimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 0

; 1474 : 			timetoaquire = radarData->Timetoacuire - skill;

	mov	edx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+28]
	subss	xmm0, DWORD PTR _skill$[ebp]
	movss	DWORD PTR _timetoaquire$[ebp], xmm0

; 1475 : 			// only allow to be in aquire for the coast amount of time
; 1476 : 			if (!t && !d && SimLibElapsedTime - AQUIREtimer >= (unsigned)radarData->Timetocoast)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN6@StepRadar
	cmp	DWORD PTR _d$[ebp], 0
	jne	SHORT $LN6@StepRadar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR [eax+308]
	mov	edx, DWORD PTR _radarData$[ebp]
	cmp	ecx, DWORD PTR [edx+36]
	jb	SHORT $LN6@StepRadar

; 1477 : 			{
; 1478 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1479 : 				step_search_mode = FEC_RADAR_SEARCH_3 ; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+312], 4
	jmp	SHORT $LN4@StepRadar
$LN6@StepRadar:

; 1480 : 			}
; 1481 : 			else if (t && range <= radarData->Rangetoguide && SimLibElapsedTime - AQUIREtimer >= timetoaquire)

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN4@StepRadar
	mov	edx, DWORD PTR _radarData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+56]
	comiss	xmm0, DWORD PTR _range$[ebp]
	jb	SHORT $LN4@StepRadar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR [eax+308]
	mov	DWORD PTR tv709[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv709[ebp]
	mov	edx, DWORD PTR tv709[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv712[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv712[ebp]
	comiss	xmm0, DWORD PTR _timetoaquire$[ebp]
	jb	SHORT $LN4@StepRadar

; 1482 : 			{
; 1483 : 				step_search_mode =FEC_RADAR_GUIDE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+312], 6

; 1484 : 				SetRadarMode(FEC_RADAR_CHANGEMODE);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 1485 : 				return FEC_RADAR_GUIDE;

	mov	eax, 6
	jmp	SHORT $LN45@StepRadar
$LN4@StepRadar:

; 1486 : 			}
; 1487 : 			break;

	jmp	SHORT $LN27@StepRadar
$LN3@StepRadar:

; 1488 : 		case FEC_RADAR_GUIDE:
; 1489 : 			AQUIREtimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+308], edx

; 1490 : 			step_search_mode = FEC_RADAR_AQUIRE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+312], 5

; 1491 : 			if (!t) SetRadarMode(FEC_RADAR_CHANGEMODE);

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@StepRadar
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
$LN2@StepRadar:
$LN27@StepRadar:

; 1492 : 			break;
; 1493 : 	}
; 1494 : 
; 1495 : 
; 1496 : 
; 1497 : 	/*	else if (SimLibElapsedTime - AQUIREtimer > timetoaquire)
; 1498 : 		{
; 1499 : 	// KCK: Good operators could shoot before going to guide mode. Check skill and return TRUE
; 1500 : 	if (
; 1501 : 		GetRadarMode() == FEC_RADAR_AQUIRE && 
; 1502 : 		rand()%100 < TeamInfo[GetOwner()]->airDefenseExperience - MINIMUM_EXP_TO_FIRE_PREGUIDE
; 1503 : 	)
; 1504 : 	{
; 1505 : 		search_mode = FEC_RADAR_AQUIRE ;
; 1506 : 		SetRadarMode(FEC_RADAR_GUIDE);
; 1507 : 	}
; 1508 : 	}
; 1509 : 	*/
; 1510 : 	int out = GetRadarMode();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	mov	DWORD PTR _out$[ebp], eax

; 1511 : 	if (out == FEC_RADAR_OFF) out = step_search_mode;

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN1@StepRadar
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+312]
	mov	DWORD PTR _out$[ebp], edx
$LN1@StepRadar:

; 1512 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN45@StepRadar:

; 1513 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN47@StepRadar:
	DD	$LN26@StepRadar
	DD	$LN27@StepRadar
	DD	$LN20@StepRadar
	DD	$LN17@StepRadar
	DD	$LN12@StepRadar
	DD	$LN7@StepRadar
	DD	$LN3@StepRadar
?StepRadar@BattalionClass@@UAEHHHM@Z ENDP		; BattalionClass::StepRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_radarData$1 = -8					; size = 4
_this$ = -4						; size = 4
_wid$ = 8						; size = 4
?CanShootWeapon@BattalionClass@@UAEHH@Z PROC		; BattalionClass::CanShootWeapon
; _this$ = ecx

; 1274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1275 : 	if (class_data->RadarVehicle < 255 && (class_data->VehicleType[class_data->RadarVehicle])) // 2002-02-07 MODIFIED BY S,G. Added check for RadarVehicle being less than 255 since 255 means 'no radar' and can cause a CTD if not checked.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movzx	edx, BYTE PTR [ecx+328]
	cmp	edx, 255				; 000000ffH
	jge	$LN6@CanShootWe
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	movzx	edx, BYTE PTR [eax+328]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	test	eax, eax
	je	SHORT $LN6@CanShootWe

; 1276 : 	{
; 1277 : 		RadarDataSet* radarData = &radarDatFileTable[((VehicleClassDataType *)Falcon4ClassTable[class_data->VehicleType[class_data->RadarVehicle]].dataPtr)->RadarType];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movzx	eax, BYTE PTR [ecx+328]
	movsx	ecx, WORD PTR [edx+eax*2+68]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	movsx	ecx, WORD PTR [eax+56]
	imul	ecx, 180				; 000000b4H
	add	ecx, DWORD PTR ?radarDatFileTable@@3PAURadarDataSet@@A ; radarDatFileTable
	mov	DWORD PTR _radarData$1[ebp], ecx

; 1278 : 		if (radarData && WeaponDataTable[wid].GuidanceFlags & WEAP_RADAR && missiles_flying >= radarData->Maxmissilesintheair)

	je	SHORT $LN5@CanShootWe
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 4
	je	SHORT $LN5@CanShootWe
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+301]
	mov	ecx, DWORD PTR _radarData$1[ebp]
	cmp	eax, DWORD PTR [ecx+132]
	jl	SHORT $LN5@CanShootWe

; 1279 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN7@CanShootWe
$LN5@CanShootWe:

; 1280 : 	}

	jmp	SHORT $LN4@CanShootWe
$LN6@CanShootWe:

; 1281 : 	else if (WeaponDataTable[wid].GuidanceFlags & WEAP_RADAR && missiles_flying >= 1)

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 4
	je	SHORT $LN4@CanShootWe
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+301]
	cmp	eax, 1
	jl	SHORT $LN4@CanShootWe

; 1282 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN7@CanShootWe
$LN4@CanShootWe:

; 1283 : 	// Check for radar guidance, and make adjustments if necessary
; 1284 : 	if (!(WeaponDataTable[wid].GuidanceFlags & WEAP_RADAR) || GetRadarMode() == FEC_RADAR_GUIDE || GetRadarMode() == FEC_RADAR_SEARCH_100)

	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	and	eax, 4
	je	SHORT $LN1@CanShootWe
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 6
	je	SHORT $LN1@CanShootWe
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN2@CanShootWe
$LN1@CanShootWe:

; 1285 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN7@CanShootWe
$LN2@CanShootWe:

; 1286 : 	return FALSE;

	xor	eax, eax
$LN7@CanShootWe:

; 1287 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CanShootWeapon@BattalionClass@@UAEHH@Z ENDP		; BattalionClass::CanShootWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetSearchMode@BattalionClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 1
?SetSearchMode@BattalionClass@@UAEXE@Z PROC		; BattalionClass::SetSearchMode, COMDAT
; _this$ = ecx

; 117  : 	virtual void SetSearchMode (uchar mode)				{ search_mode = mode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _mode$[ebp]
	mov	BYTE PTR [eax+300], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSearchMode@BattalionClass@@UAEXE@Z ENDP		; BattalionClass::SetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReturnToSearch@BattalionClass@@UAEXXZ PROC		; BattalionClass::ReturnToSearch
; _this$ = ecx

; 1255 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1256 : 	if (missiles_flying < 1 && IsEmitting())

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+301]
	cmp	ecx, 1
	jge	SHORT $LN6@ReturnToSe
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+216]
	call	edx
	test	eax, eax
	je	SHORT $LN6@ReturnToSe

; 1257 : 	{
; 1258 : 		// 2002-04-08 MN fix - this must also use Sylvain's new step_search_mode, not the old search_mode, or we will fall back from guide to search...
; 1259 : 		// 2002-04-11 ADDED BY S.G. If we have no missiles in the air anymore and we were off originally, switch back off, otherwise use the interim guidance step
; 1260 : 		if (search_mode == FEC_RADAR_OFF)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+300]
	test	ecx, ecx
	jne	SHORT $LN5@ReturnToSe

; 1261 : 			radar_mode = FEC_RADAR_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+298], 0

; 1262 : 		else

	jmp	SHORT $LN4@ReturnToSe
$LN5@ReturnToSe:

; 1263 : 			// END OF ADDED SECTION
; 1264 : 			radar_mode = step_search_mode; // search_mode

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+312]
	mov	BYTE PTR [eax+298], dl
$LN4@ReturnToSe:

; 1265 : 
; 1266 : 		if (radar_mode == FEC_RADAR_OFF)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+298]
	test	ecx, ecx
	jne	SHORT $LN3@ReturnToSe

; 1267 : 			SetEmitting(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEmitting@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetEmitting
$LN3@ReturnToSe:

; 1268 : 	}

	jmp	SHORT $LN7@ReturnToSe
$LN6@ReturnToSe:

; 1269 : 	else if (!IsEmitting())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+216]
	call	edx
	test	eax, eax
	jne	SHORT $LN7@ReturnToSe

; 1270 : 		radar_mode = FEC_RADAR_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+298], 0
$LN7@ReturnToSe:

; 1271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReturnToSearch@BattalionClass@@UAEXXZ ENDP		; BattalionClass::ReturnToSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?SetRadarMode@BattalionClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 1
?SetRadarMode@BattalionClass@@UAEXE@Z PROC		; BattalionClass::SetRadarMode, COMDAT
; _this$ = ecx

; 112  : 	virtual void SetRadarMode (uchar mode)				{ radar_mode = mode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _mode$[ebp]
	mov	BYTE PTR [eax+298], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarMode@BattalionClass@@UAEXE@Z ENDP		; BattalionClass::SetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetSearchMode@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSearchMode@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetSearchMode, COMDAT
; _this$ = ecx

; 109  : 	virtual int GetSearchMode (void)						{ return search_mode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+300]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSearchMode@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?GetRadarMode@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@BattalionClass@@UAEHXZ PROC		; BattalionClass::GetRadarMode, COMDAT
; _this$ = ecx

; 108  : 	virtual int GetRadarMode (void)						{ return radar_mode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+298]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@BattalionClass@@UAEHXZ ENDP		; BattalionClass::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
?GetElectronicDetectionRange@BattalionClass@@UAEHH@Z PROC ; BattalionClass::GetElectronicDetectionRange
; _this$ = ecx

; 1239 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1240 : 	if (class_data->RadarVehicle < 255 && GetNumVehicles(class_data->RadarVehicle))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movzx	edx, BYTE PTR [ecx+328]
	cmp	edx, 255				; 000000ffH
	jge	SHORT $LN2@GetElectro
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movzx	edx, BYTE PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	je	SHORT $LN2@GetElectro

; 1241 : 		// 2001-04-21 MODIFIED BY S.G. ABOVE 250 HAS A NEW MEANING SO USE THE UNIT ELECTRONIC DETECTION RANGE INSTEAD...
; 1242 : 		//		return class_data->Detection[mt];
; 1243 : 	{
; 1244 : 		if (class_data->Detection[mt] > 250)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+309]
	cmp	eax, 250				; 000000faH
	jle	SHORT $LN1@GetElectro

; 1245 : 		{
; 1246 : 			return 250 + (class_data->Detection[mt] - 250) * 50;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [edx+eax+309]
	sub	eax, 250				; 000000faH
	imul	eax, 50					; 00000032H
	add	eax, 250				; 000000faH
	jmp	SHORT $LN3@GetElectro
$LN1@GetElectro:

; 1247 : 		}
; 1248 : 
; 1249 : 		return class_data->Detection[mt];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [edx+eax+309]
	jmp	SHORT $LN3@GetElectro
$LN2@GetElectro:

; 1250 : 	}
; 1251 : 	return 0;

	xor	eax, eax
$LN3@GetElectro:

; 1252 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetElectronicDetectionRange@BattalionClass@@UAEHH@Z ENDP ; BattalionClass::GetElectronicDetectionRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_uc$ = -12						; size = 4
_dr$ = -8						; size = 4
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
?GetDetectionRange@BattalionClass@@UAEHH@Z PROC		; BattalionClass::GetDetectionRange
; _this$ = ecx

; 1221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1222 : 	int					dr=0;

	mov	DWORD PTR _dr$[ebp], 0

; 1223 : 	UnitClassDataType*	uc;
; 1224 : 
; 1225 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 1226 : 	ShiAssert(uc);
; 1227 : 	if (IsEmitting() && uc->RadarVehicle < 255 && GetNumVehicles(uc->RadarVehicle))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	je	SHORT $LN3@GetDetecti
	mov	ecx, DWORD PTR _uc$[ebp]
	movzx	edx, BYTE PTR [ecx+328]
	cmp	edx, 255				; 000000ffH
	jge	SHORT $LN3@GetDetecti
	mov	eax, DWORD PTR _uc$[ebp]
	movzx	ecx, BYTE PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	je	SHORT $LN3@GetDetecti

; 1228 : 		// 2001-04-21 MODIFIED BY S.G. ABOVE 250 HAS A NEW MEANING SO USE THE UNIT ELECTRONIC DETECTION RANGE INSTEAD...
; 1229 : 		//		dr = uc->Detection[mt];
; 1230 : 		dr = GetElectronicDetectionRange(mt);

	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	mov	DWORD PTR _dr$[ebp], eax

; 1231 : 	else

	jmp	SHORT $LN2@GetDetecti
$LN3@GetDetecti:

; 1232 : 		SetEmitting(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEmitting@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetEmitting
$LN2@GetDetecti:

; 1233 : 	if (dr < VisualDetectionRange[mt])

	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR _dr$[ebp]
	cmp	edx, DWORD PTR ?VisualDetectionRange@@3PAHA[ecx*4]
	jge	SHORT $LN1@GetDetecti

; 1234 : 		dr = GetVisualDetectionRange(mt);

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	call	?GetVisualDetectionRange@@YAHH@Z	; GetVisualDetectionRange
	add	esp, 4
	mov	DWORD PTR _dr$[ebp], eax
$LN1@GetDetecti:

; 1235 : 	return dr;

	mov	eax, DWORD PTR _dr$[ebp]

; 1236 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDetectionRange@BattalionClass@@UAEHH@Z ENDP		; BattalionClass::GetDetectionRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_got$ = -8						; size = 4
_this$ = -4						; size = 4
_supply$ = 8						; size = 4
_fuel$ = 12						; size = 4
?SupplyUnit@BattalionClass@@UAEXHH@Z PROC		; BattalionClass::SupplyUnit
; _this$ = ecx

; 1211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1212 : 	int		got;
; 1213 : 
; 1214 : 	if (GetMovementType() == Wheeled || GetMovementType() == Tracked)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	cmp	eax, 2
	je	SHORT $LN1@SupplyUnit
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	cmp	eax, 3
	jne	SHORT $LN2@SupplyUnit
$LN1@SupplyUnit:

; 1215 : 		supply = supply+fuel/2;

	mov	eax, DWORD PTR _fuel$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _supply$[ebp]
	mov	DWORD PTR _supply$[ebp], eax
$LN2@SupplyUnit:

; 1216 : 	got = (supply*100)/GetTotalVehicles();

	mov	esi, DWORD PTR _supply$[ebp]
	imul	esi, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	DWORD PTR _got$[ebp], eax

; 1217 : 	SetUnitSupply(GetUnitSupply()+got);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+776]
	call	edx
	add	eax, DWORD PTR _got$[ebp]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+748]
	call	eax

; 1218 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SupplyUnit@BattalionClass@@UAEXHH@Z ENDP		; BattalionClass::SupplyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_vehicles$ = -12					; size = 4
_v$1 = -8						; size = 4
_this$ = -4						; size = 4
_have$ = 8						; size = 4
?GetUnitFuelNeed@BattalionClass@@UAEHH@Z PROC		; BattalionClass::GetUnitFuelNeed
; _this$ = ecx

; 1186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1187 : 	// RV - Biker - Infantry battalions could also have vehivles which need fuel
; 1188 : 	int vehicles = 0;

	mov	DWORD PTR _vehicles$[ebp], 0

; 1189 : 
; 1190 : 	for (int v=0; v<VEHICLE_GROUPS_PER_UNIT; v++)

	mov	DWORD PTR _v$1[ebp], 0
	jmp	SHORT $LN7@GetUnitFue
$LN6@GetUnitFue:
	mov	eax, DWORD PTR _v$1[ebp]
	add	eax, 1
	mov	DWORD PTR _v$1[ebp], eax
$LN7@GetUnitFue:
	cmp	DWORD PTR _v$1[ebp], 16			; 00000010H
	jge	SHORT $LN5@GetUnitFue

; 1191 : 	{
; 1192 : 		if (class_data->VehicleClass[v][2] == TYPE_WHEELED || class_data->VehicleClass[v][2] == TYPE_TRACKED)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _v$1[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+100]
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 4
	je	SHORT $LN3@GetUnitFue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _v$1[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+100]
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 3
	jne	SHORT $LN4@GetUnitFue
$LN3@GetUnitFue:

; 1193 : 			vehicles += this->GetNumVehicles(v);

	mov	ecx, DWORD PTR _v$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	add	eax, DWORD PTR _vehicles$[ebp]
	mov	DWORD PTR _vehicles$[ebp], eax
$LN4@GetUnitFue:

; 1194 : 	}

	jmp	SHORT $LN6@GetUnitFue
$LN5@GetUnitFue:

; 1195 : 
; 1196 : 	if (have)

	cmp	DWORD PTR _have$[ebp], 0
	je	SHORT $LN2@GetUnitFue

; 1197 : 		return (vehicles * GetUnitSupply())/100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+776]
	call	edx
	imul	eax, DWORD PTR _vehicles$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	jmp	SHORT $LN8@GetUnitFue

; 1198 : 	else

	jmp	SHORT $LN8@GetUnitFue
$LN2@GetUnitFue:

; 1199 : 		return (vehicles * (100 - GetUnitSupply()))/100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+776]
	call	edx
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR _vehicles$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN8@GetUnitFue:

; 1200 : 
; 1201 : 	//if (GetMovementType() == Wheeled || GetMovementType() == Tracked)
; 1202 : 	//	if (have)
; 1203 : 	//		return (GetTotalVehicles() * GetUnitSupply())/100*1000;
; 1204 : 	//	else
; 1205 : 	//		return (GetTotalVehicles() * (100 - GetUnitSupply()))/100*1000;
; 1206 : 	//}
; 1207 : 	//return 0;
; 1208 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitFuelNeed@BattalionClass@@UAEHH@Z ENDP		; BattalionClass::GetUnitFuelNeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_have$ = 8						; size = 4
?GetUnitSupplyNeed@BattalionClass@@UAEHH@Z PROC		; BattalionClass::GetUnitSupplyNeed
; _this$ = ecx

; 1178 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1179 : 	if (have)

	cmp	DWORD PTR _have$[ebp], 0
	je	SHORT $LN2@GetUnitSup

; 1180 : 		return (GetTotalVehicles() * GetUnitSupply())/100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+776]
	call	eax
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	jmp	SHORT $LN3@GetUnitSup

; 1181 : 	else

	jmp	SHORT $LN3@GetUnitSup
$LN2@GetUnitSup:

; 1182 : 		return (GetTotalVehicles() * (100 - GetUnitSupply()))/100;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+776]
	call	edx
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	imul	esi, ecx
	mov	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN3@GetUnitSup:

; 1183 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSupplyNeed@BattalionClass@@UAEHH@Z ENDP		; BattalionClass::GetUnitSupplyNeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?CombatTime@BattalionClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatTime@BattalionClass@@UAEKXZ PROC			; BattalionClass::CombatTime, COMDAT
; _this$ = ecx

; 102  : 	virtual CampaignTime CombatTime (void)				{ return GROUND_COMBAT_CHECK_INTERVAL*CampaignSeconds; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR ?GROUND_COMBAT_CHECK_INTERVAL@@3FA ; GROUND_COMBAT_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatTime@BattalionClass@@UAEKXZ ENDP			; BattalionClass::CombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_tb$ = -8						; size = 4
tv72 = -4						; size = 4
?MaxUpdateTime@BattalionClass@@UBEKXZ PROC		; BattalionClass::MaxUpdateTime
; _this$ = ecx

; 1154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1155 : 	// sfr: make these functions const for holy cow sake...
; 1156 : 	BattalionClass *tb = const_cast<BattalionClass*>(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _tb$[ebp], eax

; 1157 : 	switch (tb->GetMovementType())

	mov	ecx, DWORD PTR _tb$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tb$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 6
	ja	SHORT $LN5@MaxUpdateT
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN10@MaxUpdateT[edx*4]
$LN5@MaxUpdateT:

; 1158 : 	{
; 1159 : 		case NoMove:
; 1160 : 		default:
; 1161 : 			return CampaignDay;

	mov	eax, 86400000				; 05265c00H
	jmp	SHORT $LN8@MaxUpdateT
$LN4@MaxUpdateT:

; 1162 : 		case Air:
; 1163 : 		case LowAir:
; 1164 : 			return FLIGHT_MOVE_CHECK_INTERVAL * CampaignSeconds;

	movsx	eax, WORD PTR ?FLIGHT_MOVE_CHECK_INTERVAL@@3FA ; FLIGHT_MOVE_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
	jmp	SHORT $LN8@MaxUpdateT
$LN3@MaxUpdateT:

; 1165 : 		case Naval:
; 1166 : 			return NAVAL_MOVE_CHECK_INTERVAL * CampaignSeconds;

	movsx	eax, WORD PTR ?NAVAL_MOVE_CHECK_INTERVAL@@3FA ; NAVAL_MOVE_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
	jmp	SHORT $LN8@MaxUpdateT
$LN2@MaxUpdateT:

; 1167 : 		case Foot:
; 1168 : 			return FOOT_MOVE_CHECK_INTERVAL * CampaignSeconds;

	movsx	eax, WORD PTR ?FOOT_MOVE_CHECK_INTERVAL@@3FA ; FOOT_MOVE_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
	jmp	SHORT $LN8@MaxUpdateT
$LN1@MaxUpdateT:

; 1169 : 		case Tracked:
; 1170 : 		case Wheeled:
; 1171 : 		case Rail:
; 1172 : 			return TRACKED_MOVE_CHECK_INTERVAL * CampaignSeconds;

	movsx	eax, WORD PTR ?TRACKED_MOVE_CHECK_INTERVAL@@3FA ; TRACKED_MOVE_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
	jmp	SHORT $LN8@MaxUpdateT

; 1173 : 	}
; 1174 : 	return GROUND_UPDATE_CHECK_INTERVAL * CampaignSeconds; 

	movsx	eax, WORD PTR ?GROUND_UPDATE_CHECK_INTERVAL@@3FA ; GROUND_UPDATE_CHECK_INTERVAL
	imul	eax, 1000				; 000003e8H
$LN8@MaxUpdateT:

; 1175 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@MaxUpdateT:
	DD	$LN2@MaxUpdateT
	DD	$LN1@MaxUpdateT
	DD	$LN1@MaxUpdateT
	DD	$LN4@MaxUpdateT
	DD	$LN4@MaxUpdateT
	DD	$LN3@MaxUpdateT
	DD	$LN1@MaxUpdateT
?MaxUpdateTime@BattalionClass@@UBEKXZ ENDP		; BattalionClass::MaxUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_aspeed$ = -20						; size = 4
_brig$ = -16						; size = 4
_mspeed$ = -12						; size = 4
_cspeed$ = -8						; size = 4
_this$ = -4						; size = 4
?GetUnitSpeed@BattalionClass@@UBEHXZ PROC		; BattalionClass::GetUnitSpeed
; _this$ = ecx

; 1118 : int BattalionClass::GetUnitSpeed() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 	int		mspeed,cspeed,aspeed;
; 1120 : 	Brigade	brig = NULL;

	mov	DWORD PTR _brig$[ebp], 0

; 1121 : 
; 1122 : 	mspeed = GetMaxSpeed();				// Fastest we can go

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _mspeed$[ebp], eax

; 1123 : 	if (GetUnitTactic() == GTACTIC_MOVE_BRIGADE_COLUMN)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN8@GetUnitSpe

; 1124 : 		brig = (Brigade)GetUnitParent();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brig$[ebp], eax
$LN8@GetUnitSpe:

; 1125 : 	if (brig)

	cmp	DWORD PTR _brig$[ebp], 0
	je	SHORT $LN7@GetUnitSpe

; 1126 : 		cspeed = brig->GetUnitSpeed();	// Brigade cruise speed

	mov	ecx, DWORD PTR _brig$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _brig$[ebp]
	mov	eax, DWORD PTR [edx+516]
	call	eax
	mov	DWORD PTR _cspeed$[ebp], eax

; 1127 : 	else

	jmp	SHORT $LN6@GetUnitSpe
$LN7@GetUnitSpe:

; 1128 : 		cspeed = GetCruiseSpeed();		// Cruise speed

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1000]
	call	eax
	mov	DWORD PTR _cspeed$[ebp], eax
$LN6@GetUnitSpe:

; 1129 : 	if (Broken())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	je	SHORT $LN5@GetUnitSpe

; 1130 : 	{
; 1131 : 		mspeed *=2;						// We get a bonus when we're running away.

	mov	ecx, DWORD PTR _mspeed$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _mspeed$[ebp], ecx

; 1132 : 		cspeed *=2;

	mov	edx, DWORD PTR _cspeed$[ebp]
	shl	edx, 1
	mov	DWORD PTR _cspeed$[ebp], edx
	jmp	SHORT $LN4@GetUnitSpe
$LN5@GetUnitSpe:

; 1133 : 	}
; 1134 : 	else if (Engaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN4@GetUnitSpe

; 1135 : 	{
; 1136 : 		cspeed = mspeed = GetCombatSpeed();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1004]
	call	eax
	mov	DWORD PTR _mspeed$[ebp], eax
	mov	ecx, DWORD PTR _mspeed$[ebp]
	mov	DWORD PTR _cspeed$[ebp], ecx

; 1137 : 		if (GetUnitCurrentRole() == GRO_ATTACK)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+672]
	call	edx
	cmp	eax, 1
	jne	SHORT $LN4@GetUnitSpe

; 1138 : 		{
; 1139 : 			mspeed /=2;					// When we're offensively engaged, we must slow down, period.

	mov	eax, DWORD PTR _mspeed$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _mspeed$[ebp], eax

; 1140 : 			cspeed /=2;

	mov	eax, DWORD PTR _cspeed$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _cspeed$[ebp], eax
$LN4@GetUnitSpe:

; 1141 : 		}
; 1142 : 	}
; 1143 : 	aspeed = GetArrivalSpeed(this);		// Rough guess as to how fast we need to go.

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?GetArrivalSpeed@@YAHPBVUnitClass@@@Z	; GetArrivalSpeed
	add	esp, 4
	mov	DWORD PTR _aspeed$[ebp], eax

; 1144 : 	if (cspeed > aspeed)

	mov	ecx, DWORD PTR _cspeed$[ebp]
	cmp	ecx, DWORD PTR _aspeed$[ebp]
	jle	SHORT $LN1@GetUnitSpe

; 1145 : 		return cspeed;					// Use cruise speed if it's fast enough

	mov	eax, DWORD PTR _cspeed$[ebp]
	jmp	SHORT $LN9@GetUnitSpe
$LN1@GetUnitSpe:

; 1146 : 	return mspeed;						// Otherwise, use max speed

	mov	eax, DWORD PTR _mspeed$[ebp]
$LN9@GetUnitSpe:

; 1147 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSpeed@BattalionClass@@UBEHXZ ENDP		; BattalionClass::GetUnitSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv82 = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?GetMaxSpeed@BattalionClass@@UBEHXZ PROC		; BattalionClass::GetMaxSpeed
; _this$ = ecx

; 1113 : int BattalionClass::GetMaxSpeed() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 	return FloatToInt32(class_data->MovementSpeed * GetSpeedModifier());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movsx	edx, WORD PTR [ecx+256]
	cvtsi2ss xmm0, edx
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	call	?GetSpeedModifier@BattalionClass@@QBEMXZ ; BattalionClass::GetSpeedModifier
	fstp	DWORD PTR tv82[ebp]
	movss	xmm0, DWORD PTR tv88[ebp]
	mulss	xmm0, DWORD PTR tv82[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 1115 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxSpeed@BattalionClass@@UBEHXZ ENDP		; BattalionClass::GetMaxSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv84 = -12						; size = 4
tv90 = -8						; size = 4
_this$ = -4						; size = 4
?GetCombatSpeed@BattalionClass@@UBEHXZ PROC		; BattalionClass::GetCombatSpeed
; _this$ = ecx

; 1108 : int BattalionClass::GetCombatSpeed() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 	return FloatToInt32(0.6F * class_data->MovementSpeed * GetSpeedModifier());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movsx	edx, WORD PTR [ecx+256]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f19999a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	call	?GetSpeedModifier@BattalionClass@@QBEMXZ ; BattalionClass::GetSpeedModifier
	fstp	DWORD PTR tv84[ebp]
	movss	xmm0, DWORD PTR tv90[ebp]
	mulss	xmm0, DWORD PTR tv84[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 1110 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatSpeed@BattalionClass@@UBEHXZ ENDP		; BattalionClass::GetCombatSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv84 = -12						; size = 4
tv90 = -8						; size = 4
_this$ = -4						; size = 4
?GetCruiseSpeed@BattalionClass@@UBEHXZ PROC		; BattalionClass::GetCruiseSpeed
; _this$ = ecx

; 1104 : int BattalionClass::GetCruiseSpeed() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 	return FloatToInt32(0.8F * class_data->MovementSpeed * GetSpeedModifier());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movsx	edx, WORD PTR [ecx+256]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	call	?GetSpeedModifier@BattalionClass@@QBEMXZ ; BattalionClass::GetSpeedModifier
	fstp	DWORD PTR tv84[ebp]
	movss	xmm0, DWORD PTR tv90[ebp]
	mulss	xmm0, DWORD PTR tv84[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 1106 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCruiseSpeed@BattalionClass@@UBEHXZ ENDP		; BattalionClass::GetCruiseSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T1 = -40						; size = 8
tv132 = -32						; size = 4
_o$ = -28						; size = 4
_this$ = -24						; size = 4
_y$ = -20						; size = 2
_x$ = -16						; size = 2
_dx$ = -12						; size = 2
_dy$ = -8						; size = 2
_h$ = -1						; size = 1
?PickFinalLocation@BattalionClass@@QAEXXZ PROC		; BattalionClass::PickFinalLocation
; _this$ = ecx

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 	Objective		o;
; 988  : 	CampaignHeading	h;
; 989  : 	GridIndex		x,y,dx,dy;
; 990  : 
; 991  : 	DisposeWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints

; 992  : 	o = GetUnitObjective();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _o$[ebp], eax

; 993  : 	if (!o)

	cmp	DWORD PTR _o$[ebp], 0
	jne	SHORT $LN17@PickFinalL

; 994  : 	{
; 995  : 		// KCK: We should pick a retreat path during the next cycle.
; 996  : 		return;

	jmp	$LN18@PickFinalL
$LN17@PickFinalL:

; 997  : 	}
; 998  : 	o->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 999  : 	o->GetLocation(&dx,&dy);

	lea	eax, DWORD PTR _dy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1000 : 
; 1001 : 	// Figure out where we want to hang out to complete our orders for this objective
; 1002 : 	switch (GetUnitOrders())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+880]
	call	edx
	mov	DWORD PTR tv132[ebp], eax
	cmp	DWORD PTR tv132[ebp], 11		; 0000000bH
	ja	$LN4@PickFinalL
	mov	eax, DWORD PTR tv132[ebp]
	movzx	ecx, BYTE PTR $LN20@PickFinalL[eax]
	jmp	DWORD PTR $LN22@PickFinalL[ecx*4]
$LN14@PickFinalL:

; 1003 : 	{
; 1004 : 		// For these, we want to sit in front of the objective
; 1005 : 		case GORD_DEFEND:
; 1006 : 		case GORD_RECON:
; 1007 : 			if (o->GetTeam() != GetTeam())		// Counter attack

	mov	edx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	esi, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN13@PickFinalL

; 1008 : 			{
; 1009 : 				SetUnitOrders (GORD_CAPTURE, o->Id());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 1010 : 				return;

	jmp	$LN18@PickFinalL
$LN13@PickFinalL:

; 1011 : 			}
; 1012 : 			h = FindBestHeading(o,1,GetTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	push	1
	mov	edx, DWORD PTR _o$[ebp]
	push	edx
	call	?FindBestHeading@@YAEPAVObjectiveClass@@HH@Z ; FindBestHeading
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _h$[ebp], al

; 1013 : 			if (h < 8)

	movzx	eax, BYTE PTR _h$[ebp]
	cmp	eax, 8
	jge	SHORT $LN12@PickFinalL

; 1014 : 				final_heading = h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _h$[ebp]
	mov	BYTE PTR [ecx+295], dl

; 1015 : 			else

	jmp	SHORT $LN11@PickFinalL
$LN12@PickFinalL:

; 1016 : 				final_heading = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+295], 255			; 000000ffH
$LN11@PickFinalL:

; 1017 : 			FindBestCover(x,y,h,&dx,&dy, TRUE);

	push	1
	lea	ecx, DWORD PTR _dy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dx$[ebp]
	push	edx
	movzx	eax, BYTE PTR _h$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?FindBestCover@@YAXFFEPAF0H@Z		; FindBestCover
	add	esp, 24					; 00000018H

; 1018 : 			break;

	jmp	$LN15@PickFinalL
$LN10@PickFinalL:

; 1019 : 			// For these, we want to sit behind the objective
; 1020 : 		case GORD_SUPPORT:
; 1021 : 		case GORD_AIRDEFENSE:
; 1022 : 		case GORD_RADAR:
; 1023 : 			// In the case of us being artillery/SAM/radar sits on our objective type, we sit on objective
; 1024 : 			if (o->ArtillerySite() && GetUnitNormalRole() == GRO_FIRESUPPORT)

	mov	ecx, DWORD PTR _o$[ebp]
	call	?ArtillerySite@ObjectiveClass@@QAEHXZ	; ObjectiveClass::ArtillerySite
	test	eax, eax
	je	SHORT $LN9@PickFinalL
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 6
	jne	SHORT $LN9@PickFinalL

; 1025 : 			{
; 1026 : 				final_heading = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+295], 255			; 000000ffH

; 1027 : 				break;

	jmp	$LN15@PickFinalL
$LN9@PickFinalL:

; 1028 : 			}
; 1029 : 			if (o->SamSite() && GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	ecx, DWORD PTR _o$[ebp]
	call	?SamSite@ObjectiveClass@@QAEHXZ		; ObjectiveClass::SamSite
	test	eax, eax
	je	SHORT $LN8@PickFinalL
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN8@PickFinalL

; 1030 : 			{
; 1031 : 				final_heading = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+295], 255			; 000000ffH

; 1032 : 				break;

	jmp	$LN15@PickFinalL
$LN8@PickFinalL:

; 1033 : 			}
; 1034 : 			if (o->RadarSite() && GetUnitNormalRole() == GRO_RECON)

	mov	ecx, DWORD PTR _o$[ebp]
	call	?RadarSite@ObjectiveClass@@QAEHXZ	; ObjectiveClass::RadarSite
	test	eax, eax
	je	SHORT $LN6@PickFinalL
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 8
	jne	SHORT $LN6@PickFinalL

; 1035 : 			{
; 1036 : 				final_heading = 255;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+295], 255			; 000000ffH

; 1037 : 				break;

	jmp	SHORT $LN15@PickFinalL
$LN6@PickFinalL:

; 1038 : 			}
; 1039 : 			// Otherwise do as reserve
; 1040 : 		case GORD_RESERVE:
; 1041 : 		case GORD_COMMANDO:
; 1042 : 			// We want to face forward, but be positioned behind.
; 1043 : 			h = FindBestHeading(o,-1,GetTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	push	-1
	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	call	?FindBestHeading@@YAEPAVObjectiveClass@@HH@Z ; FindBestHeading
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _h$[ebp], al

; 1044 : 			final_heading = (h+4)%8;				

	movzx	edx, BYTE PTR _h$[ebp]
	add	edx, 4
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN21@PickFinalL
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN21@PickFinalL:
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+295], dl

; 1045 : 			FindBestCover(x,y,h,&dx,&dy, FALSE);

	push	0
	lea	ecx, DWORD PTR _dy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dx$[ebp]
	push	edx
	movzx	eax, BYTE PTR _h$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?FindBestCover@@YAXFFEPAF0H@Z		; FindBestCover
	add	esp, 24					; 00000018H

; 1046 : 			break;

	jmp	SHORT $LN15@PickFinalL
$LN5@PickFinalL:

; 1047 : 			// For these, we want to sit on the objective
; 1048 : 		case GORD_CAPTURE:
; 1049 : 		case GORD_SECURE:
; 1050 : 		case GORD_ASSAULT:
; 1051 : 		case GORD_AIRBORNE:
; 1052 : 			final_heading = 255;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+295], 255			; 000000ffH

; 1053 : 			break;

	jmp	SHORT $LN15@PickFinalL
$LN4@PickFinalL:

; 1054 : 			//		case GORD_AIRDEFENSE:
; 1055 : 		case GORD_REPAIR:
; 1056 : 		default:
; 1057 : 			final_heading = Here;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+295], 8
$LN15@PickFinalL:

; 1058 : 			break;
; 1059 : 	}
; 1060 : 
; 1061 : 	GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1062 : 	if ((x != dx || y != dy) && GetMovementType() != NoMove)

	movsx	ecx, WORD PTR _x$[ebp]
	movsx	edx, WORD PTR _dx$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN2@PickFinalL
	movsx	eax, WORD PTR _y$[ebp]
	movsx	ecx, WORD PTR _dy$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@PickFinalL
$LN2@PickFinalL:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	test	eax, eax
	je	SHORT $LN3@PickFinalL

; 1063 : 		SetMoving(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoving@UnitClass@@QAEXH@Z		; UnitClass::SetMoving

; 1064 : 	else

	jmp	SHORT $LN1@PickFinalL
$LN3@PickFinalL:

; 1065 : 		GetLocation(&dx,&dy);

	lea	eax, DWORD PTR _dy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation
$LN1@PickFinalL:

; 1066 : 	SetUnitDestination(dx,dy);

	movzx	edx, WORD PTR _dy$[ebp]
	push	edx
	movzx	eax, WORD PTR _dx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 1067 : 	SetTempDest(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest
$LN18@PickFinalL:

; 1068 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@PickFinalL:
	DD	$LN6@PickFinalL
	DD	$LN5@PickFinalL
	DD	$LN14@PickFinalL
	DD	$LN10@PickFinalL
	DD	$LN4@PickFinalL
$LN20@PickFinalL:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	2
	DB	3
	DB	4
	DB	3
	DB	2
	DB	3
?PickFinalLocation@BattalionClass@@QAEXXZ ENDP		; BattalionClass::PickFinalLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
_neworders$ = 8						; size = 4
_oid$ = 12						; size = 8
?SetUnitOrders@BattalionClass@@UAEXHVVU_ID@@@Z PROC	; BattalionClass::SetUnitOrders
; _this$ = ecx

; 920  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 921  : #ifdef DEBUG
; 922  : 	if (gDumping)
; 923  : 	{
; 924  : 		FILE	*fp;
; 925  : 		int		id1;
; 926  : 		char	buffer[256];
; 927  : 		char	name1[80],name2[80],timestr[80];
; 928  : 		Objective	o = (Objective)vuDatabase->Find(oid);
; 929  : 
; 930  : 		sprintf(buffer,"campaign\\save\\dump\\%d.BAT",GetCampID());
; 931  : 
; 932  : 		fp = fopen(buffer,"a");
; 933  : 		if (fp)
; 934  : 		{
; 935  : 			if (o)
; 936  : 			{
; 937  : 				o->GetName(name1,79,FALSE);
; 938  : 				id1 = o->GetCampID();
; 939  : 			}
; 940  : 			else
; 941  : 			{
; 942  : 				sprintf(name1,"NONE");
; 943  : 				id1 = 0;
; 944  : 			}
; 945  : 			GetName(name2,79,FALSE);
; 946  : 			GetTimeString(TheCampaign.CurrentTime,timestr);
; 947  : 			sprintf(buffer,"%s (%d) ordered to %s %s (%d) @ %s.\n",name2,GetCampID(),OrderStr[neworders],name1,id1,timestr);
; 948  : 			fprintf(fp,buffer);
; 949  : 			fclose(fp);
; 950  : 		}
; 951  : 		else
; 952  : 			gDumping = 0;
; 953  : 	}
; 954  : #endif
; 955  : 
; 956  : 	if (neworders == GetOrders() && oid == GetUnitObjectiveID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOrders@GroundUnitClass@@QAEEXZ	; GroundUnitClass::GetOrders
	movzx	eax, al
	cmp	DWORD PTR _neworders$[ebp], eax
	jne	SHORT $LN3@SetUnitOrd
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+876]
	call	edx
	push	eax
	lea	ecx, DWORD PTR _oid$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@SetUnitOrd

; 957  : 		return;

	jmp	$LN4@SetUnitOrd
$LN3@SetUnitOrd:

; 958  : 
; 959  : 	/*	if (Cargo() || cargo_id != FalconNullId)
; 960  : 		{
; 961  : 	// KCK: We're in mid-transport, or waiting for pickup what o-what to do?
; 962  : 	// Probably be cool if we re-routed the transports to new location.
; 963  : 	// For now, ignore.
; 964  : 	return;
; 965  : 	}
; 966  : 	*/
; 967  : 
; 968  : 	SetRefused(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRefused@UnitClass@@QAEXH@Z		; UnitClass::SetRefused

; 969  : 	SetUnitObjective(oid);

	mov	ecx, DWORD PTR _oid$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _oid$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+824]
	call	eax

; 970  : 	SetUnitLastMove(Camp_GetCurrentTime());

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	call	eax

; 971  : 	// Force an immediate check
; 972  : 	SetLastCheck(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck

; 973  : 
; 974  : 	// If we've received new orders, and arn't engaged, let's halt our retreat
; 975  : 	if (Retreating() && (!Engaged() || neworders != GORD_RESERVE))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Retreating@UnitClass@@QBEHXZ		; UnitClass::Retreating
	test	eax, eax
	je	SHORT $LN2@SetUnitOrd
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN1@SetUnitOrd
	cmp	DWORD PTR _neworders$[ebp], 0
	je	SHORT $LN2@SetUnitOrd
$LN1@SetUnitOrd:

; 976  : 		SetRetreating(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRetreating@UnitClass@@QAEXH@Z	; UnitClass::SetRetreating
$LN2@SetUnitOrd:

; 977  : 
; 978  : 	GroundUnitClass::SetUnitOrders(neworders);

	movzx	ecx, BYTE PTR _neworders$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitOrders@GroundUnitClass@@UAEXE@Z	; GroundUnitClass::SetUnitOrders

; 979  : 
; 980  : 	PickFinalLocation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PickFinalLocation@BattalionClass@@QAEXXZ ; BattalionClass::PickFinalLocation

; 981  : 
; 982  : 	SetOrdered(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOrdered@UnitClass@@QAEXH@Z		; UnitClass::SetOrdered
$LN4@SetUnitOrd:

; 983  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUnitOrders@BattalionClass@@UAEXHVVU_ID@@@Z ENDP	; BattalionClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?Real@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Real@BattalionClass@@UAEHXZ PROC			; BattalionClass::Real, COMDAT
; _this$ = ecx

; 89   : 	virtual int Real (void)								{ return 1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?Real@BattalionClass@@UAEHXZ ENDP			; BattalionClass::Real
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T1 = -44						; size = 8
_e$2 = -36						; size = 4
tv370 = -32						; size = 4
tv358 = -28						; size = 4
_o$3 = -24						; size = 4
_this$ = -20						; size = 4
_x$4 = -16						; size = 2
_y$5 = -12						; size = 2
_dx$6 = -8						; size = 2
_dy$7 = -4						; size = 2
_tid$ = 8						; size = 4
?CheckTactic@BattalionClass@@UAEHH@Z PROC		; BattalionClass::CheckTactic
; _this$ = ecx

; 1998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1999 : 	if (haveWeaps < 0)

	cmp	DWORD PTR ?haveWeaps@@3HA, 0		; haveWeaps
	jge	$LN24@CheckTacti

; 2000 : 	{
; 2001 : 		GridIndex		x,y,dx,dy;
; 2002 : 		Objective		o;
; 2003 : 		FalconEntity	*e = GetTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _e$2[ebp], eax

; 2004 : 
; 2005 : 		if (Engaged() && !e)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN23@CheckTacti
	cmp	DWORD PTR _e$2[ebp], 0
	jne	SHORT $LN23@CheckTacti

; 2006 : 			SetEngaged(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged
$LN23@CheckTacti:

; 2007 : 		if (GetUnitSupply() > 30)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+776]
	call	eax
	cmp	eax, 30					; 0000001eH
	jle	SHORT $LN22@CheckTacti

; 2008 : 			haveWeaps = 1;

	mov	DWORD PTR ?haveWeaps@@3HA, 1		; haveWeaps

; 2009 : 		else

	jmp	SHORT $LN21@CheckTacti
$LN22@CheckTacti:

; 2010 : 			haveWeaps = 0;

	mov	DWORD PTR ?haveWeaps@@3HA, 0		; haveWeaps
$LN21@CheckTacti:

; 2011 : 		GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2012 : 		o = GetUnitObjective();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _o$3[ebp], eax

; 2013 : 		ourObjOwner = 0;

	mov	DWORD PTR ?ourObjOwner@@3HA, 0		; ourObjOwner

; 2014 : 		if (o && o->GetTeam() == GetTeam())

	cmp	DWORD PTR _o$3[ebp], 0
	je	SHORT $LN20@CheckTacti
	mov	ecx, DWORD PTR _o$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$3[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	esi, al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN20@CheckTacti

; 2015 : 			ourObjOwner = 1;

	mov	DWORD PTR ?ourObjOwner@@3HA, 1		; ourObjOwner
$LN20@CheckTacti:

; 2016 : 		if (o)

	cmp	DWORD PTR _o$3[ebp], 0
	je	SHORT $LN19@CheckTacti

; 2017 : 			o->GetLocation(&dx,&dy);

	lea	edx, DWORD PTR _dy$7[ebp]
	push	edx
	lea	eax, DWORD PTR _dx$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$3[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2018 : 		else

	jmp	SHORT $LN18@CheckTacti
$LN19@CheckTacti:

; 2019 : 			GetUnitDestination(&dx,&dy);

	lea	ecx, DWORD PTR _dy$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _dx$6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination
$LN18@CheckTacti:

; 2020 : 		ourObjDist = FloatToInt32(Distance(x,y,dx,dy));

	movzx	eax, WORD PTR _dy$7[ebp]
	push	eax
	movzx	ecx, WORD PTR _dx$6[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$5[ebp]
	push	edx
	movzx	eax, WORD PTR _x$4[ebp]
	push	eax
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR ?ourObjDist@@3HA, eax		; ourObjDist
$LN24@CheckTacti:

; 2021 : 	}
; 2022 : 	if (!CheckUnitType(tid, GetDomain(), GetType()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckUnitType@@YAHHHH@Z		; CheckUnitType
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@CheckTacti

; 2023 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN17@CheckTacti:

; 2024 : 	if (!CheckTeam(tid,GetTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _tid$[ebp]
	push	edx
	call	?CheckTeam@@YAHHH@Z			; CheckTeam
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@CheckTacti

; 2025 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN16@CheckTacti:

; 2026 : 	if (!CheckEngaged(tid,Engaged()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	push	eax
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckEngaged@@YAHHH@Z			; CheckEngaged
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@CheckTacti

; 2027 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN15@CheckTacti:

; 2028 : 	if (!CheckCombat(tid,Combat()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Combat@UnitClass@@QBEHXZ		; UnitClass::Combat
	push	eax
	mov	ecx, DWORD PTR _tid$[ebp]
	push	ecx
	call	?CheckCombat@@YAHHH@Z			; CheckCombat
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@CheckTacti

; 2029 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN14@CheckTacti:

; 2030 : 	if (!CheckLosses(tid,Losses()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Losses@UnitClass@@QBEHXZ		; UnitClass::Losses
	push	eax
	mov	edx, DWORD PTR _tid$[ebp]
	push	edx
	call	?CheckLosses@@YAHHH@Z			; CheckLosses
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@CheckTacti

; 2031 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN13@CheckTacti:

; 2032 : 	if (!CheckRetreating(tid,Retreating()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Retreating@UnitClass@@QBEHXZ		; UnitClass::Retreating
	push	eax
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckRetreating@@YAHHH@Z		; CheckRetreating
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@CheckTacti

; 2033 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN12@CheckTacti:

; 2034 : 	if (!CheckAction(tid,GetUnitOrders()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _tid$[ebp]
	push	ecx
	call	?CheckAction@@YAHHH@Z			; CheckAction
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@CheckTacti

; 2035 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN11@CheckTacti:

; 2036 : 	if (!CheckOwned(tid,ourObjOwner))

	mov	edx, DWORD PTR ?ourObjOwner@@3HA	; ourObjOwner
	push	edx
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckOwned@@YAHHH@Z			; CheckOwned
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@CheckTacti

; 2037 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN10@CheckTacti:

; 2038 : 	if (!CheckRange(tid,ourObjDist))

	mov	ecx, DWORD PTR ?ourObjDist@@3HA		; ourObjDist
	push	ecx
	mov	edx, DWORD PTR _tid$[ebp]
	push	edx
	call	?CheckRange@@YAHHH@Z			; CheckRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@CheckTacti

; 2039 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN9@CheckTacti:

; 2040 : 	//	if (!CheckDistToFront(tid,ourFrontDist))
; 2041 : 	//		return 0;
; 2042 : 	if (!CheckStatus(tid,Broken()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	push	eax
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckStatus@@YAHHH@Z			; CheckStatus
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@CheckTacti

; 2043 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN8@CheckTacti:

; 2044 : 	if (!CheckOdds(tid,GetOdds()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOdds@UnitClass@@QAEFXZ		; UnitClass::GetOdds
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _tid$[ebp]
	push	edx
	call	?CheckOdds@@YAHHH@Z			; CheckOdds
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@CheckTacti

; 2045 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN7@CheckTacti:

; 2046 : 	if (CheckWeapons(tid) == 1 && !haveWeaps)

	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckWeapons@@YAHH@Z			; CheckWeapons
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN6@CheckTacti
	cmp	DWORD PTR ?haveWeaps@@3HA, 0		; haveWeaps
	jne	SHORT $LN6@CheckTacti

; 2047 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN6@CheckTacti:

; 2048 : 	if (!CheckRole(tid,GetUnitNormalRole()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _tid$[ebp]
	push	ecx
	call	?CheckRole@@YAHHH@Z			; CheckRole
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@CheckTacti

; 2049 : 		return 0;

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN5@CheckTacti:

; 2050 : 	if (CheckSpecial(tid) == 1 && GetUnitParentID() == FalconNullId)

	mov	edx, DWORD PTR _tid$[ebp]
	push	edx
	call	?CheckSpecial@@YAHH@Z			; CheckSpecial
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN4@CheckTacti
	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+948]
	call	eax
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@CheckTacti

; 2051 : 		return 0;						// Check if part of a brigade

	xor	eax, eax
	jmp	$LN25@CheckTacti
$LN4@CheckTacti:

; 2052 : 	if (CheckSpecial(tid) == 2 && TeamInfo[GetTeam()]->GetGroundAction()->actionType != GACTION_OFFENSIVE)

	mov	edx, DWORD PTR _tid$[ebp]
	push	edx
	call	?CheckSpecial@@YAHH@Z			; CheckSpecial
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN3@CheckTacti
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	movzx	edx, BYTE PTR [eax+16]
	cmp	edx, 4
	je	SHORT $LN3@CheckTacti

; 2053 : 		return 0;						// KCK Check if our offensive's started yet.

	xor	eax, eax
	jmp	SHORT $LN25@CheckTacti
$LN3@CheckTacti:

; 2054 : 	// Refused() means our request was refused. These are no longer valid tactics
; 2055 : 	if (!CheckAirborne(tid,!Refused()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Refused@UnitClass@@QBEHXZ		; UnitClass::Refused
	test	eax, eax
	jne	SHORT $LN27@CheckTacti
	mov	DWORD PTR tv358[ebp], 1
	jmp	SHORT $LN28@CheckTacti
$LN27@CheckTacti:
	mov	DWORD PTR tv358[ebp], 0
$LN28@CheckTacti:
	mov	eax, DWORD PTR tv358[ebp]
	push	eax
	mov	ecx, DWORD PTR _tid$[ebp]
	push	ecx
	call	?CheckAirborne@@YAHHH@Z			; CheckAirborne
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@CheckTacti

; 2056 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN25@CheckTacti
$LN2@CheckTacti:

; 2057 : 	if (!CheckMarine(tid,!Refused()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Refused@UnitClass@@QBEHXZ		; UnitClass::Refused
	test	eax, eax
	jne	SHORT $LN29@CheckTacti
	mov	DWORD PTR tv370[ebp], 1
	jmp	SHORT $LN30@CheckTacti
$LN29@CheckTacti:
	mov	DWORD PTR tv370[ebp], 0
$LN30@CheckTacti:
	mov	edx, DWORD PTR tv370[ebp]
	push	edx
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	call	?CheckMarine@@YAHHH@Z			; CheckMarine
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@CheckTacti

; 2058 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN25@CheckTacti
$LN1@CheckTacti:

; 2059 : 
; 2060 : 	return GetTacticPriority(tid);

	mov	ecx, DWORD PTR _tid$[ebp]
	push	ecx
	call	?GetTacticPriority@@YAHH@Z		; GetTacticPriority
	add	esp, 4
$LN25@CheckTacti:

; 2061 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckTactic@BattalionClass@@UAEHH@Z ENDP		; BattalionClass::CheckTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_brigade$2 = -20					; size = 4
_priority$ = -16					; size = 4
_o$3 = -12						; size = 4
_tid$ = -8						; size = 4
_this$ = -4						; size = 4
?ChooseTactic@BattalionClass@@UAEHXZ PROC		; BattalionClass::ChooseTactic
; _this$ = ecx

; 1936 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1937 : 	int			priority=0,tid;

	mov	DWORD PTR _priority$[ebp], 0

; 1938 : 
; 1939 : 	tid = FirstGroundTactic;

	movsx	eax, WORD PTR ?FirstGroundTactic@@3FA	; FirstGroundTactic
	mov	DWORD PTR _tid$[ebp], eax
$LN11@ChooseTact:

; 1940 : 	while ((tid < FirstGroundTactic + GroundTactics) && (priority<2))

	movsx	ecx, WORD PTR ?FirstGroundTactic@@3FA	; FirstGroundTactic
	movsx	edx, WORD PTR ?GroundTactics@@3FA	; GroundTactics
	add	ecx, edx
	cmp	DWORD PTR _tid$[ebp], ecx
	jge	SHORT $LN10@ChooseTact
	cmp	DWORD PTR _priority$[ebp], 2
	jge	SHORT $LN10@ChooseTact

; 1941 : 	{
; 1942 : 		priority = CheckTactic(tid) + rand()%2;

	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+500]
	call	eax
	mov	esi, eax
	call	_rand
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN14@ChooseTact
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN14@ChooseTact:
	add	esi, eax
	mov	DWORD PTR _priority$[ebp], esi

; 1943 : 		if (priority<2)

	cmp	DWORD PTR _priority$[ebp], 2
	jge	SHORT $LN9@ChooseTact

; 1944 : 			tid++;

	mov	ecx, DWORD PTR _tid$[ebp]
	add	ecx, 1
	mov	DWORD PTR _tid$[ebp], ecx
$LN9@ChooseTact:

; 1945 : 	}

	jmp	SHORT $LN11@ChooseTact
$LN10@ChooseTact:

; 1946 : 
; 1947 : 	if (tid != GetTactic())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTactic@UnitClass@@QAEEXZ		; UnitClass::GetTactic
	movzx	edx, al
	cmp	DWORD PTR _tid$[ebp], edx
	je	SHORT $LN8@ChooseTact

; 1948 : 		SetOrdered(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOrdered@UnitClass@@QAEXH@Z		; UnitClass::SetOrdered
$LN8@ChooseTact:

; 1949 : 
; 1950 : 	// Make Adjustments due to tactic
; 1951 : 	if (tid == GTACTIC_WITHDRAW)

	cmp	DWORD PTR _tid$[ebp], 30		; 0000001eH
	jne	$LN7@ChooseTact

; 1952 : 	{
; 1953 : 		SetAssigned(0);		

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAssigned@UnitClass@@QAEXH@Z		; UnitClass::SetAssigned

; 1954 : 		if (GetUnitTactic() != GTACTIC_WITHDRAW)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 30					; 0000001eH
	je	$LN7@ChooseTact

; 1955 : 		{
; 1956 : 			Objective	o;
; 1957 : 			Brigade		brigade;
; 1958 : 
; 1959 : 			// Check for objective abandonment (possibly only if we're nearby)
; 1960 : 			if (GetUnitOrders() == GORD_DEFEND && ourObjDist < 5)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	cmp	eax, 6
	jne	SHORT $LN5@ChooseTact
	cmp	DWORD PTR ?ourObjDist@@3HA, 5		; ourObjDist
	jge	SHORT $LN5@ChooseTact

; 1961 : 			{
; 1962 : 				o = GetUnitObjective();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _o$3[ebp], eax

; 1963 : 				if (o)

	cmp	DWORD PTR _o$3[ebp], 0
	je	SHORT $LN5@ChooseTact

; 1964 : 					o->SetAbandoned(1);

	push	1
	mov	ecx, DWORD PTR _o$3[ebp]
	call	?SetAbandoned@ObjectiveClass@@QAEXH@Z	; ObjectiveClass::SetAbandoned
$LN5@ChooseTact:

; 1965 : 			}
; 1966 : 
; 1967 : 			//MonoPrint ("Retreating\n");
; 1968 : 
; 1969 : 			SetRetreating(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRetreating@UnitClass@@QAEXH@Z	; UnitClass::SetRetreating

; 1970 : 			// Re-request orders from our brigade, if we have one
; 1971 : 			brigade = (Brigade) GetUnitParent();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brigade$2[ebp], eax

; 1972 : 			if (brigade)

	cmp	DWORD PTR _brigade$2[ebp], 0
	je	SHORT $LN3@ChooseTact

; 1973 : 				// Force the brigade to reassign us immediately
; 1974 : 				brigade->SetLastCheck(0);

	push	0
	mov	ecx, DWORD PTR _brigade$2[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck

; 1975 : 			else

	jmp	SHORT $LN7@ChooseTact
$LN3@ChooseTact:

; 1976 : 			{
; 1977 : 				// Otherwise, retreat as best we can
; 1978 : 				o = FindRetreatPath(this,3,0);

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z ; FindRetreatPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _o$3[ebp], eax

; 1979 : 				if (o)

	cmp	DWORD PTR _o$3[ebp], 0
	je	SHORT $LN7@ChooseTact

; 1980 : 					SetUnitOrders(GORD_RESERVE,o->Id());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$3[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN7@ChooseTact:

; 1981 : 			}
; 1982 : 		}
; 1983 : 	}
; 1984 : 
; 1985 : #ifdef ROBIN_DEBUG
; 1986 : 	if (GetUnitTactic() != tid && TrackingOn[GetCampID()] || (GetUnitParent() && TrackingOn[GetUnitParent()->GetCampID()]))
; 1987 : 	{
; 1988 : 		CampEntity target = (CampEntity) GetTarget();
; 1989 : 		MonoPrint("Battalion %d (%s) chose tactic %s vs %d.\n",GetCampID(),OrderStr[GetUnitOrders()],TacticsTable[tid].name,(target)? target->GetCampID():0);
; 1990 : 	}
; 1991 : #endif
; 1992 : 	SetUnitTactic(tid);

	movzx	ecx, BYTE PTR _tid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitTactic@UnitClass@@QAEXE@Z	; UnitClass::SetUnitTactic

; 1993 : 
; 1994 : 	return tid;

	mov	eax, DWORD PTR _tid$[ebp]

; 1995 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ChooseTactic@BattalionClass@@UAEHXZ ENDP		; BattalionClass::ChooseTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_neworders$ = -48					; size = 4
tv269 = -44						; size = 4
_omt$ = -40						; size = 4
_tmt$ = -36						; size = 4
_et$ = -32						; size = 4
_enemy_threat_bonus$ = -28				; size = 4
_this$ = -24						; size = 4
_score$ = -20						; size = 4
_ey$ = -16						; size = 2
_y$ = -12						; size = 2
_ex$ = -8						; size = 2
_x$ = -4						; size = 2
_e$ = 8							; size = 4
_knowledge$ = 12					; size = 4
_range$ = 16						; size = 4
?Reaction@BattalionClass@@UAEHPAVCampBaseClass@@HM@Z PROC ; BattalionClass::Reaction
; _this$ = ecx

; 1846 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1847 : 	int			score = 0, neworders, enemy_threat_bonus = 1;

	mov	DWORD PTR _score$[ebp], 0
	mov	DWORD PTR _enemy_threat_bonus$[ebp], 1

; 1848 : 	CampEntity	et = NULL;								// enemy's target

	mov	DWORD PTR _et$[ebp], 0

; 1849 : 	MoveType	tmt,omt;
; 1850 : 	GridIndex	x,y,ex,ey;
; 1851 : 
; 1852 : 	if (!e || e->IsObjective())					// Ignore objectives for target canidates

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN21@Reaction
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN22@Reaction
$LN21@Reaction:

; 1853 : 		return 0;

	xor	eax, eax
	jmp	$LN23@Reaction
$LN22@Reaction:

; 1854 : 
; 1855 : 	// Some basic info on us.
; 1856 : 	omt = GetMovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _omt$[ebp], eax

; 1857 : 	tmt = e->GetMovementType();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _tmt$[ebp], eax

; 1858 : 	neworders = GetUnitOrders();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+880]
	call	eax
	mov	DWORD PTR _neworders$[ebp], eax

; 1859 : 
; 1860 : 	// Aircraft on ground are ignored (technically, we could shoot at them.. but..)
; 1861 : 	if (e->IsFlight() && !((Flight)e)->Moving())

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN20@Reaction
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	jne	SHORT $LN20@Reaction

; 1862 : 		return 0;

	xor	eax, eax
	jmp	$LN23@Reaction
$LN20@Reaction:

; 1863 : 
; 1864 : 	// KCK HACK: Don't shoot at FAC aircraft.
; 1865 : 	if (e->IsFlight() && ((Flight)e)->GetUnitMission() == AMIS_FAC)

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN19@Reaction
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN19@Reaction

; 1866 : 		return 0;

	xor	eax, eax
	jmp	$LN23@Reaction
$LN19@Reaction:

; 1867 : 
; 1868 : 	// Score their threat to us
; 1869 : 	if (knowledge & FRIENDLY_DETECTED)

	mov	ecx, DWORD PTR _knowledge$[ebp]
	and	ecx, 4
	je	SHORT $LN18@Reaction

; 1870 : 		enemy_threat_bonus++;

	mov	edx, DWORD PTR _enemy_threat_bonus$[ebp]
	add	edx, 1
	mov	DWORD PTR _enemy_threat_bonus$[ebp], edx
$LN18@Reaction:

; 1871 : 	if (knowledge & FRIENDLY_IN_RANGE)

	mov	eax, DWORD PTR _knowledge$[ebp]
	and	eax, 8
	je	SHORT $LN17@Reaction

; 1872 : 		enemy_threat_bonus += 2;

	mov	ecx, DWORD PTR _enemy_threat_bonus$[ebp]
	add	ecx, 2
	mov	DWORD PTR _enemy_threat_bonus$[ebp], ecx
$LN17@Reaction:

; 1873 : 	et = ((Unit)e)->GetCampTarget();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetCampTarget@UnitClass@@QAEPAVCampBaseClass@@XZ ; UnitClass::GetCampTarget
	mov	DWORD PTR _et$[ebp], eax

; 1874 : 
; 1875 : 	// All units score vs player units
; 1876 : 	if (e->IsPlayer())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN16@Reaction

; 1877 : 	{
; 1878 : 		//we just want to make sure we get some score, so we are at least considered as a target
; 1879 : 		score += 1;

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 1
	mov	DWORD PTR _score$[ebp], edx
$LN16@Reaction:

; 1880 : 		//score += (GetAproxHitChance(tmt,0)*enemy_threat_bonus)/5;
; 1881 : 	}
; 1882 : 
; 1883 : 	// All units score vs enemy engaged with this unit
; 1884 : 	if (et == this)

	mov	eax, DWORD PTR _et$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN15@Reaction

; 1885 : 		score += (e->GetAproxHitChance(omt,0)*enemy_threat_bonus)/5;

	push	0
	mov	ecx, DWORD PTR _omt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+396]
	call	edx
	imul	eax, DWORD PTR _enemy_threat_bonus$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN15@Reaction:

; 1886 : 
; 1887 : 	// Bonus if we can shoot them
; 1888 : 	if (knowledge & ENEMY_IN_RANGE)

	mov	edx, DWORD PTR _knowledge$[ebp]
	and	edx, 2
	je	SHORT $LN14@Reaction

; 1889 : 		score += (GetAproxHitChance(tmt,FloatToInt32(range/2.0F))+4)/5;

	movss	xmm0, DWORD PTR _range$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _tmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+396]
	call	eax
	add	eax, 4
	cdq
	mov	ecx, 5
	idiv	ecx
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN14@Reaction:

; 1890 : 
; 1891 : 	// Bonus for them being our target
; 1892 : 	GetUnitDestination(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 1893 : 	e->GetLocation(&ex,&ey);

	lea	ecx, DWORD PTR _ey$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1894 : 	if (x == ex && y == ey && e->IsUnit())

	movsx	eax, WORD PTR _x$[ebp]
	movsx	ecx, WORD PTR _ex$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN13@Reaction
	movsx	edx, WORD PTR _y$[ebp]
	movsx	eax, WORD PTR _ey$[ebp]
	cmp	edx, eax
	jne	SHORT $LN13@Reaction
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN13@Reaction

; 1895 : 		score += 2 + GetAproxHitChance(tmt,FloatToInt32(range/2.0F))/5;

	movss	xmm0, DWORD PTR _range$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _tmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+396]
	call	edx
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	edx, DWORD PTR _score$[ebp]
	lea	eax, DWORD PTR [edx+eax+2]
	mov	DWORD PTR _score$[ebp], eax
$LN13@Reaction:

; 1896 : 
; 1897 : 	// Now score for our ability to kill them, if we're on that sort of mission type
; 1898 : 	switch (neworders)

	mov	ecx, DWORD PTR _neworders$[ebp]
	mov	DWORD PTR tv269[ebp], ecx
	cmp	DWORD PTR tv269[ebp], 11		; 0000000bH
	ja	$LN2@Reaction
	mov	edx, DWORD PTR tv269[ebp]
	movzx	eax, BYTE PTR $LN25@Reaction[edx]
	jmp	DWORD PTR $LN26@Reaction[eax*4]
$LN10@Reaction:

; 1899 : 	{
; 1900 : 		case GORD_CAPTURE:
; 1901 : 		case GORD_SECURE:
; 1902 : 			// Added bonus for them being engaged with any unit
; 1903 : 			if (et && et->IsUnit())

	cmp	DWORD PTR _et$[ebp], 0
	je	SHORT $LN9@Reaction
	mov	ecx, DWORD PTR _et$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _et$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN9@Reaction

; 1904 : 				score += (e->GetAproxHitChance(omt,0)*enemy_threat_bonus)/5;

	push	0
	mov	ecx, DWORD PTR _omt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+396]
	call	edx
	imul	eax, DWORD PTR _enemy_threat_bonus$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN9@Reaction:

; 1905 : 			break;

	jmp	$LN11@Reaction
$LN8@Reaction:

; 1906 : 		case GORD_AIRDEFENSE:
; 1907 : 			// Added bonus for them attacking
; 1908 : 			if (et && (tmt == Air || tmt == LowAir))

	cmp	DWORD PTR _et$[ebp], 0
	je	SHORT $LN7@Reaction
	cmp	DWORD PTR _tmt$[ebp], 5
	je	SHORT $LN6@Reaction
	cmp	DWORD PTR _tmt$[ebp], 4
	jne	SHORT $LN7@Reaction
$LN6@Reaction:

; 1909 : 				score += (GetAproxHitChance(tmt,0)*enemy_threat_bonus)/5;

	push	0
	mov	edx, DWORD PTR _tmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+396]
	call	eax
	imul	eax, DWORD PTR _enemy_threat_bonus$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN7@Reaction:

; 1910 : 			break;

	jmp	SHORT $LN11@Reaction
$LN5@Reaction:

; 1911 : 		case GORD_DEFEND:
; 1912 : 			// Added bonus for them attacking
; 1913 : 			if (((Unit)e)->Engaged())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	SHORT $LN4@Reaction

; 1914 : 				score += (e->GetAproxHitChance(omt,0)*enemy_threat_bonus)/5;

	push	0
	mov	edx, DWORD PTR _omt$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+396]
	call	eax
	imul	eax, DWORD PTR _enemy_threat_bonus$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN4@Reaction:

; 1915 : 			break;

	jmp	SHORT $LN11@Reaction
$LN3@Reaction:

; 1916 : 		case GORD_RESERVE:
; 1917 : 		case GORD_SUPPORT:
; 1918 : 		case GORD_REPAIR:
; 1919 : 		case GORD_RECON:
; 1920 : 		case GORD_RADAR:
; 1921 : 			// The worst threat scores highest
; 1922 : 			score += (e->GetAproxHitChance(omt,0)*enemy_threat_bonus)/5;

	push	0
	mov	edx, DWORD PTR _omt$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+396]
	call	eax
	imul	eax, DWORD PTR _enemy_threat_bonus$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	eax, DWORD PTR _score$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN2@Reaction:
$LN11@Reaction:

; 1923 : 			break;
; 1924 : 		default:
; 1925 : 			break;
; 1926 : 	}
; 1927 : 
; 1928 : 	// Minimal reaction against broken units
; 1929 : 	if (e->IsBattalion() && ((Unit)e)->Broken())

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	je	SHORT $LN1@Reaction
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	je	SHORT $LN1@Reaction

; 1930 : 		score = 1;

	mov	DWORD PTR _score$[ebp], 1
$LN1@Reaction:

; 1931 : 
; 1932 : 	return score;

	mov	eax, DWORD PTR _score$[ebp]
$LN23@Reaction:

; 1933 : } 

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN26@Reaction:
	DD	$LN3@Reaction
	DD	$LN10@Reaction
	DD	$LN5@Reaction
	DD	$LN8@Reaction
	DD	$LN2@Reaction
$LN25@Reaction:
	DB	0
	DB	1
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	0
	DB	0
	DB	3
	DB	0
	DB	0
?Reaction@BattalionClass@@UAEHPAVCampBaseClass@@HM@Z ENDP ; BattalionClass::Reaction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_oc$1 = -36						; size = 4
_vc$2 = -32						; size = 4
_uc$3 = -28						; size = 4
_o$4 = -24						; size = 4
_this$ = -20						; size = 4
_type$ = -16						; size = 4
_pt$ = -12						; size = 4
_x$5 = -8						; size = 2
_y$6 = -4						; size = 2
_slot$ = 8						; size = 4
_installation$ = 12					; size = 4
?GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z PROC ; BattalionClass::GetDeaggregationPoint
; _this$ = ecx

; 1693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1694 : 	int			pt=0,type;

	mov	DWORD PTR _pt$[ebp], 0

; 1695 : 	static int	last_SAM_pt, last_AAA_pt, last_support_pt, last_art_pt, ptListType, index = 0;
; 1696 : 
; 1697 : 	if (!*installation) {

	mov	eax, DWORD PTR _installation$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN45@GetDeaggre

; 1698 : 		// We're looking for a new list, so clear statics
; 1699 : 		last_SAM_pt = last_AAA_pt = last_support_pt = last_art_pt = ptListType = index =0;

	mov	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	mov	ecx, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	mov	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx
	mov	edx, DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	mov	DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx
	mov	eax, DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	mov	DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, eax
	mov	ecx, DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	mov	DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx
	mov	edx, DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	mov	DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx

; 1700 : 
; 1701 : 		// Check if we care about placement
; 1702 : 		if (!Moving()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	jne	SHORT $LN44@GetDeaggre

; 1703 : 			// RV - Biker - Check if we want some special index type
; 1704 : 			if (GetUnitClassData()->PtDataIndex) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	movsx	eax, WORD PTR [eax+266]
	test	eax, eax
	je	SHORT $LN43@GetDeaggre

; 1705 : 				ptListType = GetUnitClassData()->PtDataIndex;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	movsx	ecx, WORD PTR [eax+266]
	mov	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx

; 1706 : 			}
; 1707 : 			else {

	jmp	SHORT $LN44@GetDeaggre
$LN43@GetDeaggre:

; 1708 : 				if (GetUnitNormalRole() == GRO_AIRDEFENSE) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN41@GetDeaggre

; 1709 : 					ptListType = SAMListType;

	mov	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 4
	jmp	SHORT $LN44@GetDeaggre
$LN41@GetDeaggre:

; 1710 : 				}
; 1711 : 				else if (GetUnitNormalRole() == GRO_FIRESUPPORT) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 6
	jne	SHORT $LN44@GetDeaggre

; 1712 : 					ptListType = ArtListType;

	mov	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 5
$LN44@GetDeaggre:

; 1713 : 				}
; 1714 : 			}
; 1715 : 		}
; 1716 : 
; 1717 : 		if (ptListType) {

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	$LN45@GetDeaggre

; 1718 : 			// Find the appropriate installation
; 1719 : 			GridIndex	x,y;
; 1720 : 			Objective	o;
; 1721 : 			GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1722 : 			o = FindNearestObjective (x,y,NULL,1);

	push	1
	push	0
	movzx	eax, WORD PTR _y$6[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$5[ebp]
	push	ecx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$4[ebp], eax

; 1723 : 			*installation = o;

	mov	edx, DWORD PTR _installation$[ebp]
	mov	eax, DWORD PTR _o$4[ebp]
	mov	DWORD PTR [edx], eax

; 1724 : 
; 1725 : 			// Find the appropriate list
; 1726 : 			if (o) {

	cmp	DWORD PTR _o$4[ebp], 0
	je	$LN45@GetDeaggre

; 1727 : 				ObjClassDataType	*oc = o->GetObjectiveClassData();

	mov	ecx, DWORD PTR _o$4[ebp]
	call	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ ; ObjectiveClass::GetObjectiveClassData
	mov	DWORD PTR _oc$1[ebp], eax

; 1728 : 				index = oc->PtDataIndex;

	mov	ecx, DWORD PTR _oc$1[ebp]
	movsx	edx, WORD PTR [ecx+26]
	mov	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx
$LN36@GetDeaggre:

; 1729 : 				while (index) {

	cmp	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	SHORT $LN35@GetDeaggre

; 1730 : 					if (PtHeaderDataTable[index].type == ptListType) {

	mov	eax, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movzx	edx, BYTE PTR [ecx+eax+2]
	cmp	edx, DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	jne	SHORT $LN34@GetDeaggre

; 1731 : 						// The first time we look, we just want to know if we have a list.
; 1732 : 						// Return now.
; 1733 : 						return index;

	mov	eax, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	jmp	$LN46@GetDeaggre
$LN34@GetDeaggre:

; 1734 : 					}
; 1735 : 					index = PtHeaderDataTable[index].nextHeader;

	mov	eax, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+26]
	mov	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx

; 1736 : 				}

	jmp	SHORT $LN36@GetDeaggre
$LN35@GetDeaggre:

; 1737 : 
; 1738 : 				// RV - Biker - OK looks like we did not find AAAListType then search for SAMListType
; 1739 : 				index = oc->PtDataIndex;

	mov	eax, DWORD PTR _oc$1[ebp]
	movsx	ecx, WORD PTR [eax+26]
	mov	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx
$LN33@GetDeaggre:

; 1740 : 				while (index) {

	cmp	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	SHORT $LN45@GetDeaggre

; 1741 : 					if (PtHeaderDataTable[index].type == SAMListType) {

	mov	edx, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movzx	ecx, BYTE PTR [eax+edx+2]
	cmp	ecx, 4
	jne	SHORT $LN31@GetDeaggre

; 1742 : 						return index;

	mov	eax, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	jmp	$LN46@GetDeaggre
$LN31@GetDeaggre:

; 1743 : 					}
; 1744 : 					index = PtHeaderDataTable[index].nextHeader;

	mov	edx, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+26]
	mov	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx

; 1745 : 				}

	jmp	SHORT $LN33@GetDeaggre
$LN45@GetDeaggre:

; 1746 : 			}
; 1747 : 		}
; 1748 : 	}
; 1749 : 
; 1750 : 	// We have a list
; 1751 : 	if (index) {

	cmp	DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	$LN30@GetDeaggre

; 1752 : 		// We have a list, and want to find the correct point
; 1753 : 		UnitClassDataType		*uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$3[ebp], eax

; 1754 : 		VehicleClassDataType	*vc = GetVehicleClassData(uc->VehicleType[slot]);

	mov	edx, DWORD PTR _slot$[ebp]
	mov	eax, DWORD PTR _uc$3[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+68]
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$2[ebp], eax

; 1755 : 		// Check which type of point we're looking for
; 1756 : 		if (ptListType == SAMListType && slot == uc->RadarVehicle)

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 4
	jne	SHORT $LN29@GetDeaggre
	mov	edx, DWORD PTR _uc$3[ebp]
	movzx	eax, BYTE PTR [edx+328]
	cmp	DWORD PTR _slot$[ebp], eax
	jne	SHORT $LN29@GetDeaggre

; 1757 : 			type = RadarPt;

	mov	DWORD PTR _type$[ebp], 7
	jmp	$LN28@GetDeaggre
$LN29@GetDeaggre:

; 1758 : 		else if (ptListType == AAAListType && slot == uc->RadarVehicle)

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 6
	jne	SHORT $LN27@GetDeaggre
	mov	ecx, DWORD PTR _uc$3[ebp]
	movzx	edx, BYTE PTR [ecx+328]
	cmp	DWORD PTR _slot$[ebp], edx
	jne	SHORT $LN27@GetDeaggre

; 1759 : 			type = RadarPt;

	mov	DWORD PTR _type$[ebp], 7
	jmp	SHORT $LN28@GetDeaggre
$LN27@GetDeaggre:

; 1760 : 		else if (ptListType == SAMListType && (vc->Flags & VEH_IS_AIR_DEFENSE))

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 4
	jne	SHORT $LN25@GetDeaggre
	mov	eax, DWORD PTR _vc$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN25@GetDeaggre

; 1761 : 			type = SAMPt;

	mov	DWORD PTR _type$[ebp], 4
	jmp	SHORT $LN28@GetDeaggre
$LN25@GetDeaggre:

; 1762 : 		else if (ptListType == AAAListType && (vc->Flags & VEH_IS_AIR_DEFENSE))

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 6
	jne	SHORT $LN23@GetDeaggre
	mov	edx, DWORD PTR _vc$2[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 131072				; 00020000H
	je	SHORT $LN23@GetDeaggre

; 1763 : 			type = AAAPt;

	mov	DWORD PTR _type$[ebp], 6
	jmp	SHORT $LN28@GetDeaggre
$LN23@GetDeaggre:

; 1764 : 		else if (ptListType == ArtListType && (vc->Flags & VEH_IS_ARTILLERY))

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 5
	jne	SHORT $LN21@GetDeaggre
	mov	ecx, DWORD PTR _vc$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 262144				; 00040000H
	je	SHORT $LN21@GetDeaggre

; 1765 : 			type = ArtilleryPt;

	mov	DWORD PTR _type$[ebp], 5

; 1766 : 		else

	jmp	SHORT $LN28@GetDeaggre
$LN21@GetDeaggre:

; 1767 : 			type = SupportPt;

	mov	DWORD PTR _type$[ebp], 9
$LN28@GetDeaggre:

; 1768 : 
; 1769 : 		// Return the next point, if it's the base type 
; 1770 : 		// NOTE: Log error if we don't have enough points of this type
; 1771 : 		
; 1772 : 		// RV - Biker - Search for SAM pt
; 1773 : 		if (last_SAM_pt && ptListType == SAMListType && type == SAMPt) {

	cmp	DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	SHORT $LN19@GetDeaggre
	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 4
	jne	SHORT $LN19@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN19@GetDeaggre

; 1774 : 			last_SAM_pt = pt = GetNextPt(last_SAM_pt);

	mov	eax, DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx
$LN18@GetDeaggre:

; 1775 : 
; 1776 : 			while (pt && PtDataTable[pt].type != SAMPt) {

	cmp	DWORD PTR _pt$[ebp], 0
	je	SHORT $LN17@GetDeaggre
	mov	edx, DWORD PTR _pt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 4
	je	SHORT $LN17@GetDeaggre

; 1777 : 				last_SAM_pt = pt = GetNextPt(last_SAM_pt);

	mov	edx, DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	edx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	eax, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, eax

; 1778 : 			}

	jmp	SHORT $LN18@GetDeaggre
$LN17@GetDeaggre:

; 1779 : 			return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	$LN46@GetDeaggre
$LN19@GetDeaggre:

; 1780 : 		}
; 1781 : 
; 1782 : 		// RV - Biker - Search for AAA pt
; 1783 : 		if (last_AAA_pt && ptListType == AAAListType && type == AAAPt) {

	cmp	DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	SHORT $LN16@GetDeaggre
	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 6
	jne	SHORT $LN16@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 6
	jne	SHORT $LN16@GetDeaggre

; 1784 : 			last_AAA_pt = pt = GetNextPt(last_AAA_pt);

	mov	ecx, DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	ecx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	edx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx
$LN15@GetDeaggre:

; 1785 : 
; 1786 : 			while (pt && PtDataTable[pt].type != AAAPt) {

	cmp	DWORD PTR _pt$[ebp], 0
	je	SHORT $LN14@GetDeaggre
	mov	eax, DWORD PTR _pt$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 6
	je	SHORT $LN14@GetDeaggre

; 1787 : 				last_AAA_pt = pt = GetNextPt(last_AAA_pt);

	mov	eax, DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx

; 1788 : 			}

	jmp	SHORT $LN15@GetDeaggre
$LN14@GetDeaggre:

; 1789 : 			return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	$LN46@GetDeaggre
$LN16@GetDeaggre:

; 1790 : 		}
; 1791 : 
; 1792 : 		// RV - Biker - Search for artillery pt
; 1793 : 		if (last_art_pt && ptListType == ArtListType && type == ArtilleryPt) {

	cmp	DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	SHORT $LN13@GetDeaggre
	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 5
	jne	SHORT $LN13@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN13@GetDeaggre

; 1794 : 			last_art_pt = pt = GetNextPt(last_art_pt);

	mov	edx, DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	edx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	eax, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, eax
$LN12@GetDeaggre:

; 1795 : 
; 1796 : 			while (pt && PtDataTable[pt].type != ArtilleryPt) {

	cmp	DWORD PTR _pt$[ebp], 0
	je	SHORT $LN11@GetDeaggre
	mov	ecx, DWORD PTR _pt$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 5
	je	SHORT $LN11@GetDeaggre

; 1797 : 				last_art_pt = pt = GetNextPt(last_art_pt);

	mov	ecx, DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	ecx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	edx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx

; 1798 : 			}		

	jmp	SHORT $LN12@GetDeaggre
$LN11@GetDeaggre:

; 1799 : 			return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	$LN46@GetDeaggre
$LN13@GetDeaggre:

; 1800 : 		}
; 1801 : 
; 1802 : 		// RV - Biker - Search for support pt
; 1803 : 		if (last_support_pt && type == SupportPt) {

	cmp	DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 0
	je	SHORT $LN10@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 9
	jne	SHORT $LN10@GetDeaggre

; 1804 : 			last_support_pt = pt = GetNextPt(last_support_pt);

	mov	eax, DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx
$LN9@GetDeaggre:

; 1805 : 
; 1806 : 			while (pt && PtDataTable[pt].type != SupportPt) {

	cmp	DWORD PTR _pt$[ebp], 0
	je	SHORT $LN8@GetDeaggre
	mov	edx, DWORD PTR _pt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 9
	je	SHORT $LN8@GetDeaggre

; 1807 : 				last_support_pt = pt = GetNextPt(last_support_pt);

	mov	edx, DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	edx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
	mov	eax, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, eax

; 1808 : 			}

	jmp	SHORT $LN9@GetDeaggre
$LN8@GetDeaggre:

; 1809 : 			return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	$LN46@GetDeaggre
$LN10@GetDeaggre:

; 1810 : 		}
; 1811 : 
; 1812 : 		// RV - Biker - This is for the first vehicle in unit also for radar vehicles and if we sitch pt type
; 1813 : 		pt = GetFirstPt(index);

	mov	ecx, DWORD PTR ?index@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
$LN7@GetDeaggre:

; 1814 : 
; 1815 : 		while (pt) {

	cmp	DWORD PTR _pt$[ebp], 0
	je	$LN30@GetDeaggre

; 1816 : 			if (PtDataTable[pt].type == type) {

	mov	edx, DWORD PTR _pt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, DWORD PTR _type$[ebp]
	jne	SHORT $LN5@GetDeaggre

; 1817 : 				if (ptListType == SAMListType && type == SAMPt)

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 4
	jne	SHORT $LN4@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN4@GetDeaggre

; 1818 : 					last_SAM_pt = pt;

	mov	edx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_SAM_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx
$LN4@GetDeaggre:

; 1819 : 				if (ptListType == AAAListType && type == AAAPt)

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 6
	jne	SHORT $LN3@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 6
	jne	SHORT $LN3@GetDeaggre

; 1820 : 					last_AAA_pt = pt;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_AAA_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, eax
$LN3@GetDeaggre:

; 1821 : 				if (ptListType == ArtListType && type == ArtilleryPt)

	cmp	DWORD PTR ?ptListType@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, 5
	jne	SHORT $LN2@GetDeaggre
	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN2@GetDeaggre

; 1822 : 					last_art_pt = pt;

	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_art_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, ecx
$LN2@GetDeaggre:

; 1823 : 				if (type == SupportPt)

	cmp	DWORD PTR _type$[ebp], 9
	jne	SHORT $LN1@GetDeaggre

; 1824 : 					last_support_pt = pt;

	mov	edx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR ?last_support_pt@?1??GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z@4HA, edx
$LN1@GetDeaggre:

; 1825 : 
; 1826 : 				return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	SHORT $LN46@GetDeaggre
$LN5@GetDeaggre:

; 1827 : 			}
; 1828 : 			pt = GetNextPt(pt);

	mov	eax, DWORD PTR _pt$[ebp]
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 1829 : 		}

	jmp	$LN7@GetDeaggre
$LN30@GetDeaggre:

; 1830 : #ifdef DEBUG
; 1831 : 		FILE	*fp = fopen("PtDatErr.log","a");
; 1832 : 		if (fp) {
; 1833 : 			char		name[80];
; 1834 : 			GridIndex	x,y;
; 1835 : 			(*installation)->GetName(name,79,FALSE);
; 1836 : 			(*installation)->GetLocation(&x,&y);
; 1837 : 			fprintf(fp, "HeaderList %d (Obj %s @ %d,%d): No points of type %d.\n",index,name,x,y,type);
; 1838 : 			fclose(fp);
; 1839 : 		}
; 1840 : #endif
; 1841 : 	}
; 1842 : 	return pt;

	mov	eax, DWORD PTR _pt$[ebp]
$LN46@GetDeaggre:

; 1843 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetDeaggregationPoint@BattalionClass@@UAEHHPAPAVCampBaseClass@@@Z ENDP ; BattalionClass::GetDeaggregationPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv71 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?ClearDeaggregationData@BattalionClass@@UAEXXZ PROC	; BattalionClass::ClearDeaggregationData
; _this$ = ecx

; 1685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1686 : 	if (deag_data){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+360], 0
	je	SHORT $LN1@ClearDeagg

; 1687 : 		delete deag_data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@ClearDeagg
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GUnitDeaggregationData@@QAEPAXI@Z
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN1@ClearDeagg
$LN4@ClearDeagg:
	mov	DWORD PTR tv71[ebp], 0
$LN1@ClearDeagg:

; 1688 : 	}
; 1689 : 	deag_data = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+360], 0

; 1690 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDeaggregationData@BattalionClass@@UAEXXZ ENDP	; BattalionClass::ClearDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_deagDataPtr$ = -8					; size = 4
_this$ = -4						; size = 4
?GetUnitDeaggregationData@BattalionClass@@UAEPAVUnitDeaggregationData@@XZ PROC ; BattalionClass::GetUnitDeaggregationData
; _this$ = ecx

; 1678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1679 : 	UnitDeaggregationData *deagDataPtr = deag_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	mov	DWORD PTR _deagDataPtr$[ebp], ecx

; 1680 : 	deag_data = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], 0

; 1681 : 	return deagDataPtr;

	mov	eax, DWORD PTR _deagDataPtr$[ebp]

; 1682 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitDeaggregationData@BattalionClass@@UAEPAVUnitDeaggregationData@@XZ ENDP ; BattalionClass::GetUnitDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_a$1 = -16						; size = 4
_combat$ = -12						; size = 4
_e$2 = -8						; size = 4
_this$ = -4						; size = 4
?DoCombat@BattalionClass@@UAEHXZ PROC			; BattalionClass::DoCombat
; _this$ = ecx

; 814  : int BattalionClass::DoCombat(){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 815  : 	int		combat;
; 816  : 
; 817  : 	SetCombatTime(TheCampaign.CurrentTime);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	call	eax

; 818  : 
; 819  : 	if (Engaged()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	je	$LN15@DoCombat

; 820  : 		FalconEntity	*e = GetTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _e$2[ebp], eax

; 821  : 		FalconEntity	*a = GetAirTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+656]
	call	eax
	mov	DWORD PTR _a$1[ebp], eax

; 822  : 
; 823  : 		// Check vs our Ground Target
; 824  : 		if (!e)											

	cmp	DWORD PTR _e$2[ebp], 0
	jne	SHORT $LN14@DoCombat

; 825  : 		{
; 826  : 			SetTargeted(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargeted@UnitClass@@QAEXH@Z		; UnitClass::SetTargeted

; 827  : 			SetTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ; UnitClass::SetTarget

; 828  : 		}
; 829  : 		else

	jmp	$LN13@DoCombat
$LN14@DoCombat:

; 830  : 		{
; 831  : 			if (Combat() && IsAggregate())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Combat@UnitClass@@QBEHXZ		; UnitClass::Combat
	test	eax, eax
	je	SHORT $LN12@DoCombat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN12@DoCombat

; 832  : 			{
; 833  : 				combat = ::DoCombat(this,e);

	mov	ecx, DWORD PTR _e$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z ; DoCombat
	add	esp, 8
	mov	DWORD PTR _combat$[ebp], eax

; 834  : 				if (combat <= 0 || Targeted())

	cmp	DWORD PTR _combat$[ebp], 0
	jle	SHORT $LN10@DoCombat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Targeted@UnitClass@@QBEHXZ		; UnitClass::Targeted
	test	eax, eax
	je	SHORT $LN12@DoCombat
$LN10@DoCombat:

; 835  : 				{
; 836  : 					SetTarget(NULL);						// Clear targeting data so we can look for another

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ; UnitClass::SetTarget

; 837  : 					SetTargeted(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargeted@UnitClass@@QAEXH@Z		; UnitClass::SetTargeted
$LN12@DoCombat:

; 838  : 				}
; 839  : 			}
; 840  : 			// Check if our target should call in Artillery/CAS against us (Only for enemy battalions with bad odds)
; 841  : 			if (e->IsUnit() && e->GetDomain() == DOMAIN_LAND && ((Unit)e)->GetOdds() < 20 && !((Unit)e)->Supported())

	mov	eax, DWORD PTR _e$2[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$2[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN13@DoCombat
	mov	ecx, DWORD PTR _e$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$2[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
	movzx	ecx, al
	cmp	ecx, 3
	jne	SHORT $LN13@DoCombat
	mov	ecx, DWORD PTR _e$2[ebp]
	call	?GetOdds@UnitClass@@QAEFXZ		; UnitClass::GetOdds
	movsx	edx, ax
	cmp	edx, 20					; 00000014H
	jge	SHORT $LN13@DoCombat
	mov	ecx, DWORD PTR _e$2[ebp]
	call	?Supported@UnitClass@@QBEHXZ		; UnitClass::Supported
	test	eax, eax
	jne	SHORT $LN13@DoCombat

; 842  : 			{
; 843  : 				// Look for artillery or air support
; 844  : 				if (RequestSupport((Unit)e,this))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$2[ebp]
	push	ecx
	call	?RequestSupport@@YAHPAVUnitClass@@0@Z	; RequestSupport
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@DoCombat

; 845  : 					((Unit)e)->SetSupported(1);

	push	1
	mov	ecx, DWORD PTR _e$2[ebp]
	call	?SetSupported@UnitClass@@QAEXH@Z	; UnitClass::SetSupported
$LN13@DoCombat:

; 846  : 			}
; 847  : 		}
; 848  : 		SetSupported(0);									// Clear supported flag so we can ask again

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSupported@UnitClass@@QAEXH@Z	; UnitClass::SetSupported

; 849  : 		// Check vs our Air Target
; 850  : 		if (!a)

	cmp	DWORD PTR _a$1[ebp], 0
	jne	SHORT $LN7@DoCombat

; 851  : 			SetAirTarget(NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1024]
	call	edx
	jmp	SHORT $LN6@DoCombat
$LN7@DoCombat:

; 852  : 		else if (Combat() && IsAggregate())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Combat@UnitClass@@QBEHXZ		; UnitClass::Combat
	test	eax, eax
	je	SHORT $LN6@DoCombat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN6@DoCombat

; 853  : 		{
; 854  : 			combat = ::DoCombat(this,a);

	mov	eax, DWORD PTR _a$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?DoCombat@@YAHPAVCampBaseClass@@PAVFalconEntity@@@Z ; DoCombat
	add	esp, 8
	mov	DWORD PTR _combat$[ebp], eax

; 855  : 			if (combat < 0)

	cmp	DWORD PTR _combat$[ebp], 0
	jge	SHORT $LN6@DoCombat

; 856  : 				SetAirTarget(NULL);							// Clear targeting data so we can look for another

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1024]
	call	edx
$LN6@DoCombat:

; 857  : 		}
; 858  : 
; 859  : 		// KCK HACK: Ground units engaged with air targets AND ground units were shooting much more often
; 860  : 		// because their last combat time was being adjusted during the radar aquisition phase. This
; 861  : 		// will simply force the combat time to current time if we're ever engaged with a ground unit
; 862  : 		if (e)

	cmp	DWORD PTR _e$2[ebp], 0
	je	SHORT $LN3@DoCombat

; 863  : 			SetCombatTime(TheCampaign.CurrentTime);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	call	eax
$LN3@DoCombat:

; 864  : 		// End HACK:
; 865  : 	}

	jmp	SHORT $LN2@DoCombat
$LN15@DoCombat:

; 866  : 	else if (Losses())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Losses@UnitClass@@QBEHXZ		; UnitClass::Losses
	test	eax, eax
	je	SHORT $LN2@DoCombat

; 867  : 	{
; 868  : 		SetLosses(0);										// Clear losses flag when we disengage

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLosses@UnitClass@@QAEXH@Z		; UnitClass::SetLosses

; 869  : 		SetSupported(0);									// Clear supported flag so we can ask again

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSupported@UnitClass@@QAEXH@Z	; UnitClass::SetSupported
$LN2@DoCombat:

; 870  : 	}
; 871  : 
; 872  : 	return 0;

	xor	eax, eax

; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoCombat@BattalionClass@@UAEHXZ ENDP			; BattalionClass::DoCombat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T2 = -248						; size = 8
$T3 = -240						; size = 8
$T4 = -232						; size = 8
$T5 = -224						; size = 8
$T6 = -216						; size = 8
$T7 = -208						; size = 8
_formation$8 = -200					; size = 4
$T9 = -196						; size = 4
$T10 = -192						; size = 4
$T11 = -188						; size = 4
$T12 = -184						; size = 4
$T13 = -180						; size = 4
$T14 = -176						; size = 4
$T15 = -172						; size = 4
tv908 = -168						; size = 4
tv95 = -164						; size = 4
_brig$16 = -160						; size = 4
_o$17 = -156						; size = 4
_brig$18 = -152						; size = 4
_moving$ = -148						; size = 4
_u$19 = -144						; size = 4
_py$20 = -140						; size = 2
_px$21 = -136						; size = 2
_pwx$22 = -132						; size = 2
_pwy$23 = -128						; size = 2
_px$24 = -124						; size = 2
_py$25 = -120						; size = 2
_pw$ = -116						; size = 4
_u$26 = -112						; size = 4
_w$ = -108						; size = 4
_lo$ = -104						; size = 4
_nx$ = -100						; size = 2
_ny$ = -96						; size = 2
_y$ = -92						; size = 2
_x$ = -88						; size = 2
_h$ = -81						; size = 1
_this$ = -80						; size = 4
_temp_path$ = -76					; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_time$ = 8						; size = 4
?MoveUnit@BattalionClass@@UAEHK@Z PROC			; BattalionClass::MoveUnit
; _this$ = ecx

; 421  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MoveUnit@BattalionClass@@UAEHK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 	GridIndex       x,y,nx,ny;
; 423  : 	int				moving = 1;

	mov	DWORD PTR _moving$[ebp], 1

; 424  : 	CampaignHeading	h;
; 425  : 	PathClass		temp_path;

	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 426  : 	WayPoint		pw = NULL,w = NULL;

	mov	DWORD PTR _pw$[ebp], 0
	mov	DWORD PTR _w$[ebp], 0

; 427  : 	Objective		lo = NULL;

	mov	DWORD PTR _lo$[ebp], 0

; 428  : 
; 429  : #ifdef DEBUG_TIMING
; 430  : 	DWORD			timec = GetTickCount();
; 431  : #endif
; 432  : 
; 433  : 	haveWeaps = -1;

	mov	DWORD PTR ?haveWeaps@@3HA, -1		; haveWeaps

; 434  : 
; 435  : 	// Check if we have a valid objective
; 436  : 	lo = GetUnitObjective();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _lo$[ebp], eax

; 437  : 	if (
; 438  : 		!lo || (
; 439  : 			Parent() && (FalconLocalGame->GetGameType() == game_Campaign) && 
; 440  : 			!TeamInfo[GetTeam()]->gtm->IsValidObjective(GetOrders(),lo)
; 441  : 		)
; 442  : 	){

	cmp	DWORD PTR _lo$[ebp], 0
	je	$LN67@MoveUnit
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	$LN64@MoveUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN71@MoveUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN72@MoveUnit
$LN71@MoveUnit:
	mov	DWORD PTR tv95[ebp], 0
$LN72@MoveUnit:
	mov	ecx, DWORD PTR tv95[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	$LN64@MoveUnit
	mov	edx, DWORD PTR _lo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOrders@GroundUnitClass@@QAEEXZ	; GroundUnitClass::GetOrders
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+880]
	call	?IsValidObjective@GroundTaskingManagerClass@@QAEHHPAVObjectiveClass@@@Z ; GroundTaskingManagerClass::IsValidObjective
	test	eax, eax
	jne	$LN64@MoveUnit
$LN67@MoveUnit:

; 443  : 		if (Parent()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	SHORT $LN66@MoveUnit

; 444  : 			lo = FindRetreatPath(this,3,0);

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z ; FindRetreatPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lo$[ebp], eax
$LN66@MoveUnit:

; 445  : 		}
; 446  : 		if (lo){

	cmp	DWORD PTR _lo$[ebp], 0
	je	SHORT $LN65@MoveUnit

; 447  : 			SetUnitOrders(GORD_RESERVE,lo->Id());

	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 448  : 		}
; 449  : 		else {

	jmp	SHORT $LN64@MoveUnit
$LN65@MoveUnit:

; 450  : #ifdef ROBIN_DEBUG
; 451  : 			MonoPrint("Error: Battalion %d not assigned! - vegitating instead.\n",GetCampID());
; 452  : #endif
; 453  : 			SetLastCheck (GetLastCheck () + CampaignMinutes);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	add	eax, 60000				; 0000ea60H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck

; 454  : 			return 0;

	mov	DWORD PTR $T14[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T14[ebp]
	jmp	$LN69@MoveUnit
$LN64@MoveUnit:

; 455  : 		}
; 456  : 	}
; 457  : 
; 458  : 	GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 459  : 	// VP_changes for tracing DB 
; 460  : 	/*
; 461  : 	   FILE* deb = fopen("c:\\traceA10\\dbrain.txt", "a");
; 462  : 	   fprintf(deb, "BattalionClass MoveUnit x=%f y=%f \n", x, y );   
; 463  : 	   fclose(deb);
; 464  : 	   */
; 465  : 
; 466  : 	// Check if we're being transported
; 467  : 	ShiAssert(!Cargo());
; 468  : 
; 469  : 	// Check to make sure our orders and tactics are still valid.
; 470  : 	ChooseTactic();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+496]
	call	eax

; 471  : 
; 472  : 	// Make some adjustments for certain tactics 
; 473  : 	if (GetUnitTactic() == GTACTIC_DELAY_FALLBACK){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 15					; 0000000fH
	jne	$LN63@MoveUnit

; 474  : 		// Keep falling back 1 km until our tactic changes
; 475  : 		lo = FindRetreatPath(this,1,0);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?FindRetreatPath@@YAPAVObjectiveClass@@PAVUnitClass@@HH@Z ; FindRetreatPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lo$[ebp], eax

; 476  : 		if (!lo) {

	cmp	DWORD PTR _lo$[ebp], 0
	jne	SHORT $LN62@MoveUnit

; 477  : 			// This unit is cut off.
; 478  : 			CheckForSurrender();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+936]
	call	edx

; 479  : 		}
; 480  : 		else {

	jmp	$LN61@MoveUnit
$LN62@MoveUnit:

; 481  : 			GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 482  : 			lo->GetLocation(&nx,&ny);

	lea	edx, DWORD PTR _ny$[ebp]
	push	edx
	lea	eax, DWORD PTR _nx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lo$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 483  : 			GetUnitGridPath(&temp_path,x,y,nx,ny);

	movzx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_path$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath

; 484  : 			h = GetNextMoveDirection();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+920]
	call	eax
	mov	BYTE PTR _h$[ebp], al

; 485  : 			x += dx[h];

	movzx	ecx, BYTE PTR _h$[ebp]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	movsx	eax, WORD PTR _x$[ebp]
	add	eax, edx
	mov	WORD PTR _x$[ebp], ax

; 486  : 			y += dy[h];

	movzx	ecx, BYTE PTR _h$[ebp]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	movsx	eax, WORD PTR _y$[ebp]
	add	eax, edx
	mov	WORD PTR _y$[ebp], ax

; 487  : 			SetUnitDestination(x,y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 488  : 			SetTempDest(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest
$LN61@MoveUnit:

; 489  : 		}

	jmp	$LN48@MoveUnit
$LN63@MoveUnit:

; 490  : 	}
; 491  : 	else if (GetUnitTactic() == GTACTIC_SUPPORT_UNIT) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN59@MoveUnit

; 492  : 		if (Ordered() && PositionToSupportUnit(this) < 1) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Ordered@UnitClass@@QBEHXZ		; UnitClass::Ordered
	test	eax, eax
	je	SHORT $LN58@MoveUnit
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?PositionToSupportUnit@@YAHPAVBattalionClass@@@Z ; PositionToSupportUnit
	add	esp, 4
	cmp	eax, 1
	jge	SHORT $LN58@MoveUnit

; 493  : 			SetUnitOrders(GORD_RESERVE,GetUnitObjectiveID());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+876]
	call	edx
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 494  : 			return 0;

	mov	DWORD PTR $T13[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T13[ebp]
	jmp	$LN69@MoveUnit
$LN58@MoveUnit:

; 495  : 		}
; 496  : 	}

	jmp	$LN48@MoveUnit
$LN59@MoveUnit:

; 497  : 	else if (GetUnitTactic() == GTACTIC_MOVE_BRIGADE_COLUMN && GetUnitElement()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 18					; 00000012H
	jne	$LN56@MoveUnit
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+892]
	call	eax
	test	eax, eax
	je	$LN56@MoveUnit

; 498  : 		// We want to follow the previous battalion, unless we're closer to our destination in which
; 499  : 		// case we hang out off the road and wait for the other unit to pass
; 500  : 		Unit		u = NULL,brig;

	mov	DWORD PTR _u$26[ebp], 0

; 501  : 		GridIndex	px,py;
; 502  : 		brig = GetUnitParent();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brig$18[ebp], eax

; 503  : 		if (brig){

	cmp	DWORD PTR _brig$18[ebp], 0
	je	SHORT $LN55@MoveUnit

; 504  : 			u = brig->GetPrevUnitElement(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _brig$18[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _brig$18[ebp]
	mov	edx, DWORD PTR [eax+968]
	call	edx
	mov	DWORD PTR _u$26[ebp], eax
$LN55@MoveUnit:

; 505  : 		}
; 506  : 		if (u && (u != this) && (u->GetUnitTactic() == GTACTIC_MOVE_BRIGADE_COLUMN)){

	cmp	DWORD PTR _u$26[ebp], 0
	je	SHORT $LN54@MoveUnit
	mov	eax, DWORD PTR _u$26[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	je	SHORT $LN54@MoveUnit
	mov	ecx, DWORD PTR _u$26[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN54@MoveUnit

; 507  : 			pw = u->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _u$26[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _pw$[ebp], eax

; 508  : 			if (pw)

	cmp	DWORD PTR _pw$[ebp], 0
	je	SHORT $LN53@MoveUnit

; 509  : 				pw->GetWPLocation(&px,&py);

	lea	ecx, DWORD PTR _py$20[ebp]
	push	ecx
	lea	edx, DWORD PTR _px$21[ebp]
	push	edx
	mov	ecx, DWORD PTR _pw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 510  : 			else

	jmp	SHORT $LN52@MoveUnit
$LN53@MoveUnit:

; 511  : 				u->GetLocation(&px,&py);

	lea	eax, DWORD PTR _py$20[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$21[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$26[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation
$LN52@MoveUnit:

; 512  : 			// Follow our previous element (temporarily)
; 513  : 			SetUnitDestination(px,py);

	movzx	edx, WORD PTR _py$20[ebp]
	push	edx
	movzx	eax, WORD PTR _px$21[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 514  : 			SetTempDest(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest
	jmp	SHORT $LN50@MoveUnit
$LN54@MoveUnit:

; 515  : 		}
; 516  : 		else if (TempDest()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TempDest@UnitClass@@QBEHXZ		; UnitClass::TempDest
	test	eax, eax
	je	SHORT $LN50@MoveUnit

; 517  : 			PickFinalLocation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PickFinalLocation@BattalionClass@@QAEXXZ ; BattalionClass::PickFinalLocation
$LN50@MoveUnit:

; 518  : 		}
; 519  : 	}

	jmp	SHORT $LN48@MoveUnit
$LN56@MoveUnit:

; 520  : 	else if (TempDest()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TempDest@UnitClass@@QBEHXZ		; UnitClass::TempDest
	test	eax, eax
	je	SHORT $LN48@MoveUnit

; 521  : 		PickFinalLocation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PickFinalLocation@BattalionClass@@QAEXXZ ; BattalionClass::PickFinalLocation
$LN48@MoveUnit:

; 522  : 	}
; 523  : 
; 524  : 	GetUnitDestination(&nx,&ny);

	lea	ecx, DWORD PTR _ny$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 525  : 	if (Ordered()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Ordered@UnitClass@@QBEHXZ		; UnitClass::Ordered
	test	eax, eax
	je	SHORT $LN47@MoveUnit

; 526  : 		ClearUnitPath();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+916]
	call	eax

; 527  : 		DisposeWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints

; 528  : 		SetOrdered(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOrdered@UnitClass@@QAEXH@Z		; UnitClass::SetOrdered
$LN47@MoveUnit:

; 529  : 	}
; 530  : 
; 531  : 	// Get our next waypoint, or build a set of waypoints if we don't have any
; 532  : 	if ((x != nx) || (y != ny)) {

	movsx	ecx, WORD PTR _x$[ebp]
	movsx	edx, WORD PTR _nx$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN45@MoveUnit
	movsx	eax, WORD PTR _y$[ebp]
	movsx	ecx, WORD PTR _ny$[ebp]
	cmp	eax, ecx
	je	$LN46@MoveUnit
$LN45@MoveUnit:

; 533  : 		w = GetCurrentUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 534  : 		if (!w)	{

	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN44@MoveUnit

; 535  : 			if (BuildGroundWP(this) < 0){

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?BuildGroundWP@@YAHPAVUnitClass@@@Z	; BuildGroundWP
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN43@MoveUnit

; 536  : 				// Build a path
; 537  : 				SetUnitObjective(FalconNullId);			// We failed for some reason, so clear our objective

	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+824]
	call	edx

; 538  : 				return 0;

	mov	DWORD PTR $T10[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T10[ebp]
	jmp	$LN69@MoveUnit
$LN43@MoveUnit:

; 539  : 			}
; 540  : 			w = GetCurrentUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax
$LN44@MoveUnit:

; 541  : 		}
; 542  : 		if (w){

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN42@MoveUnit

; 543  : 			w->GetWPLocation(&nx,&ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation
$LN42@MoveUnit:

; 544  : 		}
; 545  : 	}
; 546  : 	else {

	jmp	SHORT $LN39@MoveUnit
$LN46@MoveUnit:

; 547  : 		if (Retreating() && !Engaged()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Retreating@UnitClass@@QBEHXZ		; UnitClass::Retreating
	test	eax, eax
	je	SHORT $LN40@MoveUnit
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engaged@UnitClass@@QBEHXZ		; UnitClass::Engaged
	test	eax, eax
	jne	SHORT $LN40@MoveUnit

; 548  : 			// We've retreated to our destination
; 549  : 			SetRetreating(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRetreating@UnitClass@@QAEXH@Z	; UnitClass::SetRetreating
$LN40@MoveUnit:

; 550  : 		}
; 551  : 		if (final_heading < 255){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+295]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN39@MoveUnit

; 552  : 			heading = final_heading;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+295]
	mov	BYTE PTR [ecx+296], al
$LN39@MoveUnit:

; 553  : 		}
; 554  : 	}
; 555  : 
; 556  : 	// Check if we've arrived at this waypoint, and get next one if so.
; 557  : 	// KCK WARNING: This is duplicated at the bottom of this function -
; 558  : 	// we may be able to remove it from this point.
; 559  : 	if (w && (x==nx) && (y==ny)){

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN36@MoveUnit
	movsx	ecx, WORD PTR _x$[ebp]
	movsx	edx, WORD PTR _nx$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN36@MoveUnit
	movsx	eax, WORD PTR _y$[ebp]
	movsx	ecx, WORD PTR _ny$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN36@MoveUnit

; 560  : 		FinishUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinishUnitWP@UnitClass@@QAEXXZ		; UnitClass::FinishUnitWP

; 561  : 		w = GetCurrentUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 562  : 		if (w){

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN37@MoveUnit

; 563  : 			w->GetWPLocation(&nx,&ny);

	lea	edx, DWORD PTR _ny$[ebp]
	push	edx
	lea	eax, DWORD PTR _nx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation
$LN37@MoveUnit:

; 564  : 		}
; 565  : 		// Also set our last objective, if we're on one
; 566  : 		if (lo = GetObjectiveByXY(x,y)){

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?GetObjectiveByXY@@YAPAVObjectiveClass@@FF@Z ; GetObjectiveByXY
	add	esp, 8
	mov	DWORD PTR _lo$[ebp], eax
	cmp	DWORD PTR _lo$[ebp], 0
	je	SHORT $LN36@MoveUnit

; 567  : 			last_obj = lo->Id();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _lo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+340], ecx
	mov	DWORD PTR [eax+344], edx
$LN36@MoveUnit:

; 568  : 		}
; 569  : 	}
; 570  : 
; 571  : 	// Make some adjustments for certain tactics
; 572  : 	if ((GetUnitTactic() == GTACTIC_MOVE_BRIGADE_COLUMN) && GetUnitElement()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 18					; 00000012H
	jne	$LN35@MoveUnit
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+892]
	call	eax
	test	eax, eax
	je	$LN35@MoveUnit

; 573  : 		Unit		u=NULL,brig;

	mov	DWORD PTR _u$19[ebp], 0

; 574  : 		GridIndex	px,py,pwx,pwy;
; 575  : 		// Our next waypoint shouldn't be closer to the brigade's destination than the previous element's
; 576  : 		brig = GetUnitParent();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _brig$16[ebp], eax

; 577  : 		if (brig){

	cmp	DWORD PTR _brig$16[ebp], 0
	je	SHORT $LN34@MoveUnit

; 578  : 			u = brig->GetPrevUnitElement(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _brig$16[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _brig$16[ebp]
	mov	edx, DWORD PTR [eax+968]
	call	edx
	mov	DWORD PTR _u$19[ebp], eax
$LN34@MoveUnit:

; 579  : 		}
; 580  : 		if (u){

	cmp	DWORD PTR _u$19[ebp], 0
	je	$LN31@MoveUnit

; 581  : 			u->GetLocation(&px,&py);

	lea	eax, DWORD PTR _py$25[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$24[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$19[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 582  : 			pw = u->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _u$19[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _pw$[ebp], eax

; 583  : 			if (pw)	{

	cmp	DWORD PTR _pw$[ebp], 0
	je	$LN31@MoveUnit

; 584  : 				pw->GetWPLocation(&pwx,&pwy);

	lea	edx, DWORD PTR _pwy$23[ebp]
	push	edx
	lea	eax, DWORD PTR _pwx$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _pw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 585  : 				if ((DistSqu(x,y,px,py) < 25.0F) || (DistSqu(x,y,pwx,pwy) < DistSqu(px,py,pwx,pwy))){

	movzx	ecx, WORD PTR _py$25[ebp]
	push	ecx
	movzx	edx, WORD PTR _px$24[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@41c80000
	comiss	xmm1, xmm0
	ja	SHORT $LN30@MoveUnit
	movzx	edx, WORD PTR _pwy$23[ebp]
	push	edx
	movzx	eax, WORD PTR _pwx$22[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	mov	esi, eax
	movzx	eax, WORD PTR _pwy$23[ebp]
	push	eax
	movzx	ecx, WORD PTR _pwx$22[ebp]
	push	ecx
	movzx	edx, WORD PTR _py$25[ebp]
	push	edx
	movzx	eax, WORD PTR _px$24[ebp]
	push	eax
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jge	SHORT $LN31@MoveUnit
$LN30@MoveUnit:

; 586  : 					nx = x;		// Don't move right now - wait for previous element to pass

	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR _nx$[ebp], cx

; 587  : 					ny = y;

	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR _ny$[ebp], dx

; 588  : 					w = NULL;

	mov	DWORD PTR _w$[ebp], 0
$LN31@MoveUnit:

; 589  : 				}
; 590  : 			}
; 591  : 		}
; 592  : 	}

	jmp	$LN26@MoveUnit
$LN35@MoveUnit:

; 593  : 	else if (GetUnitTactic() == GTACTIC_MOVE_HOLD){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 28					; 0000001cH
	jne	SHORT $LN28@MoveUnit

; 594  : 		// Hang out here til we switch tactics
; 595  : 		nx = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _nx$[ebp], ax

; 596  : 		ny = y;

	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _ny$[ebp], cx
	jmp	$LN26@MoveUnit
$LN28@MoveUnit:

; 597  : 	}
; 598  : 	else if (GetUnitTactic() == GTACTIC_MOVE_AIRBORNE){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 16					; 00000010H
	jne	$LN26@MoveUnit

; 599  : 		if (GetCargoId() == Id()){

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetCargoId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@MoveUnit

; 600  : 			// We're in wait mode - either time out or continue waiting
; 601  : 			if (TheCampaign.CurrentTime > last_move + 10 * CampaignMinutes)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+324]
	add	eax, 600000				; 000927c0H
	cmp	DWORD PTR ?TheCampaign@@3VCampaignClass@@A, eax
	jbe	SHORT $LN24@MoveUnit

; 602  : 			{
; 603  : 				SetRefused(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRefused@UnitClass@@QAEXH@Z		; UnitClass::SetRefused

; 604  : 				SetUnitTactic(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitTactic@UnitClass@@QAEXE@Z	; UnitClass::SetUnitTactic

; 605  : 				SetCargoId (FalconNullId);

	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z	; UnitClass::SetCargoId
$LN24@MoveUnit:

; 606  : 			}
; 607  : 			return 0;

	mov	DWORD PTR $T9[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN69@MoveUnit
$LN25@MoveUnit:

; 608  : 		}
; 609  : 		// Otherwise, hang out and wait for the transports 
; 610  : 		nx = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _nx$[ebp], ax

; 611  : 		ny = y;

	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _ny$[ebp], cx
$LN26@MoveUnit:

; 612  : 	}
; 613  : 
; 614  : #ifdef ROBIN_DEBUG
; 615  : #ifdef CAMPTOOL
; 616  : 	// Display what we're doing, if it's on..
; 617  : 	if (SHOWSTATS && Engaged() && TrackingOn[GetCampID()])
; 618  : #endif
; 619  : 	{
; 620  : 		Objective	o;
; 621  : 		GridIndex	dx,dy;
; 622  : 		CampEntity	tar;
; 623  : 		int			tid = 0;
; 624  : 
; 625  : 		GetUnitDestination(&dx,&dy);
; 626  : 		tar = (CampEntity) GetTarget();
; 627  : 		if (tar)
; 628  : 			tid = tar->GetCampID();
; 629  : 		o = GetUnitObjective();
; 630  : 		if (o)
; 631  : 			MonoPrint("Bat %d: %d,%d->%d,%d (%d @ %d,%d), T:%d, F:%d, E:%d, S:%d",GetCampID(),x,y,nx,ny,o->GetCampID(),dx,dy,GetUnitTactic(),GetUnitFormation(),tid,GetUnitSpeed());
; 632  : 		else
; 633  : 			MonoPrint("Bat %d: %d,%d->%d,%d (%d,%d), T:%d, F:%d, E:%d, S:%d",GetCampID(),x,y,nx,ny,dx,dy,GetUnitTactic(),GetUnitFormation(),tid,GetUnitSpeed());
; 634  : 	}
; 635  : #endif
; 636  : 
; 637  : 	// Now try to actually move
; 638  : 	if ((x != nx) || (y != ny)){

	movsx	edx, WORD PTR _x$[ebp]
	movsx	eax, WORD PTR _nx$[ebp]
	cmp	edx, eax
	jne	SHORT $LN22@MoveUnit
	movsx	ecx, WORD PTR _y$[ebp]
	movsx	edx, WORD PTR _ny$[ebp]
	cmp	ecx, edx
	je	$LN23@MoveUnit
$LN22@MoveUnit:

; 639  : 		SetMoving(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoving@UnitClass@@QAEXH@Z		; UnitClass::SetMoving

; 640  : 		if (GetNextMoveDirection() == Here){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+920]
	call	eax
	cmp	eax, 8
	jne	$LN19@MoveUnit

; 641  : 			if (GetUnitGridPath(&temp_path,x,y,nx,ny) <= 0){

	movzx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_path$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath
	test	eax, eax
	jg	SHORT $LN20@MoveUnit

; 642  : #ifdef LOG_ERRORS
; 643  : 				char	buffer[1280],name1[80],timestr[80];
; 644  : 				FILE	*fp;
; 645  : 
; 646  : 				sprintf(buffer,"campaign\\save\\dump\\errors.log");
; 647  : 				fp = fopen(buffer,"a");
; 648  : 				if (fp){
; 649  : 					GetName(name1,79,FALSE);
; 650  : 					GetTimeString(TheCampaign.CurrentTime,timestr);
; 651  : 					sprintf(buffer,"%s (%d) %d,%d couldn't find path to %d,%d @ %s\n",name1,GetCampID(),x,y,nx,ny,timestr);
; 652  : 					fprintf(fp,buffer);
; 653  : 					fclose(fp);
; 654  : 				}
; 655  : #endif
; 656  : 				// Couldn't find a path (usually a destroyed bridge),
; 657  : 				// so clear our waypoints, rebuild and quit (we'll move next time we check)
; 658  : 				ClearUnitPath();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+916]
	call	eax

; 659  : 				DisposeWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints

; 660  : 				BuildGroundWP(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?BuildGroundWP@@YAHPAVUnitClass@@@Z	; BuildGroundWP
	add	esp, 4

; 661  : 				SetUnitLastMove(time);

	mov	edx, DWORD PTR _time$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	call	eax

; 662  : 				return 0;

	mov	DWORD PTR $T11[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T11[ebp]
	jmp	$LN69@MoveUnit

; 663  : 			}
; 664  : 			else {

	jmp	SHORT $LN19@MoveUnit
$LN20@MoveUnit:

; 665  : 				path->CopyPath(&temp_path);

	lea	ecx, DWORD PTR _temp_path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+356]
	call	?CopyPath@BasePathClass@@QAEHPAV1@@Z	; BasePathClass::CopyPath

; 666  : 				MakeBattalionDirty(DIRTY_SMALLPATH, SEND_SOON);

	push	4096					; 00001000H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeBattalionDirty@BattalionClass@@QAEXW4Dirty_Battalion@@W4Dirtyness@@@Z ; BattalionClass::MakeBattalionDirty
$LN19@MoveUnit:

; 667  : 			}
; 668  : 		}
; 669  : 	}
; 670  : 	else {

	jmp	$LN18@MoveUnit
$LN23@MoveUnit:

; 671  : 		// Clear offensive unit's assigned flags, so they're retasked by the brigade
; 672  : 		if (GetUnitCurrentRole() == GRO_ATTACK){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN16@MoveUnit

; 673  : 			Objective o = GetUnitObjective();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	call	eax
	mov	DWORD PTR _o$17[ebp], eax

; 674  : 			if (o->GetTeam() == GetTeam()){

	mov	ecx, DWORD PTR _o$17[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$17[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	esi, al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN16@MoveUnit

; 675  : 				SetAssigned(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAssigned@UnitClass@@QAEXH@Z		; UnitClass::SetAssigned

; 676  : 				o->SetAbandoned(0);

	push	0
	mov	ecx, DWORD PTR _o$17[ebp]
	call	?SetAbandoned@ObjectiveClass@@QAEXH@Z	; ObjectiveClass::SetAbandoned
$LN16@MoveUnit:

; 677  : 			}
; 678  : 		}
; 679  : 		// Clear the moves in case of residue
; 680  : 		ClearUnitPath();	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+916]
	call	edx

; 681  : 		SetMoving(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoving@UnitClass@@QAEXH@Z		; UnitClass::SetMoving
$LN18@MoveUnit:

; 682  : 	}
; 683  : 
; 684  : 	if (!IsAggregate()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN15@MoveUnit

; 685  : 		return 0;

	mov	DWORD PTR $T15[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T15[ebp]
	jmp	$LN69@MoveUnit
$LN15@MoveUnit:

; 686  : 	}
; 687  : 
; 688  : 	while (moving){

	cmp	DWORD PTR _moving$[ebp], 0
	je	$LN13@MoveUnit

; 689  : #ifdef DEBUG
; 690  : 		if (!IsAggregate()){
; 691  : 			MonoPrint("Updating deaggregate unit #%d.\n",GetCampID());
; 692  : 		}
; 693  : #endif
; 694  : 		int	formation = GetUnitFormation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	mov	DWORD PTR _formation$8[ebp], eax

; 695  : 		h = GetNextMoveDirection();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+920]
	call	eax
	mov	BYTE PTR _h$[ebp], al

; 696  : 		if (h != Here){

	movzx	ecx, BYTE PTR _h$[ebp]
	cmp	ecx, 8
	je	SHORT $LN10@MoveUnit

; 697  : 			// Below is ok, if we've got time for it - otherwise, we drive through other units.
; 698  : 			//			h = GetAlternateHeading(this,x,y,nx,ny,h);					// Check if we need to go around
; 699  : 			if (GetUnitTactic() == GTACTIC_DELAY_FALLBACK){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN11@MoveUnit

; 700  : 				heading = (h+4)%8;			// We back up when falling back

	movzx	edx, BYTE PTR _h$[ebp]
	add	edx, 4
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN77@MoveUnit
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN77@MoveUnit:
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+296], dl

; 701  : 			}
; 702  : 			else{

	jmp	SHORT $LN10@MoveUnit
$LN11@MoveUnit:

; 703  : 				heading = h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _h$[ebp]
	mov	BYTE PTR [ecx+296], dl
$LN10@MoveUnit:

; 704  : 			}
; 705  : 		}
; 706  : 		if ((h<0) || (h>7)){

	movzx	eax, BYTE PTR _h$[ebp]
	test	eax, eax
	jl	SHORT $LN8@MoveUnit
	movzx	ecx, BYTE PTR _h$[ebp]
	cmp	ecx, 7
	jle	$LN7@MoveUnit
$LN8@MoveUnit:

; 707  : 			ClearUnitPath();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+916]
	call	edx

; 708  : 			ChangeUnitLocation(Here);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeUnitLocation@UnitClass@@QAEHE@Z	; UnitClass::ChangeUnitLocation

; 709  : 			moving = 0;

	mov	DWORD PTR _moving$[ebp], 0

; 710  : 			if (fatigue > 0){					// Regain fatigue (faster if on reserve orders)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+293]
	test	ecx, ecx
	jle	SHORT $LN7@MoveUnit

; 711  : 				fatigue -= ((GetUnitOrders() == GORD_RESERVE)? 1 : rand()%2) * REGAIN_RATE_MULTIPLIER_FOR_TE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+880]
	call	edx
	test	eax, eax
	jne	SHORT $LN73@MoveUnit
	mov	DWORD PTR tv908[ebp], 1
	jmp	SHORT $LN74@MoveUnit
$LN73@MoveUnit:
	call	_rand
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN78@MoveUnit
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN78@MoveUnit:
	mov	DWORD PTR tv908[ebp], eax
$LN74@MoveUnit:
	movsx	eax, WORD PTR ?REGAIN_RATE_MULTIPLIER_FOR_TE@@3FA ; REGAIN_RATE_MULTIPLIER_FOR_TE
	imul	eax, DWORD PTR tv908[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+293]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+293], dl
$LN7@MoveUnit:

; 712  : 			}
; 713  : 		}
; 714  : 
; 715  : #ifdef USE_FLANKS
; 716  : 		if ((formation == GFORM_WEDGE) || (formation == GFORM_ECHELON) || (formation == GFORM_LINE)){
; 717  : 			// Move our flanks towards their 'correct' position (This will happen both before and after any move)
; 718  : 			GridIndex tx,ty;
; 719  : 			tx = x + LeftFlankOffset[formation-GFORM_WEDGE][heading][0];		// Left flank
; 720  : 			ty = y + LeftFlankOffset[formation-GFORM_WEDGE][heading][1];
; 721  : 			ph = DirectionTo(lfx,lfy,tx,ty);
; 722  : 			lfx += dx[ph];
; 723  : 			lfy += dy[ph];
; 724  : 			tx = x + RightFlankOffset[formation-GFORM_WEDGE][heading][0];		// Right flank
; 725  : 			ty = y + RightFlankOffset[formation-GFORM_WEDGE][heading][1];
; 726  : 			ph = DirectionTo(rfx,rfy,tx,ty);
; 727  : 			rfx += dx[ph];
; 728  : 			rfy += dy[ph];
; 729  : 		}
; 730  : 		else if (formation == GFORM_DISPERSED){
; 731  : 			// Just move the flanks to within one of the unit
; 732  : 			if (DistSqu(x,y,lfx,lfy) > 1){
; 733  : 				ph = DirectionTo(lfx,lfy,x,y);
; 734  : 				lfx += dx[ph];
; 735  : 				lfy += dy[ph];
; 736  : 			}
; 737  : 			if (DistSqu(x,y,rfx,rfy) > 1){
; 738  : 				ph = DirectionTo(rfx,rfy,x,y);
; 739  : 				rfx += dx[ph];
; 740  : 				rfy += dy[ph];
; 741  : 			}
; 742  : 		}
; 743  : #endif
; 744  : 
; 745  : 		if (moving && ChangeUnitLocation(h)>0){

	cmp	DWORD PTR _moving$[ebp], 0
	je	SHORT $LN6@MoveUnit
	movzx	ecx, BYTE PTR _h$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeUnitLocation@UnitClass@@QAEHE@Z	; UnitClass::ChangeUnitLocation
	test	eax, eax
	jle	SHORT $LN6@MoveUnit

; 746  : 			SetUnitNextMove();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+912]
	call	edx

; 747  : 			GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 748  : 			// Store move in path history, in opposite order
; 749  : 			if (GetUnitMoved() > 20 && supply > 2){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitMoved@UnitClass@@QBEHXZ		; UnitClass::GetUnitMoved
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN5@MoveUnit
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+292]
	cmp	eax, 2
	jle	SHORT $LN5@MoveUnit

; 750  : 				// RV - Biker - Reduce supply at higher rate
; 751  : 				//supply--;
; 752  : 				supply -= 2;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+292]
	sub	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+292], dl

; 753  : 				//				fatigue++;
; 754  : 				SetUnitMoved(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitMoved@UnitClass@@QAEXE@Z	; UnitClass::SetUnitMoved
$LN5@MoveUnit:

; 755  : 			}
; 756  : 
; 757  : #ifdef USE_FLANKS
; 758  : 			if (formation == GFORM_COLUMN || formation == GFORM_OVERWATCH){
; 759  : 				int	i;
; 760  : 				// Update flank info - Left flank on unit, right flank 3 km behind
; 761  : 				lfx = rfx = x; lfy = rfy = y;
; 762  : 				for (i=1,ph=0; ph != Here; i++){
; 763  : 					ph = (GetPreviousDirection(i)+4)%8;
; 764  : 					if (ph != Here){
; 765  : 						rfx += dx[ph];
; 766  : 						rfy += dy[ph];
; 767  : 					}
; 768  : 				}
; 769  : 			}
; 770  : #endif // USE_FLANKS
; 771  : 
; 772  : #ifdef ROBIN_DEBUG
; 773  : #ifdef CAMPTOOL
; 774  : 			// Display what we're doing, if it's on..
; 775  : 			if (SHOWSTATS && Engaged() && TrackingOn[GetCampID()])
; 776  : #endif
; 777  : 				MonoPrint(" - Moved!");
; 778  : #endif
; 779  : 		}
; 780  : 		//RV - Biker - Use supply when not moving also
; 781  : 		else {

	jmp	SHORT $LN3@MoveUnit
$LN6@MoveUnit:

; 782  : 			moving = 0;

	mov	DWORD PTR _moving$[ebp], 0

; 783  : 			if (GetMoveTime() > 3*DEG_TO_SEC*SEC_TO_MSEC && supply > 2) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+644]
	call	eax
	cmp	eax, 10800000				; 00a4cb80H
	jbe	SHORT $LN3@MoveUnit
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+292]
	cmp	edx, 2
	jle	SHORT $LN3@MoveUnit

; 784  : 				supply -= 2;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+292]
	sub	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+292], cl
$LN3@MoveUnit:

; 785  : 			}
; 786  : 		}
; 787  : 	}

	jmp	$LN15@MoveUnit
$LN13@MoveUnit:

; 788  : 
; 789  : #ifdef ROBIN_DEBUG
; 790  : #ifdef CAMPTOOL
; 791  : 	// Display what we're doing, if it's on..
; 792  : 	if (SHOWSTATS && Engaged() && TrackingOn[GetCampID()])
; 793  : #endif
; 794  : 		MonoPrint("\n");
; 795  : #endif
; 796  : 
; 797  : 	// Check once again (after movement) if we've arrived at this waypoint, and increment wp pointer if so.
; 798  : 	if (w && x==nx && y==ny){

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN1@MoveUnit
	movsx	eax, WORD PTR _x$[ebp]
	movsx	ecx, WORD PTR _nx$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@MoveUnit
	movsx	edx, WORD PTR _y$[ebp]
	movsx	eax, WORD PTR _ny$[ebp]
	cmp	edx, eax
	jne	SHORT $LN1@MoveUnit

; 799  : 		FinishUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinishUnitWP@UnitClass@@QAEXXZ		; UnitClass::FinishUnitWP

; 800  : 		// Also set our last objective, if we're on one
; 801  : 		if (lo = GetObjectiveByXY(x,y)){

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?GetObjectiveByXY@@YAPAVObjectiveClass@@FF@Z ; GetObjectiveByXY
	add	esp, 8
	mov	DWORD PTR _lo$[ebp], eax
	cmp	DWORD PTR _lo$[ebp], 0
	je	SHORT $LN1@MoveUnit

; 802  : 			last_obj = lo->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+340], ecx
	mov	DWORD PTR [eax+344], edx
$LN1@MoveUnit:

; 803  : 		}
; 804  : 	}
; 805  : 
; 806  : #ifdef DEBUG_TIMING
; 807  : 	gBattalionMoves++;
; 808  : 	gAverageBattalionMoveTime = (gAverageBattalionMoveTime*(gBattalionMoves-1) + GetTickCount() - timec) / gBattalionMoves;
; 809  : #endif
; 810  : 
; 811  : 	return 0;

	mov	DWORD PTR $T12[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp_path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T12[ebp]
$LN69@MoveUnit:

; 812  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MoveUnit@BattalionClass@@UAEHK@Z$0:
	lea	ecx, DWORD PTR _temp_path$[ebp]
	jmp	??1PathClass@@QAE@XZ
__ehhandler$?MoveUnit@BattalionClass@@UAEHK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MoveUnit@BattalionClass@@UAEHK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveUnit@BattalionClass@@UAEHK@Z ENDP			; BattalionClass::MoveUnit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fs$ = 8						; size = 1
?SetFullStrength@BattalionClass@@QAEXE@Z PROC		; BattalionClass::SetFullStrength
; _this$ = ecx

; 2146 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2147 : 	fullstrength = fs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _fs$[ebp]
	mov	BYTE PTR [eax+297], cl

; 2148 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFullStrength@BattalionClass@@QAEXE@Z ENDP		; BattalionClass::SetFullStrength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?IsBattalion@BattalionClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBattalion@BattalionClass@@UAEHXZ PROC		; BattalionClass::IsBattalion, COMDAT
; _this$ = ecx

; 72   : 	virtual int IsBattalion (void)						{ return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBattalion@BattalionClass@@UAEHXZ ENDP		; BattalionClass::IsBattalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_tmp_ent$ = -8						; size = 4
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@BattalionClass@@UAEHPAVVuFullUpdateEvent@@@Z PROC ; BattalionClass::Handle
; _this$ = ecx

; 398  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 399  : 	// copy data from temp entity to current entity
; 400  : 	BattalionClass* tmp_ent = (BattalionClass*)(event->expandedData_.get());

	mov	ecx, DWORD PTR _event$[ebp]
	add	ecx, 48					; 00000030H
	call	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ; VuBin<VuEntity>::get
	mov	DWORD PTR _tmp_ent$[ebp], eax

; 401  : 
; 402  : 	last_move = tmp_ent->last_move;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	edx, DWORD PTR [ecx+324]
	mov	DWORD PTR [eax+324], edx

; 403  : 	last_combat = tmp_ent->last_combat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR [eax+328], edx

; 404  : #ifdef USE_FLANKS
; 405  : 	lfx = tmp_ent->lfx;
; 406  : 	lfy = tmp_ent->lfy;
; 407  : 	rfx = tmp_ent->rfx;
; 408  : 	rfy = tmp_ent->rfy;
; 409  : #endif
; 410  : 	supply = tmp_ent->supply;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+292]
	mov	BYTE PTR [eax+292], dl

; 411  : 	fatigue = tmp_ent->fatigue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+293]
	mov	BYTE PTR [eax+293], dl

; 412  : 	morale = tmp_ent->morale;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+294]
	mov	BYTE PTR [eax+294], dl

; 413  : 	heading = tmp_ent->heading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+296]
	mov	BYTE PTR [eax+296], dl

; 414  : 	final_heading = tmp_ent->final_heading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+295]
	mov	BYTE PTR [eax+295], dl

; 415  : 	//	element = tmp_ent->element;
; 416  : 	position = tmp_ent->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	mov	dl, BYTE PTR [ecx+299]
	mov	BYTE PTR [eax+299], dl

; 417  : 	return (GroundUnitClass::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@GroundUnitClass@@UAEHPAVVuFullUpdateEvent@@@Z ; GroundUnitClass::Handle

; 418  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@BattalionClass@@UAEHPAVVuFullUpdateEvent@@@Z ENDP ; BattalionClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_stream$ = 8						; size = 4
?Save@BattalionClass@@UAEHPAPAE@Z PROC			; BattalionClass::Save
; _this$ = ecx

; 353  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 	GroundUnitClass::Save(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Save@GroundUnitClass@@UAEHPAPAE@Z	; GroundUnitClass::Save

; 355  : 	if (save_log)

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN1@Save

; 356  : 	{
; 357  : 		fprintf (save_log, "%08x BattalionClass ", *stream - start_save_stream);

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR ?start_save_stream@@3HA	; start_save_stream
	push	edx
	push	OFFSET ??_C@_0BF@NPAMKIGD@?$CF08x?5BattalionClass?5?$AA@
	mov	eax, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 358  : 		fflush (save_log);

	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fflush
	add	esp, 4
$LN1@Save:

; 359  : 	}
; 360  : 
; 361  : 	memcpy(*stream, &last_move, sizeof(CampaignTime));		*stream += sizeof(CampaignTime);

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 324				; 00000144H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 362  : 	memcpy(*stream, &last_combat, sizeof(CampaignTime));	*stream += sizeof(CampaignTime);

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 328				; 00000148H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 363  : #ifdef CAMPTOOL
; 364  : 	if (gRenameIds)
; 365  : 		parent_id.num_ = RenameTable[parent_id.num_];
; 366  : #endif
; 367  : 	memcpy(*stream, &parent_id, sizeof(VU_ID));				*stream += sizeof(VU_ID);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 332				; 0000014cH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 368  : #ifdef CAMPTOOL
; 369  : 	if (gRenameIds)
; 370  : 		last_obj.num_ = RenameTable[last_obj.num_];
; 371  : #endif
; 372  : 	memcpy(*stream, &last_obj, sizeof(VU_ID));				*stream += sizeof(VU_ID);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 340				; 00000154H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 373  : #ifdef USE_FLANKS
; 374  : 	memcpy(*stream, &lfx, sizeof(GridIndex));				*stream += sizeof(GridIndex);
; 375  : 	memcpy(*stream, &lfy, sizeof(GridIndex));				*stream += sizeof(GridIndex);
; 376  : 	memcpy(*stream, &rfx, sizeof(GridIndex));				*stream += sizeof(GridIndex);
; 377  : 	memcpy(*stream, &rfy, sizeof(GridIndex));				*stream += sizeof(GridIndex);
; 378  : #endif
; 379  : 	memcpy(*stream, &supply, sizeof(Percentage));			*stream += sizeof(Percentage);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 292				; 00000124H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 380  : 	memcpy(*stream, &fatigue, sizeof(Percentage));			*stream += sizeof(Percentage);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 293				; 00000125H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 381  : 	memcpy(*stream, &morale, sizeof(Percentage));			*stream += sizeof(Percentage);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 294				; 00000126H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 382  : 	// sfr: added path
; 383  : 	//	path->Save(stream);
; 384  : 	//	memcpy(*stream, &pathHist, sizeof(pathtype));			*stream += sizeof(pathtype);
; 385  : 	memcpy(*stream, &heading, sizeof(uchar));				*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 386  : 	memcpy(*stream, &final_heading, sizeof(uchar));			*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 295				; 00000127H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 387  : 	//	memcpy(*stream, &element, sizeof(uchar));				*stream += sizeof(uchar);
; 388  : 	memcpy(*stream, &position, sizeof(uchar));				*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 299				; 0000012bH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 389  : 	return SaveSize();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx

; 390  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Save@BattalionClass@@UAEHPAPAE@Z ENDP			; BattalionClass::Save
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SaveSize@BattalionClass@@UAEHXZ PROC			; BattalionClass::SaveSize
; _this$ = ecx

; 326  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 327  : 	return GroundUnitClass::SaveSize() 
; 328  : 		+ sizeof(CampaignTime)
; 329  : 		+ sizeof(CampaignTime)
; 330  : 		+ sizeof(VU_ID)
; 331  : 		+ sizeof(VU_ID)
; 332  : #ifdef USE_FLANKS
; 333  : 		+ sizeof(GridIndex)
; 334  : 		+ sizeof(GridIndex)
; 335  : 		+ sizeof(GridIndex)
; 336  : 		+ sizeof(GridIndex)
; 337  : #endif
; 338  : 		+ sizeof(Percentage)
; 339  : 		+ sizeof(Percentage)
; 340  : 		+ sizeof(Percentage)
; 341  : 		//sfr: added path
; 342  : 		//+ path->SaveSize();
; 343  : 		+ sizeof(uchar)
; 344  : 		+ sizeof(uchar)
; 345  : 		+ sizeof(uchar);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveSize@GroundUnitClass@@UAEHXZ	; GroundUnitClass::SaveSize
	add	eax, 30					; 0000001eH

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveSize@BattalionClass@@UAEHXZ ENDP			; BattalionClass::SaveSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv191 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z PROC ; BattalionClass::InitLocalData
; _this$ = ecx

; 272  : void BattalionClass::InitLocalData(Unit parent){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 273  : #ifdef USE_FLANKS
; 274  : 	lfx = lfy = rfx = rfy = 0;				// KCK hack.. should be set to starting location (which is unknown here)
; 275  : #endif
; 276  : 	supply = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+292], 100			; 00000064H

; 277  : 	last_move = 0;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], 0

; 278  : 	last_combat = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 0

; 279  : 	SetSpottedTime (0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpottedTime@CampBaseClass@@QAEXK@Z	; CampBaseClass::SetSpottedTime

; 280  : 	fatigue = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+293], 0

; 281  : 	morale = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+294], 100			; 00000064H

; 282  : 	//	element = 0;
; 283  : 	position = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+299], 0

; 284  : 	fullstrength = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+297], 0

; 285  : 	// Marco Edit - originally wasn't set
; 286  : 	SetRadarMode(FEC_RADAR_OFF);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 287  : 	// End Marco Edit
; 288  : 
; 289  : 	if(parent){

	cmp	DWORD PTR _parent$[ebp], 0
	je	SHORT $LN4@InitLocalD

; 290  : 		SetReinforcement (parent->GetReinforcement());

	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetReinforcement@UnitClass@@QAEFXZ	; UnitClass::GetReinforcement
	movzx	ecx, ax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetReinforcement@UnitClass@@QAEXF@Z	; UnitClass::SetReinforcement

; 291  : 		// Inherit parent's inactive status;
; 292  : 		SetUnitFlags (parent->GetUnitFlags () & U_INACTIVE);

	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetUnitFlags@UnitClass@@QAEJXZ		; UnitClass::GetUnitFlags
	and	eax, 131072				; 00020000H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitFlags@UnitClass@@QAEXJ@Z	; UnitClass::SetUnitFlags

; 293  : 	}
; 294  : 	else {

	jmp	SHORT $LN3@InitLocalD
$LN4@InitLocalD:

; 295  : 		SetReinforcement (0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetReinforcement@UnitClass@@QAEXF@Z	; UnitClass::SetReinforcement
$LN3@InitLocalD:

; 296  : 	}
; 297  : 
; 298  : 	dirty_battalion = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+316], 0

; 299  : 	last_obj = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+340], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+344], edx

; 300  : 	heading = final_heading = North;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+295], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+296], 0

; 301  : 	deag_data = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], 0

; 302  : 
; 303  : 	if (parent){

	cmp	DWORD PTR _parent$[ebp], 0
	je	SHORT $LN2@InitLocalD

; 304  : 		SetUnitParent(parent);

	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+952]
	call	eax

; 305  : 		parent->AddUnitChild(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [eax+972]
	call	edx

; 306  : 		SetParent(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@UnitClass@@QAEXH@Z		; UnitClass::SetParent

; 307  : 	}
; 308  : 	else{

	jmp	SHORT $LN1@InitLocalD
$LN2@InitLocalD:

; 309  : 		parent_id = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+332], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+336], edx

; 310  : 		SetParent(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@UnitClass@@QAEXH@Z		; UnitClass::SetParent
$LN1@InitLocalD:

; 311  : 	}
; 312  : 	air_target = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+348], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+352], edx

; 313  : 	search_mode = FEC_RADAR_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+300], 0

; 314  : 	step_search_mode = FEC_RADAR_OFF; // 2002-03-22 ADDED BY S.G. Our radar step search mode var needs to be set as well

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+312], 0

; 315  : 	radar_mode = FEC_RADAR_OFF; // jpo init

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+298], 0

; 316  : 	missiles_flying = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+301], 0

; 317  : 	SEARCHtimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 0

; 318  : 	AQUIREtimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+308], 0

; 319  : 	//sfr: path
; 320  : 	path = new SmallPathClass();

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@InitLocalD
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0SmallPathClass@@QAE@XZ		; SmallPathClass::SmallPathClass
	mov	DWORD PTR tv191[ebp], eax
	jmp	SHORT $LN8@InitLocalD
$LN7@InitLocalD:
	mov	DWORD PTR tv191[ebp], 0
$LN8@InitLocalD:
	mov	eax, DWORD PTR tv191[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+356], edx

; 321  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z ENDP ; BattalionClass::InitLocalData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitData@BattalionClass@@UAEXXZ PROC			; BattalionClass::InitData
; _this$ = ecx

; 267  : void BattalionClass::InitData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 268  : 	GroundUnitClass::InitData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitData@CampBaseClass@@UAEXXZ		; CampBaseClass::InitData

; 269  : 	InitLocalData(GetUnitParent());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z ; BattalionClass::InitLocalData

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitData@BattalionClass@@UAEXXZ ENDP			; BattalionClass::InitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv134 = -40						; size = 4
$T2 = -36						; size = 4
tv93 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1BattalionClass@@UAE@XZ PROC				; BattalionClass::~BattalionClass
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1BattalionClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BattalionClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 252  : 	if (IsAwake()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN3@BattalionC

; 253  : 		Sleep();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Sleep@UnitClass@@UAEHXZ		; UnitClass::Sleep
$LN3@BattalionC:

; 254  : 	}
; 255  : 
; 256  : 	if (deag_data){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+360], 0
	je	SHORT $LN2@BattalionC

; 257  : 		delete deag_data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+360]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN6@BattalionC
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GUnitDeaggregationData@@QAEPAXI@Z
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN7@BattalionC
$LN6@BattalionC:
	mov	DWORD PTR tv93[ebp], 0
$LN7@BattalionC:

; 258  : 		deag_data = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], 0
$LN2@BattalionC:

; 259  : 	}
; 260  : 
; 261  : 	if (path != NULL){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+356], 0
	je	SHORT $LN4@BattalionC

; 262  : 		delete path;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN8@BattalionC
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GSmallPathClass@@QAEPAXI@Z
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN9@BattalionC
$LN8@BattalionC:
	mov	DWORD PTR tv134[ebp], 0
$LN9@BattalionC:

; 263  : 		path = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], 0
$LN4@BattalionC:

; 264  : 	}
; 265  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1GroundUnitClass@@UAE@XZ		; GroundUnitClass::~GroundUnitClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1BattalionClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GroundUnitClass@@UAE@XZ		; GroundUnitClass::~GroundUnitClass
__ehhandler$??1BattalionClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1BattalionClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1BattalionClass@@UAE@XZ ENDP				; BattalionClass::~BattalionClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
tv232 = -48						; size = 4
_pd$ = -44						; size = 4
_o$ = -40						; size = 4
_this$ = -36						; size = 4
_x$ = -32						; size = 2
_y$ = -28						; size = 2
_nx$ = -24						; size = 2
_ny$ = -20						; size = 2
_dummy$2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
??0BattalionClass@@QAE@PAPAEPAJ@Z PROC			; BattalionClass::BattalionClass
; _this$ = ecx

; 163  : BattalionClass::BattalionClass(VU_BYTE **stream, long *rem) : GroundUnitClass(stream, rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BattalionClass@@QAE@PAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0GroundUnitClass@@QAE@PAPAEPAJ@Z	; GroundUnitClass::GroundUnitClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7BattalionClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 164  : 	InitLocalData(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z ; BattalionClass::InitLocalData

; 165  : 
; 166  : 	memcpychk(&last_move, stream, sizeof(CampaignTime), rem);		

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 324				; 00000144H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 167  : 	memcpychk(&last_combat, stream, sizeof(CampaignTime), rem);	

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 328				; 00000148H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 168  : 	memcpychk(&parent_id, stream, sizeof(VU_ID), rem);				

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 332				; 0000014cH
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 169  : 	memcpychk(&last_obj, stream, sizeof(VU_ID), rem);				

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 340				; 00000154H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 170  : #ifdef USE_FLANKS
; 171  : 	memcpychk(&lfx, stream, sizeof(GridIndex), rem);	
; 172  : 	memcpychk(&lfy, stream, sizeof(GridIndex), rem);				
; 173  : 	memcpychk(&rfx, stream, sizeof(GridIndex), rem);				
; 174  : 	memcpychk(&rfy, stream, sizeof(GridIndex), rem);				
; 175  : #endif
; 176  : 	memcpychk(&supply, stream, sizeof(Percentage), rem);			

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 292				; 00000124H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 177  : 	memcpychk(&fatigue, stream, sizeof(Percentage), rem);			

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 293				; 00000125H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 178  : 	memcpychk(&morale, stream, sizeof(Percentage), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 294				; 00000126H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 179  : 
; 180  : 	memcpychk(&heading, stream, sizeof(uchar), rem);				

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 181  : 	memcpychk(&final_heading, stream, sizeof(uchar), rem);			

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 295				; 00000127H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 182  : 	if (gCampDataVersion < 15){

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 15	; gCampDataVersion, 0000000fH
	jge	SHORT $LN7@BattalionC

; 183  : 		uchar	dummy;
; 184  : 		memcpychk(&dummy, stream, sizeof(uchar), rem);				

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dummy$2[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN7@BattalionC:

; 185  : 	}
; 186  : 	memcpychk(&position, stream, sizeof(uchar), rem);				

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 299				; 0000012bH
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 187  : 	fullstrength = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+297], 0

; 188  : 
; 189  : 	dirty_battalion = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], 0

; 190  : #ifdef DEBUG
; 191  : #ifdef USE_FLANKS
; 192  : 	// Flank sanity check
; 193  : 	GridIndex	x,y;
; 194  : 	CampBaseClass::GetLocation(&x,&y);	
; 195  : 	if (rfx - x > 5 || rfx - x < -5)		// 5 km for right flank
; 196  : 		rfx = x;
; 197  : 	if (rfy = y > 5 || rfy - y < -5)
; 198  : 		rfy = y;
; 199  : 	if (lfx - x > 2 || lfx - x < -2)		// Only 2 for left - since we don't use this for column
; 200  : 		lfx = x;
; 201  : 	if (lfy = y > 2 || lfy - y < -2)
; 202  : 		lfy = y;
; 203  : #endif
; 204  : #endif
; 205  : 
; 206  : 	deag_data = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], 0

; 207  : 	// KCK Temporary
; 208  : 	if (last_move > Camp_GetCurrentTime()){

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+324], eax
	jbe	SHORT $LN6@BattalionC

; 209  : 		last_move = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], eax
$LN6@BattalionC:

; 210  : 	}
; 211  : 	if (GetLastCheck() > Camp_GetCurrentTime()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	mov	esi, eax
	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	cmp	esi, eax
	jbe	SHORT $LN5@BattalionC

; 212  : 		SetLastCheck (Camp_GetCurrentTime());

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck
$LN5@BattalionC:

; 213  : 	}
; 214  : 	if (last_combat > Camp_GetCurrentTime()){

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], eax
	jbe	SHORT $LN4@BattalionC

; 215  : 		last_combat = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], eax
$LN4@BattalionC:

; 216  : 	}
; 217  : 
; 218  : 	// KCK: Move this to somewhere load-only
; 219  : 	// We need to add this battalion's vehicles to its primary objective's assigned rating,
; 220  : 	// so we keep our scoring system valid after a load.
; 221  : 	POData		pd;
; 222  : 	Objective	o;
; 223  : 	o = UnitClass::GetUnitPrimaryObj();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ; UnitClass::GetUnitPrimaryObj
	mov	DWORD PTR _o$[ebp], eax

; 224  : 	if (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN3@BattalionC

; 225  : 		if (pd = GetPOData(o)){

	mov	eax, DWORD PTR _o$[ebp]
	push	eax
	call	?GetPOData@@YAPAUPrimaryObjectiveData@@PAVObjectiveClass@@@Z ; GetPOData
	add	esp, 4
	mov	DWORD PTR _pd$[ebp], eax
	cmp	DWORD PTR _pd$[ebp], 0
	je	SHORT $LN3@BattalionC

; 226  : 			pd->ground_assigned[GetTeam()] += GetTotalVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeam@CampBaseClass@@UAEEXZ		; CampBaseClass::GetTeam
	movzx	ecx, al
	mov	edx, DWORD PTR _pd$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+24]
	mov	DWORD PTR tv232[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	ecx, DWORD PTR tv232[ebp]
	movsx	edx, WORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR tv232[ebp]
	mov	WORD PTR [eax], dx
$LN3@BattalionC:

; 227  : 		}
; 228  : 	}
; 229  : 
; 230  : 
; 231  : 	air_target = FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+348], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+352], eax

; 232  : 	search_mode = FEC_RADAR_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+300], 0

; 233  : 	step_search_mode = FEC_RADAR_OFF; // 2002-03-22 ADDED BY S.G. Our radar step search mode var needs to be set as well

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+312], 0

; 234  : 	radar_mode = FEC_RADAR_OFF; // JPO init

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+298], 0

; 235  : 	missiles_flying = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+301], 0

; 236  : 	SEARCHtimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], 0

; 237  : 	AQUIREtimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+308], 0

; 238  : 
; 239  : 	//sfr: path stuff
; 240  : 	// path is not serialized, so we must construct it here
; 241  : 	short x, y, nx, ny;
; 242  : 	GetLocation(&x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 243  : 	GetUnitDestination(&nx, &ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 244  : 	if ((x != nx) && (y != ny)){

	movsx	edx, WORD PTR _x$[ebp]
	movsx	eax, WORD PTR _nx$[ebp]
	cmp	edx, eax
	je	SHORT $LN8@BattalionC
	movsx	ecx, WORD PTR _y$[ebp]
	movsx	edx, WORD PTR _ny$[ebp]
	cmp	ecx, edx
	je	SHORT $LN8@BattalionC

; 245  : 		GetUnitGridPath(path,x,y,nx,ny);

	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath

; 246  : 		SetMoving(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoving@UnitClass@@QAEXH@Z		; UnitClass::SetMoving
$LN8@BattalionC:

; 247  : 	}
; 248  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0BattalionClass@@QAE@PAPAEPAJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GroundUnitClass@@UAE@XZ		; GroundUnitClass::~GroundUnitClass
__ehhandler$??0BattalionClass@@QAE@PAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BattalionClass@@QAE@PAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BattalionClass@@QAE@PAPAEPAJ@Z ENDP			; BattalionClass::BattalionClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\battalio.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 2
_parent$ = 12						; size = 4
??0BattalionClass@@QAE@GPAVUnitClass@@@Z PROC		; BattalionClass::BattalionClass
; _this$ = ecx

; 159  : : GroundUnitClass(type, GetIdFromNamespace(NonVolatileNS)){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BattalionClass@@QAE@GPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ?NonVolatileNS@@3VIdNamespace@@A	; NonVolatileNS
	call	?GetIdFromNamespace@@YAKAAVIdNamespace@@@Z ; GetIdFromNamespace
	add	esp, 4
	push	eax
	movzx	eax, WORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0GroundUnitClass@@QAE@GK@Z		; GroundUnitClass::GroundUnitClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BattalionClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 160  : 	InitLocalData(parent);

	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@BattalionClass@@AAEXPAVUnitClass@@@Z ; BattalionClass::InitLocalData

; 161  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0BattalionClass@@QAE@GPAVUnitClass@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GroundUnitClass@@UAE@XZ		; GroundUnitClass::~GroundUnitClass
__ehhandler$??0BattalionClass@@QAE@GPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BattalionClass@@QAE@GPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BattalionClass@@QAE@GPAVUnitClass@@@Z ENDP		; BattalionClass::BattalionClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ PROC ; GroundUnitClass::GetUnitObjectiveID, COMDAT
; _this$ = ecx

; 148  : 	VU_ID GetUnitObjectiveID (void)					{ return aobj; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [eax+284]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitObjectiveID@GroundUnitClass@@UAE?AVVU_ID@@XZ ENDP ; GroundUnitClass::GetUnitObjectiveID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ PROC ; GroundUnitClass::GetUnitSecondaryObjID, COMDAT
; _this$ = ecx

; 147  : 	VU_ID GetUnitSecondaryObjID (void)				{ return sobj; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	edx, DWORD PTR [eax+276]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSecondaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ENDP ; GroundUnitClass::GetUnitSecondaryObjID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ PROC ; GroundUnitClass::GetUnitPrimaryObjID, COMDAT
; _this$ = ecx

; 146  : 	VU_ID GetUnitPrimaryObjID (void)				{ return pobj; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	edx, DWORD PTR [eax+268]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitPrimaryObjID@GroundUnitClass@@UAE?AVVU_ID@@XZ ENDP ; GroundUnitClass::GetUnitPrimaryObjID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ PROC ; GroundUnitClass::GetUnitObjective, COMDAT
; _this$ = ecx

; 145  : 	Objective GetUnitObjective (void)				{ return (Objective)vuDatabase->Find(aobj); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	push	ecx
	mov	edx, DWORD PTR [eax+280]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitObjective@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; GroundUnitClass::GetUnitObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ PROC ; GroundUnitClass::GetUnitSecondaryObj, COMDAT
; _this$ = ecx

; 144  : 	Objective GetUnitSecondaryObj (void)			{ return (Objective)vuDatabase->Find(sobj); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	mov	edx, DWORD PTR [eax+272]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSecondaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; GroundUnitClass::GetUnitSecondaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ PROC ; GroundUnitClass::GetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 143  : 	Objective GetUnitPrimaryObj (void)				{ return (Objective)vuDatabase->Find(pobj); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	mov	edx, DWORD PTR [eax+264]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPrimaryObj@GroundUnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; GroundUnitClass::GetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitDivision@GroundUnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitDivision@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::GetUnitDivision, COMDAT
; _this$ = ecx

; 142  : 	virtual int GetUnitDivision (void)				{ return (int)division; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+262]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitDivision@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::GetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetUnitOrders@GroundUnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitOrders@GroundUnitClass@@UAEHXZ PROC		; GroundUnitClass::GetUnitOrders, COMDAT
; _this$ = ecx

; 141  : 	virtual int GetUnitOrders (void)				{ return (int)orders; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+260]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitOrders@GroundUnitClass@@UAEHXZ ENDP		; GroundUnitClass::GetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z PROC	; GroundUnitClass::SetUnitObjective, COMDAT
; _this$ = ecx

; 140  : 	void SetUnitObjective (VU_ID id)				{ aobj = id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+280], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+284], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitObjective@GroundUnitClass@@UAEXVVU_ID@@@Z ENDP	; GroundUnitClass::SetUnitObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z PROC ; GroundUnitClass::SetUnitSecondaryObj, COMDAT
; _this$ = ecx

; 139  : 	void SetUnitSecondaryObj (VU_ID id)				{ sobj = id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+272], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+276], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitSecondaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ENDP ; GroundUnitClass::SetUnitSecondaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 8
?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z PROC	; GroundUnitClass::SetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 138  : 	void SetUnitPrimaryObj (VU_ID id)				{ pobj = id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+264], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+268], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitPrimaryObj@GroundUnitClass@@UAEXVVU_ID@@@Z ENDP	; GroundUnitClass::SetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitDivision@GroundUnitClass@@UAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_d$ = 8							; size = 2
?SetUnitDivision@GroundUnitClass@@UAEXF@Z PROC		; GroundUnitClass::SetUnitDivision, COMDAT
; _this$ = ecx

; 137  : 	virtual void SetUnitDivision (short d)			{ division = d; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _d$[ebp]
	mov	WORD PTR [eax+262], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitDivision@GroundUnitClass@@UAEXF@Z ENDP		; GroundUnitClass::SetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?SetUnitOrders@GroundUnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_o$ = 8							; size = 1
?SetUnitOrders@GroundUnitClass@@UAEXE@Z PROC		; GroundUnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 136  : 	virtual void SetUnitOrders (uchar o)			{ orders = o; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _o$[ebp]
	mov	BYTE PTR [eax+260], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitOrders@GroundUnitClass@@UAEXE@Z ENDP		; GroundUnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetOrders@GroundUnitClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOrders@GroundUnitClass@@QAEEXZ PROC			; GroundUnitClass::GetOrders, COMDAT
; _this$ = ecx

; 124  : 	uchar GetOrders (void) { return orders; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+260]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOrders@GroundUnitClass@@QAEEXZ ENDP			; GroundUnitClass::GetOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetKias@GroundUnitClass@@UBEMXZ
_TEXT	SEGMENT
tv82 = -12						; size = 4
tv80 = -8						; size = 4
_this$ = -4						; size = 4
?GetKias@GroundUnitClass@@UBEMXZ PROC			; GroundUnitClass::GetKias, COMDAT
; _this$ = ecx

; 121  :     virtual float GetKias() const					{ return GetVt()*FTPSEC_TO_KNOTS; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv80[ebp]
	movss	xmm0, DWORD PTR tv80[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	movss	DWORD PTR tv82[ebp], xmm0
	fld	DWORD PTR tv82[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKias@GroundUnitClass@@UBEMXZ ENDP			; GroundUnitClass::GetKias
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?GetVt@GroundUnitClass@@UBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
?GetVt@GroundUnitClass@@UBEMXZ PROC			; GroundUnitClass::GetVt, COMDAT
; _this$ = ecx

; 120  :     virtual float GetVt() const						{ return (Moving() ? 40.0F : 0.0F);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN3@GetVt
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR tv71[ebp], xmm0
	jmp	SHORT $LN4@GetVt
$LN3@GetVt:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv71[ebp], xmm0
$LN4@GetVt:
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVt@GroundUnitClass@@UBEMXZ ENDP			; GroundUnitClass::GetVt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\gndunit.h
;	COMDAT ?OnGround@GroundUnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnGround@GroundUnitClass@@UAEHXZ PROC			; GroundUnitClass::OnGround, COMDAT
; _this$ = ecx

; 119  :     virtual int OnGround (void)						{ return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGround@GroundUnitClass@@UAEHXZ ENDP			; GroundUnitClass::OnGround
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ PROC ; TeamClass::GetGroundAction, COMDAT
; _this$ = ecx

; 277  : 	TeamGndActionType *GetGroundAction (void) { return &groundAction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ENDP ; TeamClass::GetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUnitDeaggregationData@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GUnitDeaggregationData@@QAEPAXI@Z PROC		; UnitDeaggregationData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UnitDeaggregationData@@QAE@XZ	; UnitDeaggregationData::~UnitDeaggregationData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GUnitDeaggregationData@@QAEPAXI@Z ENDP		; UnitDeaggregationData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?UpdateParentStatistics@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateParentStatistics@UnitClass@@UAEHXZ PROC		; UnitClass::UpdateParentStatistics, COMDAT
; _this$ = ecx

; 559  : 	virtual int UpdateParentStatistics (void)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateParentStatistics@UnitClass@@UAEHXZ ENDP		; UnitClass::UpdateParentStatistics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ReorganizeUnit@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReorganizeUnit@UnitClass@@UAEXXZ PROC			; UnitClass::ReorganizeUnit, COMDAT
; _this$ = ecx

; 558  : 	virtual void ReorganizeUnit (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReorganizeUnit@UnitClass@@UAEXXZ ENDP			; UnitClass::ReorganizeUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::RemoveChild, COMDAT
; _this$ = ecx

; 557  : 	virtual void RemoveChild (VU_ID)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::RemoveChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DisposeChildren@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisposeChildren@UnitClass@@UAEXXZ PROC			; UnitClass::DisposeChildren, COMDAT
; _this$ = ecx

; 556  : 	virtual void DisposeChildren (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisposeChildren@UnitClass@@UAEXXZ ENDP			; UnitClass::DisposeChildren
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?AddUnitChild@UnitClass@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?AddUnitChild@UnitClass@@UAEXPAV1@@Z PROC		; UnitClass::AddUnitChild, COMDAT
; _this$ = ecx

; 555  : 	virtual void AddUnitChild (Unit)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddUnitChild@UnitClass@@UAEXPAV1@@Z ENDP		; UnitClass::AddUnitChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z PROC	; UnitClass::GetPrevUnitElement, COMDAT
; _this$ = ecx

; 554  : 	virtual Unit GetPrevUnitElement (Unit)						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z ENDP	; UnitClass::GetPrevUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z PROC		; UnitClass::GetUnitElementByID, COMDAT
; _this$ = ecx

; 553  : 	virtual Unit GetUnitElementByID (int)						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z ENDP		; UnitClass::GetUnitElementByID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElement@UnitClass@@UAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitElement@UnitClass@@UAEPAV1@H@Z PROC		; UnitClass::GetUnitElement, COMDAT
; _this$ = ecx

; 552  : 	virtual Unit GetUnitElement (int)							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitElement@UnitClass@@UAEPAV1@H@Z ENDP		; UnitClass::GetUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNextUnitElement@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextUnitElement@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetNextUnitElement, COMDAT
; _this$ = ecx

; 551  : 	virtual Unit GetNextUnitElement() const						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextUnitElement@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetNextUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetFirstUnitElement, COMDAT
; _this$ = ecx

; 550  : 	virtual Unit GetFirstUnitElement() const					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetFirstUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z PROC	; UnitClass::GetUnitCurrentDestination, COMDAT
; _this$ = ecx

; 534  : 	virtual void GetUnitCurrentDestination(GridIndex*, GridIndex*)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z ENDP	; UnitClass::GetUnitCurrentDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 2
___formal$ = 12						; size = 2
?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z PROC	; UnitClass::SetUnitCurrentDestination, COMDAT
; _this$ = ecx

; 533  : 	virtual void SetUnitCurrentDestination(GridIndex, GridIndex)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z ENDP	; UnitClass::SetUnitCurrentDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMode@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMode@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitMode, COMDAT
; _this$ = ecx

; 526  : 	virtual int GetUnitMode (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMode@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ PROC ; UnitClass::GetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 517  : 	virtual Objective GetUnitPrimaryObj (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; UnitClass::GetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitHeading@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitHeading@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitHeading, COMDAT
; _this$ = ecx

; 516  : 	virtual void SetUnitHeading (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitHeading@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitDivision@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitDivision@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitDivision, COMDAT
; _this$ = ecx

; 515  : 	virtual void SetUnitDivision (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitDivision@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPosition@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitPosition@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitPosition, COMDAT
; _this$ = ecx

; 514  : 	virtual void SetUnitPosition (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPosition@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMode@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMode@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitMode, COMDAT
; _this$ = ecx

; 513  : 	virtual void SetUnitMode (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMode@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitOrders@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitOrders@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 509  : 	virtual void SetUnitOrders (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitOrders@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z PROC	; UnitClass::GetUnitAssemblyPoint, COMDAT
; _this$ = ecx

; 503  : 	virtual void GetUnitAssemblyPoint (int, GridIndex*, GridIndex*)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z ENDP	; UnitClass::GetUnitAssemblyPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 2
?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z PROC		; UnitClass::SetUnitAssemblyPoint, COMDAT
; _this$ = ecx

; 502  : 	virtual void SetUnitAssemblyPoint (int, GridIndex, GridIndex)		{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z ENDP		; UnitClass::SetUnitAssemblyPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z PROC ; UnitClass::BuildPackage, COMDAT
; _this$ = ecx

; 500  : 	virtual int BuildPackage(MissionRequest, F4PFList)	{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z ENDP ; UnitClass::BuildPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastResupply@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastResupply@UnitClass@@UAEHXZ PROC			; UnitClass::GetLastResupply, COMDAT
; _this$ = ecx

; 497  : 	virtual int GetLastResupply (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastResupply@UnitClass@@UAEHXZ ENDP			; UnitClass::GetLastResupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitStores@UnitClass@@UAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitStores@UnitClass@@UAEEH@Z PROC			; UnitClass::GetUnitStores, COMDAT
; _this$ = ecx

; 495  : 	virtual uchar GetUnitStores (int)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitStores@UnitClass@@UAEEH@Z ENDP			; UnitClass::GetUnitStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetSquadronFuel@UnitClass@@UAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSquadronFuel@UnitClass@@UAEJXZ PROC			; UnitClass::GetSquadronFuel, COMDAT
; _this$ = ecx

; 494  : 	virtual long GetSquadronFuel (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSquadronFuel@UnitClass@@UAEJXZ ENDP			; UnitClass::GetSquadronFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSpecialty@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSpecialty@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitSpecialty, COMDAT
; _this$ = ecx

; 491  : 	virtual int GetUnitSpecialty (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSpecialty@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitSpecialty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLastResupply@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLastResupply@UnitClass@@UAEXH@Z PROC		; UnitClass::SetLastResupply, COMDAT
; _this$ = ecx

; 489  : 	virtual void SetLastResupply (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastResupply@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetLastResupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitStores@UnitClass@@UAEXHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
?SetUnitStores@UnitClass@@UAEXHE@Z PROC			; UnitClass::SetUnitStores, COMDAT
; _this$ = ecx

; 488  : 	virtual void SetUnitStores (int, uchar)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitStores@UnitClass@@UAEXHE@Z ENDP			; UnitClass::SetUnitStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetSquadronFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetSquadronFuel@UnitClass@@UAEXJ@Z PROC		; UnitClass::SetSquadronFuel, COMDAT
; _this$ = ecx

; 487  : 	virtual void SetSquadronFuel (long)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSquadronFuel@UnitClass@@UAEXJ@Z ENDP		; UnitClass::SetSquadronFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSpecialty@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitSpecialty@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitSpecialty, COMDAT
; _this$ = ecx

; 484  : 	virtual void SetUnitSpecialty (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSpecialty@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitSpecialty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?UseFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?UseFuel@UnitClass@@UAEXJ@Z PROC			; UnitClass::UseFuel, COMDAT
; _this$ = ecx

; 481  : 	virtual void UseFuel (long)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?UseFuel@UnitClass@@UAEXJ@Z ENDP			; UnitClass::UseFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z PROC ; UnitClass::BuildMission, COMDAT
; _this$ = ecx

; 479  : 	virtual int BuildMission(MissionRequestClass*)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z ENDP ; UnitClass::BuildMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ PROC ; UnitClass::GetKnownEmitters, COMDAT
; _this$ = ecx

; 478  : 	virtual F4PFList GetKnownEmitters (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ ENDP ; UnitClass::GetKnownEmitters
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ETA@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ETA@UnitClass@@UAEKXZ PROC				; UnitClass::ETA, COMDAT
; _this$ = ecx

; 477  : 	virtual CampaignTime ETA (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ETA@UnitClass@@UAEKXZ ENDP				; UnitClass::ETA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DumpWeapons@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DumpWeapons@UnitClass@@UAEHXZ PROC			; UnitClass::DumpWeapons, COMDAT
; _this$ = ecx

; 476  : 	virtual int DumpWeapons (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?DumpWeapons@UnitClass@@UAEHXZ ENDP			; UnitClass::DumpWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z PROC ; UnitClass::LoadWeapons, COMDAT
; _this$ = ecx

; 475  : 	virtual int LoadWeapons (void*, uchar*, MoveType, int, int, int)	{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z ENDP ; UnitClass::LoadWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitAirbaseID, COMDAT
; _this$ = ecx

; 474  : 	virtual VU_ID GetUnitAirbaseID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitAirbaseID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ PROC	; UnitClass::GetUnitAirbase, COMDAT
; _this$ = ecx

; 473  : 	virtual CampEntity GetUnitAirbase (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ ENDP	; UnitClass::GetUnitAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitSquadronID, COMDAT
; _this$ = ecx

; 472  : 	virtual VU_ID GetUnitSquadronID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitSquadronID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSquadron@UnitClass@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSquadron@UnitClass@@UAEPAV1@XZ PROC		; UnitClass::GetUnitSquadron, COMDAT
; _this$ = ecx

; 471  : 	virtual Unit GetUnitSquadron (void)							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSquadron@UnitClass@@UAEPAV1@XZ ENDP		; UnitClass::GetUnitSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTOT@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTOT@UnitClass@@UAEKXZ PROC			; UnitClass::GetUnitTOT, COMDAT
; _this$ = ecx

; 470  : 	virtual CampaignTime GetUnitTOT (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTOT@UnitClass@@UAEKXZ ENDP			; UnitClass::GetUnitTOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionID@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMissionID@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitMissionID, COMDAT
; _this$ = ecx

; 469  : 	virtual int GetUnitMissionID (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionID@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitMissionID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitMissionTargetID, COMDAT
; _this$ = ecx

; 468  : 	virtual VU_ID GetUnitMissionTargetID (void)					{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitMissionTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ PROC ; UnitClass::GetUnitMissionTarget, COMDAT
; _this$ = ecx

; 467  : 	virtual CampEntity GetUnitMissionTarget (void)				{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ ENDP ; UnitClass::GetUnitMissionTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPriority@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPriority@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitPriority, COMDAT
; _this$ = ecx

; 466  : 	virtual int GetUnitPriority (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPriority@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ PROC ; UnitClass::GetUnitMission, COMDAT
; _this$ = ecx

; 463  : 	virtual MissionTypeEnum GetUnitMission (void)							{ return (MissionTypeEnum)0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ ENDP ; UnitClass::GetUnitMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetBurntFuel@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBurntFuel@UnitClass@@UAEHXZ PROC			; UnitClass::GetBurntFuel, COMDAT
; _this$ = ecx

; 462  : 	virtual int GetBurntFuel (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBurntFuel@UnitClass@@UAEHXZ ENDP			; UnitClass::GetBurntFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNumberOfLoadouts@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumberOfLoadouts@UnitClass@@UAEHXZ PROC		; UnitClass::GetNumberOfLoadouts, COMDAT
; _this$ = ecx

; 457  : 	virtual int GetNumberOfLoadouts (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfLoadouts@UnitClass@@UAEHXZ ENDP		; UnitClass::GetNumberOfLoadouts
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z PROC	; UnitClass::SetLoadout, COMDAT
; _this$ = ecx

; 456  : 	virtual void SetLoadout (LoadoutStruct*, int)	{ ShiWarning("Shouldn't be here"); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z ENDP	; UnitClass::SetLoadout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::SetUnitAirbase, COMDAT
; _this$ = ecx

; 455  : 	virtual void SetUnitAirbase (VU_ID)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::SetUnitAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::SetUnitSquadron, COMDAT
; _this$ = ecx

; 454  : 	virtual void SetUnitSquadron (VU_ID)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::SetUnitSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitTOT@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitTOT@UnitClass@@UAEXK@Z PROC			; UnitClass::SetUnitTOT, COMDAT
; _this$ = ecx

; 453  : 	virtual void SetUnitTOT (CampaignTime)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitTOT@UnitClass@@UAEXK@Z ENDP			; UnitClass::SetUnitTOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMissionTarget@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMissionTarget@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitMissionTarget, COMDAT
; _this$ = ecx

; 452  : 	virtual void SetUnitMissionTarget (int)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMissionTarget@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitMissionTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMissionID@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMissionID@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitMissionID, COMDAT
; _this$ = ecx

; 451  : 	virtual void SetUnitMissionID (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMissionID@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitMissionID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPriority@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitPriority@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitPriority, COMDAT
; _this$ = ecx

; 450  : 	virtual void SetUnitPriority (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPriority@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitRole@UnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetUnitRole@UnitClass@@UAEXE@Z PROC			; UnitClass::SetUnitRole, COMDAT
; _this$ = ecx

; 449  : 	virtual void SetUnitRole (uchar)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitRole@UnitClass@@UAEXE@Z ENDP			; UnitClass::SetUnitRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMission@UnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetUnitMission@UnitClass@@UAEXE@Z PROC			; UnitClass::SetUnitMission, COMDAT
; _this$ = ecx

; 448  : 	virtual void SetUnitMission (uchar)						{}			

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMission@UnitClass@@UAEXE@Z ENDP			; UnitClass::SetUnitMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetBurntFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetBurntFuel@UnitClass@@UAEXJ@Z PROC			; UnitClass::SetBurntFuel, COMDAT
; _this$ = ecx

; 447  : 	virtual void SetBurntFuel (long)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBurntFuel@UnitClass@@UAEXJ@Z ENDP			; UnitClass::SetBurntFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTactic@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTactic@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitTactic, COMDAT
; _this$ = ecx

; 375  : 	int GetUnitTactic() const						{ return tactic; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+222]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTactic@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMoved@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMoved@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitMoved, COMDAT
; _this$ = ecx

; 374  : 	int GetUnitMoved() const						{ return moved; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+220]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMoved@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ PROC	; UnitClass::GetTarget, COMDAT
; _this$ = ecx

; 366  : 	FalconEntity* GetTarget (void)					{ return (FalconEntity*) vuDatabase->Find(target_id); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR [eax+212]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNumVehicles@UnitClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vg$ = 8						; size = 4
?GetNumVehicles@UnitClass@@QAEHH@Z PROC			; UnitClass::GetNumVehicles, COMDAT
; _this$ = ecx

; 365  : 	int GetNumVehicles (int vg)						{ return (int)((roster >> (vg*2)) & 0x03); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	sar	eax, cl
	and	eax, 3
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumVehicles@UnitClass@@QAEHH@Z ENDP			; UnitClass::GetNumVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitTactic@UnitClass@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 1
?SetUnitTactic@UnitClass@@QAEXE@Z PROC			; UnitClass::SetUnitTactic, COMDAT
; _this$ = ecx

; 361  : 	void SetUnitTactic (uchar t)			 		{ tactic = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+222], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitTactic@UnitClass@@QAEXE@Z ENDP			; UnitClass::SetUnitTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMoved@UnitClass@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m$ = 8							; size = 1
?SetUnitMoved@UnitClass@@QAEXE@Z PROC			; UnitClass::SetUnitMoved, COMDAT
; _this$ = ecx

; 360  : 	void SetUnitMoved (uchar m)						{ moved = m; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _m$[ebp]
	mov	BYTE PTR [eax+220], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMoved@UnitClass@@QAEXE@Z ENDP			; UnitClass::SetUnitMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_this$ = -12						; size = 4
$T3 = -8						; size = 4
tv73 = -4						; size = 4
_e$ = 8							; size = 4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z PROC	; UnitClass::SetTarget, COMDAT
; _this$ = ecx

; 359  : 	void SetTarget (FalconEntity *e)				{ target_id = (e)? e->Id() : FalconNullId; }

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN3@SetTarget
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@SetTarget
$LN3@SetTarget:
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR $T2[ebp+4], edx
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN4@SetTarget:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], eax
	mov	DWORD PTR [edx+216], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ENDP	; UnitClass::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitDestination@UnitClass@@QAEXFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?SetUnitDestination@UnitClass@@QAEXFF@Z PROC		; UnitClass::SetUnitDestination, COMDAT
; _this$ = ecx

; 356  : 	void SetUnitDestination (GridIndex x, GridIndex y)	{ 	dest_x = (GridIndex)(x+1); dest_y = (GridIndex)(y+1); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR _x$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+200], ax
	movsx	edx, WORD PTR _y$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+202], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitDestination@UnitClass@@QAEXFF@Z ENDP		; UnitClass::SetUnitDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SimSetOrientation@UnitClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSetOrientation@UnitClass@@UAEXMMM@Z PROC		; UnitClass::SimSetOrientation, COMDAT
; _this$ = ecx

; 346  : 	virtual void SimSetOrientation (float, float, float) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SimSetOrientation@UnitClass@@UAEXMMM@Z ENDP		; UnitClass::SimSetOrientation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?TempDest@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TempDest@UnitClass@@QBEHXZ PROC			; UnitClass::TempDest, COMDAT
; _this$ = ecx

; 329  : 	int TempDest () const								{ return (int)unit_flags & U_TEMP_DEST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 16777216				; 01000000H
	mov	esp, ebp
	pop	ebp
	ret	0
?TempDest@UnitClass@@QBEHXZ ENDP			; UnitClass::TempDest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Supported@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Supported@UnitClass@@QBEHXZ PROC			; UnitClass::Supported, COMDAT
; _this$ = ecx

; 328  : 	int Supported () const							{ return (int)unit_flags & U_SUPPORTED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 8388608				; 00800000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Supported@UnitClass@@QBEHXZ ENDP			; UnitClass::Supported
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Retreating@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Retreating@UnitClass@@QBEHXZ PROC			; UnitClass::Retreating, COMDAT
; _this$ = ecx

; 326  : 	int Retreating () const							{ return (int)unit_flags & U_RETREATING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 2097152				; 00200000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Retreating@UnitClass@@QBEHXZ ENDP			; UnitClass::Retreating
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Targeted@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Targeted@UnitClass@@QBEHXZ PROC			; UnitClass::Targeted, COMDAT
; _this$ = ecx

; 325  : 	int Targeted () const								{ return (int)unit_flags & U_TARGETED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1048576				; 00100000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Targeted@UnitClass@@QBEHXZ ENDP			; UnitClass::Targeted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Losses@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Losses@UnitClass@@QBEHXZ PROC				; UnitClass::Losses, COMDAT
; _this$ = ecx

; 322  : 	int Losses () const								{ return (int)unit_flags & U_LOSSES; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 65536				; 00010000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Losses@UnitClass@@QBEHXZ ENDP				; UnitClass::Losses
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Broken@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Broken@UnitClass@@QBEHXZ PROC				; UnitClass::Broken, COMDAT
; _this$ = ecx

; 320  : 	int Broken () const								{ return (int)unit_flags & U_BROKEN; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32768				; 00008000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Broken@UnitClass@@QBEHXZ ENDP				; UnitClass::Broken
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Combat@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Combat@UnitClass@@QBEHXZ PROC				; UnitClass::Combat, COMDAT
; _this$ = ecx

; 319  : 	int Combat () const								{ return (int)unit_flags & U_COMBAT; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 16384				; 00004000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Combat@UnitClass@@QBEHXZ ENDP				; UnitClass::Combat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Refused@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Refused@UnitClass@@QBEHXZ PROC				; UnitClass::Refused, COMDAT
; _this$ = ecx

; 317  : 	int Refused () const								{ return (int)unit_flags & U_REFUSED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 2048				; 00000800H
	mov	esp, ebp
	pop	ebp
	ret	0
?Refused@UnitClass@@QBEHXZ ENDP				; UnitClass::Refused
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Moving@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Moving@UnitClass@@QBEHXZ PROC				; UnitClass::Moving, COMDAT
; _this$ = ecx

; 316  : 	int Moving() const								{ return (int)unit_flags & U_MOVING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1024				; 00000400H
	mov	esp, ebp
	pop	ebp
	ret	0
?Moving@UnitClass@@QBEHXZ ENDP				; UnitClass::Moving
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Engaged@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Engaged@UnitClass@@QBEHXZ PROC				; UnitClass::Engaged, COMDAT
; _this$ = ecx

; 313  : 	int Engaged() const								{ return (int)unit_flags & U_ENGAGED; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 64					; 00000040H
	mov	esp, ebp
	pop	ebp
	ret	0
?Engaged@UnitClass@@QBEHXZ ENDP				; UnitClass::Engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Parent@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Parent@UnitClass@@QBEHXZ PROC				; UnitClass::Parent, COMDAT
; _this$ = ecx

; 312  : 	int Parent() const								{ return (int)unit_flags & U_PARENT; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32					; 00000020H
	mov	esp, ebp
	pop	ebp
	ret	0
?Parent@UnitClass@@QBEHXZ ENDP				; UnitClass::Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Ordered@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Ordered@UnitClass@@QBEHXZ PROC				; UnitClass::Ordered, COMDAT
; _this$ = ecx

; 310  : 	int Ordered() const								{ return (int)unit_flags & U_ORDERED; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?Ordered@UnitClass@@QBEHXZ ENDP				; UnitClass::Ordered
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IsDead@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@UnitClass@@UBEHXZ PROC				; UnitClass::IsDead, COMDAT
; _this$ = ecx

; 307  : 	virtual int IsDead() const						{ return (int)unit_flags & U_DEAD; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@UnitClass@@UBEHXZ ENDP				; UnitClass::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IsUnit@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnit@UnitClass@@UAEHXZ PROC				; UnitClass::IsUnit, COMDAT
; _this$ = ecx

; 274  : 	virtual int IsUnit (void)										{ return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnit@UnitClass@@UAEHXZ ENDP				; UnitClass::IsUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Father@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Father@UnitClass@@UBEHXZ PROC				; UnitClass::Father, COMDAT
; _this$ = ecx

; 248  : 	virtual int Father() const										{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Father@UnitClass@@UBEHXZ ENDP				; UnitClass::Father
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ShouldDeaggregate@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShouldDeaggregate@UnitClass@@UAEHXZ PROC		; UnitClass::ShouldDeaggregate, COMDAT
; _this$ = ecx

; 241  : 	virtual int	ShouldDeaggregate(void)								{return TRUE;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldDeaggregate@UnitClass@@UAEHXZ ENDP		; UnitClass::ShouldDeaggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetOdds@UnitClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOdds@UnitClass@@QAEFXZ PROC				; UnitClass::GetOdds, COMDAT
; _this$ = ecx

; 159  : 	short GetOdds (void)				{ return odds; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+230]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOdds@UnitClass@@QAEFXZ ENDP				; UnitClass::GetOdds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetReinforcement@UnitClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReinforcement@UnitClass@@QAEFXZ PROC		; UnitClass::GetReinforcement, COMDAT
; _this$ = ecx

; 158  : 	short GetReinforcement (void)		{ return reinforcement; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+228]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReinforcement@UnitClass@@QAEFXZ ENDP		; UnitClass::GetReinforcement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTactic@UnitClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTactic@UnitClass@@QAEEXZ PROC			; UnitClass::GetTactic, COMDAT
; _this$ = ecx

; 155  : 	uchar GetTactic (void)				{ return tactic; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+222]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTactic@UnitClass@@QAEEXZ ENDP			; UnitClass::GetTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetCargoId, COMDAT
; _this$ = ecx

; 151  : 	VU_ID GetCargoId (void)				{ return cargo_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	edx, DWORD PTR [eax+208]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetCargoId@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetCargoId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitFlags@UnitClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitFlags@UnitClass@@QAEJXZ PROC			; UnitClass::GetUnitFlags, COMDAT
; _this$ = ecx

; 148  : 	fourbyte GetUnitFlags (void)		{ return unit_flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFlags@UnitClass@@QAEJXZ ENDP			; UnitClass::GetUnitFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastCheck@UnitClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastCheck@UnitClass@@QAEKXZ PROC			; UnitClass::GetLastCheck, COMDAT
; _this$ = ecx

; 146  : 	CampaignTime GetLastCheck (void)	{ return last_check; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastCheck@UnitClass@@QAEKXZ ENDP			; UnitClass::GetLastCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?NumLinks@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumLinks@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::NumLinks, COMDAT
; _this$ = ecx

; 268  : 	int NumLinks(void)										{	return static_data.links; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+225]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumLinks@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::NumLinks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?RadarSite@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RadarSite@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::RadarSite, COMDAT
; _this$ = ecx

; 222  : 	int RadarSite (void)									{	return obj_data.obj_flags & O_RADAR_SITE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 65536				; 00010000H
	mov	esp, ebp
	pop	ebp
	ret	0
?RadarSite@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::RadarSite
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?ArtillerySite@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ArtillerySite@ObjectiveClass@@QAEHXZ PROC		; ObjectiveClass::ArtillerySite, COMDAT
; _this$ = ecx

; 210  : 	int ArtillerySite (void)								{	return obj_data.obj_flags & O_ARTILLERY_SITE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 2048				; 00000800H
	mov	esp, ebp
	pop	ebp
	ret	0
?ArtillerySite@ObjectiveClass@@QAEHXZ ENDP		; ObjectiveClass::ArtillerySite
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?SamSite@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SamSite@ObjectiveClass@@QAEHXZ PROC			; ObjectiveClass::SamSite, COMDAT
; _this$ = ecx

; 208  : 	int SamSite (void)										{	return obj_data.obj_flags & O_SAM_SITE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 1024				; 00000400H
	mov	esp, ebp
	pop	ebp
	ret	0
?SamSite@ObjectiveClass@@QAEHXZ ENDP			; ObjectiveClass::SamSite
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?SetSpottedTime@CampBaseClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetSpottedTime@CampBaseClass@@QAEXK@Z PROC		; CampBaseClass::SetSpottedTime, COMDAT
; _this$ = ecx

; 299  : 	void SetSpottedTime (CampaignTime t)		{	spotTime = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+144], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpottedTime@CampBaseClass@@QAEXK@Z ENDP		; CampBaseClass::SetSpottedTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_e$ = 8							; size = 4
?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z PROC	; CampBaseClass::HasEntity, COMDAT
; _this$ = ecx

; 281  : 	virtual int HasEntity(VuEntity *e) const    {   

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		return ((components && (components->Find(e) != NULL)) || (this == e)); 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+160], 0
	je	SHORT $LN3@HasEntity
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?Find@VuCollection@@QBE_NPAVVuEntity@@@Z ; VuCollection::Find
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@HasEntity
$LN3@HasEntity:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	je	SHORT $LN4@HasEntity
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN5@HasEntity
$LN4@HasEntity:
	mov	DWORD PTR tv81[ebp], 1
$LN5@HasEntity:
	mov	eax, DWORD PTR tv81[ebp]

; 283  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z ENDP	; CampBaseClass::HasEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAwake@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 273  : 	int IsAwake (void)							{	return local_flags & CBC_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsEmitting@CampBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@CampBaseClass@@UAEHXZ PROC			; CampBaseClass::IsEmitting, COMDAT
; _this$ = ecx

; 269  : 	virtual int IsEmitting (void)				{	return base_flags & CBC_EMITTING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+150]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@CampBaseClass@@UAEHXZ ENDP			; CampBaseClass::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsCampBase@CampBaseClass@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCampBase@CampBaseClass@@UAE_NXZ PROC			; CampBaseClass::IsCampBase, COMDAT
; _this$ = ecx

; 268  : 	virtual bool IsCampBase() { return true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampBase@CampBaseClass@@UAE_NXZ ENDP			; CampBaseClass::IsCampBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCountry@CampBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCountry@CampBaseClass@@UAEEXZ PROC			; CampBaseClass::GetCountry, COMDAT
; _this$ = ecx

; 239  : 	virtual uchar GetCountry (void)								{	return owner; }		// New FalcEnt friendly form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCountry@CampBaseClass@@UAEEXZ ENDP			; CampBaseClass::GetCountry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetTeam@CampBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeam@CampBaseClass@@UAEEXZ PROC			; CampBaseClass::GetTeam, COMDAT
; _this$ = ecx

; 238  : 	virtual uchar GetTeam (void)								{	return ::GetTeam(owner); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+154]
	push	ecx
	call	?GetTeam@@YAEE@Z			; GetTeam
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeam@CampBaseClass@@UAEEXZ ENDP			; CampBaseClass::GetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCampID@CampBaseClass@@UAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampID@CampBaseClass@@UAEFXZ PROC			; CampBaseClass::GetCampID, COMDAT
; _this$ = ecx

; 237  : 	virtual short GetCampID (void)								{	return camp_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampID@CampBaseClass@@UAEFXZ ENDP			; CampBaseClass::GetCampID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ?memcpychk@@YAXPAXPAPAEIPAJ@Z
_TEXT	SEGMENT
$T2 = -152						; size = 12
_s$3 = -140						; size = 24
_err$4 = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_rem$ = 20						; size = 4
?memcpychk@@YAXPAXPAPAEIPAJ@Z PROC			; memcpychk, COMDAT

; 25   : inline void memcpychk(void *dst, VU_BYTE **src, size_t size, long *rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 26   : 	if ((size_t)*rem < size){

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN1@memcpychk

; 27   : 		char err[100];
; 28   : 		sprintf(err, "Trying to write %lu bytes to %ld buffer", static_cast<unsigned long>(size), *rem);

	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
	lea	edx, DWORD PTR _err$4[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 29   : 		std::string s(err);

	lea	eax, DWORD PTR _err$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 30   : 		throw InvalidBufferException(s);

	lea	ecx, DWORD PTR _s$3[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
	push	OFFSET __TI4?AVInvalidBufferException@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 31   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@memcpychk:

; 32   : 	memcpy(dst, *src, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 33   : 	*rem -= size;

	mov	ecx, DWORD PTR _rem$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [eax], edx

; 34   : 	*src += size;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax], edx
$LN3@memcpychk:

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0:
	lea	ecx, DWORD PTR _s$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?memcpychk@@YAXPAXPAPAEIPAJ@Z ENDP			; memcpychk
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidBufferException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidBufferException@@UAEPAXI@Z PROC		; InvalidBufferException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidBufferException@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidBufferException@@UAEPAXI@Z ENDP		; InvalidBufferException::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0InvalidBufferException@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV0@@Z PROC		; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV0@@Z ENDP		; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1InvalidBufferException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InvalidBufferException@@UAE@XZ PROC			; InvalidBufferException::~InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1InvalidBufferException@@UAE@XZ ENDP			; InvalidBufferException::~InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx

; 19   : 	InvalidBufferException(const std::string &msg) : out_of_range(msg){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPLocation@WayPointClass@@QBEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetWPLocation@WayPointClass@@QBEXPAF0@Z PROC		; WayPointClass::GetWPLocation, COMDAT
; _this$ = ecx

; 205  : 	void GetWPLocation (GridIndex* x, GridIndex* y) const { *x = GridX; *y = GridY; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetWPLocation@WayPointClass@@QBEXPAF0@Z ENDP		; WayPointClass::GetWPLocation
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSmallPathClass@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSmallPathClass@@QAEPAXI@Z PROC			; SmallPathClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SmallPathClass@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSmallPathClass@@QAEPAXI@Z ENDP			; SmallPathClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1SmallPathClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SmallPathClass@@QAE@XZ PROC				; SmallPathClass::~SmallPathClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BasePathClass@@QAE@XZ		; BasePathClass::~BasePathClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1SmallPathClass@@QAE@XZ ENDP				; SmallPathClass::~SmallPathClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1PathClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathClass@@QAE@XZ PROC				; PathClass::~PathClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BasePathClass@@QAE@XZ		; BasePathClass::~BasePathClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathClass@@QAE@XZ ENDP				; PathClass::~PathClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::HasAreaJamming, COMDAT
; _this$ = ecx

; 162  : 	virtual int HasAreaJamming (void)			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::HasAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::HasSPJamming, COMDAT
; _this$ = ecx

; 161  : 	virtual int HasSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::HasSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsAreaJamming, COMDAT
; _this$ = ecx

; 160  : 	virtual int IsAreaJamming (void)            { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSPJamming, COMDAT
; _this$ = ecx

; 159  : 	virtual int IsSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTaskForce@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTaskForce@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTaskForce, COMDAT
; _this$ = ecx

; 158  : 	virtual int IsTaskForce (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTaskForce@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTaskForce
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTeam@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeam@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTeam, COMDAT
; _this$ = ecx

; 157  : 	virtual int IsTeam (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeam@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPackage@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPackage@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsPackage, COMDAT
; _this$ = ecx

; 156  : 	virtual int IsPackage (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPackage@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSquadron@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSquadron@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSquadron, COMDAT
; _this$ = ecx

; 155  : 	virtual int IsSquadron (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSquadron@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsFlight@FalconEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlight@FalconEntity@@UBEHXZ PROC			; FalconEntity::IsFlight, COMDAT
; _this$ = ecx

; 154  : 	virtual int IsFlight() const				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlight@FalconEntity@@UBEHXZ ENDP			; FalconEntity::IsFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBrigade@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrigade@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBrigade, COMDAT
; _this$ = ecx

; 153  : 	virtual int IsBrigade (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrigade@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBrigade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsObjective@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjective@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsObjective, COMDAT
; _this$ = ecx

; 151  : 	virtual int IsObjective (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsObjective@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsDead@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsDead, COMDAT
; _this$ = ecx

; 144  : 	virtual int IsDead (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsExploding@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExploding@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsExploding, COMDAT
; _this$ = ecx

; 143  : 	virtual int IsExploding (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExploding@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsExploding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsWeapon@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWeapon@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsWeapon, COMDAT
; _this$ = ecx

; 142  : 	virtual int IsWeapon (void)   				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWeapon@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsShip@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShip@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsShip, COMDAT
; _this$ = ecx

; 141  : 	virtual int IsShip (void) 			        { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShip@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGroundVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGroundVehicle@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsGroundVehicle, COMDAT
; _this$ = ecx

; 140  : 	virtual int IsGroundVehicle (void) 			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGroundVehicle@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsGroundVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAirplane@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirplane@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsAirplane, COMDAT
; _this$ = ecx

; 139  : 	virtual int IsAirplane (void)	   			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirplane@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsAirplane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEject@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEject@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEject, COMDAT
; _this$ = ecx

; 138  : 	virtual int IsEject (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEject@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsHelicopter@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHelicopter@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsHelicopter, COMDAT
; _this$ = ecx

; 137  : 	virtual int IsHelicopter (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHelicopter@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsHelicopter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsStatic@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStatic@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsStatic, COMDAT
; _this$ = ecx

; 136  : 	virtual int IsStatic (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStatic@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsStatic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsVehicle@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsVehicle, COMDAT
; _this$ = ecx

; 135  : 	virtual int IsVehicle (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVehicle@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMover@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMover@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMover, COMDAT
; _this$ = ecx

; 134  : 	virtual int IsMover (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGun@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGun@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsGun, COMDAT
; _this$ = ecx

; 133  : 	virtual int IsGun (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGun@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBomb@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBomb@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBomb, COMDAT
; _this$ = ecx

; 132  : 	virtual int IsBomb (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBomb@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsLauncher@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsLauncher, COMDAT
; _this$ = ecx

; 131  : 	virtual int IsLauncher (void)               { return FALSE; } // MLR 3/4/2004 - rocket pods

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMissile@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMissile@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMissile, COMDAT
; _this$ = ecx

; 130  : 	virtual int IsMissile (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMissile@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?CombatClass@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatClass@FalconEntity@@UAEHXZ PROC			; FalconEntity::CombatClass, COMDAT
; _this$ = ecx

; 127  : 	virtual int CombatClass (void)				{ return 999; } // 2002-02-25 ADDED BY S.G. No combat class for non flight or non aircraft class

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 999				; 000003e7H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatClass@FalconEntity@@UAEHXZ ENDP			; FalconEntity::CombatClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSimBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSimBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsSimBase, COMDAT
; _this$ = ecx

; 98   : 	virtual bool IsSimBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSimBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsSimBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ PROC	; VuBin<VuEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ENDP	; VuBin<VuEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@PBD@Z		; std::logic_error::logic_error
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 146  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1717 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1718 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1719 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 38   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@

; 39   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ PROC		; VuEntity::VuState, COMDAT
; _this$ = ecx

; 153  : 	VU_MEM VuState() const    { return vuState_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ ENDP		; VuEntity::VuState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
END
