; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPTASK\Mission.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?HDelta@@3PAHA					; HDelta
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?MissionData@@3PAUMissionDataType@@A		; MissionData
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
_DATA	SEGMENT
?HDelta@@3PAHA DD 00H					; HDelta
	DD	01H
	DD	0ffffffffH
	DD	02H
	DD	0fffffffeH
	DD	03H
	DD	0fffffffdH
	ORG $+4
?MissionData@@3PAUMissionDataType@@A DB 00H		; MissionData
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	00H
	DB	00H
	DB	032H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DB	01H
	DB	03H
	DB	01H
	DB	02H
	DB	08H
	DB	01H
	DB	00H
	DB	0cH
	DW	064H
	DW	0190H
	DW	0c8H
	DW	00H
	DW	0fH
	DB	02H
	DB	05H
	DB	01eH
	DB	00H
	DB	0fH
	DB	0fH
	DB	00H
	ORG $+3
	DD	022182201H
	DB	02H
	DB	03H
	DB	01H
	DB	02H
	DB	08H
	DB	01H
	DB	00H
	DB	0cH
	DW	064H
	DW	0190H
	DW	0c8H
	DW	00H
	DW	0fH
	DB	02H
	DB	05H
	DB	01eH
	DB	00H
	DB	0fH
	DB	0fH
	DB	00H
	ORG $+3
	DD	022182201H
	DB	03H
	DB	02H
	DB	01H
	DB	02H
	DB	08H
	DB	02H
	DB	0aH
	DB	0cH
	DW	064H
	DW	0190H
	DW	012cH
	DW	0ffc4H
	DW	03cH
	DB	02H
	DB	05H
	DB	01eH
	DB	00H
	DB	01H
	DB	0fH
	DB	00H
	ORG $+3
	DD	020082201H
	DB	04H
	DB	03H
	DB	01H
	DB	02H
	DB	08H
	DB	03H
	DB	00H
	DB	0cH
	DW	064H
	DW	012cH
	DW	0c8H
	DW	0ffc4H
	DW	0fH
	DB	02H
	DB	05H
	DB	01eH
	DB	00H
	DB	01eH
	DB	0fH
	DB	00H
	ORG $+3
	DD	022088001H
	DB	05H
	DB	03H
	DB	01H
	DB	02H
	DB	08H
	DB	03H
	DB	0aH
	DB	0cH
	DW	032H
	DW	064H
	DW	064H
	DW	00H
	DW	0fH
	DB	02H
	DB	05H
	DB	01eH
	DB	00H
	DB	01eH
	DB	0fH
	DB	00H
	ORG $+3
	DD	022080001H
	DB	06H
	DB	03H
	DB	01H
	DB	01H
	DB	08H
	DB	01H
	DB	00H
	DB	0cH
	DW	02H
	DW	0aH
	DW	07H
	DW	00H
	DW	0fH
	DB	02H
	DB	05H
	DB	01eH
	DB	00H
	DB	01eH
	DB	0fH
	DB	00H
	ORG $+3
	DD	022182001H
	DB	07H
	DB	03H
	DB	01H
	DB	02H
	DB	06H
	DB	01H
	DB	0bH
	DB	0bH
	DW	064H
	DW	0190H
	DW	0c8H
	DW	00H
	DW	00H
	DB	04H
	DB	05H
	DB	01eH
	DB	00H
	DB	01H
	DB	01eH
	DB	00H
	ORG $+3
	DD	02080001H
	DB	08H
	DB	03H
	DB	01H
	DB	01H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DW	00H
	DW	0aH
	DW	00H
	DW	00H
	DW	00H
	DB	02H
	DB	00H
	DB	0aH
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	ORG $+3
	DD	0220c2000H
	DB	09H
	DB	02H
	DB	01H
	DB	02H
	DB	04H
	DB	03H
	DB	00H
	DB	0dH
	DW	064H
	DW	0190H
	DW	0c8H
	DW	00H
	DW	00H
	DB	02H
	DB	00H
	DB	014H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	026010000H
	DB	0aH
	DB	02H
	DB	01H
	DB	03H
	DB	07H
	DB	02H
	DB	0aH
	DB	0aH
	DW	032H
	DW	0258H
	DW	0c8H
	DW	0ffc4H
	DW	00H
	DB	02H
	DB	0aH
	DB	014H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	ORG $+3
	DD	028028001H
	DB	0bH
	DB	02H
	DB	07H
	DB	03H
	DB	01H
	DB	02H
	DB	013H
	DB	013H
	DW	014H
	DW	078H
	DW	028H
	DW	00H
	DW	00H
	DB	04H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	0ffH
	DB	00H
	ORG $+3
	DD	01002c04cH
	DB	0cH
	DB	02H
	DB	07H
	DB	03H
	DB	07H
	DB	02H
	DB	013H
	DB	013H
	DW	014H
	DW	078H
	DW	028H
	DW	0ffc4H
	DW	00H
	DB	02H
	DB	0aH
	DB	028H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	ORG $+3
	DD	038028004H
	DB	0dH
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	011H
	DW	05H
	DW	078H
	DW	050H
	DW	00H
	DW	00H
	DB	04H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	0ffH
	DB	00H
	ORG $+3
	DD	010024178H
	DB	0eH
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	011H
	DW	05H
	DW	078H
	DW	032H
	DW	00H
	DW	00H
	DB	04H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	0ffH
	DB	00H
	ORG $+3
	DD	010024168H
	DB	0fH
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	011H
	DW	05H
	DW	078H
	DW	050H
	DW	00H
	DW	00H
	DB	04H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	0ffH
	DB	00H
	ORG $+3
	DD	010024179H
	DB	010H
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	011H
	DW	05H
	DW	078H
	DW	050H
	DW	00H
	DW	00H
	DB	04H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	0ffH
	DB	00H
	ORG $+3
	DD	01002c065H
	DB	011H
	DB	01H
	DB	03H
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	011H
	DW	05H
	DW	078H
	DW	050H
	DW	00H
	DW	00H
	DB	04H
	DB	0aH
	DB	028H
	DB	00H
	DB	01H
	DB	0ffH
	DB	020H
	ORG $+3
	DD	01002c040H
	DB	012H
	DB	01H
	DB	05H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	012H
	DW	0c8H
	DW	0258H
	DW	012cH
	DW	00H
	DW	00H
	DB	02H
	DB	0aH
	DB	078H
	DB	0aH
	DB	01H
	DB	0ffH
	DB	00H
	ORG $+3
	DD	010020170H
	DB	013H
	DB	03H
	DB	0fH
	DB	01H
	DB	03H
	DB	03H
	DB	00H
	DB	01eH
	DW	05H
	DW	064H
	DW	032H
	DW	00H
	DW	01eH
	DB	01H
	DB	05H
	DB	03cH
	DB	07H
	DB	0aH
	DB	014H
	DB	00H
	ORG $+3
	DD	020906302H
	DB	014H
	DB	03H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	00H
	DB	09H
	DW	02H
	DW	064H
	DW	032H
	DW	00H
	DW	0fH
	DB	02H
	DB	05H
	DB	03cH
	DB	07H
	DB	0aH
	DB	014H
	DB	00H
	ORG $+3
	DD	022186b42H
	DB	015H
	DB	02H
	DB	04H
	DB	03H
	DB	04H
	DB	03H
	DB	00H
	DB	0eH
	DW	02H
	DW	064H
	DW	032H
	DW	00H
	DW	00H
	DB	02H
	DB	05H
	DB	03cH
	DB	07H
	DB	0fH
	DB	014H
	DB	00H
	ORG $+3
	DD	030006142H
	DB	016H
	DB	03H
	DB	04H
	DB	03H
	DB	04H
	DB	03H
	DB	00H
	DB	0eH
	DW	02H
	DW	064H
	DW	032H
	DW	00H
	DW	00H
	DB	02H
	DB	00H
	DB	014H
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	026114102H
	DB	017H
	DB	03H
	DB	04H
	DB	03H
	DB	08H
	DB	02H
	DB	010H
	DB	010H
	DW	05H
	DW	0c8H
	DW	064H
	DW	00H
	DW	00H
	DB	02H
	DB	05H
	DB	03cH
	DB	00H
	DB	014H
	DB	01eH
	DB	00H
	ORG $+3
	DD	0180243H
	DB	018H
	DB	03H
	DB	04H
	DB	03H
	DB	08H
	DB	02H
	DB	00H
	DB	010H
	DW	05H
	DW	0c8H
	DW	064H
	DW	00H
	DW	05H
	DB	04H
	DB	05H
	DB	03cH
	DB	00H
	DB	01H
	DB	01eH
	DB	00H
	ORG $+3
	DD	0180043H
	DB	019H
	DB	03H
	DB	04H
	DB	03H
	DB	08H
	DB	02H
	DB	00H
	DB	010H
	DW	05H
	DW	0c8H
	DW	064H
	DW	00H
	DW	0fH
	DB	04H
	DB	00H
	DB	03cH
	DB	00H
	DB	01H
	DB	01eH
	DB	00H
	ORG $+3
	DD	0184000H
	DB	01aH
	DB	03H
	DB	0cH
	DB	02H
	DB	03H
	DB	03H
	DB	014H
	DB	014H
	DW	012cH
	DW	0190H
	DW	0190H
	DW	00H
	DW	012cH
	DB	01H
	DB	014H
	DB	078H
	DB	03H
	DB	032H
	DB	078H
	DB	00H
	ORG $+3
	DD	028202090H
	DB	01bH
	DB	03H
	DB	0dH
	DB	02H
	DB	03H
	DB	03H
	DB	014H
	DB	014H
	DW	012cH
	DW	0190H
	DW	0190H
	DW	00H
	DW	012cH
	DB	01H
	DB	014H
	DB	078H
	DB	03H
	DB	032H
	DB	078H
	DB	00H
	ORG $+3
	DD	028202090H
	DB	01cH
	DB	03H
	DB	0eH
	DB	02H
	DB	03H
	DB	03H
	DB	018H
	DB	018H
	DW	064H
	DW	012cH
	DW	0c8H
	DW	00H
	DW	012cH
	DB	01H
	DB	014H
	DB	078H
	DB	03H
	DB	028H
	DB	078H
	DB	00H
	ORG $+3
	DD	028202090H
	DB	01dH
	DB	01H
	DB	0aH
	DB	01H
	DB	01H
	DB	03H
	DB	00H
	DB	015H
	DW	02H
	DW	0258H
	DW	0190H
	DW	00H
	DW	00H
	DB	02H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	05aH
	DB	00H
	ORG $+3
	DD	040H
	DB	01eH
	DB	01H
	DB	0aH
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	015H
	DW	02H
	DW	0c8H
	DW	064H
	DW	078H
	DW	00H
	DB	02H
	DB	0aH
	DB	028H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	ORG $+3
	DD	08024000H
	DB	01fH
	DB	03H
	DB	06H
	DB	02H
	DB	03H
	DB	03H
	DB	01aH
	DB	01aH
	DW	064H
	DW	01f4H
	DW	0c8H
	DW	00H
	DW	03cH
	DB	01H
	DB	0aH
	DB	03cH
	DB	03H
	DB	01eH
	DB	03cH
	DB	00H
	ORG $+3
	DD	028002090H
	DB	020H
	DB	02H
	DB	02H
	DB	01H
	DB	09H
	DB	02H
	DB	00H
	DB	019H
	DW	05H
	DW	019H
	DW	05H
	DW	00H
	DW	02H
	DB	04H
	DB	05H
	DB	028H
	DB	07H
	DB	01H
	DB	00H
	DB	080H
	ORG $+3
	DD	03142c090H
	DB	021H
	DB	03H
	DB	0bH
	DB	02H
	DB	09H
	DB	01H
	DB	00H
	DB	07H
	DW	064H
	DW	012cH
	DW	0c8H
	DW	00H
	DW	01eH
	DB	01H
	DB	05H
	DB	028H
	DB	0aH
	DB	01H
	DB	00H
	DB	00H
	ORG $+3
	DD	038622000H
	DB	022H
	DB	03H
	DB	02H
	DB	01H
	DB	04H
	DB	03H
	DB	00H
	DB	016H
	DW	01H
	DW	019H
	DW	05H
	DW	00H
	DW	00H
	DB	01H
	DB	05H
	DB	028H
	DB	05H
	DB	01H
	DB	00H
	DB	080H
	ORG $+3
	DD	03000c050H
	DB	023H
	DB	02H
	DB	08H
	DB	01H
	DB	08H
	DB	02H
	DB	017H
	DB	017H
	DW	05H
	DW	064H
	DW	032H
	DW	00H
	DW	00H
	DB	01H
	DB	05H
	DB	028H
	DB	07H
	DB	014H
	DB	00H
	DB	02H
	ORG $+3
	DD	038020080H
	DB	024H
	DB	02H
	DB	09H
	DB	03H
	DB	01H
	DB	03H
	DB	00H
	DB	0fH
	DW	05H
	DW	064H
	DW	050H
	DW	00H
	DW	00H
	DB	02H
	DB	0aH
	DB	028H
	DB	0aH
	DB	01H
	DB	00H
	DB	00H
	ORG $+3
	DD	018020050H
	DB	025H
	DB	03H
	DB	0aH
	DB	03H
	DB	04H
	DB	02H
	DB	015H
	DB	015H
	DW	064H
	DW	01f4H
	DW	032H
	DW	00H
	DW	01eH
	DB	01H
	DB	0aH
	DB	03cH
	DB	07H
	DB	014H
	DB	03cH
	DB	02H
	ORG $+3
	DD	08020080H
	DB	026H
	DB	03H
	DB	0aH
	DB	01H
	DB	03H
	DB	03H
	DB	015H
	DB	015H
	DW	05H
	DW	019H
	DW	05H
	DW	00H
	DW	01eH
	DB	02H
	DB	05H
	DB	03cH
	DB	07H
	DB	0aH
	DB	03cH
	DB	088H
	ORG $+3
	DD	0940080H
	DB	027H
	DB	03H
	DB	00H
	DB	01H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DW	05H
	DW	01f4H
	DW	064H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	03cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	020000000H
	DB	028H
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	020000000H
_DATA	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::OwnerId
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z	; WayPointClass::SetWPTarget
PUBLIC	?SetWPTargetBuilding@WayPointClass@@QAEXE@Z	; WayPointClass::SetWPTargetBuilding
PUBLIC	?SetWPAction@WayPointClass@@QAEXH@Z		; WayPointClass::SetWPAction
PUBLIC	?SetWPRouteAction@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPRouteAction
PUBLIC	?SetWPFlags@WayPointClass@@QAEXK@Z		; WayPointClass::SetWPFlags
PUBLIC	?SetWPFlag@WayPointClass@@QAEXK@Z		; WayPointClass::SetWPFlag
PUBLIC	?UnSetWPFlag@WayPointClass@@QAEXK@Z		; WayPointClass::UnSetWPFlag
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPRouteAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPRouteAction
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?SetWPDepartTime@WayPointClass@@QAEXK@Z		; WayPointClass::SetWPDepartTime
PUBLIC	?SetWPArrive@WayPointClass@@QAEXK@Z		; WayPointClass::SetWPArrive
PUBLIC	?SetWPSpeed@WayPointClass@@QAEXM@Z		; WayPointClass::SetWPSpeed
PUBLIC	?GetWPSpeed@WayPointClass@@QAEMXZ		; WayPointClass::GetWPSpeed
PUBLIC	?GetWPAltitude@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAltitude
PUBLIC	?GetWPStationTime@WayPointClass@@QAEKXZ		; WayPointClass::GetWPStationTime
PUBLIC	?GetWPArrivalTime@WayPointClass@@QAEKXZ		; WayPointClass::GetWPArrivalTime
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	?GetWPLocation@WayPointClass@@QBEXPAF0@Z	; WayPointClass::GetWPLocation
PUBLIC	??0MissionRequestClass@@QAE@XZ			; MissionRequestClass::MissionRequestClass
PUBLIC	??1MissionRequestClass@@QAE@XZ			; MissionRequestClass::~MissionRequestClass
PUBLIC	?RequestMission@MissionRequestClass@@QAEHXZ	; MissionRequestClass::RequestMission
PUBLIC	?RequestEnemyMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestEnemyMission
PUBLIC	?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z ; BuildPathToTarget
PUBLIC	?BuildDivertPath@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ; BuildDivertPath
PUBLIC	?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ; AddInformationWPs
PUBLIC	?ClearDivertWayPoints@@YAXPAVFlightClass@@@Z	; ClearDivertWayPoints
PUBLIC	?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z	; AddTankerWayPoint
PUBLIC	?SetWPTimes@@YAJPAVFlightClass@@PAVMissionRequestClass@@@Z ; SetWPTimes
PUBLIC	?SetWPTimesTanker@@YAJPAVFlightClass@@PAVMissionRequestClass@@_NK@Z ; SetWPTimesTanker
PUBLIC	?CheckPathThreats@@YAHPAVUnitClass@@@Z		; CheckPathThreats
PUBLIC	?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z ; TargetThreats
PUBLIC	?LoadMissionData@@YAHXZ				; LoadMissionData
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?GetLength@BasePathClass@@QAEHXZ		; BasePathClass::GetLength
PUBLIC	??1PathClass@@QAE@XZ				; PathClass::~PathClass
PUBLIC	?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetClassData
PUBLIC	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
PUBLIC	?GetUnitPackage@FlightClass@@QAEPAVPackageClass@@XZ ; FlightClass::GetUnitPackage
PUBLIC	?GetTPTime@PackageClass@@QAEKXZ			; PackageClass::GetTPTime
PUBLIC	?GetIngress@PackageClass@@QAEPAVWayPointClass@@XZ ; PackageClass::GetIngress
PUBLIC	?GetEgress@PackageClass@@QAEPAVWayPointClass@@XZ ; PackageClass::GetEgress
PUBLIC	?GetMissionRequest@PackageClass@@QAEPAVMissionRequestClass@@XZ ; PackageClass::GetMissionRequest
PUBLIC	?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z ; FindSafePath
PUBLIC	?CheckBestAltitude@@YAHFFEHHHH@Z		; CheckBestAltitude
PUBLIC	?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z ; ScoreThreatsOnWPLeg
PUBLIC	?CheckSafePath@@YAPAVWayPointClass@@PAV1@0PAVFlightClass@@@Z ; CheckSafePath
PUBLIC	?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z ; AddSafeWaypoint
PUBLIC	?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z ; AddDistanceWaypoint
PUBLIC	?EliminateExcessWaypoints@@YAPAVWayPointClass@@PAV1@0H@Z ; EliminateExcessWaypoints
PUBLIC	?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z ; FillAirPath
PUBLIC	?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupIngressPoints
PUBLIC	?AddIngressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddIngressPath
PUBLIC	?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddAttackProfile
PUBLIC	?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddLoiterProfile
PUBLIC	?AddBypassProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddBypassProfile
PUBLIC	?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddFlyByProfile
PUBLIC	?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddLandProfile
PUBLIC	?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddTargetProfile
PUBLIC	?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddSweepProfile
PUBLIC	?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupEgressPoints
PUBLIC	?AddEgressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddEgressPath
PUBLIC	?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddExitRoute
PUBLIC	?SetupAltitudes@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupAltitudes
PUBLIC	?SetCurrentAltitude@@YAXXZ			; SetCurrentAltitude
PUBLIC	?CheckForClimb@@YAXPAVWayPointClass@@@Z		; CheckForClimb
PUBLIC	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z	; FinalizeWayPoint
PUBLIC	?FinalizeFillerWayPoint@@YAXPAVWayPointClass@@@Z ; FinalizeFillerWayPoint
PUBLIC	?WriteMissionData@@YAHXZ			; WriteMissionData
PUBLIC	??_C@_0CO@LNFFDOCL@Problem?5?9?5airborne?5flight?5with?5n@ ; `string'
PUBLIC	??_C@_0CL@GNEDMECB@Failed?5to?5find?5a?5path?5to?5target?5@ ; `string'
PUBLIC	??_C@_02BMJICGCB@rt?$AA@			; `string'
PUBLIC	??_C@_03GILJFNFC@dat?$AA@			; `string'
PUBLIC	??_C@_07CACALAH@mission?$AA@			; `string'
PUBLIC	??_C@_0EE@JDCKNOBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_0N@DNMLHFGK@Bad?5line?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_02BKFDOEMK@wt?$AA@			; `string'
PUBLIC	??_C@_0LE@CMLDGOIL@?1?1?5No?5Type?5Target?5skill?5MissionP@ ; `string'
PUBLIC	??_C@_0GB@KDIDELCK@?$CF5d?5?$CF4d?5?$CF6d?5?$CF5d?5?$CF14d?5?$CF13d?5?$CF10d?5?$CF@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f34fdf4
PUBLIC	__real@3f800000
PUBLIC	__real@3fa66666
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40060a91
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42480000
PUBLIC	__real@42942e07
PUBLIC	__real@454cffae
PUBLIC	__real@4a5bba00
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_abs:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	_fclose:PROC
EXTRN	_fgets:PROC
EXTRN	_fprintf:PROC
EXTRN	_sscanf:PROC
EXTRN	_rand:PROC
EXTRN	_memset:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	??0FalconPrivateList@@QAE@PAVVuFilter@@@Z:PROC	; FalconPrivateList::FalconPrivateList
EXTRN	??1FalconPrivateList@@UAE@XZ:PROC		; FalconPrivateList::~FalconPrivateList
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	??0WayPointClass@@QAE@FFHHKKEH@Z:PROC		; WayPointClass::WayPointClass
EXTRN	?UnlinkNextWP@WayPointClass@@QAEXXZ:PROC	; WayPointClass::UnlinkNextWP
EXTRN	?InsertWP@WayPointClass@@QAEXPAV1@@Z:PROC	; WayPointClass::InsertWP
EXTRN	?DeleteWP@WayPointClass@@QAEXXZ:PROC		; WayPointClass::DeleteWP
EXTRN	?SetWPTimes@WayPointClass@@QAEXK@Z:PROC		; WayPointClass::SetWPTimes
EXTRN	?DistanceTo@WayPointClass@@QAEMPAV1@@Z:PROC	; WayPointClass::DistanceTo
EXTRN	?SetWPAltitude@WayPointClass@@QAEXH@Z:PROC	; WayPointClass::SetWPAltitude
EXTRN	?SetWPLocation@WayPointClass@@QAEXFF@Z:PROC	; WayPointClass::SetWPLocation
EXTRN	?SetWPTimes@@YAKPAVWayPointClass@@KHH@Z:PROC	; SetWPTimes
EXTRN	?SetWPTimes@@YAKPAVWayPointClass@@FFHH@Z:PROC	; SetWPTimes
EXTRN	?CloneWPList@@YAPAVWayPointClass@@PAV1@@Z:PROC	; CloneWPList
EXTRN	?GetSpotted@CampBaseClass@@QAEHE@Z:PROC		; CampBaseClass::GetSpotted
EXTRN	?GetFirstEntity@@YAPAVCampBaseClass@@PAVVuListIterator@@@Z:PROC ; GetFirstEntity
EXTRN	?GetNextEntity@@YAPAVCampBaseClass@@PAVVuListIterator@@@Z:PROC ; GetNextEntity
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	??1BasePathClass@@QAE@XZ:PROC			; BasePathClass::~BasePathClass
EXTRN	?GetDirection@BasePathClass@@QAEHH@Z:PROC	; BasePathClass::GetDirection
EXTRN	??0PathClass@@QAE@XZ:PROC			; PathClass::PathClass
EXTRN	?GetVehicleID@UnitClass@@QAEFH@Z:PROC		; UnitClass::GetVehicleID
EXTRN	?GetMaxSpeed@UnitClass@@QBEHXZ:PROC		; UnitClass::GetMaxSpeed
EXTRN	?GetCruiseSpeed@UnitClass@@QBEHXZ:PROC		; UnitClass::GetCruiseSpeed
EXTRN	?GetCombatSpeed@UnitClass@@QBEHXZ:PROC		; UnitClass::GetCombatSpeed
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?DistSqu@@YAHFFFF@Z:PROC			; DistSqu
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?DistanceToFront@@YAMFF@Z:PROC			; DistanceToFront
EXTRN	?DirectionTowardFriendly@@YAMFFH@Z:PROC		; DirectionTowardFriendly
EXTRN	?TimeToArrive@@YAKMM@Z:PROC			; TimeToArrive
EXTRN	?DirectionTo@@YAEFFFF@Z:PROC			; DirectionTo
EXTRN	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z:PROC	; FindUnit
EXTRN	?FindEntity@@YAPAVCampBaseClass@@VVU_ID@@@Z:PROC ; FindEntity
EXTRN	?CollectThreatsFast@@YAHFFHEHPAVFalconPrivateList@@@Z:PROC ; CollectThreatsFast
EXTRN	?ScoreThreatFast@@YAHFFHE@Z:PROC		; ScoreThreatFast
EXTRN	?SimToGrid@@YAFM@Z:PROC				; SimToGrid
EXTRN	?GetAltitudeLevel@@YAHH@Z:PROC			; GetAltitudeLevel
EXTRN	?GetAltitudeFromLevel@@YAHHH@Z:PROC		; GetAltitudeFromLevel
EXTRN	?GetGridPath@@YAHPAVBasePathClass@@FFFFHHH@Z:PROC ; GetGridPath
EXTRN	?GetOverrideWP@FlightClass@@QAEPAVWayPointClass@@XZ:PROC ; FlightClass::GetOverrideWP
EXTRN	?SetAssignedTarget@FlightClass@@QAEXVVU_ID@@@Z:PROC ; FlightClass::SetAssignedTarget
EXTRN	?SetOverrideWP@FlightClass@@QAEXPAVWayPointClass@@_N@Z:PROC ; FlightClass::SetOverrideWP
EXTRN	?CalculateFuelAvailable@FlightClass@@QAEJH@Z:PROC ; FlightClass::CalculateFuelAvailable
EXTRN	?FindAlternateStrip@@YAPAVObjectiveClass@@PAVFlightClass@@@Z:PROC ; FindAlternateStrip
EXTRN	?SetTPTime@PackageClass@@QAEXK@Z:PROC		; PackageClass::SetTPTime
EXTRN	?GetRoE@@YAHEEH@Z:PROC				; GetRoE
EXTRN	?GetPriority@@YAHPAVMissionRequestClass@@@Z:PROC ; GetPriority
EXTRN	?FindNearestActiveTanker@AirTaskingManagerClass@@QAEHPAF0PAK@Z:PROC ; AirTaskingManagerClass::FindNearestActiveTanker
EXTRN	??0FalconMissionRequestMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconMissionRequestMessage::FalconMissionRequestMessage
EXTRN	?GetOwner@@YAEPAEFF@Z:PROC			; GetOwner
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?dx@@3PAFA:BYTE					; dx
EXTRN	?dy@@3PAFA:BYTE					; dy
EXTRN	?VisualDetectionRange@@3PAHA:BYTE		; VisualDetectionRange
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?CampFilter@@3VCampBaseFilter@@A:DWORD		; CampFilter
EXTRN	?MaxAltAtLevel@@3PAHA:BYTE			; MaxAltAtLevel
EXTRN	?MinAltAtLevel@@3PAHA:BYTE			; MinAltAtLevel
EXTRN	?QuickSearch@@3HA:DWORD				; QuickSearch
EXTRN	?moveAlt@@3HA:DWORD				; moveAlt
EXTRN	?MIN_AVOID_THREAT@@3FA:WORD			; MIN_AVOID_THREAT
EXTRN	?MIN_AP_DISTANCE@@3FA:WORD			; MIN_AP_DISTANCE
EXTRN	?BREAKPOINT_DISTANCE@@3FA:WORD			; BREAKPOINT_DISTANCE
EXTRN	?LOITER_DIST@@3FA:WORD				; LOITER_DIST
EXTRN	?SWEEP_DISTANCE@@3FA:WORD			; SWEEP_DISTANCE
EXTRN	?MAXIMUM_TANKER_DISTANCE@@3FA:WORD		; MAXIMUM_TANKER_DISTANCE
EXTRN	?AIR_PATH_MAX@@3FA:WORD				; AIR_PATH_MAX
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?maxSearch@@3HA:DWORD				; maxSearch
EXTRN	?g_fClimbRatio@@3MA:DWORD			; g_fClimbRatio
EXTRN	?g_nNoWPRefuelNeeded@@3HA:DWORD			; g_nNoWPRefuelNeeded
EXTRN	?g_bAddIngressWP@@3_NA:BYTE			; g_bAddIngressWP
EXTRN	?LevelIncrement@@3PAHA:BYTE			; LevelIncrement
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_sMissionProfile DD 01H DUP (?)
_sMissionAlt DD	01H DUP (?)
_sTargetAlt DD	01H DUP (?)
_sCruiseAlt DD	01H DUP (?)
_sCurrentAlt DD	01H DUP (?)
_sMissionMode DD 01H DUP (?)
_sRouteAction DD 01H DUP (?)
_sTargetDesc DD	01H DUP (?)
_sCruiseSpeed DD 01H DUP (?)
_sMissionSpeed DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA
_BSS	SEGMENT
?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA DD 01H DUP (?) ; `FinalizeWayPoint'::`2'::nextmode
_BSS	ENDS
_BSS	SEGMENT
_COS_10	DD	01H DUP (?)
_COS_120 DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4a5bba00
CONST	SEGMENT
__real@4a5bba00 DD 04a5bba00r			; 3.6e+006
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@42942e07
CONST	SEGMENT
__real@42942e07 DD 042942e07r			; 74.0899
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40060a91
CONST	SEGMENT
__real@40060a91 DD 040060a91r			; 2.09439
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3fa66666
CONST	SEGMENT
__real@3fa66666 DD 03fa66666r			; 1.3
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f34fdf4
CONST	SEGMENT
__real@3f34fdf4 DD 03f34fdf4r			; 0.707
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0GB@KDIDELCK@?$CF5d?5?$CF4d?5?$CF6d?5?$CF5d?5?$CF14d?5?$CF13d?5?$CF10d?5?$CF@
CONST	SEGMENT
??_C@_0GB@KDIDELCK@?$CF5d?5?$CF4d?5?$CF6d?5?$CF5d?5?$CF14d?5?$CF13d?5?$CF10d?5?$CF@ DB '%'
	DB	'5d %4d %6d %5d %14d %13d %10d %7d %8d %6d %6d %10d %10d %6d %'
	DB	'3d %7d %7d %6d %7d %8d %4d 0x%08x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LE@CMLDGOIL@?1?1?5No?5Type?5Target?5skill?5MissionP@
CONST	SEGMENT
??_C@_0LE@CMLDGOIL@?1?1?5No?5Type?5Target?5skill?5MissionP@ DB '// No Typ'
	DB	'e Target skill MissionProfile TargetProfile TargetDesc RouteW'
	DB	'P TargetWP MinAlt MaxAlt MissionAlt Separation Loiter Str Min'
	DB	'Time MaxTime Escort MinDist Min_Time Caps Flags', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt?$AA@
CONST	SEGMENT
??_C@_02BKFDOEMK@wt?$AA@ DB 'wt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNMLHFGK@Bad?5line?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0N@DNMLHFGK@Bad?5line?5?$CFs?6?$AA@ DB 'Bad line %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JDCKNOBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0EE@JDCKNOBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d'
	DB	' 0x%x', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07CACALAH@mission?$AA@
CONST	SEGMENT
??_C@_07CACALAH@mission?$AA@ DB 'mission', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GILJFNFC@dat?$AA@
CONST	SEGMENT
??_C@_03GILJFNFC@dat?$AA@ DB 'dat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt?$AA@
CONST	SEGMENT
??_C@_02BMJICGCB@rt?$AA@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GNEDMECB@Failed?5to?5find?5a?5path?5to?5target?5@
CONST	SEGMENT
??_C@_0CL@GNEDMECB@Failed?5to?5find?5a?5path?5to?5target?5@ DB 'Failed to'
	DB	' find a path to target at %d,%d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LNFFDOCL@Problem?5?9?5airborne?5flight?5with?5n@
CONST	SEGMENT
??_C@_0CO@LNFFDOCL@Problem?5?9?5airborne?5flight?5with?5n@ DB 'Problem - '
	DB	'airborne flight with no waypoints!n', 00H	; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?CheckForClimb@@YAXPAVWayPointClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForClimb@@YAXPAVWayPointClass@@@Z$0
__unwindtable$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
__unwindtable$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
__unwindtable$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
__unwindtable$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
__unwindtable$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
__unwindtable$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
__unwindtable$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z$0
__unwindtable$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z$0
__unwindtable$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z$0
__unwindtable$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z$0
__unwindtable$?CheckPathThreats@@YAHPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckPathThreats@@YAHPAVUnitClass@@@Z$0
__unwindtable$?RequestMission@MissionRequestClass@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestMission@MissionRequestClass@@QAEHXZ$0
__unwindtable$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$1
__unwindtable$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$1
__unwindtable$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$1
__unwindtable$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z$1
__unwindtable$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z$1
__unwindtable$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z$1
__unwindtable$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z$2
__ehfuncinfo$?CheckForClimb@@YAXPAVWayPointClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckForClimb@@YAXPAVWayPointClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CheckPathThreats@@YAHPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckPathThreats@@YAHPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestMission@MissionRequestClass@@QAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RequestMission@MissionRequestClass@@QAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_COS_10$initializer$ DD FLAT:??__ECOS_10@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_COS_120$initializer$ DD FLAT:??__ECOS_120@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_fp$ = -12						; size = 4
_i$1 = -8						; size = 4
_mp$2 = -4						; size = 4
?WriteMissionData@@YAHXZ PROC				; WriteMissionData

; 2620 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2621 : 	FILE *fp = OpenCampFile("mission", "dat", "wt");

	push	OFFSET ??_C@_02BKFDOEMK@wt?$AA@
	push	OFFSET ??_C@_03GILJFNFC@dat?$AA@
	push	OFFSET ??_C@_07CACALAH@mission?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 2622 : 
; 2623 :     if (fp == NULL) 

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN4@WriteMissi

; 2624 : 		return FALSE;

	xor	eax, eax
	jmp	$LN5@WriteMissi
$LN4@WriteMissi:

; 2625 : 
; 2626 : 	fprintf (fp, "// No Type Target skill MissionProfile TargetProfile TargetDesc "
; 2627 : 	"RouteWP TargetWP MinAlt MaxAlt MissionAlt Separation Loiter "
; 2628 : 	"Str MinTime MaxTime Escort MinDist Min_Time Caps Flags\n");

	push	OFFSET ??_C@_0LE@CMLDGOIL@?1?1?5No?5Type?5Target?5skill?5MissionP@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 2629 :     for (int i = 0; i < sizeof(MissionData)/sizeof(MissionData[0]); i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@WriteMissi
$LN2@WriteMissi:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN3@WriteMissi:
	cmp	DWORD PTR _i$1[ebp], 41			; 00000029H
	jae	$LN1@WriteMissi

; 2630 : 	MissionDataType *mp = &MissionData[i];

	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 5
	add	edx, OFFSET ?MissionData@@3PAUMissionDataType@@A ; MissionData
	mov	DWORD PTR _mp$2[ebp], edx

; 2631 : 	fprintf(fp, 
; 2632 : 	    "%5d %4d %6d %5d %14d %13d %10d %7d %8d %6d %6d %10d %10d %6d %3d %7d %7d %6d %7d %8d %4d 0x%08x\n",
; 2633 : 	    i, 
; 2634 : 	    mp->type,
; 2635 : 	    mp->target,
; 2636 : 	    mp->skill,
; 2637 : 	    mp->mission_profile,
; 2638 : 	    mp->target_profile,
; 2639 : 	    mp->target_desc,
; 2640 : 	    mp->routewp,
; 2641 : 	    mp->targetwp,
; 2642 : 	    mp->minalt,
; 2643 : 	    mp->maxalt,
; 2644 : 	    mp->missionalt,
; 2645 : 	    mp->separation,
; 2646 : 	    mp->loitertime,
; 2647 : 	    mp->str,
; 2648 : 	    mp->min_time,
; 2649 : 	    mp->max_time,
; 2650 : 	    mp->escorttype,
; 2651 : 	    mp->mindistance,
; 2652 : 	    mp->min_time,
; 2653 : 	    mp->caps,
; 2654 : 	    mp->flags);

	mov	eax, DWORD PTR _mp$2[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movzx	eax, BYTE PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movzx	edx, BYTE PTR [ecx+19]
	push	edx
	mov	eax, DWORD PTR _mp$2[ebp]
	movzx	ecx, BYTE PTR [eax+22]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movzx	eax, BYTE PTR [edx+21]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _mp$2[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movzx	eax, BYTE PTR [edx+18]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movsx	edx, WORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _mp$2[ebp]
	movsx	ecx, WORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movsx	eax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movsx	edx, WORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _mp$2[ebp]
	movsx	ecx, WORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movzx	eax, BYTE PTR [edx+7]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movzx	edx, BYTE PTR [ecx+6]
	push	edx
	mov	eax, DWORD PTR _mp$2[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movzx	eax, BYTE PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	push	edx
	mov	eax, DWORD PTR _mp$2[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _mp$2[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _mp$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	push	OFFSET ??_C@_0GB@KDIDELCK@?$CF5d?5?$CF4d?5?$CF6d?5?$CF5d?5?$CF14d?5?$CF13d?5?$CF10d?5?$CF@
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 96					; 00000060H

; 2655 :     }

	jmp	$LN2@WriteMissi
$LN1@WriteMissi:

; 2656 :     fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 2657 :     return TRUE;

	mov	eax, 1
$LN5@WriteMissi:

; 2658 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?WriteMissionData@@YAHXZ ENDP				; WriteMissionData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
;	COMDAT ??__ECOS_120@@YAXXZ
text$yc	SEGMENT
??__ECOS_120@@YAXXZ PROC				; `dynamic initializer for 'COS_120'', COMDAT

; 2045 : static const float COS_10=(float)cos(10*DTR), COS_120=(float)cos(120*DTR);

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@40060a91
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _COS_120
	pop	ebp
	ret	0
??__ECOS_120@@YAXXZ ENDP				; `dynamic initializer for 'COS_120''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
;	COMDAT ??__ECOS_10@@YAXXZ
text$yc	SEGMENT
??__ECOS_10@@YAXXZ PROC					; `dynamic initializer for 'COS_10'', COMDAT

; 2045 : static const float COS_10=(float)cos(10*DTR), COS_120=(float)cos(120*DTR);

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __real@3e32b8c1
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _COS_10
	pop	ebp
	ret	0
??__ECOS_10@@YAXXZ ENDP					; `dynamic initializer for 'COS_10''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
tv189 = -32						; size = 4
_maxdelta$1 = -28					; size = 4
_altd$ = -24						; size = 4
_lw$ = -20						; size = 4
_x$2 = -16						; size = 2
_y$3 = -12						; size = 2
_lx$4 = -8						; size = 2
_ly$5 = -4						; size = 2
_cw$ = 8						; size = 4
?FinalizeFillerWayPoint@@YAXPAVWayPointClass@@@Z PROC	; FinalizeFillerWayPoint

; 523  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 524  : 	int			altd;
; 525  : 	WayPoint	lw;
; 526  : 
; 527  : 	// Check if in coordinated area "In Package" -> i.e: all package elements will fly this waypoint
; 528  : 	if (sMissionMode >= MMODE_AT_ASSEMBLY && sMissionMode <= MMODE_AT_POSTASSEMBLY)

	cmp	DWORD PTR _sMissionMode, 2
	jl	SHORT $LN11@FinalizeFi
	cmp	DWORD PTR _sMissionMode, 8
	jg	SHORT $LN11@FinalizeFi

; 529  : 		{
; 530  : 		cw->SetWPFlag(WPF_IN_PACKAGE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 531  : 		cw->SetWPSpeed((float)sMissionSpeed);

	cvtsi2ss xmm0, DWORD PTR _sMissionSpeed
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed

; 532  : 		}
; 533  : 	else

	jmp	SHORT $LN10@FinalizeFi
$LN11@FinalizeFi:

; 534  : 		cw->SetWPSpeed((float)sCruiseSpeed);

	cvtsi2ss xmm0, DWORD PTR _sCruiseSpeed
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed
$LN10@FinalizeFi:

; 535  : 
; 536  : 	// Check if we should perform our route action or not (depends on target description)
; 537  : // 2001-06-28 MODIFIED BY S.G. sMissionMode TAKES MANY VALUES! DON'T CHECK FOR EQUALITY BUT CHECKS FOR RANGE OF VALUES!
; 538  : //	if ((sMissionMode == MMODE_IN_TARGET_AREA && sTargetDesc <= TDESC_TAO) || ((sMissionMode == MMODE_INGRESS || sMissionMode == MMODE_EGRESS) && sTargetDesc <= TDESC_ATA) || ((sMissionMode == MMODE_ENROUTE || sMissionMode == MMODE_RETURN_TO_BASE) && sTargetDesc <= TDESC_TTL))
; 539  : 	if ((sMissionMode == MMODE_IN_TARGET_AREA && sTargetDesc <= TDESC_TAO) || ((sMissionMode >= MMODE_INGRESS && sMissionMode <= MMODE_EGRESS) && sTargetDesc <= TDESC_ATA) || ((sMissionMode >= MMODE_ENROUTE && sMissionMode <= MMODE_RETURN_TO_BASE) && sTargetDesc <= TDESC_TTL))

	cmp	DWORD PTR _sMissionMode, 5
	jne	SHORT $LN7@FinalizeFi
	cmp	DWORD PTR _sTargetDesc, 3
	jle	SHORT $LN8@FinalizeFi
$LN7@FinalizeFi:
	cmp	DWORD PTR _sMissionMode, 3
	jl	SHORT $LN6@FinalizeFi
	cmp	DWORD PTR _sMissionMode, 7
	jg	SHORT $LN6@FinalizeFi
	cmp	DWORD PTR _sTargetDesc, 2
	jle	SHORT $LN8@FinalizeFi
$LN6@FinalizeFi:
	cmp	DWORD PTR _sMissionMode, 1
	jl	SHORT $LN9@FinalizeFi
	cmp	DWORD PTR _sMissionMode, 9
	jg	SHORT $LN9@FinalizeFi
	cmp	DWORD PTR _sTargetDesc, 1
	jg	SHORT $LN9@FinalizeFi
$LN8@FinalizeFi:

; 540  : 		cw->SetWPRouteAction(sRouteAction);

	mov	eax, DWORD PTR _sRouteAction
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPRouteAction@WayPointClass@@QAEXH@Z ; WayPointClass::SetWPRouteAction
$LN9@FinalizeFi:

; 541  : 
; 542  : 	// Choose altitude
; 543  : 	cw->SetWPAltitude(sCurrentAlt);

	mov	ecx, DWORD PTR _sCurrentAlt
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude

; 544  : 
; 545  : 	// Check for max climb/decent
; 546  : 	lw = cw->GetPrevWP();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _lw$[ebp], eax

; 547  : 	if (lw)

	cmp	DWORD PTR _lw$[ebp], 0
	je	$LN1@FinalizeFi

; 548  : 		{
; 549  : 		altd = sCurrentAlt - lw->GetWPAltitude();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	mov	edx, DWORD PTR _sCurrentAlt
	sub	edx, eax
	mov	DWORD PTR _altd$[ebp], edx

; 550  : 		if (sCurrentAlt > 0 && abs(altd) > GRID_SIZE_FT)

	cmp	DWORD PTR _sCurrentAlt, 0
	jle	$LN1@FinalizeFi
	mov	eax, DWORD PTR _altd$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR __real@454cffae
	jbe	$LN1@FinalizeFi

; 551  : 			{
; 552  : 			// Just climb at max
; 553  : 			GridIndex	x,y,lx,ly;
; 554  : 			int			maxdelta;
; 555  : 			// maxdelta is 1/2 distance we're travelling
; 556  : 			cw->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 557  : 			lw->GetWPLocation(&lx,&ly);

	lea	eax, DWORD PTR _ly$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _lx$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 558  : 			maxdelta = FloatToInt32((Distance(x,y,lx,ly)+1.0F) * g_fClimbRatio * GRID_SIZE_FT);

	movzx	edx, WORD PTR _ly$5[ebp]
	push	edx
	movzx	eax, WORD PTR _lx$4[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$3[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$2[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv189[ebp]
	movss	xmm0, DWORD PTR tv189[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR ?g_fClimbRatio@@3MA
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _maxdelta$1[ebp], eax

; 559  : 			if (maxdelta < abs(altd))

	mov	eax, DWORD PTR _altd$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	cmp	DWORD PTR _maxdelta$1[ebp], eax
	jge	SHORT $LN1@FinalizeFi

; 560  : 				{
; 561  : 				// This climb/decent is to steep. Set altitude to maximum delta.
; 562  : 				if (altd > 0)

	cmp	DWORD PTR _altd$[ebp], 0
	jle	SHORT $LN2@FinalizeFi

; 563  : 					cw->SetWPAltitude( (int)((lw->GetWPAltitude() + maxdelta)/100) * 100);

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	add	eax, DWORD PTR _maxdelta$1[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude
$LN2@FinalizeFi:

; 564  : 				if (altd < 0)

	cmp	DWORD PTR _altd$[ebp], 0
	jge	SHORT $LN1@FinalizeFi

; 565  : 					cw->SetWPAltitude( (int)((lw->GetWPAltitude() - maxdelta)/100) * 100);

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	sub	eax, DWORD PTR _maxdelta$1[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude
$LN1@FinalizeFi:

; 566  : 				}
; 567  : 			}
; 568  : 		}
; 569  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?FinalizeFillerWayPoint@@YAXPAVWayPointClass@@@Z ENDP	; FinalizeFillerWayPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
tv164 = -8						; size = 4
_alt$ = -4						; size = 4
_cw$ = 8						; size = 4
_reset$ = 12						; size = 4
?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z PROC	; FinalizeWayPoint

; 413  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 414  : 	static int	nextmode;
; 415  : 	int			alt = 0;

	mov	DWORD PTR _alt$[ebp], 0

; 416  : 
; 417  : 	if (reset)

	cmp	DWORD PTR _reset$[ebp], 0
	je	SHORT $LN33@FinalizeWa

; 418  : 		nextmode = -1;

	mov	DWORD PTR ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA, -1
$LN33@FinalizeWa:

; 419  : 
; 420  : 	if (nextmode >= 0)

	cmp	DWORD PTR ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA, 0
	jl	SHORT $LN32@FinalizeWa

; 421  : 		{
; 422  : 		sMissionMode = nextmode;

	mov	eax, DWORD PTR ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA
	mov	DWORD PTR _sMissionMode, eax

; 423  : 		nextmode = -1;

	mov	DWORD PTR ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA, -1
$LN32@FinalizeWa:

; 424  : 		}
; 425  : 
; 426  : 	// Check for Takeoff
; 427  : 	if (cw->GetWPAction() == WP_TAKEOFF)

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN31@FinalizeWa

; 428  : 		sMissionMode = MMODE_TAKEOFF;					

	mov	DWORD PTR _sMissionMode, 0
	jmp	SHORT $LN29@FinalizeWa
$LN31@FinalizeWa:

; 429  : 	// Check for Enroute
; 430  : 	else if (sMissionMode == MMODE_TAKEOFF)

	cmp	DWORD PTR _sMissionMode, 0
	jne	SHORT $LN29@FinalizeWa

; 431  : 		sMissionMode = MMODE_ENROUTE;							

	mov	DWORD PTR _sMissionMode, 1
$LN29@FinalizeWa:

; 432  : 	// Check if at assembly point (will be Ingress)
; 433  : 	if (cw->GetWPFlags() & WPF_ASSEMBLE && sMissionMode < MMODE_INGRESS)

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 2
	je	SHORT $LN28@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 3
	jge	SHORT $LN28@FinalizeWa

; 434  : 		{
; 435  : 		sMissionMode = MMODE_AT_ASSEMBLY;

	mov	DWORD PTR _sMissionMode, 2

; 436  : 		nextmode = MMODE_INGRESS;	

	mov	DWORD PTR ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA, 3
$LN28@FinalizeWa:

; 437  : 		}
; 438  : 	// Check if at break point
; 439  : 	if (cw->GetWPFlags() & WPF_BREAKPOINT)

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 4
	je	SHORT $LN27@FinalizeWa

; 440  : 		sMissionMode = MMODE_AT_BREAKPOINT;

	mov	DWORD PTR _sMissionMode, 4
$LN27@FinalizeWa:

; 441  : 	// Check if in target area (Airlift/Aircav missions don't want takeoff waypoints to be in target area)
; 442  : 	if (sMissionMode > MMODE_TAKEOFF && (cw->GetWPFlags() & WPF_IP || cw->GetWPFlags() & WPF_TARGET || cw->GetWPFlags() & WPF_CP))

	cmp	DWORD PTR _sMissionMode, 0
	jle	SHORT $LN26@FinalizeWa
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 8
	jne	SHORT $LN25@FinalizeWa
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	jne	SHORT $LN25@FinalizeWa
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 32					; 00000020H
	je	SHORT $LN26@FinalizeWa
$LN25@FinalizeWa:

; 443  : 		sMissionMode = MMODE_IN_TARGET_AREA;			

	mov	DWORD PTR _sMissionMode, 5
	jmp	SHORT $LN21@FinalizeWa
$LN26@FinalizeWa:

; 444  : 	// Check if at turn point
; 445  : 	else if (cw->GetWPFlags() & WPF_TURNPOINT)

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 16					; 00000010H
	je	SHORT $LN23@FinalizeWa

; 446  : 		sMissionMode = MMODE_AT_TURNPOINT;

	mov	DWORD PTR _sMissionMode, 6
	jmp	SHORT $LN21@FinalizeWa
$LN23@FinalizeWa:

; 447  : 	// Check for Egress
; 448  : 	else if (sMissionMode >= MMODE_IN_TARGET_AREA && sMissionMode < MMODE_EGRESS)

	cmp	DWORD PTR _sMissionMode, 5
	jl	SHORT $LN21@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 7
	jge	SHORT $LN21@FinalizeWa

; 449  : 		sMissionMode = MMODE_EGRESS;			

	mov	DWORD PTR _sMissionMode, 7
$LN21@FinalizeWa:

; 450  : 	// Check for Post assembly (will be RTB)
; 451  : 	if ((cw->GetWPFlags() & WPF_ASSEMBLE) && sMissionMode >= MMODE_EGRESS && sMissionMode < MMODE_RETURN_TO_BASE)

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 2
	je	SHORT $LN20@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 7
	jl	SHORT $LN20@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 9
	jge	SHORT $LN20@FinalizeWa

; 452  : 		{
; 453  : 		sMissionMode = MMODE_AT_POSTASSEMBLY;	

	mov	DWORD PTR _sMissionMode, 8

; 454  : 		nextmode = MMODE_RETURN_TO_BASE;

	mov	DWORD PTR ?nextmode@?1??FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z@4HA, 9
$LN20@FinalizeWa:

; 455  : 		}
; 456  : 	// Check for Landing
; 457  : 	if (cw->GetWPAction() == WP_LAND)

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN19@FinalizeWa

; 458  : 		sMissionMode = MMODE_LANDING;

	mov	DWORD PTR _sMissionMode, 10		; 0000000aH
$LN19@FinalizeWa:

; 459  : 
; 460  : 	// Check if in coordinated area "In Package" -> i.e: all package elements will fly this waypoint
; 461  : 	if (sMissionMode > MMODE_AT_ASSEMBLY && sMissionMode <= MMODE_AT_POSTASSEMBLY)

	cmp	DWORD PTR _sMissionMode, 2
	jle	SHORT $LN18@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 8
	jg	SHORT $LN18@FinalizeWa

; 462  : 		{
; 463  : 		cw->SetWPFlag(WPF_IN_PACKAGE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 464  : 		cw->SetWPSpeed((float)sMissionSpeed);

	cvtsi2ss xmm0, DWORD PTR _sMissionSpeed
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed
	jmp	SHORT $LN15@FinalizeWa
$LN18@FinalizeWa:

; 465  : 		}
; 466  : 	else if (sMissionMode == MMODE_TAKEOFF)

	cmp	DWORD PTR _sMissionMode, 0
	jne	SHORT $LN16@FinalizeWa

; 467  : 		cw->SetWPSpeed(0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed

; 468  : 	else

	jmp	SHORT $LN15@FinalizeWa
$LN16@FinalizeWa:

; 469  : 		cw->SetWPSpeed((float)sCruiseSpeed);

	cvtsi2ss xmm0, DWORD PTR _sCruiseSpeed
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed
$LN15@FinalizeWa:

; 470  : 
; 471  : 	// Check if we should perform our route action or not (depends on target description)
; 472  : // 2001-06-28 MODIFIED BY S.G. sMissionMode TAKES MANY VALUES! DON'T CHECK FOR EQUALITY BUT CHECKS FOR RANGE OF VALUES!
; 473  : //	if ((sMissionMode == MMODE_IN_TARGET_AREA && sTargetDesc <= TDESC_TAO) || ((sMissionMode == MMODE_INGRESS || sMissionMode == MMODE_EGRESS) && sTargetDesc <= TDESC_ATA) || ((sMissionMode == MMODE_ENROUTE || sMissionMode == MMODE_RETURN_TO_BASE) && sTargetDesc <= TDESC_TTL))
; 474  : 	if ((sMissionMode == MMODE_IN_TARGET_AREA && sTargetDesc <= TDESC_TAO) || ((sMissionMode >= MMODE_INGRESS && sMissionMode <= MMODE_EGRESS) && sTargetDesc <= TDESC_ATA) || ((sMissionMode >= MMODE_ENROUTE && sMissionMode <= MMODE_RETURN_TO_BASE) && sTargetDesc <= TDESC_TTL))

	cmp	DWORD PTR _sMissionMode, 5
	jne	SHORT $LN12@FinalizeWa
	cmp	DWORD PTR _sTargetDesc, 3
	jle	SHORT $LN13@FinalizeWa
$LN12@FinalizeWa:
	cmp	DWORD PTR _sMissionMode, 3
	jl	SHORT $LN11@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 7
	jg	SHORT $LN11@FinalizeWa
	cmp	DWORD PTR _sTargetDesc, 2
	jle	SHORT $LN13@FinalizeWa
$LN11@FinalizeWa:
	cmp	DWORD PTR _sMissionMode, 1
	jl	SHORT $LN14@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 9
	jg	SHORT $LN14@FinalizeWa
	cmp	DWORD PTR _sTargetDesc, 1
	jg	SHORT $LN14@FinalizeWa
$LN13@FinalizeWa:

; 475  : 		cw->SetWPRouteAction(sRouteAction);

	mov	ecx, DWORD PTR _sRouteAction
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPRouteAction@WayPointClass@@QAEXH@Z ; WayPointClass::SetWPRouteAction

; 476  : 	else

	jmp	SHORT $LN10@FinalizeWa
$LN14@FinalizeWa:

; 477  : 		cw->SetWPRouteAction(WP_NOTHING);

	push	0
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPRouteAction@WayPointClass@@QAEXH@Z ; WayPointClass::SetWPRouteAction
$LN10@FinalizeWa:

; 478  : 
; 479  : 	// Choose altitude
; 480  : 	switch (sMissionMode)

	mov	edx, DWORD PTR _sMissionMode
	mov	DWORD PTR tv164[ebp], edx
	cmp	DWORD PTR tv164[ebp], 10		; 0000000aH
	ja	SHORT $LN3@FinalizeWa
	mov	eax, DWORD PTR tv164[ebp]
	movzx	ecx, BYTE PTR $LN36@FinalizeWa[eax]
	jmp	DWORD PTR $LN37@FinalizeWa[ecx*4]
$LN7@FinalizeWa:

; 481  : 		{
; 482  : 		case MMODE_TAKEOFF:
; 483  : 		case MMODE_LANDING:
; 484  : 			alt = 0;

	mov	DWORD PTR _alt$[ebp], 0

; 485  : 			break;

	jmp	SHORT $LN8@FinalizeWa
$LN6@FinalizeWa:

; 486  : 		case MMODE_ENROUTE:	
; 487  : 		case MMODE_AT_ASSEMBLY:
; 488  : 		case MMODE_AT_POSTASSEMBLY:
; 489  : 		case MMODE_RETURN_TO_BASE:
; 490  : 			alt = sCruiseAlt;

	mov	edx, DWORD PTR _sCruiseAlt
	mov	DWORD PTR _alt$[ebp], edx

; 491  : 			break;

	jmp	SHORT $LN8@FinalizeWa
$LN5@FinalizeWa:

; 492  : 		case MMODE_INGRESS:
; 493  : 		case MMODE_AT_BREAKPOINT:
; 494  : 		case MMODE_AT_TURNPOINT:
; 495  : 		case MMODE_EGRESS:
; 496  : 			alt = sMissionAlt;

	mov	eax, DWORD PTR _sMissionAlt
	mov	DWORD PTR _alt$[ebp], eax

; 497  : 			break;

	jmp	SHORT $LN8@FinalizeWa
$LN4@FinalizeWa:

; 498  : 		case MMODE_IN_TARGET_AREA:
; 499  : 			alt = sTargetAlt;

	mov	ecx, DWORD PTR _sTargetAlt
	mov	DWORD PTR _alt$[ebp], ecx
$LN3@FinalizeWa:
$LN8@FinalizeWa:

; 500  : 			break;
; 501  : 		default:
; 502  : 			ShiAssert(!"Shouldn't get here");
; 503  : 			break;
; 504  : 		}
; 505  : 	cw->SetWPAltitude(alt);

	mov	edx, DWORD PTR _alt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude

; 506  : 	sCurrentAlt = alt;

	mov	eax, DWORD PTR _alt$[ebp]
	mov	DWORD PTR _sCurrentAlt, eax

; 507  : 
; 508  : 	// Check for max climb/decent
; 509  : 	CheckForClimb(cw);

	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?CheckForClimb@@YAXPAVWayPointClass@@@Z	; CheckForClimb
	add	esp, 4

; 510  : 
; 511  : 	// I've noticed a problem where really high altitudes get generated.
; 512  : 	ShiAssert(cw->GetWPAltitude() < 100000);
; 513  : //	ShiAssert(cw->GetWPAltitude() > 0 || cw->GetWPAction() == WP_LAND || cw->GetWPAction() == WP_TAKEOFF);
; 514  : 
; 515  : 	// Set holdcurrent flag, if we need to
; 516  : 	if (sMissionMode == MMODE_RETURN_TO_BASE || (sMissionMode > MMODE_TAKEOFF && cw->GetWPAltitude() == 0))

	cmp	DWORD PTR _sMissionMode, 9
	je	SHORT $LN1@FinalizeWa
	cmp	DWORD PTR _sMissionMode, 0
	jle	SHORT $LN2@FinalizeWa
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	test	eax, eax
	jne	SHORT $LN2@FinalizeWa
$LN1@FinalizeWa:

; 517  : 		cw->SetWPFlags(cw->GetWPFlags() | WPF_HOLDCURRENT);

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	or	eax, 2048				; 00000800H
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPFlags@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlags
$LN2@FinalizeWa:

; 518  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN37@FinalizeWa:
	DD	$LN7@FinalizeWa
	DD	$LN6@FinalizeWa
	DD	$LN5@FinalizeWa
	DD	$LN4@FinalizeWa
$LN36@FinalizeWa:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	3
	DB	2
	DB	2
	DB	1
	DB	1
	DB	0
?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ENDP	; FinalizeWayPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
tv241 = -64						; size = 4
$T2 = -60						; size = 4
tv147 = -56						; size = 4
$T3 = -52						; size = 4
_alt$ = -48						; size = 4
_maxdelta$4 = -44					; size = 4
_nw$5 = -40						; size = 4
_altd$ = -36						; size = 4
_lw$ = -32						; size = 4
_x$6 = -28						; size = 2
_y$7 = -24						; size = 2
_lx$8 = -20						; size = 2
_ly$9 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
?CheckForClimb@@YAXPAVWayPointClass@@@Z PROC		; CheckForClimb

; 367  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckForClimb@@YAXPAVWayPointClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 368  : 	int			alt,altd;
; 369  : 	WayPoint	lw;
; 370  : 
; 371  : 	// Check for max climb/decent
; 372  : 	alt = cw->GetWPAltitude();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	mov	DWORD PTR _alt$[ebp], eax

; 373  : 	lw = cw->GetPrevWP();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _lw$[ebp], eax

; 374  : 	if (lw)

	cmp	DWORD PTR _lw$[ebp], 0
	je	$LN1@CheckForCl

; 375  : 		{
; 376  : 		altd = alt - lw->GetWPAltitude();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	mov	ecx, DWORD PTR _alt$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _altd$[ebp], ecx

; 377  : 		if (alt > 0 && abs(altd) > GRID_SIZE_FT)

	cmp	DWORD PTR _alt$[ebp], 0
	jle	$LN1@CheckForCl
	mov	edx, DWORD PTR _altd$[ebp]
	push	edx
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR __real@454cffae
	jbe	$LN1@CheckForCl

; 378  : 			{
; 379  : 			GridIndex	x,y,lx,ly;
; 380  : 			int			maxdelta;
; 381  : 			// maxdelta is 1/2 distance we're travelling
; 382  : 			cw->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 383  : 			lw->GetWPLocation(&lx,&ly);

	lea	edx, DWORD PTR _ly$9[ebp]
	push	edx
	lea	eax, DWORD PTR _lx$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 384  : 			if (x == lx && y == ly)

	movsx	ecx, WORD PTR _x$6[ebp]
	movsx	edx, WORD PTR _lx$8[ebp]
	cmp	ecx, edx
	jne	$LN4@CheckForCl
	movsx	eax, WORD PTR _y$7[ebp]
	movsx	ecx, WORD PTR _ly$9[ebp]
	cmp	eax, ecx
	jne	$LN4@CheckForCl

; 385  : 				{
; 386  : 				// Waypoints co-located. need to add a new one
; 387  : 				WayPoint	nw;
; 388  : 				lx = x + SimToGrid((float)altd);

	movsx	esi, WORD PTR _x$6[ebp]
	cvtsi2ss xmm0, DWORD PTR _altd$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	movsx	edx, ax
	add	esi, edx
	mov	WORD PTR _lx$8[ebp], si

; 389  : 				ly = y;

	mov	ax, WORD PTR _y$7[ebp]
	mov	WORD PTR _ly$9[ebp], ax

; 390  : 				nw = new WayPointClass(lx, ly, lw->GetWPAltitude() + altd/2, 0, 0, 0, WP_NOTHING, 0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN9@CheckForCl
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	mov	ecx, eax
	mov	eax, DWORD PTR _altd$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	push	ecx
	movzx	edx, WORD PTR _ly$9[ebp]
	push	edx
	movzx	eax, WORD PTR _lx$8[ebp]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN10@CheckForCl
$LN9@CheckForCl:
	mov	DWORD PTR tv147[ebp], 0
$LN10@CheckForCl:
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _nw$5[ebp], edx

; 391  : 				nw->SetWPRouteAction(lw->GetWPRouteAction());

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPRouteAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPRouteAction
	push	eax
	mov	ecx, DWORD PTR _nw$5[ebp]
	call	?SetWPRouteAction@WayPointClass@@QAEXH@Z ; WayPointClass::SetWPRouteAction

; 392  : 				nw->SetWPSpeed(lw->GetWPSpeed());

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPSpeed@WayPointClass@@QAEMXZ	; WayPointClass::GetWPSpeed
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _nw$5[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed

; 393  : 				lw->InsertWP(nw);

	mov	eax, DWORD PTR _nw$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 394  : 				lw = nw;

	mov	ecx, DWORD PTR _nw$5[ebp]
	mov	DWORD PTR _lw$[ebp], ecx

; 395  : 				altd /= 2;

	mov	eax, DWORD PTR _altd$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _altd$[ebp], eax
$LN4@CheckForCl:

; 396  : 				}
; 397  : 			maxdelta = FloatToInt32((Distance(x,y,lx,ly)+1.0F) * g_fClimbRatio * GRID_SIZE_FT);

	movzx	edx, WORD PTR _ly$9[ebp]
	push	edx
	movzx	eax, WORD PTR _lx$8[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$7[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$6[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR ?g_fClimbRatio@@3MA
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _maxdelta$4[ebp], eax

; 398  : 			if (maxdelta < abs(altd))

	mov	eax, DWORD PTR _altd$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	cmp	DWORD PTR _maxdelta$4[ebp], eax
	jge	SHORT $LN1@CheckForCl

; 399  : 				{
; 400  : 				// This climb/decent is to steep. Set altitude to maximum delta.
; 401  : 				if (altd > 0)

	cmp	DWORD PTR _altd$[ebp], 0
	jle	SHORT $LN2@CheckForCl

; 402  : 					cw->SetWPAltitude( (int)((lw->GetWPAltitude() + maxdelta)/100) * 100);

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	add	eax, DWORD PTR _maxdelta$4[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude
$LN2@CheckForCl:

; 403  : 				if (altd < 0)

	cmp	DWORD PTR _altd$[ebp], 0
	jge	SHORT $LN1@CheckForCl

; 404  : 					cw->SetWPAltitude( (int)((lw->GetWPAltitude() - maxdelta)/100) * 100);

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	sub	eax, DWORD PTR _maxdelta$4[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude
$LN1@CheckForCl:

; 405  : 				}
; 406  : 			}
; 407  : 		}
; 408  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckForClimb@@YAXPAVWayPointClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CheckForClimb@@YAXPAVWayPointClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckForClimb@@YAXPAVWayPointClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckForClimb@@YAXPAVWayPointClass@@@Z ENDP		; CheckForClimb
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
?SetCurrentAltitude@@YAXXZ PROC				; SetCurrentAltitude

; 356  : 	{

	push	ebp
	mov	ebp, esp

; 357  : 	// Generally speaking, we want to use our last current altitude, unless:
; 358  : 	// a) We've just taken off
; 359  : 	if (sMissionMode == MMODE_TAKEOFF)

	cmp	DWORD PTR _sMissionMode, 0
	jne	SHORT $LN2@SetCurrent

; 360  : 		sCurrentAlt = sMissionAlt; // sCruiseAlt;

	mov	eax, DWORD PTR _sMissionAlt
	mov	DWORD PTR _sCurrentAlt, eax
$LN2@SetCurrent:

; 361  : 	// b) We're at our assembly point
; 362  : 	if (sMissionMode == MMODE_AT_ASSEMBLY)

	cmp	DWORD PTR _sMissionMode, 2
	jne	SHORT $LN3@SetCurrent

; 363  : 		sCurrentAlt = sMissionAlt;

	mov	ecx, DWORD PTR _sMissionAlt
	mov	DWORD PTR _sCurrentAlt, ecx
$LN3@SetCurrent:

; 364  : 	}

	pop	ebp
	ret	0
?SetCurrentAltitude@@YAXXZ ENDP				; SetCurrentAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
tv487 = -40						; size = 4
tv468 = -36						; size = 4
tv224 = -32						; size = 4
_dtt$ = -28						; size = 4
_alt_level$ = -24					; size = 4
_minAlt$ = -20						; size = 4
_vc$ = -16						; size = 4
_maxAlt$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
_flight$ = 8						; size = 4
_mis$ = 12						; size = 4
?SetupAltitudes@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; SetupAltitudes

; 239  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 240  : 	VehicleClassDataType*	vc;
; 241  : 	float		dtt;
; 242  : 	int			minAlt,maxAlt;
; 243  : 	GridIndex	x,y;
; 244  : 
; 245  : 	// Collect some usefull data
; 246  : 	vc = GetVehicleClassData(flight->GetVehicleID(0));

	push	0
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 247  : 	flight->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 248  : 	dtt = Distance(x,y,mis->tx,mis->ty);

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dtt$[ebp]

; 249  : 	sRouteAction = MissionData[mis->mission].routewp;

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+6]
	mov	DWORD PTR _sRouteAction, edx

; 250  : 	sTargetDesc = MissionData[mis->mission].target_desc;

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+5]
	mov	DWORD PTR _sTargetDesc, edx

; 251  : 
; 252  : 	// Set speeds
; 253  : 	sCruiseSpeed = flight->GetCruiseSpeed();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	mov	DWORD PTR _sCruiseSpeed, eax

; 254  : 	sMissionSpeed = flight->GetCombatSpeed();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCombatSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCombatSpeed
	mov	DWORD PTR _sMissionSpeed, eax

; 255  : 	if (mis->speed && MissionData[mis->mission].flags & AMIS_MATCHSPEED)

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	ecx, WORD PTR [eax+52]
	test	ecx, ecx
	je	SHORT $LN37@SetupAltit
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	mov	ecx, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+28]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN37@SetupAltit

; 256  : 		sMissionSpeed = mis->speed;

	mov	edx, DWORD PTR _mis$[ebp]
	movsx	eax, WORD PTR [edx+52]
	mov	DWORD PTR _sMissionSpeed, eax
$LN37@SetupAltit:

; 257  : 
; 258  : 	// Pick a profile (This could be done as a result of searching for an ingress path)
; 259  : 	if (MissionData[mis->mission].mission_profile == MPROF_STANDARD)

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	shl	edx, 5
	movzx	eax, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[edx+3]
	cmp	eax, 3
	jne	SHORT $LN36@SetupAltit

; 260  : 		{
; 261  : 		if (TeamInfo[flight->GetTeam()]->atm->averageCAMissions > MAX_ENEMY_CA_MISSIONS_FOR_HIGH_PROFILE)

	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+876]
	movsx	ecx, WORD PTR [eax+154]
	cmp	ecx, 100				; 00000064H
	jle	SHORT $LN35@SetupAltit

; 262  : 			sMissionProfile = MPROF_LOW;

	mov	DWORD PTR _sMissionProfile, 1

; 263  : 		else

	jmp	SHORT $LN34@SetupAltit
$LN35@SetupAltit:

; 264  : 			sMissionProfile = MPROF_HIGH;

	mov	DWORD PTR _sMissionProfile, 2
$LN34@SetupAltit:

; 265  : 		}
; 266  : 	else

	jmp	SHORT $LN33@SetupAltit
$LN36@SetupAltit:

; 267  : 		sMissionProfile = MissionData[mis->mission].mission_profile;

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movzx	ecx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[eax+3]
	mov	DWORD PTR _sMissionProfile, ecx
$LN33@SetupAltit:

; 268  : 
; 269  : 	// Choose an altitude at our target
; 270  : 	minAlt = MissionData[mis->mission].minalt*100;		// Minimum altitude at target

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movsx	ecx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+8]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _minAlt$[ebp], ecx

; 271  : 	maxAlt = MissionData[mis->mission].maxalt*100;		// Maximum altitude at target

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movsx	ecx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+10]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _maxAlt$[ebp], ecx

; 272  : 	if (flight->IsHelicopter() && maxAlt > 0)

	mov	edx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax+992]
	call	edx
	test	eax, eax
	je	SHORT $LN32@SetupAltit
	cmp	DWORD PTR _maxAlt$[ebp], 0
	jle	SHORT $LN32@SetupAltit

; 273  : 		// RV - Biker - Set chopper min/max alt to 500
; 274  : 		//minAlt = maxAlt = 100;
; 275  : 		minAlt = maxAlt = 500;

	mov	DWORD PTR _maxAlt$[ebp], 500		; 000001f4H
	mov	eax, DWORD PTR _maxAlt$[ebp]
	mov	DWORD PTR _minAlt$[ebp], eax

; 276  : 	else

	jmp	SHORT $LN29@SetupAltit
$LN32@SetupAltit:

; 277  : 		{
; 278  : 		if (maxAlt > vc->HighAlt*100)

	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+48]
	imul	edx, 100				; 00000064H
	cmp	DWORD PTR _maxAlt$[ebp], edx
	jle	SHORT $LN30@SetupAltit

; 279  : 			maxAlt = vc->HighAlt*100;

	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+48]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _maxAlt$[ebp], ecx
$LN30@SetupAltit:

; 280  : 		if (minAlt < vc->LowAlt*100)

	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+50]
	imul	eax, 100				; 00000064H
	cmp	DWORD PTR _minAlt$[ebp], eax
	jge	SHORT $LN29@SetupAltit

; 281  : 			minAlt = vc->LowAlt*100;

	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+50]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _minAlt$[ebp], edx
$LN29@SetupAltit:

; 282  : 		}
; 283  : 	switch (mis->mission)

	mov	eax, DWORD PTR _mis$[ebp]
	mov	cl, BYTE PTR [eax+60]
	mov	BYTE PTR tv224[ebp], cl
	cmp	BYTE PTR tv224[ebp], 29			; 0000001dH
	je	SHORT $LN26@SetupAltit
	jmp	SHORT $LN24@SetupAltit
$LN26@SetupAltit:

; 284  : 		{
; 285  : 		case AMIS_RECON:
; 286  : 			if (flight->GetSType() == STYPE_UNIT_RECON)

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	cmp	edx, 11					; 0000000bH
	jne	SHORT $LN25@SetupAltit

; 287  : 				{
; 288  : 				minAlt = maxAlt = vc->HighAlt*100;

	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+48]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _maxAlt$[ebp], ecx
	mov	edx, DWORD PTR _maxAlt$[ebp]
	mov	DWORD PTR _minAlt$[ebp], edx

; 289  : 				sMissionProfile = MPROF_HIGH;

	mov	DWORD PTR _sMissionProfile, 2
$LN25@SetupAltit:
$LN24@SetupAltit:

; 290  : 				}
; 291  : 			break;
; 292  : 		default:
; 293  : 			break;
; 294  : 		}
; 295  : 	// Use mission alt by default
; 296  : 	if (sMissionProfile == MPROF_LOW)

	cmp	DWORD PTR _sMissionProfile, 1
	jne	SHORT $LN23@SetupAltit

; 297  : 		sTargetAlt = vc->LowAlt*100;

	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+50]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _sTargetAlt, ecx
	jmp	SHORT $LN20@SetupAltit
$LN23@SetupAltit:

; 298  : 	else if (sMissionProfile == MPROF_HIGH)

	cmp	DWORD PTR _sMissionProfile, 2
	jne	SHORT $LN21@SetupAltit

; 299  : 		sTargetAlt = vc->HighAlt*100;

	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+48]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _sTargetAlt, eax

; 300  : 	else

	jmp	SHORT $LN20@SetupAltit
$LN21@SetupAltit:

; 301  : 		sTargetAlt = MissionData[mis->mission].missionalt*100;

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	shl	edx, 5
	movsx	eax, WORD PTR ?MissionData@@3PAUMissionDataType@@A[edx+12]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _sTargetAlt, eax
$LN20@SetupAltit:

; 302  : 	if (sTargetAlt < minAlt)

	mov	ecx, DWORD PTR _sTargetAlt
	cmp	ecx, DWORD PTR _minAlt$[ebp]
	jge	SHORT $LN19@SetupAltit

; 303  : 		sTargetAlt = minAlt;

	mov	edx, DWORD PTR _minAlt$[ebp]
	mov	DWORD PTR _sTargetAlt, edx
$LN19@SetupAltit:

; 304  : 	if (sTargetAlt > maxAlt)

	mov	eax, DWORD PTR _sTargetAlt
	cmp	eax, DWORD PTR _maxAlt$[ebp]
	jle	SHORT $LN18@SetupAltit

; 305  : 		sTargetAlt = maxAlt;

	mov	ecx, DWORD PTR _maxAlt$[ebp]
	mov	DWORD PTR _sTargetAlt, ecx
$LN18@SetupAltit:

; 306  : 	if (MissionData[mis->mission].target_profile != TPROF_FLYBY && MissionData[mis->mission].target_profile != TPROF_NONE)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movzx	ecx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[eax+4]
	cmp	ecx, 7
	je	SHORT $LN17@SetupAltit
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movzx	ecx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[eax+4]
	test	ecx, ecx
	je	SHORT $LN17@SetupAltit

; 307  : 		{
; 308  : 		// Find a target alt based on threat as well
; 309  : 		sTargetAlt = (sTargetAlt + MissionData[mis->mission].missionalt*100)/2;

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movsx	eax, WORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+12]
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _sTargetAlt
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _sTargetAlt, eax

; 310  : 		sTargetAlt = CheckBestAltitude(mis->tx, mis->ty, flight->GetTeam(), minAlt, maxAlt, sTargetAlt, TT_TOTAL);

	push	1
	mov	ecx, DWORD PTR _sTargetAlt
	push	ecx
	mov	edx, DWORD PTR _maxAlt$[ebp]
	push	edx
	mov	eax, DWORD PTR _minAlt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	call	?CheckBestAltitude@@YAHFFEHHHH@Z	; CheckBestAltitude
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _sTargetAlt, eax
$LN17@SetupAltit:

; 311  : 		}
; 312  : 
; 313  : 	// Pick a Mission Altitude
; 314  : 	if (dtt < MIN_DIST_FOR_INGRESS || DistanceToFront(mis->tx,mis->ty) < MIN_DIST_FOR_INGRESS/2)

	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR _dtt$[ebp]
	ja	SHORT $LN15@SetupAltit
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR tv468[ebp]
	movss	xmm0, DWORD PTR __real@41c80000
	comiss	xmm0, DWORD PTR tv468[ebp]
	jbe	SHORT $LN16@SetupAltit
$LN15@SetupAltit:

; 315  : 		sMissionAlt = sTargetAlt;

	mov	ecx, DWORD PTR _sTargetAlt
	mov	DWORD PTR _sMissionAlt, ecx
	jmp	SHORT $LN10@SetupAltit
$LN16@SetupAltit:

; 316  : 	else if (sMissionProfile == MPROF_LOW)

	cmp	DWORD PTR _sMissionProfile, 1
	jne	SHORT $LN13@SetupAltit

; 317  : 		sMissionAlt = vc->LowAlt*100;

	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+50]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _sMissionAlt, eax
	jmp	SHORT $LN10@SetupAltit
$LN13@SetupAltit:

; 318  : 	else if (sMissionProfile == MPROF_HIGH)

	cmp	DWORD PTR _sMissionProfile, 2
	jne	SHORT $LN11@SetupAltit

; 319  : 		sMissionAlt = vc->HighAlt*100;

	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+48]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _sMissionAlt, edx

; 320  : 	else

	jmp	SHORT $LN10@SetupAltit
$LN11@SetupAltit:

; 321  : 		sMissionAlt = MissionData[mis->mission].missionalt*100;

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movsx	edx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+12]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _sMissionAlt, edx
$LN10@SetupAltit:

; 322  : 	if (sMissionAlt < minAlt)

	mov	eax, DWORD PTR _sMissionAlt
	cmp	eax, DWORD PTR _minAlt$[ebp]
	jge	SHORT $LN9@SetupAltit

; 323  : 		sMissionAlt = minAlt;

	mov	ecx, DWORD PTR _minAlt$[ebp]
	mov	DWORD PTR _sMissionAlt, ecx
$LN9@SetupAltit:

; 324  : 	if (sMissionAlt > maxAlt)

	mov	edx, DWORD PTR _sMissionAlt
	cmp	edx, DWORD PTR _maxAlt$[ebp]
	jle	SHORT $LN8@SetupAltit

; 325  : 		sMissionAlt = maxAlt;

	mov	eax, DWORD PTR _maxAlt$[ebp]
	mov	DWORD PTR _sMissionAlt, eax
$LN8@SetupAltit:

; 326  : 
; 327  : 	// Find our Cruise Altitude
; 328  : 	if (dtt < MIN_DIST_FOR_INGRESS)

	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR _dtt$[ebp]
	jbe	SHORT $LN7@SetupAltit

; 329  : 		sCruiseAlt = sTargetAlt;

	mov	ecx, DWORD PTR _sTargetAlt
	mov	DWORD PTR _sCruiseAlt, ecx
	jmp	SHORT $LN4@SetupAltit
$LN7@SetupAltit:

; 330  : 	else if (DistanceToFront(x,y) < MIN_DIST_FOR_CRUISE)

	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR tv487[ebp]
	movss	xmm0, DWORD PTR __real@41f00000
	comiss	xmm0, DWORD PTR tv487[ebp]
	jbe	SHORT $LN5@SetupAltit

; 331  : 		sCruiseAlt = sMissionAlt;

	mov	ecx, DWORD PTR _sMissionAlt
	mov	DWORD PTR _sCruiseAlt, ecx

; 332  : 	else

	jmp	SHORT $LN4@SetupAltit
$LN5@SetupAltit:

; 333  : 		sCruiseAlt = vc->CruiseAlt*100;						// Cruise altitude (over friendly territory)

	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+52]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _sCruiseAlt, eax
$LN4@SetupAltit:

; 334  : 
; 335  : 	// Randomize our altitudes some
; 336  : 	int	alt_level;
; 337  : 	alt_level = GetAltitudeLevel(sMissionAlt);

	mov	ecx, DWORD PTR _sMissionAlt
	push	ecx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR _alt_level$[ebp], eax

; 338  : 	sMissionAlt += LevelIncrement[alt_level] * (mis->tx+mis->ty)%(alt_level+1);

	mov	edx, DWORD PTR _mis$[ebp]
	movsx	eax, WORD PTR [edx+40]
	mov	ecx, DWORD PTR _mis$[ebp]
	movsx	edx, WORD PTR [ecx+42]
	add	eax, edx
	mov	ecx, DWORD PTR _alt_level$[ebp]
	imul	eax, DWORD PTR ?LevelIncrement@@3PAHA[ecx*4]
	mov	ecx, DWORD PTR _alt_level$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx
	add	edx, DWORD PTR _sMissionAlt
	mov	DWORD PTR _sMissionAlt, edx

; 339  : 	alt_level = GetAltitudeLevel(sTargetAlt);

	mov	edx, DWORD PTR _sTargetAlt
	push	edx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR _alt_level$[ebp], eax

; 340  : 	sTargetAlt += LevelIncrement[alt_level] * (mis->tx+mis->ty)%(alt_level+1);

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	mov	edx, DWORD PTR _mis$[ebp]
	movsx	eax, WORD PTR [edx+42]
	add	ecx, eax
	mov	edx, DWORD PTR _alt_level$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR ?LevelIncrement@@3PAHA[edx*4]
	mov	ecx, DWORD PTR _alt_level$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx
	add	edx, DWORD PTR _sTargetAlt
	mov	DWORD PTR _sTargetAlt, edx

; 341  : 	alt_level = GetAltitudeLevel(sCruiseAlt);

	mov	edx, DWORD PTR _sCruiseAlt
	push	edx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR _alt_level$[ebp], eax

; 342  : 	sCruiseAlt += LevelIncrement[alt_level] * (mis->tx+mis->ty)%(alt_level+1);

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	mov	edx, DWORD PTR _mis$[ebp]
	movsx	eax, WORD PTR [edx+42]
	add	ecx, eax
	mov	edx, DWORD PTR _alt_level$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR ?LevelIncrement@@3PAHA[edx*4]
	mov	ecx, DWORD PTR _alt_level$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx
	add	edx, DWORD PTR _sCruiseAlt
	mov	DWORD PTR _sCruiseAlt, edx

; 343  : 
; 344  : 	// 2001-12-31 ADDED BY S.G. Lets snap the altitude to increments of 500.
; 345  : 	if (sMissionAlt > 500)

	cmp	DWORD PTR _sMissionAlt, 500		; 000001f4H
	jle	SHORT $LN3@SetupAltit

; 346  : 		sMissionAlt = ((sMissionAlt + 250) / 500) * 500;

	mov	eax, DWORD PTR _sMissionAlt
	add	eax, 250				; 000000faH
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	imul	eax, 500				; 000001f4H
	mov	DWORD PTR _sMissionAlt, eax
$LN3@SetupAltit:

; 347  : 	if (sTargetAlt > 500)

	cmp	DWORD PTR _sTargetAlt, 500		; 000001f4H
	jle	SHORT $LN2@SetupAltit

; 348  : 		sTargetAlt = ((sTargetAlt + 250) / 500) * 500;

	mov	eax, DWORD PTR _sTargetAlt
	add	eax, 250				; 000000faH
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	imul	eax, 500				; 000001f4H
	mov	DWORD PTR _sTargetAlt, eax
$LN2@SetupAltit:

; 349  : 	if (sCruiseAlt > 500)

	cmp	DWORD PTR _sCruiseAlt, 500		; 000001f4H
	jle	SHORT $LN1@SetupAltit

; 350  : 		sCruiseAlt = ((sCruiseAlt + 250) / 500) * 500;

	mov	eax, DWORD PTR _sCruiseAlt
	add	eax, 250				; 000000faH
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	imul	eax, 500				; 000001f4H
	mov	DWORD PTR _sCruiseAlt, eax
$LN1@SetupAltit:

; 351  : 	// END OF ADDED SECTION
; 352  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SetupAltitudes@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; SetupAltitudes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_pack$ = -104						; size = 4
$T2 = -100						; size = 4
$T3 = -96						; size = 4
tv168 = -92						; size = 4
$T4 = -88						; size = 4
tv142 = -84						; size = 4
$T5 = -80						; size = 4
_bw$ = -76						; size = 4
_bs$ = -72						; size = 4
_fh$ = -68						; size = 4
_s$ = -64						; size = 4
_d$ = -60						; size = 4
_i$ = -56						; size = 4
_h$ = -52						; size = 4
_nw$ = -48						; size = 4
_eax$ = -44						; size = 2
_eay$ = -40						; size = 2
_y$ = -36						; size = 2
_x$ = -32						; size = 2
_bx$ = -28						; size = 2
_by$ = -24						; size = 2
_ty$ = -20						; size = 2
_tx$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddExitRoute

; 1142 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1143 : 	WayPoint		nw,bw;
; 1144 : 	GridIndex		eax,eay,bx,by,tx,ty,x,y;
; 1145 : 	Unit			pack;
; 1146 : 	int				i,s,bs=99999,fh,h,d;

	mov	DWORD PTR _bs$[ebp], 99999		; 0001869fH

; 1147 : 
; 1148 : 	pack = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 1149 : 
; 1150 : 	// Find a good egress direction (from target or turn point)
; 1151 : 	cw->GetWPLocation(&tx,&ty);						// Last way point (Turn point or target)

	lea	ecx, DWORD PTR _ty$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1152 : 	fh = (int)DirectionTo(mis->tx,mis->ty,tx,ty);

	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	call	?DirectionTo@@YAEFFFF@Z			; DirectionTo
	add	esp, 16					; 00000010H
	movzx	eax, al
	mov	DWORD PTR _fh$[ebp], eax

; 1153 : 	if (fh == Here)

	cmp	DWORD PTR _fh$[ebp], 8
	jne	SHORT $LN8@AddExitRou

; 1154 : 		{
; 1155 : 		nw = cw->GetPrevWP();	// Pre-target WP

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _nw$[ebp], eax

; 1156 : 		nw->GetWPLocation(&tx,&ty);

	lea	ecx, DWORD PTR _ty$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1157 : 		fh = (int)(DirectionTo(mis->tx,mis->ty,tx,ty) + 4)%8;

	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	call	?DirectionTo@@YAEFFFF@Z			; DirectionTo
	add	esp, 16					; 00000010H
	movzx	eax, al
	add	eax, 4
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN18@AddExitRou
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN18@AddExitRou:
	mov	DWORD PTR _fh$[ebp], eax
$LN8@AddExitRou:

; 1158 : 		}
; 1159 : 	// Add the new WP to path (note: it's location hasn't been determined yet)
; 1160 : 	nw = new WayPointClass(0, 0, 0, 0, 0, 0, WP_NOTHING, 0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN11@AddExitRou
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN12@AddExitRou
$LN11@AddExitRou:
	mov	DWORD PTR tv142[ebp], 0
$LN12@AddExitRou:
	mov	ecx, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _nw$[ebp], edx

; 1161 : 	FinalizeWayPoint(nw);

	push	0
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1162 : 	cw->InsertWP(nw);

	mov	ecx, DWORD PTR _nw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1163 : 
; 1164 : 	// Now add the home bases' location, for checking best exit route
; 1165 : 	u->GetLocation(&bx,&by);

	lea	edx, DWORD PTR _by$[ebp]
	push	edx
	lea	eax, DWORD PTR _bx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1166 : 	bw = new WayPointClass(bx, by, 0, 0, 0, 0, WP_LAND, WPF_LAND | WPF_HOLDCURRENT);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN13@AddExitRou
	push	2304					; 00000900H
	push	7
	push	0
	push	0
	push	0
	push	0
	movzx	ecx, WORD PTR _by$[ebp]
	push	ecx
	movzx	edx, WORD PTR _bx$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN14@AddExitRou
$LN13@AddExitRou:
	mov	DWORD PTR tv168[ebp], 0
$LN14@AddExitRou:
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _bw$[ebp], ecx

; 1167 : 	bw->SetWPFlags(WPF_LAND);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?SetWPFlags@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlags

; 1168 : 	nw->InsertWP(bw);

	mov	edx, DWORD PTR _bw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1169 : 
; 1170 : 	eax = bx;

	mov	ax, WORD PTR _bx$[ebp]
	mov	WORD PTR _eax$[ebp], ax

; 1171 : 	eay = by;

	mov	cx, WORD PTR _by$[ebp]
	mov	WORD PTR _eay$[ebp], cx

; 1172 : 
; 1173 : 	// Now determine best exit direction
; 1174 : 	for (i=3; i<7; i++)

	mov	DWORD PTR _i$[ebp], 3
	jmp	SHORT $LN7@AddExitRou
$LN6@AddExitRou:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@AddExitRou:
	cmp	DWORD PTR _i$[ebp], 7
	jge	$LN5@AddExitRou

; 1175 : 		{
; 1176 : 		h = (fh + HDelta[i] + 8)%8;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?HDelta@@3PAHA[eax*4]
	mov	edx, DWORD PTR _fh$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN19@AddExitRou
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN19@AddExitRou:
	mov	DWORD PTR _h$[ebp], eax

; 1177 : 		if (dx[h] && dy[h])

	mov	ecx, DWORD PTR _h$[ebp]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	test	edx, edx
	je	SHORT $LN4@AddExitRou
	mov	eax, DWORD PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dy@@3PAFA[eax*2]
	test	ecx, ecx
	je	SHORT $LN4@AddExitRou

; 1178 : 			d = FloatToInt32(0.707F * BREAKPOINT_DISTANCE);

	movsx	edx, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f34fdf4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 1179 : 		else

	jmp	SHORT $LN3@AddExitRou
$LN4@AddExitRou:

; 1180 : 			d = BREAKPOINT_DISTANCE;

	movsx	eax, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	mov	DWORD PTR _d$[ebp], eax
$LN3@AddExitRou:

; 1181 : 		x = tx + dx[h] * d;

	movsx	ecx, WORD PTR _tx$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	imul	eax, DWORD PTR _d$[ebp]
	add	ecx, eax
	mov	WORD PTR _x$[ebp], cx

; 1182 : 		y = ty + dy[h] * d;

	movsx	ecx, WORD PTR _ty$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	movsx	eax, WORD PTR ?dy@@3PAFA[edx*2]
	imul	eax, DWORD PTR _d$[ebp]
	add	ecx, eax
	mov	WORD PTR _y$[ebp], cx

; 1183 : 		s = ScoreThreatFast(x,y,GetAltitudeLevel(sMissionAlt),u->GetTeam()) + i;

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _sMissionAlt
	push	edx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 1184 : 		s += ScoreThreatFast(x+dx[h]*d,y+dy[h]*d,GetAltitudeLevel(sMissionAlt),u->GetTeam());

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _sMissionAlt
	push	ecx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movsx	edx, WORD PTR _y$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dy@@3PAFA[eax*2]
	imul	ecx, DWORD PTR _d$[ebp]
	add	edx, ecx
	push	edx
	movsx	edx, WORD PTR _x$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dx@@3PAFA[eax*2]
	imul	ecx, DWORD PTR _d$[ebp]
	add	edx, ecx
	push	edx
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 1185 : 		if (s < bs || (s==bs && DistSqu(x,y,bx,by) < DistSqu(eax,eay,bx,by)))

	mov	edx, DWORD PTR _s$[ebp]
	cmp	edx, DWORD PTR _bs$[ebp]
	jl	SHORT $LN1@AddExitRou
	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _bs$[ebp]
	jne	SHORT $LN2@AddExitRou
	movzx	ecx, WORD PTR _by$[ebp]
	push	ecx
	movzx	edx, WORD PTR _bx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	mov	esi, eax
	movzx	edx, WORD PTR _by$[ebp]
	push	edx
	movzx	eax, WORD PTR _bx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _eay$[ebp]
	push	ecx
	movzx	edx, WORD PTR _eax$[ebp]
	push	edx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jge	SHORT $LN2@AddExitRou
$LN1@AddExitRou:

; 1186 : 			{
; 1187 : 			eax = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _eax$[ebp], ax

; 1188 : 			eay = y;

	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _eay$[ebp], cx

; 1189 : 			bs = s;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _bs$[ebp], edx
$LN2@AddExitRou:

; 1190 : 			}
; 1191 : 		}

	jmp	$LN6@AddExitRou
$LN5@AddExitRou:

; 1192 : 	//if this asserts ScoreThreatFast probably has an error
; 1193 : 	ShiAssert(bs < 99999);
; 1194 : 	nw->SetWPLocation(eax,eay);

	movzx	eax, WORD PTR _eay$[ebp]
	push	eax
	movzx	ecx, WORD PTR _eax$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPLocation@WayPointClass@@QAEXFF@Z	; WayPointClass::SetWPLocation

; 1195 : 	cw = nw;

	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _cw$[ebp], edx

; 1196 : 
; 1197 : 	// Now delete the home base waypoint (we'll add this when we do our egress
; 1198 : 	bw->DeleteWP ();

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 1199 : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 1200 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddExitRoute
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_pack$ = -12						; size = 4
_nw$ = -8						; size = 4
_temp$1 = -4						; size = 4
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddEgressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddEgressPath

; 1113 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1114 : 	WayPoint			nw;
; 1115 : 	Package				pack;
; 1116 : 
; 1117 : 	pack = (Package)u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 1118 : 	nw = CloneWPList(pack->GetEgress());

	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetEgress@PackageClass@@QAEPAVWayPointClass@@XZ ; PackageClass::GetEgress
	push	eax
	call	?CloneWPList@@YAPAVWayPointClass@@PAV1@@Z ; CloneWPList
	add	esp, 4
	mov	DWORD PTR _nw$[ebp], eax

; 1119 : 	if (MissionData[mis->mission].flags & AMIS_DONT_COORD)

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	shl	edx, 5
	mov	eax, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[edx+28]
	and	eax, 1048576				; 00100000H
	je	SHORT $LN5@AddEgressP

; 1120 : 		{
; 1121 : 		// Don't tie egress times to package
; 1122 : 		WayPoint temp = nw;

	mov	ecx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _temp$1[ebp], ecx
$LN4@AddEgressP:

; 1123 : 		while (temp)

	cmp	DWORD PTR _temp$1[ebp], 0
	je	SHORT $LN5@AddEgressP

; 1124 : 			{
; 1125 : 			temp->SetWPTimes(0);

	push	0
	mov	ecx, DWORD PTR _temp$1[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes

; 1126 : 			temp = temp->GetNextWP();

	mov	ecx, DWORD PTR _temp$1[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _temp$1[ebp], eax

; 1127 : 			}

	jmp	SHORT $LN4@AddEgressP
$LN5@AddEgressP:

; 1128 : 		}
; 1129 : 	cw->InsertWP(nw);

	mov	edx, DWORD PTR _nw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1130 : 	cw = nw;

	mov	eax, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _cw$[ebp], eax
$LN2@AddEgressP:

; 1131 : 	while (cw && cw->GetNextWP())

	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN1@AddEgressP
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN1@AddEgressP

; 1132 : 		{
; 1133 : 		FinalizeWayPoint(cw);

	push	0
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1134 : 		cw = cw->GetNextWP();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _cw$[ebp], eax

; 1135 : 		}

	jmp	SHORT $LN2@AddEgressP
$LN1@AddEgressP:

; 1136 : 	FinalizeWayPoint(cw);

	push	0
	mov	edx, DWORD PTR _cw$[ebp]
	push	edx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1137 : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 1138 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AddEgressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddEgressPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_tw$ = -60						; size = 4
$T2 = -56						; size = 4
_pack$ = -52						; size = 4
tv90 = -48						; size = 4
$T3 = -44						; size = 4
_bw$ = -40						; size = 4
_dw$ = -36						; size = 4
_nw$ = -32						; size = 4
_eax$ = -28						; size = 2
_eay$ = -24						; size = 2
_bx$ = -20						; size = 2
_by$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; SetupEgressPoints

; 1075 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1076 : 	WayPoint		nw,bw,tw,dw;
; 1077 : 	GridIndex		eax,eay,bx,by;
; 1078 : 	Unit			pack;
; 1079 : 	
; 1080 : 	pack = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 1081 : 
; 1082 : 	// Finalize route from exit WP to base
; 1083 : 	u->GetLocation(&bx,&by);

	lea	ecx, DWORD PTR _by$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1084 : 	bw = new WayPointClass(bx, by, 0, 0, 0, 0, WP_LAND, WPF_LAND | WPF_HOLDCURRENT);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@SetupEgres
	push	2304					; 00000900H
	push	7
	push	0
	push	0
	push	0
	push	0
	movzx	eax, WORD PTR _by$[ebp]
	push	eax
	movzx	ecx, WORD PTR _bx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@SetupEgres
$LN6@SetupEgres:
	mov	DWORD PTR tv90[ebp], 0
$LN7@SetupEgres:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _bw$[ebp], eax

; 1085 : 	cw->InsertWP(bw);

	mov	ecx, DWORD PTR _bw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1086 : 	if (!CheckSafePath(cw,bw,u))

	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _bw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?CheckSafePath@@YAPAVWayPointClass@@PAV1@0PAVFlightClass@@@Z ; CheckSafePath
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SetupEgres

; 1087 : 		return 0;

	xor	eax, eax
	jmp	$LN4@SetupEgres
$LN3@SetupEgres:

; 1088 : 
; 1089 : 	// Find a safe location for a post assembly point and add it to the list
; 1090 : 	nw = AddSafeWaypoint(bw,cw,1,MIN_AP_DISTANCE,u->GetTeam());

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	movsx	ecx, WORD PTR ?MIN_AP_DISTANCE@@3FA	; MIN_AP_DISTANCE
	push	ecx
	push	1
	mov	edx, DWORD PTR _cw$[ebp]
	push	edx
	mov	eax, DWORD PTR _bw$[ebp]
	push	eax
	call	?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z ; AddSafeWaypoint
	add	esp, 20					; 00000014H
	mov	DWORD PTR _nw$[ebp], eax

; 1091 : 	nw->GetWPLocation(&eax,&eay);

	lea	ecx, DWORD PTR _eay$[ebp]
	push	ecx
	lea	edx, DWORD PTR _eax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1092 : 	pack->SetUnitAssemblyPoint(1,eax,eay);

	movzx	eax, WORD PTR _eay$[ebp]
	push	eax
	movzx	ecx, WORD PTR _eax$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [eax+808]
	call	edx

; 1093 : 	nw->SetWPAction(WP_POSTASSEMBLE);

	push	3
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPAction@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAction

; 1094 : 	nw->SetWPFlag(WPF_HOLDCURRENT);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 1095 : 	nw->SetWPRouteAction(WP_NOTHING);

	push	0
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPRouteAction@WayPointClass@@QAEXH@Z ; WayPointClass::SetWPRouteAction

; 1096 : 	FinalizeWayPoint(nw);

	push	0
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1097 : 	dw = nw->GetNextWP();

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _dw$[ebp], eax
$LN2@SetupEgres:

; 1098 : 
; 1099 : 	// Remove remaining waypoint from assembly point to base - We'll add them in later with
; 1100 : 	// another scheme.
; 1101 : 	while (dw)

	cmp	DWORD PTR _dw$[ebp], 0
	je	SHORT $LN1@SetupEgres

; 1102 : 		{
; 1103 : 		tw = dw->GetNextWP();

	mov	ecx, DWORD PTR _dw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tw$[ebp], eax

; 1104 : 		dw->DeleteWP ();

	mov	ecx, DWORD PTR _dw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 1105 : 		dw = tw;

	mov	ecx, DWORD PTR _tw$[ebp]
	mov	DWORD PTR _dw$[ebp], ecx

; 1106 : 		}

	jmp	SHORT $LN2@SetupEgres
$LN1@SetupEgres:

; 1107 : 
; 1108 : 	return nw;

	mov	eax, DWORD PTR _nw$[ebp]
$LN4@SetupEgres:

; 1109 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; SetupEgressPoints
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_fw$ = -108						; size = 4
$T2 = -104						; size = 4
_ch$ = -100						; size = 4
_fh$ = -96						; size = 4
tv133 = -92						; size = 4
_bs$ = -88						; size = 4
$T3 = -84						; size = 4
_d$ = -80						; size = 4
_score$ = -76						; size = 4
_h$ = -72						; size = 4
_i$ = -68						; size = 4
_ls$ = -64						; size = 4
_sw$ = -60						; size = 4
_s$ = -56						; size = 4
_y$ = -52						; size = 2
_x$ = -48						; size = 2
_ad$ = -44						; size = 12
_sx$ = -32						; size = 6
_sy$ = -24						; size = 6
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddSweepProfile

; 989  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 990  : 	GridIndex	sx[3],sy[3],x,y;
; 991  : 	int			i,s,ls,score,bs,fh,ch,h,d;
; 992  : 	int			ad[3] = { -2, 0, 2 };

	mov	DWORD PTR _ad$[ebp], -2			; fffffffeH
	mov	DWORD PTR _ad$[ebp+4], 0
	mov	DWORD PTR _ad$[ebp+8], 2

; 993  : 	WayPoint	sw,fw;
; 994  : 
; 995  : 	// Sweep around mission destination point
; 996  : 	u->GetLocation (&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 997  : 	fh = (int)DirectionTo(x,y,mis->tx,mis->ty);

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?DirectionTo@@YAEFFFF@Z			; DirectionTo
	add	esp, 16					; 00000010H
	movzx	edx, al
	mov	DWORD PTR _fh$[ebp], edx

; 998  : 	fw = cw;

	mov	eax, DWORD PTR _cw$[ebp]
	mov	DWORD PTR _fw$[ebp], eax

; 999  : 
; 1000 : 	// Look around for safe spots (we want 3)
; 1001 : 	for (s=0; s<3; s++)

	mov	DWORD PTR _s$[ebp], 0
	jmp	SHORT $LN13@AddSweepPr
$LN12@AddSweepPr:
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN13@AddSweepPr:
	cmp	DWORD PTR _s$[ebp], 3
	jge	$LN11@AddSweepPr

; 1002 : 		{
; 1003 : 		bs = 9999;

	mov	DWORD PTR _bs$[ebp], 9999		; 0000270fH

; 1004 : 		sw = new WayPointClass(0, 0, 0, 0, 0, 0, MissionData[mis->mission].targetwp, WPF_TARGET);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN16@AddSweepPr
	push	1
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movzx	ecx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[eax+7]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN17@AddSweepPr
$LN16@AddSweepPr:
	mov	DWORD PTR tv133[ebp], 0
$LN17@AddSweepPr:
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _sw$[ebp], eax

; 1005 : 		sw->SetWPTarget(mis->targetID);

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	mov	ecx, DWORD PTR _sw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 1006 : 		sw->SetWPTargetBuilding((uchar)mis->target_num);

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+50]
	push	edx
	mov	ecx, DWORD PTR _sw$[ebp]
	call	?SetWPTargetBuilding@WayPointClass@@QAEXE@Z ; WayPointClass::SetWPTargetBuilding

; 1007 : 		ch = (fh + ad[s] + 8)%8; 

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _ad$[ebp+eax*4]
	mov	edx, DWORD PTR _fh$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN20@AddSweepPr
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN20@AddSweepPr:
	mov	DWORD PTR _ch$[ebp], eax

; 1008 : 		for (i=0; i<3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@AddSweepPr
$LN9@AddSweepPr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@AddSweepPr:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN8@AddSweepPr

; 1009 : 			{
; 1010 : 			h = (ch + HDelta[i] + 8)%8;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?HDelta@@3PAHA[edx*4]
	mov	ecx, DWORD PTR _ch$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN21@AddSweepPr
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN21@AddSweepPr:
	mov	DWORD PTR _h$[ebp], edx

; 1011 : 			if (dx[h] && dy[h])

	mov	eax, DWORD PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dx@@3PAFA[eax*2]
	test	ecx, ecx
	je	SHORT $LN7@AddSweepPr
	mov	edx, DWORD PTR _h$[ebp]
	movsx	eax, WORD PTR ?dy@@3PAFA[edx*2]
	test	eax, eax
	je	SHORT $LN7@AddSweepPr

; 1012 : 				d = FloatToInt32((.707F * SWEEP_DISTANCE));

	movsx	ecx, WORD PTR ?SWEEP_DISTANCE@@3FA	; SWEEP_DISTANCE
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3f34fdf4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 1013 : 			else

	jmp	SHORT $LN6@AddSweepPr
$LN7@AddSweepPr:

; 1014 : 				d = SWEEP_DISTANCE;

	movsx	edx, WORD PTR ?SWEEP_DISTANCE@@3FA	; SWEEP_DISTANCE
	mov	DWORD PTR _d$[ebp], edx
$LN6@AddSweepPr:

; 1015 : 			x = mis->tx + dx[h] * d;

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	mov	edx, DWORD PTR _h$[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	imul	eax, DWORD PTR _d$[ebp]
	add	ecx, eax
	mov	WORD PTR _x$[ebp], cx

; 1016 : 			y = mis->ty + dy[h] * d;

	mov	ecx, DWORD PTR _mis$[ebp]
	movsx	edx, WORD PTR [ecx+42]
	mov	eax, DWORD PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dy@@3PAFA[eax*2]
	imul	ecx, DWORD PTR _d$[ebp]
	add	edx, ecx
	mov	WORD PTR _y$[ebp], dx

; 1017 : 			score = ScoreThreatFast(x,y,GetAltitudeLevel(sTargetAlt),u->GetTeam()) + i;

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _sTargetAlt
	push	ecx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _score$[ebp], eax

; 1018 : 			// Check if the previous guy grabbed this point
; 1019 : 			for (ls=0; ls<s; ls++)

	mov	DWORD PTR _ls$[ebp], 0
	jmp	SHORT $LN5@AddSweepPr
$LN4@AddSweepPr:
	mov	ecx, DWORD PTR _ls$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ls$[ebp], ecx
$LN5@AddSweepPr:
	mov	edx, DWORD PTR _ls$[ebp]
	cmp	edx, DWORD PTR _s$[ebp]
	jge	SHORT $LN3@AddSweepPr

; 1020 : 				{
; 1021 : 				if (sx[ls] == x && sy[ls] == y)

	mov	eax, DWORD PTR _ls$[ebp]
	movsx	ecx, WORD PTR _sx$[ebp+eax*2]
	movsx	edx, WORD PTR _x$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN2@AddSweepPr
	mov	eax, DWORD PTR _ls$[ebp]
	movsx	ecx, WORD PTR _sy$[ebp+eax*2]
	movsx	edx, WORD PTR _y$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN2@AddSweepPr

; 1022 : 					score = 100;

	mov	DWORD PTR _score$[ebp], 100		; 00000064H
$LN2@AddSweepPr:

; 1023 : 				}

	jmp	SHORT $LN4@AddSweepPr
$LN3@AddSweepPr:

; 1024 : 			if (score < bs)

	mov	eax, DWORD PTR _score$[ebp]
	cmp	eax, DWORD PTR _bs$[ebp]
	jge	SHORT $LN1@AddSweepPr

; 1025 : 				{
; 1026 : 				sx[s] = x;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR _x$[ebp]
	mov	WORD PTR _sx$[ebp+ecx*2], dx

; 1027 : 				sy[s] = y;

	mov	eax, DWORD PTR _s$[ebp]
	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _sy$[ebp+eax*2], cx

; 1028 : 				bs = score;

	mov	edx, DWORD PTR _score$[ebp]
	mov	DWORD PTR _bs$[ebp], edx
$LN1@AddSweepPr:

; 1029 : 				}
; 1030 : 			}

	jmp	$LN9@AddSweepPr
$LN8@AddSweepPr:

; 1031 : 		sw->SetWPLocation(sx[s],sy[s]);

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR _sy$[ebp+eax*2]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR _sx$[ebp+edx*2]
	push	eax
	mov	ecx, DWORD PTR _sw$[ebp]
	call	?SetWPLocation@WayPointClass@@QAEXFF@Z	; WayPointClass::SetWPLocation

; 1032 : 		FinalizeWayPoint(sw);

	push	0
	mov	ecx, DWORD PTR _sw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1033 : 		cw->InsertWP(sw);

	mov	edx, DWORD PTR _sw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1034 : 		cw = sw;

	mov	eax, DWORD PTR _sw$[ebp]
	mov	DWORD PTR _cw$[ebp], eax

; 1035 : 		}

	jmp	$LN12@AddSweepPr
$LN11@AddSweepPr:

; 1036 : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 1037 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddSweepProfile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv86 = -24						; size = 4
$T3 = -20						; size = 4
_tw$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddTargetProfile

; 1061 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1062 : 	WayPoint		tw;
; 1063 : 
; 1064 : 	tw = new WayPointClass(mis->tx, mis->ty, 0, 0, 0, 0, MissionData[mis->mission].targetwp, WPF_TARGET);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@AddTargetP
	push	1
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+7]
	push	edx
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@AddTargetP
$LN4@AddTargetP:
	mov	DWORD PTR tv86[ebp], 0
$LN5@AddTargetP:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _tw$[ebp], edx

; 1065 : 	tw->SetWPTarget(mis->targetID);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 1066 : 	tw->SetWPTargetBuilding((uchar)mis->target_num);

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+50]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTargetBuilding@WayPointClass@@QAEXE@Z ; WayPointClass::SetWPTargetBuilding

; 1067 : 	FinalizeWayPoint(tw);

	push	0
	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1068 : 	if (cw)

	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN1@AddTargetP

; 1069 : 		cw->InsertWP(tw);

	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN1@AddTargetP:

; 1070 : 	return tw;

	mov	eax, DWORD PTR _tw$[ebp]

; 1071 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddTargetProfile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv93 = -24						; size = 4
$T3 = -20						; size = 4
_tw$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddLandProfile

; 1041 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1042 : 	WayPoint		tw;
; 1043 : 
; 1044 : 	// Mark both takeoff and land flags, since we're not staying here.
; 1045 : 	tw = new WayPointClass(mis->tx, mis->ty, 0, 0, 0, MissionData[mis->mission].loitertime*CampaignMinutes, MissionData[mis->mission].targetwp, WPF_TARGET | WPF_LAND | WPF_TAKEOFF);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@AddLandPro
	push	385					; 00000181H
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+7]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movsx	edx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+16]
	imul	edx, 60000				; 0000ea60H
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN5@AddLandPro
$LN4@AddLandPro:
	mov	DWORD PTR tv93[ebp], 0
$LN5@AddLandPro:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _tw$[ebp], edx

; 1046 : 	tw->SetWPTarget(mis->targetID);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 1047 : 	tw->SetWPTargetBuilding((uchar)mis->target_num);

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+50]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTargetBuilding@WayPointClass@@QAEXE@Z ; WayPointClass::SetWPTargetBuilding

; 1048 : 	FinalizeWayPoint(tw);

	push	0
	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1049 : 	if (cw)

	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN1@AddLandPro

; 1050 : 		cw->InsertWP(tw);

	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN1@AddLandPro:

; 1051 : 	cw = tw;

	mov	ecx, DWORD PTR _tw$[ebp]
	mov	DWORD PTR _cw$[ebp], ecx

; 1052 : 	// KCK: Experimental - Fold the takeoff bit into previous waypoint.
; 1053 : //	tw = new WayPointClass(mis->tx, mis->ty, 0, 0, 0, 0, WP_TAKEOFF, WPF_TARGET | WPF_TAKEOFF);
; 1054 : //	FinalizeWayPoint(tw);
; 1055 : //	cw->InsertWP(tw);
; 1056 : 	return tw;

	mov	eax, DWORD PTR _tw$[ebp]

; 1057 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddLandProfile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_pack$ = -32						; size = 4
$T2 = -28						; size = 4
tv90 = -24						; size = 4
$T3 = -20						; size = 4
_tw$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddFlyByProfile

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 972  : //	GridIndex		tpx,tpy;
; 973  : 	WayPoint		tw;
; 974  : 	Unit			pack;
; 975  : 
; 976  : 	pack = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 977  : 
; 978  : 	// Target WP
; 979  : 	tw = new WayPointClass(mis->tx, mis->ty, 0, 0, 0, 0, MissionData[mis->mission].targetwp, WPF_TARGET);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@AddFlyByPr
	push	1
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	shl	edx, 5
	movzx	eax, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[edx+7]
	push	eax
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+42]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN4@AddFlyByPr
$LN3@AddFlyByPr:
	mov	DWORD PTR tv90[ebp], 0
$LN4@AddFlyByPr:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _tw$[ebp], eax

; 980  : 	FinalizeWayPoint(tw);

	push	0
	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 981  : 	cw->InsertWP(tw);

	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 982  : 	cw = tw;

	mov	eax, DWORD PTR _tw$[ebp]
	mov	DWORD PTR _cw$[ebp], eax

; 983  : 
; 984  : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 985  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddFlyByProfile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddBypassProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddBypassProfile

; 965  : 	{

	push	ebp
	mov	ebp, esp

; 966  : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 967  : 	}

	pop	ebp
	ret	0
?AddBypassProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddBypassProfile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -108						; size = 4
tv368 = -104						; size = 4
tv398 = -100						; size = 4
tv359 = -96						; size = 4
tv396 = -92						; size = 4
tv350 = -88						; size = 4
tv394 = -84						; size = 4
tv340 = -80						; size = 4
tv392 = -76						; size = 4
tv330 = -72						; size = 4
tv390 = -68						; size = 4
tv320 = -64						; size = 4
tv388 = -60						; size = 4
$T3 = -56						; size = 4
tv258 = -52						; size = 4
$T4 = -48						; size = 4
tv86 = -44						; size = 4
$T5 = -40						; size = 4
_lw$ = -36						; size = 4
tv149 = -32						; size = 4
_tw$ = -28						; size = 4
_r$ = -24						; size = 4
_lx$ = -20						; size = 2
_ly$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddLoiterProfile

; 914  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 915  : 	GridIndex		lx,ly;
; 916  : 	WayPoint		tw,lw;
; 917  : 	float			r;
; 918  : 
; 919  : 	// The Target Location
; 920  : 	tw = new WayPointClass(mis->tx, mis->ty, 0, 0, 0, 0, MissionData[mis->mission].targetwp, WPF_TARGET | WPF_CP);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN9@AddLoiterP
	push	33					; 00000021H
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+7]
	push	edx
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN10@AddLoiterP
$LN9@AddLoiterP:
	mov	DWORD PTR tv86[ebp], 0
$LN10@AddLoiterP:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _tw$[ebp], edx

; 921  : 	tw->SetWPTarget(mis->targetID);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 922  : 	tw->SetWPTargetBuilding((uchar)mis->target_num);

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+50]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTargetBuilding@WayPointClass@@QAEXE@Z ; WayPointClass::SetWPTargetBuilding

; 923  : 	FinalizeWayPoint(tw);

	push	0
	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 924  : 	cw->InsertWP(tw);

	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 925  : 	cw = tw;

	mov	ecx, DWORD PTR _tw$[ebp]
	mov	DWORD PTR _cw$[ebp], ecx

; 926  : 
; 927  : 	// The Loiter Location (loop back to previous wp)
; 928  : 	r = DirectionTowardFriendly(mis->tx,mis->ty,u->GetTeam());		// Direction away from front, essentially

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+42]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	push	ecx
	call	?DirectionTowardFriendly@@YAMFFH@Z	; DirectionTowardFriendly
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _r$[ebp]

; 929  : 	// Special case for FAC missions - direction towards enemy
; 930  : 	if (mis->mission == AMIS_FAC)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN6@AddLoiterP

; 931  : 		r += PI;

	movss	xmm0, DWORD PTR _r$[ebp]
	addss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR _r$[ebp], xmm0
$LN6@AddLoiterP:

; 932  : 	
; 933  : 	// RV - Biker - Loiter distance is too small for heavies
; 934  : 	//lx = mis->tx + (GridIndex)(LOITER_DIST*sin(r));
; 935  : 	//ly = mis->ty + (GridIndex)(LOITER_DIST*cos(r));
; 936  : 	switch(mis->mission)

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	dl, BYTE PTR [ecx+60]
	mov	BYTE PTR tv149[ebp], dl
	cmp	BYTE PTR tv149[ebp], 26			; 0000001aH
	jb	$LN1@AddLoiterP
	cmp	BYTE PTR tv149[ebp], 27			; 0000001bH
	jbe	$LN2@AddLoiterP
	cmp	BYTE PTR tv149[ebp], 28			; 0000001cH
	je	SHORT $LN3@AddLoiterP
	jmp	$LN1@AddLoiterP
$LN3@AddLoiterP:

; 937  : 	{
; 938  : 		case AMIS_TANKER:
; 939  : 			lx = mis->tx + (GridIndex)(4.0F*LOITER_DIST*sin(r));

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	esi, WORD PTR [eax+40]
	movsx	ecx, WORD PTR ?LOITER_DIST@@3FA		; LOITER_DIST
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@40800000
	push	ecx
	movss	xmm1, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv388[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv320[ebp]
	movss	xmm0, DWORD PTR tv388[ebp]
	mulss	xmm0, DWORD PTR tv320[ebp]
	cvttss2si edx, xmm0
	movsx	eax, dx
	add	esi, eax
	mov	WORD PTR _lx$[ebp], si

; 940  : 			ly = mis->ty + (GridIndex)(4.0F*LOITER_DIST*cos(r));

	mov	ecx, DWORD PTR _mis$[ebp]
	movsx	esi, WORD PTR [ecx+42]
	movsx	edx, WORD PTR ?LOITER_DIST@@3FA		; LOITER_DIST
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@40800000
	push	ecx
	movss	xmm1, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv390[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv330[ebp]
	movss	xmm0, DWORD PTR tv390[ebp]
	mulss	xmm0, DWORD PTR tv330[ebp]
	cvttss2si eax, xmm0
	movsx	ecx, ax
	add	esi, ecx
	mov	WORD PTR _ly$[ebp], si

; 941  : 			break;

	jmp	$LN4@AddLoiterP
$LN2@AddLoiterP:

; 942  : 		
; 943  : 		case AMIS_AWACS:
; 944  : 		case AMIS_JSTAR:
; 945  : 			lx = mis->tx + (GridIndex)(2.0F*LOITER_DIST*sin(r));

	mov	edx, DWORD PTR _mis$[ebp]
	movsx	esi, WORD PTR [edx+40]
	movsx	eax, WORD PTR ?LOITER_DIST@@3FA		; LOITER_DIST
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	xmm1, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv392[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv340[ebp]
	movss	xmm0, DWORD PTR tv392[ebp]
	mulss	xmm0, DWORD PTR tv340[ebp]
	cvttss2si ecx, xmm0
	movsx	edx, cx
	add	esi, edx
	mov	WORD PTR _lx$[ebp], si

; 946  : 			ly = mis->ty + (GridIndex)(2.0F*LOITER_DIST*cos(r));

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	esi, WORD PTR [eax+42]
	movsx	ecx, WORD PTR ?LOITER_DIST@@3FA		; LOITER_DIST
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	xmm1, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv394[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv350[ebp]
	movss	xmm0, DWORD PTR tv394[ebp]
	mulss	xmm0, DWORD PTR tv350[ebp]
	cvttss2si edx, xmm0
	movsx	eax, dx
	add	esi, eax
	mov	WORD PTR _ly$[ebp], si

; 947  : 			break;

	jmp	$LN4@AddLoiterP
$LN1@AddLoiterP:

; 948  : 		
; 949  : 		default:
; 950  : 			lx = mis->tx + (GridIndex)(LOITER_DIST*sin(r));

	mov	ecx, DWORD PTR _mis$[ebp]
	movsx	esi, WORD PTR [ecx+40]
	movsx	edx, WORD PTR ?LOITER_DIST@@3FA		; LOITER_DIST
	cvtsi2ss xmm0, edx
	push	ecx
	movss	xmm1, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv396[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv359[ebp]
	movss	xmm0, DWORD PTR tv396[ebp]
	mulss	xmm0, DWORD PTR tv359[ebp]
	cvttss2si eax, xmm0
	movsx	ecx, ax
	add	esi, ecx
	mov	WORD PTR _lx$[ebp], si

; 951  : 			ly = mis->ty + (GridIndex)(LOITER_DIST*cos(r));

	mov	edx, DWORD PTR _mis$[ebp]
	movsx	esi, WORD PTR [edx+42]
	movsx	eax, WORD PTR ?LOITER_DIST@@3FA		; LOITER_DIST
	cvtsi2ss xmm0, eax
	push	ecx
	movss	xmm1, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv398[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv368[ebp]
	movss	xmm0, DWORD PTR tv398[ebp]
	mulss	xmm0, DWORD PTR tv368[ebp]
	cvttss2si ecx, xmm0
	movsx	edx, cx
	add	esi, edx
	mov	WORD PTR _ly$[ebp], si
$LN4@AddLoiterP:

; 952  : 			break;
; 953  : 	}
; 954  : 
; 955  : 	lw = new WayPointClass(lx, ly, 0, 0, 0, MissionData[mis->mission].loitertime*CampaignMinutes, MissionData[mis->mission].targetwp, WPF_TARGET | WPF_CP | WPF_REPEAT);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN11@AddLoiterP
	push	97					; 00000061H
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+7]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movsx	edx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+16]
	imul	edx, 60000				; 0000ea60H
	push	edx
	push	0
	push	0
	push	0
	movzx	eax, WORD PTR _ly$[ebp]
	push	eax
	movzx	ecx, WORD PTR _lx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv258[ebp], eax
	jmp	SHORT $LN12@AddLoiterP
$LN11@AddLoiterP:
	mov	DWORD PTR tv258[ebp], 0
$LN12@AddLoiterP:
	mov	edx, DWORD PTR tv258[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _lw$[ebp], eax

; 956  : 	FinalizeWayPoint(lw);

	push	0
	mov	ecx, DWORD PTR _lw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 957  : 	cw->InsertWP(lw);

	mov	edx, DWORD PTR _lw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 958  : 	cw = lw;

	mov	eax, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _cw$[ebp], eax

; 959  : 
; 960  : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 961  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddLoiterProfile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_fh$2 = -116						; size = 4
$T3 = -112						; size = 4
$T4 = -108						; size = 4
tv214 = -104						; size = 4
tv205 = -100						; size = 4
tv184 = -96						; size = 4
$T5 = -92						; size = 4
tv129 = -88						; size = 4
$T6 = -84						; size = 4
_bs$7 = -80						; size = 4
_nw$ = -76						; size = 4
_tpw$ = -72						; size = 4
_pack$ = -68						; size = 4
_s$8 = -64						; size = 4
_d$9 = -60						; size = 4
_i$10 = -56						; size = 4
_h$11 = -52						; size = 4
_tw$ = -48						; size = 4
_ipx$ = -44						; size = 2
_ipy$ = -40						; size = 2
_bx$ = -36						; size = 2
_by$ = -32						; size = 2
_y$12 = -28						; size = 2
_x$13 = -24						; size = 2
_tpx$ = -20						; size = 2
_tpy$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddAttackProfile

; 854  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 855  : 	GridIndex		ipx,ipy,tpx,tpy,bx,by;
; 856  : 	WayPoint		tw,tpw,nw;
; 857  : 	Unit			pack;
; 858  : 
; 859  : 	pack = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 860  : 	u->GetLocation(&bx,&by);

	lea	ecx, DWORD PTR _by$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 861  : 
; 862  : 	// Add the target WP
; 863  : 	tw = new WayPointClass(mis->tx, mis->ty, 0, 0, 0, 0, MissionData[mis->mission].targetwp, WPF_TARGET);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN12@AddAttackP
	push	1
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movzx	edx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[ecx+7]
	push	edx
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN13@AddAttackP
$LN12@AddAttackP:
	mov	DWORD PTR tv129[ebp], 0
$LN13@AddAttackP:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _tw$[ebp], edx

; 864  : 	cw->InsertWP(tw);

	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 865  : 	tw->SetWPTarget(mis->targetID);

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 866  : 	tw->SetWPTargetBuilding((uchar)mis->target_num);

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+50]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTargetBuilding@WayPointClass@@QAEXE@Z ; WayPointClass::SetWPTargetBuilding

; 867  : 		
; 868  : 	// Find and add the IP
; 869  : 	nw = AddDistanceWaypoint(cw,tw,BREAKPOINT_DISTANCE);

	movsx	eax, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cw$[ebp]
	push	edx
	call	?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z ; AddDistanceWaypoint
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nw$[ebp], eax

; 870  : 	nw->SetWPFlag(WPF_IP);

	push	8
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 871  : 	FinalizeWayPoint(nw);

	push	0
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 872  : 	FinalizeWayPoint(tw);

	push	0
	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 873  : 
; 874  : 	// Find and add the FIRST turn point, if we don't have one
; 875  : 	pack->GetUnitAssemblyPoint(3,&tpx,&tpy);

	lea	edx, DWORD PTR _tpy$[ebp]
	push	edx
	lea	eax, DWORD PTR _tpx$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+812]
	call	eax

; 876  : 	if (!tpx || !tpy)

	movsx	ecx, WORD PTR _tpx$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@AddAttackP
	movsx	edx, WORD PTR _tpy$[ebp]
	test	edx, edx
	jne	$LN9@AddAttackP
$LN8@AddAttackP:

; 877  : 		{
; 878  : 		int			i,s,bs=9999,fh,h,d;

	mov	DWORD PTR _bs$7[ebp], 9999		; 0000270fH

; 879  : 		GridIndex	x,y;
; 880  : 		// Look around for a safe spot
; 881  : 		nw->GetWPLocation(&ipx,&ipy);

	lea	eax, DWORD PTR _ipy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ipx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 882  : 		fh = (int)DirectionTo(ipx,ipy,mis->tx,mis->ty);

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	movzx	eax, WORD PTR _ipy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ipx$[ebp]
	push	ecx
	call	?DirectionTo@@YAEFFFF@Z			; DirectionTo
	add	esp, 16					; 00000010H
	movzx	edx, al
	mov	DWORD PTR _fh$2[ebp], edx

; 883  : 		tpw = new WayPointClass(0, 0, 0, 0, 0, 0, WP_NOTHING, WPF_TURNPOINT);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN14@AddAttackP
	push	16					; 00000010H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv184[ebp], eax
	jmp	SHORT $LN15@AddAttackP
$LN14@AddAttackP:
	mov	DWORD PTR tv184[ebp], 0
$LN15@AddAttackP:
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _tpw$[ebp], ecx

; 884  : 		for (i=0; i<5; i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN7@AddAttackP
$LN6@AddAttackP:
	mov	edx, DWORD PTR _i$10[ebp]
	add	edx, 1
	mov	DWORD PTR _i$10[ebp], edx
$LN7@AddAttackP:
	cmp	DWORD PTR _i$10[ebp], 5
	jge	$LN5@AddAttackP

; 885  : 			{
; 886  : 			h = (fh + HDelta[i] + 8)%8;

	mov	eax, DWORD PTR _i$10[ebp]
	mov	ecx, DWORD PTR ?HDelta@@3PAHA[eax*4]
	mov	edx, DWORD PTR _fh$2[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN23@AddAttackP
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN23@AddAttackP:
	mov	DWORD PTR _h$11[ebp], eax

; 887  : 			if (dx[h] && dy[h])

	mov	ecx, DWORD PTR _h$11[ebp]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	test	edx, edx
	je	SHORT $LN4@AddAttackP
	mov	eax, DWORD PTR _h$11[ebp]
	movsx	ecx, WORD PTR ?dy@@3PAFA[eax*2]
	test	ecx, ecx
	je	SHORT $LN4@AddAttackP

; 888  : 				d = FloatToInt32(0.707F * max(3, BREAKPOINT_DISTANCE/4));

	movsx	eax, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	eax, 3
	jge	SHORT $LN16@AddAttackP
	mov	DWORD PTR tv205[ebp], 3
	jmp	SHORT $LN17@AddAttackP
$LN16@AddAttackP:
	movsx	eax, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv205[ebp], eax
$LN17@AddAttackP:
	cvtsi2ss xmm0, DWORD PTR tv205[ebp]
	mulss	xmm0, DWORD PTR __real@3f34fdf4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$9[ebp], eax

; 889  : 			else

	jmp	SHORT $LN3@AddAttackP
$LN4@AddAttackP:

; 890  : 				d = max(3, BREAKPOINT_DISTANCE/4);

	movsx	eax, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	eax, 3
	jge	SHORT $LN18@AddAttackP
	mov	DWORD PTR tv214[ebp], 3
	jmp	SHORT $LN19@AddAttackP
$LN18@AddAttackP:
	movsx	eax, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv214[ebp], eax
$LN19@AddAttackP:
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _d$9[ebp], edx
$LN3@AddAttackP:

; 891  : 			x = mis->tx + dx[h] * d;

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	mov	edx, DWORD PTR _h$11[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	imul	eax, DWORD PTR _d$9[ebp]
	add	ecx, eax
	mov	WORD PTR _x$13[ebp], cx

; 892  : 			y = mis->ty + dy[h] * d;

	mov	ecx, DWORD PTR _mis$[ebp]
	movsx	edx, WORD PTR [ecx+42]
	mov	eax, DWORD PTR _h$11[ebp]
	movsx	ecx, WORD PTR ?dy@@3PAFA[eax*2]
	imul	ecx, DWORD PTR _d$9[ebp]
	add	edx, ecx
	mov	WORD PTR _y$12[ebp], dx

; 893  : 			s = ScoreThreatFast(x,y,GetAltitudeLevel(sTargetAlt),u->GetTeam()) - i;

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _sTargetAlt
	push	ecx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movzx	edx, WORD PTR _y$12[ebp]
	push	edx
	movzx	eax, WORD PTR _x$13[ebp]
	push	eax
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	sub	eax, DWORD PTR _i$10[ebp]
	mov	DWORD PTR _s$8[ebp], eax

; 894  : 			s += ScoreThreatFast(x+dx[h]*d,y+dy[h]*d,GetAltitudeLevel(sTargetAlt),u->GetTeam());

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _sTargetAlt
	push	edx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movsx	eax, WORD PTR _y$12[ebp]
	mov	ecx, DWORD PTR _h$11[ebp]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	imul	edx, DWORD PTR _d$9[ebp]
	add	eax, edx
	push	eax
	movsx	eax, WORD PTR _x$13[ebp]
	mov	ecx, DWORD PTR _h$11[ebp]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	imul	edx, DWORD PTR _d$9[ebp]
	add	eax, edx
	push	eax
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _s$8[ebp]
	mov	DWORD PTR _s$8[ebp], eax

; 895  : 			if (s < bs || (s==bs && DistSqu(x,y,bx,by) < DistSqu(tpx,tpy,bx,by)))

	mov	eax, DWORD PTR _s$8[ebp]
	cmp	eax, DWORD PTR _bs$7[ebp]
	jl	SHORT $LN1@AddAttackP
	mov	ecx, DWORD PTR _s$8[ebp]
	cmp	ecx, DWORD PTR _bs$7[ebp]
	jne	SHORT $LN2@AddAttackP
	movzx	edx, WORD PTR _by$[ebp]
	push	edx
	movzx	eax, WORD PTR _bx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$12[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$13[ebp]
	push	edx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	mov	esi, eax
	movzx	eax, WORD PTR _by$[ebp]
	push	eax
	movzx	ecx, WORD PTR _bx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tpy$[ebp]
	push	edx
	movzx	eax, WORD PTR _tpx$[ebp]
	push	eax
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jge	SHORT $LN2@AddAttackP
$LN1@AddAttackP:

; 896  : 				{
; 897  : 				tpx = x;

	mov	cx, WORD PTR _x$13[ebp]
	mov	WORD PTR _tpx$[ebp], cx

; 898  : 				tpy = y;

	mov	dx, WORD PTR _y$12[ebp]
	mov	WORD PTR _tpy$[ebp], dx

; 899  : 				bs = s;

	mov	eax, DWORD PTR _s$8[ebp]
	mov	DWORD PTR _bs$7[ebp], eax
$LN2@AddAttackP:

; 900  : 				}
; 901  : 			}

	jmp	$LN6@AddAttackP
$LN5@AddAttackP:

; 902  : 		pack->SetUnitAssemblyPoint(3,tpx,tpy);

	movzx	ecx, WORD PTR _tpy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tpx$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+808]
	call	eax

; 903  : 		tpw->SetWPLocation(tpx,tpy);

	movzx	ecx, WORD PTR _tpy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tpx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _tpw$[ebp]
	call	?SetWPLocation@WayPointClass@@QAEXFF@Z	; WayPointClass::SetWPLocation

; 904  : 		FinalizeWayPoint(tpw);

	push	0
	mov	eax, DWORD PTR _tpw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 905  : 		tw->InsertWP(tpw);

	mov	ecx, DWORD PTR _tpw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 906  : 		tw = tpw;

	mov	edx, DWORD PTR _tpw$[ebp]
	mov	DWORD PTR _tw$[ebp], edx
$LN9@AddAttackP:

; 907  : 		}
; 908  : 
; 909  : 	return tw;

	mov	eax, DWORD PTR _tw$[ebp]

; 910  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddAttackProfile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_pack$ = -12						; size = 4
_nw$ = -8						; size = 4
_temp$1 = -4						; size = 4
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?AddIngressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddIngressPath

; 826  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 827  : 	WayPoint		nw;
; 828  : 	Unit			pack;
; 829  : 
; 830  : 	pack = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 831  : 	nw = CloneWPList(((Package)pack)->GetIngress());

	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetIngress@PackageClass@@QAEPAVWayPointClass@@XZ ; PackageClass::GetIngress
	push	eax
	call	?CloneWPList@@YAPAVWayPointClass@@PAV1@@Z ; CloneWPList
	add	esp, 4
	mov	DWORD PTR _nw$[ebp], eax

; 832  : 	cw->InsertWP(nw);

	mov	ecx, DWORD PTR _nw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 833  : 	if (MissionData[mis->mission].flags & AMIS_DONT_COORD)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	mov	ecx, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+28]
	and	ecx, 1048576				; 00100000H
	je	SHORT $LN2@AddIngress

; 834  : 		{
; 835  : 		// Reset ingress times to 0
; 836  : 		WayPoint temp = nw;

	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _temp$1[ebp], edx
$LN4@AddIngress:

; 837  : 		while (temp)

	cmp	DWORD PTR _temp$1[ebp], 0
	je	SHORT $LN2@AddIngress

; 838  : 			{
; 839  : 			temp->SetWPTimes(0);

	push	0
	mov	ecx, DWORD PTR _temp$1[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes

; 840  : 			temp = temp->GetNextWP();

	mov	ecx, DWORD PTR _temp$1[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _temp$1[ebp], eax

; 841  : 			}

	jmp	SHORT $LN4@AddIngress
$LN2@AddIngress:

; 842  : 		}
; 843  : 	while (cw && cw->GetNextWP())

	cmp	DWORD PTR _cw$[ebp], 0
	je	SHORT $LN1@AddIngress
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN1@AddIngress

; 844  : 		{
; 845  : 		FinalizeWayPoint(cw);

	push	0
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 846  : 		cw = cw->GetNextWP();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _cw$[ebp], eax

; 847  : 		}

	jmp	SHORT $LN2@AddIngress
$LN1@AddIngress:

; 848  : 	FinalizeWayPoint(cw);

	push	0
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 849  : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]

; 850  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AddIngressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddIngressPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 4
tv85 = -56						; size = 4
$T3 = -52						; size = 4
_dw$ = -48						; size = 4
_pack$ = -44						; size = 4
_aw$ = -40						; size = 4
_nw$ = -36						; size = 4
_tw$ = -32						; size = 4
_bpx$ = -28						; size = 2
_bpy$ = -24						; size = 2
_iax$ = -20						; size = 2
_iay$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_cw$ = 8						; size = 4
_u$ = 12						; size = 4
_mis$ = 16						; size = 4
?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; SetupIngressPoints

; 779  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 780  : 	Unit			pack;
; 781  : 	WayPoint		nw,tw,dw,aw;
; 782  : 	GridIndex		iax,iay,bpx,bpy;
; 783  : 
; 784  : 	pack = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 785  : 
; 786  : 	// Find the path to the target
; 787  : 	tw = new WayPointClass(mis->tx, mis->ty, 10000, 0, 0, 0, WP_NOTHING, WPF_TARGET);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@SetupIngre
	push	1
	push	0
	push	0
	push	0
	push	0
	push	10000					; 00002710H
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+42]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN9@SetupIngre
$LN8@SetupIngre:
	mov	DWORD PTR tv85[ebp], 0
$LN9@SetupIngre:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _tw$[ebp], eax

; 788  : 	cw->UnlinkNextWP ();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?UnlinkNextWP@WayPointClass@@QAEXXZ	; WayPointClass::UnlinkNextWP

; 789  : 	cw->InsertWP(tw);

	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 790  : 	if (!CheckSafePath(cw,tw,u))

	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?CheckSafePath@@YAPAVWayPointClass@@PAV1@0PAVFlightClass@@@Z ; CheckSafePath
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SetupIngre

; 791  : 		return 0;

	xor	eax, eax
	jmp	$LN6@SetupIngre
$LN5@SetupIngre:

; 792  : 
; 793  : 	// Find a safe location for an assembly point and add it to the list
; 794  : 	aw = AddSafeWaypoint(cw,tw,0,MIN_AP_DISTANCE,u->GetTeam());

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	movsx	ecx, WORD PTR ?MIN_AP_DISTANCE@@3FA	; MIN_AP_DISTANCE
	push	ecx
	push	0
	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z ; AddSafeWaypoint
	add	esp, 20					; 00000014H
	mov	DWORD PTR _aw$[ebp], eax

; 795  : 	aw->SetWPAction(WP_ASSEMBLE);

	push	2
	mov	ecx, DWORD PTR _aw$[ebp]
	call	?SetWPAction@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAction

; 796  : 	aw->GetWPLocation(&iax,&iay);

	lea	ecx, DWORD PTR _iay$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _aw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 797  : 	FinalizeWayPoint(aw);

	push	0
	mov	eax, DWORD PTR _aw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 798  : 	pack->SetUnitAssemblyPoint(0,iax,iay);

	movzx	ecx, WORD PTR _iay$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iax$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+808]
	call	eax

; 799  : 
; 800  : 	if (!(MissionData[mis->mission].flags & AMIS_NO_BREAKPT))

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	shl	edx, 5
	mov	eax, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[edx+28]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN4@SetupIngre

; 801  : 		{
; 802  : 		// Find a good breakpoint
; 803  : 		nw = AddDistanceWaypoint(aw,tw,BREAKPOINT_DISTANCE*2);

	movsx	ecx, WORD PTR ?BREAKPOINT_DISTANCE@@3FA	; BREAKPOINT_DISTANCE
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	mov	eax, DWORD PTR _aw$[ebp]
	push	eax
	call	?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z ; AddDistanceWaypoint
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nw$[ebp], eax

; 804  : 		nw->SetWPFlag(WPF_BREAKPOINT);

	push	4
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 805  : 		nw->GetWPLocation(&bpx,&bpy);

	lea	ecx, DWORD PTR _bpy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bpx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 806  : 		FinalizeWayPoint(nw);

	push	0
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 807  : 		pack->SetUnitAssemblyPoint(2,bpx,bpy);

	movzx	ecx, WORD PTR _bpy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _bpx$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+808]
	call	eax

; 808  : 		}
; 809  : 	else

	jmp	SHORT $LN3@SetupIngre
$LN4@SetupIngre:

; 810  : 		nw = aw;

	mov	ecx, DWORD PTR _aw$[ebp]
	mov	DWORD PTR _nw$[ebp], ecx
$LN3@SetupIngre:

; 811  : 
; 812  : 	// Remove target area waypoints
; 813  : 	dw = nw->GetNextWP();

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _dw$[ebp], eax
$LN2@SetupIngre:

; 814  : 	while (dw)

	cmp	DWORD PTR _dw$[ebp], 0
	je	SHORT $LN1@SetupIngre

; 815  : 		{
; 816  : 		tw = dw->GetNextWP();

	mov	ecx, DWORD PTR _dw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tw$[ebp], eax

; 817  : 		dw->DeleteWP ();

	mov	ecx, DWORD PTR _dw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 818  : 		dw = tw;

	mov	edx, DWORD PTR _tw$[ebp]
	mov	DWORD PTR _dw$[ebp], edx

; 819  : 		}

	jmp	SHORT $LN2@SetupIngre
$LN1@SetupIngre:

; 820  : 
; 821  : 	return nw;

	mov	eax, DWORD PTR _nw$[ebp]
$LN6@SetupIngre:

; 822  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; SetupIngressPoints
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -44						; size = 4
_step$ = -40						; size = 4
tv95 = -36						; size = 4
$T3 = -32						; size = 4
_nw$ = -28						; size = 4
_steps$ = -24						; size = 4
_i$ = -20						; size = 4
_lh$ = -14						; size = 1
_h$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_nx$ = 20						; size = 2
_ny$ = 24						; size = 2
_w$ = 28						; size = 4
?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z PROC ; FillAirPath

; 2006 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2007 : 	CampaignHeading	lh,h;
; 2008 : 	int				i,step=QuickSearch,steps=0;

	mov	eax, DWORD PTR ?QuickSearch@@3HA	; QuickSearch
	mov	DWORD PTR _step$[ebp], eax
	mov	DWORD PTR _steps$[ebp], 0

; 2009 : 	WayPoint		nw;
; 2010 : 
; 2011 : 	ShiAssert(step);
; 2012 : 
; 2013 : 	h = lh = (CampaignHeading) path->GetDirection(0);

	push	0
	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	BYTE PTR _lh$[ebp], al
	mov	cl, BYTE PTR _lh$[ebp]
	mov	BYTE PTR _h$[ebp], cl

; 2014 : 	for (i=0; i<path->GetLength(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@FillAirPat
$LN5@FillAirPat:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@FillAirPat:
	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetLength@BasePathClass@@QAEHXZ	; BasePathClass::GetLength
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN4@FillAirPat

; 2015 : 		{
; 2016 : 		h = (CampaignHeading) path->GetDirection(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	call	?GetDirection@BasePathClass@@QAEHH@Z	; BasePathClass::GetDirection
	mov	BYTE PTR _h$[ebp], al

; 2017 : 
; 2018 : 		// We trigger an add if we've moved a couple times and our heading has changed
; 2019 : 		if (h != lh && steps > 1)

	movzx	ecx, BYTE PTR _h$[ebp]
	movzx	edx, BYTE PTR _lh$[ebp]
	cmp	ecx, edx
	je	$LN3@FillAirPat
	cmp	DWORD PTR _steps$[ebp], 1
	jle	$LN3@FillAirPat

; 2020 : 			{
; 2021 : 			nw = new WayPointClass(*x,*y,0,0,0,0,WP_NOTHING,0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN9@FillAirPat
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN10@FillAirPat
$LN9@FillAirPat:
	mov	DWORD PTR tv95[ebp], 0
$LN10@FillAirPat:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _nw$[ebp], edx

; 2022 : 			FinalizeFillerWayPoint(nw);

	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	call	?FinalizeFillerWayPoint@@YAXPAVWayPointClass@@@Z ; FinalizeFillerWayPoint
	add	esp, 4

; 2023 : 			w->InsertWP (nw);

	mov	ecx, DWORD PTR _nw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 2024 : 	        w = nw;

	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 2025 : 			steps = 0;

	mov	DWORD PTR _steps$[ebp], 0

; 2026 : 			}
; 2027 : 		else

	jmp	SHORT $LN2@FillAirPat
$LN3@FillAirPat:

; 2028 : 			{
; 2029 : 			lh = h;

	mov	al, BYTE PTR _h$[ebp]
	mov	BYTE PTR _lh$[ebp], al

; 2030 : 			steps++;

	mov	ecx, DWORD PTR _steps$[ebp]
	add	ecx, 1
	mov	DWORD PTR _steps$[ebp], ecx
$LN2@FillAirPat:

; 2031 : 			}
; 2032 : 
; 2033 : 		*x += step * dx[h];

	movzx	edx, BYTE PTR _h$[ebp]
	movsx	eax, WORD PTR ?dx@@3PAFA[edx*2]
	imul	eax, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	movsx	edx, WORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _x$[ebp]
	mov	WORD PTR [eax], dx

; 2034 : 		*y += step * dy[h];

	movzx	ecx, BYTE PTR _h$[ebp]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	imul	edx, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	movsx	ecx, WORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR _y$[ebp]
	mov	WORD PTR [edx], cx

; 2035 : 		}

	jmp	$LN5@FillAirPat
$LN4@FillAirPat:

; 2036 : 	// Snap to our target if we're close enough
; 2037 : 	if (QuickSearch && DistSqu(*x,*y,nx,ny) < QuickSearch*QuickSearch)

	cmp	DWORD PTR ?QuickSearch@@3HA, 0		; QuickSearch
	je	SHORT $LN1@FillAirPat
	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?QuickSearch@@3HA	; QuickSearch
	imul	ecx, DWORD PTR ?QuickSearch@@3HA	; QuickSearch
	cmp	eax, ecx
	jge	SHORT $LN1@FillAirPat

; 2038 : 		{
; 2039 : 		*x = nx;

	mov	edx, DWORD PTR _x$[ebp]
	mov	ax, WORD PTR _nx$[ebp]
	mov	WORD PTR [edx], ax

; 2040 : 		*y = ny;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	dx, WORD PTR _ny$[ebp]
	mov	WORD PTR [ecx], dx
$LN1@FillAirPat:

; 2041 : 		}
; 2042 : 	return w;

	mov	eax, DWORD PTR _w$[ebp]

; 2043 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z ENDP ; FillAirPath
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_nh$ = -68						; size = 4
_mh$ = -64						; size = 4
_oh$ = -60						; size = 4
_mnd$ = -56						; size = 4
_wmd$ = -52						; size = 4
_cnm$ = -48						; size = 4
_cwm$ = -44						; size = 4
_wnd$ = -40						; size = 4
_nw$ = -36						; size = 4
_w$ = -32						; size = 4
_mw$ = -28						; size = 4
_my$ = -24						; size = 2
_mx$ = -20						; size = 2
_ny$ = -16						; size = 2
_y$ = -12						; size = 2
_nx$ = -8						; size = 2
_x$ = -4						; size = 2
_w1$ = 8						; size = 4
_w2$ = 12						; size = 4
_who$ = 16						; size = 4
?EliminateExcessWaypoints@@YAPAVWayPointClass@@PAV1@0H@Z PROC ; EliminateExcessWaypoints

; 2048 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi

; 2049 : 	WayPoint	w,mw,nw;
; 2050 : 	int         nh,mh,oh;
; 2051 : 	GridIndex	x,y,mx,my,nx,ny;
; 2052 : 	float		wnd,wmd,mnd,cwm,cnm;
; 2053 : #ifdef DEBUG
; 2054 : 	static int	trimmed_by_angle=0,trimmed_by_threat=0;
; 2055 : #endif
; 2056 : 
; 2057 : 	w = w1;						// Starting waypoint for this check

	mov	eax, DWORD PTR _w1$[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 2058 : 	mw = w->GetNextWP();		// Middle waypoint (The one we may decide to eliminate)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _mw$[ebp], eax

; 2059 : 	nw = mw->GetNextWP();		// End waypoint

	mov	ecx, DWORD PTR _mw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax
$LN9@EliminateE:

; 2060 : 	while (w && mw && nw && w != w2 && mw != w2)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN8@EliminateE
	cmp	DWORD PTR _mw$[ebp], 0
	je	$LN8@EliminateE
	cmp	DWORD PTR _nw$[ebp], 0
	je	$LN8@EliminateE
	mov	ecx, DWORD PTR _w$[ebp]
	cmp	ecx, DWORD PTR _w2$[ebp]
	je	$LN8@EliminateE
	mov	edx, DWORD PTR _mw$[ebp]
	cmp	edx, DWORD PTR _w2$[ebp]
	je	$LN8@EliminateE

; 2061 : 		{
; 2062 : 		// Check to see if this is a filler way point
; 2063 : 		if (mw->GetWPAction()==WP_NOTHING && !(mw->GetWPFlags() & WPF_CRITICAL_MASK))

	mov	ecx, DWORD PTR _mw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	test	eax, eax
	jne	$LN7@EliminateE
	mov	ecx, DWORD PTR _mw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 2047				; 000007ffH
	jne	$LN7@EliminateE

; 2064 : 			{
; 2065 : 			// Basically, I want to trim this if:
; 2066 : 			// a) it's co-linear with next waypoint or greater than our max angle
; 2067 : 			w->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2068 : 			mw->GetWPLocation(&mx,&my);

	lea	edx, DWORD PTR _my$[ebp]
	push	edx
	lea	eax, DWORD PTR _mx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2069 : 			nw->GetWPLocation(&nx,&ny);

	lea	ecx, DWORD PTR _ny$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2070 : 			wnd = Distance(x,y,nx,ny);

	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _wnd$[ebp]

; 2071 : 			wmd = Distance(x,y,mx,my);

	movzx	ecx, WORD PTR _my$[ebp]
	push	ecx
	movzx	edx, WORD PTR _mx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _wmd$[ebp]

; 2072 : 			mnd = Distance(mx,my,nx,ny);

	movzx	edx, WORD PTR _ny$[ebp]
	push	edx
	movzx	eax, WORD PTR _nx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _my$[ebp]
	push	ecx
	movzx	edx, WORD PTR _mx$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _mnd$[ebp]

; 2073 : 			cwm = ((mx-x)*(nx-x) + (my-y)*(ny-y)) / (wmd * wnd);

	movsx	eax, WORD PTR _mx$[ebp]
	movsx	ecx, WORD PTR _x$[ebp]
	sub	eax, ecx
	movsx	edx, WORD PTR _nx$[ebp]
	movsx	ecx, WORD PTR _x$[ebp]
	sub	edx, ecx
	imul	eax, edx
	movsx	edx, WORD PTR _my$[ebp]
	movsx	ecx, WORD PTR _y$[ebp]
	sub	edx, ecx
	movsx	ecx, WORD PTR _ny$[ebp]
	movsx	esi, WORD PTR _y$[ebp]
	sub	ecx, esi
	imul	edx, ecx
	add	eax, edx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _wmd$[ebp]
	mulss	xmm1, DWORD PTR _wnd$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _cwm$[ebp], xmm0

; 2074 : 			cnm = ((mx-nx)*(x-nx) + (my-ny)*(y-ny)) / (mnd * wnd);

	movsx	edx, WORD PTR _mx$[ebp]
	movsx	eax, WORD PTR _nx$[ebp]
	sub	edx, eax
	movsx	ecx, WORD PTR _x$[ebp]
	movsx	eax, WORD PTR _nx$[ebp]
	sub	ecx, eax
	imul	edx, ecx
	movsx	ecx, WORD PTR _my$[ebp]
	movsx	eax, WORD PTR _ny$[ebp]
	sub	ecx, eax
	movsx	eax, WORD PTR _y$[ebp]
	movsx	esi, WORD PTR _ny$[ebp]
	sub	eax, esi
	imul	ecx, eax
	add	edx, ecx
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _mnd$[ebp]
	mulss	xmm1, DWORD PTR _wnd$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _cnm$[ebp], xmm0

; 2075 : 			if (cwm > COS_10 || cwm < COS_120 || cnm > COS_10 || cnm < COS_120)

	movss	xmm0, DWORD PTR _cwm$[ebp]
	comiss	xmm0, DWORD PTR _COS_10
	ja	SHORT $LN5@EliminateE
	movss	xmm0, DWORD PTR _COS_120
	comiss	xmm0, DWORD PTR _cwm$[ebp]
	ja	SHORT $LN5@EliminateE
	movss	xmm0, DWORD PTR _cnm$[ebp]
	comiss	xmm0, DWORD PTR _COS_10
	ja	SHORT $LN5@EliminateE
	movss	xmm0, DWORD PTR _COS_120
	comiss	xmm0, DWORD PTR _cnm$[ebp]
	jbe	SHORT $LN6@EliminateE
$LN5@EliminateE:

; 2076 : 				{
; 2077 : #ifdef DEBUG
; 2078 : 				trimmed_by_angle++;
; 2079 : #endif
; 2080 : 				mw->DeleteWP ();

	mov	ecx, DWORD PTR _mw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 2081 : 				}
; 2082 : 			else

	jmp	$LN2@EliminateE
$LN6@EliminateE:

; 2083 : 				{
; 2084 : 				// b) It doesn't significantly reduce the threat we're exposed to
; 2085 : 				mh = ScoreThreatsOnWPLeg (w,mw,who,TT_TOTAL) + FloatToInt32(wmd);

	push	1
	movzx	ecx, BYTE PTR _who$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mw$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z ; ScoreThreatsOnWPLeg
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	ecx
	movss	xmm0, DWORD PTR _wmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _mh$[ebp], esi

; 2086 : 				oh = ScoreThreatsOnWPLeg (mw,nw,who,TT_TOTAL) + FloatToInt32(mnd);

	push	1
	movzx	ecx, BYTE PTR _who$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nw$[ebp]
	push	edx
	mov	eax, DWORD PTR _mw$[ebp]
	push	eax
	call	?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z ; ScoreThreatsOnWPLeg
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	ecx
	movss	xmm0, DWORD PTR _mnd$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _oh$[ebp], esi

; 2087 : 				nh = ScoreThreatsOnWPLeg (w,nw,who,TT_TOTAL) + FloatToInt32(wnd);

	push	1
	movzx	ecx, BYTE PTR _who$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nw$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z ; ScoreThreatsOnWPLeg
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	ecx
	movss	xmm0, DWORD PTR _wnd$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _nh$[ebp], esi

; 2088 : 				if (nh <= oh+mh)

	mov	ecx, DWORD PTR _oh$[ebp]
	add	ecx, DWORD PTR _mh$[ebp]
	cmp	DWORD PTR _nh$[ebp], ecx
	jg	SHORT $LN3@EliminateE

; 2089 : 					{
; 2090 : #ifdef DEBUG
; 2091 : 					trimmed_by_threat++;
; 2092 : #endif
; 2093 : 					mw->DeleteWP ();

	mov	ecx, DWORD PTR _mw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 2094 : 					}
; 2095 : 				else

	jmp	SHORT $LN2@EliminateE
$LN3@EliminateE:

; 2096 : 					w = mw;

	mov	edx, DWORD PTR _mw$[ebp]
	mov	DWORD PTR _w$[ebp], edx
$LN2@EliminateE:

; 2097 : 				}
; 2098 : 			}
; 2099 : 		else

	jmp	SHORT $LN1@EliminateE
$LN7@EliminateE:

; 2100 : 			w = mw;

	mov	eax, DWORD PTR _mw$[ebp]
	mov	DWORD PTR _w$[ebp], eax
$LN1@EliminateE:

; 2101 : 		// Set up for the next pass, if any
; 2102 : 		mw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _mw$[ebp], eax

; 2103 : 		nw = mw->GetNextWP();

	mov	ecx, DWORD PTR _mw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax

; 2104 : 		}

	jmp	$LN9@EliminateE
$LN8@EliminateE:

; 2105 : 	return w;

	mov	eax, DWORD PTR _w$[ebp]

; 2106 : 
; 2107 : /*
; 2108 : 	w = w1;						// Starting waypoint for this check
; 2109 : 	mw = w->GetNextWP();		// Middle waypoint (The one we may decide to eliminate)
; 2110 : 	nw = mw->GetNextWP();		// End waypoint
; 2111 : 	while (w && mw && nw && w != w2 && mw != w2)
; 2112 : 		{
; 2113 : 		// Check to see if this is a filler way point
; 2114 : 		if (mw->GetWPAction()==WP_NOTHING)
; 2115 : 			{
; 2116 : 			// Check threats FIRST HALF
; 2117 : 			mh = ScoreThreatsOnWPLeg (w,mw,who,TT_AVERAGE);
; 2118 : 			// Check threats SECOND HALF
; 2119 : 			oh = ScoreThreatsOnWPLeg (mw,nw,who,TT_AVERAGE);
; 2120 : 			// Check threats SHORTER PATH
; 2121 : 			nh = ScoreThreatsOnWPLeg (w,nw,who,TT_AVERAGE);
; 2122 : 			// Take the lowest cost route
; 2123 : 			if (nh <= oh+mh)
; 2124 : 				{
; 2125 : 				mw->DeleteWP ();
; 2126 : 				mw = NULL;
; 2127 : 				}
; 2128 : 			else
; 2129 : 				w = mw;
; 2130 : 			}
; 2131 : 		else
; 2132 : 			w = mw;
; 2133 : 		// Set up for the next pass, if any
; 2134 : 		mw = w->GetNextWP();
; 2135 : 		nw = mw->GetNextWP();
; 2136 : 		}
; 2137 : 	return w;
; 2138 : */
; 2139 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?EliminateExcessWaypoints@@YAPAVWayPointClass@@PAV1@0H@Z ENDP ; EliminateExcessWaypoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -88						; size = 4
_yd$ = -84						; size = 4
_xd$ = -80						; size = 4
_dist$ = -76						; size = 4
_nw$ = -72						; size = 4
_bw$ = -68						; size = 4
tv170 = -64						; size = 4
$T3 = -60						; size = 4
_d$ = -56						; size = 4
_step$ = -52						; size = 4
_w$ = -48						; size = 4
_tx$ = -44						; size = 2
_ty$ = -40						; size = 2
_cx$ = -36						; size = 2
_cy$ = -32						; size = 2
_ny$ = -28						; size = 2
_nx$ = -24						; size = 2
_y$ = -20						; size = 2
_x$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_w1$ = 8						; size = 4
_w2$ = 12						; size = 4
_distance$ = 16						; size = 4
?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z PROC ; AddDistanceWaypoint

; 2238 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2239 : 	WayPoint	w,nw,bw;
; 2240 : 	GridIndex	x,y,nx,ny,tx,ty,cx,cy;
; 2241 : 	int			step,dist;//,alt;
; 2242 : 	float		d,xd,yd;
; 2243 : 
; 2244 : 	w2->GetWPLocation(&tx,&ty);

	lea	eax, DWORD PTR _ty$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w2$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2245 : 	w = w1;

	mov	edx, DWORD PTR _w1$[ebp]
	mov	DWORD PTR _w$[ebp], edx
$LN7@AddDistanc:

; 2246 : 	while (w && w != w2)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN6@AddDistanc
	mov	eax, DWORD PTR _w$[ebp]
	cmp	eax, DWORD PTR _w2$[ebp]
	je	$LN6@AddDistanc

; 2247 : 		{
; 2248 : 		w->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2249 : 		nw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax

; 2250 : 		nw->GetWPLocation(&nx,&ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2251 : //		alt = nw->GetWPAltitude();
; 2252 : 		d = Distance(x,y,nx,ny);

	movzx	edx, WORD PTR _ny$[ebp]
	push	edx
	movzx	eax, WORD PTR _nx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]

; 2253 : 		dist = FloatToInt32(d);

	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist$[ebp], eax

; 2254 : 		xd = (float)(nx-x)/d;

	movsx	eax, WORD PTR _nx$[ebp]
	movsx	ecx, WORD PTR _x$[ebp]
	sub	eax, ecx
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 2255 : 		yd = (float)(ny-y)/d;

	movsx	edx, WORD PTR _ny$[ebp]
	movsx	eax, WORD PTR _y$[ebp]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _yd$[ebp], xmm0

; 2256 : 		for (step=0; step<=dist; step++)

	mov	DWORD PTR _step$[ebp], 0
	jmp	SHORT $LN5@AddDistanc
$LN4@AddDistanc:
	mov	ecx, DWORD PTR _step$[ebp]
	add	ecx, 1
	mov	DWORD PTR _step$[ebp], ecx
$LN5@AddDistanc:
	mov	edx, DWORD PTR _step$[ebp]
	cmp	edx, DWORD PTR _dist$[ebp]
	jg	$LN3@AddDistanc

; 2257 : 			{
; 2258 : 			cx = x + (GridIndex)(xd*step + 0.5F);

	movsx	eax, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	add	eax, edx
	mov	WORD PTR _cx$[ebp], ax

; 2259 : 			cy = y + (GridIndex)(yd*step + 0.5F);

	movsx	eax, WORD PTR _y$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _yd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	add	eax, edx
	mov	WORD PTR _cy$[ebp], ax

; 2260 : 			if (FloatToInt32(Distance(cx,cy,tx,ty)) <= distance)

	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _cy$[ebp]
	push	edx
	movzx	eax, WORD PTR _cx$[ebp]
	push	eax
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	cmp	eax, DWORD PTR _distance$[ebp]
	jg	SHORT $LN2@AddDistanc

; 2261 : 				{
; 2262 : 				if (step < 3)

	cmp	DWORD PTR _step$[ebp], 3
	jge	SHORT $LN1@AddDistanc

; 2263 : 					return w;

	mov	eax, DWORD PTR _w$[ebp]
	jmp	SHORT $LN8@AddDistanc
$LN1@AddDistanc:

; 2264 : 				bw = new WayPointClass(cx, cy, 0, 0, 0, 0, WP_NOTHING, 0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN10@AddDistanc
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	movzx	ecx, WORD PTR _cy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _cx$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $LN11@AddDistanc
$LN10@AddDistanc:
	mov	DWORD PTR tv170[ebp], 0
$LN11@AddDistanc:
	mov	eax, DWORD PTR tv170[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _bw$[ebp], ecx

; 2265 : 				// Add it into the wp list;
; 2266 : 				w->InsertWP(bw);

	mov	edx, DWORD PTR _bw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 2267 : 				return bw;

	mov	eax, DWORD PTR _bw$[ebp]
	jmp	SHORT $LN8@AddDistanc
$LN2@AddDistanc:

; 2268 : 				}
; 2269 : 			}

	jmp	$LN4@AddDistanc
$LN3@AddDistanc:

; 2270 : 		w = nw;

	mov	eax, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 2271 : 		}

	jmp	$LN7@AddDistanc
$LN6@AddDistanc:

; 2272 : 	return w2;

	mov	eax, DWORD PTR _w2$[ebp]
$LN8@AddDistanc:

; 2273 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z ENDP ; AddDistanceWaypoint
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_guesses$ = -120					; size = 4
$T2 = -116						; size = 4
tv355 = -112						; size = 4
_dsq$ = -108						; size = 4
_yd$ = -104						; size = 4
_dist$ = -100						; size = 4
tv251 = -96						; size = 4
$T3 = -92						; size = 4
_owner$ = -88						; size = 4
_pw$ = -84						; size = 4
_done$ = -80						; size = 4
_bw$ = -76						; size = 4
_xd$ = -72						; size = 4
_step$ = -68						; size = 4
_d$ = -64						; size = 4
_w$ = -60						; size = 4
_nw$ = -56						; size = 4
_tx$ = -52						; size = 2
_ty$ = -48						; size = 2
_bx$ = -44						; size = 2
_by$ = -40						; size = 2
_ny$ = -36						; size = 2
_nx$ = -32						; size = 2
_cy$ = -28						; size = 2
_cx$ = -24						; size = 2
_y$ = -20						; size = 2
_x$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_w1$ = 8						; size = 4
_w2$ = 12						; size = 4
_type$ = 16						; size = 4
_distance$ = 20						; size = 4
_who$ = 24						; size = 1
?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z PROC	; AddSafeWaypoint

; 2145 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2146 : 	WayPoint	w,nw,bw,pw=NULL;

	mov	DWORD PTR _pw$[ebp], 0

; 2147 : 	GridIndex	x,y,nx,ny,tx,ty,cx,cy,bx,by;
; 2148 : 	int			guesses=0,step,owner,dist,done=0; //alt,balt=0;

	mov	DWORD PTR _guesses$[ebp], 0
	mov	DWORD PTR _done$[ebp], 0

; 2149 : 	float		d,xd,yd,dsq = (float)distance*distance;

	cvtsi2ss xmm0, DWORD PTR _distance$[ebp]
	cvtsi2ss xmm1, DWORD PTR _distance$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _dsq$[ebp], xmm0

; 2150 : 
; 2151 : 	bx = by = 0;

	xor	eax, eax
	mov	WORD PTR _by$[ebp], ax
	mov	cx, WORD PTR _by$[ebp]
	mov	WORD PTR _bx$[ebp], cx

; 2152 : 	w2->GetWPLocation(&tx,&ty);

	lea	edx, DWORD PTR _ty$[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w2$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2153 : 	bw = w = w1;

	mov	ecx, DWORD PTR _w1$[ebp]
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _bw$[ebp], edx
$LN24@AddSafeWay:

; 2154 : 	while (w && w != w2 && !done)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN23@AddSafeWay
	mov	eax, DWORD PTR _w$[ebp]
	cmp	eax, DWORD PTR _w2$[ebp]
	je	$LN23@AddSafeWay
	cmp	DWORD PTR _done$[ebp], 0
	jne	$LN23@AddSafeWay

; 2155 : 		{
; 2156 : 		if (type)

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN22@AddSafeWay

; 2157 : 			nw = w->GetPrevWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _nw$[ebp], eax

; 2158 : 		else

	jmp	SHORT $LN21@AddSafeWay
$LN22@AddSafeWay:

; 2159 : 			nw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax
$LN21@AddSafeWay:

; 2160 : 		ShiAssert(nw);
; 2161 : 		w->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2162 : 		nw->GetWPLocation(&nx,&ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2163 : 		// Check both wps, and a few points in between, depending on distance
; 2164 : 		d = Distance(x,y,nx,ny);

	movzx	edx, WORD PTR _ny$[ebp]
	push	edx
	movzx	eax, WORD PTR _nx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]

; 2165 : 		dist = FloatToInt32(d);

	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist$[ebp], eax

; 2166 : 		xd = (float)(nx-x)/d;

	movsx	eax, WORD PTR _nx$[ebp]
	movsx	ecx, WORD PTR _x$[ebp]
	sub	eax, ecx
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 2167 : 		yd = (float)(ny-y)/d;

	movsx	edx, WORD PTR _ny$[ebp]
	movsx	eax, WORD PTR _y$[ebp]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _yd$[ebp], xmm0

; 2168 : 		for (step=0; step<=dist && !done; step += 10)

	mov	DWORD PTR _step$[ebp], 0
	jmp	SHORT $LN20@AddSafeWay
$LN19@AddSafeWay:
	mov	ecx, DWORD PTR _step$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _step$[ebp], ecx
$LN20@AddSafeWay:
	mov	edx, DWORD PTR _step$[ebp]
	cmp	edx, DWORD PTR _dist$[ebp]
	jg	$LN18@AddSafeWay
	cmp	DWORD PTR _done$[ebp], 0
	jne	$LN18@AddSafeWay

; 2169 : 			{
; 2170 : 			cx = x + (GridIndex)(xd*step + 0.5F);

	movsx	eax, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	add	eax, edx
	mov	WORD PTR _cx$[ebp], ax

; 2171 : 			cy = y + (GridIndex)(yd*step + 0.5F);

	movsx	eax, WORD PTR _y$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _yd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	movsx	edx, cx
	add	eax, edx
	mov	WORD PTR _cy$[ebp], ax

; 2172 : 			owner = GetOwner(TheCampaign.CampMapData,cx,cy);

	movzx	eax, WORD PTR _cy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _cx$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+296
	push	edx
	call	?GetOwner@@YAEPAEFF@Z			; GetOwner
	add	esp, 12					; 0000000cH
	movzx	eax, al
	mov	DWORD PTR _owner$[ebp], eax

; 2173 : 			if (owner && owner != who)

	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN17@AddSafeWay
	movzx	ecx, BYTE PTR _who$[ebp]
	cmp	DWORD PTR _owner$[ebp], ecx
	je	SHORT $LN17@AddSafeWay

; 2174 : 				done = 1;

	mov	DWORD PTR _done$[ebp], 1
	jmp	$LN9@AddSafeWay
$LN17@AddSafeWay:

; 2175 : 			else if (ScoreThreatFast (cx, cy, GetAltitudeLevel(sCruiseAlt), who) || DistSqu (cx,cy,tx,ty) < dsq)

	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	mov	eax, DWORD PTR _sCruiseAlt
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movzx	ecx, WORD PTR _cy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _cx$[ebp]
	push	edx
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN14@AddSafeWay
	movzx	eax, WORD PTR _ty$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _cy$[ebp]
	push	edx
	movzx	eax, WORD PTR _cx$[ebp]
	push	eax
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _dsq$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN15@AddSafeWay
$LN14@AddSafeWay:

; 2176 : 				done = 1;

	mov	DWORD PTR _done$[ebp], 1
	jmp	SHORT $LN9@AddSafeWay
$LN15@AddSafeWay:

; 2177 : 			else if (DistanceToFront(cx,cy) < distance / 2.0F)

	movzx	ecx, WORD PTR _cy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _cx$[ebp]
	push	edx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR tv355[ebp]
	cvtsi2ss xmm0, DWORD PTR _distance$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR tv355[ebp]
	jbe	SHORT $LN12@AddSafeWay

; 2178 : 				done = 1;

	mov	DWORD PTR _done$[ebp], 1
	jmp	SHORT $LN9@AddSafeWay
$LN12@AddSafeWay:

; 2179 : 			else if (step)

	cmp	DWORD PTR _step$[ebp], 0
	je	SHORT $LN10@AddSafeWay

; 2180 : 				{
; 2181 : 				// Otherwise, make this location our last best guess
; 2182 : 				bx = cx;

	mov	ax, WORD PTR _cx$[ebp]
	mov	WORD PTR _bx$[ebp], ax

; 2183 : 				by = cy;

	mov	cx, WORD PTR _cy$[ebp]
	mov	WORD PTR _by$[ebp], cx

; 2184 : 				bw = NULL;

	mov	DWORD PTR _bw$[ebp], 0

; 2185 : 				}
; 2186 : 			else

	jmp	SHORT $LN9@AddSafeWay
$LN10@AddSafeWay:

; 2187 : 				bw = w;											// Use existing WP if possible

	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _bw$[ebp], edx
$LN9@AddSafeWay:

; 2188 : 			if (type)

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN8@AddSafeWay

; 2189 : 				pw = nw;

	mov	eax, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _pw$[ebp], eax

; 2190 : 			else

	jmp	SHORT $LN7@AddSafeWay
$LN8@AddSafeWay:

; 2191 : 				pw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _pw$[ebp], ecx
$LN7@AddSafeWay:

; 2192 : 			}

	jmp	$LN19@AddSafeWay
$LN18@AddSafeWay:

; 2193 : 		w = nw;

	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 2194 : 		}

	jmp	$LN24@AddSafeWay
$LN23@AddSafeWay:

; 2195 : 	if (bw)

	cmp	DWORD PTR _bw$[ebp], 0
	je	$LN1@AddSafeWay

; 2196 : 		{
; 2197 : 		// Check if we can share/co-op this waypoint
; 2198 : 		if (bw->GetWPAction() != WP_NOTHING)

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	test	eax, eax
	je	$LN5@AddSafeWay

; 2199 : 			{
; 2200 : 			// find a decent spot for it.
; 2201 : 			if (type)

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN4@AddSafeWay

; 2202 : 				nw = w1->GetPrevWP();

	mov	ecx, DWORD PTR _w1$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _nw$[ebp], eax

; 2203 : 			else

	jmp	SHORT $LN3@AddSafeWay
$LN4@AddSafeWay:

; 2204 : 				nw = w1->GetNextWP();

	mov	ecx, DWORD PTR _w1$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax
$LN3@AddSafeWay:

; 2205 : 			w1->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w1$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2206 : 			nw->GetWPLocation(&nx,&ny);

	lea	edx, DWORD PTR _ny$[ebp]
	push	edx
	lea	eax, DWORD PTR _nx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2207 : 			xd = d = Distance(x,y,nx,ny);

	movzx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 2208 : 			if (xd > 5.0F)

	movss	xmm0, DWORD PTR _xd$[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	SHORT $LN2@AddSafeWay

; 2209 : 				xd = 5.0F;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _xd$[ebp], xmm0
$LN2@AddSafeWay:

; 2210 : 			bx = x + (GridIndex)(((float)(nx-x)/d)*xd + 0.5F);

	movsx	edx, WORD PTR _x$[ebp]
	movsx	eax, WORD PTR _nx$[ebp]
	movsx	ecx, WORD PTR _x$[ebp]
	sub	eax, ecx
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movsx	ecx, ax
	add	edx, ecx
	mov	WORD PTR _bx$[ebp], dx

; 2211 : 			by = y + (GridIndex)(((float)(ny-y)/d)*xd + 0.5F);

	movsx	edx, WORD PTR _y$[ebp]
	movsx	eax, WORD PTR _ny$[ebp]
	movsx	ecx, WORD PTR _y$[ebp]
	sub	eax, ecx
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movsx	ecx, ax
	add	edx, ecx
	mov	WORD PTR _by$[ebp], dx

; 2212 : 			}
; 2213 : 		else

	jmp	SHORT $LN1@AddSafeWay
$LN5@AddSafeWay:

; 2214 : 			{
; 2215 : 			bw->SetWPFlag(WPF_ASSEMBLE);

	push	2
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 2216 : 			return bw;

	mov	eax, DWORD PTR _bw$[ebp]
	jmp	SHORT $LN25@AddSafeWay
$LN1@AddSafeWay:

; 2217 : 			}
; 2218 : 		}
; 2219 : 	nw = new WayPointClass(bx, by, 0, 0, 0, 0, WP_NOTHING, WPF_ASSEMBLE);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN27@AddSafeWay
	push	2
	push	0
	push	0
	push	0
	push	0
	push	0
	movzx	edx, WORD PTR _by$[ebp]
	push	edx
	movzx	eax, WORD PTR _bx$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv251[ebp], eax
	jmp	SHORT $LN28@AddSafeWay
$LN27@AddSafeWay:
	mov	DWORD PTR tv251[ebp], 0
$LN28@AddSafeWay:
	mov	ecx, DWORD PTR tv251[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _nw$[ebp], edx

; 2220 : 	// Add it into the wp list;
; 2221 : 	pw->InsertWP (nw);

	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 2222 : 
; 2223 : 	// Eliminate any unneeded waypoints before or after this one.
; 2224 : 	// KCK NOTE: This is a fairly expensive check for a possibility of eliminating one waypoint.
; 2225 : 	// If we determine we need more speed, we can axe this.
; 2226 : /*	bw = nw->GetNextWP();
; 2227 : 	if (bw && bw->GetNextWP())
; 2228 : 		EliminateExcessWaypoints(nw,bw->GetNextWP(),who);
; 2229 : 	bw = pw->GetPrevWP();
; 2230 : 	if (bw)
; 2231 : 		EliminateExcessWaypoints(bw,nw,who);
; 2232 : */
; 2233 : 	return nw;

	mov	eax, DWORD PTR _nw$[ebp]
$LN25@AddSafeWay:

; 2234 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddSafeWaypoint@@YAPAVWayPointClass@@PAV1@0HHE@Z ENDP	; AddSafeWaypoint
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_threats$1 = -4						; size = 4
_w$ = 8							; size = 4
_nw$ = 12						; size = 4
_flight$ = 16						; size = 4
?CheckSafePath@@YAPAVWayPointClass@@PAV1@0PAVFlightClass@@@Z PROC ; CheckSafePath

; 1804 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1805 : 	// If we're not a lead flight, we just follow the waypoints we've been given
; 1806 : 	if (!flight->GetUnitMissionID())

	mov	eax, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+688]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@CheckSafeP

; 1807 : 		{
; 1808 : 		int threats = ScoreThreatsOnWPLeg(w,nw,flight->GetTeam(),TT_MAX);

	push	2
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _nw$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z ; ScoreThreatsOnWPLeg
	add	esp, 16					; 00000010H
	mov	DWORD PTR _threats$1[ebp], eax

; 1809 : 
; 1810 : 		if (threats > MIN_AVOID_THREAT)

	movsx	ecx, WORD PTR ?MIN_AVOID_THREAT@@3FA	; MIN_AVOID_THREAT
	cmp	DWORD PTR _threats$1[ebp], ecx
	jle	SHORT $LN3@CheckSafeP

; 1811 : 			{
; 1812 : 			// Try to find a way around
; 1813 : 			SetCurrentAltitude();

	call	?SetCurrentAltitude@@YAXXZ		; SetCurrentAltitude

; 1814 : 			if (!FindSafePath(w,nw,flight))

	mov	edx, DWORD PTR _flight$[ebp]
	push	edx
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z ; FindSafePath
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@CheckSafeP

; 1815 : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@CheckSafeP
$LN3@CheckSafeP:

; 1816 : 			}
; 1817 : 		}
; 1818 : 	return nw;

	mov	eax, DWORD PTR _nw$[ebp]
$LN4@CheckSafeP:

; 1819 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckSafePath@@YAPAVWayPointClass@@PAV1@0PAVFlightClass@@@Z ENDP ; CheckSafePath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_dist$ = -60						; size = 4
_al$ = -56						; size = 4
_xd$ = -52						; size = 4
_steps$ = -48						; size = 4
_threat$ = -44						; size = 4
_yd$ = -40						; size = 4
_d$ = -36						; size = 4
_step$ = -32						; size = 4
_worst$ = -28						; size = 4
_x$ = -24						; size = 2
_y$ = -20						; size = 2
_y2$ = -16						; size = 2
_x2$ = -12						; size = 2
_y1$ = -8						; size = 2
_x1$ = -4						; size = 2
_w1$ = 8						; size = 4
_w2$ = 12						; size = 4
_who$ = 16						; size = 1
_type$ = 20						; size = 4
?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z PROC	; ScoreThreatsOnWPLeg

; 1823 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1824 : 	GridIndex   x,y,x1,y1,x2,y2;
; 1825 : 	float		xd,yd,d;
; 1826 : 	int			step,steps=0,threat,dist,worst=0,al;

	mov	DWORD PTR _steps$[ebp], 0
	mov	DWORD PTR _worst$[ebp], 0

; 1827 : 
; 1828 : 	// Check for threats along this leg
; 1829 : 	w1->GetWPLocation(&x1,&y1);

	lea	eax, DWORD PTR _y1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w1$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1830 : 	w2->GetWPLocation(&x2,&y2);

	lea	edx, DWORD PTR _y2$[ebp]
	push	edx
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w2$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1831 : 	d = Distance(x1,y1,x2,y2);

	movzx	ecx, WORD PTR _y2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x2$[ebp]
	push	edx
	movzx	eax, WORD PTR _y1$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x1$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]

; 1832 : //	al = GetAltitudeLevel(sCurrentAlt);
; 1833 : 	if (w2->GetWPFlags() & WPF_HOLDCURRENT)

	mov	ecx, DWORD PTR _w2$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 2048				; 00000800H
	je	SHORT $LN11@ScoreThrea

; 1834 : 		al = GetAltitudeLevel(w1->GetWPAltitude());

	mov	ecx, DWORD PTR _w1$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR _al$[ebp], eax

; 1835 : 	else

	jmp	SHORT $LN10@ScoreThrea
$LN11@ScoreThrea:

; 1836 : 		al = GetAltitudeLevel(w2->GetWPAltitude());

	mov	ecx, DWORD PTR _w2$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR _al$[ebp], eax
$LN10@ScoreThrea:

; 1837 : 
; 1838 : 	// Traverse the waypoint leg
; 1839 : 	xd = yd = 0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _yd$[ebp], xmm0
	movss	xmm0, DWORD PTR _yd$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 1840 : 	ShiAssert(d);
; 1841 : 	if (d)

	movss	xmm0, DWORD PTR _d$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@ScoreThrea

; 1842 : 	{
; 1843 : 		xd = (float)(x2-x1)/d;

	movsx	edx, WORD PTR _x2$[ebp]
	movsx	eax, WORD PTR _x1$[ebp]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 1844 : 		yd = (float)(y2-y1)/d;

	movsx	ecx, WORD PTR _y2$[ebp]
	movsx	edx, WORD PTR _y1$[ebp]
	sub	ecx, edx
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _yd$[ebp], xmm0
$LN9@ScoreThrea:

; 1845 : 	}
; 1846 : 
; 1847 : 	dist = FloatToInt32(d);

	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist$[ebp], eax

; 1848 : 	for (step=0; step<=dist; step+=MAP_RATIO)

	mov	DWORD PTR _step$[ebp], 0
	jmp	SHORT $LN8@ScoreThrea
$LN7@ScoreThrea:
	mov	eax, DWORD PTR _step$[ebp]
	add	eax, 6
	mov	DWORD PTR _step$[ebp], eax
$LN8@ScoreThrea:
	mov	ecx, DWORD PTR _step$[ebp]
	cmp	ecx, DWORD PTR _dist$[ebp]
	jg	$LN6@ScoreThrea

; 1849 : 		{
; 1850 : 		x = x1 + (GridIndex)(xd*step + 0.5F);

	movsx	edx, WORD PTR _x1$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movsx	ecx, ax
	add	edx, ecx
	mov	WORD PTR _x$[ebp], dx

; 1851 : 		y = y1 + (GridIndex)(yd*step + 0.5F);

	movsx	edx, WORD PTR _y1$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _yd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movsx	ecx, ax
	add	edx, ecx
	mov	WORD PTR _y$[ebp], dx

; 1852 : 		// Check threats
; 1853 : 		threat = ScoreThreatFast (x,y,al,who);

	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	mov	eax, DWORD PTR _al$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	mov	DWORD PTR _threat$[ebp], eax

; 1854 : 		if (type == TT_MAX && threat > worst)

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN5@ScoreThrea
	mov	eax, DWORD PTR _threat$[ebp]
	cmp	eax, DWORD PTR _worst$[ebp]
	jle	SHORT $LN5@ScoreThrea

; 1855 : 			worst = threat;

	mov	ecx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR _worst$[ebp], ecx
	jmp	SHORT $LN3@ScoreThrea
$LN5@ScoreThrea:

; 1856 : 		else if (type == TT_TOTAL || type == TT_AVERAGE)

	cmp	DWORD PTR _type$[ebp], 1
	je	SHORT $LN2@ScoreThrea
	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN3@ScoreThrea
$LN2@ScoreThrea:

; 1857 : 			worst += threat;

	mov	edx, DWORD PTR _worst$[ebp]
	add	edx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR _worst$[ebp], edx
$LN3@ScoreThrea:

; 1858 : 		steps++;

	mov	eax, DWORD PTR _steps$[ebp]
	add	eax, 1
	mov	DWORD PTR _steps$[ebp], eax

; 1859 : 		}

	jmp	$LN7@ScoreThrea
$LN6@ScoreThrea:

; 1860 : 	if (type == TT_AVERAGE)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN1@ScoreThrea

; 1861 : 		worst /= steps;

	mov	eax, DWORD PTR _worst$[ebp]
	cdq
	idiv	DWORD PTR _steps$[ebp]
	mov	DWORD PTR _worst$[ebp], eax
$LN1@ScoreThrea:

; 1862 : 	return worst;

	mov	eax, DWORD PTR _worst$[ebp]

; 1863 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ScoreThreatsOnWPLeg@@YAHPAVWayPointClass@@0EH@Z ENDP	; ScoreThreatsOnWPLeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_bests$ = -64						; size = 4
_y$ = -60						; size = 2
_x$ = -56						; size = 2
_threat$ = -52						; size = 4
_d$ = -48						; size = 4
_bestLevel$ = -44					; size = 4
_la$ = -40						; size = 4
_ha$ = -36						; size = 4
_ca$ = -32						; size = 4
_a$ = -28						; size = 4
_score$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_tx$ = 8						; size = 2
_ty$ = 12						; size = 2
_who$ = 16						; size = 1
_min$ = 20						; size = 4
_max$ = 24						; size = 4
_try_for$ = 28						; size = 4
_type$ = 32						; size = 4
?CheckBestAltitude@@YAHFFEHHHH@Z PROC			; CheckBestAltitude

; 1867 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1868 : 	GridIndex   x,y;
; 1869 : 	int			a,ca,la=1,ha=ALT_LEVELS,bests=9999,threat;

	mov	DWORD PTR _la$[ebp], 1
	mov	DWORD PTR _ha$[ebp], 5
	mov	DWORD PTR _bests$[ebp], 9999		; 0000270fH

; 1870 : 	int			score[ALT_LEVELS] = { 0 };

	mov	DWORD PTR _score$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _score$[ebp+4], eax
	mov	DWORD PTR _score$[ebp+8], eax
	mov	DWORD PTR _score$[ebp+12], eax
	mov	DWORD PTR _score$[ebp+16], eax

; 1871 : 	int			bestLevel,d;
; 1872 : 	
; 1873 : 	// Some basic stuff
; 1874 : 	if (min == max)

	mov	ecx, DWORD PTR _min$[ebp]
	cmp	ecx, DWORD PTR _max$[ebp]
	jne	SHORT $LN35@CheckBestA

; 1875 : 		return max;

	mov	eax, DWORD PTR _max$[ebp]
	jmp	$LN36@CheckBestA
$LN35@CheckBestA:

; 1876 : 	bestLevel = 2;

	mov	DWORD PTR _bestLevel$[ebp], 2

; 1877 : 
; 1878 : 	// Determine our bounds
; 1879 : 	for (a=1; a<ALT_LEVELS; a++)

	mov	DWORD PTR _a$[ebp], 1
	jmp	SHORT $LN34@CheckBestA
$LN33@CheckBestA:
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 1
	mov	DWORD PTR _a$[ebp], edx
$LN34@CheckBestA:
	cmp	DWORD PTR _a$[ebp], 5
	jge	SHORT $LN32@CheckBestA

; 1880 : 		{
; 1881 : 		if (MaxAltAtLevel[a] < min)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR ?MaxAltAtLevel@@3PAHA[eax*4]
	cmp	ecx, DWORD PTR _min$[ebp]
	jge	SHORT $LN31@CheckBestA

; 1882 : 			la = a+1;

	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 1
	mov	DWORD PTR _la$[ebp], edx
$LN31@CheckBestA:

; 1883 : 		if (MinAltAtLevel[a] > max && ha == ALT_LEVELS)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR ?MinAltAtLevel@@3PAHA[eax*4]
	cmp	ecx, DWORD PTR _max$[ebp]
	jle	SHORT $LN30@CheckBestA
	cmp	DWORD PTR _ha$[ebp], 5
	jne	SHORT $LN30@CheckBestA

; 1884 : 			ha = a;

	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _ha$[ebp], edx
$LN30@CheckBestA:

; 1885 : 		}

	jmp	SHORT $LN33@CheckBestA
$LN32@CheckBestA:

; 1886 : 	if (la == ha-1)

	mov	eax, DWORD PTR _ha$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _la$[ebp], eax
	jne	SHORT $LN29@CheckBestA

; 1887 : 		{
; 1888 : 		if (la == GetAltitudeLevel(try_for))

	mov	ecx, DWORD PTR _try_for$[ebp]
	push	ecx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	cmp	DWORD PTR _la$[ebp], eax
	jne	SHORT $LN28@CheckBestA

; 1889 : 			return try_for;

	mov	eax, DWORD PTR _try_for$[ebp]
	jmp	$LN36@CheckBestA

; 1890 : 		else

	jmp	SHORT $LN29@CheckBestA
$LN28@CheckBestA:

; 1891 : 			return max;

	mov	eax, DWORD PTR _max$[ebp]
	jmp	$LN36@CheckBestA
$LN29@CheckBestA:

; 1892 : 		}
; 1893 : 
; 1894 : 	// Check this spot and 4 adjancent spots
; 1895 : 	for (d=0; d<=Here; d+=2)

	mov	DWORD PTR _d$[ebp], 0
	jmp	SHORT $LN26@CheckBestA
$LN25@CheckBestA:
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 2
	mov	DWORD PTR _d$[ebp], edx
$LN26@CheckBestA:
	cmp	DWORD PTR _d$[ebp], 8
	jg	$LN24@CheckBestA

; 1896 : 		{
; 1897 : 		x = tx + dx[d] * 10;

	movsx	eax, WORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR ?dx@@3PAFA[ecx*2]
	imul	edx, 10					; 0000000aH
	add	eax, edx
	mov	WORD PTR _x$[ebp], ax

; 1898 : 		y = ty + dy[d] * 10;

	movsx	eax, WORD PTR _ty$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, WORD PTR ?dy@@3PAFA[ecx*2]
	imul	edx, 10					; 0000000aH
	add	eax, edx
	mov	WORD PTR _y$[ebp], ax

; 1899 : 		// Check each level
; 1900 : 		for (a=la; a<ha; a++)

	mov	eax, DWORD PTR _la$[ebp]
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN23@CheckBestA
$LN22@CheckBestA:
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 1
	mov	DWORD PTR _a$[ebp], ecx
$LN23@CheckBestA:
	mov	edx, DWORD PTR _a$[ebp]
	cmp	edx, DWORD PTR _ha$[ebp]
	jge	SHORT $LN21@CheckBestA

; 1901 : 			{
; 1902 : 			threat = ScoreThreatFast (x,y,a,who);

	movzx	eax, BYTE PTR _who$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?ScoreThreatFast@@YAHFFHE@Z		; ScoreThreatFast
	add	esp, 16					; 00000010H
	mov	DWORD PTR _threat$[ebp], eax

; 1903 : 			if (type == TT_TOTAL || type == TT_AVERAGE)

	cmp	DWORD PTR _type$[ebp], 1
	je	SHORT $LN19@CheckBestA
	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN20@CheckBestA
$LN19@CheckBestA:

; 1904 : 				score[a] += threat;

	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _score$[ebp+ecx*4]
	add	edx, DWORD PTR _threat$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _score$[ebp+eax*4], edx
	jmp	SHORT $LN18@CheckBestA
$LN20@CheckBestA:

; 1905 : 			else if (type == TT_MAX && threat > score[a])

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN18@CheckBestA
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _threat$[ebp]
	cmp	edx, DWORD PTR _score$[ebp+ecx*4]
	jle	SHORT $LN18@CheckBestA

; 1906 : 				score[a] = threat;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR _score$[ebp+eax*4], ecx
$LN18@CheckBestA:

; 1907 : 			}

	jmp	SHORT $LN22@CheckBestA
$LN21@CheckBestA:

; 1908 : 		}

	jmp	$LN25@CheckBestA
$LN24@CheckBestA:

; 1909 : 
; 1910 : 	// Average the scores, if that's what we're looking for
; 1911 : 	if (type == TT_AVERAGE)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN16@CheckBestA

; 1912 : 		{
; 1913 : 		for (a=la; a<ha; a++)

	mov	edx, DWORD PTR _la$[ebp]
	mov	DWORD PTR _a$[ebp], edx
	jmp	SHORT $LN15@CheckBestA
$LN14@CheckBestA:
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 1
	mov	DWORD PTR _a$[ebp], eax
$LN15@CheckBestA:
	mov	ecx, DWORD PTR _a$[ebp]
	cmp	ecx, DWORD PTR _ha$[ebp]
	jge	SHORT $LN16@CheckBestA

; 1914 : 			score[a] = score[a] / 5;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _score$[ebp+edx*4]
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _score$[ebp+edx*4], eax
	jmp	SHORT $LN14@CheckBestA
$LN16@CheckBestA:

; 1915 : 		}
; 1916 : 
; 1917 : 	// Bonus for being at or near the altitude we're trying for
; 1918 : 	ca = GetAltitudeLevel(try_for);

	mov	eax, DWORD PTR _try_for$[ebp]
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR _ca$[ebp], eax

; 1919 : 	score[ca] -= 20;

	mov	ecx, DWORD PTR _ca$[ebp]
	mov	edx, DWORD PTR _score$[ebp+ecx*4]
	sub	edx, 20					; 00000014H
	mov	eax, DWORD PTR _ca$[ebp]
	mov	DWORD PTR _score$[ebp+eax*4], edx

; 1920 : 	if (ca-1 >= la)

	mov	ecx, DWORD PTR _ca$[ebp]
	sub	ecx, 1
	cmp	ecx, DWORD PTR _la$[ebp]
	jl	SHORT $LN12@CheckBestA

; 1921 : 		score[ca-1] -= 10;

	mov	edx, DWORD PTR _ca$[ebp]
	mov	eax, DWORD PTR _score$[ebp+edx*4-4]
	sub	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _ca$[ebp]
	mov	DWORD PTR _score$[ebp+ecx*4-4], eax
$LN12@CheckBestA:

; 1922 : 	if (ca+1 < ha)

	mov	edx, DWORD PTR _ca$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _ha$[ebp]
	jge	SHORT $LN11@CheckBestA

; 1923 : 		score[ca+1] -= 10;

	mov	eax, DWORD PTR _ca$[ebp]
	mov	ecx, DWORD PTR _score$[ebp+eax*4+4]
	sub	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _ca$[ebp]
	mov	DWORD PTR _score$[ebp+edx*4+4], ecx
$LN11@CheckBestA:

; 1924 : 
; 1925 : 	// Find the best level
; 1926 : 	for (a=la; a<ha; a++)

	mov	eax, DWORD PTR _la$[ebp]
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN10@CheckBestA
$LN9@CheckBestA:
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 1
	mov	DWORD PTR _a$[ebp], ecx
$LN10@CheckBestA:
	mov	edx, DWORD PTR _a$[ebp]
	cmp	edx, DWORD PTR _ha$[ebp]
	jge	SHORT $LN8@CheckBestA

; 1927 : 		{
; 1928 : 		if (score[a] < bests)

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _score$[ebp+eax*4]
	cmp	ecx, DWORD PTR _bests$[ebp]
	jge	SHORT $LN7@CheckBestA

; 1929 : 			{
; 1930 : 			bests = score[a];

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _score$[ebp+edx*4]
	mov	DWORD PTR _bests$[ebp], eax

; 1931 : 			bestLevel = a;

	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _bestLevel$[ebp], ecx
$LN7@CheckBestA:

; 1932 : 			}
; 1933 : 		}

	jmp	SHORT $LN9@CheckBestA
$LN8@CheckBestA:

; 1934 : 
; 1935 : 	// Find the best altitude
; 1936 : 	if (bestLevel == GetAltitudeLevel(try_for))

	mov	edx, DWORD PTR _try_for$[ebp]
	push	edx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	cmp	DWORD PTR _bestLevel$[ebp], eax
	jne	SHORT $LN6@CheckBestA

; 1937 : 		return try_for;

	mov	eax, DWORD PTR _try_for$[ebp]
	jmp	SHORT $LN36@CheckBestA
	jmp	SHORT $LN36@CheckBestA
$LN6@CheckBestA:

; 1938 : 	else if (bestLevel == GetAltitudeLevel(max))

	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	cmp	DWORD PTR _bestLevel$[ebp], eax
	jne	SHORT $LN4@CheckBestA

; 1939 : 		return max;

	mov	eax, DWORD PTR _max$[ebp]
	jmp	SHORT $LN36@CheckBestA
	jmp	SHORT $LN36@CheckBestA
$LN4@CheckBestA:

; 1940 : 	else if (bestLevel == GetAltitudeLevel(min))

	mov	ecx, DWORD PTR _min$[ebp]
	push	ecx
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	cmp	DWORD PTR _bestLevel$[ebp], eax
	jne	SHORT $LN2@CheckBestA

; 1941 : 		return min;

	mov	eax, DWORD PTR _min$[ebp]
	jmp	SHORT $LN36@CheckBestA

; 1942 : 	else

	jmp	SHORT $LN36@CheckBestA
$LN2@CheckBestA:

; 1943 : 		return GetAltitudeFromLevel (bestLevel, tx+ty);

	movsx	edx, WORD PTR _tx$[ebp]
	movsx	eax, WORD PTR _ty$[ebp]
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR _bestLevel$[ebp]
	push	ecx
	call	?GetAltitudeFromLevel@@YAHHH@Z		; GetAltitudeFromLevel
	add	esp, 8
$LN36@CheckBestA:

; 1944 : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckBestAltitude@@YAHFFEHHHH@Z ENDP			; CheckBestAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -120						; size = 4
tv159 = -116						; size = 4
$T3 = -112						; size = 4
$T4 = -108						; size = 4
_w$ = -104						; size = 4
_moveType$ = -100					; size = 4
_passes$ = -96						; size = 4
_y$ = -92						; size = 2
_x$ = -88						; size = 2
_nx$ = -84						; size = 2
_ny$ = -80						; size = 2
_path$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_w1$ = 8						; size = 4
_w2$ = 12						; size = 4
_flight$ = 16						; size = 4
?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z PROC ; FindSafePath

; 1953 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1954 : 	PathClass   path;

	lea	ecx, DWORD PTR _path$[ebp]
	call	??0PathClass@@QAE@XZ			; PathClass::PathClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1955 : 	GridIndex   x,y,nx,ny;
; 1956 : 	WayPoint    w;
; 1957 : 	MoveType	moveType = Air;

	mov	DWORD PTR _moveType$[ebp], 5

; 1958 : 	int			passes = 0;

	mov	DWORD PTR _passes$[ebp], 0

; 1959 : 
; 1960 : 	// Set up our data
; 1961 : 	QuickSearch = MAP_RATIO*2;                       // Use fast path routines

	mov	DWORD PTR ?QuickSearch@@3HA, 12		; QuickSearch, 0000000cH

; 1962 : 	w1->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w1$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1963 : 	w2->GetWPLocation(&nx,&ny);

	lea	edx, DWORD PTR _ny$[ebp]
	push	edx
	lea	eax, DWORD PTR _nx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w2$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1964 : 	w = w1;

	mov	ecx, DWORD PTR _w1$[ebp]
	mov	DWORD PTR _w$[ebp], ecx

; 1965 : 	if (flight->IsHelicopter())

	mov	edx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax+992]
	call	edx
	test	eax, eax
	je	SHORT $LN9@FindSafePa

; 1966 : 		moveType = LowAir;

	mov	DWORD PTR _moveType$[ebp], 4
$LN9@FindSafePa:

; 1967 : 	moveAlt = GetAltitudeLevel(sCurrentAlt);

	mov	eax, DWORD PTR _sCurrentAlt
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	mov	DWORD PTR ?moveAlt@@3HA, eax		; moveAlt

; 1968 : 	maxSearch = AIR_PATH_MAX;

	movsx	ecx, WORD PTR ?AIR_PATH_MAX@@3FA	; AIR_PATH_MAX
	mov	DWORD PTR ?maxSearch@@3HA, ecx		; maxSearch
$LN8@FindSafePa:

; 1969 : 
; 1970 : 	// Check high altitude
; 1971 : 	// Loop until we find a full path to our next waypoint
; 1972 : 	while (x != nx || y != ny)

	movsx	edx, WORD PTR _x$[ebp]
	movsx	eax, WORD PTR _nx$[ebp]
	cmp	edx, eax
	jne	SHORT $LN6@FindSafePa
	movsx	ecx, WORD PTR _y$[ebp]
	movsx	edx, WORD PTR _ny$[ebp]
	cmp	ecx, edx
	je	$LN7@FindSafePa
$LN6@FindSafePa:

; 1973 : 		{
; 1974 : 		if (GetGridPath(&path,x,y,nx,ny,moveType,flight->GetTeam(),PATH_ENEMYCOST) >= 0)

	push	8
	mov	eax, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _moveType$[ebp]
	push	edx
	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?GetGridPath@@YAHPAVBasePathClass@@FFFFHHH@Z ; GetGridPath
	add	esp, 32					; 00000020H
	test	eax, eax
	jl	SHORT $LN5@FindSafePa

; 1975 : 			w = FillAirPath(&path,&x,&y,nx,ny,w);

	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?FillAirPath@@YAPAVWayPointClass@@PAVBasePathClass@@PAF1FFPAV1@@Z ; FillAirPath
	add	esp, 24					; 00000018H
	mov	DWORD PTR _w$[ebp], eax

; 1976 : 		else 

	jmp	SHORT $LN4@FindSafePa
$LN5@FindSafePa:

; 1977 : 			break;

	jmp	SHORT $LN7@FindSafePa
$LN4@FindSafePa:

; 1978 : 		if (passes++ > 1)

	mov	edx, DWORD PTR _passes$[ebp]
	mov	DWORD PTR tv159[ebp], edx
	mov	eax, DWORD PTR _passes$[ebp]
	add	eax, 1
	mov	DWORD PTR _passes$[ebp], eax
	cmp	DWORD PTR tv159[ebp], 1
	jle	SHORT $LN3@FindSafePa

; 1979 : 			{
; 1980 : 			MonoPrint("Failed to find a path to target at %d,%d.\n",nx,ny);

	movsx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nx$[ebp]
	push	edx
	push	OFFSET ??_C@_0CL@GNEDMECB@Failed?5to?5find?5a?5path?5to?5target?5@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 1981 : 			maxSearch = MAX_SEARCH;

	mov	DWORD PTR ?maxSearch@@3HA, 2000		; maxSearch, 000007d0H

; 1982 : 			QuickSearch = 0;

	mov	DWORD PTR ?QuickSearch@@3HA, 0		; QuickSearch

; 1983 : 			return 0;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN10@FindSafePa
$LN3@FindSafePa:

; 1984 : 			}
; 1985 : 		}

	jmp	$LN8@FindSafePa
$LN7@FindSafePa:

; 1986 : 
; 1987 : #ifdef DEBUG
; 1988 : 	gAvgPasses = (float)(gAvgPasses*gTries + passes) / (float)(gTries+1);
; 1989 : 	gTries++;
; 1990 : #endif
; 1991 : 
; 1992 : 	maxSearch = MAX_SEARCH;

	mov	DWORD PTR ?maxSearch@@3HA, 2000		; maxSearch, 000007d0H

; 1993 : 	QuickSearch = 0;

	mov	DWORD PTR ?QuickSearch@@3HA, 0		; QuickSearch

; 1994 : 
; 1995 : 	if (x!=nx || y!=ny)

	movsx	eax, WORD PTR _x$[ebp]
	movsx	ecx, WORD PTR _nx$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@FindSafePa
	movsx	edx, WORD PTR _y$[ebp]
	movsx	eax, WORD PTR _ny$[ebp]
	cmp	edx, eax
	je	SHORT $LN2@FindSafePa
$LN1@FindSafePa:

; 1996 : 		return 0;

	mov	DWORD PTR $T4[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN10@FindSafePa
$LN2@FindSafePa:

; 1997 : 
; 1998 : 	// Now let's try to eliminated unneeded waypoints
; 1999 : //	EliminateExcessWaypoints (w1,w2,flight->GetTeam());
; 2000 : 
; 2001 : 	return 1;

	mov	DWORD PTR $T3[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _path$[ebp]
	call	??1PathClass@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
$LN10@FindSafePa:

; 2002 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z$0:
	lea	ecx, DWORD PTR _path$[ebp]
	jmp	??1PathClass@@QAE@XZ
__ehhandler$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindSafePath@@YAHPAVWayPointClass@@0PAVFlightClass@@@Z ENDP ; FindSafePath
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\package.h
;	COMDAT ?GetMissionRequest@PackageClass@@QAEPAVMissionRequestClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMissionRequest@PackageClass@@QAEPAVMissionRequestClass@@XZ PROC ; PackageClass::GetMissionRequest, COMDAT
; _this$ = ecx

; 96   : 		MissionRequestClass *GetMissionRequest (void)	{ return &mis_request; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMissionRequest@PackageClass@@QAEPAVMissionRequestClass@@XZ ENDP ; PackageClass::GetMissionRequest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\package.h
;	COMDAT ?GetEgress@PackageClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEgress@PackageClass@@QAEPAVWayPointClass@@XZ PROC	; PackageClass::GetEgress, COMDAT
; _this$ = ecx

; 94   : 		WayPoint GetEgress (void)						{ return egress; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+388]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEgress@PackageClass@@QAEPAVWayPointClass@@XZ ENDP	; PackageClass::GetEgress
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\package.h
;	COMDAT ?GetIngress@PackageClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIngress@PackageClass@@QAEPAVWayPointClass@@XZ PROC	; PackageClass::GetIngress, COMDAT
; _this$ = ecx

; 93   : 		WayPoint GetIngress (void)						{ return ingress; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+384]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIngress@PackageClass@@QAEPAVWayPointClass@@XZ ENDP	; PackageClass::GetIngress
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\package.h
;	COMDAT ?GetTPTime@PackageClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTPTime@PackageClass@@QAEKXZ PROC			; PackageClass::GetTPTime, COMDAT
; _this$ = ecx

; 90   : 		CampaignTime GetTPTime (void)					{ return tp_time; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+368]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTPTime@PackageClass@@QAEKXZ ENDP			; PackageClass::GetTPTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\flight.h
;	COMDAT ?GetUnitPackage@FlightClass@@QAEPAVPackageClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPackage@FlightClass@@QAEPAVPackageClass@@XZ PROC ; FlightClass::GetUnitPackage, COMDAT
; _this$ = ecx

; 216  : 		PackageClass* GetUnitPackage (void)	{ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 			return (PackageClass*)vuDatabase->Find(package); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	mov	edx, DWORD PTR [eax+384]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find

; 218  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPackage@FlightClass@@QAEPAVPackageClass@@XZ ENDP ; FlightClass::GetUnitPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC	; UnitClass::GetFirstUnitWP, COMDAT
; _this$ = ecx

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP	; UnitClass::GetFirstUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ PROC ; UnitClass::GetClassData, COMDAT
; _this$ = ecx

; 160  : 	UnitClassDataType *GetClassData (void) { return class_data; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+236]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ENDP ; UnitClass::GetClassData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1PathClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathClass@@QAE@XZ PROC				; PathClass::~PathClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BasePathClass@@QAE@XZ		; BasePathClass::~BasePathClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathClass@@QAE@XZ ENDP				; PathClass::~PathClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\asearch.h
;	COMDAT ?GetLength@BasePathClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLength@BasePathClass@@QAEHXZ PROC			; BasePathClass::GetLength, COMDAT
; _this$ = ecx

; 77   : 		int GetLength (void)					{ return length; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLength@BasePathClass@@QAEHXZ ENDP			; BasePathClass::GetLength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_target$1 = -1124					; size = 4
_tprof$2 = -1120					; size = 4
_flags$3 = -1116					; size = 4
_minalt$4 = -1112					; size = 4
_caps$5 = -1108						; size = 4
_missalt$6 = -1104					; size = 4
_min_time$7 = -1100					; size = 4
_routewp$8 = -1096					; size = 4
_mindist$9 = -1092					; size = 4
_skill$10 = -1088					; size = 4
_escort$11 = -1084					; size = 4
_type$12 = -1080					; size = 4
_maxtime$13 = -1076					; size = 4
_targetwp$14 = -1072					; size = 4
_mintime$15 = -1068					; size = 4
_tdesc$16 = -1064					; size = 4
_str$17 = -1060						; size = 4
_misprof$18 = -1056					; size = 4
_loiter$19 = -1052					; size = 4
_separation$20 = -1048					; size = 4
_maxalt$21 = -1044					; size = 4
_fp$ = -1040						; size = 4
_no$22 = -1036						; size = 4
_mp$23 = -1032						; size = 4
_buffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
?LoadMissionData@@YAHXZ PROC				; LoadMissionData

; 2571 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1124				; 00000464H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2572 :     FILE *fp = OpenCampFile("mission", "dat", "rt");

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	push	OFFSET ??_C@_03GILJFNFC@dat?$AA@
	push	OFFSET ??_C@_07CACALAH@mission?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 2573 :     if (fp == NULL) return FALSE;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN7@LoadMissio
	xor	eax, eax
	jmp	$LN9@LoadMissio
$LN7@LoadMissio:

; 2574 :     char buffer[1024];
; 2575 : 
; 2576 :     while (fgets(buffer, sizeof buffer, fp) != NULL) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@LoadMissio

; 2577 : 	if (buffer[0] == '/' || buffer[0] == '\r' || buffer[0] == '\n')

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN4@LoadMissio
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN4@LoadMissio
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN5@LoadMissio
$LN4@LoadMissio:

; 2578 : 	    continue;

	jmp	SHORT $LN7@LoadMissio
$LN5@LoadMissio:

; 2579 : 	DWORD no, type, target, skill, misprof, tprof, tdesc, routewp, targetwp;
; 2580 : 	int minalt, maxalt, missalt, separation, loiter;
; 2581 : 	DWORD str, mintime, maxtime, escort, mindist, min_time, caps, flags;
; 2582 : 	if (sscanf(buffer, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d 0x%x",
; 2583 : 	    &no, &type, &target, &skill, &misprof, &tprof, &tdesc, &routewp, &targetwp,
; 2584 : 	    &minalt, &maxalt, &missalt, &separation, &loiter,
; 2585 : 	    &str, &mintime, &maxtime, &escort, &mindist, &min_time, &caps, &flags
; 2586 : 	    ) != 22) {

	lea	edx, DWORD PTR _flags$3[ebp]
	push	edx
	lea	eax, DWORD PTR _caps$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _min_time$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _mindist$9[ebp]
	push	edx
	lea	eax, DWORD PTR _escort$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _maxtime$13[ebp]
	push	ecx
	lea	edx, DWORD PTR _mintime$15[ebp]
	push	edx
	lea	eax, DWORD PTR _str$17[ebp]
	push	eax
	lea	ecx, DWORD PTR _loiter$19[ebp]
	push	ecx
	lea	edx, DWORD PTR _separation$20[ebp]
	push	edx
	lea	eax, DWORD PTR _missalt$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _maxalt$21[ebp]
	push	ecx
	lea	edx, DWORD PTR _minalt$4[ebp]
	push	edx
	lea	eax, DWORD PTR _targetwp$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _routewp$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _tdesc$16[ebp]
	push	edx
	lea	eax, DWORD PTR _tprof$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _misprof$18[ebp]
	push	ecx
	lea	edx, DWORD PTR _skill$10[ebp]
	push	edx
	lea	eax, DWORD PTR _target$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _type$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _no$22[ebp]
	push	edx
	push	OFFSET ??_C@_0EE@JDCKNOBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sscanf
	add	esp, 96					; 00000060H
	cmp	eax, 22					; 00000016H
	je	SHORT $LN3@LoadMissio

; 2587 : 	    MonoPrint("Bad line %s\n", buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@DNMLHFGK@Bad?5line?5?$CFs?6?$AA@
	call	_MonoPrint
	add	esp, 8

; 2588 : 	    continue;

	jmp	$LN7@LoadMissio
$LN3@LoadMissio:

; 2589 : 	}
; 2590 : 	if (no < 0 || no >= sizeof(MissionData)/sizeof(MissionData[0]))

	cmp	DWORD PTR _no$22[ebp], 0
	jb	SHORT $LN1@LoadMissio
	cmp	DWORD PTR _no$22[ebp], 41		; 00000029H
	jb	SHORT $LN2@LoadMissio
$LN1@LoadMissio:

; 2591 : 	    continue;

	jmp	$LN7@LoadMissio
$LN2@LoadMissio:

; 2592 : 	MissionDataType *mp = &MissionData[no];

	mov	edx, DWORD PTR _no$22[ebp]
	shl	edx, 5
	add	edx, OFFSET ?MissionData@@3PAUMissionDataType@@A ; MissionData
	mov	DWORD PTR _mp$23[ebp], edx

; 2593 : 	mp->type = (BYTE)type;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cl, BYTE PTR _type$12[ebp]
	mov	BYTE PTR [eax], cl

; 2594 : 	mp->target = (BYTE)target;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	al, BYTE PTR _target$1[ebp]
	mov	BYTE PTR [edx+1], al

; 2595 : 	mp->skill = (BYTE)skill;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	dl, BYTE PTR _skill$10[ebp]
	mov	BYTE PTR [ecx+2], dl

; 2596 : 	mp->mission_profile = (BYTE)misprof;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cl, BYTE PTR _misprof$18[ebp]
	mov	BYTE PTR [eax+3], cl

; 2597 : 	mp->target_profile = (BYTE)tprof;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	al, BYTE PTR _tprof$2[ebp]
	mov	BYTE PTR [edx+4], al

; 2598 : 	mp->target_desc = (BYTE)tdesc;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	dl, BYTE PTR _tdesc$16[ebp]
	mov	BYTE PTR [ecx+5], dl

; 2599 : 	mp->routewp = (BYTE)routewp;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cl, BYTE PTR _routewp$8[ebp]
	mov	BYTE PTR [eax+6], cl

; 2600 : 	mp->targetwp = (BYTE)targetwp;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	al, BYTE PTR _targetwp$14[ebp]
	mov	BYTE PTR [edx+7], al

; 2601 : 	mp->minalt = minalt;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	dx, WORD PTR _minalt$4[ebp]
	mov	WORD PTR [ecx+8], dx

; 2602 : 	mp->maxalt = maxalt;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cx, WORD PTR _maxalt$21[ebp]
	mov	WORD PTR [eax+10], cx

; 2603 : 	mp->missionalt = missalt;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	ax, WORD PTR _missalt$6[ebp]
	mov	WORD PTR [edx+12], ax

; 2604 : 	mp->separation = separation;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	dx, WORD PTR _separation$20[ebp]
	mov	WORD PTR [ecx+14], dx

; 2605 : 	mp->loitertime = loiter;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cx, WORD PTR _loiter$19[ebp]
	mov	WORD PTR [eax+16], cx

; 2606 : 	mp->str = (BYTE)str;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	al, BYTE PTR _str$17[ebp]
	mov	BYTE PTR [edx+18], al

; 2607 : 	mp->min_time = (BYTE)mintime;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	dl, BYTE PTR _mintime$15[ebp]
	mov	BYTE PTR [ecx+19], dl

; 2608 : 	mp->max_time = (BYTE)maxtime;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cl, BYTE PTR _maxtime$13[ebp]
	mov	BYTE PTR [eax+20], cl

; 2609 : 	mp->escorttype = (BYTE)escort;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	al, BYTE PTR _escort$11[ebp]
	mov	BYTE PTR [edx+21], al

; 2610 : 	mp->mindistance = (BYTE)mindist;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	dl, BYTE PTR _mindist$9[ebp]
	mov	BYTE PTR [ecx+22], dl

; 2611 : 	mp->min_time = (BYTE)min_time;

	mov	eax, DWORD PTR _mp$23[ebp]
	mov	cl, BYTE PTR _min_time$7[ebp]
	mov	BYTE PTR [eax+19], cl

; 2612 : 	mp->caps = (BYTE)caps;

	mov	edx, DWORD PTR _mp$23[ebp]
	mov	al, BYTE PTR _caps$5[ebp]
	mov	BYTE PTR [edx+24], al

; 2613 : 	mp->flags = flags;

	mov	ecx, DWORD PTR _mp$23[ebp]
	mov	edx, DWORD PTR _flags$3[ebp]
	mov	DWORD PTR [ecx+28], edx

; 2614 :     }

	jmp	$LN7@LoadMissio
$LN6@LoadMissio:

; 2615 :     fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 2616 :     return TRUE;

	mov	eax, 1
$LN9@LoadMissio:

; 2617 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadMissionData@@YAHXZ ENDP				; LoadMissionData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -140						; size = 8
_tit$ = -132						; size = 12
$T3 = -120						; size = 4
_x$ = -116						; size = 2
_y$ = -112						; size = 2
_strike_type$ = -108					; size = 4
_do_request$ = -104					; size = 4
_retval$ = -100						; size = 4
_e$ = -96						; size = 4
_mis$ = -92						; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_team$ = 8						; size = 1
_priority$ = 12						; size = 4
_list$ = 16						; size = 4
_mt$ = 20						; size = 4
_time$ = 24						; size = 4
_target_flags$ = 28					; size = 4
_targeted$ = 32						; size = 4
?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z PROC ; TargetThreats

; 2337 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2338 : 	CampEntity			e;
; 2339 : 	int					retval=0, do_request;

	mov	DWORD PTR _retval$[ebp], 0

; 2340 : 	int					strike_type = AMIS_SEADSTRIKE;

	mov	DWORD PTR _strike_type$[ebp], 11	; 0000000bH

; 2341 : 	GridIndex			x,y;
; 2342 : 	MissionRequestClass	mis;

	lea	ecx, DWORD PTR _mis$[ebp]
	call	??0MissionRequestClass@@QAE@XZ		; MissionRequestClass::MissionRequestClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2343 : 	
; 2344 : 	VuListIterator		tit(list);

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2345 : 	e = GetFirstEntity(&tit);

	lea	ecx, DWORD PTR _tit$[ebp]
	push	ecx
	call	?GetFirstEntity@@YAPAVCampBaseClass@@PAVVuListIterator@@@Z ; GetFirstEntity
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax
$LN10@TargetThre:

; 2346 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN9@TargetThre

; 2347 : 	{
; 2348 : 		do_request = FALSE;

	mov	DWORD PTR _do_request$[ebp], 0

; 2349 : 		if (e->GetAproxCombatStrength(mt,0) > 0)						// This unit can hurt us

	push	0
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+404]
	call	eax
	test	eax, eax
	jle	SHORT $LN8@TargetThre

; 2350 : 		{
; 2351 : 			retval |= NEED_SEAD;

	mov	ecx, DWORD PTR _retval$[ebp]
	or	ecx, 1
	mov	DWORD PTR _retval$[ebp], ecx

; 2352 : 			if (e->IsUnit() && e->GetSType() == STYPE_UNIT_AIR_DEFENSE && (e->GetSpotted(team) || rand() < HALF_CHANCE))

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+232]
	call	edx
	test	eax, eax
	je	SHORT $LN7@TargetThre
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN7@TargetThre
	movzx	ecx, BYTE PTR _team$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSpotted@CampBaseClass@@QAEHE@Z	; CampBaseClass::GetSpotted
	test	eax, eax
	jne	SHORT $LN6@TargetThre
	call	_rand
	cmp	eax, 16000				; 00003e80H
	jge	SHORT $LN7@TargetThre
$LN6@TargetThre:

; 2353 : 			{
; 2354 : 				// Specifically, it's a SAM battalion
; 2355 : 				strike_type = AMIS_SEADSTRIKE;

	mov	DWORD PTR _strike_type$[ebp], 11	; 0000000bH

; 2356 : 				mis.context = enemyAirDefense;

	mov	BYTE PTR _mis$[ebp+62], 39		; 00000027H

; 2357 : 				do_request = TRUE;

	mov	DWORD PTR _do_request$[ebp], 1
$LN7@TargetThre:

; 2358 : 			}
; 2359 : 		}

	jmp	SHORT $LN5@TargetThre
$LN8@TargetThre:

; 2360 : 		else if (e->GetDetectionRange(mt) > VisualDetectionRange[mt])	// This unit has radar

	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+416]
	call	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	cmp	eax, DWORD PTR ?VisualDetectionRange@@3PAHA[ecx*4]
	jle	SHORT $LN5@TargetThre

; 2361 : 		{
; 2362 : 			retval |= NEED_ECM;

	mov	edx, DWORD PTR _retval$[ebp]
	or	edx, 2
	mov	DWORD PTR _retval$[ebp], edx

; 2363 : 			if (e->IsObjective())

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN3@TargetThre

; 2364 : 			{
; 2365 : 				strike_type = AMIS_OCASTRIKE;

	mov	DWORD PTR _strike_type$[ebp], 13	; 0000000dH

; 2366 : 				mis.context = enemyAirPowerRadar;

	mov	BYTE PTR _mis$[ebp+62], 41		; 00000029H

; 2367 : 				do_request = TRUE;

	mov	DWORD PTR _do_request$[ebp], 1

; 2368 : 			}
; 2369 : 			else

	jmp	SHORT $LN5@TargetThre
$LN3@TargetThre:

; 2370 : 			{
; 2371 : 				strike_type = AMIS_SEADSTRIKE;

	mov	DWORD PTR _strike_type$[ebp], 11	; 0000000bH

; 2372 : 				mis.context = enemyAirDefense;

	mov	BYTE PTR _mis$[ebp+62], 39		; 00000027H

; 2373 : 				do_request = TRUE;

	mov	DWORD PTR _do_request$[ebp], 1
$LN5@TargetThre:

; 2374 : 			}
; 2375 : 		}
; 2376 : 		
; 2377 : 		if (do_request && (target_flags & AMIS_ADDOCASTRIKE))

	cmp	DWORD PTR _do_request$[ebp], 0
	je	$LN1@TargetThre
	mov	ecx, DWORD PTR _target_flags$[ebp]
	and	ecx, 256				; 00000100H
	je	$LN1@TargetThre

; 2378 : 		{
; 2379 : 			// Plan a type of oca Strike mission
; 2380 : 			e->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2381 : 			mis.tot = time;

	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR _mis$[ebp+36], ecx

; 2382 : 			mis.who = team;

	mov	dl, BYTE PTR _team$[ebp]
	mov	BYTE PTR _mis$[ebp+32], dl

; 2383 : 			mis.vs = e->GetTeam();

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _mis$[ebp+33], al

; 2384 : 			mis.tot_type = TYPE_LE;

	mov	BYTE PTR _mis$[ebp+58], 2

; 2385 : 			mis.tx = x;

	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR _mis$[ebp+40], cx

; 2386 : 			mis.ty = y;

	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR _mis$[ebp+42], dx

; 2387 : 			mis.targetID = e->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mis$[ebp+8], ecx
	mov	DWORD PTR _mis$[ebp+12], edx

; 2388 : 			mis.mission = strike_type;

	mov	al, BYTE PTR _strike_type$[ebp]
	mov	BYTE PTR _mis$[ebp+60], al

; 2389 : 			mis.roe_check = ROE_AIR_ATTACK;

	mov	BYTE PTR _mis$[ebp+63], 8

; 2390 : 			mis.flags = 0;

	mov	DWORD PTR _mis$[ebp+44], 0

; 2391 : 			mis.priority = priority/10;

	mov	eax, DWORD PTR _priority$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	WORD PTR _mis$[ebp+56], ax

; 2392 : 			mis.RequestMission();

	lea	ecx, DWORD PTR _mis$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission

; 2393 : 			*targeted++;

	mov	edx, DWORD PTR _targeted$[ebp]
	add	edx, 2
	mov	DWORD PTR _targeted$[ebp], edx
$LN1@TargetThre:

; 2394 : 		}
; 2395 : 		e = GetNextEntity(&tit);

	lea	eax, DWORD PTR _tit$[ebp]
	push	eax
	call	?GetNextEntity@@YAPAVCampBaseClass@@PAVVuListIterator@@@Z ; GetNextEntity
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 2396 : 	}

	jmp	$LN10@TargetThre
$LN9@TargetThre:

; 2397 : 	return retval;

	mov	ecx, DWORD PTR _retval$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mis$[ebp]
	call	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
	mov	eax, DWORD PTR $T3[ebp]

; 2398 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z$0:
	lea	ecx, DWORD PTR _mis$[ebp]
	jmp	??1MissionRequestClass@@QAE@XZ		; MissionRequestClass::~MissionRequestClass
__unwindfunclet$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z$1:
	lea	ecx, DWORD PTR _tit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TargetThreats@@YAHEHPAVFalconPrivateList@@W4MoveType@@KJPAF@Z ENDP ; TargetThreats
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_threats$ = -100					; size = 24
$T2 = -76						; size = 4
$T3 = -72						; size = 4
_yd$ = -68						; size = 4
_xd$ = -64						; size = 4
_dist$ = -60						; size = 4
_d$ = -56						; size = 4
_retval$ = -52						; size = 4
_nw$ = -48						; size = 4
_w$ = -44						; size = 4
_step$ = -40						; size = 4
_x$ = -36						; size = 2
_y$ = -32						; size = 2
_ny$ = -28						; size = 2
_nx$ = -24						; size = 2
_fy$ = -20						; size = 2
_fx$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
?CheckPathThreats@@YAHPAVUnitClass@@@Z PROC		; CheckPathThreats

; 2278 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckPathThreats@@YAHPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2279 : 	FalconPrivateList	threats(&CampFilter);

	push	OFFSET ?CampFilter@@3VCampBaseFilter@@A	; CampFilter
	lea	ecx, DWORD PTR _threats$[ebp]
	call	??0FalconPrivateList@@QAE@PAVVuFilter@@@Z ; FalconPrivateList::FalconPrivateList
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2280 : 	WayPoint		w,nw;
; 2281 : 	int				step,retval=0,dist;

	mov	DWORD PTR _retval$[ebp], 0

; 2282 : //	short			targeted=0;
; 2283 : //	long			target_flags;
; 2284 : 	GridIndex		x,y,fx,fy,nx,ny;
; 2285 : 	float			xd,yd,d;
; 2286 : //	CampEntity		e;
; 2287 : 
; 2288 : 	// Set our main target as targeted
; 2289 : //	e = u->GetCampTarget();
; 2290 : //	if (e)
; 2291 : //		ThreatSearch[e->GetCampID()] = 2;
; 2292 : 
; 2293 : //	target_flags = MissionData[u->GetUnitMission()].flags;
; 2294 : 	w = u->GetFirstUnitWP();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 2295 : 	nw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax
$LN6@CheckPathT:

; 2296 : 	while (w && nw)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN5@CheckPathT
	cmp	DWORD PTR _nw$[ebp], 0
	je	$LN5@CheckPathT

; 2297 : 		{
; 2298 : 		w->GetWPLocation(&fx,&fy);

	lea	eax, DWORD PTR _fy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2299 : 		nw->GetWPLocation(&nx,&ny);

	lea	edx, DWORD PTR _ny$[ebp]
	push	edx
	lea	eax, DWORD PTR _nx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 2300 : 		d = Distance(fx,fy,nx,ny);

	movzx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nx$[ebp]
	push	edx
	movzx	eax, WORD PTR _fy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _fx$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]

; 2301 : 		dist = FloatToInt32(d);

	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist$[ebp], eax

; 2302 : 		xd = (float)(nx-fx)/d;

	movsx	edx, WORD PTR _nx$[ebp]
	movsx	eax, WORD PTR _fx$[ebp]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 2303 : 		yd = (float)(ny-fy)/d;

	movsx	ecx, WORD PTR _ny$[ebp]
	movsx	edx, WORD PTR _fy$[ebp]
	sub	ecx, edx
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _yd$[ebp], xmm0

; 2304 : 		for (step=0; step<dist; step+=5)

	mov	DWORD PTR _step$[ebp], 0
	jmp	SHORT $LN4@CheckPathT
$LN3@CheckPathT:
	mov	eax, DWORD PTR _step$[ebp]
	add	eax, 5
	mov	DWORD PTR _step$[ebp], eax
$LN4@CheckPathT:
	mov	ecx, DWORD PTR _step$[ebp]
	cmp	ecx, DWORD PTR _dist$[ebp]
	jge	$LN2@CheckPathT

; 2305 : 			{
; 2306 : 			x = fx + FloatToInt32(xd*step + 0.5F);

	movsx	esi, WORD PTR _fx$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	WORD PTR _x$[ebp], si

; 2307 : 			y = fy + FloatToInt32(yd*step + 0.5F);

	movsx	esi, WORD PTR _fy$[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR _yd$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	WORD PTR _y$[ebp], si

; 2308 : 			// Just check to see what sort of escorts we'll need, if any
; 2309 : 			retval |= CollectThreatsFast (x,y,GetAltitudeLevel(nw->GetWPAltitude()),u->GetTeam(),FIND_NOAIR | FIND_NOMOVERS | FIND_FINDUNSPOTTED,&threats);

	lea	edx, DWORD PTR _threats$[ebp]
	push	edx
	push	148					; 00000094H
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetWPAltitude@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAltitude
	push	eax
	call	?GetAltitudeLevel@@YAHH@Z		; GetAltitudeLevel
	add	esp, 4
	push	eax
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?CollectThreatsFast@@YAHFFHEHPAVFalconPrivateList@@@Z ; CollectThreatsFast
	add	esp, 24					; 00000018H
	or	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 2310 : 			// Return if we've got everything we're likely to get
; 2311 : 			if (retval == (NEED_SEAD | NEED_ECM))

	cmp	DWORD PTR _retval$[ebp], 3
	jne	SHORT $LN1@CheckPathT

; 2312 : 				return retval;

	mov	ecx, DWORD PTR _retval$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _threats$[ebp]
	call	??1FalconPrivateList@@UAE@XZ		; FalconPrivateList::~FalconPrivateList
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN7@CheckPathT
$LN1@CheckPathT:

; 2313 : /*			// This was only usefull when we wanted to actually target things which got in our way.
; 2314 : 			if (CollectThreatsFast (x,y,GetAltitudeLevel(nw->GetWPAltitude()),u->GetTeam(),FIND_NOAIR | FIND_NOMOVERS | FIND_FINDUNSPOTTED,&threats))
; 2315 : 				{
; 2316 : 				if (nw->GetWPAltitude() < LOW_ALTITUDE_CUTOFF)
; 2317 : 					mt = LowAir;
; 2318 : 				else
; 2319 : 					mt = Air;
; 2320 : 				if (w->GetWPArrivalTime() > 1.0F)
; 2321 : 					time = w->GetWPArrivalTime() + TimeToArrive(Distance(fx,fy,x,y),u->GetCruiseSpeed());
; 2322 : 				else
; 2323 : 					time = u->GetUnitTOT();
; 2324 : 				retval |= TargetThreats(u->GetTeam(),u->GetUnitPriority(),&threats,mt,time,target_flags,&targeted);
; 2325 : 				}
; 2326 : */
; 2327 : 			}

	jmp	$LN3@CheckPathT
$LN2@CheckPathT:

; 2328 : 		w = nw;

	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 2329 : 		nw = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax

; 2330 : 		}

	jmp	$LN6@CheckPathT
$LN5@CheckPathT:

; 2331 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _threats$[ebp]
	call	??1FalconPrivateList@@UAE@XZ		; FalconPrivateList::~FalconPrivateList
	mov	eax, DWORD PTR $T2[ebp]
$LN7@CheckPathT:

; 2332 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckPathThreats@@YAHPAVUnitClass@@@Z$0:
	lea	ecx, DWORD PTR _threats$[ebp]
	jmp	??1FalconPrivateList@@UAE@XZ		; FalconPrivateList::~FalconPrivateList
__ehhandler$?CheckPathThreats@@YAHPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckPathThreats@@YAHPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckPathThreats@@YAHPAVUnitClass@@@Z ENDP		; CheckPathThreats
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
tv344 = -64						; size = 8
_maxSpeed$ = -56					; size = 4
_minSpeed$ = -52					; size = 4
tv341 = -48						; size = 4
_dist$ = -44						; size = 4
_speed$ = -40						; size = 4
_pack$ = -36						; size = 4
_fw$ = -32						; size = 4
_tw$ = -28						; size = 4
_mission_time$ = -24					; size = 4
_w$ = -20						; size = 4
_y$ = -16						; size = 2
_ny$ = -12						; size = 2
_x$ = -8						; size = 2
_nx$ = -4						; size = 2
_u$ = 8							; size = 4
_mis$ = 12						; size = 4
_type$ = 16						; size = 1
_time$ = 20						; size = 4
?SetWPTimesTanker@@YAJPAVFlightClass@@PAVMissionRequestClass@@_NK@Z PROC ; SetWPTimesTanker

; 1667 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1668 : 	WayPoint		w,fw,tw=NULL;

	mov	DWORD PTR _tw$[ebp], 0

; 1669 : 	CampaignTime	mission_time;
; 1670 : 	float			minSpeed,maxSpeed,speed,dist;
; 1671 : 	GridIndex		x,y,nx,ny;
; 1672 : 	Package			pack;
; 1673 : 
; 1674 : 	fw = w = u->GetFirstUnitWP();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax
	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _fw$[ebp], eax

; 1675 : 	if (!w)

	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN32@SetWPTimes

; 1676 : 		return 0;

	xor	eax, eax
	jmp	$LN33@SetWPTimes
$LN32@SetWPTimes:

; 1677 : 
; 1678 : 	pack = (Package) u->GetUnitParent();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 1679 : 	if (!pack)

	cmp	DWORD PTR _pack$[ebp], 0
	jne	SHORT $LN31@SetWPTimes

; 1680 : 		return 0;

	xor	eax, eax
	jmp	$LN33@SetWPTimes
$LN31@SetWPTimes:

; 1681 : //TJL 11/23/03 More division by 2 removal
; 1682 : 	//minSpeed = u->GetCruiseSpeed()/2.0F;
; 1683 : 	minSpeed = (float)u->GetCruiseSpeed();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _minSpeed$[ebp], xmm0

; 1684 : 	maxSpeed = (float)u->GetMaxSpeed();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetMaxSpeed@UnitClass@@QBEHXZ		; UnitClass::GetMaxSpeed
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _maxSpeed$[ebp], xmm0

; 1685 : 
; 1686 : #ifdef DEBUG
; 1687 : 	counttanker++;
; 1688 : 	MonoPrint("%d TankerWaypoints created",counttanker);
; 1689 : #endif
; 1690 : 
; 1691 : 	// Fix the offset for any fixed wps (time should == 0 for any wps needing setting)
; 1692 : 	if (mis->tot_type == TOT_TAKEOFF)

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+58]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN30@SetWPTimes

; 1693 : 		{
; 1694 : 		// Fixed Takeoff time
; 1695 : 		tw = fw;

	mov	eax, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], eax

; 1696 : 		tw->SetWPTimes(mis->tot);

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
	jmp	SHORT $LN23@SetWPTimes
$LN30@SetWPTimes:

; 1697 : 		}
; 1698 : 	else if (mis->tot_type == TOT_ENROUTE)

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+58]
	cmp	ecx, 11					; 0000000bH
	jne	SHORT $LN28@SetWPTimes

; 1699 : 		{
; 1700 : 		// Fixed enroute time
; 1701 : 		tw = fw;

	mov	edx, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], edx

; 1702 : 		tw->SetWPTimes(mis->tot);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
	jmp	SHORT $LN23@SetWPTimes
$LN28@SetWPTimes:

; 1703 : 		}
; 1704 : 	else if (mis->tot_type == TOT_INGRESS)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+58]
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN23@SetWPTimes

; 1705 : 		{
; 1706 : 		// Fixed ingrss time
; 1707 : 		tw = fw;

	mov	ecx, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], ecx
$LN25@SetWPTimes:

; 1708 : 		while (tw && !(tw->GetWPFlags() & WPF_IN_PACKAGE))

	cmp	DWORD PTR _tw$[ebp], 0
	je	SHORT $LN24@SetWPTimes
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN24@SetWPTimes

; 1709 : 			tw = tw->GetNextWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tw$[ebp], eax
	jmp	SHORT $LN25@SetWPTimes
$LN24@SetWPTimes:

; 1710 : 		if (tw)

	cmp	DWORD PTR _tw$[ebp], 0
	je	SHORT $LN23@SetWPTimes

; 1711 : 			tw->SetWPTimes(mis->tot);

	mov	edx, DWORD PTR _mis$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
$LN23@SetWPTimes:

; 1712 : 		}
; 1713 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN21@SetWPTimes

; 1714 : 		{
; 1715 : 		if (w->GetWPFlags() & WPF_TARGET && !tw)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN20@SetWPTimes
	cmp	DWORD PTR _tw$[ebp], 0
	jne	SHORT $LN20@SetWPTimes

; 1716 : 			{
; 1717 : 			tw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _tw$[ebp], ecx

; 1718 : 			w->SetWPTimes(mis->tot);

	mov	edx, DWORD PTR _mis$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
$LN20@SetWPTimes:

; 1719 : 			}
; 1720 : 		if (w->GetWPFlags() & WPF_TURNPOINT && !tw)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 16					; 00000010H
	je	SHORT $LN19@SetWPTimes
	cmp	DWORD PTR _tw$[ebp], 0
	jne	SHORT $LN19@SetWPTimes

; 1721 : 			tw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _tw$[ebp], ecx
$LN19@SetWPTimes:

; 1722 : 		// Lock time in some cases - only lock target waypoint if we have to refuel somewhere..
; 1723 : 		w->UnSetWPFlag(WPF_SPEED_LOCKED);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _w$[ebp]
	call	?UnSetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::UnSetWPFlag

; 1724 : 		if (/*w->GetWPAction() == WP_TAKEOFF ||*/ (w->GetWPFlags() & WPF_TARGET) /*|| (w->GetWPFlags() & WPF_ASSEMBLE)*/)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN18@SetWPTimes

; 1725 : 			w->SetWPFlag(WPF_TIME_LOCKED);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag
$LN18@SetWPTimes:

; 1726 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1727 : 		}

	jmp	SHORT $LN23@SetWPTimes
$LN21@SetWPTimes:

; 1728 : 
; 1729 : 	// Now let's try and set any times we're allowed to (target to landing first)
; 1730 : 	if (!tw)

	cmp	DWORD PTR _tw$[ebp], 0
	jne	SHORT $LN17@SetWPTimes

; 1731 : 		tw = fw;

	mov	edx, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], edx
$LN17@SetWPTimes:

; 1732 : 	if (!type) // egress -> adjust target to land waypoint ; time = takeoff time

	movzx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	$LN16@SetWPTimes

; 1733 : 	{
; 1734 : 	mission_time = tw->GetWPDepartureTime();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _mission_time$[ebp], eax

; 1735 : 	tw->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1736 : 	ShiAssert (mission_time > 0.0F);
; 1737 : 	w = tw->GetNextWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax
$LN15@SetWPTimes:

; 1738 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN14@SetWPTimes

; 1739 : 		{
; 1740 : 		w->GetWPLocation(&nx,&ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1741 : 		dist = Distance(x,y,nx,ny);

	movzx	edx, WORD PTR _ny$[ebp]
	push	edx
	movzx	eax, WORD PTR _nx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dist$[ebp]

; 1742 : 		speed = w->GetWPSpeed();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPSpeed@WayPointClass@@QAEMXZ	; WayPointClass::GetWPSpeed
	fstp	DWORD PTR _speed$[ebp]

; 1743 : 		mission_time += TimeToArrive(dist,speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	add	eax, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _mission_time$[ebp], eax

; 1744 : 		// If we have the refuel waypoint, set a new departure time
; 1745 : 		if (w->GetWPAction() == WP_REFUEL)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 4
	jne	SHORT $LN13@SetWPTimes

; 1746 : 		{
; 1747 : 			w->SetWPArrive(mission_time);

	mov	eax, DWORD PTR _mission_time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPArrive@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPArrive

; 1748 : 			mission_time += 3 * CampaignMinutes;

	mov	ecx, DWORD PTR _mission_time$[ebp]
	add	ecx, 180000				; 0002bf20H
	mov	DWORD PTR _mission_time$[ebp], ecx

; 1749 : 			w->SetWPDepartTime(mission_time);	// 3 minutes to refuel

	mov	edx, DWORD PTR _mission_time$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPDepartTime@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPDepartTime
	jmp	SHORT $LN12@SetWPTimes
$LN13@SetWPTimes:

; 1750 : 		}
; 1751 : 		else w->SetWPTimes(mission_time);

	mov	eax, DWORD PTR _mission_time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
$LN12@SetWPTimes:

; 1752 : 		// Set package turn point time, as a secondary syncronization point
; 1753 : 		if (w->GetWPFlags() == WPF_TURNPOINT && ((Package)pack)->GetTPTime() < 1.0F)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN11@SetWPTimes
	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetTPTime@PackageClass@@QAEKXZ		; PackageClass::GetTPTime
	mov	DWORD PTR tv341[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv341[ebp]
	mov	ecx, DWORD PTR tv341[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv344[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv344[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@SetWPTimes

; 1754 : 			((Package)pack)->SetTPTime (mission_time);

	mov	edx, DWORD PTR _mission_time$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pack$[ebp]
	call	?SetTPTime@PackageClass@@QAEXK@Z	; PackageClass::SetTPTime
$LN11@SetWPTimes:

; 1755 : 		mission_time += w->GetWPStationTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPStationTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPStationTime
	add	eax, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _mission_time$[ebp], eax

; 1756 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1757 : 		x = nx; y = ny;

	mov	ax, WORD PTR _nx$[ebp]
	mov	WORD PTR _x$[ebp], ax
	mov	cx, WORD PTR _ny$[ebp]
	mov	WORD PTR _y$[ebp], cx

; 1758 : 		}

	jmp	$LN15@SetWPTimes
$LN14@SetWPTimes:

; 1759 : 	if (mis->flags & REQF_TE_MISSION)

	mov	edx, DWORD PTR _mis$[ebp]
	mov	eax, DWORD PTR [edx+44]
	and	eax, 4096				; 00001000H
	je	SHORT $LN10@SetWPTimes

; 1760 : 		return mission_time - time;

	mov	eax, DWORD PTR _mission_time$[ebp]
	sub	eax, DWORD PTR _time$[ebp]
	jmp	$LN33@SetWPTimes
$LN10@SetWPTimes:

; 1761 : 	if (mission_time < TheCampaign.CurrentTime)

	mov	ecx, DWORD PTR _mission_time$[ebp]
	cmp	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jae	SHORT $LN9@SetWPTimes

; 1762 : 		return (long)time - (long)TheCampaign.CurrentTime;

	mov	eax, DWORD PTR _time$[ebp]
	sub	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jmp	$LN33@SetWPTimes
$LN9@SetWPTimes:

; 1763 : 	if (mission_time > time)

	mov	edx, DWORD PTR _mission_time$[ebp]
	cmp	edx, DWORD PTR _time$[ebp]
	jbe	SHORT $LN8@SetWPTimes

; 1764 : 		return mission_time - time;

	mov	eax, DWORD PTR _mission_time$[ebp]
	sub	eax, DWORD PTR _time$[ebp]
	jmp	$LN33@SetWPTimes
$LN8@SetWPTimes:

; 1765 : 	return 0;

	xor	eax, eax
	jmp	$LN33@SetWPTimes

; 1766 : 	}
; 1767 : 	else	// ingress -> adjust takeoff to target waypoint ; time = landing time

	jmp	$LN5@SetWPTimes
$LN16@SetWPTimes:

; 1768 : 	{
; 1769 : 	// Backwards, from target to takeoff
; 1770 : 	mission_time = tw->GetWPArrivalTime();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _mission_time$[ebp], eax

; 1771 : 	tw->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1772 : 	w = tw->GetPrevWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _w$[ebp], eax
$LN6@SetWPTimes:

; 1773 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN5@SetWPTimes

; 1774 : 		{
; 1775 : 		w->GetWPLocation(&nx,&ny);

	lea	edx, DWORD PTR _ny$[ebp]
	push	edx
	lea	eax, DWORD PTR _nx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1776 : 		dist = Distance(x,y,nx,ny);

	movzx	ecx, WORD PTR _ny$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dist$[ebp]

; 1777 : 		speed = w->GetNextWP()->GetWPSpeed();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, eax
	call	?GetWPSpeed@WayPointClass@@QAEMXZ	; WayPointClass::GetWPSpeed
	fstp	DWORD PTR _speed$[ebp]

; 1778 : 		mission_time -= TimeToArrive(dist,speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	mov	edx, DWORD PTR _mission_time$[ebp]
	sub	edx, eax
	mov	DWORD PTR _mission_time$[ebp], edx

; 1779 : 		mission_time -= w->GetWPStationTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPStationTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPStationTime
	mov	ecx, DWORD PTR _mission_time$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _mission_time$[ebp], ecx

; 1780 : 		// If we have the refuel waypoint, set a new departure time
; 1781 : 		if (w->GetWPAction() == WP_REFUEL)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 4
	jne	SHORT $LN4@SetWPTimes

; 1782 : 			w->SetWPDepartTime(mission_time + 3 * CampaignMinutes);	// 3 minutes to refuel

	mov	edx, DWORD PTR _mission_time$[ebp]
	add	edx, 180000				; 0002bf20H
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPDepartTime@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPDepartTime
$LN4@SetWPTimes:

; 1783 : 		w->SetWPTimes(mission_time);

	mov	eax, DWORD PTR _mission_time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes

; 1784 : 		w = w->GetPrevWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _w$[ebp], eax

; 1785 : 		x = nx; y = ny;

	mov	cx, WORD PTR _nx$[ebp]
	mov	WORD PTR _x$[ebp], cx
	mov	dx, WORD PTR _ny$[ebp]
	mov	WORD PTR _y$[ebp], dx

; 1786 : 		}

	jmp	$LN6@SetWPTimes
$LN5@SetWPTimes:

; 1787 : 	}
; 1788 : 	if (mis->flags & REQF_TE_MISSION)

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN3@SetWPTimes

; 1789 : 		return time - mission_time;

	mov	eax, DWORD PTR _time$[ebp]
	sub	eax, DWORD PTR _mission_time$[ebp]
	jmp	SHORT $LN33@SetWPTimes
$LN3@SetWPTimes:

; 1790 : 	if (mission_time < TheCampaign.CurrentTime)

	mov	edx, DWORD PTR _mission_time$[ebp]
	cmp	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jae	SHORT $LN2@SetWPTimes

; 1791 : 		return (long)mission_time - (long)TheCampaign.CurrentTime;

	mov	eax, DWORD PTR _mission_time$[ebp]
	sub	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jmp	SHORT $LN33@SetWPTimes
$LN2@SetWPTimes:

; 1792 : 	if (time > mission_time)

	mov	eax, DWORD PTR _time$[ebp]
	cmp	eax, DWORD PTR _mission_time$[ebp]
	jbe	SHORT $LN1@SetWPTimes

; 1793 : 		return time - mission_time;

	mov	eax, DWORD PTR _time$[ebp]
	sub	eax, DWORD PTR _mission_time$[ebp]
	jmp	SHORT $LN33@SetWPTimes
$LN1@SetWPTimes:

; 1794 : 	return 0;

	xor	eax, eax
$LN33@SetWPTimes:

; 1795 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SetWPTimesTanker@@YAJPAVFlightClass@@PAVMissionRequestClass@@_NK@Z ENDP ; SetWPTimesTanker
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
tv443 = -108						; size = 8
tv407 = -100						; size = 8
tv383 = -92						; size = 8
_prevmission_time$ = -84				; size = 4
_offset$ = -80						; size = 4
tv439 = -76						; size = 4
tv404 = -72						; size = 4
tv379 = -68						; size = 4
_land$ = -64						; size = 4
_time$ = -60						; size = 4
_pack$ = -56						; size = 4
_maxSpeed$ = -52					; size = 4
_minSpeed$ = -48					; size = 4
_fw$ = -44						; size = 4
_to$ = -40						; size = 4
_dist$ = -36						; size = 4
_speed$ = -32						; size = 4
_mission_time$ = -28					; size = 4
_tw$ = -24						; size = 4
_w$ = -20						; size = 4
_y$ = -16						; size = 2
_ny$ = -12						; size = 2
_x$ = -8						; size = 2
_nx$ = -4						; size = 2
_u$ = 8							; size = 4
_mis$ = 12						; size = 4
?SetWPTimes@@YAJPAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; SetWPTimes

; 1498 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 1499 : 	WayPoint		w,fw,tw=NULL;

	mov	DWORD PTR _tw$[ebp], 0

; 1500 : 	CampaignTime	mission_time,to,land,time;
; 1501 : 	long			offset;
; 1502 : 	float			minSpeed,maxSpeed,speed,dist;
; 1503 : 	GridIndex		x,y,nx,ny;
; 1504 : 	Package			pack;
; 1505 : 
; 1506 : 	fw = w = u->GetFirstUnitWP();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax
	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _fw$[ebp], eax

; 1507 : 	if (!w)

	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN35@SetWPTimes

; 1508 : 		return 0;

	xor	eax, eax
	jmp	$LN36@SetWPTimes
$LN35@SetWPTimes:

; 1509 : 
; 1510 : 	pack = (Package) u->GetUnitParent();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+1008]
	call	eax
	mov	DWORD PTR _pack$[ebp], eax

; 1511 : 	if (!pack)

	cmp	DWORD PTR _pack$[ebp], 0
	jne	SHORT $LN34@SetWPTimes

; 1512 : 		return 0;

	xor	eax, eax
	jmp	$LN36@SetWPTimes
$LN34@SetWPTimes:

; 1513 : //TJL 11/22/03 More division by 2 removal. Errors are now aircraft specific.
; 1514 : 	// Removed cruise/max distinctions.  All speeds are based on MoveSpeed (in KM).
; 1515 : 	//minSpeed = u->GetCruiseSpeed()/2.0F;
; 1516 : 	//maxSpeed = (float)u->GetMaxSpeed();
; 1517 : 	minSpeed = (float)u->GetCruiseSpeed() * 0.7F;

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _minSpeed$[ebp], xmm0

; 1518 : 	maxSpeed = (float)u->GetMaxSpeed() * 1.3F;

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetMaxSpeed@UnitClass@@QBEHXZ		; UnitClass::GetMaxSpeed
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fa66666
	movss	DWORD PTR _maxSpeed$[ebp], xmm0

; 1519 : 
; 1520 : 
; 1521 : 
; 1522 : 	offset = MissionData[u->GetUnitMission()].separation*CampaignSeconds;

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	shl	eax, 5
	movsx	ecx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+14]
	imul	ecx, 1000				; 000003e8H
	mov	DWORD PTR _offset$[ebp], ecx

; 1523 : 
; 1524 : 	// Fix the offset for any fixed wps (time should == 0 for any wps needing setting)
; 1525 : 	if (mis->tot_type == TOT_TAKEOFF)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+58]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN33@SetWPTimes

; 1526 : 		{
; 1527 : 		// Fixed Takeoff time
; 1528 : 		tw = fw;

	mov	ecx, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], ecx

; 1529 : 		tw->SetWPTimes(mis->tot);

	mov	edx, DWORD PTR _mis$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
	jmp	SHORT $LN26@SetWPTimes
$LN33@SetWPTimes:

; 1530 : 		}
; 1531 : 	else if (mis->tot_type == TOT_ENROUTE)

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+58]
	cmp	edx, 11					; 0000000bH
	jne	SHORT $LN31@SetWPTimes

; 1532 : 		{
; 1533 : 		// Fixed enroute time
; 1534 : 		tw = fw;

	mov	eax, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], eax

; 1535 : 		tw->SetWPTimes(mis->tot);

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
	jmp	SHORT $LN26@SetWPTimes
$LN31@SetWPTimes:

; 1536 : 		}
; 1537 : 	else if (mis->tot_type == TOT_INGRESS)

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+58]
	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN26@SetWPTimes

; 1538 : 		{
; 1539 : 		// Fixed ingrss time
; 1540 : 		tw = fw;

	mov	edx, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], edx
$LN28@SetWPTimes:

; 1541 : 		while (tw && !(tw->GetWPFlags() & WPF_IN_PACKAGE))

	cmp	DWORD PTR _tw$[ebp], 0
	je	SHORT $LN27@SetWPTimes
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN27@SetWPTimes

; 1542 : 			tw = tw->GetNextWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tw$[ebp], eax
	jmp	SHORT $LN28@SetWPTimes
$LN27@SetWPTimes:

; 1543 : 		if (tw)

	cmp	DWORD PTR _tw$[ebp], 0
	je	SHORT $LN26@SetWPTimes

; 1544 : 			tw->SetWPTimes(mis->tot);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
$LN26@SetWPTimes:

; 1545 : 		}
; 1546 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN24@SetWPTimes

; 1547 : 		{
; 1548 : 		if (w->GetWPArrivalTime())

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	test	eax, eax
	je	SHORT $LN23@SetWPTimes

; 1549 : 			w->SetWPTimes(w->GetWPArrivalTime() + offset);

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	add	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
$LN23@SetWPTimes:

; 1550 : 		if (w->GetWPFlags() & WPF_TARGET && !tw)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN22@SetWPTimes
	cmp	DWORD PTR _tw$[ebp], 0
	jne	SHORT $LN22@SetWPTimes

; 1551 : 			{
; 1552 : 			tw = w;

	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _tw$[ebp], edx

; 1553 : 			w->SetWPTimes(mis->tot);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes
$LN22@SetWPTimes:

; 1554 : 			}
; 1555 : 		if (w->GetWPFlags() & WPF_TURNPOINT && !tw)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 16					; 00000010H
	je	SHORT $LN21@SetWPTimes
	cmp	DWORD PTR _tw$[ebp], 0
	jne	SHORT $LN21@SetWPTimes

; 1556 : 			tw = w;

	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _tw$[ebp], edx
$LN21@SetWPTimes:

; 1557 : 		// Lock time in some cases
; 1558 : 		w->UnSetWPFlag(WPF_SPEED_LOCKED);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _w$[ebp]
	call	?UnSetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::UnSetWPFlag

; 1559 : 		if (w->GetWPAction() == WP_TAKEOFF || (w->GetWPFlags() & WPF_TARGET) || (w->GetWPFlags() & WPF_ASSEMBLE))

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	je	SHORT $LN19@SetWPTimes
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	jne	SHORT $LN19@SetWPTimes
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 2
	je	SHORT $LN20@SetWPTimes
$LN19@SetWPTimes:

; 1560 : 			w->SetWPFlag(WPF_TIME_LOCKED);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag
$LN20@SetWPTimes:

; 1561 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1562 : 		}

	jmp	$LN26@SetWPTimes
$LN24@SetWPTimes:

; 1563 : 
; 1564 : 	// Now let's try and set any times we're allowed to (target to landing first)
; 1565 : 	if (!tw)

	cmp	DWORD PTR _tw$[ebp], 0
	jne	SHORT $LN18@SetWPTimes

; 1566 : 		tw = fw;

	mov	eax, DWORD PTR _fw$[ebp]
	mov	DWORD PTR _tw$[ebp], eax
$LN18@SetWPTimes:

; 1567 : 	mission_time = tw->GetWPDepartureTime();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _mission_time$[ebp], eax

; 1568 : 	tw->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1569 : 	ShiAssert (mission_time > 0.0F);
; 1570 : 	w = tw->GetNextWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax
$LN17@SetWPTimes:

; 1571 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN16@SetWPTimes

; 1572 : 		{
; 1573 : 		w->GetWPLocation(&nx,&ny);

	lea	eax, DWORD PTR _ny$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1574 : 		dist = Distance(x,y,nx,ny);

	movzx	edx, WORD PTR _ny$[ebp]
	push	edx
	movzx	eax, WORD PTR _nx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dist$[ebp]

; 1575 : 		if (w->GetWPArrivalTime() > 0)			// Preset time - Adjust Speed to match

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	test	eax, eax
	jbe	$LN15@SetWPTimes

; 1576 : 			{
; 1577 : 			ShiAssert(w->GetWPArrivalTime() > mission_time);
; 1578 : 			time = w->GetWPArrivalTime() - mission_time;

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	sub	eax, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _time$[ebp], eax

; 1579 : 			speed = (dist * CampaignHours) / time;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@4a5bba00
	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR tv379[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv379[ebp]
	mov	ecx, DWORD PTR tv379[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv383[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv383[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _speed$[ebp], xmm0

; 1580 : 			if (speed < minSpeed)

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN14@SetWPTimes

; 1581 : 				speed = minSpeed;

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN14@SetWPTimes:

; 1582 : 			if (speed > maxSpeed)

	movss	xmm0, DWORD PTR _speed$[ebp]
	comiss	xmm0, DWORD PTR _maxSpeed$[ebp]
	jbe	SHORT $LN13@SetWPTimes

; 1583 : 				speed = maxSpeed;

	movss	xmm0, DWORD PTR _maxSpeed$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN13@SetWPTimes:

; 1584 : 			w->SetWPSpeed(speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed

; 1585 : 			}
; 1586 : 		else

	jmp	SHORT $LN12@SetWPTimes
$LN15@SetWPTimes:

; 1587 : 			speed = w->GetWPSpeed();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPSpeed@WayPointClass@@QAEMXZ	; WayPointClass::GetWPSpeed
	fstp	DWORD PTR _speed$[ebp]
$LN12@SetWPTimes:

; 1588 : 		mission_time += TimeToArrive(dist,speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	add	eax, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _mission_time$[ebp], eax

; 1589 : 		w->SetWPTimes(mission_time);

	mov	edx, DWORD PTR _mission_time$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes

; 1590 : 		// Set package turn point time, as a secondary syncronization point
; 1591 : 		if (w->GetWPFlags() == WPF_TURNPOINT && ((Package)pack)->GetTPTime() < 1.0F)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN11@SetWPTimes
	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetTPTime@PackageClass@@QAEKXZ		; PackageClass::GetTPTime
	mov	DWORD PTR tv404[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv404[ebp]
	mov	eax, DWORD PTR tv404[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv407[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv407[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@SetWPTimes

; 1592 : 			((Package)pack)->SetTPTime (mission_time);

	mov	ecx, DWORD PTR _mission_time$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pack$[ebp]
	call	?SetTPTime@PackageClass@@QAEXK@Z	; PackageClass::SetTPTime
$LN11@SetWPTimes:

; 1593 : 		mission_time += w->GetWPStationTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPStationTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPStationTime
	add	eax, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _mission_time$[ebp], eax

; 1594 : #ifdef DEBUG
; 1595 : //		if (u->GetUnitMission() != AMIS_ALERT && u->GetUnitMission() != AMIS_RECONPATROL)
; 1596 : //			ShiAssert(!WayPointErrorCode(w,u));
; 1597 : #endif
; 1598 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1599 : 		x = nx; y = ny;

	mov	dx, WORD PTR _nx$[ebp]
	mov	WORD PTR _x$[ebp], dx
	mov	ax, WORD PTR _ny$[ebp]
	mov	WORD PTR _y$[ebp], ax

; 1600 : 		}

	jmp	$LN17@SetWPTimes
$LN16@SetWPTimes:

; 1601 : 	land = mission_time;		// This is landing time

	mov	ecx, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _land$[ebp], ecx

; 1602 : 
; 1603 : 	// Backwards, from target to takeoff
; 1604 : 	mission_time = tw->GetWPArrivalTime();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _mission_time$[ebp], eax

; 1605 : 	tw->GetWPLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1606 : 	w = tw->GetPrevWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _w$[ebp], eax
$LN10@SetWPTimes:

; 1607 : 	unsigned long prevmission_time;
; 1608 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN9@SetWPTimes

; 1609 : 		{
; 1610 : 		w->GetWPLocation(&nx,&ny);

	lea	ecx, DWORD PTR _ny$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1611 : 		dist = Distance(x,y,nx,ny);

	movzx	eax, WORD PTR _ny$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dist$[ebp]

; 1612 : 		if (w->GetWPArrivalTime() > 0)			// Preset time

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	test	eax, eax
	jbe	$LN8@SetWPTimes

; 1613 : 			{
; 1614 : //			ShiAssert(mission_time > w->GetWPDepartureTime());
; 1615 : 			time = mission_time - w->GetWPDepartureTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	ecx, DWORD PTR _mission_time$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _time$[ebp], ecx

; 1616 : 			speed = (dist * CampaignHours) / time;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@4a5bba00
	mov	edx, DWORD PTR _time$[ebp]
	mov	DWORD PTR tv439[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv439[ebp]
	mov	eax, DWORD PTR tv439[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv443[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv443[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _speed$[ebp], xmm0

; 1617 : 			if (speed < minSpeed)

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN7@SetWPTimes

; 1618 : 				speed = minSpeed;

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN7@SetWPTimes:

; 1619 : 			if (speed > maxSpeed)

	movss	xmm0, DWORD PTR _speed$[ebp]
	comiss	xmm0, DWORD PTR _maxSpeed$[ebp]
	jbe	SHORT $LN6@SetWPTimes

; 1620 : 				speed = maxSpeed;

	movss	xmm0, DWORD PTR _maxSpeed$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN6@SetWPTimes:

; 1621 : 			w->GetNextWP()->SetWPSpeed(speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, eax
	call	?SetWPSpeed@WayPointClass@@QAEXM@Z	; WayPointClass::SetWPSpeed

; 1622 : 			mission_time = w->GetWPArrivalTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _mission_time$[ebp], eax

; 1623 : 			}
; 1624 : 		else

	jmp	SHORT $LN5@SetWPTimes
$LN8@SetWPTimes:

; 1625 : 			{
; 1626 : 			speed = w->GetNextWP()->GetWPSpeed();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, eax
	call	?GetWPSpeed@WayPointClass@@QAEMXZ	; WayPointClass::GetWPSpeed
	fstp	DWORD PTR _speed$[ebp]

; 1627 : 			if (w->GetWPAction() == WP_TAKEOFF)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN4@SetWPTimes

; 1628 : 				prevmission_time = mission_time;

	mov	ecx, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _prevmission_time$[ebp], ecx
$LN4@SetWPTimes:

; 1629 : 			mission_time -= TimeToArrive(dist,speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?TimeToArrive@@YAKMM@Z			; TimeToArrive
	add	esp, 8
	mov	edx, DWORD PTR _mission_time$[ebp]
	sub	edx, eax
	mov	DWORD PTR _mission_time$[ebp], edx

; 1630 : 			mission_time -= w->GetWPStationTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPStationTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPStationTime
	mov	ecx, DWORD PTR _mission_time$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _mission_time$[ebp], ecx
$LN5@SetWPTimes:

; 1631 : 			}
; 1632 : // 2002-03-21 MN give a bit more time at takeoff
; 1633 : /*		if (w->GetWPAction() == WP_TAKEOFF)
; 1634 : 		{
; 1635 : 			mission_time -= 15000; // we need a bit more time to take off...
; 1636 : 			w->SetWPTimes(mission_time);
; 1637 : 			time = prevmission_time - w->GetWPDepartureTime();
; 1638 : 			speed = (dist * CampaignHours) / time;
; 1639 : 			if (speed < minSpeed)
; 1640 : 				speed = minSpeed;
; 1641 : 			if (speed > maxSpeed)
; 1642 : 				speed = maxSpeed;
; 1643 : 			w->GetNextWP()->SetWPSpeed(speed);
; 1644 : 		}
; 1645 : 		else*/
; 1646 : 			w->SetWPTimes(mission_time);

	mov	edx, DWORD PTR _mission_time$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes

; 1647 : 		w = w->GetPrevWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _w$[ebp], eax

; 1648 : 		x = nx; y = ny;

	mov	ax, WORD PTR _nx$[ebp]
	mov	WORD PTR _x$[ebp], ax
	mov	cx, WORD PTR _ny$[ebp]
	mov	WORD PTR _y$[ebp], cx

; 1649 : 		}

	jmp	$LN10@SetWPTimes
$LN9@SetWPTimes:

; 1650 : 	to = mission_time;			// This is takeoff time

	mov	edx, DWORD PTR _mission_time$[ebp]
	mov	DWORD PTR _to$[ebp], edx

; 1651 : 
; 1652 : 	// Calculate length and check for impossible takeoff times
; 1653 : // 2001-10-31 MODIFIED by M.N. Added new flag check for TE Missions. 
; 1654 : // In TE Planner, to < CurrentTime is always the case, thus we get a wrong mission length
; 1655 : 	if (mis->flags & REQF_TE_MISSION)

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN3@SetWPTimes

; 1656 : 		return land - to;

	mov	eax, DWORD PTR _land$[ebp]
	sub	eax, DWORD PTR _to$[ebp]
	jmp	SHORT $LN36@SetWPTimes
$LN3@SetWPTimes:

; 1657 : 	if (to < TheCampaign.CurrentTime)

	mov	edx, DWORD PTR _to$[ebp]
	cmp	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jae	SHORT $LN2@SetWPTimes

; 1658 : 		return (long)to - (long)TheCampaign.CurrentTime;

	mov	eax, DWORD PTR _to$[ebp]
	sub	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jmp	SHORT $LN36@SetWPTimes
$LN2@SetWPTimes:

; 1659 : 	if (land > to)

	mov	eax, DWORD PTR _land$[ebp]
	cmp	eax, DWORD PTR _to$[ebp]
	jbe	SHORT $LN1@SetWPTimes

; 1660 : 		return land - to;

	mov	eax, DWORD PTR _land$[ebp]
	sub	eax, DWORD PTR _to$[ebp]
	jmp	SHORT $LN36@SetWPTimes
$LN1@SetWPTimes:

; 1661 : 	return 0;

	xor	eax, eax
$LN36@SetWPTimes:

; 1662 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SetWPTimes@@YAJPAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; SetWPTimes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_ingresstime$ = -136					; size = 4
$T2 = -132						; size = 4
_landtime$ = -128					; size = 4
$T3 = -124						; size = 4
_pack$ = -120						; size = 4
_sw$ = -116						; size = 4
_fw$ = -112						; size = 4
tv390 = -108						; size = 4
$T4 = -104						; size = 4
tv228 = -100						; size = 4
$T5 = -96						; size = 4
_totime$ = -92						; size = 4
_mis$ = -88						; size = 4
_wdist$ = -84						; size = 4
_dist$ = -80						; size = 4
_time$ = -76						; size = 4
_fuel$ = -72						; size = 4
_fuelNeeded$ = -68					; size = 4
_bd$ = -64						; size = 4
_d$ = -60						; size = 4
_wpinserted$ = -56					; size = 4
_length$ = -52						; size = 4
_w$ = -48						; size = 4
_bw$ = -44						; size = 4
_lw$ = -40						; size = 4
_wx$ = -36						; size = 2
_wy$ = -32						; size = 2
_ix$ = -28						; size = 2
_iy$ = -24						; size = 2
_x$ = -20						; size = 2
_y$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
_refuel$ = 12						; size = 4
?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z PROC		; AddTankerWayPoint

; 1282 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1283 : 	WayPoint		w = NULL,lw = NULL,fw = NULL,sw = NULL,bw = NULL;

	mov	DWORD PTR _w$[ebp], 0
	mov	DWORD PTR _lw$[ebp], 0
	mov	DWORD PTR _fw$[ebp], 0
	mov	DWORD PTR _sw$[ebp], 0
	mov	DWORD PTR _bw$[ebp], 0

; 1284 : 	float			dist,wdist;
; 1285 : 	Int32			d,bd;
; 1286 : 	int				fuel, fuelNeeded;
; 1287 : 	GridIndex		x,y,ix,iy,wx,wy;
; 1288 : //	Objective		o;		Use CampMap team locator instead of objective
; 1289 : 	Package			pack;
; 1290 : 	MissionRequestClass *mis;	
; 1291 : 	CampaignTime	time,totime,landtime,ingresstime;
; 1292 : 	int				wpinserted = 0;

	mov	DWORD PTR _wpinserted$[ebp], 0

; 1293 : 	long			length;
; 1294 : 
; 1295 : 	// This assumes the flight is still owned by the ATM's machine
; 1296 : 	// If not, return..
; 1297 : 	if (!TeamInfo[u->GetTeam()]->atm->IsLocal())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+876]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN33@AddTankerW

; 1298 : 		return 1;

	mov	eax, 1
	jmp	$LN34@AddTankerW
$LN33@AddTankerW:

; 1299 : 	
; 1300 : 	if (refuel < g_nNoWPRefuelNeeded)

	mov	ecx, DWORD PTR _refuel$[ebp]
	cmp	ecx, DWORD PTR ?g_nNoWPRefuelNeeded@@3HA ; g_nNoWPRefuelNeeded
	jge	SHORT $LN32@AddTankerW

; 1301 : 		return 1;

	mov	eax, 1
	jmp	$LN34@AddTankerW
$LN32@AddTankerW:

; 1302 : 
; 1303 : 	// Okay, we will now - hopefully at least added one regular tanker waypoint,
; 1304 : 	// remove a possible tanker information waypoint, which is not 
; 1305 : 	// needed anymore, and get takeoff & land waypoint for excess elimination
; 1306 : 
; 1307 : 	lw = u->wp_list;

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR _lw$[ebp], eax
$LN31@AddTankerW:

; 1308 : 	while (lw)

	cmp	DWORD PTR _lw$[ebp], 0
	je	SHORT $LN30@AddTankerW

; 1309 : 	{
; 1310 : 		bw = lw;

	mov	ecx, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _bw$[ebp], ecx

; 1311 : 		// only delete tanker information WP, not regular refueling WP
; 1312 : 		if (bw->GetWPAction() == WP_REFUEL && (bw->GetWPFlags() & WPF_REFUEL_INFORMATION)) 

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 4
	jne	SHORT $LN29@AddTankerW
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 65536				; 00010000H
	je	SHORT $LN29@AddTankerW

; 1313 : 			bw->DeleteWP();

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP
$LN29@AddTankerW:

; 1314 : 		if (lw->GetWPAction() == WP_TAKEOFF)

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN28@AddTankerW

; 1315 : 		{
; 1316 : 			totime = lw->GetWPDepartureTime();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _totime$[ebp], eax

; 1317 : 			sw = lw;

	mov	edx, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _sw$[ebp], edx
$LN28@AddTankerW:

; 1318 : 		}
; 1319 : 		if (lw->GetWPAction() == WP_LAND)

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN27@AddTankerW

; 1320 : 		{
; 1321 : 			landtime = lw->GetWPArrivalTime();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _landtime$[ebp], eax

; 1322 : 			fw = lw;

	mov	eax, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _fw$[ebp], eax
$LN27@AddTankerW:

; 1323 : 		}
; 1324 : 		lw = lw->GetNextWP();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _lw$[ebp], eax

; 1325 : 	}

	jmp	SHORT $LN31@AddTankerW
$LN30@AddTankerW:

; 1326 : 
; 1327 : 	x = y = ix = iy = wx = wy = 0;

	xor	ecx, ecx
	mov	WORD PTR _wy$[ebp], cx
	mov	dx, WORD PTR _wy$[ebp]
	mov	WORD PTR _wx$[ebp], dx
	mov	ax, WORD PTR _wx$[ebp]
	mov	WORD PTR _iy$[ebp], ax
	mov	cx, WORD PTR _iy$[ebp]
	mov	WORD PTR _ix$[ebp], cx
	mov	dx, WORD PTR _ix$[ebp]
	mov	WORD PTR _y$[ebp], dx
	mov	ax, WORD PTR _y$[ebp]
	mov	WORD PTR _x$[ebp], ax

; 1328 : 
; 1329 : 	pack = u->GetUnitPackage();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitPackage@FlightClass@@QAEPAVPackageClass@@XZ ; FlightClass::GetUnitPackage
	mov	DWORD PTR _pack$[ebp], eax

; 1330 : 	mis = pack->GetMissionRequest();

	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetMissionRequest@PackageClass@@QAEPAVMissionRequestClass@@XZ ; PackageClass::GetMissionRequest
	mov	DWORD PTR _mis$[ebp], eax

; 1331 : 	SetupAltitudes (u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?SetupAltitudes@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupAltitudes
	add	esp, 8

; 1332 : 
; 1333 : 	fuel = u->CalculateFuelAvailable(255); // this gives us the loaded fuel (+ extra tanks)

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	call	?CalculateFuelAvailable@FlightClass@@QAEJH@Z ; FlightClass::CalculateFuelAvailable
	mov	DWORD PTR _fuel$[ebp], eax

; 1334 : 
; 1335 : 	// if needed fuel (==refuel) is less than the flight 
; 1336 : 	// unit's fuel * 2/3, only add a refuel waypoint at 
; 1337 : 	// egress, if more, add another one at ingress.
; 1338 : 
; 1339 : 	lw = u->wp_list;

	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _lw$[ebp], ecx

; 1340 : 	if (refuel > (2*fuel/3) && g_bAddIngressWP)	// Add a Tanker waypoint at ingress

	mov	eax, DWORD PTR _fuel$[ebp]
	shl	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	cmp	DWORD PTR _refuel$[ebp], eax
	jle	$LN16@AddTankerW
	movzx	edx, BYTE PTR ?g_bAddIngressWP@@3_NA	; g_bAddIngressWP
	test	edx, edx
	je	$LN16@AddTankerW

; 1341 : 	{
; 1342 : 		// Find the ingress waypoint closest to an active tanker
; 1343 : 		bd = 9990;

	mov	DWORD PTR _bd$[ebp], 9990		; 00002706H

; 1344 : 		bw = NULL;

	mov	DWORD PTR _bw$[ebp], 0
$LN25@AddTankerW:

; 1345 : 		while (lw && lw->GetNextWP())

	cmp	DWORD PTR _lw$[ebp], 0
	je	$LN24@AddTankerW
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	$LN24@AddTankerW

; 1346 : 		{
; 1347 : 			lw->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1348 : 			wx = x;

	mov	dx, WORD PTR _x$[ebp]
	mov	WORD PTR _wx$[ebp], dx

; 1349 : 			wy = y;

	mov	ax, WORD PTR _y$[ebp]
	mov	WORD PTR _wy$[ebp], ax

; 1350 : 			time = lw->GetWPArrivalTime();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _time$[ebp], eax

; 1351 : 			d = TeamInfo[u->GetTeam()]->atm->FindNearestActiveTanker(&x,&y,&time);

	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+876]
	call	?FindNearestActiveTanker@AirTaskingManagerClass@@QAEHPAF0PAK@Z ; AirTaskingManagerClass::FindNearestActiveTanker
	mov	DWORD PTR _d$[ebp], eax

; 1352 : 			if (d < bd)

	mov	eax, DWORD PTR _d$[ebp]
	cmp	eax, DWORD PTR _bd$[ebp]
	jge	SHORT $LN23@AddTankerW

; 1353 : 			{
; 1354 : 				bd = d;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _bd$[ebp], ecx

; 1355 : 				bw = lw;

	mov	edx, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _bw$[ebp], edx

; 1356 : 				ix = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _ix$[ebp], ax

; 1357 : 				iy = y;

	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _iy$[ebp], cx
$LN23@AddTankerW:

; 1358 : 			}
; 1359 : //			o = FindNearestObjective(wx,wy,NULL); // objective near the waypoint => marker for territory
; 1360 : 			if (::GetOwner(TheCampaign.CampMapData, wx, wy) != u->GetTeam()) // abort search if we got into enemy territory

	movzx	edx, WORD PTR _wy$[ebp]
	push	edx
	movzx	eax, WORD PTR _wx$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+296
	push	ecx
	call	?GetOwner@@YAEPAEFF@Z			; GetOwner
	add	esp, 12					; 0000000cH
	movzx	esi, al
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	esi, eax
	je	SHORT $LN22@AddTankerW

; 1361 : 			{
; 1362 : 				break;

	jmp	SHORT $LN24@AddTankerW
$LN22@AddTankerW:

; 1363 : 			}
; 1364 : 			lw = lw->GetNextWP();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _lw$[ebp], eax

; 1365 : 		}

	jmp	$LN25@AddTankerW
$LN24@AddTankerW:

; 1366 : 
; 1367 : 		if (ix != 0 && iy != 0)	// -> We have found a tanker near a waypoint

	movsx	ecx, WORD PTR _ix$[ebp]
	test	ecx, ecx
	je	$LN16@AddTankerW
	movsx	edx, WORD PTR _iy$[ebp]
	test	edx, edx
	je	$LN16@AddTankerW

; 1368 : 		{
; 1369 : 			dist = DistanceToFront(ix,iy); // Tankers distance to FLOT

	movzx	eax, WORD PTR _iy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ix$[ebp]
	push	ecx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 1370 : 			w = new WayPointClass(ix, iy, 20000, 0, 0, 0, WP_REFUEL, 0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN36@AddTankerW
	push	0
	push	4
	push	0
	push	0
	push	0
	push	20000					; 00004e20H
	movzx	edx, WORD PTR _iy$[ebp]
	push	edx
	movzx	eax, WORD PTR _ix$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN37@AddTankerW
$LN36@AddTankerW:
	mov	DWORD PTR tv228[ebp], 0
$LN37@AddTankerW:
	mov	ecx, DWORD PTR tv228[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 1371 : //			o = FindNearestObjective(wx,wy,NULL);
; 1372 : 			// We can have the case that a waypoint on the other side of the FLOT
; 1373 : 			// is closer to an active tanker at its mistot time than a waypoint on friendly side.
; 1374 : 			// In this case, go one waypoint back
; 1375 : 			if (::GetOwner(TheCampaign.CampMapData, wx, wy) != u->GetTeam() && bw->GetPrevWP())

	movzx	eax, WORD PTR _wy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _wx$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+296
	push	edx
	call	?GetOwner@@YAEPAEFF@Z			; GetOwner
	add	esp, 12					; 0000000cH
	movzx	esi, al
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN20@AddTankerW
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN20@AddTankerW

; 1376 : 				bw = bw->GetPrevWP();		// Is wx,wy right here ?????????????????

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _bw$[ebp], eax
$LN20@AddTankerW:

; 1377 : 			
; 1378 : 			bw->GetWPLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1379 : 			wdist = DistanceToFront(x,y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR _wdist$[ebp]

; 1380 : 			if (wdist < dist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _wdist$[ebp]
	jbe	SHORT $LN19@AddTankerW

; 1381 : 				bw->InsertWP(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1382 : 			else

	jmp	SHORT $LN18@AddTankerW
$LN19@AddTankerW:

; 1383 : 			{
; 1384 : 				bw = bw->GetNextWP();

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _bw$[ebp], eax

; 1385 : 				// Do the friendly territory check here again
; 1386 : 				bw->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1387 : //				o = FindNearestObjective(x,y,NULL);
; 1388 : 				if (::GetOwner(TheCampaign.CampMapData, x, y) != u->GetTeam() && bw->GetPrevWP())

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+296
	push	edx
	call	?GetOwner@@YAEPAEFF@Z			; GetOwner
	add	esp, 12					; 0000000cH
	movzx	esi, al
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN17@AddTankerW
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN17@AddTankerW

; 1389 : 					bw = bw->GetPrevWP();

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _bw$[ebp], eax
$LN17@AddTankerW:

; 1390 : 				bw->InsertWP(w);

	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN18@AddTankerW:

; 1391 : 			}
; 1392 : 			FinalizeWayPoint(w);

	push	0
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1393 : 			wpinserted++;

	mov	ecx, DWORD PTR _wpinserted$[ebp]
	add	ecx, 1
	mov	DWORD PTR _wpinserted$[ebp], ecx

; 1394 : 			SetWPTimesTanker(u,mis,true, landtime);

	mov	edx, DWORD PTR _landtime$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _mis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?SetWPTimesTanker@@YAJPAVFlightClass@@PAVMissionRequestClass@@_NK@Z ; SetWPTimesTanker
	add	esp, 16					; 00000010H

; 1395 : 			// Check if we can reach this first tanker waypoint with our loaded fuel,
; 1396 : 			// otherwise kill this unit
; 1397 : 			ingresstime = w->GetWPDepartureTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _ingresstime$[ebp], eax

; 1398 : 			length = w->GetWPArrivalTime() - totime;

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	sub	eax, DWORD PTR _totime$[ebp]
	mov	DWORD PTR _length$[ebp], eax

; 1399 : 			fuelNeeded = ((int)(length/CampaignMinutes) * u->GetClassData()->Rate);

	mov	eax, DWORD PTR _length$[ebp]
	cdq
	mov	ecx, 60000				; 0000ea60H
	idiv	ecx
	mov	esi, eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetClassData
	movsx	edx, WORD PTR [eax+264]
	imul	esi, edx
	mov	DWORD PTR _fuelNeeded$[ebp], esi

; 1400 : 			if (fuelNeeded > fuel*1.5) // way to tanker, 50% tolerance

	cvtsi2sd xmm0, DWORD PTR _fuelNeeded$[ebp]
	cvtsi2sd xmm1, DWORD PTR _fuel$[ebp]
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	comisd	xmm0, xmm1
	jbe	SHORT $LN16@AddTankerW

; 1401 : 			{
; 1402 : #ifdef DEBUG
; 1403 : 				MonoPrint ("Flight %d can't reach ingress tanker",u->GetCampID());
; 1404 : #endif
; 1405 : 				return 0;

	xor	eax, eax
	jmp	$LN34@AddTankerW
$LN16@AddTankerW:

; 1406 : 			}
; 1407 : 		}
; 1408 : 	}
; 1409 : 
; 1410 : 	ix = iy = 0;

	xor	eax, eax
	mov	WORD PTR _iy$[ebp], ax
	mov	cx, WORD PTR _iy$[ebp]
	mov	WORD PTR _ix$[ebp], cx

; 1411 : 	lw = u->wp_list;

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR _lw$[ebp], eax
$LN15@AddTankerW:

; 1412 : 	// Get the landing waypoint, and backwards browse the wp list for the best egress wp
; 1413 : 	while (lw && lw->GetNextWP())

	cmp	DWORD PTR _lw$[ebp], 0
	je	SHORT $LN14@AddTankerW
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN14@AddTankerW

; 1414 : 	{
; 1415 : 		if (lw->GetWPAction() == WP_LAND)

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN13@AddTankerW

; 1416 : 		{
; 1417 : 			break;

	jmp	SHORT $LN14@AddTankerW
$LN13@AddTankerW:

; 1418 : 		}
; 1419 : 		lw = lw->GetNextWP();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _lw$[ebp], eax

; 1420 : 	}

	jmp	SHORT $LN15@AddTankerW
$LN14@AddTankerW:

; 1421 : 
; 1422 : 	// Find the egress waypoint closest to an active tanker
; 1423 : 
; 1424 : 	bd = 9990;

	mov	DWORD PTR _bd$[ebp], 9990		; 00002706H

; 1425 : 	bw = NULL;

	mov	DWORD PTR _bw$[ebp], 0
$LN12@AddTankerW:

; 1426 : 	while (lw && lw->GetPrevWP())

	cmp	DWORD PTR _lw$[ebp], 0
	je	$LN11@AddTankerW
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	$LN11@AddTankerW

; 1427 : 	{
; 1428 : 		lw->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1429 : 		wx = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _wx$[ebp], ax

; 1430 : 		wy = y;

	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR _wy$[ebp], cx

; 1431 : 		time = lw->GetWPArrivalTime();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _time$[ebp], eax

; 1432 : 		d = TeamInfo[u->GetTeam()]->atm->FindNearestActiveTanker(&x,&y,&time);

	lea	edx, DWORD PTR _time$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	ecx, DWORD PTR [ecx+876]
	call	?FindNearestActiveTanker@AirTaskingManagerClass@@QAEHPAF0PAK@Z ; AirTaskingManagerClass::FindNearestActiveTanker
	mov	DWORD PTR _d$[ebp], eax

; 1433 : 		if (d < bd)

	mov	edx, DWORD PTR _d$[ebp]
	cmp	edx, DWORD PTR _bd$[ebp]
	jge	SHORT $LN10@AddTankerW

; 1434 : 		{
; 1435 : 			bd = d;

	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _bd$[ebp], eax

; 1436 : 			bw = lw;

	mov	ecx, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _bw$[ebp], ecx

; 1437 : 			ix = x;

	mov	dx, WORD PTR _x$[ebp]
	mov	WORD PTR _ix$[ebp], dx

; 1438 : 			iy = y;

	mov	ax, WORD PTR _y$[ebp]
	mov	WORD PTR _iy$[ebp], ax
$LN10@AddTankerW:

; 1439 : 		}
; 1440 : //		o = FindNearestObjective(wx,wy,NULL);
; 1441 : 		if (::GetOwner(TheCampaign.CampMapData, wx, wy) != u->GetTeam()) // abort search if we got into enemy territory

	movzx	ecx, WORD PTR _wy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _wx$[ebp]
	push	edx
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+296
	push	eax
	call	?GetOwner@@YAEPAEFF@Z			; GetOwner
	add	esp, 12					; 0000000cH
	movzx	esi, al
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN9@AddTankerW

; 1442 : 		{
; 1443 : 			//bw = lw;
; 1444 : 			break;

	jmp	SHORT $LN11@AddTankerW
$LN9@AddTankerW:

; 1445 : 		}
; 1446 : 		lw = lw->GetPrevWP();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _lw$[ebp], eax

; 1447 : 	}

	jmp	$LN12@AddTankerW
$LN11@AddTankerW:

; 1448 : 
; 1449 : 	if (ix != 0 && iy != 0)	// -> We have found a tanker, otherwise ix==iy==0;

	movsx	edx, WORD PTR _ix$[ebp]
	test	edx, edx
	je	$LN2@AddTankerW
	movsx	eax, WORD PTR _iy$[ebp]
	test	eax, eax
	je	$LN2@AddTankerW

; 1450 : 	{
; 1451 : 		dist = DistanceToFront(ix,iy); // Tankers distance to FLOT

	movzx	ecx, WORD PTR _iy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ix$[ebp]
	push	edx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 1452 : 		w = new WayPointClass(ix, iy, 20000, 0, 0, 0, WP_REFUEL, 0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN38@AddTankerW
	push	0
	push	4
	push	0
	push	0
	push	0
	push	20000					; 00004e20H
	movzx	eax, WORD PTR _iy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ix$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv390[ebp], eax
	jmp	SHORT $LN39@AddTankerW
$LN38@AddTankerW:
	mov	DWORD PTR tv390[ebp], 0
$LN39@AddTankerW:
	mov	edx, DWORD PTR tv390[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 1453 : 		bw->GetWPLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1454 : 		wdist = DistanceToFront(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 8
	fstp	DWORD PTR _wdist$[ebp]

; 1455 : 		if (wdist < dist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _wdist$[ebp]
	jbe	SHORT $LN7@AddTankerW

; 1456 : 			bw->InsertWP(w);

	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1457 : 		else

	jmp	SHORT $LN6@AddTankerW
$LN7@AddTankerW:

; 1458 : 		{
; 1459 : 			bw = bw->GetPrevWP();

	mov	ecx, DWORD PTR _bw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _bw$[ebp], eax

; 1460 : 			bw->InsertWP(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN6@AddTankerW:

; 1461 : 		}
; 1462 : 		FinalizeWayPoint(w);

	push	0
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 1463 : 		wpinserted++;

	mov	edx, DWORD PTR _wpinserted$[ebp]
	add	edx, 1
	mov	DWORD PTR _wpinserted$[ebp], edx

; 1464 : 		length = SetWPTimesTanker(u,mis,false, totime);

	mov	eax, DWORD PTR _totime$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	?SetWPTimesTanker@@YAJPAVFlightClass@@PAVMissionRequestClass@@_NK@Z ; SetWPTimesTanker
	add	esp, 16					; 00000010H
	mov	DWORD PTR _length$[ebp], eax

; 1465 : 		if (wpinserted == 2)	// we already have an ingress waypoint

	cmp	DWORD PTR _wpinserted$[ebp], 2
	jne	SHORT $LN5@AddTankerW

; 1466 : 		{
; 1467 : 			length = w->GetWPArrivalTime() - ingresstime;

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	sub	eax, DWORD PTR _ingresstime$[ebp]
	mov	DWORD PTR _length$[ebp], eax

; 1468 : 			fuelNeeded = ((int)(length/CampaignMinutes) * u->GetClassData()->Rate);

	mov	eax, DWORD PTR _length$[ebp]
	cdq
	mov	ecx, 60000				; 0000ea60H
	idiv	ecx
	mov	esi, eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetClassData
	movsx	edx, WORD PTR [eax+264]
	imul	esi, edx
	mov	DWORD PTR _fuelNeeded$[ebp], esi

; 1469 : 			if (fuelNeeded > fuel*1.5) // way ingresstanker -> egresstanker, 50% tolerance

	cvtsi2sd xmm0, DWORD PTR _fuelNeeded$[ebp]
	cvtsi2sd xmm1, DWORD PTR _fuel$[ebp]
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	comisd	xmm0, xmm1
	jbe	SHORT $LN4@AddTankerW

; 1470 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN34@AddTankerW
$LN4@AddTankerW:

; 1471 : 		}
; 1472 : 		else		// only an egress waypoint

	jmp	SHORT $LN2@AddTankerW
$LN5@AddTankerW:

; 1473 : 		{
; 1474 : 			length = w->GetWPArrivalTime() - totime;

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	sub	eax, DWORD PTR _totime$[ebp]
	mov	DWORD PTR _length$[ebp], eax

; 1475 : 			fuelNeeded = ((int)(length/CampaignMinutes) * u->GetClassData()->Rate);

	mov	eax, DWORD PTR _length$[ebp]
	cdq
	mov	ecx, 60000				; 0000ea60H
	idiv	ecx
	mov	esi, eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetClassData
	movsx	edx, WORD PTR [eax+264]
	imul	esi, edx
	mov	DWORD PTR _fuelNeeded$[ebp], esi

; 1476 : 			if (fuelNeeded > fuel*1.5) // way takeoff -> egresstanker, 50% tolerance

	cvtsi2sd xmm0, DWORD PTR _fuelNeeded$[ebp]
	cvtsi2sd xmm1, DWORD PTR _fuel$[ebp]
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	comisd	xmm0, xmm1
	jbe	SHORT $LN2@AddTankerW

; 1477 : 			{
; 1478 : #ifdef DEBUG
; 1479 : 		ShiWarning ("Takeoff to egresstanker can't be reached - needs adjusting the 2D fuel rates");
; 1480 : #endif
; 1481 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN34@AddTankerW
$LN2@AddTankerW:

; 1482 : 			}
; 1483 : 		}
; 1484 : 	}
; 1485 : 	if (!wpinserted)

	cmp	DWORD PTR _wpinserted$[ebp], 0
	jne	SHORT $LN1@AddTankerW

; 1486 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN34@AddTankerW
$LN1@AddTankerW:

; 1487 : 	EliminateExcessWaypoints(sw,fw,u->GetTeam()); // remove unneeded wpts from Takeoff to Land

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _fw$[ebp]
	push	edx
	mov	eax, DWORD PTR _sw$[ebp]
	push	eax
	call	?EliminateExcessWaypoints@@YAPAVWayPointClass@@PAV1@0H@Z ; EliminateExcessWaypoints
	add	esp, 12					; 0000000cH

; 1488 : 	return 1;

	mov	eax, 1
$LN34@AddTankerW:

; 1489 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddTankerWayPoint@@YAHPAVFlightClass@@H@Z ENDP		; AddTankerWayPoint
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_nw$ = -8						; size = 4
_w$ = -4						; size = 4
_flight$ = 8						; size = 4
?ClearDivertWayPoints@@YAXPAVFlightClass@@@Z PROC	; ClearDivertWayPoints

; 1263 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1264 : 	WayPoint		w,nw;
; 1265 : 
; 1266 : 	w = flight->GetFirstUnitWP();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax
$LN3@ClearDiver:

; 1267 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN4@ClearDiver

; 1268 : 		{
; 1269 : 		if (w->GetWPFlags() & WPF_DIVERT)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 512				; 00000200H
	je	SHORT $LN1@ClearDiver

; 1270 : 			{
; 1271 : 			nw = w;

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _nw$[ebp], eax

; 1272 : 			w = w->GetPrevWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _w$[ebp], eax

; 1273 : 			nw->DeleteWP();

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP
$LN1@ClearDiver:

; 1274 : 			}
; 1275 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1276 : 		}

	jmp	SHORT $LN3@ClearDiver
$LN4@ClearDiver:

; 1277 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDivertWayPoints@@YAXPAVFlightClass@@@Z ENDP	; ClearDivertWayPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -72						; size = 8
$T3 = -64						; size = 4
$T4 = -60						; size = 4
_d$ = -56						; size = 4
tv214 = -52						; size = 4
$T5 = -48						; size = 4
tv187 = -44						; size = 4
$T6 = -40						; size = 4
_time$ = -36						; size = 4
_o$ = -32						; size = 4
_w$ = -28						; size = 4
_lw$ = -24						; size = 4
_y$ = -20						; size = 2
_x$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_flight$ = 8						; size = 4
_mis$ = 12						; size = 4
?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; AddInformationWPs

; 1204 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1205 : 	WayPoint		w,lw;
; 1206 : 	int				d;
; 1207 : 	GridIndex		x,y;
; 1208 : 	Objective		o;
; 1209 : 	CampaignTime	time;
; 1210 : 
; 1211 : 	// KCK NOTE: This assumes the flight is still owned by the ATM's machine
; 1212 : 	// If not, abort..
; 1213 : 	if (!TeamInfo[flight->GetTeam()]->atm->IsLocal())

	mov	eax, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+876]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@AddInforma

; 1214 : 		return;

	jmp	$LN9@AddInforma
$LN8@AddInforma:

; 1215 : 
; 1216 : 	x = y = 0;

	xor	ecx, ecx
	mov	WORD PTR _y$[ebp], cx
	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR _x$[ebp], dx

; 1217 : 	lw = flight->wp_list;

	mov	eax, DWORD PTR _flight$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _lw$[ebp], ecx
$LN7@AddInforma:

; 1218 : 	while (lw && lw->GetNextWP())

	cmp	DWORD PTR _lw$[ebp], 0
	je	SHORT $LN6@AddInforma
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN6@AddInforma

; 1219 : 		{
; 1220 : 		if (!x && lw->GetWPFlags() & WPF_ASSEMBLE)

	movsx	edx, WORD PTR _x$[ebp]
	test	edx, edx
	jne	SHORT $LN5@AddInforma
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 2
	je	SHORT $LN5@AddInforma

; 1221 : 			{
; 1222 : 			lw->GetWPLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 1223 : 			time = lw->GetWPArrivalTime();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _time$[ebp], eax
$LN5@AddInforma:

; 1224 : 			}
; 1225 : 		lw = lw->GetNextWP();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _lw$[ebp], eax

; 1226 : 		}

	jmp	SHORT $LN7@AddInforma
$LN6@AddInforma:

; 1227 : 
; 1228 : 	// Find Tanker (Use assembly points, if possible, otherwise target)
; 1229 : 	if (!x)

	movsx	edx, WORD PTR _x$[ebp]
	test	edx, edx
	jne	SHORT $LN4@AddInforma

; 1230 : 		{
; 1231 : 		x = mis->tx;

	mov	eax, DWORD PTR _mis$[ebp]
	mov	cx, WORD PTR [eax+40]
	mov	WORD PTR _x$[ebp], cx

; 1232 : 		y = mis->ty;

	mov	edx, DWORD PTR _mis$[ebp]
	mov	ax, WORD PTR [edx+42]
	mov	WORD PTR _y$[ebp], ax

; 1233 : 		time = mis->tot;

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _time$[ebp], edx
$LN4@AddInforma:

; 1234 : 		}
; 1235 : 	if (flight->GetUnitMission() != AMIS_TANKER)

	mov	eax, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 28					; 0000001cH
	je	$LN3@AddInforma

; 1236 : 		{
; 1237 :  		d = TeamInfo[flight->GetTeam()]->atm->FindNearestActiveTanker(&x,&y,&time);

	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+876]
	call	?FindNearestActiveTanker@AirTaskingManagerClass@@QAEHPAF0PAK@Z ; AirTaskingManagerClass::FindNearestActiveTanker
	mov	DWORD PTR _d$[ebp], eax

; 1238 : 		if (d < MAXIMUM_TANKER_DISTANCE*4)

	movsx	eax, WORD PTR ?MAXIMUM_TANKER_DISTANCE@@3FA ; MAXIMUM_TANKER_DISTANCE
	shl	eax, 2
	cmp	DWORD PTR _d$[ebp], eax
	jge	SHORT $LN3@AddInforma

; 1239 : 			{
; 1240 : 			w = new WayPointClass(x, y, 20000, 0, 0, 0, WP_REFUEL, WPF_REFUEL_INFORMATION);	// M.N. added REFUEL_INFORMATION flag

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN11@AddInforma
	push	65536					; 00010000H
	push	4
	push	0
	push	0
	push	0
	push	20000					; 00004e20H
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv187[ebp], eax
	jmp	SHORT $LN12@AddInforma
$LN11@AddInforma:
	mov	DWORD PTR tv187[ebp], 0
$LN12@AddInforma:
	mov	eax, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _w$[ebp], ecx

; 1241 : //			w->SetWPTarget(tanker);
; 1242 : 			lw->InsertWP(w);

	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1243 : 			lw = w;

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], eax
$LN3@AddInforma:

; 1244 : 			}
; 1245 : 		}
; 1246 : 
; 1247 : 	// Find Secondary Target
; 1248 : 	// KCK NOTE: Do Later
; 1249 : 
; 1250 : 	// Find Abort Strip
; 1251 : 	o = FindAlternateStrip ((Flight)flight);

	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	call	?FindAlternateStrip@@YAPAVObjectiveClass@@PAVFlightClass@@@Z ; FindAlternateStrip
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax

; 1252 : 	if (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN9@AddInforma

; 1253 : 		{
; 1254 : 		o->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1255 : 		w = new WayPointClass(x, y, 0, 0, 0, 0, WP_LAND, WPF_ALTERNATE | WPF_LAND | WPF_HOLDCURRENT);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN13@AddInforma
	push	3328					; 00000d00H
	push	7
	push	0
	push	0
	push	0
	push	0
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN14@AddInforma
$LN13@AddInforma:
	mov	DWORD PTR tv214[ebp], 0
$LN14@AddInforma:
	mov	eax, DWORD PTR tv214[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _w$[ebp], ecx

; 1256 : 		w->SetWPTarget(o->Id());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 1257 : 		lw->InsertWP(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1258 : 		lw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], ecx
$LN9@AddInforma:

; 1259 : 		}
; 1260 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddInformationWPs@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; AddInformationWPs
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
_nw$ = -24						; size = 4
_cw$ = -20						; size = 4
_w$ = -16						; size = 4
_tw$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
_flight$ = 8						; size = 4
_mis$ = 12						; size = 4
?BuildDivertPath@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z PROC ; BuildDivertPath

; 719  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 720  : 	WayPoint	cw,w,nw,tw;
; 721  : 	GridIndex	x,y;
; 722  : 
; 723  : 	w = cw = flight->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _cw$[ebp], eax
	mov	eax, DWORD PTR _cw$[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 724  : 	if (!cw)

	cmp	DWORD PTR _cw$[ebp], 0
	jne	SHORT $LN8@BuildDiver

; 725  : 		{
; 726  : 		MonoPrint("Problem - airborne flight with no waypoints!n");

	push	OFFSET ??_C@_0CO@LNFFDOCL@Problem?5?9?5airborne?5flight?5with?5n@
	call	_MonoPrint
	add	esp, 4

; 727  : 		return;

	jmp	$LN9@BuildDiver
$LN8@BuildDiver:

; 728  : 		}
; 729  : 
; 730  : 	SetupAltitudes(flight, mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flight$[ebp]
	push	edx
	call	?SetupAltitudes@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupAltitudes
	add	esp, 8

; 731  : 
; 732  : 	tw = AddTargetProfile(NULL,flight,mis);

	mov	eax, DWORD PTR _mis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	push	0
	call	?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddTargetProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tw$[ebp], eax

; 733  : 	tw->SetWPFlags(w->GetWPFlags() | WPF_DIVERT | WPF_TARGET);

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	or	eax, 512				; 00000200H
	or	eax, 1
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPFlags@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlags

; 734  : 	tw->SetWPAltitude(MissionData[mis->mission].missionalt*100);//Cobra they forgot *100 ;)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movsx	ecx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+12]
	imul	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude

; 735  : 
; 736  : 	if (w->GetWPAction() == WP_TAKEOFF || !w->GetPrevWP())

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	je	SHORT $LN6@BuildDiver
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	jne	SHORT $LN7@BuildDiver
$LN6@BuildDiver:

; 737  : 		{
; 738  : 		// This thing hasn't taken off yet, so plan a real route
; 739  : 		w->InsertWP(tw);

	mov	edx, DWORD PTR _tw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 740  : 		SetWPTimes (w, TheCampaign.CurrentTime + CampaignMinutes, sMissionSpeed, 0);

	push	0
	mov	eax, DWORD PTR _sMissionSpeed
	push	eax
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	add	ecx, 60000				; 0000ea60H
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	?SetWPTimes@@YAKPAVWayPointClass@@KHH@Z	; SetWPTimes
	add	esp, 16					; 00000010H

; 741  : 		}
; 742  : 	else

	jmp	$LN9@BuildDiver
$LN7@BuildDiver:

; 743  : 		{
; 744  : 		// Otherwise only set up the override waypoint
; 745  : 		if (MissionData[mis->mission].flags & AMIS_ASSIGNED_TAR)

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	mov	edx, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+28]
	and	edx, 67108864				; 04000000H
	je	SHORT $LN4@BuildDiver

; 746  : 			{
; 747  : 			// Just assign us a target and an override waypoint
; 748  : 			flight->SetAssignedTarget(mis->targetID);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?SetAssignedTarget@FlightClass@@QAEXVVU_ID@@@Z ; FlightClass::SetAssignedTarget

; 749  : 			FinalizeWayPoint(tw,TRUE);

	push	1
	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 750  : 			if (mis->flags & AMIS_HELP_REQUEST)

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN3@BuildDiver

; 751  : 				flight->SetOverrideWP(tw, true);

	push	1
	mov	eax, DWORD PTR _tw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?SetOverrideWP@FlightClass@@QAEXPAVWayPointClass@@_N@Z ; FlightClass::SetOverrideWP

; 752  : 			else

	jmp	SHORT $LN2@BuildDiver
$LN3@BuildDiver:

; 753  : 				flight->SetOverrideWP(tw);

	push	0
	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?SetOverrideWP@FlightClass@@QAEXPAVWayPointClass@@_N@Z ; FlightClass::SetOverrideWP
$LN2@BuildDiver:

; 754  : 			delete tw;

	mov	edx, DWORD PTR _tw$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 755  : 			tw = flight->GetOverrideWP();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetOverrideWP@FlightClass@@QAEPAVWayPointClass@@XZ ; FlightClass::GetOverrideWP
	mov	DWORD PTR _tw$[ebp], eax

; 756  : 			}
; 757  : 		else

	jmp	SHORT $LN1@BuildDiver
$LN4@BuildDiver:

; 758  : 			{
; 759  : 			// Otherwise, insert it into our list
; 760  : 			nw = cw->GetPrevWP();

	mov	ecx, DWORD PTR _cw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _nw$[ebp], eax

; 761  : 			nw->UnlinkNextWP();

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?UnlinkNextWP@WayPointClass@@QAEXXZ	; WayPointClass::UnlinkNextWP

; 762  : 			nw->InsertWP(tw);

	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 763  : 			tw->InsertWP(cw);

	mov	edx, DWORD PTR _cw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 764  : 			tw->SetWPAltitude(MissionData[mis->mission].missionalt);

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	movsx	edx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+12]
	push	edx
	mov	ecx, DWORD PTR _tw$[ebp]
	call	?SetWPAltitude@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAltitude
$LN1@BuildDiver:

; 765  : 			}
; 766  : 		flight->GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 767  : 		SetWPTimes (tw, x, y, flight->GetCombatSpeed(), 0);

	push	0
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCombatSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCombatSpeed
	push	eax
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tw$[ebp]
	push	ecx
	call	?SetWPTimes@@YAKPAVWayPointClass@@FFHH@Z ; SetWPTimes
	add	esp, 20					; 00000014H
$LN9@BuildDiver:

; 768  : 		}
; 769  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildDivertPath@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ENDP ; BuildDivertPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -136						; size = 8
$T3 = -128						; size = 8
$T4 = -120						; size = 8
_sw$ = -112						; size = 4
tv536 = -108						; size = 4
$T5 = -104						; size = 4
$T6 = -100						; size = 4
$T7 = -96						; size = 4
tv322 = -92						; size = 4
$T8 = -88						; size = 4
tv190 = -84						; size = 4
$T9 = -80						; size = 4
tv131 = -76						; size = 4
$T10 = -72						; size = 4
_tmpWP$ = -68						; size = 4
_u$11 = -64						; size = 4
_airbase$ = -60						; size = 4
_exitroute$ = -56					; size = 4
tv235 = -52						; size = 4
_pack$ = -48						; size = 4
_nw$ = -44						; size = 4
_cw$ = -40						; size = 4
_x$12 = -36						; size = 2
_y$13 = -32						; size = 2
_bx$ = -28						; size = 2
_by$ = -24						; size = 2
_ay$ = -20						; size = 2
_ax$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
_mis$ = 12						; size = 4
_airbaseID$ = 16					; size = 8
?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z PROC ; BuildPathToTarget

; 574  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 575  : 	WayPoint		nw,cw,sw;
; 576  : 	GridIndex		bx,by,ax,ay;
; 577  : 	Package			pack;
; 578  : 	int				exitroute = 0;

	mov	DWORD PTR _exitroute$[ebp], 0

; 579  : 	CampEntity		airbase = FindEntity(airbaseID);

	mov	eax, DWORD PTR _airbaseID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _airbaseID$[ebp]
	push	ecx
	call	?FindEntity@@YAPAVCampBaseClass@@VVU_ID@@@Z ; FindEntity
	add	esp, 8
	mov	DWORD PTR _airbase$[ebp], eax

; 580  : 
; 581  : 	WayPoint		tmpWP;
; 582  : 
; 583  : 	if (!airbase)

	cmp	DWORD PTR _airbase$[ebp], 0
	jne	SHORT $LN26@BuildPathT

; 584  : 		return 0;

	xor	eax, eax
	jmp	$LN27@BuildPathT
$LN26@BuildPathT:

; 585  : 
; 586  : 	// Pointer to the package
; 587  : 	pack = (Package)u->GetUnitParent();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+1008]
	call	edx
	mov	DWORD PTR _pack$[ebp], eax

; 588  : 	SetupAltitudes(u, mis);

	mov	eax, DWORD PTR _mis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	?SetupAltitudes@@YAXPAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupAltitudes
	add	esp, 8

; 589  : 
; 590  : 	// Takeoff waypoint (or filler wp for immediate missions
; 591  : 	airbase->GetLocation(&bx,&by);

	lea	edx, DWORD PTR _by$[ebp]
	push	edx
	lea	eax, DWORD PTR _bx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _airbase$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 592  : 	sw = cw = new WayPointClass(bx, by, 0, 0, 0, 0, WP_TAKEOFF, WPF_TAKEOFF);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN29@BuildPathT
	push	128					; 00000080H
	push	1
	push	0
	push	0
	push	0
	push	0
	movzx	ecx, WORD PTR _by$[ebp]
	push	ecx
	movzx	edx, WORD PTR _bx$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN30@BuildPathT
$LN29@BuildPathT:
	mov	DWORD PTR tv131[ebp], 0
$LN30@BuildPathT:
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _cw$[ebp], ecx
	mov	edx, DWORD PTR _cw$[ebp]
	mov	DWORD PTR _sw$[ebp], edx

; 593  : 	u->wp_list = cw;

	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR _cw$[ebp]
	mov	DWORD PTR [eax+244], ecx

; 594  : 	cw->SetWPTarget(airbase->Id());

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _airbase$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 595  : 	FinalizeWayPoint(cw,TRUE);

	push	1
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 596  : 	SetCurrentAltitude();

	call	?SetCurrentAltitude@@YAXXZ		; SetCurrentAltitude

; 597  : 
; 598  : 	if (!(MissionData[mis->mission].flags & AMIS_TARGET_ONLY))

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	shl	edx, 5
	mov	eax, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[edx+28]
	and	eax, 262144				; 00040000H
	jne	$LN19@BuildPathT

; 599  : 		{
; 600  : 		if (mis->mission == AMIS_AIRCAV)

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	cmp	edx, 32					; 00000020H
	jne	$LN24@BuildPathT

; 601  : 			{
; 602  : 			// We've got to pick up our cargo first
; 603  : 			Unit		u = FindUnit(mis->requesterID);

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z	; FindUnit
	add	esp, 8
	mov	DWORD PTR _u$11[ebp], eax

; 604  : 			GridIndex	x,y;
; 605  : 
; 606  : 			if (!u)

	cmp	DWORD PTR _u$11[ebp], 0
	jne	SHORT $LN23@BuildPathT

; 607  : 				return 0;

	xor	eax, eax
	jmp	$LN27@BuildPathT
$LN23@BuildPathT:

; 608  : 			u->GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$13[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$12[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$11[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 609  : 			nw = new WayPointClass(x, y, 0, 0, 0, MissionData[mis->mission].loitertime*CampaignMinutes, WP_PICKUP, WPF_LAND);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN31@BuildPathT
	push	256					; 00000100H
	push	6
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movsx	ecx, WORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+16]
	imul	ecx, 60000				; 0000ea60H
	push	ecx
	push	0
	push	0
	push	0
	movzx	edx, WORD PTR _y$13[ebp]
	push	edx
	movzx	eax, WORD PTR _x$12[ebp]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv190[ebp], eax
	jmp	SHORT $LN32@BuildPathT
$LN31@BuildPathT:
	mov	DWORD PTR tv190[ebp], 0
$LN32@BuildPathT:
	mov	ecx, DWORD PTR tv190[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _nw$[ebp], edx

; 610  : 			nw->SetWPTarget(u->Id());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$11[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 611  : 			FinalizeWayPoint(nw);

	push	0
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 612  : 			cw->InsertWP(nw);

	mov	ecx, DWORD PTR _nw$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 613  : 			cw = nw;

	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR _cw$[ebp], edx
$LN24@BuildPathT:

; 614  : 			// KCK EXPERIMENTAL: Try making taking off part of our 'PICKUP'..
; 615  : //			nw = new WayPointClass(x, y, 0, 0, 0, 0, WP_TAKEOFF, WPF_TAKEOFF);
; 616  : //			FinalizeWayPoint(nw);
; 617  : //			cw->InsertWP(nw);
; 618  : //			cw = nw;
; 619  : 			}
; 620  : 
; 621  : 		// Ingress route
; 622  : 		pack->GetUnitAssemblyPoint(0,&ax,&ay);

	lea	eax, DWORD PTR _ay$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ax$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [eax+812]
	call	edx

; 623  : 		if (!ax || !ay || !pack->GetIngress())

	movsx	eax, WORD PTR _ax$[ebp]
	test	eax, eax
	je	SHORT $LN21@BuildPathT
	movsx	ecx, WORD PTR _ay$[ebp]
	test	ecx, ecx
	je	SHORT $LN21@BuildPathT
	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetIngress@PackageClass@@QAEPAVWayPointClass@@XZ ; PackageClass::GetIngress
	test	eax, eax
	jne	SHORT $LN22@BuildPathT
$LN21@BuildPathT:

; 624  : 			{
; 625  : 			// No assembly point currently- We need to find a path to the target, and determine
; 626  : 			// a good assembly point and break point from it.
; 627  : 			cw = SetupIngressPoints(cw,u,mis);

	mov	edx, DWORD PTR _mis$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?SetupIngressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupIngressPoints
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 628  : 			if (!cw)

	cmp	DWORD PTR _cw$[ebp], 0
	jne	SHORT $LN20@BuildPathT

; 629  : 				return 0;

	xor	eax, eax
	jmp	$LN27@BuildPathT
$LN20@BuildPathT:

; 630  : 			}
; 631  : 		else

	jmp	SHORT $LN19@BuildPathT
$LN22@BuildPathT:

; 632  : 			{
; 633  : 			// Otherwise, find a path to the assembly point, and copy Ingress route
; 634  : 			cw = AddIngressPath(cw,u,mis);

	mov	edx, DWORD PTR _mis$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?AddIngressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddIngressPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax
$LN19@BuildPathT:

; 635  : 			}
; 636  : 		}
; 637  : 
; 638  : 	// Target area waypoints
; 639  : 	switch (MissionData[mis->mission].target_profile)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	movzx	ecx, BYTE PTR ?MissionData@@3PAUMissionDataType@@A[eax+4]
	mov	DWORD PTR tv235[ebp], ecx
	mov	edx, DWORD PTR tv235[ebp]
	sub	edx, 1
	mov	DWORD PTR tv235[ebp], edx
	cmp	DWORD PTR tv235[ebp], 8
	ja	$LN9@BuildPathT
	mov	eax, DWORD PTR tv235[ebp]
	jmp	DWORD PTR $LN39@BuildPathT[eax*4]
$LN16@BuildPathT:

; 640  : 		{
; 641  : 		case TPROF_ATTACK:
; 642  : 			cw = AddAttackProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddAttackProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddAttackProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 643  : 			exitroute = 1;

	mov	DWORD PTR _exitroute$[ebp], 1

; 644  : 			break;

	jmp	$LN17@BuildPathT
$LN15@BuildPathT:

; 645  : 		case TPROF_LOITER:
; 646  : 		case TPROF_SEARCH:
; 647  : 			cw = AddLoiterProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddLoiterProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddLoiterProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 648  : 			break;

	jmp	$LN17@BuildPathT
$LN14@BuildPathT:

; 649  : 		case TPROF_AVOID:
; 650  : 			cw = AddBypassProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddBypassProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddBypassProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 651  : 			break;

	jmp	$LN17@BuildPathT
$LN13@BuildPathT:

; 652  : 		case TPROF_FLYBY:
; 653  : 			cw = AddFlyByProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddFlyByProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddFlyByProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 654  : 			break;

	jmp	SHORT $LN17@BuildPathT
$LN12@BuildPathT:

; 655  : 		case TPROF_SWEEP:
; 656  : 			cw = AddSweepProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddSweepProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddSweepProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 657  : 			break;

	jmp	SHORT $LN17@BuildPathT
$LN11@BuildPathT:

; 658  : 		case TPROF_LAND:
; 659  : 			cw = AddLandProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddLandProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddLandProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 660  : 			break;

	jmp	SHORT $LN17@BuildPathT
$LN10@BuildPathT:

; 661  : 		case TPROF_HPATTACK:
; 662  : 		case TPROF_TARGET:
; 663  : 			cw = AddTargetProfile(cw,u,mis);

	mov	ecx, DWORD PTR _mis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	mov	eax, DWORD PTR _cw$[ebp]
	push	eax
	call	?AddTargetProfile@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddTargetProfile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 664  : 			exitroute = 1;

	mov	DWORD PTR _exitroute$[ebp], 1

; 665  : 			break;

	jmp	SHORT $LN17@BuildPathT
$LN9@BuildPathT:

; 666  : 		case TPROF_NONE:
; 667  : 		default:
; 668  : 			// No target WP
; 669  : 			cw->SetWPTimes(mis->tot);

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?SetWPTimes@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPTimes

; 670  : 			exitroute = 1;

	mov	DWORD PTR _exitroute$[ebp], 1
$LN17@BuildPathT:

; 671  : 			break;
; 672  : 		}
; 673  : 
; 674  : 	if (!(MissionData[mis->mission].flags & AMIS_TARGET_ONLY))

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	mov	edx, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+28]
	and	edx, 262144				; 00040000H
	jne	$LN3@BuildPathT

; 675  : 		{
; 676  : 		// Egress Route
; 677  : 		pack->GetUnitAssemblyPoint(1,&ax,&ay);

	lea	eax, DWORD PTR _ay$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ax$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [eax+812]
	call	edx

; 678  : 		if (!ax || !ay || !pack->GetEgress())

	movsx	eax, WORD PTR _ax$[ebp]
	test	eax, eax
	je	SHORT $LN6@BuildPathT
	movsx	ecx, WORD PTR _ay$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@BuildPathT
	mov	ecx, DWORD PTR _pack$[ebp]
	call	?GetEgress@PackageClass@@QAEPAVWayPointClass@@XZ ; PackageClass::GetEgress
	test	eax, eax
	jne	SHORT $LN7@BuildPathT
$LN6@BuildPathT:

; 679  : 			{
; 680  : 			// No assembly point currently- We need to find a path to the target, and determine
; 681  : 			// a good assembly point and break point from it.
; 682  : 			if (exitroute)

	cmp	DWORD PTR _exitroute$[ebp], 0
	je	SHORT $LN5@BuildPathT

; 683  : 				cw = AddExitRoute (cw,u,mis);

	mov	edx, DWORD PTR _mis$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?AddExitRoute@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddExitRoute
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax
$LN5@BuildPathT:

; 684  : 			cw = SetupEgressPoints(cw,u,mis);

	mov	edx, DWORD PTR _mis$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?SetupEgressPoints@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; SetupEgressPoints
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax

; 685  : 			if (!cw)

	cmp	DWORD PTR _cw$[ebp], 0
	jne	SHORT $LN4@BuildPathT

; 686  : 				return 0;

	xor	eax, eax
	jmp	$LN27@BuildPathT
$LN4@BuildPathT:

; 687  : 			}
; 688  : 		else

	jmp	SHORT $LN3@BuildPathT
$LN7@BuildPathT:

; 689  : 			{
; 690  : 			// Otherwise, find a path to the assembly point, and copy Ingress route
; 691  : 			cw = AddEgressPath(cw,u,mis);

	mov	edx, DWORD PTR _mis$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?AddEgressPath@@YAPAVWayPointClass@@PAV1@PAVFlightClass@@PAVMissionRequestClass@@@Z ; AddEgressPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cw$[ebp], eax
$LN3@BuildPathT:

; 692  : 			}
; 693  : 		}
; 694  : 
; 695  : 	// Route back to base
; 696  : 	nw = new WayPointClass(bx, by, 0, 0, 0, 0, WP_LAND, WPF_LAND | WPF_HOLDCURRENT);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN33@BuildPathT
	push	2304					; 00000900H
	push	7
	push	0
	push	0
	push	0
	push	0
	movzx	edx, WORD PTR _by$[ebp]
	push	edx
	movzx	eax, WORD PTR _bx$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv322[ebp], eax
	jmp	SHORT $LN34@BuildPathT
$LN33@BuildPathT:
	mov	DWORD PTR tv322[ebp], 0
$LN34@BuildPathT:
	mov	ecx, DWORD PTR tv322[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _nw$[ebp], edx

; 697  : 	nw->SetWPTarget(airbase->Id());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _airbase$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _nw$[ebp]
	call	?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ; WayPointClass::SetWPTarget

; 698  : 
; 699  : 	cw->InsertWP(nw);

	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 700  : 	FinalizeWayPoint(nw);

	push	0
	mov	ecx, DWORD PTR _nw$[ebp]
	push	ecx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8

; 701  : 
; 702  : 	// RV - Biker - Additional WP 30nm before home base
; 703  : 	// so long range mission will fly home at high altitude 
; 704  : 	if(cw->DistanceTo(nw) > 40 * NM_TO_KM) {

	mov	edx, DWORD PTR _nw$[ebp]
	push	edx
	mov	ecx, DWORD PTR _cw$[ebp]
	call	?DistanceTo@WayPointClass@@QAEMPAV1@@Z	; WayPointClass::DistanceTo
	fstp	DWORD PTR tv536[ebp]
	movss	xmm0, DWORD PTR tv536[ebp]
	comiss	xmm0, DWORD PTR __real@42942e07
	jbe	SHORT $LN2@BuildPathT

; 705  : 		tmpWP = AddDistanceWaypoint(cw, nw, int(30 * NM_TO_KM));

	push	55					; 00000037H
	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cw$[ebp]
	push	ecx
	call	?AddDistanceWaypoint@@YAPAVWayPointClass@@PAV1@0H@Z ; AddDistanceWaypoint
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpWP$[ebp], eax

; 706  : 		tmpWP->SetWPAction(WP_NOTHING);

	push	0
	mov	ecx, DWORD PTR _tmpWP$[ebp]
	call	?SetWPAction@WayPointClass@@QAEXH@Z	; WayPointClass::SetWPAction

; 707  : 		tmpWP->SetWPFlag(WPF_TURNPOINT);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _tmpWP$[ebp]
	call	?SetWPFlag@WayPointClass@@QAEXK@Z	; WayPointClass::SetWPFlag

; 708  : 		FinalizeWayPoint(tmpWP);

	push	0
	mov	edx, DWORD PTR _tmpWP$[ebp]
	push	edx
	call	?FinalizeWayPoint@@YAXPAVWayPointClass@@H@Z ; FinalizeWayPoint
	add	esp, 8
$LN2@BuildPathT:

; 709  : 	}
; 710  : 
; 711  : 	// Now let's try to eliminated unneeded waypoints for initial flight
; 712  : 	if (!u->GetUnitMissionID())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+688]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@BuildPathT

; 713  : 		EliminateExcessWaypoints (sw,nw,u->GetTeam());

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _nw$[ebp]
	push	edx
	mov	eax, DWORD PTR _sw$[ebp]
	push	eax
	call	?EliminateExcessWaypoints@@YAPAVWayPointClass@@PAV1@0H@Z ; EliminateExcessWaypoints
	add	esp, 12					; 0000000cH
$LN1@BuildPathT:

; 714  : 
; 715  : 	return 1;

	mov	eax, 1
$LN27@BuildPathT:

; 716  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@BuildPathT:
	DD	$LN16@BuildPathT
	DD	$LN10@BuildPathT
	DD	$LN15@BuildPathT
	DD	$LN10@BuildPathT
	DD	$LN14@BuildPathT
	DD	$LN12@BuildPathT
	DD	$LN13@BuildPathT
	DD	$LN15@BuildPathT
	DD	$LN11@BuildPathT
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z$0:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z$1:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z$2:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildPathToTarget@@YAHPAVFlightClass@@PAVMissionRequestClass@@VVU_ID@@@Z ENDP ; BuildPathToTarget
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_bonus$ = -8						; size = 4
_this$ = -4						; size = 4
?RequestEnemyMission@MissionRequestClass@@QAEHXZ PROC	; MissionRequestClass::RequestEnemyMission
; _this$ = ecx

; 133  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 	int		bonus = priority;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	mov	DWORD PTR _bonus$[ebp], ecx

; 135  : 	if (!vs)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN5@RequestEne

; 136  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN6@RequestEne
$LN5@RequestEne:

; 137  : 	for (who=1; who<NUM_TEAMS; who++)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], 1
	jmp	SHORT $LN4@RequestEne
$LN3@RequestEne:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+32]
	add	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], al
$LN4@RequestEne:
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	cmp	eax, 8
	jge	SHORT $LN2@RequestEne

; 138  : 		{
; 139  : 		if (TeamInfo[who])

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4], 0
	je	SHORT $LN1@RequestEne

; 140  : 			{
; 141  : 			priority = bonus;		// Reset to bonus priority;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _bonus$[ebp]
	mov	WORD PTR [eax+56], cx

; 142  : 			RequestMission();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestMission@MissionRequestClass@@QAEHXZ ; MissionRequestClass::RequestMission
$LN1@RequestEne:

; 143  : 			}
; 144  : 		}

	jmp	SHORT $LN3@RequestEne
$LN2@RequestEne:

; 145  : 	return 0;

	xor	eax, eax
$LN6@RequestEne:

; 146  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?RequestEnemyMission@MissionRequestClass@@QAEHXZ ENDP	; MissionRequestClass::RequestEnemyMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
$T2 = -64						; size = 8
$T3 = -56						; size = 8
_target$4 = -48						; size = 4
tv212 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
tv185 = -32						; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 4
_message$9 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?RequestMission@MissionRequestClass@@QAEHXZ PROC	; MissionRequestClass::RequestMission
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestMission@MissionRequestClass@@QAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 	if (!mission || priority < 0 || (vs && !GetRoE(who,vs,roe_check)))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	je	SHORT $LN4@RequestMis
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+56]
	test	eax, eax
	jl	SHORT $LN4@RequestMis
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN5@RequestMis
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+63]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+33]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	push	edx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@RequestMis
$LN4@RequestMis:

; 112  : 		return -1;

	or	eax, -1
	jmp	$LN6@RequestMis
$LN5@RequestMis:

; 113  : 	if ((TeamInfo[who]) && (TeamInfo[who]->atm) && (TeamInfo[who]->flags & TEAM_ACTIVE))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	$LN3@RequestMis
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	cmp	DWORD PTR [ecx+876], 0
	je	$LN3@RequestMis
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movsx	edx, WORD PTR [ecx+350]
	and	edx, 1
	je	$LN3@RequestMis

; 114  : 		{
; 115  : 		VuTargetEntity				*target = (VuTargetEntity*) vuDatabase->Find(TeamInfo[who]->atm->OwnerId());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR [eax+876]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$4[ebp], eax

; 116  : 		FalconMissionRequestMessage	*message = 
; 117  : 			new FalconMissionRequestMessage(TeamInfo[who]->atm->Id(), vuLocalSessionEntity.get());

	push	126					; 0000007eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN8@RequestMis
	push	1
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR [eax+876]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconMissionRequestMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconMissionRequestMessage::FalconMissionRequestMessage
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN9@RequestMis
$LN8@RequestMis:
	mov	DWORD PTR tv185[ebp], 0
$LN9@RequestMis:
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _message$9[ebp], ecx

; 118  : 		GetPriority(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?GetPriority@@YAHPAVMissionRequestClass@@@Z ; GetPriority
	add	esp, 4

; 119  : 		message->dataBlock.request = *this;

	mov	edi, DWORD PTR _message$9[ebp]
	add	edi, 50					; 00000032H
	mov	ecx, 19					; 00000013H
	mov	esi, DWORD PTR _this$[ebp]
	rep movsd

; 120  : 		message->dataBlock.team = who;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	cx, BYTE PTR [eax+32]
	mov	edx, DWORD PTR _message$9[ebp]
	mov	WORD PTR [edx+48], cx

; 121  : 		if (priority > 0)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	test	ecx, ecx
	jle	SHORT $LN2@RequestMis

; 122  : 			{
; 123  : 			FalconSendMessage(message,FALSE);			// KCK NOTE: Go ahead and let a few messages miss their target

	push	0
	mov	edx, DWORD PTR _message$9[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 124  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN6@RequestMis

; 125  : 			}
; 126  : 		else 

	jmp	SHORT $LN3@RequestMis
$LN2@RequestMis:

; 127  : 		    delete message; // JPO mem leak

	mov	eax, DWORD PTR _message$9[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN10@RequestMis
	push	1
	mov	edx, DWORD PTR $T8[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv212[ebp], eax
	jmp	SHORT $LN3@RequestMis
$LN10@RequestMis:
	mov	DWORD PTR tv212[ebp], 0
$LN3@RequestMis:

; 128  : 		}
; 129  : 	return -1;

	or	eax, -1
$LN6@RequestMis:

; 130  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestMission@MissionRequestClass@@QAEHXZ$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RequestMission@MissionRequestClass@@QAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestMission@MissionRequestClass@@QAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestMission@MissionRequestClass@@QAEHXZ ENDP	; MissionRequestClass::RequestMission
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MissionRequestClass@@QAE@XZ PROC			; MissionRequestClass::~MissionRequestClass
; _this$ = ecx

; 105  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 	// Nothing to do here.
; 107  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1MissionRequestClass@@QAE@XZ ENDP			; MissionRequestClass::~MissionRequestClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camptask\mission.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MissionRequestClass@@QAE@XZ PROC			; MissionRequestClass::MissionRequestClass
; _this$ = ecx

; 79   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 80   : 	targetID = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+12], edx

; 81   : 	requesterID = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx

; 82   : 	who = vs = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+33], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], 0

; 83   : 	tot = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 84   : 	tx = ty = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+42], ax
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+40], dx

; 85   : 	flags = caps = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+48], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 86   : 	target_num = 255;

	mov	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+50], cx

; 87   : 	tot_type = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+58], 0

; 88   : 	mission = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+60], 0

; 89   : 	priority = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+56], dx

; 90   : 	speed = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+52], cx

; 91   : 	match_strength = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+54], ax

; 92   : 	aircraft = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+61], 0

; 93   : 	context = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+62], 0

; 94   : 	roe_check = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+63], 0

; 95   : 	delayed = 0;	

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+64], 0

; 96   : 	start_block = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+65], 0

; 97   : 	final_block = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+66], 0

; 98   : 	action_type = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+59], 0

; 99   : 	memset(slots,255,4);

	push	4
	push	255					; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 67					; 00000043H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 100  : 	min_to = -127;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+71], -127			; ffffff81H

; 101  : 	max_to = 127;	

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+72], 127			; 0000007fH

; 102  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0MissionRequestClass@@QAE@XZ ENDP			; MissionRequestClass::MissionRequestClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPLocation@WayPointClass@@QBEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetWPLocation@WayPointClass@@QBEXPAF0@Z PROC		; WayPointClass::GetWPLocation, COMDAT
; _this$ = ecx

; 205  : 	void GetWPLocation (GridIndex* x, GridIndex* y) const { *x = GridX; *y = GridY; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetWPLocation@WayPointClass@@QBEXPAF0@Z ENDP		; WayPointClass::GetWPLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPArrivalTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPArrivalTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPArrivalTime, COMDAT
; _this$ = ecx

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPArrivalTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPArrivalTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPStationTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPStationTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPStationTime, COMDAT
; _this$ = ecx

; 201  : 	CampaignTime GetWPStationTime()					{ return (int)(Depart-Arrive); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPStationTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPStationTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAltitude@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAltitude@WayPointClass@@QAEHXZ PROC		; WayPointClass::GetWPAltitude, COMDAT
; _this$ = ecx

; 199  : 	int GetWPAltitude()								{ return (int)(GridZ*GRIDZ_SCALE_FACTOR); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+4]
	imul	eax, 10					; 0000000aH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAltitude@WayPointClass@@QAEHXZ ENDP		; WayPointClass::GetWPAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPSpeed@WayPointClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPSpeed@WayPointClass@@QAEMXZ PROC			; WayPointClass::GetWPSpeed, COMDAT
; _this$ = ecx

; 197  : 	float GetWPSpeed (void)							{ return Speed; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPSpeed@WayPointClass@@QAEMXZ ENDP			; WayPointClass::GetWPSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPSpeed@WayPointClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?SetWPSpeed@WayPointClass@@QAEXM@Z PROC			; WayPointClass::SetWPSpeed, COMDAT
; _this$ = ecx

; 196  : 	void SetWPSpeed (float s)						{ Speed = s; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [eax+36], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPSpeed@WayPointClass@@QAEXM@Z ENDP			; WayPointClass::SetWPSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPArrive@WayPointClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetWPArrive@WayPointClass@@QAEXK@Z PROC		; WayPointClass::SetWPArrive, COMDAT
; _this$ = ecx

; 195  : 	void SetWPArrive (CampaignTime t)				{ Arrive = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPArrive@WayPointClass@@QAEXK@Z ENDP		; WayPointClass::SetWPArrive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPDepartTime@WayPointClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetWPDepartTime@WayPointClass@@QAEXK@Z PROC		; WayPointClass::SetWPDepartTime, COMDAT
; _this$ = ecx

; 194  : 	void SetWPDepartTime (CampaignTime t)			{ Depart = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPDepartTime@WayPointClass@@QAEXK@Z ENDP		; WayPointClass::SetWPDepartTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPRouteAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPRouteAction@WayPointClass@@QAEHXZ PROC		; WayPointClass::GetWPRouteAction, COMDAT
; _this$ = ecx

; 171  : 	int GetWPRouteAction(void)						{ return (int)RouteAction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+25]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPRouteAction@WayPointClass@@QAEHXZ ENDP		; WayPointClass::GetWPRouteAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?UnSetWPFlag@WayPointClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?UnSetWPFlag@WayPointClass@@QAEXK@Z PROC		; WayPointClass::UnSetWPFlag, COMDAT
; _this$ = ecx

; 165  : 	void UnSetWPFlag (ulong f)						{ Flags &= ~((ulong)(f)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _f$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?UnSetWPFlag@WayPointClass@@QAEXK@Z ENDP		; WayPointClass::UnSetWPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPFlag@WayPointClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?SetWPFlag@WayPointClass@@QAEXK@Z PROC			; WayPointClass::SetWPFlag, COMDAT
; _this$ = ecx

; 164  : 	void SetWPFlag (ulong f)						{ Flags |= (ulong) f; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPFlag@WayPointClass@@QAEXK@Z ENDP			; WayPointClass::SetWPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPFlags@WayPointClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?SetWPFlags@WayPointClass@@QAEXK@Z PROC			; WayPointClass::SetWPFlags, COMDAT
; _this$ = ecx

; 163  : 	void SetWPFlags (ulong f)						{ Flags = (ulong) f; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPFlags@WayPointClass@@QAEXK@Z ENDP			; WayPointClass::SetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPRouteAction@WayPointClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 4
?SetWPRouteAction@WayPointClass@@QAEXH@Z PROC		; WayPointClass::SetWPRouteAction, COMDAT
; _this$ = ecx

; 161  : 	void SetWPRouteAction (int a)					{ RouteAction = (uchar) a; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _a$[ebp]
	mov	BYTE PTR [eax+25], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPRouteAction@WayPointClass@@QAEXH@Z ENDP		; WayPointClass::SetWPRouteAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPAction@WayPointClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 4
?SetWPAction@WayPointClass@@QAEXH@Z PROC		; WayPointClass::SetWPAction, COMDAT
; _this$ = ecx

; 160  : 	void SetWPAction (int a)						{ Action = (uchar) a; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _a$[ebp]
	mov	BYTE PTR [eax+24], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPAction@WayPointClass@@QAEXH@Z ENDP		; WayPointClass::SetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPTargetBuilding@WayPointClass@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 1
?SetWPTargetBuilding@WayPointClass@@QAEXE@Z PROC	; WayPointClass::SetWPTargetBuilding, COMDAT
; _this$ = ecx

; 159  : 	void SetWPTargetBuilding (uchar t)				{ TargetBuilding = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+27], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPTargetBuilding@WayPointClass@@QAEXE@Z ENDP	; WayPointClass::SetWPTargetBuilding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 8
?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z PROC		; WayPointClass::SetWPTarget, COMDAT
; _this$ = ecx

; 158  : 	void SetWPTarget (VU_ID e)						{ TargetID = e; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _e$[ebp+4]
	mov	DWORD PTR [eax+20], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetWPTarget@WayPointClass@@QAEXVVU_ID@@@Z ENDP		; WayPointClass::SetWPTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::OwnerId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID OwnerId() const     { return share_.ownerId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::OwnerId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
END
