; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPLIB\Listadt.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	??0ListElementClass@@AAE@FPAXE@Z		; ListElementClass::ListElementClass
PUBLIC	??1ListElementClass@@AAE@XZ			; ListElementClass::~ListElementClass
PUBLIC	?SetUserData@ListElementClass@@QAEXPAX@Z	; ListElementClass::SetUserData
PUBLIC	??_GListElementClass@@AAEPAXI@Z			; ListElementClass::`scalar deleting destructor'
PUBLIC	??0ListClass@@QAE@E@Z				; ListClass::ListClass
PUBLIC	??1ListClass@@QAE@XZ				; ListClass::~ListClass
PUBLIC	?Insert@ListClass@@QAEXPAVListElementClass@@@Z	; ListClass::Insert
PUBLIC	?InsertAtEnd@ListClass@@QAEXPAVListElementClass@@@Z ; ListClass::InsertAtEnd
PUBLIC	?Remove@ListClass@@QAEXPAVListElementClass@@@Z	; ListClass::Remove
PUBLIC	?Detach@ListClass@@QAEXPAVListElementClass@@@Z	; ListClass::Detach
PUBLIC	?InsertNewElement@ListClass@@QAEXFPAXE@Z	; ListClass::InsertNewElement
PUBLIC	?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z	; ListClass::InsertNewElementAtEnd
PUBLIC	?Purge@ListClass@@QAEXXZ			; ListClass::Purge
PUBLIC	?SanityCheck@ListClass@@QAEHXZ			; ListClass::SanityCheck
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
xdata$x	SEGMENT
__unwindtable$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z$0
__unwindtable$?InsertNewElement@ListClass@@QAEXFPAXE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InsertNewElement@ListClass@@QAEXFPAXE@Z$0
__ehfuncinfo$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?InsertNewElement@ListClass@@QAEXFPAXE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InsertNewElement@ListClass@@QAEXFPAXE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_next$ = -12						; size = 4
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
?SanityCheck@ListClass@@QAEHXZ PROC			; ListClass::SanityCheck
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	ListElementClass *cur,*next;
; 184  : 
; 185  : 	if (!front && !end)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN16@SanityChec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN16@SanityChec

; 186  : 		return 1;

	mov	eax, 1
	jmp	$LN17@SanityChec
$LN16@SanityChec:

; 187  : 	if (front == end && (front->prev || front->next))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN15@SanityChec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN14@SanityChec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN15@SanityChec
$LN14@SanityChec:

; 188  : 		return 0;

	xor	eax, eax
	jmp	$LN17@SanityChec
$LN15@SanityChec:

; 189  : 	if ((front && !end) || (!front && end))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@SanityChec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN12@SanityChec
$LN11@SanityChec:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN13@SanityChec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN13@SanityChec
$LN12@SanityChec:

; 190  : 		return 0;

	xor	eax, eax
	jmp	$LN17@SanityChec
$LN13@SanityChec:

; 191  : 	if (front == (void*)0xdddddddd || front == (void*)0xfcfcfcfc)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], -572662307		; ddddddddH
	je	SHORT $LN9@SanityChec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], -50529028		; fcfcfcfcH
	jne	SHORT $LN10@SanityChec
$LN9@SanityChec:

; 192  : 		return 0;

	xor	eax, eax
	jmp	$LN17@SanityChec
$LN10@SanityChec:

; 193  : 	if (end == (void*)0xdddddddd || end == (void*)0xfcfcfcfc)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], -572662307		; ddddddddH
	je	SHORT $LN7@SanityChec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], -50529028		; fcfcfcfcH
	jne	SHORT $LN8@SanityChec
$LN7@SanityChec:

; 194  : 		return 0;

	xor	eax, eax
	jmp	$LN17@SanityChec
$LN8@SanityChec:

; 195  : 	cur = front;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cur$[ebp], eax

; 196  : 	next = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _next$[ebp], edx
$LN6@SanityChec:

; 197  : 	while (cur && next)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN5@SanityChec
	cmp	DWORD PTR _next$[ebp], 0
	je	SHORT $LN5@SanityChec

; 198  : 		{
; 199  : 		if (next->prev != cur)

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _cur$[ebp]
	je	SHORT $LN4@SanityChec

; 200  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN17@SanityChec
$LN4@SanityChec:

; 201  : 		cur = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 202  : 		next = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _next$[ebp], ecx

; 203  : 		}

	jmp	SHORT $LN6@SanityChec
$LN5@SanityChec:

; 204  : 	cur = end;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 205  : 	next = cur->prev;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _next$[ebp], edx
$LN3@SanityChec:

; 206  : 	while (cur && next)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@SanityChec
	cmp	DWORD PTR _next$[ebp], 0
	je	SHORT $LN2@SanityChec

; 207  : 		{
; 208  : 		if (next->next != cur)

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _cur$[ebp]
	je	SHORT $LN1@SanityChec

; 209  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN17@SanityChec
$LN1@SanityChec:

; 210  : 		cur = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 211  : 		next = cur->prev;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _next$[ebp], ecx

; 212  : 		}

	jmp	SHORT $LN3@SanityChec
$LN2@SanityChec:

; 213  : 	return 1;

	mov	eax, 1
$LN17@SanityChec:

; 214  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SanityCheck@ListClass@@QAEHXZ ENDP			; ListClass::SanityCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
tv72 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_current$ = -8						; size = 4
_this$ = -4						; size = 4
?Purge@ListClass@@QAEXXZ PROC				; ListClass::Purge
; _this$ = ecx

; 167  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 	ListNode current = front;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _current$[ebp], ecx
$LN2@Purge:

; 169  : 
; 170  : 	ShiAssert (SanityCheck());
; 171  : 
; 172  : 	while (current)

	cmp	DWORD PTR _current$[ebp], 0
	je	SHORT $LN1@Purge

; 173  : 		{
; 174  : 		front = current->next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+4], ecx

; 175  : 		delete current;

	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@Purge
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GListElementClass@@AAEPAXI@Z
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN6@Purge
$LN5@Purge:
	mov	DWORD PTR tv72[ebp], 0
$LN6@Purge:

; 176  : 		current = front;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _current$[ebp], edx

; 177  : 		}

	jmp	SHORT $LN2@Purge
$LN1@Purge:

; 178  : 	front = end = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 179  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@ListClass@@QAEXXZ ENDP				; ListClass::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -32						; size = 4
_newNode$ = -28						; size = 4
$T2 = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newKey$ = 8						; size = 2
_newData$ = 12						; size = 4
_newFlags$ = 16						; size = 1
?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z PROC	; ListClass::InsertNewElementAtEnd
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	ListNode newNode = new ListElementClass(newKey, newData, newFlags);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@InsertNewE
	movzx	eax, BYTE PTR _newFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	movzx	edx, WORD PTR _newKey$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0ListElementClass@@AAE@FPAXE@Z	; ListElementClass::ListElementClass
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@InsertNewE
$LN3@InsertNewE:
	mov	DWORD PTR tv74[ebp], 0
$LN4@InsertNewE:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newNode$[ebp], ecx

; 162  : 
; 163  : 	InsertAtEnd(newNode);

	mov	edx, DWORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAtEnd@ListClass@@QAEXPAVListElementClass@@@Z ; ListClass::InsertAtEnd

; 164  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InsertNewElementAtEnd@ListClass@@QAEXFPAXE@Z ENDP	; ListClass::InsertNewElementAtEnd
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -32						; size = 4
_newNode$ = -28						; size = 4
$T2 = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newKey$ = 8						; size = 2
_newData$ = 12						; size = 4
_newFlags$ = 16						; size = 1
?InsertNewElement@ListClass@@QAEXFPAXE@Z PROC		; ListClass::InsertNewElement
; _this$ = ecx

; 153  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InsertNewElement@ListClass@@QAEXFPAXE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	ListNode newNode = new ListElementClass(newKey, newData, newFlags);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@InsertNewE
	movzx	eax, BYTE PTR _newFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	movzx	edx, WORD PTR _newKey$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0ListElementClass@@AAE@FPAXE@Z	; ListElementClass::ListElementClass
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@InsertNewE
$LN3@InsertNewE:
	mov	DWORD PTR tv74[ebp], 0
$LN4@InsertNewE:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newNode$[ebp], ecx

; 155  : 
; 156  : 	Insert(newNode);

	mov	edx, DWORD PTR _newNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@ListClass@@QAEXPAVListElementClass@@@Z ; ListClass::Insert

; 157  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InsertNewElement@ListClass@@QAEXFPAXE@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InsertNewElement@ListClass@@QAEXFPAXE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InsertNewElement@ListClass@@QAEXFPAXE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InsertNewElement@ListClass@@QAEXFPAXE@Z ENDP		; ListClass::InsertNewElement
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_oldElement$ = 8					; size = 4
?Detach@ListClass@@QAEXPAVListElementClass@@@Z PROC	; ListClass::Detach
; _this$ = ecx

; 135  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 	if (!oldElement)

	cmp	DWORD PTR _oldElement$[ebp], 0
	jne	SHORT $LN5@Detach

; 137  : 		return;

	jmp	SHORT $LN6@Detach
$LN5@Detach:

; 138  : 
; 139  : 	if (front == oldElement)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _oldElement$[ebp]
	jne	SHORT $LN4@Detach

; 140  : 		front = oldElement->next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _oldElement$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+4], ecx
$LN4@Detach:

; 141  : 	if (end == oldElement)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _oldElement$[ebp]
	jne	SHORT $LN3@Detach

; 142  : 		end = oldElement->prev;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _oldElement$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
$LN3@Detach:

; 143  : 	if (oldElement->prev)

	mov	ecx, DWORD PTR _oldElement$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN2@Detach

; 144  : 		oldElement->prev->next = oldElement->next;

	mov	edx, DWORD PTR _oldElement$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _oldElement$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
$LN2@Detach:

; 145  : 	if (oldElement->next)

	mov	eax, DWORD PTR _oldElement$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Detach

; 146  : 		oldElement->next->prev = oldElement->prev;

	mov	ecx, DWORD PTR _oldElement$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _oldElement$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
$LN1@Detach:

; 147  : 	ShiAssert (SanityCheck());
; 148  : 	oldElement->prev = NULL;

	mov	edx, DWORD PTR _oldElement$[ebp]
	mov	DWORD PTR [edx+8], 0

; 149  : 	oldElement->next = NULL;

	mov	eax, DWORD PTR _oldElement$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN6@Detach:

; 150  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Detach@ListClass@@QAEXPAVListElementClass@@@Z ENDP	; ListClass::Detach
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
tv71 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
_oldElement$ = 8					; size = 4
?Remove@ListClass@@QAEXPAVListElementClass@@@Z PROC	; ListClass::Remove
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 	if (!oldElement)

	cmp	DWORD PTR _oldElement$[ebp], 0
	jne	SHORT $LN1@Remove

; 128  : 		return;

	jmp	SHORT $LN2@Remove
$LN1@Remove:

; 129  : 	Detach(oldElement);

	mov	eax, DWORD PTR _oldElement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Detach@ListClass@@QAEXPAVListElementClass@@@Z ; ListClass::Detach

; 130  : 	delete oldElement;

	mov	ecx, DWORD PTR _oldElement$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@Remove
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GListElementClass@@AAEPAXI@Z
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN2@Remove
$LN4@Remove:
	mov	DWORD PTR tv71[ebp], 0
$LN2@Remove:

; 131  : 	ShiAssert (SanityCheck());
; 132  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@ListClass@@QAEXPAVListElementClass@@@Z ENDP	; ListClass::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?InsertAtEnd@ListClass@@QAEXPAVListElementClass@@@Z PROC ; ListClass::InsertAtEnd
; _this$ = ecx

; 106  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 	if (!newElement)

	cmp	DWORD PTR _newElement$[ebp], 0
	jne	SHORT $LN4@InsertAtEn

; 108  : 		return;

	jmp	SHORT $LN5@InsertAtEn
$LN4@InsertAtEn:

; 109  : 
; 110  : 	if (flags & LADT_SORTED_LIST)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 1
	je	SHORT $LN3@InsertAtEn

; 111  : 		{
; 112  : 		Insert(newElement);

	mov	edx, DWORD PTR _newElement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@ListClass@@QAEXPAVListElementClass@@@Z ; ListClass::Insert

; 113  : 		return;

	jmp	SHORT $LN5@InsertAtEn
$LN3@InsertAtEn:

; 114  : 		}
; 115  : 
; 116  : 	newElement->prev = end;

	mov	eax, DWORD PTR _newElement$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 117  : 	if (end)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@InsertAtEn

; 118  : 		end->next = newElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN2@InsertAtEn:

; 119  : 	end = newElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 120  : 	if (!front)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@InsertAtEn

; 121  : 		front = newElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN5@InsertAtEn:

; 122  : 	ShiAssert (SanityCheck());
; 123  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?InsertAtEnd@ListClass@@QAEXPAVListElementClass@@@Z ENDP ; ListClass::InsertAtEnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
tv72 = -12						; size = 4
_current$1 = -8						; size = 4
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?Insert@ListClass@@QAEXPAVListElementClass@@@Z PROC	; ListClass::Insert
; _this$ = ecx

; 48   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	if (!newElement)

	cmp	DWORD PTR _newElement$[ebp], 0
	jne	SHORT $LN12@Insert

; 50   : 		return;

	jmp	$LN13@Insert
$LN12@Insert:

; 51   : 
; 52   : 	if (!front)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@Insert

; 53   : 		{
; 54   : 		ShiAssert (!end);
; 55   : 		front = newElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 56   : 		end = newElement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 57   : 		ShiAssert (SanityCheck());
; 58   : 		return;

	jmp	$LN13@Insert
$LN11@Insert:

; 59   : 		}
; 60   : 
; 61   : 	if (!flags & LADT_SORTED_LIST)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN15@Insert
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN16@Insert
$LN15@Insert:
	mov	DWORD PTR tv72[ebp], 0
$LN16@Insert:
	mov	ecx, DWORD PTR tv72[ebp]
	and	ecx, 1
	je	SHORT $LN10@Insert

; 62   : 		{
; 63   : 		newElement->next = front;

	mov	edx, DWORD PTR _newElement$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+12], ecx

; 64   : 		front->prev = newElement;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 65   : 		front = newElement;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [edx+4], eax

; 66   : 		ShiAssert (SanityCheck());
; 67   : 		return;

	jmp	$LN13@Insert

; 68   : 		}
; 69   : 	else

	jmp	$LN13@Insert
$LN10@Insert:

; 70   : 		{
; 71   : 		// Check for end of list
; 72   : 		if (end->key <= newElement->key)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _newElement$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	cmp	eax, edx
	jg	SHORT $LN8@Insert

; 73   : 			{
; 74   : 			// Inserting at the end
; 75   : 			newElement->prev = end;

	mov	eax, DWORD PTR _newElement$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 76   : 			if (end)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN7@Insert

; 77   : 				end->next = newElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN7@Insert:

; 78   : 			end = newElement;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	$LN13@Insert
$LN8@Insert:

; 79   : 			}
; 80   : 		// Check for front of list
; 81   : 		else if (front->key >= newElement->key)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _newElement$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	edx, ecx
	jl	SHORT $LN5@Insert

; 82   : 			{
; 83   : 			newElement->next = front;

	mov	edx, DWORD PTR _newElement$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+12], ecx

; 84   : 			newElement->prev = NULL;

	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [edx+8], 0

; 85   : 			front->prev = newElement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 86   : 			front = newElement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 87   : 			}
; 88   : 		// Insert somewhere in the middle
; 89   : 		else

	jmp	SHORT $LN13@Insert
$LN5@Insert:

; 90   : 			{
; 91   : 			ListNode	current = front;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _current$1[ebp], eax
$LN3@Insert:

; 92   : 			while (current && current->key < newElement->key)

	cmp	DWORD PTR _current$1[ebp], 0
	je	SHORT $LN2@Insert
	mov	ecx, DWORD PTR _current$1[ebp]
	movsx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _newElement$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	edx, ecx
	jge	SHORT $LN2@Insert

; 93   : 				current = current->next;

	mov	edx, DWORD PTR _current$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _current$1[ebp], eax
	jmp	SHORT $LN3@Insert
$LN2@Insert:

; 94   : 			ShiAssert (current != front);
; 95   : 			newElement->prev = current->prev;

	mov	ecx, DWORD PTR _newElement$[ebp]
	mov	edx, DWORD PTR _current$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 96   : 			newElement->next = current;

	mov	ecx, DWORD PTR _newElement$[ebp]
	mov	edx, DWORD PTR _current$1[ebp]
	mov	DWORD PTR [ecx+12], edx

; 97   : 			if (current->prev)

	mov	eax, DWORD PTR _current$1[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@Insert

; 98   : 				current->prev->next = newElement;

	mov	ecx, DWORD PTR _current$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN1@Insert:

; 99   : 			current->prev = newElement;

	mov	ecx, DWORD PTR _current$1[ebp]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN13@Insert:

; 100  : 			}
; 101  : 		}
; 102  : 	ShiAssert (SanityCheck());
; 103  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@ListClass@@QAEXPAVListElementClass@@@Z ENDP	; ListClass::Insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ListClass@@QAE@XZ PROC				; ListClass::~ListClass
; _this$ = ecx

; 43   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@ListClass@@QAEXXZ		; ListClass::Purge

; 45   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1ListClass@@QAE@XZ ENDP				; ListClass::~ListClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlags$ = 8						; size = 1
??0ListClass@@QAE@E@Z PROC				; ListClass::ListClass
; _this$ = ecx

; 37   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	flags = newFlags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _newFlags$[ebp]
	mov	BYTE PTR [eax], cl

; 39   : 	front = end = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 40   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ListClass@@QAE@E@Z ENDP				; ListClass::ListClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GListElementClass@@AAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GListElementClass@@AAEPAXI@Z PROC			; ListElementClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ListElementClass@@AAE@XZ		; ListElementClass::~ListElementClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GListElementClass@@AAEPAXI@Z ENDP			; ListElementClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_newData$ = 8						; size = 4
?SetUserData@ListElementClass@@QAEXPAX@Z PROC		; ListElementClass::SetUserData
; _this$ = ecx

; 30   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 	if (user_data && (flags & LADT_FREE_USER_DATA))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@SetUserDat
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+6]
	and	edx, 2
	je	SHORT $LN1@SetUserDat

; 32   : 		delete user_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@SetUserDat:

; 33   : 	user_data = newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax], ecx

; 34   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUserData@ListElementClass@@QAEXPAX@Z ENDP		; ListElementClass::SetUserData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1ListElementClass@@AAE@XZ PROC			; ListElementClass::~ListElementClass
; _this$ = ecx

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	if (flags & LADT_FREE_USER_DATA)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	and	ecx, 2
	je	SHORT $LN2@ListElemen

; 26   : 		delete user_data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@ListElemen:

; 27   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1ListElementClass@@AAE@XZ ENDP			; ListElementClass::~ListElementClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\listadt.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newKey$ = 8						; size = 2
_newData$ = 12						; size = 4
_newFlags$ = 16						; size = 1
??0ListElementClass@@AAE@FPAXE@Z PROC			; ListElementClass::ListElementClass
; _this$ = ecx

; 16   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 17   : 	key = newKey;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _newKey$[ebp]
	mov	WORD PTR [eax+4], cx

; 18   : 	user_data = newData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [edx], eax

; 19   : 	flags = newFlags;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _newFlags$[ebp]
	mov	BYTE PTR [ecx+6], dl

; 20   : 	prev = next = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 21   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0ListElementClass@@AAE@FPAXE@Z ENDP			; ListElementClass::ListElementClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
