; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPLIB\Unit.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?CollectRad@@3PAHA				; CollectRad
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?LoadingUnits@@3HA				; LoadingUnits
PUBLIC	?save_log@@3PAU_iobuf@@A			; save_log
PUBLIC	?load_log@@3PAU_iobuf@@A			; load_log
PUBLIC	?start_save_stream@@3HA				; start_save_stream
PUBLIC	?start_load_stream@@3HA				; start_load_stream
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
_BSS	SEGMENT
?LoadingUnits@@3HA DD 01H DUP (?)			; LoadingUnits
?save_log@@3PAU_iobuf@@A DD 01H DUP (?)			; save_log
?load_log@@3PAU_iobuf@@A DD 01H DUP (?)			; load_log
?start_save_stream@@3HA DD 01H DUP (?)			; start_save_stream
?start_load_stream@@3HA DD 01H DUP (?)			; start_load_stream
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
_DATA	SEGMENT
?CollectRad@@3PAHA DD 00H				; CollectRad
	DD	014H
	DD	028H
	DD	028H
	DD	050H
	DD	096H
	DD	064H
	ORG $+4
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_DATA	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	__tcsnccpy
PUBLIC	??0VU_SESSION_ID@@QAE@XZ			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??BVU_SESSION_ID@@QBEKXZ			; VU_SESSION_ID::operator unsigned long
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??9VU_ID@@QBE_NABV0@@Z				; VU_ID::operator!=
PUBLIC	??BVU_ID@@QBEKXZ				; VU_ID::operator unsigned long
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ; VuEntity::SetSendCreate
PUBLIC	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::OwnerId
PUBLIC	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ		; VuEntity::VuState
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ	; VuBin<VuEntity>::get
PUBLIC	?IsSimBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsSimBase
PUBLIC	?IsCampaign@FalconEntity@@QAEHXZ		; FalconEntity::IsCampaign
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?GetRadarMode@FalconEntity@@UAEHXZ		; FalconEntity::GetRadarMode
PUBLIC	?SetRadarMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetRadarMode
PUBLIC	?ReturnToSearch@FalconEntity@@UAEXXZ		; FalconEntity::ReturnToSearch
PUBLIC	?SetSearchMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetSearchMode
PUBLIC	?CombatClass@FalconEntity@@UAEHXZ		; FalconEntity::CombatClass
PUBLIC	?IsMissile@FalconEntity@@UAEHXZ			; FalconEntity::IsMissile
PUBLIC	?IsLauncher@FalconEntity@@UAEHXZ		; FalconEntity::IsLauncher
PUBLIC	?IsBomb@FalconEntity@@UAEHXZ			; FalconEntity::IsBomb
PUBLIC	?IsGun@FalconEntity@@UAEHXZ			; FalconEntity::IsGun
PUBLIC	?IsMover@FalconEntity@@UAEHXZ			; FalconEntity::IsMover
PUBLIC	?IsVehicle@FalconEntity@@UAEHXZ			; FalconEntity::IsVehicle
PUBLIC	?IsStatic@FalconEntity@@UAEHXZ			; FalconEntity::IsStatic
PUBLIC	?IsHelicopter@FalconEntity@@UAEHXZ		; FalconEntity::IsHelicopter
PUBLIC	?IsEject@FalconEntity@@UAEHXZ			; FalconEntity::IsEject
PUBLIC	?IsAirplane@FalconEntity@@UAEHXZ		; FalconEntity::IsAirplane
PUBLIC	?IsGroundVehicle@FalconEntity@@UAEHXZ		; FalconEntity::IsGroundVehicle
PUBLIC	?IsShip@FalconEntity@@UAEHXZ			; FalconEntity::IsShip
PUBLIC	?IsWeapon@FalconEntity@@UAEHXZ			; FalconEntity::IsWeapon
PUBLIC	?IsExploding@FalconEntity@@UAEHXZ		; FalconEntity::IsExploding
PUBLIC	?IsDead@FalconEntity@@UAEHXZ			; FalconEntity::IsDead
PUBLIC	?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ ; FalconEntity::GetMovementType
PUBLIC	?IsObjective@FalconEntity@@UAEHXZ		; FalconEntity::IsObjective
PUBLIC	?IsBattalion@FalconEntity@@UAEHXZ		; FalconEntity::IsBattalion
PUBLIC	?IsBrigade@FalconEntity@@UAEHXZ			; FalconEntity::IsBrigade
PUBLIC	?IsFlight@FalconEntity@@UBEHXZ			; FalconEntity::IsFlight
PUBLIC	?IsSquadron@FalconEntity@@UAEHXZ		; FalconEntity::IsSquadron
PUBLIC	?IsPackage@FalconEntity@@UAEHXZ			; FalconEntity::IsPackage
PUBLIC	?IsTeam@FalconEntity@@UAEHXZ			; FalconEntity::IsTeam
PUBLIC	?IsTaskForce@FalconEntity@@UAEHXZ		; FalconEntity::IsTaskForce
PUBLIC	?IsSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsSPJamming
PUBLIC	?IsAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsAreaJamming
PUBLIC	?HasSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasSPJamming
PUBLIC	?HasAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasAreaJamming
PUBLIC	?GetAltitude@FalconEntity@@QBEHXZ		; FalconEntity::GetAltitude
PUBLIC	?SetAQUIREtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetAQUIREtimer
PUBLIC	?SetSEARCHtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetSEARCHtimer
PUBLIC	?SetStepSearchMode@FalconEntity@@UAEXE@Z	; FalconEntity::SetStepSearchMode
PUBLIC	?GetAQUIREtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetAQUIREtimer
PUBLIC	?GetSEARCHtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetSEARCHtimer
PUBLIC	?GetWPTargetID@WayPointClass@@QAE?AVVU_ID@@XZ	; WayPointClass::GetWPTargetID
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?GetWPArrivalTime@WayPointClass@@QAEKXZ		; WayPointClass::GetWPArrivalTime
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	?GetWPLocation@WayPointClass@@QBEXPAF0@Z	; WayPointClass::GetWPLocation
PUBLIC	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
PUBLIC	??1InvalidBufferException@@UAE@XZ		; InvalidBufferException::~InvalidBufferException
PUBLIC	??0InvalidBufferException@@QAE@ABV0@@Z		; InvalidBufferException::InvalidBufferException
PUBLIC	??_GInvalidBufferException@@UAEPAXI@Z		; InvalidBufferException::`scalar deleting destructor'
PUBLIC	?memcpychk@@YAXPAXPAPAEIPAJ@Z			; memcpychk
PUBLIC	?GetSpotTime@CampBaseClass@@QBEKXZ		; CampBaseClass::GetSpotTime
PUBLIC	?GetSpotted@CampBaseClass@@QBEFXZ		; CampBaseClass::GetSpotted
PUBLIC	?GetBaseFlags@CampBaseClass@@QBEFXZ		; CampBaseClass::GetBaseFlags
PUBLIC	?GetCampId@CampBaseClass@@QBEFXZ		; CampBaseClass::GetCampId
PUBLIC	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
PUBLIC	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ	; CampBaseClass::GetDeagOwner
PUBLIC	?OnGround@CampBaseClass@@UAEHXZ			; CampBaseClass::OnGround
PUBLIC	?GetCampID@CampBaseClass@@UAEFXZ		; CampBaseClass::GetCampID
PUBLIC	?GetTeam@CampBaseClass@@UAEEXZ			; CampBaseClass::GetTeam
PUBLIC	?GetCountry@CampBaseClass@@UAEEXZ		; CampBaseClass::GetCountry
PUBLIC	?StepRadar@CampBaseClass@@UAEHHHM@Z		; CampBaseClass::StepRadar
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?GetMissilesFlying@CampBaseClass@@UAEHXZ	; CampBaseClass::GetMissilesFlying
PUBLIC	?IsCampBase@CampBaseClass@@UAE_NXZ		; CampBaseClass::IsCampBase
PUBLIC	?IsEmitting@CampBaseClass@@UAEHXZ		; CampBaseClass::IsEmitting
PUBLIC	?IsAwake@CampBaseClass@@QAEHXZ			; CampBaseClass::IsAwake
PUBLIC	?InSimLists@CampBaseClass@@QAEHXZ		; CampBaseClass::InSimLists
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z	; CampBaseClass::HasEntity
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?GetSPType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSPType
PUBLIC	?SetSpottedTime@CampBaseClass@@QAEXK@Z		; CampBaseClass::SetSpottedTime
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	??0SimInitDataClass@@QAE@XZ			; SimInitDataClass::SimInitDataClass
PUBLIC	??0LoadoutStruct@@QAE@XZ			; LoadoutStruct::LoadoutStruct
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?IsOnline@CampaignClass@@QAEHXZ			; CampaignClass::IsOnline
PUBLIC	?GetLastCheck@UnitClass@@QAEKXZ			; UnitClass::GetLastCheck
PUBLIC	?GetRoster@UnitClass@@QAEJXZ			; UnitClass::GetRoster
PUBLIC	?GetUnitFlags@UnitClass@@QAEJXZ			; UnitClass::GetUnitFlags
PUBLIC	?GetDestX@UnitClass@@QAEFXZ			; UnitClass::GetDestX
PUBLIC	?GetDestY@UnitClass@@QAEFXZ			; UnitClass::GetDestY
PUBLIC	?GetTargetId@UnitClass@@QAE?AVVU_ID@@XZ		; UnitClass::GetTargetId
PUBLIC	?GetMoved@UnitClass@@QAEEXZ			; UnitClass::GetMoved
PUBLIC	?GetLosses@UnitClass@@QAEEXZ			; UnitClass::GetLosses
PUBLIC	?GetTactic@UnitClass@@QAEEXZ			; UnitClass::GetTactic
PUBLIC	?GetCurrentWaypoint@UnitClass@@QAEGXZ		; UnitClass::GetCurrentWaypoint
PUBLIC	?GetNameId@UnitClass@@QAEFXZ			; UnitClass::GetNameId
PUBLIC	?SetLastCheck@UnitClass@@QAEXK@Z		; UnitClass::SetLastCheck
PUBLIC	?SetRoster@UnitClass@@QAEXJ@Z			; UnitClass::SetRoster
PUBLIC	?SetUnitFlags@UnitClass@@QAEXJ@Z		; UnitClass::SetUnitFlags
PUBLIC	?SetDestX@UnitClass@@QAEXF@Z			; UnitClass::SetDestX
PUBLIC	?SetDestY@UnitClass@@QAEXF@Z			; UnitClass::SetDestY
PUBLIC	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z		; UnitClass::SetCargoId
PUBLIC	?SetTargetId@UnitClass@@QAEXVVU_ID@@@Z		; UnitClass::SetTargetId
PUBLIC	?SetMoved@UnitClass@@QAEXE@Z			; UnitClass::SetMoved
PUBLIC	?SetLosses@UnitClass@@QAEXE@Z			; UnitClass::SetLosses
PUBLIC	?SetTactic@UnitClass@@QAEXE@Z			; UnitClass::SetTactic
PUBLIC	?SetCurrentWaypoint@UnitClass@@QAEXG@Z		; UnitClass::SetCurrentWaypoint
PUBLIC	?SetNameId@UnitClass@@QAEXF@Z			; UnitClass::SetNameId
PUBLIC	?SetReinforcement@UnitClass@@QAEXF@Z		; UnitClass::SetReinforcement
PUBLIC	?SetOdds@UnitClass@@QAEXF@Z			; UnitClass::SetOdds
PUBLIC	?MakeWaypointsDirty@UnitClass@@QAEXXZ		; UnitClass::MakeWaypointsDirty
PUBLIC	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
PUBLIC	?WriteDirty@UnitClass@@QAEXPAPAE@Z		; UnitClass::WriteDirty
PUBLIC	?ReadDirty@UnitClass@@QAEXPAPAEPAJ@Z		; UnitClass::ReadDirty
PUBLIC	??0UnitClass@@QAE@GK@Z				; UnitClass::UnitClass
PUBLIC	??0UnitClass@@QAE@PAPAEPAJ@Z			; UnitClass::UnitClass
PUBLIC	??1UnitClass@@UAE@XZ				; UnitClass::~UnitClass
PUBLIC	?SaveSize@UnitClass@@UAEHXZ			; UnitClass::SaveSize
PUBLIC	?Save@UnitClass@@UAEHPAPAE@Z			; UnitClass::Save
PUBLIC	?Handle@UnitClass@@UAEHPAVVuFullUpdateEvent@@@Z	; UnitClass::Handle
PUBLIC	?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z ; UnitClass::SendDeaggregateData
PUBLIC	?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z ; UnitClass::RecordCurrentState
PUBLIC	?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z ; UnitClass::Deaggregate
PUBLIC	?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z ; UnitClass::Reaggregate
PUBLIC	?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z ; UnitClass::TransferOwnership
PUBLIC	?Wake@UnitClass@@UAEHXZ				; UnitClass::Wake
PUBLIC	?Sleep@UnitClass@@UAEHXZ			; UnitClass::Sleep
PUBLIC	?InsertInSimLists@UnitClass@@UAEXMM@Z		; UnitClass::InsertInSimLists
PUBLIC	?RemoveFromSimLists@UnitClass@@UAEXXZ		; UnitClass::RemoveFromSimLists
PUBLIC	?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z	; UnitClass::DeaggregateFromData
PUBLIC	?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z	; UnitClass::ReaggregateFromData
PUBLIC	?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z ; UnitClass::TransferOwnershipFromData
PUBLIC	?ResetPlayerStatus@UnitClass@@UAEHXZ		; UnitClass::ResetPlayerStatus
PUBLIC	?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z ; UnitClass::ApplyDamage
PUBLIC	?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z ; UnitClass::ApplyDamage
PUBLIC	?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z ; UnitClass::DecodeDamageData
PUBLIC	?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z ; UnitClass::CollectWeapons
PUBLIC	?GetDamageModifiers@UnitClass@@UAEPAEXZ		; UnitClass::GetDamageModifiers
PUBLIC	?GetName@UnitClass@@UAEPADPADHH@Z		; UnitClass::GetName
PUBLIC	?GetFullName@UnitClass@@UAEPADPADHH@Z		; UnitClass::GetFullName
PUBLIC	?GetDivisionName@UnitClass@@UAEPADPADHH@Z	; UnitClass::GetDivisionName
PUBLIC	?GetHitChance@UnitClass@@UAEHHH@Z		; UnitClass::GetHitChance
PUBLIC	?GetAproxHitChance@UnitClass@@UAEHHH@Z		; UnitClass::GetAproxHitChance
PUBLIC	?GetCombatStrength@UnitClass@@UAEHHH@Z		; UnitClass::GetCombatStrength
PUBLIC	?GetAproxCombatStrength@UnitClass@@UAEHHH@Z	; UnitClass::GetAproxCombatStrength
PUBLIC	?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z ; UnitClass::GetWeaponRange
PUBLIC	?GetAproxWeaponRange@UnitClass@@UAEHH@Z		; UnitClass::GetAproxWeaponRange
PUBLIC	?GetDetectionRange@UnitClass@@UAEHH@Z		; UnitClass::GetDetectionRange
PUBLIC	?GetElectronicDetectionRange@UnitClass@@UAEHH@Z	; UnitClass::GetElectronicDetectionRange
PUBLIC	?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z	; UnitClass::CanDetect
PUBLIC	?GetComponentLocation@UnitClass@@UAEXPAF0H@Z	; UnitClass::GetComponentLocation
PUBLIC	?GetComponentAltitude@UnitClass@@UAEHH@Z	; UnitClass::GetComponentAltitude
PUBLIC	?GetRCSFactor@UnitClass@@UAEMXZ			; UnitClass::GetRCSFactor
PUBLIC	?GetIRFactor@UnitClass@@UAEMXZ			; UnitClass::GetIRFactor
PUBLIC	?GetNumberOfArcs@UnitClass@@UAEHXZ		; UnitClass::GetNumberOfArcs
PUBLIC	?GetArcRatio@UnitClass@@UAEMH@Z			; UnitClass::GetArcRatio
PUBLIC	?GetArcRange@UnitClass@@UAEMH@Z			; UnitClass::GetArcRange
PUBLIC	?GetArcAngle@UnitClass@@UAEXHPAM0@Z		; UnitClass::GetArcAngle
PUBLIC	?GetRadarType@UnitClass@@UAEHXZ			; UnitClass::GetRadarType
PUBLIC	?CanShootWeapon@UnitClass@@UAEHH@Z		; UnitClass::CanShootWeapon
PUBLIC	?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z ; UnitClass::GetDeaggregationPoint
PUBLIC	?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ ; UnitClass::GetUnitDeaggregationData
PUBLIC	?ShouldDeaggregate@UnitClass@@UAEHXZ		; UnitClass::ShouldDeaggregate
PUBLIC	?ClearDeaggregationData@UnitClass@@UAEXXZ	; UnitClass::ClearDeaggregationData
PUBLIC	?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z	; UnitClass::Reaction
PUBLIC	?MoveUnit@UnitClass@@UAEHK@Z			; UnitClass::MoveUnit
PUBLIC	?DoCombat@UnitClass@@UAEHXZ			; UnitClass::DoCombat
PUBLIC	?ChooseTactic@UnitClass@@UAEHXZ			; UnitClass::ChooseTactic
PUBLIC	?CheckTactic@UnitClass@@UAEHH@Z			; UnitClass::CheckTactic
PUBLIC	?Father@UnitClass@@UBEHXZ			; UnitClass::Father
PUBLIC	?Real@UnitClass@@UAEHXZ				; UnitClass::Real
PUBLIC	?AdjustForSupply@UnitClass@@UAEMXZ		; UnitClass::AdjustForSupply
PUBLIC	?GetUnitSpeed@UnitClass@@UBEHXZ			; UnitClass::GetUnitSpeed
PUBLIC	?DetectOnMove@UnitClass@@UAEHXZ			; UnitClass::DetectOnMove
PUBLIC	?ChooseTarget@UnitClass@@UAEHXZ			; UnitClass::ChooseTarget
PUBLIC	?UpdateTime@UnitClass@@QBEKXZ			; UnitClass::UpdateTime
PUBLIC	?CombatTime@UnitClass@@UAEKXZ			; UnitClass::CombatTime
PUBLIC	?GetUnitSupplyNeed@UnitClass@@UAEHH@Z		; UnitClass::GetUnitSupplyNeed
PUBLIC	?GetUnitFuelNeed@UnitClass@@UAEHH@Z		; UnitClass::GetUnitFuelNeed
PUBLIC	?SupplyUnit@UnitClass@@UAEXHH@Z			; UnitClass::SupplyUnit
PUBLIC	?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z ; UnitClass::GetVehicleDeagData
PUBLIC	?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z	; UnitClass::SendUnitMessage
PUBLIC	?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::BroadcastUnitMessage
PUBLIC	?ChangeUnitLocation@UnitClass@@QAEHE@Z		; UnitClass::ChangeUnitLocation
PUBLIC	?MoraleCheck@UnitClass@@QAEHHH@Z		; UnitClass::MoraleCheck
PUBLIC	?IsUnit@UnitClass@@UAEHXZ			; UnitClass::IsUnit
PUBLIC	?SetDead@UnitClass@@QAEXH@Z			; UnitClass::SetDead
PUBLIC	?SetAssigned@UnitClass@@QAEXH@Z			; UnitClass::SetAssigned
PUBLIC	?SetOrdered@UnitClass@@QAEXH@Z			; UnitClass::SetOrdered
PUBLIC	?SetDontPlan@UnitClass@@QAEXH@Z			; UnitClass::SetDontPlan
PUBLIC	?SetParent@UnitClass@@QAEXH@Z			; UnitClass::SetParent
PUBLIC	?SetEngaged@UnitClass@@QAEXH@Z			; UnitClass::SetEngaged
PUBLIC	?SetScripted@UnitClass@@QAEXH@Z			; UnitClass::SetScripted
PUBLIC	?SetCommando@UnitClass@@QAEXH@Z			; UnitClass::SetCommando
PUBLIC	?SetMoving@UnitClass@@QAEXH@Z			; UnitClass::SetMoving
PUBLIC	?SetRefused@UnitClass@@QAEXH@Z			; UnitClass::SetRefused
PUBLIC	?SetHasECM@UnitClass@@QAEXH@Z			; UnitClass::SetHasECM
PUBLIC	?SetCargo@UnitClass@@QAEXH@Z			; UnitClass::SetCargo
PUBLIC	?SetCombat@UnitClass@@QAEXH@Z			; UnitClass::SetCombat
PUBLIC	?SetBroken@UnitClass@@QAEXH@Z			; UnitClass::SetBroken
PUBLIC	?SetAborted@UnitClass@@QAEXH@Z			; UnitClass::SetAborted
PUBLIC	?SetLosses@UnitClass@@QAEXH@Z			; UnitClass::SetLosses
PUBLIC	?SetInactive@UnitClass@@QAEXH@Z			; UnitClass::SetInactive
PUBLIC	?SetFragment@UnitClass@@QAEXH@Z			; UnitClass::SetFragment
PUBLIC	?SetTargeted@UnitClass@@QAEXH@Z			; UnitClass::SetTargeted
PUBLIC	?SetRetreating@UnitClass@@QAEXH@Z		; UnitClass::SetRetreating
PUBLIC	?SetDetached@UnitClass@@QAEXH@Z			; UnitClass::SetDetached
PUBLIC	?SetSupported@UnitClass@@QAEXH@Z		; UnitClass::SetSupported
PUBLIC	?SetTempDest@UnitClass@@QAEXH@Z			; UnitClass::SetTempDest
PUBLIC	?SetFinal@UnitClass@@QAEXH@Z			; UnitClass::SetFinal
PUBLIC	?SetPilots@UnitClass@@QAEXH@Z			; UnitClass::SetPilots
PUBLIC	?SetDiverted@UnitClass@@QAEXH@Z			; UnitClass::SetDiverted
PUBLIC	?SetFired@UnitClass@@QAEXH@Z			; UnitClass::SetFired
PUBLIC	?SetLocked@UnitClass@@QAEXH@Z			; UnitClass::SetLocked
PUBLIC	?SetIAKill@UnitClass@@QAEXH@Z			; UnitClass::SetIAKill
PUBLIC	?SetNoAbort@UnitClass@@QAEXH@Z			; UnitClass::SetNoAbort
PUBLIC	?IsDead@UnitClass@@UBEHXZ			; UnitClass::IsDead
PUBLIC	?Parent@UnitClass@@QBEHXZ			; UnitClass::Parent
PUBLIC	?Moving@UnitClass@@QBEHXZ			; UnitClass::Moving
PUBLIC	?Cargo@UnitClass@@QBEHXZ			; UnitClass::Cargo
PUBLIC	?Broken@UnitClass@@QBEHXZ			; UnitClass::Broken
PUBLIC	?Inactive@UnitClass@@QBEHXZ			; UnitClass::Inactive
PUBLIC	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
PUBLIC	?GetUnitClassName@UnitClass@@QAEPADXZ		; UnitClass::GetUnitClassName
PUBLIC	?SetUnitAltitude@UnitClass@@QAEXH@Z		; UnitClass::SetUnitAltitude
PUBLIC	?SimSetLocation@UnitClass@@UAEXMMM@Z		; UnitClass::SimSetLocation
PUBLIC	?SimSetOrientation@UnitClass@@UAEXMMM@Z		; UnitClass::SimSetOrientation
PUBLIC	?GetRealPosition@UnitClass@@UAEXPAM00@Z		; UnitClass::GetRealPosition
PUBLIC	?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z ; UnitClass::GetBestVehicleWeapon
PUBLIC	?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z ; UnitClass::GetVehicleHitChance
PUBLIC	?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z ; UnitClass::GetVehicleCombatStrength
PUBLIC	?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z ; UnitClass::GetVehicleRange
PUBLIC	?GetUnitWeaponId@UnitClass@@UAEHHH@Z		; UnitClass::GetUnitWeaponId
PUBLIC	?GetUnitWeaponCount@UnitClass@@UAEHHH@Z		; UnitClass::GetUnitWeaponCount
PUBLIC	?SetUnitDestination@UnitClass@@QAEXFF@Z		; UnitClass::SetUnitDestination
PUBLIC	?SetNumVehicles@UnitClass@@QAEXHH@Z		; UnitClass::SetNumVehicles
PUBLIC	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z	; UnitClass::SetTarget
PUBLIC	?SetUnitMoved@UnitClass@@QAEXE@Z		; UnitClass::SetUnitMoved
PUBLIC	?GetUnitDestination@UnitClass@@QAEXPAF0@Z	; UnitClass::GetUnitDestination
PUBLIC	?GetNumVehicles@UnitClass@@QAEHH@Z		; UnitClass::GetNumVehicles
PUBLIC	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ	; UnitClass::GetTarget
PUBLIC	?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ		; UnitClass::GetTargetID
PUBLIC	?GetSimTarget@UnitClass@@QAEPAVSimBaseClass@@XZ	; UnitClass::GetSimTarget
PUBLIC	?GetCampTarget@UnitClass@@QAEPAVCampBaseClass@@XZ ; UnitClass::GetCampTarget
PUBLIC	?GetCargo@UnitClass@@QAEPAVCampBaseClass@@XZ	; UnitClass::GetCargo
PUBLIC	?GetTransport@UnitClass@@QAEPAVCampBaseClass@@XZ ; UnitClass::GetTransport
PUBLIC	?GetCargoID@UnitClass@@QAE?AVVU_ID@@XZ		; UnitClass::GetCargoID
PUBLIC	?GetTransportID@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetTransportID
PUBLIC	?GetUnitMoved@UnitClass@@QBEHXZ			; UnitClass::GetUnitMoved
PUBLIC	?GetUnitTactic@UnitClass@@QBEHXZ		; UnitClass::GetUnitTactic
PUBLIC	?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z	; UnitClass::AssignUnit
PUBLIC	?SetUnitSType@UnitClass@@QAEHD@Z		; UnitClass::SetUnitSType
PUBLIC	?SetUnitSPType@UnitClass@@QAEHD@Z		; UnitClass::SetUnitSPType
PUBLIC	?GetUnitNameID@UnitClass@@QAEHXZ		; UnitClass::GetUnitNameID
PUBLIC	?GetVehicleID@UnitClass@@QAEFH@Z		; UnitClass::GetVehicleID
PUBLIC	?GetTotalVehicles@UnitClass@@QAEHXZ		; UnitClass::GetTotalVehicles
PUBLIC	?GetFullstrengthVehicles@UnitClass@@QAEHXZ	; UnitClass::GetFullstrengthVehicles
PUBLIC	?GetFullstrengthVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetFullstrengthVehicles
PUBLIC	?GetMaxSpeed@UnitClass@@QBEHXZ			; UnitClass::GetMaxSpeed
PUBLIC	?GetCruiseSpeed@UnitClass@@QBEHXZ		; UnitClass::GetCruiseSpeed
PUBLIC	?GetCombatSpeed@UnitClass@@QBEHXZ		; UnitClass::GetCombatSpeed
PUBLIC	?GetUnitEndurance@UnitClass@@QAEHXZ		; UnitClass::GetUnitEndurance
PUBLIC	?GetUnitRange@UnitClass@@QAEHXZ			; UnitClass::GetUnitRange
PUBLIC	?GetRClass@UnitClass@@QAEHXZ			; UnitClass::GetRClass
PUBLIC	?CountUnitElements@UnitClass@@QAEHXZ		; UnitClass::CountUnitElements
PUBLIC	?GetRandomElement@UnitClass@@QAEPAV1@XZ		; UnitClass::GetRandomElement
PUBLIC	?ResetMoves@UnitClass@@QAEXXZ			; UnitClass::ResetMoves
PUBLIC	?ResetLocations@UnitClass@@QAEXFF@Z		; UnitClass::ResetLocations
PUBLIC	?ResetDestinations@UnitClass@@QAEXFF@Z		; UnitClass::ResetDestinations
PUBLIC	?BuildElements@UnitClass@@QAEXXZ		; UnitClass::BuildElements
PUBLIC	?ChangeVehicles@UnitClass@@QAEHH@Z		; UnitClass::ChangeVehicles
PUBLIC	?GetFormationCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetFormationCruiseSpeed
PUBLIC	?KillUnit@UnitClass@@QAEXXZ			; UnitClass::KillUnit
PUBLIC	?NoMission@UnitClass@@QAEHXZ			; UnitClass::NoMission
PUBLIC	?AtDestination@UnitClass@@QAEHXZ		; UnitClass::AtDestination
PUBLIC	?GetUnitFormation@UnitClass@@QBEHXZ		; UnitClass::GetUnitFormation
PUBLIC	?GetUnitRoleScore@UnitClass@@QAEHHHH@Z		; UnitClass::GetUnitRoleScore
PUBLIC	?GetUnitMovementCost@UnitClass@@QAEMFFE@Z	; UnitClass::GetUnitMovementCost
PUBLIC	?GetUnitObjectivePath@UnitClass@@QAEHPAVBasePathClass@@PAVObjectiveClass@@1@Z ; UnitClass::GetUnitObjectivePath
PUBLIC	?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ; UnitClass::GetUnitGridPath
PUBLIC	?LoadUnit@UnitClass@@QAEXPAV1@@Z		; UnitClass::LoadUnit
PUBLIC	?UnloadUnit@UnitClass@@QAEXXZ			; UnitClass::UnloadUnit
PUBLIC	?GetUnitSupplyTime@UnitClass@@QAEKXZ		; UnitClass::GetUnitSupplyTime
PUBLIC	?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ; UnitClass::AddUnitWP
PUBLIC	?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z ; UnitClass::AddWPAfter
PUBLIC	?DeleteUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ; UnitClass::DeleteUnitWP
PUBLIC	?EncodeWaypoints@UnitClass@@QAEHPAPAE@Z		; UnitClass::EncodeWaypoints
PUBLIC	?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z	; UnitClass::DecodeWaypoints
PUBLIC	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
PUBLIC	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
PUBLIC	?GetUnitMissionWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetUnitMissionWP
PUBLIC	?FinishUnitWP@UnitClass@@QAEXXZ			; UnitClass::FinishUnitWP
PUBLIC	?DisposeWayPoints@UnitClass@@QAEXXZ		; UnitClass::DisposeWayPoints
PUBLIC	?CheckBroken@UnitClass@@QAEXXZ			; UnitClass::CheckBroken
PUBLIC	?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ; UnitClass::SetCurrentUnitWP
PUBLIC	?AdjustWayPoints@UnitClass@@QAEXXZ		; UnitClass::AdjustWayPoints
PUBLIC	?SetUnitLastMove@UnitClass@@UAEXK@Z		; UnitClass::SetUnitLastMove
PUBLIC	?SetCombatTime@UnitClass@@UAEXK@Z		; UnitClass::SetCombatTime
PUBLIC	?SetBurntFuel@UnitClass@@UAEXJ@Z		; UnitClass::SetBurntFuel
PUBLIC	?SetUnitMission@UnitClass@@UAEXE@Z		; UnitClass::SetUnitMission
PUBLIC	?SetUnitRole@UnitClass@@UAEXE@Z			; UnitClass::SetUnitRole
PUBLIC	?SetUnitPriority@UnitClass@@UAEXH@Z		; UnitClass::SetUnitPriority
PUBLIC	?SetUnitMissionID@UnitClass@@UAEXH@Z		; UnitClass::SetUnitMissionID
PUBLIC	?SetUnitMissionTarget@UnitClass@@UAEXH@Z	; UnitClass::SetUnitMissionTarget
PUBLIC	?SetUnitTOT@UnitClass@@UAEXK@Z			; UnitClass::SetUnitTOT
PUBLIC	?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitSquadron
PUBLIC	?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitAirbase
PUBLIC	?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z ; UnitClass::SetLoadout
PUBLIC	?GetNumberOfLoadouts@UnitClass@@UAEHXZ		; UnitClass::GetNumberOfLoadouts
PUBLIC	?GetMoveTime@UnitClass@@UAEKXZ			; UnitClass::GetMoveTime
PUBLIC	?GetCombatTime@UnitClass@@UAEKXZ		; UnitClass::GetCombatTime
PUBLIC	?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetAirTargetID
PUBLIC	?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ	; UnitClass::GetAirTarget
PUBLIC	?GetBurntFuel@UnitClass@@UAEHXZ			; UnitClass::GetBurntFuel
PUBLIC	?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ ; UnitClass::GetUnitMission
PUBLIC	?GetUnitNormalRole@UnitClass@@UAEHXZ		; UnitClass::GetUnitNormalRole
PUBLIC	?GetUnitCurrentRole@UnitClass@@UBEHXZ		; UnitClass::GetUnitCurrentRole
PUBLIC	?GetUnitPriority@UnitClass@@UAEHXZ		; UnitClass::GetUnitPriority
PUBLIC	?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ ; UnitClass::GetUnitMissionTarget
PUBLIC	?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ ; UnitClass::GetUnitMissionTargetID
PUBLIC	?GetUnitMissionID@UnitClass@@UAEHXZ		; UnitClass::GetUnitMissionID
PUBLIC	?GetUnitTOT@UnitClass@@UAEKXZ			; UnitClass::GetUnitTOT
PUBLIC	?GetUnitSquadron@UnitClass@@UAEPAV1@XZ		; UnitClass::GetUnitSquadron
PUBLIC	?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitSquadronID
PUBLIC	?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ ; UnitClass::GetUnitAirbase
PUBLIC	?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitAirbaseID
PUBLIC	?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z ; UnitClass::LoadWeapons
PUBLIC	?DumpWeapons@UnitClass@@UAEHXZ			; UnitClass::DumpWeapons
PUBLIC	?ETA@UnitClass@@UAEKXZ				; UnitClass::ETA
PUBLIC	?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ ; UnitClass::GetKnownEmitters
PUBLIC	?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z ; UnitClass::BuildMission
PUBLIC	?IncrementTime@UnitClass@@UAEXK@Z		; UnitClass::IncrementTime
PUBLIC	?UseFuel@UnitClass@@UAEXJ@Z			; UnitClass::UseFuel
PUBLIC	?SetUnitSpecialty@UnitClass@@UAEXH@Z		; UnitClass::SetUnitSpecialty
PUBLIC	?SetUnitSupply@UnitClass@@UAEXH@Z		; UnitClass::SetUnitSupply
PUBLIC	?SetUnitMorale@UnitClass@@UAEXH@Z		; UnitClass::SetUnitMorale
PUBLIC	?SetSquadronFuel@UnitClass@@UAEXJ@Z		; UnitClass::SetSquadronFuel
PUBLIC	?SetUnitStores@UnitClass@@UAEXHE@Z		; UnitClass::SetUnitStores
PUBLIC	?SetLastResupply@UnitClass@@UAEXH@Z		; UnitClass::SetLastResupply
PUBLIC	?SetLastResupplyTime@UnitClass@@UAEXK@Z		; UnitClass::SetLastResupplyTime
PUBLIC	?GetUnitSpecialty@UnitClass@@UAEHXZ		; UnitClass::GetUnitSpecialty
PUBLIC	?GetUnitSupply@UnitClass@@UAEHXZ		; UnitClass::GetUnitSupply
PUBLIC	?GetUnitMorale@UnitClass@@UAEHXZ		; UnitClass::GetUnitMorale
PUBLIC	?GetSquadronFuel@UnitClass@@UAEJXZ		; UnitClass::GetSquadronFuel
PUBLIC	?GetUnitStores@UnitClass@@UAEEH@Z		; UnitClass::GetUnitStores
PUBLIC	?GetLastResupplyTime@UnitClass@@UAEKXZ		; UnitClass::GetLastResupplyTime
PUBLIC	?GetLastResupply@UnitClass@@UAEHXZ		; UnitClass::GetLastResupply
PUBLIC	?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z ; UnitClass::BuildPackage
PUBLIC	?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z ; UnitClass::HandleRequestReceipt
PUBLIC	?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z	; UnitClass::SetUnitAssemblyPoint
PUBLIC	?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z	; UnitClass::GetUnitAssemblyPoint
PUBLIC	?SetUnitPrimaryObj@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitPrimaryObj
PUBLIC	?SetUnitSecondaryObj@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitSecondaryObj
PUBLIC	?SetUnitObjective@UnitClass@@UAEXVVU_ID@@@Z	; UnitClass::SetUnitObjective
PUBLIC	?SetUnitOrders@UnitClass@@UAEXH@Z		; UnitClass::SetUnitOrders
PUBLIC	?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z	; UnitClass::SetUnitOrders
PUBLIC	?SetUnitFatigue@UnitClass@@UAEXH@Z		; UnitClass::SetUnitFatigue
PUBLIC	?SetUnitMode@UnitClass@@UAEXH@Z			; UnitClass::SetUnitMode
PUBLIC	?SetUnitPosition@UnitClass@@UAEXH@Z		; UnitClass::SetUnitPosition
PUBLIC	?SetUnitDivision@UnitClass@@UAEXH@Z		; UnitClass::SetUnitDivision
PUBLIC	?SetUnitHeading@UnitClass@@UAEXH@Z		; UnitClass::SetUnitHeading
PUBLIC	?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ; UnitClass::GetUnitPrimaryObj
PUBLIC	?GetUnitSecondaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ; UnitClass::GetUnitSecondaryObj
PUBLIC	?GetUnitObjective@UnitClass@@UAEPAVObjectiveClass@@XZ ; UnitClass::GetUnitObjective
PUBLIC	?GetUnitPrimaryObjID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitPrimaryObjID
PUBLIC	?GetUnitSecondaryObjID@UnitClass@@UAE?AVVU_ID@@XZ ; UnitClass::GetUnitSecondaryObjID
PUBLIC	?GetUnitObjectiveID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitObjectiveID
PUBLIC	?GetUnitOrders@UnitClass@@UAEHXZ		; UnitClass::GetUnitOrders
PUBLIC	?GetUnitFatigue@UnitClass@@UAEHXZ		; UnitClass::GetUnitFatigue
PUBLIC	?GetUnitElement@UnitClass@@UAEHXZ		; UnitClass::GetUnitElement
PUBLIC	?GetUnitMode@UnitClass@@UAEHXZ			; UnitClass::GetUnitMode
PUBLIC	?GetUnitPosition@UnitClass@@UAEHXZ		; UnitClass::GetUnitPosition
PUBLIC	?GetUnitDivision@UnitClass@@UAEHXZ		; UnitClass::GetUnitDivision
PUBLIC	?GetUnitHeading@UnitClass@@UAEHXZ		; UnitClass::GetUnitHeading
PUBLIC	?SetUnitNextMove@UnitClass@@UAEXXZ		; UnitClass::SetUnitNextMove
PUBLIC	?ClearUnitPath@UnitClass@@UAEXXZ		; UnitClass::ClearUnitPath
PUBLIC	?GetNextMoveDirection@UnitClass@@UAEHXZ		; UnitClass::GetNextMoveDirection
PUBLIC	?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z	; UnitClass::SetUnitCurrentDestination
PUBLIC	?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z ; UnitClass::GetUnitCurrentDestination
PUBLIC	?GetObjMovementType@UnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z ; UnitClass::GetObjMovementType
PUBLIC	?CheckForSurrender@UnitClass@@UAEHXZ		; UnitClass::CheckForSurrender
PUBLIC	?BuildMission@UnitClass@@UAEHXZ			; UnitClass::BuildMission
PUBLIC	?RallyUnit@UnitClass@@UAEHH@Z			; UnitClass::RallyUnit
PUBLIC	?GetUnitParent@UnitClass@@UBEPAV1@XZ		; UnitClass::GetUnitParent
PUBLIC	?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ	; UnitClass::GetUnitParentID
PUBLIC	?SetUnitParent@UnitClass@@UAEXPAV1@@Z		; UnitClass::SetUnitParent
PUBLIC	?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ	; UnitClass::GetFirstUnitElement
PUBLIC	?GetNextUnitElement@UnitClass@@UBEPAV1@XZ	; UnitClass::GetNextUnitElement
PUBLIC	?GetUnitElement@UnitClass@@UAEPAV1@H@Z		; UnitClass::GetUnitElement
PUBLIC	?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z	; UnitClass::GetUnitElementByID
PUBLIC	?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z	; UnitClass::GetPrevUnitElement
PUBLIC	?AddUnitChild@UnitClass@@UAEXPAV1@@Z		; UnitClass::AddUnitChild
PUBLIC	?DisposeChildren@UnitClass@@UAEXXZ		; UnitClass::DisposeChildren
PUBLIC	?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z		; UnitClass::RemoveChild
PUBLIC	?ReorganizeUnit@UnitClass@@UAEXXZ		; UnitClass::ReorganizeUnit
PUBLIC	?UpdateParentStatistics@UnitClass@@UAEHXZ	; UnitClass::UpdateParentStatistics
PUBLIC	?CalculateSOJ@UnitClass@@QAEXAAVVuGridIterator@@@Z ; UnitClass::CalculateSOJ
PUBLIC	??_GUnitClass@@UAEPAXI@Z			; UnitClass::`scalar deleting destructor'
PUBLIC	??0UnitDeaggregationData@@QAE@XZ		; UnitDeaggregationData::UnitDeaggregationData
PUBLIC	??1UnitDeaggregationData@@QAE@XZ		; UnitDeaggregationData::~UnitDeaggregationData
PUBLIC	?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z ; UnitDeaggregationData::StoreDeaggregationData
PUBLIC	?SaveUnits@@YAXPAD@Z				; SaveUnits
PUBLIC	?LoadUnits@@YAHPAD@Z				; LoadUnits
PUBLIC	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
PUBLIC	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
PUBLIC	?ConvertUnit@@YAPAVUnitClass@@PAV1@HHHH@Z	; ConvertUnit
PUBLIC	?GetSizeName@@YAPADHHPAD@Z			; GetSizeName
PUBLIC	?GetDivisionName@@YAPADHPADHH@Z			; GetDivisionName
PUBLIC	?FindUnitNameID@@YAHPAVUnitClass@@@Z		; FindUnitNameID
PUBLIC	?NewUnit@@YAPAVUnitClass@@HHHHPAV1@@Z		; NewUnit
PUBLIC	?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z		; NewUnit
PUBLIC	?GetRange@@YAMPAVUnitClass@@PAVCampBaseClass@@@Z ; GetRange
PUBLIC	?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z ; EncodeUnitData
PUBLIC	?DecodeUnitData@@YAHPAPAEPAJPAVFalconSessionEntity@@@Z ; DecodeUnitData
PUBLIC	?MinDeagTime@ATCBrain@@QAEKXZ			; ATCBrain::MinDeagTime
PUBLIC	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
PUBLIC	?GetColor@TeamClass@@QAEHXZ			; TeamClass::GetColor
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?get@?$VuBin@VSquadronClass@@@@QBEPAVSquadronClass@@XZ ; VuBin<SquadronClass>::get
PUBLIC	?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ ; VuBin<FlightClass>::get
PUBLIC	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
PUBLIC	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
PUBLIC	?GetPlayerSquadron@FalconSessionEntity@@QBEPAVSquadronClass@@XZ ; FalconSessionEntity::GetPlayerSquadron
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?GetSlot@SimBaseClass@@QAEHXZ			; SimBaseClass::GetSlot
PUBLIC	?IsAwake@SimBaseClass@@QBEHXZ			; SimBaseClass::IsAwake
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ	; AircraftClass::DBrain
PUBLIC	?NumHardpoints@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumHardpoints
PUBLIC	?NameTagsOn@PlayerOptionsClass@@QAEHXZ		; PlayerOptionsClass::NameTagsOn
PUBLIC	?GetTaxiPoint@DigitalBrain@@QAEHXZ		; DigitalBrain::GetTaxiPoint
PUBLIC	?GetArrivalSpeed@@YAHPBVUnitClass@@@Z		; GetArrivalSpeed
PUBLIC	?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z	; GetUnitByID
PUBLIC	?GetDivisionName@@YAPADHHPADHH@Z		; GetDivisionName
PUBLIC	?FindTaxiPt@@YAHPAVFlightClass@@PAVObjectiveClass@@H@Z ; FindTaxiPt
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_7InvalidBufferException@@6B@			; InvalidBufferException::`vftable'
PUBLIC	??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ ; `string'
PUBLIC	__TI4?AVInvalidBufferException@@
PUBLIC	__CTA4?AVInvalidBufferException@@
PUBLIC	??_R0?AVInvalidBufferException@@@8		; InvalidBufferException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7UnitClass@@6B@				; UnitClass::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0BA@NIOPHDFC@?$CF08x?5UnitClass?5?$AA@	; `string'
PUBLIC	??_C@_0BA@BOFFLAKG@?$CF08x?5Waypoints?5?$AA@	; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BM@JKDKHHG@battalion?5heir?5will?5exceed?6?$AA@ ; `string'
PUBLIC	??_C@_08EPEHIMMI@?$CFs?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_07LLFIICBM@?$CFs?5?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_0BD@HHBCIDIG@Cargo?5is?5missing?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@CFBAPBAH@Unit?5?$CFd?5picking?5up?5unit?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@FIGMOKMC@Unit?5?$CFd?5dropping?5off?5unit?5?$CFd?5at?5@ ; `string'
PUBLIC	??_C@_07MMBOBMNN@Nothing?$AA@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_03HECMEGIJ@uni?$AA@			; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BF@JMEEBPII@Count?$DN?$CF1d?0Size?$DN?$CF1ld?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@LACJBFNH@Encode?5Unit?5Data?5?$CFd?5?$DN?$DO?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_03JDANDILB@?$CFd?5?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4UnitClass@@6B@				; UnitClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUnitClass@@@8				; UnitClass `RTTI Type Descriptor'
PUBLIC	??_R3UnitClass@@8				; UnitClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UnitClass@@8				; UnitClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UnitClass@@8			; UnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CampBaseClass@@8			; CampBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCampBaseClass@@@8			; CampBaseClass `RTTI Type Descriptor'
PUBLIC	??_R3CampBaseClass@@8				; CampBaseClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CampBaseClass@@8				; CampBaseClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FalconEntity@@8			; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFalconEntity@@@8			; FalconEntity `RTTI Type Descriptor'
PUBLIC	??_R3FalconEntity@@8				; FalconEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FalconEntity@@8				; FalconEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuEntity@@8			; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuEntity@@@8				; VuEntity `RTTI Type Descriptor'
PUBLIC	??_R3VuEntity@@8				; VuEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuEntity@@8				; VuEntity::`RTTI Base Class Array'
PUBLIC	??_R4InvalidBufferException@@6B@		; InvalidBufferException::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidBufferException@@8			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidBufferException@@8			; InvalidBufferException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidBufferException@@8		; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@3fa00000
PUBLIC	__real@3fb2b8c1
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3fdf66f1
PUBLIC	__real@40100000
PUBLIC	__real@40400000
PUBLIC	__real@40437a13
PUBLIC	__real@40490fd9
PUBLIC	__real@40490fdb
PUBLIC	__real@40c90fdb
PUBLIC	__real@41800000
PUBLIC	__real@42000000
PUBLIC	__real@43000000
PUBLIC	__real@447a0000
PUBLIC	__real@454cffae
PUBLIC	__real@4a5bba00
PUBLIC	__real@bf060a91
PUBLIC	__real@bf800000
PUBLIC	__real@c3fa0000
PUBLIC	__real@c4fa0000
PUBLIC	__real@c65ac000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_fclose:PROC
EXTRN	_fflush:PROC
EXTRN	_fprintf:PROC
EXTRN	_fwrite:PROC
EXTRN	_printf:PROC
EXTRN	__snprintf:PROC
EXTRN	_sprintf:PROC
EXTRN	_rand:PROC
EXTRN	_fabs:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__mbsncpy:PROC
EXTRN	_MonoPrint:PROC
EXTRN	__isnan:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?F4IsBadCodePtr@@YA_NPAX@Z:PROC			; F4IsBadCodePtr
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetOwnerId@VuEntity@@QAEXVVU_ID@@@Z:PROC	; VuEntity::SetOwnerId
EXTRN	?SetEntityType@VuEntity@@QAEXG@Z:PROC		; VuEntity::SetEntityType
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z:PROC ; VuEntity::CustomCollisionCheck
EXTRN	?TerrainCollisionCheck@VuEntity@@UAEEXZ:PROC	; VuEntity::TerrainCollisionCheck
EXTRN	?IsTarget@VuEntity@@UAEEXZ:PROC			; VuEntity::IsTarget
EXTRN	?IsSession@VuEntity@@UAEEXZ:PROC		; VuEntity::IsSession
EXTRN	?IsGroup@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGroup
EXTRN	?IsGame@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGame
EXTRN	?IsCamera@VuEntity@@UBEEXZ:PROC			; VuEntity::IsCamera
EXTRN	?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?InsertionCallback@VuEntity@@MAEHXZ:PROC	; VuEntity::InsertionCallback
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Register@VuCollection@@QAEXXZ:PROC		; VuCollection::Register
EXTRN	?Unregister@VuCollection@@QAEXXZ:PROC		; VuCollection::Unregister
EXTRN	?Insert@VuCollection@@QAEHPAVVuEntity@@@Z:PROC	; VuCollection::Insert
EXTRN	?ForcedInsert@VuCollection@@QAEHPAVVuEntity@@@Z:PROC ; VuCollection::ForcedInsert
EXTRN	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z:PROC	; VuCollection::Remove
EXTRN	?Find@VuCollection@@QBE_NPAVVuEntity@@@Z:PROC	; VuCollection::Find
EXTRN	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Insert
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetFirst
EXTRN	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetNext
EXTRN	?Save@FalconEntity@@UAEHPAU_iobuf@@@Z:PROC	; FalconEntity::Save
EXTRN	?CleanupData@FalconEntity@@UAEXXZ:PROC		; FalconEntity::CleanupData
EXTRN	?RemovalCallback@FalconEntity@@UAEHXZ:PROC	; FalconEntity::RemovalCallback
EXTRN	?GetDomain@FalconEntity@@UAEEXZ:PROC		; FalconEntity::GetDomain
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z:PROC ; FalconEntity::MakeDirty
EXTRN	??0TailInsertList@@QAE@PAVVuFilter@@@Z:PROC	; TailInsertList::TailInsertList
EXTRN	?ForcedInsert@TailInsertList@@QAEHPAVVuEntity@@@Z:PROC ; TailInsertList::ForcedInsert
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?GetWeaponStrength@@YAHH@Z:PROC			; GetWeaponStrength
EXTRN	?GetWeaponRange@@YAHHH@Z:PROC			; GetWeaponRange
EXTRN	?GetWeaponFireRate@@YAHH@Z:PROC			; GetWeaponFireRate
EXTRN	?GetWeaponHitChance@@YAHHH@Z:PROC		; GetWeaponHitChance
EXTRN	?GetWeaponHitChance@@YAHHHH@Z:PROC		; GetWeaponHitChance
EXTRN	?GetWeaponScore@@YAHHHH@Z:PROC			; GetWeaponScore
EXTRN	?GetWeaponScore@@YAHHPAEHH@Z:PROC		; GetWeaponScore
EXTRN	?GetWeaponDamageType@@YAHH@Z:PROC		; GetWeaponDamageType
EXTRN	?GetWeaponFlags@@YAHH@Z:PROC			; GetWeaponFlags
EXTRN	?GetClassID@@YAHEEEEEEEE@Z:PROC			; GetClassID
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?GetGroundCover@@YA?AW4CoverType@@PAE@Z:PROC	; GetGroundCover
EXTRN	?GetCell@@YAPAEFF@Z:PROC			; GetCell
EXTRN	??0WayPointClass@@QAE@FFHHKKEH@Z:PROC		; WayPointClass::WayPointClass
EXTRN	??0WayPointClass@@QAE@PAPAEPAJ@Z:PROC		; WayPointClass::WayPointClass
EXTRN	?SaveSize@WayPointClass@@QAEHXZ:PROC		; WayPointClass::SaveSize
EXTRN	?Save@WayPointClass@@QAEHPAPAE@Z:PROC		; WayPointClass::Save
EXTRN	?SetNextWP@WayPointClass@@QAEXPAV1@@Z:PROC	; WayPointClass::SetNextWP
EXTRN	?UnlinkNextWP@WayPointClass@@QAEXXZ:PROC	; WayPointClass::UnlinkNextWP
EXTRN	?InsertWP@WayPointClass@@QAEXPAV1@@Z:PROC	; WayPointClass::InsertWP
EXTRN	?DeleteWP@WayPointClass@@QAEXXZ:PROC		; WayPointClass::DeleteWP
EXTRN	?CloneWP@WayPointClass@@QAEXPAV1@@Z:PROC	; WayPointClass::CloneWP
EXTRN	?DeleteWPList@@YAXPAVWayPointClass@@@Z:PROC	; DeleteWPList
EXTRN	?SetWPTimes@@YAKPAVWayPointClass@@FFHH@Z:PROC	; SetWPTimes
EXTRN	?SetWPSpeed@@YAMPAVWayPointClass@@@Z:PROC	; SetWPSpeed
EXTRN	??_EInvalidBufferException@@UAEPAXI@Z:PROC	; InvalidBufferException::`vector deleting destructor'
EXTRN	?GetTeam@@YAEE@Z:PROC				; GetTeam
EXTRN	?SetBaseFlags@CampBaseClass@@QAEXF@Z:PROC	; CampBaseClass::SetBaseFlags
EXTRN	?SetOwner@CampBaseClass@@UAEXE@Z:PROC		; CampBaseClass::SetOwner
EXTRN	?SetCampId@CampBaseClass@@QAEXF@Z:PROC		; CampBaseClass::SetCampId
EXTRN	?SetComponents@CampBaseClass@@QAEXPAVTailInsertList@@@Z:PROC ; CampBaseClass::SetComponents
EXTRN	?SetDeagOwner@CampBaseClass@@QAEXVVU_ID@@@Z:PROC ; CampBaseClass::SetDeagOwner
EXTRN	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z:PROC ; CampBaseClass::MakeCampBaseDirty
EXTRN	??0CampBaseClass@@QAE@GK@Z:PROC			; CampBaseClass::CampBaseClass
EXTRN	??0CampBaseClass@@QAE@PAPAEPAJ@Z:PROC		; CampBaseClass::CampBaseClass
EXTRN	??1CampBaseClass@@UAE@XZ:PROC			; CampBaseClass::~CampBaseClass
EXTRN	?InitData@CampBaseClass@@UAEXXZ:PROC		; CampBaseClass::InitData
EXTRN	?SaveSize@CampBaseClass@@UAEHXZ:PROC		; CampBaseClass::SaveSize
EXTRN	?Save@CampBaseClass@@UAEHPAPAE@Z:PROC		; CampBaseClass::Save
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuEvent@@@Z:PROC	; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuFullUpdateEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuPositionUpdateEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuEntityCollisionEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuTransferEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Handle@CampBaseClass@@UAEHPAVVuSessionEvent@@@Z:PROC ; CampBaseClass::Handle
EXTRN	?Remove@CampBaseClass@@QAEHXZ:PROC		; CampBaseClass::Remove
EXTRN	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentEntity
EXTRN	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentNumber
EXTRN	?SetLocation@CampBaseClass@@QAEXFF@Z:PROC	; CampBaseClass::SetLocation
EXTRN	?SetAltitude@CampBaseClass@@QAEXH@Z:PROC	; CampBaseClass::SetAltitude
EXTRN	?SetSpotted@CampBaseClass@@QAEXEKH@Z:PROC	; CampBaseClass::SetSpotted
EXTRN	?SetEmitting@CampBaseClass@@QAEXH@Z:PROC	; CampBaseClass::SetEmitting
EXTRN	?SetAggregate@CampBaseClass@@QAEX_N@Z:PROC	; CampBaseClass::SetAggregate
EXTRN	?SetAwake@CampBaseClass@@QAEXH@Z:PROC		; CampBaseClass::SetAwake
EXTRN	?SetInSimLists@CampBaseClass@@QAEXH@Z:PROC	; CampBaseClass::SetInSimLists
EXTRN	?GetEntityClass@@YAFPAVVuEntity@@@Z:PROC	; GetEntityClass
EXTRN	?GetVisualDetectionRange@@YAHH@Z:PROC		; GetVisualDetectionRange
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?CloseCampFile@@YAXPAU_iobuf@@@Z:PROC		; CloseCampFile
EXTRN	?ReadCampFile@@YA?AUCampaignData@@PAD0@Z:PROC	; ReadCampFile
EXTRN	?GetTacticFormation@@YAHH@Z:PROC		; GetTacticFormation
EXTRN	??0FalconUnitMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconUnitMessage::FalconUnitMessage
EXTRN	??0FalconUnitAssignmentMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconUnitAssignmentMessage::FalconUnitAssignmentMessage
EXTRN	??0FalconCampEventMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconCampEventMessage::FalconCampEventMessage
EXTRN	?SendCampUIMessage@@YAXPAVFalconCampEventMessage@@@Z:PROC ; SendCampUIMessage
EXTRN	??_EUnitClass@@UAEPAXI@Z:PROC			; UnitClass::`vector deleting destructor'
EXTRN	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z:PROC ; ATCBrain::InList
EXTRN	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z:PROC ; ATCBrain::AddTraffic
EXTRN	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z:PROC ; ATCBrain::FindFlightTakeoffTime
EXTRN	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z:PROC	; ATCBrain::FindBestTakeoffRunway
EXTRN	?GetSiteRange@ObjectiveClass@@QAEMPAVFalconEntity@@@Z:PROC ; ObjectiveClass::GetSiteRange
EXTRN	?HasRadarRanges@ObjectiveClass@@QAEHXZ:PROC	; ObjectiveClass::HasRadarRanges
EXTRN	?GetGridPath@@YAHPAVBasePathClass@@FFFFHHH@Z:PROC ; GetGridPath
EXTRN	?GetObjectivePath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1HHH@Z:PROC ; GetObjectivePath
EXTRN	?GetMovementCost@@YAMFFW4MoveType@@HE@Z:PROC	; GetMovementCost
EXTRN	?DistSqu@@YAHFFFF@Z:PROC			; DistSqu
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?DistSqu@@YAMMMMM@Z:PROC			; DistSqu
EXTRN	?OctantTo@@YAHMMMM@Z:PROC			; OctantTo
EXTRN	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z:PROC ; FindNearestObjective
EXTRN	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z:PROC	; ConvertSimToGrid
EXTRN	?GetRoE@@YAHEEH@Z:PROC				; GetRoE
EXTRN	?TransferInitiative@@YAXEEH@Z:PROC		; TransferInitiative
EXTRN	?AirExperienceAdjustment@@YAME@Z:PROC		; AirExperienceAdjustment
EXTRN	?AirDefenseExperienceAdjustment@@YAME@Z:PROC	; AirDefenseExperienceAdjustment
EXTRN	?GroundExperienceAdjustment@@YAME@Z:PROC	; GroundExperienceAdjustment
EXTRN	?NavalExperienceAdjustment@@YAME@Z:PROC		; NavalExperienceAdjustment
EXTRN	?CombatBonus@@YAMEVVU_ID@@@Z:PROC		; CombatBonus
EXTRN	?GetEnemyTeam@@YAEE@Z:PROC			; GetEnemyTeam
EXTRN	?GetName@DivisionClass@@QAEPADPADHH@Z:PROC	; DivisionClass::GetName
EXTRN	?GetDivisionByUnit@@YAPAVDivisionClass@@PAVUnitClass@@@Z:PROC ; GetDivisionByUnit
EXTRN	??0BattalionClass@@QAE@PAPAEPAJ@Z:PROC		; BattalionClass::BattalionClass
EXTRN	?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z:PROC ; NewBattalion
EXTRN	??0BrigadeClass@@QAE@PAPAEPAJ@Z:PROC		; BrigadeClass::BrigadeClass
EXTRN	?NewBrigade@@YAPAVBrigadeClass@@H@Z:PROC	; NewBrigade
EXTRN	??0PackageClass@@QAE@PAPAEPAJ@Z:PROC		; PackageClass::PackageClass
EXTRN	?NewPackage@@YAPAVPackageClass@@H@Z:PROC	; NewPackage
EXTRN	?MakeFlightDirty@FlightClass@@QAEXW4Dirty_Flight@@W4Dirtyness@@@Z:PROC ; FlightClass::MakeFlightDirty
EXTRN	??0FlightClass@@QAE@PAPAEPAJ@Z:PROC		; FlightClass::FlightClass
EXTRN	?DetectVs@FlightClass@@QAEHPAVCampBaseClass@@PAMPAH22@Z:PROC ; FlightClass::DetectVs
EXTRN	?PickRandomPilot@FlightClass@@QAEHH@Z:PROC	; FlightClass::PickRandomPilot
EXTRN	?GetAdjustedPlayerSlot@FlightClass@@QAEHH@Z:PROC ; FlightClass::GetAdjustedPlayerSlot
EXTRN	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ:PROC ; FlightClass::GetFlightLeadCallNumber
EXTRN	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ:PROC	; FlightClass::GetFlightLeadVoiceID
EXTRN	?CalculateFuelAvailable@FlightClass@@QAEJH@Z:PROC ; FlightClass::CalculateFuelAvailable
EXTRN	?GetECMFlight@FlightClass@@QAEPAV1@XZ:PROC	; FlightClass::GetECMFlight
EXTRN	?NewFlight@@YAPAVFlightClass@@HPAVUnitClass@@0@Z:PROC ; NewFlight
EXTRN	?RegroupFlight@@YAHPAVFlightClass@@@Z:PROC	; RegroupFlight
EXTRN	?CancelFlight@@YAXPAVFlightClass@@@Z:PROC	; CancelFlight
EXTRN	?UpdateSquadronStatus@@YAXPAVFlightClass@@HH@Z:PROC ; UpdateSquadronStatus
EXTRN	??0SquadronClass@@QAE@PAPAEPAJ@Z:PROC		; SquadronClass::SquadronClass
EXTRN	?NewSquadron@@YAPAVSquadronClass@@H@Z:PROC	; NewSquadron
EXTRN	?SendATMMessage@AirTaskingManagerClass@@QAEXVVU_ID@@EFFFPAXH@Z:PROC ; AirTaskingManagerClass::SendATMMessage
EXTRN	?TimeToMove@@YAKPAVUnitClass@@E@Z:PROC		; TimeToMove
EXTRN	??0TaskForceClass@@QAE@PAPAEPAJ@Z:PROC		; TaskForceClass::TaskForceClass
EXTRN	?NewTaskForce@@YAPAVTaskForceClass@@H@Z:PROC	; NewTaskForce
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?GetFirstPt@@YAHH@Z:PROC			; GetFirstPt
EXTRN	?GetNextPt@@YAHH@Z:PROC				; GetNextPt
EXTRN	?GetQueue@@YAHH@Z:PROC				; GetQueue
EXTRN	??0FalconCampDataMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconCampDataMessage::FalconCampDataMessage
EXTRN	?SetPlayerSquadron@FalconSessionEntity@@QAEXPAVSquadronClass@@@Z:PROC ; FalconSessionEntity::SetPlayerSquadron
EXTRN	?SetPlayerFlight@FalconSessionEntity@@QAEXPAVFlightClass@@@Z:PROC ; FalconSessionEntity::SetPlayerFlight
EXTRN	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z:PROC ; FalconSessionEntity::InSessionBubble
EXTRN	?TargetAz@@YAMPAVFalconEntity@@0@Z:PROC		; TargetAz
EXTRN	?TargetEl@@YAMPAVFalconEntity@@0@Z:PROC		; TargetEl
EXTRN	?AddObjectToSim@@YAPAVSimBaseClass@@PAVSimInitDataClass@@H@Z:PROC ; AddObjectToSim
EXTRN	?SetRemoveFlag@SimBaseClass@@QAEXXZ:PROC	; SimBaseClass::SetRemoveFlag
EXTRN	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconRadioChatterMessage::FalconRadioChatterMessage
EXTRN	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconSimCampMessage::FalconSimCampMessage
EXTRN	??0FalconFlightPlanMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconFlightPlanMessage::FalconFlightPlanMessage
EXTRN	?AddMissCraters@@YAXPAVFalconEntity@@H@Z:PROC	; AddMissCraters
EXTRN	?AddHulk@@YAXPAVFalconEntity@@H@Z:PROC		; AddHulk
EXTRN	?GetSTypeName@@YAPADHHHQAD@Z:PROC		; GetSTypeName
EXTRN	?GetNumberName@@YAPADHPAD@Z:PROC		; GetNumberName
EXTRN	?ReadIndexedString@@YAXHPADH@Z:PROC		; ReadIndexedString
EXTRN	_LZSS_Compress:PROC
EXTRN	_LZSS_Expand:PROC
EXTRN	?AddToCampUnitList@SimulationDriver@@QAEXPAVVuEntity@@@Z:PROC ; SimulationDriver::AddToCampUnitList
EXTRN	?RemoveFromCampUnitList@SimulationDriver@@QAEXPAVVuEntity@@@Z:PROC ; SimulationDriver::RemoveFromCampUnitList
EXTRN	?WakeCampaignBase@SimulationDriver@@QAEXHPAVCampBaseClass@@PAVTailInsertList@@@Z:PROC ; SimulationDriver::WakeCampaignBase
EXTRN	?SleepCampaignFlight@SimulationDriver@@QAEXPAVTailInsertList@@@Z:PROC ; SimulationDriver::SleepCampaignFlight
EXTRN	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z:PROC ; OTWDriverClass::InsertObject
EXTRN	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z:PROC ; OTWDriverClass::RemoveObject
EXTRN	??0DrawablePoint@@QAE@KHPBUTpoint@@M@Z:PROC	; DrawablePoint::DrawablePoint
EXTRN	?GetMEA@TMap@@QAEMMM@Z:PROC			; TMap::GetMEA
EXTRN	?AdjustClassId@DogfightClass@@QAEHHH@Z:PROC	; DogfightClass::AdjustClassId
EXTRN	?CheckPlayerStatus@GameManagerClass@@QAEHPAVFalconEntity@@@Z:PROC ; GameManagerClass::CheckPlayerStatus
EXTRN	?UI_Refresh@@YAXXZ:PROC				; UI_Refresh
EXTRN	?update_active_flight@@YAXPAVUnitClass@@@Z:PROC	; update_active_flight
EXTRN	?EvaluateKill@@YAXPAVFalconDeathMessage@@PAVSimBaseClass@@PAVCampBaseClass@@12@Z:PROC ; EvaluateKill
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuLocalSession@@3VVU_ID@@A:QWORD		; vuLocalSession
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?FalconNothingFilter@@3VFalconNothingFilterType@@A:DWORD ; FalconNothingFilter
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?PtHeaderDataTable@@3PAUPtHeaderDataType@@A:DWORD ; PtHeaderDataTable
EXTRN	?PtDataTable@@3PAUPtDataType@@A:DWORD		; PtDataTable
EXTRN	?SimWeaponDataTable@@3PAUSimWeaponDataType@@A:DWORD ; SimWeaponDataTable
EXTRN	?DDP@@3PAUDirtyDataClassType@@A:DWORD		; DDP
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?Map_Max_X@@3FA:WORD				; Map_Max_X
EXTRN	?Map_Max_Y@@3FA:WORD				; Map_Max_Y
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?gDamageStatusBuffer@@3PAEA:BYTE		; gDamageStatusBuffer
EXTRN	?gDamageStatusPtr@@3PAEA:DWORD			; gDamageStatusPtr
EXTRN	?dx@@3PAFA:BYTE					; dx
EXTRN	?dy@@3PAFA:BYTE					; dy
EXTRN	?campCritical@@3PAUF4CSECTIONHANDLE@@A:DWORD	; campCritical
EXTRN	?VisualDetectionRange@@3PAHA:BYTE		; VisualDetectionRange
EXTRN	?DefaultDamageMods@@3PAEA:BYTE			; DefaultDamageMods
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?gCampDataVersion@@3HA:DWORD			; gCampDataVersion
EXTRN	?AllUnitList@@3PAVVuLinkedList@@A:DWORD		; AllUnitList
EXTRN	?AllAirList@@3PAVVuLinkedList@@A:DWORD		; AllAirList
EXTRN	?AllParentList@@3PAVVuLinkedList@@A:DWORD	; AllParentList
EXTRN	?AllRealList@@3PAVVuLinkedList@@A:DWORD		; AllRealList
EXTRN	?InactiveList@@3PAVVuLinkedList@@A:DWORD	; InactiveList
EXTRN	?deaggregatedEntities@@3PAVVuHashTable@@A:DWORD	; deaggregatedEntities
EXTRN	?RealUnitProxList@@3PAVVuGridTree@@A:DWORD	; RealUnitProxList
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?GROUND_PATH_MAX@@3FA:WORD			; GROUND_PATH_MAX
EXTRN	?OBJ_GROUND_PATH_MAX_SEARCH@@3FA:WORD		; OBJ_GROUND_PATH_MAX_SEARCH
EXTRN	?MINIMUM_STRENGTH@@3FA:WORD			; MINIMUM_STRENGTH
EXTRN	?MAX_DAMAGE_TRIES@@3FA:WORD			; MAX_DAMAGE_TRIES
EXTRN	?REAGREGATION_RATIO@@3MA:DWORD			; REAGREGATION_RATIO
EXTRN	?ActionTimeOut@@3HA:DWORD			; ActionTimeOut
EXTRN	?CampBugFixes@@3HA:DWORD			; CampBugFixes
EXTRN	?HitChanceAir@@3MA:DWORD			; HitChanceAir
EXTRN	?HitChanceGround@@3MA:DWORD			; HitChanceGround
EXTRN	?gUnitNameFormat@@3PADA:BYTE			; gUnitNameFormat
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?TheMap@@3VTMap@@A:BYTE				; TheMap
EXTRN	?SimDogfight@@3VDogfightClass@@A:BYTE		; SimDogfight
EXTRN	?GameManager@@3VGameManagerClass@@A:BYTE	; GameManager
EXTRN	?gLangIDNum@@3HA:DWORD				; gLangIDNum
EXTRN	?RadarDataTable@@3PAURadarDataType@@A:DWORD	; RadarDataTable
EXTRN	?missileDataset@@3PAVMissileDataSetClass@@A:DWORD ; missileDataset
EXTRN	?numMissileDatasets@@3HA:DWORD			; numMissileDatasets
EXTRN	?g_bLimit2DRadarFight@@3_NA:BYTE		; g_bLimit2DRadarFight
EXTRN	?g_nDeagTimer@@3HA:DWORD			; g_nDeagTimer
EXTRN	?MIN_DEAD_PCT@@3MA:DWORD			; MIN_DEAD_PCT
EXTRN	?theirDomain@@3HA:DWORD				; theirDomain
EXTRN	?maxSearch@@3HA:DWORD				; maxSearch
EXTRN	?gRocketId@@3FA:WORD				; gRocketId
EXTRN	?TeamSimColorList@@3PAJA:BYTE			; TeamSimColorList
EXTRN	?g_bFireOntheMove@@3_NA:BYTE			; g_bFireOntheMove
EXTRN	?g_bRealisticAttrition@@3_NA:BYTE		; g_bRealisticAttrition
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c65ac000
CONST	SEGMENT
__real@c65ac000 DD 0c65ac000r			; -14000
CONST	ENDS
;	COMDAT __real@c4fa0000
CONST	SEGMENT
__real@c4fa0000 DD 0c4fa0000r			; -2000
CONST	ENDS
;	COMDAT __real@c3fa0000
CONST	SEGMENT
__real@c3fa0000 DD 0c3fa0000r			; -500
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf060a91
CONST	SEGMENT
__real@bf060a91 DD 0bf060a91r			; -0.523599
CONST	ENDS
;	COMDAT __real@4a5bba00
CONST	SEGMENT
__real@4a5bba00 DD 04a5bba00r			; 3.6e+006
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@40437a13
CONST	SEGMENT
__real@40437a13 DD 040437a13r			; 3.05433
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40100000
CONST	SEGMENT
__real@40100000 DD 040100000r			; 2.25
CONST	ENDS
;	COMDAT __real@3fdf66f1
CONST	SEGMENT
__real@3fdf66f1 DD 03fdf66f1r			; 1.74533
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fb2b8c1
CONST	SEGMENT
__real@3fb2b8c1 DD 03fb2b8c1r			; 1.39626
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidBufferException@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidBufferException@@8 DD FLAT:??_R0?AVInvalidBufferException@@@8 ; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidBufferException@@8
rdata$r	SEGMENT
??_R2InvalidBufferException@@8 DD FLAT:??_R1A@?0A@EA@InvalidBufferException@@8 ; InvalidBufferException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@out_of_range@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidBufferException@@8
rdata$r	SEGMENT
??_R3InvalidBufferException@@8 DD 00H			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidBufferException@@6B@
rdata$r	SEGMENT
??_R4InvalidBufferException@@6B@ DD 00H			; InvalidBufferException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2VuEntity@@8
rdata$r	SEGMENT
??_R2VuEntity@@8 DD FLAT:??_R1A@?0A@EA@VuEntity@@8	; VuEntity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuEntity@@8
rdata$r	SEGMENT
??_R3VuEntity@@8 DD 00H					; VuEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuEntity@@@8
_DATA	SEGMENT
??_R0?AVVuEntity@@@8 DD FLAT:??_7type_info@@6B@		; VuEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuEntity@@8 DD FLAT:??_R0?AVVuEntity@@@8	; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FalconEntity@@8
rdata$r	SEGMENT
??_R2FalconEntity@@8 DD FLAT:??_R1A@?0A@EA@FalconEntity@@8 ; FalconEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3FalconEntity@@8
rdata$r	SEGMENT
??_R3FalconEntity@@8 DD 00H				; FalconEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFalconEntity@@@8
_DATA	SEGMENT
??_R0?AVFalconEntity@@@8 DD FLAT:??_7type_info@@6B@	; FalconEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFalconEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FalconEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FalconEntity@@8 DD FLAT:??_R0?AVFalconEntity@@@8 ; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2CampBaseClass@@8
rdata$r	SEGMENT
??_R2CampBaseClass@@8 DD FLAT:??_R1A@?0A@EA@CampBaseClass@@8 ; CampBaseClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3CampBaseClass@@8
rdata$r	SEGMENT
??_R3CampBaseClass@@8 DD 00H				; CampBaseClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CampBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCampBaseClass@@@8
_DATA	SEGMENT
??_R0?AVCampBaseClass@@@8 DD FLAT:??_7type_info@@6B@	; CampBaseClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCampBaseClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CampBaseClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CampBaseClass@@8 DD FLAT:??_R0?AVCampBaseClass@@@8 ; CampBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CampBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@UnitClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UnitClass@@8 DD FLAT:??_R0?AVUnitClass@@@8 ; UnitClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R2UnitClass@@8
rdata$r	SEGMENT
??_R2UnitClass@@8 DD FLAT:??_R1A@?0A@EA@UnitClass@@8	; UnitClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CampBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3UnitClass@@8
rdata$r	SEGMENT
??_R3UnitClass@@8 DD 00H				; UnitClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUnitClass@@@8
_DATA	SEGMENT
??_R0?AVUnitClass@@@8 DD FLAT:??_7type_info@@6B@	; UnitClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUnitClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4UnitClass@@6B@
rdata$r	SEGMENT
??_R4UnitClass@@6B@ DD 00H				; UnitClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVUnitClass@@@8
	DD	FLAT:??_R3UnitClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDANDILB@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03JDANDILB@?$CFd?5?$AA@ DB '%d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LACJBFNH@Encode?5Unit?5Data?5?$CFd?5?$DN?$DO?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@LACJBFNH@Encode?5Unit?5Data?5?$CFd?5?$DN?$DO?5?$CFd?6?$AA@ DB 'E'
	DB	'ncode Unit Data %d => %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JMEEBPII@Count?$DN?$CF1d?0Size?$DN?$CF1ld?6?$AA@
CONST	SEGMENT
??_C@_0BF@JMEEBPII@Count?$DN?$CF1d?0Size?$DN?$CF1ld?6?$AA@ DB 'Count=%1d,'
	DB	'Size=%1ld', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@
CONST	SEGMENT
??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@ DB 'Type conflict'
	DB	' while creating unit.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HECMEGIJ@uni?$AA@
CONST	SEGMENT
??_C@_03HECMEGIJ@uni?$AA@ DB 'uni', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMBOBMNN@Nothing?$AA@
CONST	SEGMENT
??_C@_07MMBOBMNN@Nothing?$AA@ DB 'Nothing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FIGMOKMC@Unit?5?$CFd?5dropping?5off?5unit?5?$CFd?5at?5@
CONST	SEGMENT
??_C@_0CI@FIGMOKMC@Unit?5?$CFd?5dropping?5off?5unit?5?$CFd?5at?5@ DB 'Uni'
	DB	't %d dropping off unit %d at %d,%d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CFBAPBAH@Unit?5?$CFd?5picking?5up?5unit?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@CFBAPBAH@Unit?5?$CFd?5picking?5up?5unit?5?$CFd?4?6?$AA@ DB 'Uni'
	DB	't %d picking up unit %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHBCIDIG@Cargo?5is?5missing?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BD@HHBCIDIG@Cargo?5is?5missing?$CB?6?$AA@ DB 'Cargo is missing!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLFIICBM@?$CFs?5?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_07LLFIICBM@?$CFs?5?$CFs?$CFs?$AA@ DB '%s %s%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPEHIMMI@?$CFs?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08EPEHIMMI@?$CFs?5?$CFs?5?$CFs?$AA@ DB '%s %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JKDKHHG@battalion?5heir?5will?5exceed?6?$AA@
CONST	SEGMENT
??_C@_0BM@JKDKHHG@battalion?5heir?5will?5exceed?6?$AA@ DB 'battalion heir'
	DB	' will exceed', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOFFLAKG@?$CF08x?5Waypoints?5?$AA@
CONST	SEGMENT
??_C@_0BA@BOFFLAKG@?$CF08x?5Waypoints?5?$AA@ DB '%08x Waypoints ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NIOPHDFC@?$CF08x?5UnitClass?5?$AA@
CONST	SEGMENT
??_C@_0BA@NIOPHDFC@?$CF08x?5UnitClass?5?$AA@ DB '%08x UnitClass ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7UnitClass@@6B@
CONST	SEGMENT
??_7UnitClass@@6B@ DD FLAT:??_R4UnitClass@@6B@		; UnitClass::`vftable'
	DD	FLAT:?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z
	DD	FLAT:?TerrainCollisionCheck@VuEntity@@UAEEXZ
	DD	FLAT:?IsTarget@VuEntity@@UAEEXZ
	DD	FLAT:?IsSession@VuEntity@@UAEEXZ
	DD	FLAT:?IsGroup@VuEntity@@UAEEXZ
	DD	FLAT:?IsGame@VuEntity@@UAEEXZ
	DD	FLAT:?IsCamera@VuEntity@@UBEEXZ
	DD	FLAT:?SaveSize@UnitClass@@UAEHXZ
	DD	FLAT:?Save@FalconEntity@@UAEHPAU_iobuf@@@Z
	DD	FLAT:?Save@UnitClass@@UAEHPAPAE@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuSessionEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuTransferEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuEntityCollisionEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@UnitClass@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@CampBaseClass@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z
	DD	FLAT:??_EUnitClass@@UAEPAXI@Z
	DD	FLAT:?InsertionCallback@VuEntity@@MAEHXZ
	DD	FLAT:?RemovalCallback@FalconEntity@@UAEHXZ
	DD	FLAT:?InitData@CampBaseClass@@UAEXXZ
	DD	FLAT:?CleanupData@FalconEntity@@UAEXXZ
	DD	FLAT:?IsSimBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?IsCampBase@CampBaseClass@@UAE_NXZ
	DD	FLAT:?Wake@UnitClass@@UAEHXZ
	DD	FLAT:?Sleep@UnitClass@@UAEHXZ
	DD	FLAT:?GetCampID@CampBaseClass@@UAEFXZ
	DD	FLAT:?GetTeam@CampBaseClass@@UAEEXZ
	DD	FLAT:?GetCountry@CampBaseClass@@UAEEXZ
	DD	FLAT:?GetDomain@FalconEntity@@UAEEXZ
	DD	FLAT:?GetRadarMode@FalconEntity@@UAEHXZ
	DD	FLAT:?SetRadarMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?ReturnToSearch@FalconEntity@@UAEXXZ
	DD	FLAT:?SetSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?CombatClass@FalconEntity@@UAEHXZ
	DD	FLAT:?OnGround@CampBaseClass@@UAEHXZ
	DD	FLAT:?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z
	DD	FLAT:?IsMissile@FalconEntity@@UAEHXZ
	DD	FLAT:?IsLauncher@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBomb@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGun@FalconEntity@@UAEHXZ
	DD	FLAT:?IsMover@FalconEntity@@UAEHXZ
	DD	FLAT:?IsVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsStatic@FalconEntity@@UAEHXZ
	DD	FLAT:?IsHelicopter@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEject@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAirplane@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGroundVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsShip@FalconEntity@@UAEHXZ
	DD	FLAT:?IsWeapon@FalconEntity@@UAEHXZ
	DD	FLAT:?IsExploding@FalconEntity@@UAEHXZ
	DD	FLAT:?IsDead@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEmitting@CampBaseClass@@UAEHXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ
	DD	FLAT:?IsUnit@UnitClass@@UAEHXZ
	DD	FLAT:?IsObjective@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBattalion@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBrigade@FalconEntity@@UAEHXZ
	DD	FLAT:?IsFlight@FalconEntity@@UBEHXZ
	DD	FLAT:?IsSquadron@FalconEntity@@UAEHXZ
	DD	FLAT:?IsPackage@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTeam@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTaskForce@FalconEntity@@UAEHXZ
	DD	FLAT:?IsSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?GetRCSFactor@UnitClass@@UAEMXZ
	DD	FLAT:?GetIRFactor@UnitClass@@UAEMXZ
	DD	FLAT:?GetRadarType@UnitClass@@UAEHXZ
	DD	FLAT:?GetDamageModifiers@UnitClass@@UAEPAEXZ
	DD	FLAT:?SetAQUIREtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetSEARCHtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetStepSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?GetAQUIREtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?GetSEARCHtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?SetOwner@CampBaseClass@@UAEXE@Z
	DD	FLAT:?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z
	DD	FLAT:?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z
	DD	FLAT:?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	FLAT:?InsertInSimLists@UnitClass@@UAEXMM@Z
	DD	FLAT:?RemoveFromSimLists@UnitClass@@UAEXXZ
	DD	FLAT:?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z
	DD	FLAT:?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z
	DD	FLAT:?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z
	DD	FLAT:?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z
	DD	FLAT:?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z
	DD	FLAT:?GetName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetFullName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetDivisionName@UnitClass@@UAEPADPADHH@Z
	DD	FLAT:?GetHitChance@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetAproxHitChance@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetCombatStrength@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetAproxCombatStrength@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z
	DD	FLAT:?GetAproxWeaponRange@UnitClass@@UAEHH@Z
	DD	FLAT:?GetDetectionRange@UnitClass@@UAEHH@Z
	DD	FLAT:?GetElectronicDetectionRange@UnitClass@@UAEHH@Z
	DD	FLAT:?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z
	DD	FLAT:?StepRadar@CampBaseClass@@UAEHHHM@Z
	DD	FLAT:?GetNumberOfArcs@UnitClass@@UAEHXZ
	DD	FLAT:?GetArcRatio@UnitClass@@UAEMH@Z
	DD	FLAT:?GetArcRange@UnitClass@@UAEMH@Z
	DD	FLAT:?GetArcAngle@UnitClass@@UAEXHPAM0@Z
	DD	FLAT:?GetMissilesFlying@CampBaseClass@@UAEHXZ
	DD	FLAT:?ResetPlayerStatus@UnitClass@@UAEHXZ
	DD	FLAT:?GetComponentLocation@UnitClass@@UAEXPAF0H@Z
	DD	FLAT:?GetComponentAltitude@UnitClass@@UAEHH@Z
	DD	FLAT:?CanShootWeapon@UnitClass@@UAEHH@Z
	DD	FLAT:?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z
	DD	FLAT:?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ
	DD	FLAT:?ShouldDeaggregate@UnitClass@@UAEHXZ
	DD	FLAT:?ClearDeaggregationData@UnitClass@@UAEXXZ
	DD	FLAT:?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z
	DD	FLAT:?MoveUnit@UnitClass@@UAEHK@Z
	DD	FLAT:?DoCombat@UnitClass@@UAEHXZ
	DD	FLAT:?ChooseTactic@UnitClass@@UAEHXZ
	DD	FLAT:?CheckTactic@UnitClass@@UAEHH@Z
	DD	FLAT:?Father@UnitClass@@UBEHXZ
	DD	FLAT:?Real@UnitClass@@UAEHXZ
	DD	FLAT:?AdjustForSupply@UnitClass@@UAEMXZ
	DD	FLAT:?GetUnitSpeed@UnitClass@@UBEHXZ
	DD	FLAT:?DetectOnMove@UnitClass@@UAEHXZ
	DD	FLAT:?ChooseTarget@UnitClass@@UAEHXZ
	DD	FLAT:__purecall
	DD	FLAT:?CombatTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetUnitSupplyNeed@UnitClass@@UAEHH@Z
	DD	FLAT:?GetUnitFuelNeed@UnitClass@@UAEHH@Z
	DD	FLAT:?SupplyUnit@UnitClass@@UAEXHH@Z
	DD	FLAT:?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z
	DD	FLAT:?IsDead@UnitClass@@UBEHXZ
	DD	FLAT:?SimSetLocation@UnitClass@@UAEXMMM@Z
	DD	FLAT:?SimSetOrientation@UnitClass@@UAEXMMM@Z
	DD	FLAT:?GetRealPosition@UnitClass@@UAEXPAM00@Z
	DD	FLAT:?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z
	DD	FLAT:?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z
	DD	FLAT:?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z
	DD	FLAT:?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z
	DD	FLAT:?GetUnitWeaponId@UnitClass@@UAEHHH@Z
	DD	FLAT:?GetUnitWeaponCount@UnitClass@@UAEHHH@Z
	DD	FLAT:?SetUnitLastMove@UnitClass@@UAEXK@Z
	DD	FLAT:?SetCombatTime@UnitClass@@UAEXK@Z
	DD	FLAT:?SetBurntFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitMission@UnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitRole@UnitClass@@UAEXE@Z
	DD	FLAT:?SetUnitPriority@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMissionID@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMissionTarget@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitTOT@UnitClass@@UAEXK@Z
	DD	FLAT:?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z
	DD	FLAT:?GetNumberOfLoadouts@UnitClass@@UAEHXZ
	DD	FLAT:?GetMoveTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetCombatTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ
	DD	FLAT:?GetBurntFuel@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ
	DD	FLAT:?GetUnitNormalRole@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitCurrentRole@UnitClass@@UBEHXZ
	DD	FLAT:?GetUnitPriority@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ
	DD	FLAT:?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitMissionID@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitTOT@UnitClass@@UAEKXZ
	DD	FLAT:?GetUnitSquadron@UnitClass@@UAEPAV1@XZ
	DD	FLAT:?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ
	DD	FLAT:?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z
	DD	FLAT:?DumpWeapons@UnitClass@@UAEHXZ
	DD	FLAT:?ETA@UnitClass@@UAEKXZ
	DD	FLAT:?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ
	DD	FLAT:?BuildMission@UnitClass@@UAEHXZ
	DD	FLAT:?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z
	DD	FLAT:?IncrementTime@UnitClass@@UAEXK@Z
	DD	FLAT:?UseFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitSpecialty@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitSupply@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMorale@UnitClass@@UAEXH@Z
	DD	FLAT:?SetSquadronFuel@UnitClass@@UAEXJ@Z
	DD	FLAT:?SetUnitStores@UnitClass@@UAEXHE@Z
	DD	FLAT:?SetLastResupply@UnitClass@@UAEXH@Z
	DD	FLAT:?SetLastResupplyTime@UnitClass@@UAEXK@Z
	DD	FLAT:?GetUnitSpecialty@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitSupply@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMorale@UnitClass@@UAEHXZ
	DD	FLAT:?GetSquadronFuel@UnitClass@@UAEJXZ
	DD	FLAT:?GetUnitStores@UnitClass@@UAEEH@Z
	DD	FLAT:?GetLastResupplyTime@UnitClass@@UAEKXZ
	DD	FLAT:?GetLastResupply@UnitClass@@UAEHXZ
	DD	FLAT:?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z
	DD	FLAT:?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z
	DD	FLAT:?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z
	DD	FLAT:?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z
	DD	FLAT:?SetUnitPrimaryObj@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitSecondaryObj@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitObjective@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z
	DD	FLAT:?SetUnitOrders@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitFatigue@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitMode@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitPosition@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitDivision@UnitClass@@UAEXH@Z
	DD	FLAT:?SetUnitHeading@UnitClass@@UAEXH@Z
	DD	FLAT:?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitSecondaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitObjective@UnitClass@@UAEPAVObjectiveClass@@XZ
	DD	FLAT:?GetUnitPrimaryObjID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitSecondaryObjID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitObjectiveID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?GetUnitOrders@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitFatigue@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitElement@UnitClass@@UAEPAV1@H@Z
	DD	FLAT:?GetUnitElement@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitMode@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitPosition@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitDivision@UnitClass@@UAEHXZ
	DD	FLAT:?GetUnitHeading@UnitClass@@UAEHXZ
	DD	FLAT:?SetUnitNextMove@UnitClass@@UAEXXZ
	DD	FLAT:?ClearUnitPath@UnitClass@@UAEXXZ
	DD	FLAT:?GetNextMoveDirection@UnitClass@@UAEHXZ
	DD	FLAT:?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z
	DD	FLAT:?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z
	DD	FLAT:?GetObjMovementType@UnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z
	DD	FLAT:?CheckForSurrender@UnitClass@@UAEHXZ
	DD	FLAT:?RallyUnit@UnitClass@@UAEHH@Z
	DD	FLAT:?GetUnitParent@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetUnitParent@UnitClass@@UAEXPAV1@@Z
	DD	FLAT:?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetNextUnitElement@UnitClass@@UBEPAV1@XZ
	DD	FLAT:?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z
	DD	FLAT:?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z
	DD	FLAT:?AddUnitChild@UnitClass@@UAEXPAV1@@Z
	DD	FLAT:?DisposeChildren@UnitClass@@UAEXXZ
	DD	FLAT:?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?ReorganizeUnit@UnitClass@@UAEXXZ
	DD	FLAT:?UpdateParentStatistics@UnitClass@@UAEHXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0InvalidBufferException@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVInvalidBufferException@@@8
_DATA	SEGMENT
??_R0?AVInvalidBufferException@@@8 DD FLAT:??_7type_info@@6B@ ; InvalidBufferException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidBufferException@@', 00H
_DATA	ENDS
;	COMDAT __CTA4?AVInvalidBufferException@@
xdata$x	SEGMENT
__CTA4?AVInvalidBufferException@@ DD 04H
	DD	FLAT:__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVInvalidBufferException@@
xdata$x	SEGMENT
__TI4?AVInvalidBufferException@@ DD 00H
	DD	FLAT:??1InvalidBufferException@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVInvalidBufferException@@
xdata$x	ENDS
;	COMDAT ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
CONST	SEGMENT
??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ DB 'Tryi'
	DB	'ng to write %lu bytes to %ld buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7InvalidBufferException@@6B@
CONST	SEGMENT
??_7InvalidBufferException@@6B@ DD FLAT:??_R4InvalidBufferException@@6B@ ; InvalidBufferException::`vftable'
	DD	FLAT:??_EInvalidBufferException@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z$0
__unwindtable$?FindUnitNameID@@YAHPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitNameID@@YAHPAVUnitClass@@@Z$0
__unwindtable$?GetDivisionName@@YAPADHPADHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDivisionName@@YAPADHPADHH@Z$0
__unwindtable$?LoadUnits@@YAHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadUnits@@YAHPAD@Z$0
__unwindtable$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z$0
__unwindtable$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z$0
__unwindtable$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z$0
__unwindtable$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z$0
__unwindtable$?KillUnit@UnitClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?KillUnit@UnitClass@@QAEXXZ$0
__unwindtable$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z$0
__unwindtable$?SetBroken@UnitClass@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetBroken@UnitClass@@QAEXH@Z$0
__unwindtable$?SetDead@UnitClass@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetDead@UnitClass@@QAEXH@Z$0
__unwindtable$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z$0
__unwindtable$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z$0
__unwindtable$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z$0
__unwindtable$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z$0
__unwindtable$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$0
__unwindtable$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$0
__unwindtable$??1UnitClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1UnitClass@@UAE@XZ$0
__unwindtable$??0UnitClass@@QAE@PAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0UnitClass@@QAE@PAPAEPAJ@Z$0
__unwindtable$??0UnitClass@@QAE@GK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0UnitClass@@QAE@GK@Z$0
__unwindtable$?MakeWaypointsDirty@UnitClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeWaypointsDirty@UnitClass@@QAEXXZ$0
__unwindtable$?UnloadUnit@UnitClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UnloadUnit@UnitClass@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UnloadUnit@UnitClass@@QAEXXZ$1
__unwindtable$?InsertInSimLists@UnitClass@@UAEXMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InsertInSimLists@UnitClass@@UAEXMM@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InsertInSimLists@UnitClass@@UAEXMM@Z$1
__unwindtable$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z$1
__unwindtable$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z$2
__unwindtable$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$2
__unwindtable$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z$2
__unwindtable$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$3
__ehfuncinfo$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?FindUnitNameID@@YAHPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindUnitNameID@@YAHPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?GetDivisionName@@YAPADHPADHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDivisionName@@YAPADHPADHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?LoadUnits@@YAHPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadUnits@@YAHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?UnloadUnit@UnitClass@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UnloadUnit@UnitClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?KillUnit@UnitClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?KillUnit@UnitClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SetBroken@UnitClass@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetBroken@UnitClass@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SetDead@UnitClass@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetDead@UnitClass@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?InsertInSimLists@UnitClass@@UAEXMM@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InsertInSimLists@UnitClass@@UAEXMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1UnitClass@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1UnitClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0UnitClass@@QAE@PAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0UnitClass@@QAE@PAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0UnitClass@@QAE@GK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0UnitClass@@QAE@GK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?MakeWaypointsDirty@UnitClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MakeWaypointsDirty@UnitClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0
__ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -48						; size = 8
_pt$ = -40						; size = 4
_prevPt$ = -36						; size = 4
_parkPt$ = -32						; size = 4
_w$ = -28						; size = 4
_takeoff_time$ = -24					; size = 4
_info$ = -20						; size = 4
_rwindex$ = -16						; size = 4
_time_til_takeoff$ = -12				; size = 4
_tp$ = -8						; size = 4
_goanyway$ = -1						; size = 1
_flight$ = 8						; size = 4
_airbase$ = 12						; size = 4
_checklist$ = 16					; size = 4
?FindTaxiPt@@YAHPAVFlightClass@@PAVObjectiveClass@@H@Z PROC ; FindTaxiPt

; 5066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi

; 5067 : 	int		time_til_takeoff=0,tp,rwindex = 0, pt, parkPt;			// in 10 second blocks

	mov	DWORD PTR _time_til_takeoff$[ebp], 0
	mov	DWORD PTR _rwindex$[ebp], 0

; 5068 : 	bool goanyway = false;

	mov	BYTE PTR _goanyway$[ebp], 0

; 5069 : 	ulong		takeoff_time;
; 5070 : 	pt = 0; // Cobra

	mov	DWORD PTR _pt$[ebp], 0

; 5071 : 
; 5072 : 	WayPoint	w;
; 5073 : 	runwayQueueStruct *info = NULL;	

	mov	DWORD PTR _info$[ebp], 0

; 5074 : 
; 5075 : 	w = flight->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 5076 : 	if(checklist && airbase && airbase->brain)

	cmp	DWORD PTR _checklist$[ebp], 0
	je	SHORT $LN21@FindTaxiPt
	cmp	DWORD PTR _airbase$[ebp], 0
	je	SHORT $LN21@FindTaxiPt
	mov	eax, DWORD PTR _airbase$[ebp]
	cmp	DWORD PTR [eax+240], 0
	je	SHORT $LN21@FindTaxiPt

; 5077 : 		info = airbase->brain->InList(flight->Id());

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax
$LN21@FindTaxiPt:

; 5078 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN20@FindTaxiPt

; 5079 : 	{
; 5080 : 		rwindex = info->rwindex;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _rwindex$[ebp], eax

; 5081 : 		takeoff_time = info->schedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _takeoff_time$[ebp], edx

; 5082 : 	}
; 5083 : 	else

	jmp	SHORT $LN19@FindTaxiPt
$LN20@FindTaxiPt:

; 5084 : 	{
; 5085 : 		if (airbase && airbase->brain)

	cmp	DWORD PTR _airbase$[ebp], 0
	je	SHORT $LN18@FindTaxiPt
	mov	eax, DWORD PTR _airbase$[ebp]
	cmp	DWORD PTR [eax+240], 0
	je	SHORT $LN18@FindTaxiPt

; 5086 : 			rwindex = airbase->brain->FindBestTakeoffRunway(checklist);

	mov	ecx, DWORD PTR _checklist$[ebp]
	push	ecx
	mov	edx, DWORD PTR _airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _rwindex$[ebp], eax
$LN18@FindTaxiPt:

; 5087 : 		takeoff_time = w->GetWPDepartureTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _takeoff_time$[ebp], eax
$LN19@FindTaxiPt:

; 5088 : 	}
; 5089 : 
; 5090 : 	if(!rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	jne	SHORT $LN17@FindTaxiPt

; 5091 : 		return DPT_ERROR_CANT_PLACE; // Error, runway is toast

	mov	eax, -2					; fffffffeH
	jmp	$LN22@FindTaxiPt
$LN17@FindTaxiPt:

; 5092 : 
; 5093 : 	if (takeoff_time > SimLibElapsedTime && w->GetWPAction() == WP_TAKEOFF)

	mov	eax, DWORD PTR _takeoff_time$[ebp]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jbe	SHORT $LN16@FindTaxiPt
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN16@FindTaxiPt

; 5094 : 		time_til_takeoff = (takeoff_time - SimLibElapsedTime) / (TAKEOFF_TIME_DELTA);

	mov	eax, DWORD PTR _takeoff_time$[ebp]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	xor	edx, edx
	mov	ecx, 10000				; 00002710H
	div	ecx
	mov	DWORD PTR _time_til_takeoff$[ebp], eax
$LN16@FindTaxiPt:

; 5095 : 	// JPO - if this is true, we should be able to go anyway.as were after the min deag time.
; 5096 : 	if (g_nDeagTimer > 0 && airbase && airbase->brain && SimLibElapsedTime > w->GetWPArrivalTime() - airbase->brain->MinDeagTime() - CampaignMinutes * g_nDeagTimer)

	cmp	DWORD PTR ?g_nDeagTimer@@3HA, 0		; g_nDeagTimer
	jle	SHORT $LN15@FindTaxiPt
	cmp	DWORD PTR _airbase$[ebp], 0
	je	SHORT $LN15@FindTaxiPt
	mov	edx, DWORD PTR _airbase$[ebp]
	cmp	DWORD PTR [edx+240], 0
	je	SHORT $LN15@FindTaxiPt
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	esi, eax
	mov	eax, DWORD PTR _airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?MinDeagTime@ATCBrain@@QAEKXZ		; ATCBrain::MinDeagTime
	sub	esi, eax
	mov	ecx, DWORD PTR ?g_nDeagTimer@@3HA	; g_nDeagTimer
	imul	ecx, 60000				; 0000ea60H
	sub	esi, ecx
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, esi	; SimLibElapsedTime
	jbe	SHORT $LN15@FindTaxiPt

; 5097 : 		goanyway = true;

	mov	BYTE PTR _goanyway$[ebp], 1
	jmp	SHORT $LN14@FindTaxiPt
$LN15@FindTaxiPt:

; 5098 : 	else if (flight->IsSetFalcFlag(FEC_PLAYER_ENTERING|FEC_HASPLAYERS)) // players go too

	push	20					; 00000014H
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN14@FindTaxiPt

; 5099 : 		goanyway = true;

	mov	BYTE PTR _goanyway$[ebp], 1
$LN14@FindTaxiPt:

; 5100 : 
; 5101 : 	// Cobra - Determine parking/spawning spots later in Aircraft.cpp FindBestSpawningPoint()
; 5102 : 	if (time_til_takeoff > PtHeaderDataTable[rwindex].count) 

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movzx	ecx, BYTE PTR [eax+edx+3]
	cmp	DWORD PTR _time_til_takeoff$[ebp], ecx
	jle	SHORT $LN12@FindTaxiPt

; 5103 : 	{
; 5104 : 		if (!checklist)

	cmp	DWORD PTR _checklist$[ebp], 0
	jne	SHORT $LN11@FindTaxiPt

; 5105 : 			return 0;								// Takeoff longer away than we have taxi pts for

	xor	eax, eax
	jmp	$LN22@FindTaxiPt
$LN11@FindTaxiPt:

; 5106 : 		time_til_takeoff = PtHeaderDataTable[rwindex].count; // JPO - just go in this case

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movzx	ecx, BYTE PTR [eax+edx+3]
	mov	DWORD PTR _time_til_takeoff$[ebp], ecx
$LN12@FindTaxiPt:

; 5107 : 	}
; 5108 : 	// Cobra - FRB - Replaced with my landme.cpp code		
; 5109 : 	if (time_til_takeoff < 0)

	cmp	DWORD PTR _time_til_takeoff$[ebp], 0
	jge	SHORT $LN10@FindTaxiPt

; 5110 : 		time_til_takeoff = 0;

	mov	DWORD PTR _time_til_takeoff$[ebp], 0
$LN10@FindTaxiPt:

; 5111 : 	tp = GetFirstPt(rwindex);

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax

; 5112 : 	int prevPt = tp;

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR _prevPt$[ebp], eax

; 5113 : 	parkPt = -1; // FRB

	mov	DWORD PTR _parkPt$[ebp], -1

; 5114 : 	tp = GetNextPt(tp);	

	mov	ecx, DWORD PTR _tp$[ebp]
	push	ecx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax
$LN9@FindTaxiPt:

; 5115 : 	while (tp && time_til_takeoff){

	cmp	DWORD PTR _tp$[ebp], 0
	je	$LN8@FindTaxiPt
	cmp	DWORD PTR _time_til_takeoff$[ebp], 0
	je	$LN8@FindTaxiPt

; 5116 : 		prevPt = tp;

	mov	edx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR _prevPt$[ebp], edx

; 5117 : 		tp = GetNextPt(tp);	// FRB - Look at all of them

	mov	eax, DWORD PTR _tp$[ebp]
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax

; 5118 : 		if(PtDataTable[tp].type == CritTaxiPt){

	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN7@FindTaxiPt

; 5119 : 			break;

	jmp	SHORT $LN8@FindTaxiPt
$LN7@FindTaxiPt:

; 5120 : 		}
; 5121 : 
; 5122 : 		// 17JAN04 - FRB - Locate a suitable parking spot
; 5123 : 		if ((PtDataTable[tp].type == SmallParkPt) || (PtDataTable[tp].type == LargeParkPt)){

	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN5@FindTaxiPt
	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN6@FindTaxiPt
$LN5@FindTaxiPt:

; 5124 : 			if (PtDataTable[tp].flags & PT_OCCUPIED){

	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	and	eax, 4
	je	SHORT $LN4@FindTaxiPt

; 5125 : 				time_til_takeoff--;

	mov	ecx, DWORD PTR _time_til_takeoff$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], ecx

; 5126 : 				continue;  // Taken

	jmp	$LN9@FindTaxiPt

; 5127 : 			}
; 5128 : 			else {

	jmp	SHORT $LN6@FindTaxiPt
$LN4@FindTaxiPt:

; 5129 : 				parkPt = tp; 

	mov	edx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR _parkPt$[ebp], edx

; 5130 : 				time_til_takeoff--;

	mov	eax, DWORD PTR _time_til_takeoff$[ebp]
	sub	eax, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], eax

; 5131 : 				continue;

	jmp	$LN9@FindTaxiPt
$LN6@FindTaxiPt:

; 5132 : 			}
; 5133 : 		}
; 5134 : 
; 5135 : 		time_til_takeoff--;

	mov	ecx, DWORD PTR _time_til_takeoff$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], ecx

; 5136 : 	}

	jmp	$LN9@FindTaxiPt
$LN8@FindTaxiPt:

; 5137 : 	// 17JAN04 - FRB - Use nearest Parking spot
; 5138 : 	if (parkPt >= 0){

	cmp	DWORD PTR _parkPt$[ebp], 0
	jl	SHORT $LN2@FindTaxiPt

; 5139 : 		tp = parkPt;

	mov	edx, DWORD PTR _parkPt$[ebp]
	mov	DWORD PTR _tp$[ebp], edx

; 5140 : 		return tp;

	mov	eax, DWORD PTR _tp$[ebp]
	jmp	SHORT $LN22@FindTaxiPt
$LN2@FindTaxiPt:

; 5141 : 	}
; 5142 : 
; 5143 : 	if(tp){

	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN1@FindTaxiPt

; 5144 : 		return tp;

	mov	eax, DWORD PTR _tp$[ebp]
	jmp	SHORT $LN22@FindTaxiPt
$LN1@FindTaxiPt:

; 5145 : 	}
; 5146 : 
; 5147 : 	return prevPt;

	mov	eax, DWORD PTR _prevPt$[ebp]
$LN22@FindTaxiPt:

; 5148 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?FindTaxiPt@@YAHPAVFlightClass@@PAVObjectiveClass@@H@Z ENDP ; FindTaxiPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_temp3$ = -68						; size = 20
_temp2$ = -48						; size = 20
_temp1$ = -28						; size = 10
_format$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_div$ = 8						; size = 4
_type$ = 12						; size = 4
_buffer$ = 16						; size = 4
_size$ = 20						; size = 4
_object$ = 24						; size = 4
?GetDivisionName@@YAPADHHPADHH@Z PROC			; GetDivisionName

; 4821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4822 : 	_TCHAR		temp1[10],temp2[20],temp3[20],format[10];
; 4823 : 
; 4824 : 	GetNumberName(div,temp1);

	lea	eax, DWORD PTR _temp1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _div$[ebp]
	push	ecx
	call	?GetNumberName@@YAPADHPAD@Z		; GetNumberName
	add	esp, 8

; 4825 : 	GetSTypeName(DOMAIN_LAND,0,type,temp2);

	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	push	3
	call	?GetSTypeName@@YAPADHHHQAD@Z		; GetSTypeName
	add	esp, 16					; 00000010H

; 4826 : 	_tcscpy(format,"%s %s %s");

	push	OFFSET ??_C@_08EPEHIMMI@?$CFs?5?$CFs?5?$CFs?$AA@
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4827 : 
; 4828 : 	if (gLangIDNum == F4LANG_GERMAN)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 3		; gLangIDNum
	jne	SHORT $LN4@GetDivisio

; 4829 : 	{
; 4830 : 		// Replace space with hyphen, if necessary
; 4831 : 		if (temp2[_tcslen(temp2)-1] == '-')

	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	movsx	eax, BYTE PTR _temp2$[ebp+eax-1]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN4@GetDivisio

; 4832 : 			_tcscpy(format,"%s %s%s");

	push	OFFSET ??_C@_07LLFIICBM@?$CFs?5?$CFs?$CFs?$AA@
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN4@GetDivisio:

; 4833 : 	}
; 4834 : 
; 4835 : 	ReadIndexedString(613, temp3, 19);

	push	19					; 00000013H
	lea	edx, DWORD PTR _temp3$[ebp]
	push	edx
	push	613					; 00000265H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 4836 : 
; 4837 : 	ShiAssert(((int) _tcslen(temp1)+_tcslen(temp2)+_tcslen(temp3)+3) < static_cast<unsigned long>(size));
; 4838 : 
; 4839 : 	if (gLangIDNum >= F4LANG_SPANISH)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 5		; gLangIDNum
	jl	SHORT $LN2@GetDivisio

; 4840 : 		_sntprintf(buffer,size,format,temp1,temp3,temp2);

	lea	eax, DWORD PTR _temp2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp1$[ebp]
	push	edx
	lea	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 24					; 00000018H

; 4841 : 	else

	jmp	SHORT $LN1@GetDivisio
$LN2@GetDivisio:

; 4842 : 		_sntprintf(buffer,size,format,temp1,temp2,temp3);

	lea	eax, DWORD PTR _temp3$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp1$[ebp]
	push	edx
	lea	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 24					; 00000018H
$LN1@GetDivisio:

; 4843 : 
; 4844 : 	// _sntprintf should do this for us, but for some reason it sometimes doesn't
; 4845 : 	buffer[size-1] = 0;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	BYTE PTR [eax-1], 0

; 4846 : 
; 4847 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 4848 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDivisionName@@YAPADHHPADHH@Z ENDP			; GetDivisionName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_it$ = -44						; size = 12
$T2 = -32						; size = 8
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_u$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 8
?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z PROC		; GetUnitByID

; 4713 : Unit GetUnitByID(VU_ID id){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4714 : #if VU_ALL_FILTERED
; 4715 : 	VuListIterator it(AllUnitList);

	mov	eax, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4716 : 	for (VuEntity *u = it.GetFirst(); u != NULL; u = it.GetNext()){

	lea	ecx, DWORD PTR _it$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$5[ebp], eax
	jmp	SHORT $LN4@GetUnitByI
$LN3@GetUnitByI:
	lea	ecx, DWORD PTR _it$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _u$5[ebp], eax
$LN4@GetUnitByI:
	cmp	DWORD PTR _u$5[ebp], 0
	je	SHORT $LN2@GetUnitByI

; 4717 : 		if (u->Id() == id){ return static_cast<Unit>(u); }

	lea	ecx, DWORD PTR _id$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$5[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetUnitByI
	mov	ecx, DWORD PTR _u$5[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _it$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN5@GetUnitByI
$LN1@GetUnitByI:

; 4718 : 	}

	jmp	SHORT $LN3@GetUnitByI
$LN2@GetUnitByI:

; 4719 : 	return NULL;

	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _it$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T3[ebp]
$LN5@GetUnitByI:

; 4720 : #else
; 4721 : 	return (Unit)AllUnitList->Find(id);
; 4722 : #endif
; 4723 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetUnitByID@@YAPAVUnitClass@@VVU_ID@@@Z ENDP		; GetUnitByID
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv177 = -52						; size = 8
_d$ = -44						; size = 4
tv174 = -40						; size = 4
_c$ = -36						; size = 4
_t$ = -32						; size = 4
_w$ = -28						; size = 4
_reqs$ = -24						; size = 4
_maxs$ = -20						; size = 4
_x$ = -16						; size = 2
_y$ = -12						; size = 2
_wx$ = -8						; size = 2
_wy$ = -4						; size = 2
_u$ = 8							; size = 4
?GetArrivalSpeed@@YAHPBVUnitClass@@@Z PROC		; GetArrivalSpeed

; 4765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 4766 : 	WayPoint		w;
; 4767 : 	GridIndex		x,y,wx,wy;
; 4768 : 	float			d;
; 4769 : 	CampaignTime	t,c;
; 4770 : 	int				maxs,reqs;
; 4771 : 
; 4772 : 	if (u->Father())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN6@GetArrival

; 4773 : 		maxs = u->GetFormationCruiseSpeed();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFormationCruiseSpeed@UnitClass@@QBEHXZ ; UnitClass::GetFormationCruiseSpeed
	mov	DWORD PTR _maxs$[ebp], eax

; 4774 : 	else

	jmp	SHORT $LN5@GetArrival
$LN6@GetArrival:

; 4775 : 		maxs = u->GetMaxSpeed();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetMaxSpeed@UnitClass@@QBEHXZ		; UnitClass::GetMaxSpeed
	mov	DWORD PTR _maxs$[ebp], eax
$LN5@GetArrival:

; 4776 : 	w = u->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 4777 : 	if (!w)

	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN4@GetArrival

; 4778 : 		return maxs;

	mov	eax, DWORD PTR _maxs$[ebp]
	jmp	$LN7@GetArrival
$LN4@GetArrival:

; 4779 : 	u->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 4780 : 	w->GetWPLocation(&wx,&wy);

	lea	eax, DWORD PTR _wy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPLocation@WayPointClass@@QBEXPAF0@Z ; WayPointClass::GetWPLocation

; 4781 : 	d = Distance(x,y,wx,wy);

	movzx	edx, WORD PTR _wy$[ebp]
	push	edx
	movzx	eax, WORD PTR _wx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _d$[ebp]

; 4782 : 	t = w->GetWPArrivalTime();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _t$[ebp], eax

; 4783 : 	c = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _c$[ebp], eax

; 4784 : 	if (t > c)

	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jbe	$LN1@GetArrival

; 4785 : 	{
; 4786 : 		reqs = FloatToInt32(d*CampaignHours/(t-c));

	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR __real@4a5bba00
	mov	ecx, DWORD PTR _t$[ebp]
	sub	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv174[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv174[ebp]
	mov	edx, DWORD PTR tv174[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv177[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv177[ebp]
	divss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _reqs$[ebp], eax

; 4787 : 		if (u->IsFlight() && reqs < maxs/2)

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN2@GetArrival
	mov	eax, DWORD PTR _maxs$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _reqs$[ebp], eax
	jge	SHORT $LN2@GetArrival

; 4788 : 			reqs = maxs/2;					// Minimal speed

	mov	eax, DWORD PTR _maxs$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _reqs$[ebp], eax
$LN2@GetArrival:

; 4789 : 		if (reqs < maxs)

	mov	ecx, DWORD PTR _reqs$[ebp]
	cmp	ecx, DWORD PTR _maxs$[ebp]
	jge	SHORT $LN1@GetArrival

; 4790 : 			return reqs;

	mov	eax, DWORD PTR _reqs$[ebp]
	jmp	SHORT $LN7@GetArrival
$LN1@GetArrival:

; 4791 : 	}
; 4792 : 	return maxs;

	mov	eax, DWORD PTR _maxs$[ebp]
$LN7@GetArrival:

; 4793 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetArrivalSpeed@@YAHPBVUnitClass@@@Z ENDP		; GetArrivalSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?GetTaxiPoint@DigitalBrain@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTaxiPoint@DigitalBrain@@QAEHXZ PROC			; DigitalBrain::GetTaxiPoint, COMDAT
; _this$ = ecx

; 691  : 	int		GetTaxiPoint(void)								{return curTaxiPoint;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTaxiPoint@DigitalBrain@@QAEHXZ ENDP			; DigitalBrain::GetTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?NameTagsOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?NameTagsOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::NameTagsOn, COMDAT
; _this$ = ecx

; 155  : 	int NameTagsOn (void)									{ return (SimFlags & SIM_NAMETAGS) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 64					; 00000040H
	je	SHORT $LN3@NameTagsOn
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@NameTagsOn
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@NameTagsOn
$LN3@NameTagsOn:
	mov	DWORD PTR tv68[ebp], 0
$LN4@NameTagsOn:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?NameTagsOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::NameTagsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumHardpoints@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumHardpoints@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumHardpoints, COMDAT
; _this$ = ecx

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumHardpoints@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumHardpoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ PROC	; AircraftClass::DBrain, COMDAT
; _this$ = ecx

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]
	mov	esp, ebp
	pop	ebp
	ret	0
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ENDP	; AircraftClass::DBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsAwake@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 177  : 	int IsAwake() const { return localFlags & OBJ_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetSlot@SimBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSlot@SimBaseClass@@QAEHXZ PROC			; SimBaseClass::GetSlot, COMDAT
; _this$ = ecx

; 155  : 	int GetSlot () { return slotNumber;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+236]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSlot@SimBaseClass@@QAEHXZ ENDP			; SimBaseClass::GetSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerSquadron@FalconSessionEntity@@QBEPAVSquadronClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerSquadron@FalconSessionEntity@@QBEPAVSquadronClass@@XZ PROC ; FalconSessionEntity::GetPlayerSquadron, COMDAT
; _this$ = ecx

; 140  : 	SquadronClass* GetPlayerSquadron(void)	const { return playerSquadronPtr.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 476				; 000001dcH
	call	?get@?$VuBin@VSquadronClass@@@@QBEPAVSquadronClass@@XZ ; VuBin<SquadronClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerSquadron@FalconSessionEntity@@QBEPAVSquadronClass@@XZ ENDP ; FalconSessionEntity::GetPlayerSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ PROC ; FalconSessionEntity::GetPlayerFlight, COMDAT
; _this$ = ecx

; 139  : 	FlightClass* GetPlayerFlight(void) const      { return playerFlightPtr.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 480				; 000001e0H
	call	?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ ; VuBin<FlightClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ENDP ; FalconSessionEntity::GetPlayerFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ PROC ; FalconSessionEntity::GetPlayerEntity, COMDAT
; _this$ = ecx

; 138  : 	FalconEntity* GetPlayerEntity(void) const     { return playerEntityPtr.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 484				; 000001e4H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ENDP ; FalconSessionEntity::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ PROC	; VuBin<FlightClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFlightClass@@@@QBEPAVFlightClass@@XZ ENDP	; VuBin<FlightClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSquadronClass@@@@QBEPAVSquadronClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSquadronClass@@@@QBEPAVSquadronClass@@XZ PROC ; VuBin<SquadronClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSquadronClass@@@@QBEPAVSquadronClass@@XZ ENDP ; VuBin<SquadronClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetColor@TeamClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetColor@TeamClass@@QAEHXZ PROC			; TeamClass::GetColor, COMDAT
; _this$ = ecx

; 329  : 	int GetColor (void)							{ return (int) teamColor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+889]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetColor@TeamClass@@QAEHXZ ENDP			; TeamClass::GetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ PROC ; TeamClass::GetGroundAction, COMDAT
; _this$ = ecx

; 277  : 	TeamGndActionType *GetGroundAction (void) { return &groundAction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ENDP ; TeamClass::GetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\atcbrain.h
;	COMDAT ?MinDeagTime@ATCBrain@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinDeagTime@ATCBrain@@QAEKXZ PROC			; ATCBrain::MinDeagTime, COMDAT
; _this$ = ecx

; 185  : 	ulong				MinDeagTime(void)				{return minDeagTime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?MinDeagTime@ATCBrain@@QAEKXZ ENDP			; ATCBrain::MinDeagTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -76						; size = 8
_vuid$ = -68						; size = 8
_last_buf$ = -60					; size = 4
$T2 = -56						; size = 4
_bufhead$ = -52						; size = 4
$T3 = -48						; size = 4
tv194 = -44						; size = 4
tv171 = -40						; size = 4
_start_buf$ = -36					; size = 4
_i$4 = -32						; size = 4
_size$ = -28						; size = 4
_buf$ = -24						; size = 4
_cur$ = -20						; size = 4
_last_type$ = -16					; size = 2
_num$ = -12						; size = 2
_count$ = -8						; size = 2
_type$ = -4						; size = 2
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
_owner$ = 16						; size = 4
?DecodeUnitData@@YAHPAPAEPAJPAVFalconSessionEntity@@@Z PROC ; DecodeUnitData

; 5268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 5269 : 	long            size;
; 5270 : 	short			count,last_type,type,num;
; 5271 : 	VU_ID			vuid;

	lea	ecx, DWORD PTR _vuid$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 5272 : 	Unit			cur;
; 5273 : 	VU_BYTE			*buf,*bufhead,*last_buf,*start_buf;
; 5274 : 	//	char			buffer[100];
; 5275 : 
; 5276 : 	memcpychk(&count, stream, sizeof(short), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5277 : 	memcpychk(&size, stream, sizeof(long), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5278 : 
; 5279 : 	//we dont decode if we dont have to
; 5280 : 	if (size == 0){

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN13@DecodeUnit

; 5281 : 		return 0;

	xor	eax, eax
	jmp	$LN14@DecodeUnit
$LN13@DecodeUnit:

; 5282 : 	}
; 5283 : 
; 5284 : 	//we use buf head to free buffer later
; 5285 : 	buf = new VU_BYTE[size];

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _buf$[ebp], ecx

; 5286 : 	bufhead = buf;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _bufhead$[ebp], edx

; 5287 : 	
; 5288 : 	//now we check the expand return
; 5289 : 	if ( (LZSS_Expand(*stream, rem[0], buf, size)) <= 0){

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_LZSS_Expand
	add	esp, 16					; 00000010H

; 5290 : //		char err[200];
; 5291 : //		sprintf(err, "%s %d: error expanding unit data", __FILE__, __LINE__);
; 5292 : //		throw std::InvalidBufferException(err);
; 5293 : 	}
; 5294 : 	rem[0] = size;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 5295 : 	
; 5296 : 	start_buf = 0;

	mov	DWORD PTR _start_buf$[ebp], 0

; 5297 : 	type = 0;

	xor	ecx, ecx
	mov	WORD PTR _type$[ebp], cx

; 5298 : 
; 5299 : 	num = 0;

	xor	edx, edx
	mov	WORD PTR _num$[ebp], dx
$LN11@DecodeUnit:

; 5300 : 
; 5301 : 	while (count) {

	movsx	eax, WORD PTR _count$[ebp]
	test	eax, eax
	je	$LN10@DecodeUnit

; 5302 : 		last_buf = start_buf;

	mov	ecx, DWORD PTR _start_buf$[ebp]
	mov	DWORD PTR _last_buf$[ebp], ecx

; 5303 : 		last_type = type;

	mov	dx, WORD PTR _type$[ebp]
	mov	WORD PTR _last_type$[ebp], dx

; 5304 : 
; 5305 : 		start_buf = buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _start_buf$[ebp], eax

; 5306 : 
; 5307 : 		memcpychk(&type, &buf, sizeof(short), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	lea	eax, DWORD PTR _type$[ebp]
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5308 : 
; 5309 : 		cur = NewUnit(type, &buf, rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	movzx	eax, WORD PTR _type$[ebp]
	push	eax
	call	?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z	; NewUnit
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cur$[ebp], eax

; 5310 : 
; 5311 : 		if (load_log) {

	cmp	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
	je	SHORT $LN9@DecodeUnit

; 5312 : 			fprintf (load_log, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	ecx
	call	_fprintf
	add	esp, 8

; 5313 : 			fflush (load_log);

	mov	edx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	edx
	call	_fflush
	add	esp, 4
$LN9@DecodeUnit:

; 5314 : 		}
; 5315 : 
; 5316 : 		if (cur && owner) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN8@DecodeUnit
	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN8@DecodeUnit

; 5317 : 			cur->FalconEntity::SetOwnerId(owner->Id());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _owner$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?SetOwnerId@VuEntity@@QAEXVVU_ID@@@Z	; VuEntity::SetOwnerId
$LN8@DecodeUnit:

; 5318 : 		}
; 5319 : 
; 5320 : 		// sfr: dont think this is necessary since unit is not local... but anyway
; 5321 : 		cur->SetSendCreate(VuEntity::VU_SC_DONT_SEND);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ; VuEntity::SetSendCreate

; 5322 : 		vuDatabase->/*Silent*/Insert(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 5323 : 
; 5324 : 		// Special case shit for tactical engagement
; 5325 : 		if (FalconLocalGame && cur->IsBattalion() && FalconLocalGame->GetGameType() == game_TacticalEngagement)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@DecodeUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN17@DecodeUnit
$LN16@DecodeUnit:
	mov	DWORD PTR tv171[ebp], 0
$LN17@DecodeUnit:
	cmp	DWORD PTR tv171[ebp], 0
	je	$LN7@DecodeUnit
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	je	$LN7@DecodeUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@DecodeUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv194[ebp], eax
	jmp	SHORT $LN19@DecodeUnit
$LN18@DecodeUnit:
	mov	DWORD PTR tv194[ebp], 0
$LN19@DecodeUnit:
	mov	ecx, DWORD PTR tv194[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN7@DecodeUnit

; 5326 : 		{
; 5327 : 			// Emitters are always spotted and emitting in tactical engagement
; 5328 : 			if (cur->GetRadarType() != RDR_NO_RADAR)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	test	eax, eax
	je	SHORT $LN6@DecodeUnit

; 5329 : 			{
; 5330 : 				cur->SetSearchMode(FEC_RADAR_SEARCH_1);//me123 + rand()%3);

	push	2
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+140]
	call	eax

; 5331 : 				cur->SetEmitting(1);

	push	1
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?SetEmitting@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetEmitting

; 5332 : 			}
; 5333 : 			else

	jmp	SHORT $LN5@DecodeUnit
$LN6@DecodeUnit:

; 5334 : 				cur->SetEmitting(0);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?SetEmitting@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetEmitting
$LN5@DecodeUnit:

; 5335 : 
; 5336 : 			for (int i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@DecodeUnit
$LN3@DecodeUnit:
	mov	ecx, DWORD PTR _i$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$4[ebp], ecx
$LN4@DecodeUnit:
	cmp	DWORD PTR _i$4[ebp], 8
	jge	SHORT $LN7@DecodeUnit

; 5337 : 				cur->SetSpotted (i, TheCampaign.CurrentTime);

	push	0
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	edx
	movzx	eax, BYTE PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted
	jmp	SHORT $LN3@DecodeUnit
$LN7@DecodeUnit:

; 5338 : 		}
; 5339 : 
; 5340 : 		count--;

	mov	cx, WORD PTR _count$[ebp]
	sub	cx, 1
	mov	WORD PTR _count$[ebp], cx

; 5341 : 	}

	jmp	$LN11@DecodeUnit
$LN10@DecodeUnit:

; 5342 : 
; 5343 : 	delete bufhead;

	mov	edx, DWORD PTR _bufhead$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 5344 : 
; 5345 : 	if (load_log)

	cmp	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
	je	SHORT $LN1@DecodeUnit

; 5346 : 	{
; 5347 : 		fclose (load_log);

	mov	ecx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	ecx
	call	_fclose
	add	esp, 4

; 5348 : 		load_log = 0;

	mov	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
$LN1@DecodeUnit:

; 5349 : 	}
; 5350 : 
; 5351 : 	return 0;

	xor	eax, eax
$LN14@DecodeUnit:

; 5352 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecodeUnitData@@YAHPAPAEPAJPAVFalconSessionEntity@@@Z ENDP ; DecodeUnitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -164						; size = 8
$T3 = -156						; size = 8
_vuid$ = -148						; size = 8
$T4 = -140						; size = 8
$T5 = -132						; size = 8
$T6 = -124						; size = 8
_myit$7 = -116						; size = 12
_myit$8 = -104						; size = 12
_iit$9 = -92						; size = 12
_iit$10 = -80						; size = 12
$T11 = -68						; size = 4
_num$ = -64						; size = 2
$T12 = -60						; size = 4
$T13 = -56						; size = 4
_bufhead$ = -52						; size = 4
_ownerid$ = -48						; size = 8
_newsize$ = -40						; size = 4
_sptr$ = -36						; size = 4
_type$ = -32						; size = 2
_size$ = -28						; size = 4
_buf$ = -24						; size = 4
_count$ = -20						; size = 2
_cur$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_owner$ = 12						; size = 4
?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z PROC ; EncodeUnitData

; 5151 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 5152 : 	long            size=0,newsize;

	mov	DWORD PTR _size$[ebp], 0

; 5153 : 	short			num=0,count=0,type;

	xor	eax, eax
	mov	WORD PTR _num$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _count$[ebp], cx

; 5154 : 	Unit			cur;
; 5155 : 	VU_BYTE			*buf,*sptr,*bufhead;
; 5156 : //#ifdef DEBUG
; 5157 : //	//VU_BYTE			*temp;
; 5158 : //#endif
; 5159 : 	VU_ID			vuid,ownerid;

	lea	ecx, DWORD PTR _vuid$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	lea	ecx, DWORD PTR _ownerid$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 5160 : 	//	char			buffer[100];
; 5161 : 
; 5162 : 	if (!AllUnitList)

	cmp	DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A, 0 ; AllUnitList
	jne	SHORT $LN20@EncodeUnit

; 5163 : 		return 0;

	xor	eax, eax
	jmp	$LN21@EncodeUnit
$LN20@EncodeUnit:

; 5164 : 
; 5165 : 	if (owner)

	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN19@EncodeUnit

; 5166 : 		ownerid = owner->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _owner$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ownerid$[ebp], ecx
	mov	DWORD PTR _ownerid$[ebp+4], edx
$LN19@EncodeUnit:

; 5167 : 
; 5168 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 5169 : 
; 5170 : 	// Count # of units && calculate size
; 5171 : 	{
; 5172 : 		VuListIterator	myit(AllUnitList);

	mov	eax, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	eax
	lea	ecx, DWORD PTR _myit$8[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5173 : 		cur = GetFirstUnit(&myit);

	lea	ecx, DWORD PTR _myit$8[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax
$LN18@EncodeUnit:

; 5174 : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN17@EncodeUnit

; 5175 : 		{
; 5176 : 			if ((!owner || cur->OwnerId() == ownerid) && !cur->IsDead())

	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN15@EncodeUnit
	lea	edx, DWORD PTR _ownerid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@EncodeUnit
$LN15@EncodeUnit:
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+552]
	call	edx
	test	eax, eax
	jne	SHORT $LN16@EncodeUnit

; 5177 : 			{
; 5178 : 				size += cur->SaveSize() + sizeof(short);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	ecx, DWORD PTR _size$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	DWORD PTR _size$[ebp], edx

; 5179 : 				count++;

	mov	ax, WORD PTR _count$[ebp]
	add	ax, 1
	mov	WORD PTR _count$[ebp], ax
$LN16@EncodeUnit:

; 5180 : 			}
; 5181 : 			cur = GetNextUnit(&myit);

	lea	ecx, DWORD PTR _myit$8[ebp]
	push	ecx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5182 : 		}

	jmp	SHORT $LN18@EncodeUnit
$LN17@EncodeUnit:

; 5183 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$8[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 5184 : 
; 5185 : 	// Count Inactive units
; 5186 : 	{
; 5187 : 		VuListIterator  iit(InactiveList);

	mov	edx, DWORD PTR ?InactiveList@@3PAVVuLinkedList@@A ; InactiveList
	push	edx
	lea	ecx, DWORD PTR _iit$9[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5188 : 		cur = GetFirstUnit(&iit);

	lea	eax, DWORD PTR _iit$9[ebp]
	push	eax
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax
$LN14@EncodeUnit:

; 5189 : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN13@EncodeUnit

; 5190 : 		{
; 5191 : 			if ((!owner || cur->OwnerId() == ownerid) && !cur->IsDead())

	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN11@EncodeUnit
	lea	ecx, DWORD PTR _ownerid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@EncodeUnit
$LN11@EncodeUnit:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN12@EncodeUnit

; 5192 : 			{
; 5193 : 				size += cur->SaveSize() + sizeof(short);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	ecx, DWORD PTR _size$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	DWORD PTR _size$[ebp], edx

; 5194 : 				count++;

	mov	ax, WORD PTR _count$[ebp]
	add	ax, 1
	mov	WORD PTR _count$[ebp], ax
$LN12@EncodeUnit:

; 5195 : 			}
; 5196 : 			cur = GetNextUnit(&iit);

	lea	ecx, DWORD PTR _iit$9[ebp]
	push	ecx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5197 : 		}

	jmp	SHORT $LN14@EncodeUnit
$LN13@EncodeUnit:

; 5198 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iit$9[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 5199 : 
; 5200 : 	buf = new VU_BYTE[size+1];

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 1
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR _buf$[ebp], eax

; 5201 : 	bufhead = buf;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _bufhead$[ebp], ecx

; 5202 : 
; 5203 : 	//	save_log = fopen ("save.log", "w");
; 5204 : 	//	start_save_stream = (int) buf;
; 5205 : 
; 5206 : 	// Save Units one at a time, with a domain/type header, so we can load it correctly
; 5207 : 	{
; 5208 : 		VuListIterator	myit(AllUnitList);

	mov	edx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	edx
	lea	ecx, DWORD PTR _myit$7[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 5209 : 		cur = GetFirstUnit(&myit);

	lea	eax, DWORD PTR _myit$7[ebp]
	push	eax
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax
$LN10@EncodeUnit:

; 5210 : 		while (cur){

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN9@EncodeUnit

; 5211 : 			if ((!owner || cur->OwnerId() == ownerid) && !cur->IsDead()){

	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN7@EncodeUnit
	lea	ecx, DWORD PTR _ownerid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@EncodeUnit
$LN7@EncodeUnit:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@EncodeUnit

; 5212 : 				type = cur->Type();

	mov	ecx, DWORD PTR _cur$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	WORD PTR _type$[ebp], ax

; 5213 : 				memcpy(buf, &type, sizeof(short));			buf += sizeof(short);

	push	2
	lea	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf$[ebp], eax

; 5214 : 				cur->Save(&buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 5215 : 				if (save_log){

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN8@EncodeUnit

; 5216 : 					fprintf (save_log, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	eax
	call	_fprintf
	add	esp, 8

; 5217 : 					fflush (save_log);

	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fflush
	add	esp, 4
$LN8@EncodeUnit:

; 5218 : 				}
; 5219 : 			}
; 5220 : 			cur = GetNextUnit(&myit);

	lea	edx, DWORD PTR _myit$7[ebp]
	push	edx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5221 : 		}

	jmp	$LN10@EncodeUnit
$LN9@EncodeUnit:

; 5222 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$7[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 5223 : 
; 5224 : 	// Save Inactive units
; 5225 : 	{
; 5226 : 		VuListIterator  iit(InactiveList);

	mov	eax, DWORD PTR ?InactiveList@@3PAVVuLinkedList@@A ; InactiveList
	push	eax
	lea	ecx, DWORD PTR _iit$10[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 5227 : 		cur = GetFirstUnit(&iit);

	lea	ecx, DWORD PTR _iit$10[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax
$LN5@EncodeUnit:

; 5228 : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN4@EncodeUnit

; 5229 : 		{
; 5230 : 			if ((!owner || cur->OwnerId() == ownerid) && !cur->IsDead())

	cmp	DWORD PTR _owner$[ebp], 0
	je	SHORT $LN2@EncodeUnit
	lea	edx, DWORD PTR _ownerid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@EncodeUnit
$LN2@EncodeUnit:
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+552]
	call	edx
	test	eax, eax
	jne	SHORT $LN3@EncodeUnit

; 5231 : 			{
; 5232 : 				type = cur->Type();

	mov	ecx, DWORD PTR _cur$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	WORD PTR _type$[ebp], ax

; 5233 : 				newsize = cur->SaveSize ();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	DWORD PTR _newsize$[ebp], eax

; 5234 : 				memcpy(buf, &type, sizeof(short));			buf += sizeof(short);

	push	2
	lea	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf$[ebp], eax

; 5235 : 				cur->Save(&buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN3@EncodeUnit:

; 5236 : 			}
; 5237 : 			cur = GetNextUnit(&iit);

	lea	eax, DWORD PTR _iit$10[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5238 : 		}

	jmp	$LN5@EncodeUnit
$LN4@EncodeUnit:

; 5239 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iit$10[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 5240 : 	ShiAssert((int)(buf-bufhead) == size); // JPO - this fired.
; 5241 : 
; 5242 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 5243 : 
; 5244 : 	// Compress it and return
; 5245 : 	*stream = new VU_BYTE[size + sizeof(short) + sizeof(long) + MAX_POSSIBLE_OVERWRITE];

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 106				; 0000006aH
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR [edx], eax

; 5246 : 	sptr = *stream;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _sptr$[ebp], edx

; 5247 : 	memcpy(sptr, &count, sizeof(short));			sptr += sizeof(short);

	push	2
	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _sptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _sptr$[ebp], edx

; 5248 : 	memcpy(sptr, &size, sizeof(long));				sptr += sizeof(long);

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _sptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _sptr$[ebp], edx

; 5249 : 
; 5250 : 	MonoPrint("Count=%1d,Size=%1ld\n",count,size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	movsx	ecx, WORD PTR _count$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@JMEEBPII@Count?$DN?$CF1d?0Size?$DN?$CF1ld?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 5251 : 
; 5252 : 	buf = bufhead;

	mov	edx, DWORD PTR _bufhead$[ebp]
	mov	DWORD PTR _buf$[ebp], edx

; 5253 : 	newsize = LZSS_Compress(buf, sptr, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_LZSS_Compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _newsize$[ebp], eax

; 5254 : 	delete bufhead;

	mov	eax, DWORD PTR _bufhead$[ebp]
	mov	DWORD PTR $T13[ebp], eax
	mov	ecx, DWORD PTR $T13[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 5255 : 
; 5256 : 	MonoPrint ("Encode Unit Data %d => %d\n", size, newsize);

	mov	edx, DWORD PTR _newsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@LACJBFNH@Encode?5Unit?5Data?5?$CFd?5?$DN?$DO?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 5257 : 
; 5258 : 	if (save_log)

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN1@EncodeUnit

; 5259 : 	{
; 5260 : 		fclose (save_log);

	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fclose
	add	esp, 4

; 5261 : 		save_log = 0;

	mov	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
$LN1@EncodeUnit:

; 5262 : 	}
; 5263 : 
; 5264 : 	return newsize + sizeof(short) + sizeof(long);

	mov	eax, DWORD PTR _newsize$[ebp]
	add	eax, 6
$LN21@EncodeUnit:

; 5265 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$0:
	lea	ecx, DWORD PTR _myit$8[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$1:
	lea	ecx, DWORD PTR _iit$9[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$2:
	lea	ecx, DWORD PTR _myit$7[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z$3:
	lea	ecx, DWORD PTR _iit$10[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z ENDP ; EncodeUnitData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_x$ = -16						; size = 2
_y$ = -12						; size = 2
_tx$ = -8						; size = 2
_ty$ = -4						; size = 2
_us$ = 8						; size = 4
_them$ = 12						; size = 4
?GetRange@@YAMPAVUnitClass@@PAVCampBaseClass@@@Z PROC	; GetRange

; 5043 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5044 : 	GridIndex	x,y,tx,ty;
; 5045 : 
; 5046 : 	theirDomain = 0;

	mov	DWORD PTR ?theirDomain@@3HA, 0		; theirDomain

; 5047 : 	if (!them)

	cmp	DWORD PTR _them$[ebp], 0
	jne	SHORT $LN6@GetRange

; 5048 : 		return 0.0F;

	fldz
	jmp	$LN7@GetRange
$LN6@GetRange:

; 5049 : 
; 5050 : 	// Set the domain while we're here
; 5051 : 	if (them->GetDomain() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _them$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 2
	jne	SHORT $LN5@GetRange

; 5052 : 		theirDomain = 1;

	mov	DWORD PTR ?theirDomain@@3HA, 1		; theirDomain
	jmp	SHORT $LN1@GetRange
$LN5@GetRange:

; 5053 : 	else if (them->IsUnit())

	mov	ecx, DWORD PTR _them$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _them$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN3@GetRange

; 5054 : 		theirDomain = 2;

	mov	DWORD PTR ?theirDomain@@3HA, 2		; theirDomain
	jmp	SHORT $LN1@GetRange
$LN3@GetRange:

; 5055 : 	else if (them->IsObjective())

	mov	ecx, DWORD PTR _them$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _them$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN1@GetRange

; 5056 : 		theirDomain = 3;

	mov	DWORD PTR ?theirDomain@@3HA, 3		; theirDomain
$LN1@GetRange:

; 5057 : 
; 5058 : 	// return range
; 5059 : 	us->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _us$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 5060 : 	them->GetLocation(&tx,&ty);

	lea	eax, DWORD PTR _ty$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _them$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 5061 : 	return Distance(x,y,tx,ty);

	movzx	edx, WORD PTR _ty$[ebp]
	push	edx
	movzx	eax, WORD PTR _tx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 16					; 00000010H
$LN7@GetRange:

; 5062 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRange@@YAMPAVUnitClass@@PAVCampBaseClass@@@Z ENDP	; GetRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -92						; size = 4
$T3 = -88						; size = 4
$T4 = -84						; size = 4
$T5 = -80						; size = 4
$T6 = -76						; size = 4
$T7 = -72						; size = 4
tv241 = -68						; size = 4
$T8 = -64						; size = 4
tv212 = -60						; size = 4
$T9 = -56						; size = 4
tv193 = -52						; size = 4
$T10 = -48						; size = 4
tv164 = -44						; size = 4
$T11 = -40						; size = 4
tv145 = -36						; size = 4
$T12 = -32						; size = 4
tv94 = -28						; size = 4
$T13 = -24						; size = 4
_cur$ = -20						; size = 4
_classPtr$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tid$ = 8						; size = 2
_stream$ = 12						; size = 4
_rem$ = 16						; size = 4
?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z PROC		; NewUnit

; 4993 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4994 : 	Unit cur = NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 4995 : 	Falcon4EntityClassType* classPtr = &(Falcon4ClassTable[tid - VU_LAST_ENTITY_TYPE]);

	movsx	eax, WORD PTR _tid$[ebp]
	sub	eax, 100				; 00000064H
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], eax

; 4996 : 
; 4997 : 	if (!tid){ return NULL; }

	movsx	ecx, WORD PTR _tid$[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@NewUnit
	xor	eax, eax
	jmp	$LN20@NewUnit
$LN19@NewUnit:

; 4998 : 
; 4999 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 5000 : 	if (classPtr->vuClassData.classInfo_[VU_DOMAIN] == DOMAIN_AIR){

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	jne	$LN18@NewUnit

; 5001 : 		if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_FLIGHT){

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 1
	jne	SHORT $LN17@NewUnit

; 5002 : 			cur = new FlightClass(stream, rem);

	push	456					; 000001c8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN22@NewUnit
	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0FlightClass@@QAE@PAPAEPAJ@Z		; FlightClass::FlightClass
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN23@NewUnit
$LN22@NewUnit:
	mov	DWORD PTR tv94[ebp], 0
$LN23@NewUnit:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	$LN16@NewUnit
$LN17@NewUnit:

; 5003 : 		}
; 5004 : 		else if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_SQUADRON){

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 3
	jne	SHORT $LN15@NewUnit

; 5005 : 			cur = new SquadronClass(stream, rem);

	push	1476					; 000005c4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN24@NewUnit
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0SquadronClass@@QAE@PAPAEPAJ@Z	; SquadronClass::SquadronClass
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN25@NewUnit
$LN24@NewUnit:
	mov	DWORD PTR tv145[ebp], 0
$LN25@NewUnit:
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN16@NewUnit
$LN15@NewUnit:

; 5006 : 		}
; 5007 : 		else if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_PACKAGE){

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 2
	jne	SHORT $LN13@NewUnit

; 5008 : 			cur = new PackageClass(stream, rem);

	push	476					; 000001dcH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN26@NewUnit
	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0PackageClass@@QAE@PAPAEPAJ@Z		; PackageClass::PackageClass
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN27@NewUnit
$LN26@NewUnit:
	mov	DWORD PTR tv164[ebp], 0
$LN27@NewUnit:
	mov	eax, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 5009 : 		}
; 5010 : 		else {

	jmp	SHORT $LN16@NewUnit
$LN13@NewUnit:

; 5011 : 			MessageBox(NULL,"Type conflict while creating unit.","Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND );

	push	65552					; 00010010H
	push	OFFSET ??_C@_05NAOIJFC@Error?$AA@
	push	OFFSET ??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
$LN16@NewUnit:

; 5012 : 		}

	jmp	$LN11@NewUnit
$LN18@NewUnit:

; 5013 : 	}
; 5014 : 	else if (classPtr->vuClassData.classInfo_[VU_DOMAIN] == DOMAIN_LAND){

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 3
	jne	$LN10@NewUnit

; 5015 : 		if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BRIGADE){

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	jne	SHORT $LN9@NewUnit

; 5016 : 			cur = new BrigadeClass(stream, rem);

	push	340					; 00000154H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN28@NewUnit
	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0BrigadeClass@@QAE@PAPAEPAJ@Z		; BrigadeClass::BrigadeClass
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN29@NewUnit
$LN28@NewUnit:
	mov	DWORD PTR tv193[ebp], 0
$LN29@NewUnit:
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN8@NewUnit
$LN9@NewUnit:

; 5017 : 		}
; 5018 : 		else if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BATTALION){

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 1
	jne	SHORT $LN7@NewUnit

; 5019 : 			cur = new BattalionClass(stream, rem);

	push	364					; 0000016cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN30@NewUnit
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0BattalionClass@@QAE@PAPAEPAJ@Z	; BattalionClass::BattalionClass
	mov	DWORD PTR tv212[ebp], eax
	jmp	SHORT $LN31@NewUnit
$LN30@NewUnit:
	mov	DWORD PTR tv212[ebp], 0
$LN31@NewUnit:
	mov	edx, DWORD PTR tv212[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 5020 : 		}
; 5021 : 		else {

	jmp	SHORT $LN8@NewUnit
$LN7@NewUnit:

; 5022 : 			MessageBox(NULL,"Type conflict while creating unit.","Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND );

	push	65552					; 00010010H
	push	OFFSET ??_C@_05NAOIJFC@Error?$AA@
	push	OFFSET ??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
$LN8@NewUnit:

; 5023 : 		}

	jmp	$LN11@NewUnit
$LN10@NewUnit:

; 5024 : 	}
; 5025 : 	else if (classPtr->vuClassData.classInfo_[VU_DOMAIN] == DOMAIN_SEA){

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 4
	jne	SHORT $LN4@NewUnit

; 5026 : 		if (classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_TASKFORCE){

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 1
	jne	SHORT $LN3@NewUnit

; 5027 : 			cur = new TaskForceClass(stream, rem);

	push	312					; 00000138H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN32@NewUnit
	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0TaskForceClass@@QAE@PAPAEPAJ@Z	; TaskForceClass::TaskForceClass
	mov	DWORD PTR tv241[ebp], eax
	jmp	SHORT $LN33@NewUnit
$LN32@NewUnit:
	mov	DWORD PTR tv241[ebp], 0
$LN33@NewUnit:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 5028 : 		}
; 5029 : 		else {

	jmp	SHORT $LN2@NewUnit
$LN3@NewUnit:

; 5030 : 			MessageBox(NULL,"Type conflict while creating unit.","Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND );

	push	65552					; 00010010H
	push	OFFSET ??_C@_05NAOIJFC@Error?$AA@
	push	OFFSET ??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
$LN2@NewUnit:

; 5031 : 		}
; 5032 : 	}
; 5033 : 	else

	jmp	SHORT $LN11@NewUnit
$LN4@NewUnit:

; 5034 : 	{
; 5035 : 		MessageBox(NULL,"Type conflict while creating unit.","Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND );

	push	65552					; 00010010H
	push	OFFSET ??_C@_05NAOIJFC@Error?$AA@
	push	OFFSET ??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16

; 5036 : 		cur = NULL;

	mov	DWORD PTR _cur$[ebp], 0
$LN11@NewUnit:

; 5037 : 	}
; 5038 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 5039 : 	return cur;

	mov	eax, DWORD PTR _cur$[ebp]
$LN20@NewUnit:

; 5040 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$0:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$1:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$2:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$3:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$4:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z$5:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NewUnit@@YAPAVUnitClass@@FPAPAEPAJ@Z ENDP		; NewUnit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_id$ = -36						; size = 4
tv159 = -32						; size = 4
_low$ = -28						; size = 4
_hi$ = -24						; size = 4
tv140 = -20						; size = 4
tv80 = -16						; size = 4
_cur$ = -12						; size = 4
_tid$ = -8						; size = 2
_error$ = -1						; size = 1
_domain$ = 8						; size = 4
_type$ = 12						; size = 4
_stype$ = 16						; size = 4
_sptype$ = 20						; size = 4
_parent$ = 24						; size = 4
?NewUnit@@YAPAVUnitClass@@HHHHPAV1@@Z PROC		; NewUnit

; 4931 : Unit NewUnit (int domain, int type, int stype, int sptype, Unit parent){

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 4932 : 	Unit	cur=NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 4933 : 	ushort	tid = GetClassID(domain,CLASS_UNIT,type,stype,sptype,0,0,0);

	push	0
	push	0
	push	0
	movzx	eax, BYTE PTR _sptype$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _stype$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _type$[ebp]
	push	edx
	push	6
	movzx	eax, BYTE PTR _domain$[ebp]
	push	eax
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	WORD PTR _tid$[ebp], ax

; 4934 : 	VU_ID_NUMBER id, low, hi;
; 4935 : 	id = low = hi = 0;

	mov	DWORD PTR _hi$[ebp], 0
	mov	ecx, DWORD PTR _hi$[ebp]
	mov	DWORD PTR _low$[ebp], ecx
	mov	edx, DWORD PTR _low$[ebp]
	mov	DWORD PTR _id$[ebp], edx

; 4936 : 	bool error = false;

	mov	BYTE PTR _error$[ebp], 0

; 4937 : 
; 4938 : 	if (!tid){

	movzx	eax, WORD PTR _tid$[ebp]
	test	eax, eax
	jne	SHORT $LN22@NewUnit

; 4939 : 		return NULL;

	xor	eax, eax
	jmp	$LN23@NewUnit
$LN22@NewUnit:

; 4940 : 	}
; 4941 : 
; 4942 : 	tid += VU_LAST_ENTITY_TYPE;

	movzx	ecx, WORD PTR _tid$[ebp]
	add	ecx, 100				; 00000064H
	mov	WORD PTR _tid$[ebp], cx

; 4943 : 	if (domain == DOMAIN_AIR){

	cmp	DWORD PTR _domain$[ebp], 2
	jne	SHORT $LN21@NewUnit

; 4944 : 		switch (type){

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 1
	je	SHORT $LN17@NewUnit
	cmp	DWORD PTR tv80[ebp], 2
	je	SHORT $LN18@NewUnit
	cmp	DWORD PTR tv80[ebp], 3
	je	SHORT $LN16@NewUnit
	jmp	SHORT $LN15@NewUnit
$LN18@NewUnit:

; 4945 : 			case TYPE_PACKAGE:
; 4946 : 				cur = NewPackage(tid);

	movzx	eax, WORD PTR _tid$[ebp]
	push	eax
	call	?NewPackage@@YAPAVPackageClass@@H@Z	; NewPackage
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 4947 : 			break;

	jmp	SHORT $LN19@NewUnit
$LN17@NewUnit:

; 4948 : 			case TYPE_FLIGHT:
; 4949 : 				cur = NewFlight(tid,parent,NULL);

	push	0
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tid$[ebp]
	push	edx
	call	?NewFlight@@YAPAVFlightClass@@HPAVUnitClass@@0@Z ; NewFlight
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cur$[ebp], eax

; 4950 : 			break;

	jmp	SHORT $LN19@NewUnit
$LN16@NewUnit:

; 4951 : 			case TYPE_SQUADRON:
; 4952 : 				cur = NewSquadron(tid);

	movzx	eax, WORD PTR _tid$[ebp]
	push	eax
	call	?NewSquadron@@YAPAVSquadronClass@@H@Z	; NewSquadron
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 4953 : 			break;

	jmp	SHORT $LN19@NewUnit
$LN15@NewUnit:

; 4954 : 			default:
; 4955 : 				error = true;

	mov	BYTE PTR _error$[ebp], 1
$LN19@NewUnit:

; 4956 : 		}
; 4957 : 	}
; 4958 : 	else if (domain == DOMAIN_LAND){

	jmp	SHORT $LN14@NewUnit
$LN21@NewUnit:
	cmp	DWORD PTR _domain$[ebp], 3
	jne	SHORT $LN13@NewUnit

; 4959 : 		switch (type){

	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv140[ebp], ecx
	cmp	DWORD PTR tv140[ebp], 1
	je	SHORT $LN9@NewUnit
	cmp	DWORD PTR tv140[ebp], 2
	je	SHORT $LN10@NewUnit
	jmp	SHORT $LN8@NewUnit
$LN10@NewUnit:

; 4960 : 			case TYPE_BRIGADE:
; 4961 : 				cur = NewBrigade(tid);

	movzx	edx, WORD PTR _tid$[ebp]
	push	edx
	call	?NewBrigade@@YAPAVBrigadeClass@@H@Z	; NewBrigade
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 4962 : 			break;

	jmp	SHORT $LN11@NewUnit
$LN9@NewUnit:

; 4963 : 			case TYPE_BATTALION:
; 4964 : 				cur = NewBattalion(tid,parent);

	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tid$[ebp]
	push	ecx
	call	?NewBattalion@@YAPAVBattalionClass@@HPAVUnitClass@@@Z ; NewBattalion
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4965 : 			break;

	jmp	SHORT $LN11@NewUnit
$LN8@NewUnit:

; 4966 : 			default:
; 4967 : 				error = true;

	mov	BYTE PTR _error$[ebp], 1
$LN11@NewUnit:

; 4968 : 		}
; 4969 : 	}
; 4970 : 	else if (domain == DOMAIN_SEA)

	jmp	SHORT $LN14@NewUnit
$LN13@NewUnit:
	cmp	DWORD PTR _domain$[ebp], 4
	jne	SHORT $LN14@NewUnit

; 4971 : 	{
; 4972 : 		switch (type){

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv159[ebp], edx
	cmp	DWORD PTR tv159[ebp], 1
	je	SHORT $LN3@NewUnit
	jmp	SHORT $LN2@NewUnit
$LN3@NewUnit:

; 4973 : 			case TYPE_TASKFORCE:
; 4974 : 				cur = NewTaskForce(tid);		

	movzx	eax, WORD PTR _tid$[ebp]
	push	eax
	call	?NewTaskForce@@YAPAVTaskForceClass@@H@Z	; NewTaskForce
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 4975 : 			break;

	jmp	SHORT $LN14@NewUnit
$LN2@NewUnit:

; 4976 : 			default:
; 4977 : 				error = true;

	mov	BYTE PTR _error$[ebp], 1
$LN14@NewUnit:

; 4978 : 		}
; 4979 : 	}
; 4980 : 
; 4981 : 	if (error){

	movzx	ecx, BYTE PTR _error$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@NewUnit

; 4982 : 		MessageBox(NULL,"Type conflict while creating unit.","Error", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND );

	push	65552					; 00010010H
	push	OFFSET ??_C@_05NAOIJFC@Error?$AA@
	push	OFFSET ??_C@_0CD@CMPFCOF@Type?5conflict?5while?5creating?5uni@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
$LN1@NewUnit:

; 4983 : 	}
; 4984 : 
; 4985 : 	cur->BuildElements();

	mov	ecx, DWORD PTR _cur$[ebp]
	call	?BuildElements@UnitClass@@QAEXXZ	; UnitClass::BuildElements

; 4986 : 	vuDatabase->Insert(cur/*, id, low, hi*/);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 4987 : 	return cur;

	mov	eax, DWORD PTR _cur$[ebp]
$LN23@NewUnit:

; 4988 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NewUnit@@YAPAVUnitClass@@HHHHPAV1@@Z ENDP		; NewUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$2 = -44						; size = 12
$T3 = -32						; size = 4
_div$ = -28						; size = 4
_f$ = -24						; size = 4
_element$ = -20						; size = 4
_e$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_u$ = 8							; size = 4
?FindUnitNameID@@YAHPAVUnitClass@@@Z PROC		; FindUnitNameID

; 4888 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindUnitNameID@@YAHPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4889 : 	Unit			f,e;
; 4890 : 	int				div,element=1;	

	mov	DWORD PTR _element$[ebp], 1

; 4891 : 
; 4892 : 	if (u->Parent())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	$LN13@FindUnitNa

; 4893 : 	{
; 4894 : 		div = u->GetUnitDivision();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	mov	DWORD PTR _div$[ebp], eax

; 4895 : 		VuListIterator	myit(AllUnitList);

	mov	ecx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	ecx
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4896 : 		e = GetFirstUnit(&myit);

	lea	edx, DWORD PTR _myit$2[ebp]
	push	edx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax
$LN12@FindUnitNa:

; 4897 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN11@FindUnitNa

; 4898 : 		{
; 4899 : 			if (e->GetUnitDivision() == div && e->GetOwner() == u->GetOwner() && e->GetDomain() == DOMAIN_LAND && e->Parent())

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	cmp	eax, DWORD PTR _div$[ebp]
	jne	SHORT $LN10@FindUnitNa
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	esi, al
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN10@FindUnitNa
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 3
	jne	SHORT $LN10@FindUnitNa
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	SHORT $LN10@FindUnitNa

; 4900 : 			{
; 4901 : 				if (e == u)

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _u$[ebp]
	jne	SHORT $LN9@FindUnitNa

; 4902 : 				{
; 4903 : 					if (u->GetUnitNameID())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	test	eax, eax
	je	SHORT $LN8@FindUnitNa

; 4904 : 						return u->GetUnitNameID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	$LN14@FindUnitNa
$LN8@FindUnitNa:

; 4905 : 				}
; 4906 : 				else

	jmp	SHORT $LN10@FindUnitNa
$LN9@FindUnitNa:

; 4907 : 					element++;

	mov	ecx, DWORD PTR _element$[ebp]
	add	ecx, 1
	mov	DWORD PTR _element$[ebp], ecx
$LN10@FindUnitNa:

; 4908 : 			}
; 4909 : 			e = GetNextUnit(&myit);

	lea	edx, DWORD PTR _myit$2[ebp]
	push	edx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 4910 : 		}

	jmp	$LN12@FindUnitNa
$LN11@FindUnitNa:

; 4911 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 4912 : 	else

	jmp	SHORT $LN6@FindUnitNa
$LN13@FindUnitNa:

; 4913 : 	{
; 4914 : 		f = u->GetUnitParent();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _f$[ebp], eax

; 4915 : 		e = f->GetFirstUnitElement();

	mov	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN5@FindUnitNa:

; 4916 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN6@FindUnitNa

; 4917 : 		{
; 4918 : 			if (e == u)

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR _u$[ebp]
	jne	SHORT $LN3@FindUnitNa

; 4919 : 			{
; 4920 : 				if (u->GetUnitNameID())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	test	eax, eax
	je	SHORT $LN2@FindUnitNa

; 4921 : 					return u->GetUnitNameID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	jmp	SHORT $LN14@FindUnitNa
$LN2@FindUnitNa:

; 4922 : 			}
; 4923 : 			else

	jmp	SHORT $LN1@FindUnitNa
$LN3@FindUnitNa:

; 4924 : 				element++;

	mov	edx, DWORD PTR _element$[ebp]
	add	edx, 1
	mov	DWORD PTR _element$[ebp], edx
$LN1@FindUnitNa:

; 4925 : 			e = f->GetNextUnitElement();

	mov	eax, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 4926 : 		}

	jmp	SHORT $LN5@FindUnitNa
$LN6@FindUnitNa:

; 4927 : 	}
; 4928 : 	return element;

	mov	eax, DWORD PTR _element$[ebp]
$LN14@FindUnitNa:

; 4929 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?FindUnitNameID@@YAHPAVUnitClass@@@Z$0:
	lea	ecx, DWORD PTR _myit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?FindUnitNameID@@YAHPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindUnitNameID@@YAHPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindUnitNameID@@YAHPAVUnitClass@@@Z ENDP		; FindUnitNameID
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$2 = -100						; size = 12
_btype$ = -88						; size = 4
tv95 = -84						; size = 4
_bcount$ = -80						; size = 4
_e$ = -76						; size = 4
_i$ = -72						; size = 4
_count$ = -68						; size = 50
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_div$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_object$ = 20						; size = 4
?GetDivisionName@@YAPADHPADHH@Z PROC			; GetDivisionName

; 4851 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetDivisionName@@YAPADHPADHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4852 : 	Unit		e;
; 4853 : 	uchar		count[50];
; 4854 : 	int			bcount=0,btype=0,i;

	mov	DWORD PTR _bcount$[ebp], 0
	mov	DWORD PTR _btype$[ebp], 0

; 4855 : 
; 4856 : 	if (!div)

	cmp	DWORD PTR _div$[ebp], 0
	jne	SHORT $LN8@GetDivisio

; 4857 : 	{
; 4858 : 		ReadIndexedString(167, buffer, 29);

	push	29					; 0000001dH
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	167					; 000000a7H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 4859 : 		return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	jmp	$LN9@GetDivisio
$LN8@GetDivisio:

; 4860 : 	}
; 4861 : 
; 4862 : 	memset(count,0,50);

	push	50					; 00000032H
	push	0
	lea	ecx, DWORD PTR _count$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 4863 : 
; 4864 : 	{
; 4865 : 		VuListIterator		myit(AllUnitList);

	mov	edx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	edx
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4866 : 		e = GetFirstUnit(&myit);

	lea	eax, DWORD PTR _myit$2[ebp]
	push	eax
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax
$LN7@GetDivisio:

; 4867 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN6@GetDivisio

; 4868 : 		{
; 4869 : 			if (e->GetUnitDivision() == div && e->Parent())

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	cmp	eax, DWORD PTR _div$[ebp]
	jne	SHORT $LN5@GetDivisio
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	SHORT $LN5@GetDivisio

; 4870 : 				count[e->GetSType()]++;

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	lea	edx, DWORD PTR _count$[ebp+ecx]
	mov	DWORD PTR tv95[ebp], edx
	mov	eax, DWORD PTR tv95[ebp]
	mov	cl, BYTE PTR [eax]
	add	cl, 1
	mov	edx, DWORD PTR tv95[ebp]
	mov	BYTE PTR [edx], cl
$LN5@GetDivisio:

; 4871 : 			e = GetNextUnit(&myit);

	lea	eax, DWORD PTR _myit$2[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 4872 : 		}

	jmp	SHORT $LN7@GetDivisio
$LN6@GetDivisio:

; 4873 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 4874 : 
; 4875 : 	for (i=0; i<50; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GetDivisio
$LN3@GetDivisio:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@GetDivisio:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	SHORT $LN2@GetDivisio

; 4876 : 	{
; 4877 : 		if (count[i] > bcount)

	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _count$[ebp+edx]
	cmp	eax, DWORD PTR _bcount$[ebp]
	jle	SHORT $LN1@GetDivisio

; 4878 : 		{
; 4879 : 			bcount = count[i];

	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _count$[ebp+ecx]
	mov	DWORD PTR _bcount$[ebp], edx

; 4880 : 			btype = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _btype$[ebp], eax
$LN1@GetDivisio:

; 4881 : 		}
; 4882 : 	}

	jmp	SHORT $LN3@GetDivisio
$LN2@GetDivisio:

; 4883 : 
; 4884 : 	return GetDivisionName (div, btype, buffer, size, object);

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _btype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _div$[ebp]
	push	edx
	call	?GetDivisionName@@YAPADHHPADHH@Z	; GetDivisionName
	add	esp, 20					; 00000014H
$LN9@GetDivisio:

; 4885 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetDivisionName@@YAPADHPADHH@Z$0:
	lea	ecx, DWORD PTR _myit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?GetDivisionName@@YAPADHPADHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetDivisionName@@YAPADHPADHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetDivisionName@@YAPADHPADHH@Z ENDP			; GetDivisionName
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_domain$ = 8						; size = 4
_type$ = 12						; size = 4
_buffer$ = 16						; size = 4
?GetSizeName@@YAPADHHPAD@Z PROC				; GetSizeName

; 4796 : {

	push	ebp
	mov	ebp, esp

; 4797 : 	if (domain == DOMAIN_AIR)

	cmp	DWORD PTR _domain$[ebp], 2
	jne	SHORT $LN14@GetSizeNam

; 4798 : 	{
; 4799 : 		if (type == TYPE_SQUADRON)

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN13@GetSizeNam

; 4800 : 			ReadIndexedString(610, buffer, 19);

	push	19					; 00000013H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	610					; 00000262H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN12@GetSizeNam
$LN13@GetSizeNam:

; 4801 : 		else if (type == TYPE_FLIGHT)

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN11@GetSizeNam

; 4802 : 			ReadIndexedString(611, buffer, 19);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	611					; 00000263H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN12@GetSizeNam
$LN11@GetSizeNam:

; 4803 : 		else if (type == TYPE_PACKAGE)

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN12@GetSizeNam

; 4804 : 			ReadIndexedString(612, buffer, 19);

	push	19					; 00000013H
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	612					; 00000264H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN12@GetSizeNam:

; 4805 : 	}

	jmp	SHORT $LN8@GetSizeNam
$LN14@GetSizeNam:

; 4806 : 	else if (domain == DOMAIN_LAND)

	cmp	DWORD PTR _domain$[ebp], 3
	jne	SHORT $LN7@GetSizeNam

; 4807 : 	{
; 4808 : 		if (type == TYPE_BRIGADE)

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN6@GetSizeNam

; 4809 : 			ReadIndexedString(614, buffer, 19);

	push	19					; 00000013H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	614					; 00000266H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@GetSizeNam
$LN6@GetSizeNam:

; 4810 : 		else if (type == TYPE_BATTALION)

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN5@GetSizeNam

; 4811 : 			ReadIndexedString(615, buffer, 19);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	615					; 00000267H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN5@GetSizeNam:

; 4812 : 	}

	jmp	SHORT $LN8@GetSizeNam
$LN7@GetSizeNam:

; 4813 : 	else if (domain == DOMAIN_SEA)

	cmp	DWORD PTR _domain$[ebp], 4
	jne	SHORT $LN2@GetSizeNam

; 4814 : 		ReadIndexedString(616, buffer, 19);

	push	19					; 00000013H
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	616					; 00000268H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 4815 : 	else

	jmp	SHORT $LN8@GetSizeNam
$LN2@GetSizeNam:

; 4816 : 		ReadIndexedString(617, buffer, 19);

	push	19					; 00000013H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	617					; 00000269H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN8@GetSizeNam:

; 4817 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 4818 : }

	pop	ebp
	ret	0
?GetSizeName@@YAPADHHPAD@Z ENDP				; GetSizeName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_p$ = -20						; size = 4
_nu$ = -16						; size = 4
_z$ = -12						; size = 2
_x$ = -8						; size = 2
_y$ = -4						; size = 2
_u$ = 8							; size = 4
_domain$ = 12						; size = 4
_type$ = 16						; size = 4
_stype$ = 20						; size = 4
_sptype$ = 24						; size = 4
?ConvertUnit@@YAPAVUnitClass@@PAV1@HHHH@Z PROC		; ConvertUnit

; 4726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 4727 : 	Unit		nu,p=NULL;

	mov	DWORD PTR _p$[ebp], 0

; 4728 : 	GridIndex	x,y;
; 4729 : 	short		z;
; 4730 : 
; 4731 : 	nu = NewUnit(domain,type,stype,sptype,u->GetUnitParent());

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _sptype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stype$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _domain$[ebp]
	push	ecx
	call	?NewUnit@@YAPAVUnitClass@@HHHHPAV1@@Z	; NewUnit
	add	esp, 20					; 00000014H
	mov	DWORD PTR _nu$[ebp], eax

; 4732 : 	if (!nu)

	cmp	DWORD PTR _nu$[ebp], 0
	jne	SHORT $LN1@ConvertUni

; 4733 : 		return u;

	mov	eax, DWORD PTR _u$[ebp]
	jmp	$LN2@ConvertUni
$LN1@ConvertUni:

; 4734 : 	u->DisposeChildren();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+976]
	call	edx

; 4735 : 
; 4736 : 	// Copy Data (Common Unit, CampBase, and VuEntity data)
; 4737 : 	nu->SetLastCheck (u->GetLastCheck());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLastCheck@UnitClass@@QAEKXZ		; UnitClass::GetLastCheck
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck

; 4738 : 	nu->SetRoster (u->GetRoster());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetRoster@UnitClass@@QAEJXZ		; UnitClass::GetRoster
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetRoster@UnitClass@@QAEXJ@Z		; UnitClass::SetRoster

; 4739 : 	nu->SetUnitFlags (u->GetUnitFlags());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitFlags@UnitClass@@QAEJXZ		; UnitClass::GetUnitFlags
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetUnitFlags@UnitClass@@QAEXJ@Z	; UnitClass::SetUnitFlags

; 4740 : 	nu->SetDestX (u->GetDestX());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDestX@UnitClass@@QAEFXZ		; UnitClass::GetDestX
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetDestX@UnitClass@@QAEXF@Z		; UnitClass::SetDestX

; 4741 : 	nu->SetDestY (u->GetDestY());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDestY@UnitClass@@QAEFXZ		; UnitClass::GetDestY
	movzx	ecx, ax
	push	ecx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetDestY@UnitClass@@QAEXF@Z		; UnitClass::SetDestY

; 4742 : 	nu->SetMoved (u->GetMoved());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetMoved@UnitClass@@QAEEXZ		; UnitClass::GetMoved
	movzx	edx, al
	push	edx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetMoved@UnitClass@@QAEXE@Z		; UnitClass::SetMoved

; 4743 : 	nu->SetLosses (u->GetLosses());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLosses@UnitClass@@QAEEXZ		; UnitClass::GetLosses
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetLosses@UnitClass@@QAEXE@Z		; UnitClass::SetLosses

; 4744 : 	nu->SetTactic (u->GetTactic());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTactic@UnitClass@@QAEEXZ		; UnitClass::GetTactic
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetTactic@UnitClass@@QAEXE@Z		; UnitClass::SetTactic

; 4745 : 	nu->SetCurrentWaypoint (u->GetCurrentWaypoint());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCurrentWaypoint@UnitClass@@QAEGXZ	; UnitClass::GetCurrentWaypoint
	movzx	edx, ax
	push	edx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetCurrentWaypoint@UnitClass@@QAEXG@Z	; UnitClass::SetCurrentWaypoint

; 4746 : 	nu->SetNameId (u->GetNameId());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetNameId@UnitClass@@QAEFXZ		; UnitClass::GetNameId
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetNameId@UnitClass@@QAEXF@Z		; UnitClass::SetNameId

; 4747 : 	nu->wp_list = u->wp_list;

	mov	ecx, DWORD PTR _nu$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR [ecx+244], eax

; 4748 : 	nu->SetSpottedTime (u->GetSpotTime());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSpotTime@CampBaseClass@@QBEKXZ	; CampBaseClass::GetSpotTime
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetSpottedTime@CampBaseClass@@QAEXK@Z	; CampBaseClass::SetSpottedTime

; 4749 : 	nu->SetSpotted (u->GetOwner(), u->GetSpotted());

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSpotted@CampBaseClass@@QBEFXZ	; CampBaseClass::GetSpotted
	movsx	ecx, ax
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	push	edx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted

; 4750 : 	nu->SetBaseFlags (u->GetBaseFlags());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetBaseFlags@CampBaseClass@@QBEFXZ	; CampBaseClass::GetBaseFlags
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetBaseFlags@CampBaseClass@@QAEXF@Z	; CampBaseClass::SetBaseFlags

; 4751 : 	nu->SetOwner (u->GetOwner());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _nu$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nu$[ebp]
	mov	edx, DWORD PTR [eax+320]
	call	edx

; 4752 : 	nu->SetTargetId (u->GetTargetId());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTargetId@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetTargetId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetTargetId@UnitClass@@QAEXVVU_ID@@@Z	; UnitClass::SetTargetId

; 4753 : 	nu->SetCampId (u->GetCampId());

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetCampId@CampBaseClass@@QBEFXZ	; CampBaseClass::GetCampId
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetCampId@CampBaseClass@@QAEXF@Z	; CampBaseClass::SetCampId

; 4754 : 	u->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 4755 : 	z = u->GetAltitude();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetAltitude@FalconEntity@@QBEHXZ	; FalconEntity::GetAltitude
	mov	WORD PTR _z$[ebp], ax

; 4756 : 	nu->SetLocation(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetLocation@CampBaseClass@@QAEXFF@Z	; CampBaseClass::SetLocation

; 4757 : 	nu->SetAltitude(z);

	movsx	edx, WORD PTR _z$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nu$[ebp]
	call	?SetAltitude@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetAltitude

; 4758 : 	nu->BuildElements();

	mov	ecx, DWORD PTR _nu$[ebp]
	call	?BuildElements@UnitClass@@QAEXXZ	; UnitClass::BuildElements

; 4759 : 
; 4760 : 	u->Remove();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?Remove@CampBaseClass@@QAEHXZ		; CampBaseClass::Remove

; 4761 : 	return nu;

	mov	eax, DWORD PTR _nu$[ebp]
$LN2@ConvertUni:

; 4762 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ConvertUnit@@YAPAVUnitClass@@PAV1@HHHH@Z ENDP		; ConvertUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_e$ = -4						; size = 4
_l$ = 8							; size = 4
?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z PROC ; GetNextUnit

; 4699 : Unit GetNextUnit(F4LIt l){

	push	ebp
	mov	ebp, esp
	push	ecx

; 4700 : 	VuEntity *e;
; 4701 : 
; 4702 : 	e = l->GetNext();

	mov	ecx, DWORD PTR _l$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax
$LN3@GetNextUni:

; 4703 : 	while (e){

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN2@GetNextUni

; 4704 : 		//if (e->VuState() != VU_MEM_DELETED)
; 4705 : 		if (GetEntityClass(e) == CLASS_UNIT){

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?GetEntityClass@@YAFPAVVuEntity@@@Z	; GetEntityClass
	add	esp, 4
	movsx	ecx, ax
	cmp	ecx, 6
	jne	SHORT $LN1@GetNextUni

; 4706 : 			return (Unit)e;

	mov	eax, DWORD PTR _e$[ebp]
	jmp	SHORT $LN4@GetNextUni
$LN1@GetNextUni:

; 4707 : 		}
; 4708 : 		e = l->GetNext();

	mov	ecx, DWORD PTR _l$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax

; 4709 : 	}

	jmp	SHORT $LN3@GetNextUni
$LN2@GetNextUni:

; 4710 : 	return NULL;

	xor	eax, eax
$LN4@GetNextUni:

; 4711 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ENDP ; GetNextUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_e$ = -4						; size = 4
_l$ = 8							; size = 4
?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z PROC ; GetFirstUnit

; 4686 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4687 : 	VuEntity*	e;
; 4688 : 
; 4689 : 	e = l->GetFirst();

	mov	ecx, DWORD PTR _l$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _e$[ebp], eax
$LN3@GetFirstUn:

; 4690 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN2@GetFirstUn

; 4691 : 	{
; 4692 : 		if (GetEntityClass(e) == CLASS_UNIT)

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?GetEntityClass@@YAFPAVVuEntity@@@Z	; GetEntityClass
	add	esp, 4
	movsx	ecx, ax
	cmp	ecx, 6
	jne	SHORT $LN1@GetFirstUn

; 4693 : 			return (Unit)e;

	mov	eax, DWORD PTR _e$[ebp]
	jmp	SHORT $LN4@GetFirstUn
$LN1@GetFirstUn:

; 4694 : 		e = l->GetNext();

	mov	ecx, DWORD PTR _l$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax

; 4695 : 	}

	jmp	SHORT $LN3@GetFirstUn
$LN2@GetFirstUn:

; 4696 : 	return NULL;

	xor	eax, eax
$LN4@GetFirstUn:

; 4697 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ENDP ; GetFirstUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$ = -64						; size = 12
$T2 = -52						; size = 8
_cd$ = -44						; size = 8
_size$ = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
_data_ptr$ = -24					; size = 4
_rem$ = -20						; size = 4
_u$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_scenario$ = 8						; size = 4
?LoadUnits@@YAHPAD@Z PROC				; LoadUnits

; 4650 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadUnits@@YAHPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4651 : 	long	size;
; 4652 : 	uchar /* *data,*/ *data_ptr;;
; 4653 : 
; 4654 : 
; 4655 : 	CampaignData cd = ReadCampFile (scenario, "uni");

	push	OFFSET ??_C@_03HECMEGIJ@uni?$AA@
	mov	eax, DWORD PTR _scenario$[ebp]
	push	eax
	call	?ReadCampFile@@YA?AUCampaignData@@PAD0@Z ; ReadCampFile
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _cd$[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _cd$[ebp+4], edx

; 4656 : 	if (cd.dataSize == -1){

	cmp	DWORD PTR _cd$[ebp], -1
	jne	SHORT $LN4@LoadUnits

; 4657 : 		return 0;

	xor	eax, eax
	jmp	$LN5@LoadUnits
$LN4@LoadUnits:

; 4658 : 	}
; 4659 : 
; 4660 : 	data_ptr = (uchar*)cd.data;

	mov	eax, DWORD PTR _cd$[ebp+4]
	mov	DWORD PTR _data_ptr$[ebp], eax

; 4661 : 	long rem = cd.dataSize;

	mov	ecx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR _rem$[ebp], ecx

; 4662 : 
; 4663 : 	//take size out and update pointer
; 4664 : 	//this size is not used anywhere, so ill trust my size
; 4665 : 	memcpychk(&size, &data_ptr, sizeof(long), &rem);

	lea	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _data_ptr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 4666 : 
; 4667 : 	//updated the call to include remaining value
; 4668 : 	DecodeUnitData (&data_ptr, &rem, NULL);

	push	0
	lea	edx, DWORD PTR _rem$[ebp]
	push	edx
	lea	eax, DWORD PTR _data_ptr$[ebp]
	push	eax
	call	?DecodeUnitData@@YAHPAPAEPAJPAVFalconSessionEntity@@@Z ; DecodeUnitData
	add	esp, 12					; 0000000cH

; 4669 : 	delete cd.data;

	mov	ecx, DWORD PTR _cd$[ebp+4]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4670 : 
; 4671 : 	// KCK HACK: Reset any saved off player slots
; 4672 : 	VuListIterator		myit(AllAirList);

	mov	eax, DWORD PTR ?AllAirList@@3PAVVuLinkedList@@A ; AllAirList
	push	eax
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4673 : 	Unit				u;
; 4674 : 	u = (Unit) myit.GetFirst();

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _u$[ebp], eax
$LN3@LoadUnits:

; 4675 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN2@LoadUnits

; 4676 : 	{
; 4677 : 		if (u->IsFlight())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN1@LoadUnits

; 4678 : 			memset(((FlightClass*)u)->player_slots,NO_PILOT,PILOTS_PER_FLIGHT*sizeof(uchar));

	push	4
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	add	ecx, 420				; 000001a4H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@LoadUnits:

; 4679 : 		u = (Unit) myit.GetNext();

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _u$[ebp], eax

; 4680 : 	}

	jmp	SHORT $LN3@LoadUnits
$LN2@LoadUnits:

; 4681 : 
; 4682 : 	return 1;

	mov	DWORD PTR $T3[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T3[ebp]
$LN5@LoadUnits:

; 4683 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadUnits@@YAHPAD@Z$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?LoadUnits@@YAHPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadUnits@@YAHPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadUnits@@YAHPAD@Z ENDP				; LoadUnits
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
_buffer$ = -12						; size = 4
_size$ = -8						; size = 4
_fp$ = -4						; size = 4
_scenario$ = 8						; size = 4
?SaveUnits@@YAXPAD@Z PROC				; SaveUnits

; 4632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4633 : 	long	size;
; 4634 : 	FILE	*fp;
; 4635 : 	uchar	*buffer;
; 4636 : 
; 4637 : 	size = EncodeUnitData (&buffer, NULL);

	push	0
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	?EncodeUnitData@@YAHPAPAEPAVFalconSessionEntity@@@Z ; EncodeUnitData
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 4638 : 
; 4639 : 	if ((fp = OpenCampFile (scenario, "uni", "wb")) == NULL)

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	OFFSET ??_C@_03HECMEGIJ@uni?$AA@
	mov	ecx, DWORD PTR _scenario$[ebp]
	push	ecx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN1@SaveUnits

; 4640 : 		return;

	jmp	SHORT $LN2@SaveUnits
$LN1@SaveUnits:

; 4641 : 
; 4642 : 	fwrite (&size, sizeof(long), 1, fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 4643 : 	fwrite (buffer, size, 1, fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 4644 : 	CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 4645 : 	delete buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@SaveUnits:

; 4646 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveUnits@@YAXPAD@Z ENDP				; SaveUnits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$ = -108						; size = 12
_vehicles$ = -96					; size = 4
_vehicle$ = -92						; size = 4
_this$ = -88						; size = 4
_slot$ = -84						; size = 4
_inSlot$ = -80						; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_theUnit$ = 8						; size = 4
?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z PROC ; UnitDeaggregationData::StoreDeaggregationData
; _this$ = ecx

; 5368 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5369 : 	if (!theUnit || theUnit->IsAggregate() || theUnit->GetDomain() != DOMAIN_LAND || !theUnit->GetComponents())

	cmp	DWORD PTR _theUnit$[ebp], 0
	je	SHORT $LN6@StoreDeagg
	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN6@StoreDeagg
	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	jne	SHORT $LN6@StoreDeagg
	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	jne	SHORT $LN7@StoreDeagg
$LN6@StoreDeagg:

; 5370 : 		return;

	jmp	$LN8@StoreDeagg
$LN7@StoreDeagg:

; 5371 : 
; 5372 : 	int				vehicles = 0,slot;

	mov	DWORD PTR _vehicles$[ebp], 0

; 5373 : 	int				inSlot[VEHICLE_GROUPS_PER_UNIT] = { 0 };

	mov	DWORD PTR _inSlot$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	ecx, DWORD PTR _inSlot$[ebp+4]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 5374 : 	SimBaseClass*	vehicle;
; 5375 : 
; 5376 : 	// Init them to something reasonable
; 5377 : 	for (slot=0; slot<3*VEHICLE_GROUPS_PER_UNIT; slot++)

	mov	DWORD PTR _slot$[ebp], 0
	jmp	SHORT $LN5@StoreDeagg
$LN4@StoreDeagg:
	mov	edx, DWORD PTR _slot$[ebp]
	add	edx, 1
	mov	DWORD PTR _slot$[ebp], edx
$LN5@StoreDeagg:
	cmp	DWORD PTR _slot$[ebp], 48		; 00000030H
	jge	SHORT $LN3@StoreDeagg

; 5378 : 	{
; 5379 : 		position_data[slot].x = theUnit->XPos();

	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _slot$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+eax+4]

; 5380 : 		position_data[slot].y = theUnit->YPos();

	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _slot$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+edx+8]

; 5381 : 		position_data[slot].heading = theUnit->Yaw();

	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	ecx, DWORD PTR _slot$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+ecx+12]

; 5382 : 	}

	jmp	SHORT $LN4@StoreDeagg
$LN3@StoreDeagg:

; 5383 : 
; 5384 : 	VuListIterator	myit(theUnit->GetComponents());

	mov	ecx, DWORD PTR _theUnit$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5385 : 	vehicle = (SimBaseClass*) myit.GetFirst();

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _vehicle$[ebp], eax
$LN2@StoreDeagg:

; 5386 : 	while (vehicle)

	cmp	DWORD PTR _vehicle$[ebp], 0
	je	$LN1@StoreDeagg

; 5387 : 	{
; 5388 : 		slot = vehicle->GetSlot();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?GetSlot@SimBaseClass@@QAEHXZ		; SimBaseClass::GetSlot
	mov	DWORD PTR _slot$[ebp], eax

; 5389 : 		position_data[slot*3 + inSlot[slot]].x = vehicle->XPos();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _slot$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _slot$[ebp]
	add	eax, DWORD PTR _inSlot$[ebp+ecx*4]
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+eax+4]

; 5390 : 		position_data[slot*3 + inSlot[slot]].y = vehicle->YPos();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _slot$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _slot$[ebp]
	add	eax, DWORD PTR _inSlot$[ebp+ecx*4]
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+eax+8]

; 5391 : 		position_data[slot*3 + inSlot[slot]].heading = vehicle->Yaw();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	eax, DWORD PTR _slot$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _slot$[ebp]
	add	eax, DWORD PTR _inSlot$[ebp+ecx*4]
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+eax+12]

; 5392 : 		inSlot[slot]++;

	mov	eax, DWORD PTR _slot$[ebp]
	mov	ecx, DWORD PTR _inSlot$[ebp+eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _slot$[ebp]
	mov	DWORD PTR _inSlot$[ebp+edx*4], ecx

; 5393 : 		vehicles++;

	mov	eax, DWORD PTR _vehicles$[ebp]
	add	eax, 1
	mov	DWORD PTR _vehicles$[ebp], eax

; 5394 : 		vehicle = (SimBaseClass*) myit.GetNext();

	lea	ecx, DWORD PTR _myit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _vehicle$[ebp], eax

; 5395 : 	}

	jmp	$LN2@StoreDeagg
$LN1@StoreDeagg:

; 5396 : 	num_vehicles = vehicles;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _vehicles$[ebp]
	mov	WORD PTR [ecx], dx

; 5397 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN8@StoreDeagg:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z ENDP ; UnitDeaggregationData::StoreDeaggregationData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1UnitDeaggregationData@@QAE@XZ PROC			; UnitDeaggregationData::~UnitDeaggregationData
; _this$ = ecx

; 5364 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5365 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1UnitDeaggregationData@@QAE@XZ ENDP			; UnitDeaggregationData::~UnitDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0UnitDeaggregationData@@QAE@XZ PROC			; UnitDeaggregationData::UnitDeaggregationData
; _this$ = ecx

; 5359 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5360 : 	num_vehicles = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx], ax

; 5361 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0UnitDeaggregationData@@QAE@XZ ENDP			; UnitDeaggregationData::UnitDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUnitClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GUnitClass@@UAEPAXI@Z PROC				; UnitClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UnitClass@@UAE@XZ			; UnitClass::~UnitClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GUnitClass@@UAEPAXI@Z ENDP				; UnitClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv297 = -40						; size = 4
tv313 = -36						; size = 4
tv293 = -32						; size = 4
tv289 = -28						; size = 4
tv311 = -24						; size = 4
tv285 = -20						; size = 4
_rangesq$1 = -16					; size = 4
_e$ = -12						; size = 4
_this$ = -8						; size = 4
_who$ = -1						; size = 1
_iter$ = 8						; size = 4
?CalculateSOJ@UnitClass@@QAEXAAVVuGridIterator@@@Z PROC	; UnitClass::CalculateSOJ
; _this$ = ecx

; 5974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 5975 : 	Team who = GetTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _who$[ebp], al

; 5976 : 	CampEntity	e;
; 5977 : 
; 5978 : 	// JB SOJ
; 5979 : 	sojSource = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+248], 0

; 5980 : 	sojOctant = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+252], 0

; 5981 : 	// start my assuming the biggest distance possible.
; 5982 : 	sojRangeSq = KM_TO_FT * GetElectronicDetectionRange(Air);

	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+256], xmm0

; 5983 : 	if (sojRangeSq == 0) return; // no point looking further

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+256]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CalculateS
	jmp	$LN6@CalculateS
$LN5@CalculateS:

; 5984 : 	sojRangeSq *= sojRangeSq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+256]
	mulss	xmm0, DWORD PTR [ecx+256]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+256], xmm0

; 5985 : 	e = (CampEntity)iter.GetFirst();

	mov	ecx, DWORD PTR _iter$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _e$[ebp], eax
$LN4@CalculateS:

; 5986 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN3@CalculateS

; 5987 : 	{
; 5988 : 		// JPO - use IsAreaJamming - the virtual functions will sort it out
; 5989 : 		if (GetRoE(who,e->GetTeam(),ROE_GROUND_FIRE) == ROE_ALLOWED && 
; 5990 : 						e->IsAreaJamming() )

	push	1
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN1@CalculateS
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+272]
	call	eax
	test	eax, eax
	je	$LN1@CalculateS

; 5991 : 		{
; 5992 : 			float rangesq = DistSqu(XPos(), YPos(), e->XPos(), e->YPos());

	mov	ecx, DWORD PTR _e$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _e$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?DistSqu@@YAMMMMM@Z			; DistSqu
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _rangesq$1[ebp]

; 5993 : 
; 5994 : 			if (rangesq < sojRangeSq)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+256]
	comiss	xmm0, DWORD PTR _rangesq$1[ebp]
	jbe	$LN1@CalculateS

; 5995 : 			{
; 5996 : 				sojSource = e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+248], eax

; 5997 : 				sojOctant = OctantTo(0.0F, 0.0F, e->XPos() - XPos(), e->YPos() - YPos());

	mov	ecx, DWORD PTR _e$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv285[ebp]
	movss	xmm0, DWORD PTR tv285[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv311[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv289[ebp]
	movss	xmm0, DWORD PTR tv311[ebp]
	subss	xmm0, DWORD PTR tv289[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv293[ebp]
	movss	xmm0, DWORD PTR tv293[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv313[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv297[ebp]
	movss	xmm0, DWORD PTR tv313[ebp]
	subss	xmm0, DWORD PTR tv297[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	?OctantTo@@YAHMMMM@Z			; OctantTo
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+252], eax

; 5998 : 				sojRangeSq = rangesq;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rangesq$1[ebp]
	movss	DWORD PTR [edx+256], xmm0
$LN1@CalculateS:

; 5999 : 			}
; 6000 : 		}
; 6001 : 
; 6002 : 		e = (CampEntity)iter.GetNext();

	mov	ecx, DWORD PTR _iter$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _e$[ebp], eax

; 6003 : 	}

	jmp	$LN4@CalculateS
$LN3@CalculateS:
$LN6@CalculateS:

; 6004 : 	// JB SOJ
; 6005 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateSOJ@UnitClass@@QAEXAAVVuGridIterator@@@Z ENDP	; UnitClass::CalculateSOJ
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?UpdateParentStatistics@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateParentStatistics@UnitClass@@UAEHXZ PROC		; UnitClass::UpdateParentStatistics, COMDAT
; _this$ = ecx

; 559  : 	virtual int UpdateParentStatistics (void)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateParentStatistics@UnitClass@@UAEHXZ ENDP		; UnitClass::UpdateParentStatistics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ReorganizeUnit@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReorganizeUnit@UnitClass@@UAEXXZ PROC			; UnitClass::ReorganizeUnit, COMDAT
; _this$ = ecx

; 558  : 	virtual void ReorganizeUnit (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReorganizeUnit@UnitClass@@UAEXXZ ENDP			; UnitClass::ReorganizeUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::RemoveChild, COMDAT
; _this$ = ecx

; 557  : 	virtual void RemoveChild (VU_ID)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveChild@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::RemoveChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DisposeChildren@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisposeChildren@UnitClass@@UAEXXZ PROC			; UnitClass::DisposeChildren, COMDAT
; _this$ = ecx

; 556  : 	virtual void DisposeChildren (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisposeChildren@UnitClass@@UAEXXZ ENDP			; UnitClass::DisposeChildren
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?AddUnitChild@UnitClass@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?AddUnitChild@UnitClass@@UAEXPAV1@@Z PROC		; UnitClass::AddUnitChild, COMDAT
; _this$ = ecx

; 555  : 	virtual void AddUnitChild (Unit)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddUnitChild@UnitClass@@UAEXPAV1@@Z ENDP		; UnitClass::AddUnitChild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z PROC	; UnitClass::GetPrevUnitElement, COMDAT
; _this$ = ecx

; 554  : 	virtual Unit GetPrevUnitElement (Unit)						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrevUnitElement@UnitClass@@UAEPAV1@PAV1@@Z ENDP	; UnitClass::GetPrevUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z PROC		; UnitClass::GetUnitElementByID, COMDAT
; _this$ = ecx

; 553  : 	virtual Unit GetUnitElementByID (int)						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitElementByID@UnitClass@@UAEPAV1@H@Z ENDP		; UnitClass::GetUnitElementByID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElement@UnitClass@@UAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitElement@UnitClass@@UAEPAV1@H@Z PROC		; UnitClass::GetUnitElement, COMDAT
; _this$ = ecx

; 552  : 	virtual Unit GetUnitElement (int)							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitElement@UnitClass@@UAEPAV1@H@Z ENDP		; UnitClass::GetUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNextUnitElement@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextUnitElement@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetNextUnitElement, COMDAT
; _this$ = ecx

; 551  : 	virtual Unit GetNextUnitElement() const						{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextUnitElement@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetNextUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetFirstUnitElement, COMDAT
; _this$ = ecx

; 550  : 	virtual Unit GetFirstUnitElement() const					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitElement@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetFirstUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitParent@UnitClass@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitParent@UnitClass@@UAEXPAV1@@Z PROC		; UnitClass::SetUnitParent, COMDAT
; _this$ = ecx

; 543  : 	virtual void SetUnitParent (Unit)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitParent@UnitClass@@UAEXPAV1@@Z ENDP		; UnitClass::SetUnitParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitParentID, COMDAT
; _this$ = ecx

; 542  : 	virtual VU_ID GetUnitParentID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitParentID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitParentID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitParent@UnitClass@@UBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitParent@UnitClass@@UBEPAV1@XZ PROC		; UnitClass::GetUnitParent, COMDAT
; _this$ = ecx

; 541  : 	virtual Unit GetUnitParent() const							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitParent@UnitClass@@UBEPAV1@XZ ENDP		; UnitClass::GetUnitParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?RallyUnit@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?RallyUnit@UnitClass@@UAEHH@Z PROC			; UnitClass::RallyUnit, COMDAT
; _this$ = ecx

; 538  : 	virtual int RallyUnit (int)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?RallyUnit@UnitClass@@UAEHH@Z ENDP			; UnitClass::RallyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildMission@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BuildMission@UnitClass@@UAEHXZ PROC			; UnitClass::BuildMission, COMDAT
; _this$ = ecx

; 537  : 	virtual int BuildMission (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildMission@UnitClass@@UAEHXZ ENDP			; UnitClass::BuildMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CheckForSurrender@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CheckForSurrender@UnitClass@@UAEHXZ PROC		; UnitClass::CheckForSurrender, COMDAT
; _this$ = ecx

; 536  : 	virtual int CheckForSurrender (void)						{ return 1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForSurrender@UnitClass@@UAEHXZ ENDP		; UnitClass::CheckForSurrender
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetObjMovementType@UnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetObjMovementType@UnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z PROC ; UnitClass::GetObjMovementType, COMDAT
; _this$ = ecx

; 535  : 	virtual MoveType GetObjMovementType (Objective, int)	{ return CampBaseClass::GetMovementType(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ ; FalconEntity::GetMovementType
	mov	esp, ebp
	pop	ebp
	ret	8
?GetObjMovementType@UnitClass@@UAE?AW4MoveType@@PAVObjectiveClass@@H@Z ENDP ; UnitClass::GetObjMovementType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z PROC	; UnitClass::GetUnitCurrentDestination, COMDAT
; _this$ = ecx

; 534  : 	virtual void GetUnitCurrentDestination(GridIndex*, GridIndex*)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitCurrentDestination@UnitClass@@UAEXPAF0@Z ENDP	; UnitClass::GetUnitCurrentDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 2
___formal$ = 12						; size = 2
?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z PROC	; UnitClass::SetUnitCurrentDestination, COMDAT
; _this$ = ecx

; 533  : 	virtual void SetUnitCurrentDestination(GridIndex, GridIndex)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitCurrentDestination@UnitClass@@UAEXFF@Z ENDP	; UnitClass::SetUnitCurrentDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNextMoveDirection@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextMoveDirection@UnitClass@@UAEHXZ PROC		; UnitClass::GetNextMoveDirection, COMDAT
; _this$ = ecx

; 532  : 	virtual int GetNextMoveDirection (void)						{ return Here; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextMoveDirection@UnitClass@@UAEHXZ ENDP		; UnitClass::GetNextMoveDirection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ClearUnitPath@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearUnitPath@UnitClass@@UAEXXZ PROC			; UnitClass::ClearUnitPath, COMDAT
; _this$ = ecx

; 531  : 	virtual void ClearUnitPath (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearUnitPath@UnitClass@@UAEXXZ ENDP			; UnitClass::ClearUnitPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitNextMove@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetUnitNextMove@UnitClass@@UAEXXZ PROC			; UnitClass::SetUnitNextMove, COMDAT
; _this$ = ecx

; 530  : 	virtual void SetUnitNextMove (void)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetUnitNextMove@UnitClass@@UAEXXZ ENDP			; UnitClass::SetUnitNextMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitHeading@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitHeading@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitHeading, COMDAT
; _this$ = ecx

; 529  : 	virtual int GetUnitHeading (void)							{ return Here; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitHeading@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitDivision@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitDivision@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitDivision, COMDAT
; _this$ = ecx

; 528  : 	virtual int GetUnitDivision (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitDivision@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPosition@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPosition@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitPosition, COMDAT
; _this$ = ecx

; 527  : 	virtual int GetUnitPosition (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPosition@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMode@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMode@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitMode, COMDAT
; _this$ = ecx

; 526  : 	virtual int GetUnitMode (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMode@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitElement@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitElement@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitElement, COMDAT
; _this$ = ecx

; 525  : 	virtual int GetUnitElement (void) 							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitElement@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitFatigue@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitFatigue@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitFatigue, COMDAT
; _this$ = ecx

; 524  : 	virtual int GetUnitFatigue (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFatigue@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitFatigue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitOrders@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitOrders@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitOrders, COMDAT
; _this$ = ecx

; 523  : 	virtual int GetUnitOrders (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitOrders@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitObjectiveID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitObjectiveID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitObjectiveID, COMDAT
; _this$ = ecx

; 522  : 	virtual VU_ID GetUnitObjectiveID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitObjectiveID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitObjectiveID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSecondaryObjID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitSecondaryObjID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitSecondaryObjID, COMDAT
; _this$ = ecx

; 521  : 	virtual VU_ID GetUnitSecondaryObjID (void)					{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSecondaryObjID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitSecondaryObjID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPrimaryObjID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitPrimaryObjID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitPrimaryObjID, COMDAT
; _this$ = ecx

; 520  : 	virtual VU_ID GetUnitPrimaryObjID (void)					{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitPrimaryObjID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitPrimaryObjID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitObjective@UnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitObjective@UnitClass@@UAEPAVObjectiveClass@@XZ PROC ; UnitClass::GetUnitObjective, COMDAT
; _this$ = ecx

; 519  : 	virtual Objective GetUnitObjective (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitObjective@UnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; UnitClass::GetUnitObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSecondaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSecondaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ PROC ; UnitClass::GetUnitSecondaryObj, COMDAT
; _this$ = ecx

; 518  : 	virtual Objective GetUnitSecondaryObj (void)				{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSecondaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; UnitClass::GetUnitSecondaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ PROC ; UnitClass::GetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 517  : 	virtual Objective GetUnitPrimaryObj (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPrimaryObj@UnitClass@@UAEPAVObjectiveClass@@XZ ENDP ; UnitClass::GetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitHeading@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitHeading@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitHeading, COMDAT
; _this$ = ecx

; 516  : 	virtual void SetUnitHeading (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitHeading@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitHeading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitDivision@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitDivision@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitDivision, COMDAT
; _this$ = ecx

; 515  : 	virtual void SetUnitDivision (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitDivision@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPosition@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitPosition@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitPosition, COMDAT
; _this$ = ecx

; 514  : 	virtual void SetUnitPosition (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPosition@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMode@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMode@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitMode, COMDAT
; _this$ = ecx

; 513  : 	virtual void SetUnitMode (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMode@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitFatigue@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitFatigue@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitFatigue, COMDAT
; _this$ = ecx

; 511  : 	virtual void SetUnitFatigue (int) 						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitFatigue@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitFatigue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z PROC		; UnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 510  : 	virtual void SetUnitOrders (int, VU_ID)				{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUnitOrders@UnitClass@@UAEXHVVU_ID@@@Z ENDP		; UnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitOrders@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitOrders@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitOrders, COMDAT
; _this$ = ecx

; 509  : 	virtual void SetUnitOrders (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitOrders@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitObjective@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitObjective@UnitClass@@UAEXVVU_ID@@@Z PROC	; UnitClass::SetUnitObjective, COMDAT
; _this$ = ecx

; 508  : 	virtual void SetUnitObjective (VU_ID)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitObjective@UnitClass@@UAEXVVU_ID@@@Z ENDP	; UnitClass::SetUnitObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSecondaryObj@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitSecondaryObj@UnitClass@@UAEXVVU_ID@@@Z PROC	; UnitClass::SetUnitSecondaryObj, COMDAT
; _this$ = ecx

; 507  : 	virtual void SetUnitSecondaryObj (VU_ID)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitSecondaryObj@UnitClass@@UAEXVVU_ID@@@Z ENDP	; UnitClass::SetUnitSecondaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPrimaryObj@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitPrimaryObj@UnitClass@@UAEXVVU_ID@@@Z PROC	; UnitClass::SetUnitPrimaryObj, COMDAT
; _this$ = ecx

; 506  : 	virtual void SetUnitPrimaryObj (VU_ID)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitPrimaryObj@UnitClass@@UAEXVVU_ID@@@Z ENDP	; UnitClass::SetUnitPrimaryObj
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z PROC	; UnitClass::GetUnitAssemblyPoint, COMDAT
; _this$ = ecx

; 503  : 	virtual void GetUnitAssemblyPoint (int, GridIndex*, GridIndex*)	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitAssemblyPoint@UnitClass@@UAEXHPAF0@Z ENDP	; UnitClass::GetUnitAssemblyPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 2
?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z PROC		; UnitClass::SetUnitAssemblyPoint, COMDAT
; _this$ = ecx

; 502  : 	virtual void SetUnitAssemblyPoint (int, GridIndex, GridIndex)		{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUnitAssemblyPoint@UnitClass@@UAEXHFF@Z ENDP		; UnitClass::SetUnitAssemblyPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 8
?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z PROC	; UnitClass::HandleRequestReceipt, COMDAT
; _this$ = ecx

; 501  : 	virtual void HandleRequestReceipt(int, int, VU_ID)			{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?HandleRequestReceipt@UnitClass@@UAEXHHVVU_ID@@@Z ENDP	; UnitClass::HandleRequestReceipt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z PROC ; UnitClass::BuildPackage, COMDAT
; _this$ = ecx

; 500  : 	virtual int BuildPackage(MissionRequest, F4PFList)	{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?BuildPackage@UnitClass@@UAEHPAVMissionRequestClass@@PAVFalconPrivateList@@@Z ENDP ; UnitClass::BuildPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastResupply@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastResupply@UnitClass@@UAEHXZ PROC			; UnitClass::GetLastResupply, COMDAT
; _this$ = ecx

; 497  : 	virtual int GetLastResupply (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastResupply@UnitClass@@UAEHXZ ENDP			; UnitClass::GetLastResupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastResupplyTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastResupplyTime@UnitClass@@UAEKXZ PROC		; UnitClass::GetLastResupplyTime, COMDAT
; _this$ = ecx

; 496  : 	virtual CampaignTime GetLastResupplyTime (void)				{ return TheCampaign.CurrentTime; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastResupplyTime@UnitClass@@UAEKXZ ENDP		; UnitClass::GetLastResupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitStores@UnitClass@@UAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitStores@UnitClass@@UAEEH@Z PROC			; UnitClass::GetUnitStores, COMDAT
; _this$ = ecx

; 495  : 	virtual uchar GetUnitStores (int)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitStores@UnitClass@@UAEEH@Z ENDP			; UnitClass::GetUnitStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetSquadronFuel@UnitClass@@UAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSquadronFuel@UnitClass@@UAEJXZ PROC			; UnitClass::GetSquadronFuel, COMDAT
; _this$ = ecx

; 494  : 	virtual long GetSquadronFuel (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSquadronFuel@UnitClass@@UAEJXZ ENDP			; UnitClass::GetSquadronFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMorale@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMorale@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitMorale, COMDAT
; _this$ = ecx

; 493  : 	virtual int GetUnitMorale (void) 							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMorale@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitMorale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSupply@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSupply@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitSupply, COMDAT
; _this$ = ecx

; 492  : 	virtual int GetUnitSupply (void) 							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSupply@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSpecialty@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSpecialty@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitSpecialty, COMDAT
; _this$ = ecx

; 491  : 	virtual int GetUnitSpecialty (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSpecialty@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitSpecialty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLastResupplyTime@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLastResupplyTime@UnitClass@@UAEXK@Z PROC		; UnitClass::SetLastResupplyTime, COMDAT
; _this$ = ecx

; 490  : 	virtual void SetLastResupplyTime (CampaignTime)			{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastResupplyTime@UnitClass@@UAEXK@Z ENDP		; UnitClass::SetLastResupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLastResupply@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLastResupply@UnitClass@@UAEXH@Z PROC		; UnitClass::SetLastResupply, COMDAT
; _this$ = ecx

; 489  : 	virtual void SetLastResupply (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastResupply@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetLastResupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitStores@UnitClass@@UAEXHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
?SetUnitStores@UnitClass@@UAEXHE@Z PROC			; UnitClass::SetUnitStores, COMDAT
; _this$ = ecx

; 488  : 	virtual void SetUnitStores (int, uchar)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitStores@UnitClass@@UAEXHE@Z ENDP			; UnitClass::SetUnitStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetSquadronFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetSquadronFuel@UnitClass@@UAEXJ@Z PROC		; UnitClass::SetSquadronFuel, COMDAT
; _this$ = ecx

; 487  : 	virtual void SetSquadronFuel (long)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSquadronFuel@UnitClass@@UAEXJ@Z ENDP		; UnitClass::SetSquadronFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMorale@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMorale@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitMorale, COMDAT
; _this$ = ecx

; 486  : 	virtual void SetUnitMorale (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMorale@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitMorale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSupply@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitSupply@UnitClass@@UAEXH@Z PROC			; UnitClass::SetUnitSupply, COMDAT
; _this$ = ecx

; 485  : 	virtual void SetUnitSupply (int)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSupply@UnitClass@@UAEXH@Z ENDP			; UnitClass::SetUnitSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSpecialty@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitSpecialty@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitSpecialty, COMDAT
; _this$ = ecx

; 484  : 	virtual void SetUnitSpecialty (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSpecialty@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitSpecialty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?UseFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?UseFuel@UnitClass@@UAEXJ@Z PROC			; UnitClass::UseFuel, COMDAT
; _this$ = ecx

; 481  : 	virtual void UseFuel (long)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?UseFuel@UnitClass@@UAEXJ@Z ENDP			; UnitClass::UseFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IncrementTime@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?IncrementTime@UnitClass@@UAEXK@Z PROC			; UnitClass::IncrementTime, COMDAT
; _this$ = ecx

; 480  : 	virtual void IncrementTime (CampaignTime) 				{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?IncrementTime@UnitClass@@UAEXK@Z ENDP			; UnitClass::IncrementTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z PROC ; UnitClass::BuildMission, COMDAT
; _this$ = ecx

; 479  : 	virtual int BuildMission(MissionRequestClass*)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?BuildMission@UnitClass@@UAEHPAVMissionRequestClass@@@Z ENDP ; UnitClass::BuildMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ PROC ; UnitClass::GetKnownEmitters, COMDAT
; _this$ = ecx

; 478  : 	virtual F4PFList GetKnownEmitters (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKnownEmitters@UnitClass@@UAEPAVFalconPrivateList@@XZ ENDP ; UnitClass::GetKnownEmitters
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ETA@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ETA@UnitClass@@UAEKXZ PROC				; UnitClass::ETA, COMDAT
; _this$ = ecx

; 477  : 	virtual CampaignTime ETA (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ETA@UnitClass@@UAEKXZ ENDP				; UnitClass::ETA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DumpWeapons@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DumpWeapons@UnitClass@@UAEHXZ PROC			; UnitClass::DumpWeapons, COMDAT
; _this$ = ecx

; 476  : 	virtual int DumpWeapons (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?DumpWeapons@UnitClass@@UAEHXZ ENDP			; UnitClass::DumpWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z PROC ; UnitClass::LoadWeapons, COMDAT
; _this$ = ecx

; 475  : 	virtual int LoadWeapons (void*, uchar*, MoveType, int, int, int)	{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?LoadWeapons@UnitClass@@UAEHPAXPAEW4MoveType@@HHH@Z ENDP ; UnitClass::LoadWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitAirbaseID, COMDAT
; _this$ = ecx

; 474  : 	virtual VU_ID GetUnitAirbaseID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitAirbaseID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitAirbaseID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ PROC	; UnitClass::GetUnitAirbase, COMDAT
; _this$ = ecx

; 473  : 	virtual CampEntity GetUnitAirbase (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitAirbase@UnitClass@@UAEPAVCampBaseClass@@XZ ENDP	; UnitClass::GetUnitAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitSquadronID, COMDAT
; _this$ = ecx

; 472  : 	virtual VU_ID GetUnitSquadronID (void)						{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSquadronID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitSquadronID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSquadron@UnitClass@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSquadron@UnitClass@@UAEPAV1@XZ PROC		; UnitClass::GetUnitSquadron, COMDAT
; _this$ = ecx

; 471  : 	virtual Unit GetUnitSquadron (void)							{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSquadron@UnitClass@@UAEPAV1@XZ ENDP		; UnitClass::GetUnitSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTOT@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTOT@UnitClass@@UAEKXZ PROC			; UnitClass::GetUnitTOT, COMDAT
; _this$ = ecx

; 470  : 	virtual CampaignTime GetUnitTOT (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTOT@UnitClass@@UAEKXZ ENDP			; UnitClass::GetUnitTOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionID@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMissionID@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitMissionID, COMDAT
; _this$ = ecx

; 469  : 	virtual int GetUnitMissionID (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionID@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitMissionID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ PROC	; UnitClass::GetUnitMissionTargetID, COMDAT
; _this$ = ecx

; 468  : 	virtual VU_ID GetUnitMissionTargetID (void)					{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitMissionTargetID@UnitClass@@UAE?AVVU_ID@@XZ ENDP	; UnitClass::GetUnitMissionTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ PROC ; UnitClass::GetUnitMissionTarget, COMDAT
; _this$ = ecx

; 467  : 	virtual CampEntity GetUnitMissionTarget (void)				{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionTarget@UnitClass@@UAEPAVCampBaseClass@@XZ ENDP ; UnitClass::GetUnitMissionTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitPriority@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPriority@UnitClass@@UAEHXZ PROC			; UnitClass::GetUnitPriority, COMDAT
; _this$ = ecx

; 466  : 	virtual int GetUnitPriority (void)							{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPriority@UnitClass@@UAEHXZ ENDP			; UnitClass::GetUnitPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitCurrentRole@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitCurrentRole@UnitClass@@UBEHXZ PROC		; UnitClass::GetUnitCurrentRole, COMDAT
; _this$ = ecx

; 465  : 	virtual int GetUnitCurrentRole() const						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitCurrentRole@UnitClass@@UBEHXZ ENDP		; UnitClass::GetUnitCurrentRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitNormalRole@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitNormalRole@UnitClass@@UAEHXZ PROC		; UnitClass::GetUnitNormalRole, COMDAT
; _this$ = ecx

; 464  : 	virtual int GetUnitNormalRole (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitNormalRole@UnitClass@@UAEHXZ ENDP		; UnitClass::GetUnitNormalRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ PROC ; UnitClass::GetUnitMission, COMDAT
; _this$ = ecx

; 463  : 	virtual MissionTypeEnum GetUnitMission (void)							{ return (MissionTypeEnum)0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMission@UnitClass@@UAE?AW4MissionTypeEnum@@XZ ENDP ; UnitClass::GetUnitMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetBurntFuel@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBurntFuel@UnitClass@@UAEHXZ PROC			; UnitClass::GetBurntFuel, COMDAT
; _this$ = ecx

; 462  : 	virtual int GetBurntFuel (void)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBurntFuel@UnitClass@@UAEHXZ ENDP			; UnitClass::GetBurntFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ PROC	; UnitClass::GetAirTarget, COMDAT
; _this$ = ecx

; 461  : 	virtual FalconEntity* GetAirTarget (void)					{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirTarget@UnitClass@@UAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetAirTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ PROC		; UnitClass::GetAirTargetID, COMDAT
; _this$ = ecx

; 460  : 	virtual VU_ID GetAirTargetID (void)							{ return FalconNullId; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAirTargetID@UnitClass@@UAE?AVVU_ID@@XZ ENDP		; UnitClass::GetAirTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetCombatTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatTime@UnitClass@@UAEKXZ PROC			; UnitClass::GetCombatTime, COMDAT
; _this$ = ecx

; 459  : 	virtual CampaignTime GetCombatTime (void)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatTime@UnitClass@@UAEKXZ ENDP			; UnitClass::GetCombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetMoveTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMoveTime@UnitClass@@UAEKXZ PROC			; UnitClass::GetMoveTime, COMDAT
; _this$ = ecx

; 458  : 	virtual CampaignTime GetMoveTime (void)						{ return TheCampaign.CurrentTime - last_check; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, DWORD PTR [eax+184]
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveTime@UnitClass@@UAEKXZ ENDP			; UnitClass::GetMoveTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNumberOfLoadouts@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumberOfLoadouts@UnitClass@@UAEHXZ PROC		; UnitClass::GetNumberOfLoadouts, COMDAT
; _this$ = ecx

; 457  : 	virtual int GetNumberOfLoadouts (void)						{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfLoadouts@UnitClass@@UAEHXZ ENDP		; UnitClass::GetNumberOfLoadouts
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z PROC	; UnitClass::SetLoadout, COMDAT
; _this$ = ecx

; 456  : 	virtual void SetLoadout (LoadoutStruct*, int)	{ ShiWarning("Shouldn't be here"); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLoadout@UnitClass@@UAEXPAULoadoutStruct@@H@Z ENDP	; UnitClass::SetLoadout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::SetUnitAirbase, COMDAT
; _this$ = ecx

; 455  : 	virtual void SetUnitAirbase (VU_ID)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitAirbase@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::SetUnitAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 8
?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z PROC		; UnitClass::SetUnitSquadron, COMDAT
; _this$ = ecx

; 454  : 	virtual void SetUnitSquadron (VU_ID)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitSquadron@UnitClass@@UAEXVVU_ID@@@Z ENDP		; UnitClass::SetUnitSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitTOT@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitTOT@UnitClass@@UAEXK@Z PROC			; UnitClass::SetUnitTOT, COMDAT
; _this$ = ecx

; 453  : 	virtual void SetUnitTOT (CampaignTime)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitTOT@UnitClass@@UAEXK@Z ENDP			; UnitClass::SetUnitTOT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMissionTarget@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMissionTarget@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitMissionTarget, COMDAT
; _this$ = ecx

; 452  : 	virtual void SetUnitMissionTarget (int)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMissionTarget@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitMissionTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMissionID@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitMissionID@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitMissionID, COMDAT
; _this$ = ecx

; 451  : 	virtual void SetUnitMissionID (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMissionID@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitMissionID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitPriority@UnitClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitPriority@UnitClass@@UAEXH@Z PROC		; UnitClass::SetUnitPriority, COMDAT
; _this$ = ecx

; 450  : 	virtual void SetUnitPriority (int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitPriority@UnitClass@@UAEXH@Z ENDP		; UnitClass::SetUnitPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitRole@UnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetUnitRole@UnitClass@@UAEXE@Z PROC			; UnitClass::SetUnitRole, COMDAT
; _this$ = ecx

; 449  : 	virtual void SetUnitRole (uchar)							{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitRole@UnitClass@@UAEXE@Z ENDP			; UnitClass::SetUnitRole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMission@UnitClass@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetUnitMission@UnitClass@@UAEXE@Z PROC			; UnitClass::SetUnitMission, COMDAT
; _this$ = ecx

; 448  : 	virtual void SetUnitMission (uchar)						{}			

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMission@UnitClass@@UAEXE@Z ENDP			; UnitClass::SetUnitMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetBurntFuel@UnitClass@@UAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetBurntFuel@UnitClass@@UAEXJ@Z PROC			; UnitClass::SetBurntFuel, COMDAT
; _this$ = ecx

; 447  : 	virtual void SetBurntFuel (long)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBurntFuel@UnitClass@@UAEXJ@Z ENDP			; UnitClass::SetBurntFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetCombatTime@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetCombatTime@UnitClass@@UAEXK@Z PROC			; UnitClass::SetCombatTime, COMDAT
; _this$ = ecx

; 446  : 	virtual void SetCombatTime (CampaignTime)					{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCombatTime@UnitClass@@UAEXK@Z ENDP			; UnitClass::SetCombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitLastMove@UnitClass@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetUnitLastMove@UnitClass@@UAEXK@Z PROC		; UnitClass::SetUnitLastMove, COMDAT
; _this$ = ecx

; 445  : 	virtual void SetUnitLastMove (CampaignTime)				{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitLastMove@UnitClass@@UAEXK@Z ENDP		; UnitClass::SetUnitLastMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_w$ = -20						; size = 4
_u$ = -16						; size = 4
_this$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
?AdjustWayPoints@UnitClass@@QAEXXZ PROC			; UnitClass::AdjustWayPoints
; _this$ = ecx

; 4237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4238 : 	WayPoint		w;
; 4239 : 	GridIndex		x,y;
; 4240 : 	Unit			u;
; 4241 : 
; 4242 : 	w = GetCurrentUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 4243 : 	if (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN3@AdjustWayP

; 4244 : 	{
; 4245 : 		GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 4246 : 		SetWPTimes (w, x, y, GetCruiseSpeed(), WPTS_KEEP_DEPARTURE_TIMES);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	push	eax
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	?SetWPTimes@@YAKPAVWayPointClass@@FFHH@Z ; SetWPTimes
	add	esp, 20					; 00000014H
$LN3@AdjustWayP:

; 4247 : 	}
; 4248 : 	u = GetFirstUnitElement();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+956]
	call	edx
	mov	DWORD PTR _u$[ebp], eax
$LN2@AdjustWayP:

; 4249 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN4@AdjustWayP

; 4250 : 	{
; 4251 : 		u->AdjustWayPoints();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?AdjustWayPoints@UnitClass@@QAEXXZ	; UnitClass::AdjustWayPoints

; 4252 : 		u = GetNextUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _u$[ebp], eax

; 4253 : 	}

	jmp	SHORT $LN2@AdjustWayP
$LN4@AdjustWayP:

; 4254 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustWayPoints@UnitClass@@QAEXXZ ENDP			; UnitClass::AdjustWayPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
_i$ = -12						; size = 4
_tw$ = -8						; size = 4
_this$ = -4						; size = 4
_w$ = 8							; size = 4
?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z PROC ; UnitClass::SetCurrentUnitWP
; _this$ = ecx

; 4183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 4184 : 	int			i;
; 4185 : 	WayPoint	tw;
; 4186 : 
; 4187 : 	tw = wp_list;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _tw$[ebp], ecx

; 4188 : 	if (!tw || !w)

	cmp	DWORD PTR _tw$[ebp], 0
	je	SHORT $LN4@SetCurrent
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN5@SetCurrent
$LN4@SetCurrent:

; 4189 : 	{
; 4190 : 		//		ShiAssert(!IsFlight());
; 4191 : 		current_wp = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+224], dx

; 4192 : 		return;

	jmp	$LN6@SetCurrent
$LN5@SetCurrent:

; 4193 : 	}
; 4194 : 	i = 1;

	mov	DWORD PTR _i$[ebp], 1
$LN3@SetCurrent:

; 4195 : 	while (tw && tw != w)

	cmp	DWORD PTR _tw$[ebp], 0
	je	SHORT $LN2@SetCurrent
	mov	ecx, DWORD PTR _tw$[ebp]
	cmp	ecx, DWORD PTR _w$[ebp]
	je	SHORT $LN2@SetCurrent

; 4196 : 	{
; 4197 : 		tw = tw->GetNextWP();

	mov	ecx, DWORD PTR _tw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tw$[ebp], eax

; 4198 : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 4199 : 	}

	jmp	SHORT $LN3@SetCurrent
$LN2@SetCurrent:

; 4200 : 	current_wp = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+224], cx

; 4201 : 	// KCK Hack to help out tacE flights which got saved with no mission target
; 4202 : 	if (IsFlight() && GetUnitMissionTargetID() == FalconNullId && w->GetWPTargetID())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN1@SetCurrent
	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+684]
	call	eax
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@SetCurrent
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPTargetID@WayPointClass@@QAE?AVVU_ID@@XZ ; WayPointClass::GetWPTargetID
	mov	ecx, eax
	call	??BVU_ID@@QBEKXZ			; VU_ID::operator unsigned long
	test	eax, eax
	je	SHORT $LN1@SetCurrent

; 4203 : 		SetUnitMissionTarget(w->GetWPTargetID());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPTargetID@WayPointClass@@QAE?AVVU_ID@@XZ ; WayPointClass::GetWPTargetID
	mov	ecx, eax
	call	??BVU_ID@@QBEKXZ			; VU_ID::operator unsigned long
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+620]
	call	eax
$LN1@SetCurrent:

; 4204 : 	/*	if (IsFlight() || IsTaskForce())
; 4205 : 		{
; 4206 : 	// Set yaw to current wp's heading
; 4207 : 	float	xd,yd,zd;
; 4208 : 	w->GetLocation(&xd,&yd,&zd);
; 4209 : 	xd -= XPos();
; 4210 : 	yd -= YPos();
; 4211 : 	SetYPR(atan2(yd,xd),0.0F,0.0F);
; 4212 : 	}
; 4213 : 	 */
; 4214 : 	//MakeUnitDirty (DIRTY_WAYPOINT, DDP[76].priority);
; 4215 : 	MakeUnitDirty (DIRTY_WAYPOINT, SEND_NOW);

	push	65536					; 00010000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN6@SetCurrent:

; 4216 : 	return;
; 4217 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCurrentUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ENDP ; UnitClass::SetCurrentUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_e$ = -8						; size = 4
_this$ = -4						; size = 4
?CheckBroken@UnitClass@@QAEXXZ PROC			; UnitClass::CheckBroken
; _this$ = ecx

; 4339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4340 : 	Unit		e;
; 4341 : 
; 4342 : 	if (!Parent())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	jne	SHORT $LN4@CheckBroke

; 4343 : 		return;

	jmp	SHORT $LN5@CheckBroke
$LN4@CheckBroke:

; 4344 : 	e = GetFirstUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN3@CheckBroke:

; 4345 : 	while (e && e->Broken())

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN2@CheckBroke
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	je	SHORT $LN2@CheckBroke

; 4346 : 		e = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
	jmp	SHORT $LN3@CheckBroke
$LN2@CheckBroke:

; 4347 : 	if (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN5@CheckBroke

; 4348 : 		SetBroken(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBroken@UnitClass@@QAEXH@Z		; UnitClass::SetBroken
$LN5@CheckBroke:

; 4349 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckBroken@UnitClass@@QAEXXZ ENDP			; UnitClass::CheckBroken
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
_t$ = -12						; size = 4
_w$ = -8						; size = 4
_this$ = -4						; size = 4
?DisposeWayPoints@UnitClass@@QAEXXZ PROC		; UnitClass::DisposeWayPoints
; _this$ = ecx

; 4319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 4320 : 	WayPoint    w,t;
; 4321 : 
; 4322 : 	w = wp_list;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _w$[ebp], ecx

; 4323 : 	current_wp = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+224], dx
$LN3@DisposeWay:

; 4324 : 	while (w != NULL)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN2@DisposeWay

; 4325 : 	{
; 4326 : 		t = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _t$[ebp], ecx

; 4327 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 4328 : 		delete t;

	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4329 : 	}

	jmp	SHORT $LN3@DisposeWay
$LN2@DisposeWay:

; 4330 : 	wp_list = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], 0

; 4331 : 	if (IsFlight())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN1@DisposeWay

; 4332 : 		//MakeUnitDirty (DIRTY_WP_LIST, DDP[77].priority);
; 4333 : 		MakeUnitDirty (DIRTY_WP_LIST, SEND_NOW);

	push	65536					; 00010000H
	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN1@DisposeWay:

; 4334 : 	//MakeUnitDirty (DIRTY_WAYPOINT, DDP[78].priority);
; 4335 : 	MakeUnitDirty (DIRTY_WAYPOINT, SEND_NOW);

	push	65536					; 00010000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 4336 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DisposeWayPoints@UnitClass@@QAEXXZ ENDP		; UnitClass::DisposeWayPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FinishUnitWP@UnitClass@@QAEXXZ PROC			; UnitClass::FinishUnitWP
; _this$ = ecx

; 4155 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4156 : 	current_wp++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+224]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+224], cx

; 4157 : 	if (GetCurrentUnitWP() == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	test	eax, eax
	jne	SHORT $LN1@FinishUnit

; 4158 : 	{
; 4159 : 		ShiAssert(!IsFlight());
; 4160 : 		current_wp = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+224], ax
$LN1@FinishUnit:

; 4161 : 	}
; 4162 : 	//MakeUnitDirty (DIRTY_WAYPOINT, DDP[75].priority);
; 4163 : 	MakeUnitDirty (DIRTY_WAYPOINT, SEND_NOW);

	push	65536					; 00010000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 4164 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FinishUnitWP@UnitClass@@QAEXXZ ENDP			; UnitClass::FinishUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_w$ = -4						; size = 4
?GetUnitMissionWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC ; UnitClass::GetUnitMissionWP
; _this$ = ecx

; 4220 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4221 : 	WayPoint		w;
; 4222 : 
; 4223 : 	w = GetFirstUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax
$LN3@GetUnitMis:

; 4224 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN2@GetUnitMis

; 4225 : 	{
; 4226 : 		if (w->GetWPFlags() & WPF_TARGET)

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN1@GetUnitMis

; 4227 : 			return w;

	mov	eax, DWORD PTR _w$[ebp]
	jmp	SHORT $LN4@GetUnitMis
$LN1@GetUnitMis:

; 4228 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 4229 : 	}

	jmp	SHORT $LN3@GetUnitMis
$LN2@GetUnitMis:

; 4230 : 	return NULL;

	xor	eax, eax
$LN4@GetUnitMis:

; 4231 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMissionWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP ; UnitClass::GetUnitMissionWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_i$ = -12						; size = 4
_this$ = -8						; size = 4
_w$ = -4						; size = 4
?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ PROC ; UnitClass::GetCurrentUnitWP
; _this$ = ecx

; 4166 : WayPoint UnitClass::GetCurrentUnitWP() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4167 : 	WayPoint		w;
; 4168 : 	int			i;
; 4169 : 
; 4170 : 	if (!current_wp)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+224]
	test	ecx, ecx
	jne	SHORT $LN3@GetCurrent

; 4171 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@GetCurrent
$LN3@GetCurrent:

; 4172 : 	w = wp_list;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR _w$[ebp], eax

; 4173 : 	i = 1;

	mov	DWORD PTR _i$[ebp], 1
$LN2@GetCurrent:

; 4174 : 	while (w && i != current_wp)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN1@GetCurrent
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+224]
	cmp	DWORD PTR _i$[ebp], edx
	je	SHORT $LN1@GetCurrent

; 4175 : 	{
; 4176 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 4177 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 4178 : 	}

	jmp	SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 4179 : 	return w;

	mov	eax, DWORD PTR _w$[ebp]
$LN4@GetCurrent:

; 4180 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ENDP ; UnitClass::GetCurrentUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC	; UnitClass::GetFirstUnitWP, COMDAT
; _this$ = ecx

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP	; UnitClass::GetFirstUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -48						; size = 4
tv90 = -44						; size = 4
$T3 = -40						; size = 4
_new_list$ = -36					; size = 4
_this$ = -32						; size = 4
_nw$ = -28						; size = 4
_lw$ = -24						; size = 4
_w$ = -20						; size = 4
_count$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z PROC		; UnitClass::DecodeWaypoints
; _this$ = ecx

; 5703 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5704 : 	ushort			count;
; 5705 : 	WayPointClass	*new_list,*lw,*nw,*w;
; 5706 : 
; 5707 : 
; 5708 : 	if (gCampDataVersion >= 71)	{

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 71	; gCampDataVersion, 00000047H
	jl	SHORT $LN20@DecodeWayp

; 5709 : 		memcpychk(&count, stream, sizeof (ushort), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5710 : 	}
; 5711 : 	else {

	jmp	SHORT $LN19@DecodeWayp
$LN20@DecodeWayp:

; 5712 : 		count = 0;

	xor	eax, eax
	mov	WORD PTR _count$[ebp], ax

; 5713 : 		memcpychk(&count, stream, sizeof (uchar), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN19@DecodeWayp:

; 5714 : 	}
; 5715 : 
; 5716 : 	if (load_log) {

	cmp	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
	je	SHORT $LN18@DecodeWayp

; 5717 : 		fprintf (load_log, "%d ", count);

	movzx	ecx, WORD PTR _count$[ebp]
	push	ecx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	mov	edx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5718 : 		fflush (load_log);

	mov	eax, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	eax
	call	_fflush
	add	esp, 4
$LN18@DecodeWayp:

; 5719 : 	}
; 5720 : 
; 5721 : 	// KCK: Rather than replace our waypoint list,
; 5722 : 	// I'm going to copy the new list into our old one.
; 5723 : 	// Although this is more time consuming considering
; 5724 : 	// the copy, it lowers the possibily of running into
; 5725 : 	// deleted waypoints in the UI (I doubt we'll be able
; 5726 : 	// to critical section all references to waypoints in
; 5727 : 	// time).
; 5728 : 	new_list = lw = NULL;

	mov	DWORD PTR _lw$[ebp], 0
	mov	ecx, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _new_list$[ebp], ecx
$LN17@DecodeWayp:

; 5729 : 	while (count) 

	movzx	edx, WORD PTR _count$[ebp]
	test	edx, edx
	je	$LN16@DecodeWayp

; 5730 : 	{
; 5731 : 		w = new WayPointClass(stream, rem);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN23@DecodeWayp
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@PAPAEPAJ@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN24@DecodeWayp
$LN23@DecodeWayp:
	mov	DWORD PTR tv90[ebp], 0
$LN24@DecodeWayp:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 5732 : 		if (!lw)

	cmp	DWORD PTR _lw$[ebp], 0
	jne	SHORT $LN15@DecodeWayp

; 5733 : 			new_list = lw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], ecx
	mov	edx, DWORD PTR _lw$[ebp]
	mov	DWORD PTR _new_list$[ebp], edx

; 5734 : 		else

	jmp	SHORT $LN14@DecodeWayp
$LN15@DecodeWayp:

; 5735 : 			lw->InsertWP(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN14@DecodeWayp:

; 5736 : 		lw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], ecx

; 5737 : 		count --;

	mov	dx, WORD PTR _count$[ebp]
	sub	dx, 1
	mov	WORD PTR _count$[ebp], dx

; 5738 : 	}

	jmp	$LN17@DecodeWayp
$LN16@DecodeWayp:

; 5739 : 
; 5740 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 5741 : 	nw = new_list;

	mov	eax, DWORD PTR _new_list$[ebp]
	mov	DWORD PTR _nw$[ebp], eax

; 5742 : 	w = wp_list;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR _w$[ebp], edx

; 5743 : 	lw = NULL;

	mov	DWORD PTR _lw$[ebp], 0
$LN13@DecodeWayp:

; 5744 : 	while (w && nw)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN12@DecodeWayp
	cmp	DWORD PTR _nw$[ebp], 0
	je	SHORT $LN12@DecodeWayp

; 5745 : 	{
; 5746 : 		w->CloneWP(nw);

	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	call	?CloneWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::CloneWP

; 5747 : 		lw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], ecx

; 5748 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 5749 : 		nw = nw->GetNextWP();

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _nw$[ebp], eax

; 5750 : 	}

	jmp	SHORT $LN13@DecodeWayp
$LN12@DecodeWayp:

; 5751 : 	// Delete any extra old ones
; 5752 : 	if (w == wp_list)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	cmp	eax, DWORD PTR [edx+244]
	jne	SHORT $LN11@DecodeWayp

; 5753 : 		wp_list = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], 0
$LN11@DecodeWayp:

; 5754 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN9@DecodeWayp

; 5755 : 	{
; 5756 : 		lw = w;

	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], edx

; 5757 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 5758 : 		lw->DeleteWP();

	mov	ecx, DWORD PTR _lw$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 5759 : 	}

	jmp	SHORT $LN11@DecodeWayp
$LN9@DecodeWayp:

; 5760 : 	// Add any extra new ones
; 5761 : 	if (nw)

	cmp	DWORD PTR _nw$[ebp], 0
	je	SHORT $LN4@DecodeWayp

; 5762 : 	{
; 5763 : 		if (nw->GetPrevWP())

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN7@DecodeWayp

; 5764 : 			nw->GetPrevWP()->UnlinkNextWP();

	mov	ecx, DWORD PTR _nw$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	ecx, eax
	call	?UnlinkNextWP@WayPointClass@@QAEXXZ	; WayPointClass::UnlinkNextWP

; 5765 : 		else

	jmp	SHORT $LN6@DecodeWayp
$LN7@DecodeWayp:

; 5766 : 			new_list = NULL;

	mov	DWORD PTR _new_list$[ebp], 0
$LN6@DecodeWayp:

; 5767 : 		if (lw)

	cmp	DWORD PTR _lw$[ebp], 0
	je	SHORT $LN5@DecodeWayp

; 5768 : 			lw->SetNextWP(nw);

	mov	eax, DWORD PTR _nw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?SetNextWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::SetNextWP

; 5769 : 		else

	jmp	SHORT $LN4@DecodeWayp
$LN5@DecodeWayp:

; 5770 : 			wp_list = nw;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nw$[ebp]
	mov	DWORD PTR [ecx+244], edx
$LN4@DecodeWayp:

; 5771 : 	}
; 5772 : 	if (new_list)

	cmp	DWORD PTR _new_list$[ebp], 0
	je	SHORT $LN3@DecodeWayp

; 5773 : 		DeleteWPList(new_list);

	mov	eax, DWORD PTR _new_list$[ebp]
	push	eax
	call	?DeleteWPList@@YAXPAVWayPointClass@@@Z	; DeleteWPList
	add	esp, 4
$LN3@DecodeWayp:

; 5774 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 5775 : 
; 5776 : 	// Fix up Speeds
; 5777 : 	w = wp_list;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR _w$[ebp], edx
$LN2@DecodeWayp:

; 5778 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN1@DecodeWayp

; 5779 : 	{
; 5780 : 		::SetWPSpeed(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?SetWPSpeed@@YAMPAVWayPointClass@@@Z	; SetWPSpeed
	fstp	ST(0)
	add	esp, 4

; 5781 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 5782 : 	}

	jmp	SHORT $LN2@DecodeWayp
$LN1@DecodeWayp:

; 5783 : 
; 5784 : 	update_active_flight (this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?update_active_flight@@YAXPAVUnitClass@@@Z ; update_active_flight
	add	esp, 4

; 5785 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z ENDP		; UnitClass::DecodeWaypoints
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_start$ = -16						; size = 4
_this$ = -12						; size = 4
_w$ = -8						; size = 4
_count$ = -4						; size = 2
_stream$ = 8						; size = 4
?EncodeWaypoints@UnitClass@@QAEHPAPAE@Z PROC		; UnitClass::EncodeWaypoints
; _this$ = ecx

; 5668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 5669 : 	uchar			*start;
; 5670 : 	ushort			count = 0;

	xor	eax, eax
	mov	WORD PTR _count$[ebp], ax

; 5671 : 	WayPointClass	*w;
; 5672 : 
; 5673 : 	start = *stream;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _start$[ebp], edx

; 5674 : 
; 5675 : 	// Count waypoints
; 5676 : 	w = wp_list;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _w$[ebp], ecx
$LN5@EncodeWayp:

; 5677 : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN4@EncodeWayp

; 5678 : 	{
; 5679 : 		count ++;

	mov	dx, WORD PTR _count$[ebp]
	add	dx, 1
	mov	WORD PTR _count$[ebp], dx

; 5680 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 5681 : 	}

	jmp	SHORT $LN5@EncodeWayp
$LN4@EncodeWayp:

; 5682 : 
; 5683 : 	if (save_log)

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN3@EncodeWayp

; 5684 : 	{
; 5685 : 		fprintf (save_log, "%d ", count);

	movzx	eax, WORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 5686 : 		fflush (save_log);

	mov	edx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	edx
	call	_fflush
	add	esp, 4
$LN3@EncodeWayp:

; 5687 : 	}
; 5688 : 
; 5689 : 	memcpy(*stream, &count, sizeof(ushort));			*stream += sizeof(ushort);

	push	2
	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 5690 : 
; 5691 : 	// Save waypoints
; 5692 : 	w = wp_list;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _w$[ebp], ecx
$LN2@EncodeWayp:

; 5693 : 	while (w) 

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN1@EncodeWayp

; 5694 : 	{
; 5695 : 		w->Save(stream);

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?Save@WayPointClass@@QAEHPAPAE@Z	; WayPointClass::Save

; 5696 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 5697 : 	}

	jmp	SHORT $LN2@EncodeWayp
$LN1@EncodeWayp:

; 5698 : 	return *stream - start;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR _start$[ebp]

; 5699 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EncodeWaypoints@UnitClass@@QAEHPAPAE@Z ENDP		; UnitClass::EncodeWaypoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_t$ = -8						; size = 4
_this$ = -4						; size = 4
_w$ = 8							; size = 4
?DeleteUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z PROC	; UnitClass::DeleteUnitWP
; _this$ = ecx

; 5653 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5654 : 	WayPoint    t;
; 5655 : 
; 5656 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 5657 : 	t = wp_list;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _t$[ebp], ecx

; 5658 : 	if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@DeleteUnit

; 5659 : 		return;

	jmp	SHORT $LN3@DeleteUnit
$LN2@DeleteUnit:

; 5660 : 	if (t == w)

	mov	edx, DWORD PTR _t$[ebp]
	cmp	edx, DWORD PTR _w$[ebp]
	jne	SHORT $LN1@DeleteUnit

; 5661 : 		wp_list = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax
$LN1@DeleteUnit:

; 5662 : 	w->DeleteWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?DeleteWP@WayPointClass@@QAEXXZ		; WayPointClass::DeleteWP

; 5663 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 5664 : 	MakeWaypointsDirty ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeWaypointsDirty@UnitClass@@QAEXXZ	; UnitClass::MakeWaypointsDirty
$LN3@DeleteUnit:

; 5665 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteUnitWP@UnitClass@@QAEXPAVWayPointClass@@@Z ENDP	; UnitClass::DeleteUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv79 = -28						; size = 4
$T3 = -24						; size = 4
_w$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pw$ = 8						; size = 4
_x$ = 12						; size = 2
_y$ = 16						; size = 2
_alt$ = 20						; size = 4
_speed$ = 24						; size = 4
_arr$ = 28						; size = 4
_station$ = 32						; size = 4
_mission$ = 36						; size = 1
?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z PROC ; UnitClass::AddWPAfter
; _this$ = ecx

; 5634 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5635 : 	WayPoint    w;
; 5636 : 
; 5637 : 	w = new WayPointClass(x,y,alt,speed,arr,station,mission,0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@AddWPAfter
	push	0
	movzx	eax, BYTE PTR _mission$[ebp]
	push	eax
	mov	ecx, DWORD PTR _station$[ebp]
	push	ecx
	mov	edx, DWORD PTR _arr$[ebp]
	push	edx
	mov	eax, DWORD PTR _speed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _alt$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@AddWPAfter
$LN7@AddWPAfter:
	mov	DWORD PTR tv79[ebp], 0
$LN8@AddWPAfter:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 5638 : 	if (pw && wp_list)

	cmp	DWORD PTR _pw$[ebp], 0
	je	SHORT $LN4@AddWPAfter
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+244], 0
	je	SHORT $LN4@AddWPAfter

; 5639 : 		pw->InsertWP(w);

	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 5640 : 	else

	jmp	SHORT $LN3@AddWPAfter
$LN4@AddWPAfter:

; 5641 : 	{
; 5642 : 		if (wp_list)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+244], 0
	je	SHORT $LN2@AddWPAfter

; 5643 : 			w->InsertWP(wp_list);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	push	ecx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN2@AddWPAfter:

; 5644 : 		wp_list = w;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR [edx+244], eax
$LN3@AddWPAfter:

; 5645 : 	}
; 5646 : 	if (wp_list == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+244], 0
	jne	SHORT $LN1@AddWPAfter

; 5647 : 		current_wp = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+224], dx
$LN1@AddWPAfter:

; 5648 : 	MakeWaypointsDirty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeWaypointsDirty@UnitClass@@QAEXXZ	; UnitClass::MakeWaypointsDirty

; 5649 : 	return w;

	mov	eax, DWORD PTR _w$[ebp]

; 5650 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddWPAfter@UnitClass@@QAEPAVWayPointClass@@PAV2@FFHHKHE@Z ENDP ; UnitClass::AddWPAfter
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 4
tv79 = -32						; size = 4
$T3 = -28						; size = 4
_w$ = -24						; size = 4
_t$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_x$ = 8							; size = 2
_y$ = 12						; size = 2
_alt$ = 16						; size = 4
_speed$ = 20						; size = 4
_arr$ = 24						; size = 4
_station$ = 28						; size = 4
_mission$ = 32						; size = 1
?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z PROC ; UnitClass::AddUnitWP
; _this$ = ecx

; 5611 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5612 : 	WayPoint    w,t;
; 5613 : 
; 5614 : 	w = new WayPointClass(x,y,alt,speed,arr,station,mission,0);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@AddUnitWP
	push	0
	movzx	eax, BYTE PTR _mission$[ebp]
	push	eax
	mov	ecx, DWORD PTR _station$[ebp]
	push	ecx
	mov	edx, DWORD PTR _arr$[ebp]
	push	edx
	mov	eax, DWORD PTR _speed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _alt$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0WayPointClass@@QAE@FFHHKKEH@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@AddUnitWP
$LN7@AddUnitWP:
	mov	DWORD PTR tv79[ebp], 0
$LN8@AddUnitWP:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 5615 : 	if (!wp_list)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+244], 0
	jne	SHORT $LN4@AddUnitWP

; 5616 : 	{
; 5617 : 		wp_list = w;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [ecx+244], edx

; 5618 : 		current_wp = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+224], ax

; 5619 : 	}
; 5620 : 	else

	jmp	SHORT $LN3@AddUnitWP
$LN4@AddUnitWP:

; 5621 : 	{
; 5622 : 		t = wp_list;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR _t$[ebp], eax
$LN2@AddUnitWP:

; 5623 : 		while (t->GetNextWP() != NULL)

	mov	ecx, DWORD PTR _t$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN1@AddUnitWP

; 5624 : 			t = t->GetNextWP();

	mov	ecx, DWORD PTR _t$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _t$[ebp], eax
	jmp	SHORT $LN2@AddUnitWP
$LN1@AddUnitWP:

; 5625 : 		t->InsertWP(w);

	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _t$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP
$LN3@AddUnitWP:

; 5626 : 	}
; 5627 : 	MakeWaypointsDirty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeWaypointsDirty@UnitClass@@QAEXXZ	; UnitClass::MakeWaypointsDirty

; 5628 : 	return w;

	mov	eax, DWORD PTR _w$[ebp]

; 5629 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddUnitWP@UnitClass@@QAEPAVWayPointClass@@FFHHKHE@Z ENDP ; UnitClass::AddUnitWP
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_time$ = -8						; size = 4
_this$ = -4						; size = 4
?GetUnitSupplyTime@UnitClass@@QAEKXZ PROC		; UnitClass::GetUnitSupplyTime
; _this$ = ecx

; 3916 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3917 : 	CampaignTime		time = ~0;

	mov	DWORD PTR _time$[ebp], -1

; 3918 : 
; 3919 : 	// Determine how long we need to wait to receive supplies
; 3920 : 	if (IsBattalion())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN7@GetUnitSup

; 3921 : 	{
; 3922 : 		if (GetUnitCurrentRole() == GRO_ATTACK)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN6@GetUnitSup

; 3923 : 			time = GND_OFFENSIVE_SUPPLY_TIME;

	mov	DWORD PTR _time$[ebp], 1200000		; 00124f80H

; 3924 : 		else

	jmp	SHORT $LN5@GetUnitSup
$LN6@GetUnitSup:

; 3925 : 			time = GND_DEFENSIVE_SUPPLY_TIME;

	mov	DWORD PTR _time$[ebp], 10800000		; 00a4cb80H
$LN5@GetUnitSup:
	jmp	SHORT $LN4@GetUnitSup
$LN7@GetUnitSup:

; 3926 : 	}
; 3927 : 	else if (IsSquadron())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	SHORT $LN4@GetUnitSup

; 3928 : 	{
; 3929 : 		// KCK: Air or Ground action?
; 3930 : 		if (TeamInfo[GetTeam()]->GetGroundAction()->actionType == GACTION_OFFENSIVE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	movzx	edx, BYTE PTR [eax+16]
	cmp	edx, 4
	jne	SHORT $LN2@GetUnitSup

; 3931 : 			time = AIR_OFFENSIVE_SUPPLY_TIME;

	mov	eax, DWORD PTR ?ActionTimeOut@@3HA	; ActionTimeOut
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, 3600000				; 0036ee80H
	mov	DWORD PTR _time$[ebp], eax

; 3932 : 		else

	jmp	SHORT $LN4@GetUnitSup
$LN2@GetUnitSup:

; 3933 : 			time = AIR_DEFENSIVE_SUPPLY_TIME;

	mov	eax, DWORD PTR ?ActionTimeOut@@3HA	; ActionTimeOut
	imul	eax, 3600000				; 0036ee80H
	mov	DWORD PTR _time$[ebp], eax
$LN4@GetUnitSup:

; 3934 : 	}
; 3935 : 	return time;

	mov	eax, DWORD PTR _time$[ebp]

; 3936 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSupplyTime@UnitClass@@QAEKXZ ENDP		; UnitClass::GetUnitSupplyTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -104						; size = 8
$T3 = -96						; size = 8
$T4 = -88						; size = 8
$T5 = -80						; size = 8
$T6 = -72						; size = 8
$T7 = -64						; size = 4
$T8 = -60						; size = 4
tv237 = -56						; size = 4
$T9 = -52						; size = 4
tv226 = -48						; size = 4
tv154 = -44						; size = 4
$T10 = -40						; size = 4
tv143 = -36						; size = 4
_ourCargo$ = -32					; size = 4
_msg$11 = -28						; size = 4
_this$ = -24						; size = 4
_x$ = -20						; size = 2
_y$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
?UnloadUnit@UnitClass@@QAEXXZ PROC			; UnitClass::UnloadUnit
; _this$ = ecx

; 3868 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UnloadUnit@UnitClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3869 : 	if (!Cargo())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	SHORT $LN3@UnloadUnit

; 3870 : 		return;

	jmp	$LN4@UnloadUnit
$LN3@UnloadUnit:

; 3871 : 
; 3872 : 	Unit		ourCargo = (Unit) vuDatabase->Find(cargo_id);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	push	ecx
	mov	edx, DWORD PTR [eax+204]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ourCargo$[ebp], eax

; 3873 : 	GridIndex	x,y;
; 3874 : 
; 3875 : 	// KCK: We should probably check to see if we're over valid territory,
; 3876 : 	// and if not move towards valid territory (or throw the unit there)
; 3877 : 
; 3878 : 	SetCargo(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCargo@UnitClass@@QAEXH@Z		; UnitClass::SetCargo

; 3879 : 	cargo_id = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+204], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+208], edx

; 3880 : 	if (!ourCargo)

	cmp	DWORD PTR _ourCargo$[ebp], 0
	jne	SHORT $LN2@UnloadUnit

; 3881 : 		return;

	jmp	$LN4@UnloadUnit
$LN2@UnloadUnit:

; 3882 : 
; 3883 : 	// Play a radio message
; 3884 : 	if (IsFlight())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN1@UnloadUnit

; 3885 : 	{
; 3886 : 		FalconRadioChatterMessage *msg = new FalconRadioChatterMessage(Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN8@UnloadUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@UnloadUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN7@UnloadUnit
$LN6@UnloadUnit:
	mov	DWORD PTR tv143[ebp], 0
$LN7@UnloadUnit:
	push	1
	mov	edx, DWORD PTR tv143[ebp]
	push	edx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $LN9@UnloadUnit
$LN8@UnloadUnit:
	mov	DWORD PTR tv154[ebp], 0
$LN9@UnloadUnit:
	mov	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _msg$11[ebp], ecx

; 3887 : 		msg->dataBlock.from = Id();

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$11[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 3888 : 		msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	ecx, DWORD PTR _msg$11[ebp]
	mov	BYTE PTR [ecx+60], 1

; 3889 : 		msg->dataBlock.voice_id = ((Flight)this)->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$11[ebp]
	mov	BYTE PTR [edx+61], al

; 3890 : 		msg->dataBlock.message = rcAIRDROPAPPROACH;

	mov	eax, 5
	mov	ecx, DWORD PTR _msg$11[ebp]
	mov	WORD PTR [ecx+62], ax

; 3891 : 		msg->dataBlock.edata[0] = ((Flight)this)->callsign_id;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$11[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 3892 : 		msg->dataBlock.edata[1] = ((Flight)this)->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$11[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 3893 : 		FalconSendMessage(msg, FALSE);

	push	0
	mov	eax, DWORD PTR _msg$11[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 3894 : 		msg = new FalconRadioChatterMessage(Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN12@UnloadUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@UnloadUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv226[ebp], eax
	jmp	SHORT $LN11@UnloadUnit
$LN10@UnloadUnit:
	mov	DWORD PTR tv226[ebp], 0
$LN11@UnloadUnit:
	push	1
	mov	edx, DWORD PTR tv226[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv237[ebp], eax
	jmp	SHORT $LN13@UnloadUnit
$LN12@UnloadUnit:
	mov	DWORD PTR tv237[ebp], 0
$LN13@UnloadUnit:
	mov	eax, DWORD PTR tv237[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _msg$11[ebp], ecx

; 3895 : 		msg->dataBlock.from = Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$11[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 3896 : 		msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	ecx, DWORD PTR _msg$11[ebp]
	mov	BYTE PTR [ecx+60], 1

; 3897 : 		msg->dataBlock.voice_id = ((Flight)this)->GetFlightLeadVoiceID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFlightLeadVoiceID@FlightClass@@QAEEXZ ; FlightClass::GetFlightLeadVoiceID
	mov	edx, DWORD PTR _msg$11[ebp]
	mov	BYTE PTR [edx+61], al

; 3898 : 		msg->dataBlock.message = rcAIRDROPDONE;

	mov	eax, 6
	mov	ecx, DWORD PTR _msg$11[ebp]
	mov	WORD PTR [ecx+62], ax

; 3899 : 		msg->dataBlock.edata[0] = ((Flight)this)->callsign_id;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	ax, BYTE PTR [edx+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$11[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 3900 : 		msg->dataBlock.edata[1] = ((Flight)this)->GetFlightLeadCallNumber();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFlightLeadCallNumber@FlightClass@@QAEHXZ ; FlightClass::GetFlightLeadCallNumber
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _msg$11[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 3901 : 		msg->dataBlock.time_to_play = CampaignMinutes;

	mov	eax, DWORD PTR _msg$11[ebp]
	mov	DWORD PTR [eax+56], 60000		; 0000ea60H

; 3902 : 		FalconSendMessage(msg, FALSE);

	push	0
	mov	ecx, DWORD PTR _msg$11[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN1@UnloadUnit:

; 3903 : 	}
; 3904 : 
; 3905 : 	// Apply any damage sustained:
; 3906 : 	// KCK TODO.
; 3907 : 	GetLocation (&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 3908 : 	MonoPrint("Unit %d dropping off unit %d at %d,%d.\n",GetCampID(),ourCargo->GetCampID(),x,y);

	movsx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movsx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _ourCargo$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	push	OFFSET ??_C@_0CI@FIGMOKMC@Unit?5?$CFd?5dropping?5off?5unit?5?$CFd?5at?5@
	call	_MonoPrint
	add	esp, 20					; 00000014H

; 3909 : 	ourCargo->SetCargo(0);

	push	0
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?SetCargo@UnitClass@@QAEXH@Z		; UnitClass::SetCargo

; 3910 : 	ourCargo->SetCargoId(FalconNullId);

	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z	; UnitClass::SetCargoId

; 3911 : 	ourCargo->SetLocation(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?SetLocation@CampBaseClass@@QAEXFF@Z	; CampBaseClass::SetLocation

; 3912 : 	ourCargo->BroadcastUnitMessage(Id(), FalconUnitMessage::unitActivate, 0, 0, 0);

	push	0
	push	0
	push	0
	push	7
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::BroadcastUnitMessage
$LN4@UnloadUnit:

; 3913 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UnloadUnit@UnitClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?UnloadUnit@UnitClass@@QAEXXZ$1:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?UnloadUnit@UnitClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UnloadUnit@UnitClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UnloadUnit@UnitClass@@QAEXXZ ENDP			; UnitClass::UnloadUnit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -16						; size = 8
_this$ = -8						; size = 4
_ourCargo$ = -4						; size = 4
_cargo$ = 8						; size = 4
?LoadUnit@UnitClass@@QAEXPAV1@@Z PROC			; UnitClass::LoadUnit
; _this$ = ecx

; 3847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3848 : 	if (Cargo())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	je	SHORT $LN2@LoadUnit

; 3849 : 		return;

	jmp	$LN3@LoadUnit
$LN2@LoadUnit:

; 3850 : 
; 3851 : 	Unit	ourCargo = (Unit) vuDatabase->Find(cargo_id);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	push	ecx
	mov	edx, DWORD PTR [eax+204]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ourCargo$[ebp], eax

; 3852 : 
; 3853 : 	if (!ourCargo)

	cmp	DWORD PTR _ourCargo$[ebp], 0
	jne	SHORT $LN1@LoadUnit

; 3854 : 	{
; 3855 : 		// KCK TODO: Abort Mission
; 3856 : 		MonoPrint("Cargo is missing!\n");

	push	OFFSET ??_C@_0BD@HHBCIDIG@Cargo?5is?5missing?$CB?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 3857 : 		return;

	jmp	$LN3@LoadUnit
$LN1@LoadUnit:

; 3858 : 	}
; 3859 : 	MonoPrint("Unit %d picking up unit %d.\n",GetCampID(),ourCargo->GetCampID());

	mov	eax, DWORD PTR _ourCargo$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	push	OFFSET ??_C@_0BN@CFBAPBAH@Unit?5?$CFd?5picking?5up?5unit?5?$CFd?4?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 3860 : 	ourCargo->SetInactive(1);

	push	1
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?SetInactive@UnitClass@@QAEXH@Z		; UnitClass::SetInactive

; 3861 : 	ourCargo->SetCargo(1);

	push	1
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?SetCargo@UnitClass@@QAEXH@Z		; UnitClass::SetCargo

; 3862 : 	ourCargo->SetCargoId(Id());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z	; UnitClass::SetCargoId

; 3863 : 	ourCargo->BroadcastUnitMessage(Id(), FalconUnitMessage::unitActivate, 1, 0, 0);

	push	0
	push	0
	push	1
	push	7
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _ourCargo$[ebp]
	call	?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::BroadcastUnitMessage

; 3864 : 	SetCargo(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCargo@UnitClass@@QAEXH@Z		; UnitClass::SetCargo
$LN3@LoadUnit:

; 3865 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LoadUnit@UnitClass@@QAEXPAV1@@Z ENDP			; UnitClass::LoadUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_retval$ = -12						; size = 4
_flags$ = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_x$ = 12						; size = 2
_y$ = 16						; size = 2
_xx$ = 20						; size = 2
_yy$ = 24						; size = 2
?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z PROC ; UnitClass::GetUnitGridPath
; _this$ = ecx

; 3824 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3825 : 	int				flags = 0,retval;

	mov	DWORD PTR _flags$[ebp], 0

; 3826 : 
; 3827 : 	if (GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	jne	SHORT $LN4@GetUnitGri

; 3828 : 	{
; 3829 : 		if (GetUnitFormation() == GFORM_COLUMN || GetUnitFormation() == GFORM_OVERWATCH || DistSqu(x,y,xx,yy) > 30)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	cmp	eax, 1
	je	SHORT $LN2@GetUnitGri
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	cmp	eax, 3
	je	SHORT $LN2@GetUnitGri
	movzx	ecx, WORD PTR _yy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _xx$[ebp]
	push	edx
	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cmp	eax, 30					; 0000001eH
	jle	SHORT $LN3@GetUnitGri
$LN2@GetUnitGri:

; 3830 : 			flags |= PATH_ROADOK | PATH_ENEMYCOST;

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 9
	mov	DWORD PTR _flags$[ebp], edx
$LN3@GetUnitGri:

; 3831 : 		if (GetUnitNormalRole() == GRO_ENGINEER)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 7
	jne	SHORT $LN4@GetUnitGri

; 3832 : 			flags |= PATH_ENGINEER;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 128				; 00000080H
	mov	DWORD PTR _flags$[ebp], ecx
$LN4@GetUnitGri:

; 3833 : 	}
; 3834 : 
; 3835 : 	// Flights will never find a path inroute - only during planning and they should use
; 3836 : 	// 2001-07-27 REMOVED BY S.G. ALLOWED IN RP5
; 3837 : 	//	ShiAssert ( GetMovementType() != Air && GetMovementType() != LowAir );
; 3838 : 
; 3839 : 	maxSearch = GROUND_PATH_MAX;

	movsx	edx, WORD PTR ?GROUND_PATH_MAX@@3FA	; GROUND_PATH_MAX
	mov	DWORD PTR ?maxSearch@@3HA, edx		; maxSearch

; 3840 : 	retval = GetGridPath(p,x,y,xx,yy,GetMovementType(),GetTeam(),flags);

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	push	eax
	movzx	eax, WORD PTR _yy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _xx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _y$[ebp]
	push	edx
	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?GetGridPath@@YAHPAVBasePathClass@@FFFFHHH@Z ; GetGridPath
	add	esp, 32					; 00000020H
	mov	DWORD PTR _retval$[ebp], eax

; 3841 : 	maxSearch = MAX_SEARCH;

	mov	DWORD PTR ?maxSearch@@3HA, 2000		; maxSearch, 000007d0H

; 3842 : 
; 3843 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 3844 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetUnitGridPath@UnitClass@@QAEHPAVBasePathClass@@FFFF@Z ENDP ; UnitClass::GetUnitGridPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flags$ = -4						; size = 4
_p$ = 8							; size = 4
_o$ = 12						; size = 4
_t$ = 16						; size = 4
?GetUnitObjectivePath@UnitClass@@QAEHPAVBasePathClass@@PAVObjectiveClass@@1@Z PROC ; UnitClass::GetUnitObjectivePath
; _this$ = ecx

; 3806 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3807 : 	int				flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 3808 : 
; 3809 : 	if (GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	jne	SHORT $LN2@GetUnitObj

; 3810 : 	{
; 3811 : 		flags |= PATH_ROADOK;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 1
	mov	DWORD PTR _flags$[ebp], ecx

; 3812 : 		// KCK: Commented out to prevent units from stalling
; 3813 : 		//		if (GetUnitCurrentRole() == GRO_ATTACK || GetUnitCurrentRole() == GRO_FIRESUPPORT)
; 3814 : 		flags |= PATH_ENEMYOK | PATH_ENEMYCOST;

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], edx

; 3815 : 		if (GetUnitNormalRole() == GRO_ENGINEER)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 7
	jne	SHORT $LN2@GetUnitObj

; 3816 : 			flags |= PATH_ENGINEER;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 128				; 00000080H
	mov	DWORD PTR _flags$[ebp], ecx
$LN2@GetUnitObj:

; 3817 : 	}
; 3818 : 	maxSearch = OBJ_GROUND_PATH_MAX_SEARCH;

	movsx	edx, WORD PTR ?OBJ_GROUND_PATH_MAX_SEARCH@@3FA ; OBJ_GROUND_PATH_MAX_SEARCH
	mov	DWORD PTR ?maxSearch@@3HA, edx		; maxSearch

; 3819 : 	return GetObjectivePath(p,o,t,GetMovementType(),GetTeam(),flags);

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
	push	eax
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?GetObjectivePath@@YAHPAVBasePathClass@@PAVObjectiveClass@@1HHH@Z ; GetObjectivePath
	add	esp, 24					; 00000018H
	jmp	SHORT $LN3@GetUnitObj

; 3820 : 	maxSearch = MAX_SEARCH;

	mov	DWORD PTR ?maxSearch@@3HA, 2000		; maxSearch, 000007d0H
$LN3@GetUnitObj:

; 3821 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitObjectivePath@UnitClass@@QAEHPAVBasePathClass@@PAVObjectiveClass@@1@Z ENDP ; UnitClass::GetUnitObjectivePath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flags$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
_h$ = 16						; size = 1
?GetUnitMovementCost@UnitClass@@QAEMFFE@Z PROC		; UnitClass::GetUnitMovementCost
; _this$ = ecx

; 3796 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3797 : 	int				flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 3798 : 
; 3799 : 	if (GetUnitFormation() == GFORM_COLUMN)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	cmp	eax, 1
	jne	SHORT $LN1@GetUnitMov

; 3800 : 		flags |= PATH_ROADOK;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1
	mov	DWORD PTR _flags$[ebp], eax
$LN1@GetUnitMov:

; 3801 : 
; 3802 : 	return GetMovementCost(x,y,GetMovementType(),flags,h);

	movzx	ecx, BYTE PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	push	eax
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?GetMovementCost@@YAMFFW4MoveType@@HE@Z	; GetMovementCost
	add	esp, 20					; 00000014H

; 3803 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitMovementCost@UnitClass@@QAEMFFE@Z ENDP		; UnitClass::GetUnitMovementCost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv281 = -56						; size = 4
tv300 = -52						; size = 4
tv273 = -48						; size = 4
tv298 = -44						; size = 4
tv264 = -40						; size = 4
tv296 = -36						; size = 4
tv255 = -32						; size = 4
tv294 = -28						; size = 4
tv81 = -24						; size = 4
_e$ = -20						; size = 4
_i$ = -16						; size = 4
_s$ = -12						; size = 4
_this$ = -8						; size = 4
_score$ = -4						; size = 4
_role$ = 8						; size = 4
_calcType$ = 12						; size = 4
_use_to_calc$ = 16					; size = 4
?GetUnitRoleScore@UnitClass@@QAEHHHH@Z PROC		; UnitClass::GetUnitRoleScore
; _this$ = ecx

; 4377 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4378 : 	int					score=0,s,i=0;

	mov	DWORD PTR _score$[ebp], 0
	mov	DWORD PTR _i$[ebp], 0

; 4379 : 	Unit				e;
; 4380 : 
; 4381 : 	if (calcType == CALC_MIN)

	cmp	DWORD PTR _calcType$[ebp], 4
	jne	SHORT $LN22@GetUnitRol

; 4382 : 		score = 32000;

	mov	DWORD PTR _score$[ebp], 32000		; 00007d00H
$LN22@GetUnitRol:

; 4383 : 
; 4384 : 	if (Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	$LN21@GetUnitRol

; 4385 : 	{
; 4386 : 		e = GetUnitElement(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+888]
	call	edx
	mov	DWORD PTR _e$[ebp], eax
$LN20@GetUnitRol:

; 4387 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN19@GetUnitRol

; 4388 : 		{
; 4389 : 			s = e->GetUnitRoleScore(role, calcType, use_to_calc);

	mov	eax, DWORD PTR _use_to_calc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _calcType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _role$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetUnitRoleScore@UnitClass@@QAEHHHH@Z	; UnitClass::GetUnitRoleScore
	mov	DWORD PTR _s$[ebp], eax

; 4390 : 			switch (calcType)

	mov	eax, DWORD PTR _calcType$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 3
	je	SHORT $LN16@GetUnitRol
	cmp	DWORD PTR tv81[ebp], 4
	je	SHORT $LN14@GetUnitRol
	jmp	SHORT $LN12@GetUnitRol
$LN16@GetUnitRol:

; 4391 : 			{
; 4392 : 					case CALC_MAX:
; 4393 : 							if (s > score)

	mov	ecx, DWORD PTR _s$[ebp]
	cmp	ecx, DWORD PTR _score$[ebp]
	jle	SHORT $LN15@GetUnitRol

; 4394 : 								score = s;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _score$[ebp], edx
$LN15@GetUnitRol:

; 4395 : 							break;

	jmp	SHORT $LN17@GetUnitRol
$LN14@GetUnitRol:

; 4396 : 					case CALC_MIN:
; 4397 : 							if (s < score)

	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _score$[ebp]
	jge	SHORT $LN13@GetUnitRol

; 4398 : 								score = s;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _score$[ebp], ecx
$LN13@GetUnitRol:

; 4399 : 							break;

	jmp	SHORT $LN17@GetUnitRol
$LN12@GetUnitRol:

; 4400 : 					default:
; 4401 : 							score += s;

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _score$[ebp], edx
$LN17@GetUnitRol:

; 4402 : 							break;
; 4403 : 			}
; 4404 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 4405 : 			e = GetUnitElement(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+888]
	call	edx
	mov	DWORD PTR _e$[ebp], eax

; 4406 : 		}

	jmp	SHORT $LN20@GetUnitRol
$LN19@GetUnitRol:

; 4407 : 		if (calcType == CALC_AVERAGE)

	cmp	DWORD PTR _calcType$[ebp], 1
	jne	SHORT $LN11@GetUnitRol

; 4408 : 			score /= i;

	mov	eax, DWORD PTR _score$[ebp]
	cdq
	idiv	DWORD PTR _i$[ebp]
	mov	DWORD PTR _score$[ebp], eax
$LN11@GetUnitRol:

; 4409 : 	}
; 4410 : 	else

	jmp	$LN1@GetUnitRol
$LN21@GetUnitRol:

; 4411 : 	{
; 4412 : 		score = class_data->Scores[role];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _role$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+268]
	mov	DWORD PTR _score$[ebp], eax

; 4413 : 		if (use_to_calc & USE_VEH_COUNT)

	mov	ecx, DWORD PTR _use_to_calc$[ebp]
	and	ecx, 2
	je	SHORT $LN9@GetUnitRol

; 4414 : 			score = score * GetTotalVehicles() / GetFullstrengthVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	esi, eax
	imul	esi, DWORD PTR _score$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	DWORD PTR _score$[ebp], eax
$LN9@GetUnitRol:

; 4415 : 		if (use_to_calc & USE_EXP)

	mov	edx, DWORD PTR _use_to_calc$[ebp]
	and	edx, 1
	je	$LN2@GetUnitRol

; 4416 : 		{
; 4417 : 			if (GetRClass() == RCLASS_AIR)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	test	eax, eax
	jne	SHORT $LN7@GetUnitRol

; 4418 : 				score = FloatToInt32(score * AirExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _score$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv294[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	eax, al
	push	eax
	call	?AirExperienceAdjustment@@YAME@Z	; AirExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv255[ebp]
	movss	xmm0, DWORD PTR tv294[ebp]
	mulss	xmm0, DWORD PTR tv255[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _score$[ebp], eax
	jmp	$LN2@GetUnitRol
$LN7@GetUnitRol:

; 4419 : 			else if (GetRClass() == RCLASS_NAVAL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	cmp	eax, 3
	jne	SHORT $LN5@GetUnitRol

; 4420 : 				score = FloatToInt32(score * NavalExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _score$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv296[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	push	ecx
	call	?NavalExperienceAdjustment@@YAME@Z	; NavalExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv264[ebp]
	movss	xmm0, DWORD PTR tv296[ebp]
	mulss	xmm0, DWORD PTR tv264[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _score$[ebp], eax
	jmp	$LN2@GetUnitRol
$LN5@GetUnitRol:

; 4421 : 			else if (GetRClass() == RCLASS_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	cmp	eax, 2
	jne	SHORT $LN3@GetUnitRol

; 4422 : 				score = FloatToInt32(score * AirDefenseExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _score$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv298[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	push	edx
	call	?AirDefenseExperienceAdjustment@@YAME@Z	; AirDefenseExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv273[ebp]
	movss	xmm0, DWORD PTR tv298[ebp]
	mulss	xmm0, DWORD PTR tv273[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _score$[ebp], eax

; 4423 : 			else

	jmp	SHORT $LN2@GetUnitRol
$LN3@GetUnitRol:

; 4424 : 				score = FloatToInt32(score * GroundExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _score$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv300[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	eax, al
	push	eax
	call	?GroundExperienceAdjustment@@YAME@Z	; GroundExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv281[ebp]
	movss	xmm0, DWORD PTR tv300[ebp]
	mulss	xmm0, DWORD PTR tv281[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _score$[ebp], eax
$LN2@GetUnitRol:

; 4425 : 		}
; 4426 : 		if (use_to_calc & IGNORE_BROKEN && Broken())

	mov	ecx, DWORD PTR _use_to_calc$[ebp]
	and	ecx, 4
	je	SHORT $LN1@GetUnitRol
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Broken@UnitClass@@QBEHXZ		; UnitClass::Broken
	test	eax, eax
	je	SHORT $LN1@GetUnitRol

; 4427 : 			score /= 5;

	mov	eax, DWORD PTR _score$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	DWORD PTR _score$[ebp], eax
$LN1@GetUnitRol:

; 4428 : 	}
; 4429 : 
; 4430 : 	return score;

	mov	eax, DWORD PTR _score$[ebp]

; 4431 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetUnitRoleScore@UnitClass@@QAEHHHH@Z ENDP		; UnitClass::GetUnitRoleScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_t$ = -4						; size = 4
?GetUnitFormation@UnitClass@@QBEHXZ PROC		; UnitClass::GetUnitFormation
; _this$ = ecx

; 2232 : int UnitClass::GetUnitFormation() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2233 : 	int		t;
; 2234 : 	t = GetUnitTactic();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	mov	DWORD PTR _t$[ebp], eax

; 2235 : 	if (t){

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN1@GetUnitFor

; 2236 : 		return GetTacticFormation(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?GetTacticFormation@@YAHH@Z		; GetTacticFormation
	add	esp, 4
	jmp	SHORT $LN2@GetUnitFor
$LN1@GetUnitFor:

; 2237 : 	}
; 2238 : 	return 0;

	xor	eax, eax
$LN2@GetUnitFor:

; 2239 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFormation@UnitClass@@QBEHXZ ENDP		; UnitClass::GetUnitFormation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_dy$ = -16						; size = 2
_y$ = -12						; size = 2
_dx$ = -8						; size = 2
_x$ = -4						; size = 2
?AtDestination@UnitClass@@QAEHXZ PROC			; UnitClass::AtDestination
; _this$ = ecx

; 2222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2223 : 	GridIndex		x,y,dx,dy;
; 2224 : 
; 2225 : 	GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2226 : 	GetUnitDestination(&dx,&dy);

	lea	edx, DWORD PTR _dy$[ebp]
	push	edx
	lea	eax, DWORD PTR _dx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 2227 : 	if (x == dx && y == dy)

	movsx	ecx, WORD PTR _x$[ebp]
	movsx	edx, WORD PTR _dx$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN1@AtDestinat
	movsx	eax, WORD PTR _y$[ebp]
	movsx	ecx, WORD PTR _dy$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@AtDestinat

; 2228 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@AtDestinat
$LN1@AtDestinat:

; 2229 : 	return 0;

	xor	eax, eax
$LN2@AtDestinat:

; 2230 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AtDestination@UnitClass@@QAEHXZ ENDP			; UnitClass::AtDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv77 = -16						; size = 4
_allplanned$ = -12					; size = 4
_e$ = -8						; size = 4
_this$ = -4						; size = 4
?NoMission@UnitClass@@QAEHXZ PROC			; UnitClass::NoMission
; _this$ = ecx

; 2207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2208 : 	Unit			e;
; 2209 : 	int			allplanned=1;

	mov	DWORD PTR _allplanned$[ebp], 1

; 2210 : 
; 2211 : 	e = GetFirstUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN3@NoMission:

; 2212 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN2@NoMission

; 2213 : 	{
; 2214 : 		if (e->GetCurrentUnitWP() == NULL)

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	test	eax, eax
	jne	SHORT $LN1@NoMission

; 2215 : 			allplanned=0;

	mov	DWORD PTR _allplanned$[ebp], 0
$LN1@NoMission:

; 2216 : 		e = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 2217 : 	}

	jmp	SHORT $LN3@NoMission
$LN2@NoMission:

; 2218 : 	return !allplanned;

	cmp	DWORD PTR _allplanned$[ebp], 0
	jne	SHORT $LN6@NoMission
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN7@NoMission
$LN6@NoMission:
	mov	DWORD PTR tv77[ebp], 0
$LN7@NoMission:
	mov	eax, DWORD PTR tv77[ebp]

; 2219 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NoMission@UnitClass@@QAEHXZ ENDP			; UnitClass::NoMission
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -68						; size = 8
$T3 = -60						; size = 8
$T4 = -52						; size = 8
$T5 = -44						; size = 4
_target$6 = -40						; size = 4
tv155 = -36						; size = 4
$T7 = -32						; size = 4
tv131 = -28						; size = 4
_msg$8 = -24						; size = 4
_f$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?KillUnit@UnitClass@@QAEXXZ PROC			; UnitClass::KillUnit
; _this$ = ecx

; 2244 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?KillUnit@UnitClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2245 : 	Unit  f;
; 2246 : 
; 2247 : #ifdef DEBUG
; 2248 : 	// Check if we're killing the player flight inappropriately
; 2249 : 	if (this == FalconLocalSession->GetPlayerFlight())
; 2250 : 	{
; 2251 : 		if ((FalconLocalSession->GetPlayerEntity()) && (!((SimBaseClass*)FalconLocalSession->GetPlayerEntity())->IsDead()) && (!((FalconEntity*)(FalconLocalSession->GetPlayerEntity()))->IsEject()))
; 2252 : 		{
; 2253 : 			*((unsigned int *) 0x00) = 0;
; 2254 : 		}
; 2255 : 	}
; 2256 : #endif
; 2257 : 
; 2258 : 	if (IsSetFalcFlag(FEC_REGENERATING))

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN13@KillUnit

; 2259 : 		return;

	jmp	$LN14@KillUnit
$LN13@KillUnit:

; 2260 : 
; 2261 : 	if (!IsAggregate())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	$LN12@KillUnit

; 2262 : 	{
; 2263 : 		VuTargetEntity* target = (VuTargetEntity*) vuDatabase->Find(FalconLocalGame->OwnerId());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@KillUnit
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN17@KillUnit
$LN16@KillUnit:
	mov	DWORD PTR tv131[ebp], 0
$LN17@KillUnit:
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv131[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$6[ebp], eax

; 2264 : 		FalconSimCampMessage	*msg = new FalconSimCampMessage (Id(), target);

	push	66					; 00000042H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN18@KillUnit
	push	1
	mov	ecx, DWORD PTR _target$6[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconSimCampMessage::FalconSimCampMessage
	mov	DWORD PTR tv155[ebp], eax
	jmp	SHORT $LN19@KillUnit
$LN18@KillUnit:
	mov	DWORD PTR tv155[ebp], 0
$LN19@KillUnit:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _msg$8[ebp], ecx

; 2265 : 		msg->dataBlock.from = FalconLocalSessionId;

	mov	edx, DWORD PTR _msg$8[ebp]
	mov	eax, DWORD PTR ?vuLocalSession@@3VVU_ID@@A
	mov	DWORD PTR [edx+48], eax
	mov	ecx, DWORD PTR ?vuLocalSession@@3VVU_ID@@A+4
	mov	DWORD PTR [edx+52], ecx

; 2266 : 		msg->dataBlock.message = FalconSimCampMessage::simcampReaggregate;

	mov	edx, DWORD PTR _msg$8[ebp]
	mov	DWORD PTR [edx+56], 0

; 2267 : 		FalconSendMessage(msg);

	push	0
	mov	eax, DWORD PTR _msg$8[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN12@KillUnit:

; 2268 : 	}
; 2269 : 
; 2270 : #ifdef DEBUG
; 2271 : 	//	if (IsFlight())
; 2272 : 	//		{
; 2273 : 	//		ShiAssert(((Flight)this)->pilots[0] == NO_PILOT && ((Flight)this)->pilots[1] == NO_PILOT && ((Flight)this)->pilots[2] == NO_PILOT && ((Flight)this)->pilots[3] == NO_PILOT);
; 2274 : 	//		}
; 2275 : #endif
; 2276 : 
; 2277 : 	if (!IsDead())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN11@KillUnit

; 2278 : 		SetDead(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDead@UnitClass@@QAEXH@Z		; UnitClass::SetDead
$LN11@KillUnit:

; 2279 : 
; 2280 : 	// Regroup us, if we're a flight
; 2281 : 	if (IsFlight())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN10@KillUnit

; 2282 : 		RegroupFlight((FlightClass*)this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?RegroupFlight@@YAHPAVFlightClass@@@Z	; RegroupFlight
	add	esp, 4
$LN10@KillUnit:

; 2283 : 
; 2284 : 	f = GetUnitParent();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+944]
	call	edx
	mov	DWORD PTR _f$[ebp], eax

; 2285 : 	if (Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN9@KillUnit

; 2286 : 		DisposeChildren();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+976]
	call	eax

; 2287 : 	else

	jmp	SHORT $LN8@KillUnit
$LN9@KillUnit:

; 2288 : 	{
; 2289 : 		if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN8@KillUnit

; 2290 : 			f->RemoveChild(Id());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [edx+980]
	call	eax
$LN8@KillUnit:

; 2291 : 	}
; 2292 : 	if (!f || f==this)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN5@KillUnit
	mov	ecx, DWORD PTR _f$[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $LN6@KillUnit
$LN5@KillUnit:

; 2293 : 		return;

	jmp	$LN14@KillUnit
$LN6@KillUnit:

; 2294 : 	if (f->CountUnitElements() == 0 && !f->IsDead())          // Nothing left in father

	mov	ecx, DWORD PTR _f$[ebp]
	call	?CountUnitElements@UnitClass@@QAEHXZ	; UnitClass::CountUnitElements
	test	eax, eax
	jne	SHORT $LN4@KillUnit
	mov	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR [eax+552]
	call	edx
	test	eax, eax
	jne	SHORT $LN4@KillUnit

; 2295 : 		f->KillUnit();

	mov	ecx, DWORD PTR _f$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit
$LN4@KillUnit:

; 2296 : 	if (IsSetFalcFlag(FEC_HASPLAYERS))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	je	SHORT $LN14@KillUnit

; 2297 : 	{
; 2298 : 		if (this == FalconLocalSession->GetPlayerFlight())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	cmp	DWORD PTR _this$[ebp], eax
	jne	SHORT $LN2@KillUnit

; 2299 : 			FalconLocalSession->SetPlayerFlight(NULL);

	push	0
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?SetPlayerFlight@FalconSessionEntity@@QAEXPAVFlightClass@@@Z ; FalconSessionEntity::SetPlayerFlight
$LN2@KillUnit:

; 2300 : 		if (this == FalconLocalSession->GetPlayerSquadron())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetPlayerSquadron@FalconSessionEntity@@QBEPAVSquadronClass@@XZ ; FalconSessionEntity::GetPlayerSquadron
	cmp	DWORD PTR _this$[ebp], eax
	jne	SHORT $LN14@KillUnit

; 2301 : 			FalconLocalSession->SetPlayerSquadron(NULL);

	push	0
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?SetPlayerSquadron@FalconSessionEntity@@QAEXPAVSquadronClass@@@Z ; FalconSessionEntity::SetPlayerSquadron
$LN14@KillUnit:

; 2302 : 	}
; 2303 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?KillUnit@UnitClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?KillUnit@UnitClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?KillUnit@UnitClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?KillUnit@UnitClass@@QAEXXZ ENDP			; UnitClass::KillUnit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_speed$ = -12						; size = 4
_e$ = -8						; size = 4
_this$ = -4						; size = 4
?GetFormationCruiseSpeed@UnitClass@@QBEHXZ PROC		; UnitClass::GetFormationCruiseSpeed
; _this$ = ecx

; 3618 : int UnitClass::GetFormationCruiseSpeed() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3619 : 	int      speed = 9999;

	mov	DWORD PTR _speed$[ebp], 9999		; 0000270fH

; 3620 : 	Unit     e;
; 3621 : 
; 3622 : 	if (!Father() || !GetFirstUnitElement())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN4@GetFormati
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	test	eax, eax
	jne	SHORT $LN5@GetFormati
$LN4@GetFormati:

; 3623 : 		return GetCruiseSpeed();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	jmp	SHORT $LN6@GetFormati
$LN5@GetFormati:

; 3624 : 	e = GetFirstUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN3@GetFormati:

; 3625 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN2@GetFormati

; 3626 : 	{
; 3627 : 		if (speed > e->GetCruiseSpeed())

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	cmp	DWORD PTR _speed$[ebp], eax
	jle	SHORT $LN1@GetFormati

; 3628 : 			speed = e->GetCruiseSpeed();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	mov	DWORD PTR _speed$[ebp], eax
$LN1@GetFormati:

; 3629 : 		e = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 3630 : 	}

	jmp	SHORT $LN3@GetFormati
$LN2@GetFormati:

; 3631 : 	return speed;

	mov	eax, DWORD PTR _speed$[ebp]
$LN6@GetFormati:

; 3632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormationCruiseSpeed@UnitClass@@QBEHXZ ENDP		; UnitClass::GetFormationCruiseSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_mv$ = -28						; size = 4
_i$ = -24						; size = 4
_n$ = -20						; size = 4
_uc$ = -16						; size = 4
_vehs$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
_a$ = 8							; size = 4
?ChangeVehicles@UnitClass@@QAEHH@Z PROC			; UnitClass::ChangeVehicles
; _this$ = ecx

; 2173 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2174 : 	int		i,v,n,vehs,mv;
; 2175 : 	UnitClassDataType*	uc;
; 2176 : 
; 2177 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 2178 : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN9@ChangeVehi

; 2179 : 		return 0;

	xor	eax, eax
	jmp	$LN10@ChangeVehi
$LN9@ChangeVehi:

; 2180 : 
; 2181 : 	mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	edx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$[ebp], edx

; 2182 : 	vehs = GetTotalVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _vehs$[ebp], eax

; 2183 : 	for (i=0; i<50 && (vehs>0 || a>0) && a; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@ChangeVehi
$LN7@ChangeVehi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@ChangeVehi:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	$LN6@ChangeVehi
	cmp	DWORD PTR _vehs$[ebp], 0
	jg	SHORT $LN5@ChangeVehi
	cmp	DWORD PTR _a$[ebp], 0
	jle	$LN6@ChangeVehi
$LN5@ChangeVehi:
	cmp	DWORD PTR _a$[ebp], 0
	je	$LN6@ChangeVehi

; 2184 : 	{
; 2185 : 		v = rand()%mv;

	call	_rand
	cdq
	idiv	DWORD PTR _mv$[ebp]
	mov	DWORD PTR _v$[ebp], edx

; 2186 : 		n = GetNumVehicles(v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	DWORD PTR _n$[ebp], eax

; 2187 : 		if (a > 0 && n < uc->NumElements[v] && uc->VehicleType[v])

	cmp	DWORD PTR _a$[ebp], 0
	jle	SHORT $LN4@ChangeVehi
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _uc$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+4]
	jge	SHORT $LN4@ChangeVehi
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _uc$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+68]
	test	ecx, ecx
	je	SHORT $LN4@ChangeVehi

; 2188 : 		{
; 2189 : 			vehs++;

	mov	edx, DWORD PTR _vehs$[ebp]
	add	edx, 1
	mov	DWORD PTR _vehs$[ebp], edx

; 2190 : 			if (losses) losses--;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+221]
	test	ecx, ecx
	je	SHORT $LN3@ChangeVehi
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+221]
	sub	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+221], al
$LN3@ChangeVehi:

; 2191 : 			SetNumVehicles(v, n+1);

	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles

; 2192 : 			a--;

	mov	ecx, DWORD PTR _a$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _a$[ebp], ecx
	jmp	SHORT $LN2@ChangeVehi
$LN4@ChangeVehi:

; 2193 : 		}
; 2194 : 		else if (a < 0 && n > 0 && uc->VehicleType[v])

	cmp	DWORD PTR _a$[ebp], 0
	jge	SHORT $LN2@ChangeVehi
	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN2@ChangeVehi
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _uc$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+68]
	test	ecx, ecx
	je	SHORT $LN2@ChangeVehi

; 2195 : 		{
; 2196 : 			vehs--;

	mov	edx, DWORD PTR _vehs$[ebp]
	sub	edx, 1
	mov	DWORD PTR _vehs$[ebp], edx

; 2197 : 			losses++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+221]
	add	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+221], cl

; 2198 : 			SetNumVehicles(v, n-1);

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles

; 2199 : 			a++;

	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 1
	mov	DWORD PTR _a$[ebp], edx
$LN2@ChangeVehi:

; 2200 : 		}
; 2201 : 	}

	jmp	$LN7@ChangeVehi
$LN6@ChangeVehi:

; 2202 : 	ClearDeaggregationData();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	call	eax

; 2203 : 	return vehs;

	mov	eax, DWORD PTR _vehs$[ebp]
$LN10@ChangeVehi:

; 2204 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeVehicles@UnitClass@@QAEHH@Z ENDP			; UnitClass::ChangeVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_mv$ = -16						; size = 4
_R$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?BuildElements@UnitClass@@QAEXXZ PROC			; UnitClass::BuildElements
; _this$ = ecx

; 4352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4353 : 	int i,R,mv=VEHICLE_GROUPS_PER_UNIT;

	mov	DWORD PTR _mv$[ebp], 16			; 00000010H

; 4354 : 
; 4355 : 	// This is a hack- basically, Squadrons arn't "real", but need their elements built.
; 4356 : 	if (!Real() && !IsSquadron()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@BuildEleme
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@BuildEleme

; 4357 : 		return;

	jmp	$LN7@BuildEleme
$LN6@BuildEleme:

; 4358 : 	}
; 4359 : 
; 4360 : 	R = 0;

	mov	DWORD PTR _R$[ebp], 0

; 4361 : 	if (!class_data){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+236], 0
	jne	SHORT $LN5@BuildEleme

; 4362 : 		return;

	jmp	$LN7@BuildEleme
$LN5@BuildEleme:

; 4363 : 	}
; 4364 : 
; 4365 : 	if (TeamInfo[GetTeam ()]){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN4@BuildEleme

; 4366 : 		mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	edx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$[ebp], edx
$LN4@BuildEleme:

; 4367 : 	}
; 4368 : 
; 4369 : 	for (i=0; i<mv; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@BuildEleme
$LN2@BuildEleme:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@BuildEleme:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mv$[ebp]
	jge	SHORT $LN1@BuildEleme

; 4370 : 		R = R ^ (class_data->NumElements[i]) << (i*2);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+4]
	shl	eax, cl
	xor	eax, DWORD PTR _R$[ebp]
	mov	DWORD PTR _R$[ebp], eax

; 4371 : 	}

	jmp	SHORT $LN2@BuildEleme
$LN1@BuildEleme:

; 4372 : 	roster = R;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _R$[ebp]
	mov	DWORD PTR [ecx+192], edx
$LN7@BuildEleme:

; 4373 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildElements@UnitClass@@QAEXXZ ENDP			; UnitClass::BuildElements
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_e$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?ResetDestinations@UnitClass@@QAEXFF@Z PROC		; UnitClass::ResetDestinations
; _this$ = ecx

; 4303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4304 : 	Unit			e;
; 4305 : 
; 4306 : 	SetUnitDestination(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 4307 : 	if (Father())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+504]
	call	edx
	test	eax, eax
	je	SHORT $LN4@ResetDesti

; 4308 : 	{
; 4309 : 		e = GetFirstUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN2@ResetDesti:

; 4310 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN4@ResetDesti

; 4311 : 		{
; 4312 : 			e->ResetDestinations(x,y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?ResetDestinations@UnitClass@@QAEXFF@Z	; UnitClass::ResetDestinations

; 4313 : 			e = GetNextUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 4314 : 		}

	jmp	SHORT $LN2@ResetDesti
$LN4@ResetDesti:

; 4315 : 	}
; 4316 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ResetDestinations@UnitClass@@QAEXFF@Z ENDP		; UnitClass::ResetDestinations
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_e$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?ResetLocations@UnitClass@@QAEXFF@Z PROC		; UnitClass::ResetLocations
; _this$ = ecx

; 4280 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4281 : 	Unit			e;
; 4282 : 
; 4283 : 	SetLocation(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocation@CampBaseClass@@QAEXFF@Z	; CampBaseClass::SetLocation

; 4284 : 	if (Father())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+504]
	call	edx
	test	eax, eax
	je	SHORT $LN4@ResetLocat

; 4285 : 	{
; 4286 : 		e = GetFirstUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN2@ResetLocat:

; 4287 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN4@ResetLocat

; 4288 : 		{
; 4289 : 			e->ResetLocations(x,y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?ResetLocations@UnitClass@@QAEXFF@Z	; UnitClass::ResetLocations

; 4290 : 			e = GetNextUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 4291 : 		}

	jmp	SHORT $LN2@ResetLocat
$LN4@ResetLocat:

; 4292 : 	}
; 4293 : #ifdef USE_FLANKS
; 4294 : 	if (IsBattalion())
; 4295 : 	{
; 4296 : 		((Battalion)this)->lfx = ((Battalion)this)->rfx = x;
; 4297 : 		((Battalion)this)->lfy = ((Battalion)this)->rfy = y;
; 4298 : 	}
; 4299 : #endif
; 4300 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ResetLocations@UnitClass@@QAEXFF@Z ENDP		; UnitClass::ResetLocations
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_n$ = -16						; size = 4
_this$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
?ResetMoves@UnitClass@@QAEXXZ PROC			; UnitClass::ResetMoves
; _this$ = ecx

; 4257 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 4258 : 	Unit        n;
; 4259 : 	GridIndex	x,y;
; 4260 : 
; 4261 : 	if (IsBattalion() || IsTaskForce())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@ResetMoves
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN5@ResetMoves
$LN4@ResetMoves:

; 4262 : 	{
; 4263 : 		ClearUnitPath();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+916]
	call	eax

; 4264 : 		GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 4265 : 		SetUnitDestination(x,y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitDestination@UnitClass@@QAEXFF@Z	; UnitClass::SetUnitDestination

; 4266 : 		SetTempDest(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTempDest@UnitClass@@QAEXH@Z		; UnitClass::SetTempDest
$LN5@ResetMoves:

; 4267 : 	}
; 4268 : 	if (Father())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+504]
	call	edx
	test	eax, eax
	je	SHORT $LN6@ResetMoves

; 4269 : 	{
; 4270 : 		n = GetFirstUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _n$[ebp], eax
$LN2@ResetMoves:

; 4271 : 		while (n != NULL)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN6@ResetMoves

; 4272 : 		{
; 4273 : 			n->ResetMoves();

	mov	ecx, DWORD PTR _n$[ebp]
	call	?ResetMoves@UnitClass@@QAEXXZ		; UnitClass::ResetMoves

; 4274 : 			n = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _n$[ebp], eax

; 4275 : 		}

	jmp	SHORT $LN2@ResetMoves
$LN6@ResetMoves:

; 4276 : 	}
; 4277 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetMoves@UnitClass@@QAEXXZ ENDP			; UnitClass::ResetMoves
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_dam$ = -16						; size = 4
_e$ = -12						; size = 4
_els$ = -8						; size = 4
_this$ = -4						; size = 4
?GetRandomElement@UnitClass@@QAEPAV1@XZ PROC		; UnitClass::GetRandomElement
; _this$ = ecx

; 3964 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3965 : 	Unit     e;
; 3966 : 	int      els,dam;
; 3967 : 
; 3968 : 	if (!Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@GetRandomE

; 3969 : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN7@GetRandomE
$LN6@GetRandomE:

; 3970 : 	els = CountUnitElements();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CountUnitElements@UnitClass@@QAEHXZ	; UnitClass::CountUnitElements
	mov	DWORD PTR _els$[ebp], eax

; 3971 : 	dam = rand()%(els+1);

	call	_rand
	mov	ecx, DWORD PTR _els$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx
	mov	DWORD PTR _dam$[ebp], edx

; 3972 : 	for (els=0,e=this;els<dam;els++)

	mov	DWORD PTR _els$[ebp], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _e$[ebp], edx
	jmp	SHORT $LN5@GetRandomE
$LN4@GetRandomE:
	mov	eax, DWORD PTR _els$[ebp]
	add	eax, 1
	mov	DWORD PTR _els$[ebp], eax
$LN5@GetRandomE:
	mov	ecx, DWORD PTR _els$[ebp]
	cmp	ecx, DWORD PTR _dam$[ebp]
	jge	SHORT $LN3@GetRandomE

; 3973 : 	{
; 3974 : 		if (els)

	cmp	DWORD PTR _els$[ebp], 0
	je	SHORT $LN2@GetRandomE

; 3975 : 			e = GetNextUnitElement();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+960]
	call	edx
	mov	DWORD PTR _e$[ebp], eax

; 3976 : 		else

	jmp	SHORT $LN1@GetRandomE
$LN2@GetRandomE:

; 3977 : 			e = GetFirstUnitElement();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN1@GetRandomE:

; 3978 : 	}

	jmp	SHORT $LN4@GetRandomE
$LN3@GetRandomE:

; 3979 : 	return e;

	mov	eax, DWORD PTR _e$[ebp]
$LN7@GetRandomE:

; 3980 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRandomElement@UnitClass@@QAEPAV1@XZ ENDP		; UnitClass::GetRandomElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_mv$1 = -20						; size = 4
_e$ = -16						; size = 4
_i$ = -12						; size = 4
_els$ = -8						; size = 4
_this$ = -4						; size = 4
?CountUnitElements@UnitClass@@QAEHXZ PROC		; UnitClass::CountUnitElements
; _this$ = ecx

; 3939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3940 : 	Unit  e;
; 3941 : 	int   i,els = 0;

	mov	DWORD PTR _els$[ebp], 0

; 3942 : 
; 3943 : 	if (!Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	jne	SHORT $LN7@CountUnitE

; 3944 : 	{
; 3945 : 		int	mv;
; 3946 : 		mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	edx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$1[ebp], edx

; 3947 : 		for (i=0; i<mv; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CountUnitE
$LN5@CountUnitE:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CountUnitE:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mv$1[ebp]
	jge	SHORT $LN4@CountUnitE

; 3948 : 		{
; 3949 : 			if (GetVehicleID((uchar)i))

	movzx	edx, BYTE PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	test	eax, eax
	je	SHORT $LN3@CountUnitE

; 3950 : 				els++;

	mov	ecx, DWORD PTR _els$[ebp]
	add	ecx, 1
	mov	DWORD PTR _els$[ebp], ecx
$LN3@CountUnitE:

; 3951 : 		}

	jmp	SHORT $LN5@CountUnitE
$LN4@CountUnitE:

; 3952 : 		return els;

	mov	eax, DWORD PTR _els$[ebp]
	jmp	SHORT $LN8@CountUnitE
$LN7@CountUnitE:

; 3953 : 	}
; 3954 : 	e = GetFirstUnitElement();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+956]
	call	edx
	mov	DWORD PTR _e$[ebp], eax
$LN2@CountUnitE:

; 3955 : 	while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN1@CountUnitE

; 3956 : 	{
; 3957 : 		els++;

	mov	eax, DWORD PTR _els$[ebp]
	add	eax, 1
	mov	DWORD PTR _els$[ebp], eax

; 3958 : 		e = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 3959 : 	}

	jmp	SHORT $LN2@CountUnitE
$LN1@CountUnitE:

; 3960 : 	return els;

	mov	eax, DWORD PTR _els$[ebp]
$LN8@CountUnitE:

; 3961 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?CountUnitElements@UnitClass@@QAEHXZ ENDP		; UnitClass::CountUnitElements
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRClass@UnitClass@@QAEHXZ PROC			; UnitClass::GetRClass
; _this$ = ecx

; 3676 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3677 : 	if (GetDomain() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 2
	jne	SHORT $LN6@GetRClass

; 3678 : 		return RCLASS_AIR;

	xor	eax, eax
	jmp	SHORT $LN7@GetRClass
	jmp	SHORT $LN7@GetRClass
$LN6@GetRClass:

; 3679 : 	else if (GetDomain() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 4
	jne	SHORT $LN4@GetRClass

; 3680 : 		return RCLASS_NAVAL;

	mov	eax, 3
	jmp	SHORT $LN7@GetRClass
	jmp	SHORT $LN7@GetRClass
$LN4@GetRClass:

; 3681 : 	else if (GetDomain() == DOMAIN_LAND && GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 3
	jne	SHORT $LN2@GetRClass
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN2@GetRClass

; 3682 : 		return RCLASS_AIRDEFENSE;

	mov	eax, 2
	jmp	SHORT $LN7@GetRClass

; 3683 : 	else

	jmp	SHORT $LN7@GetRClass
$LN2@GetRClass:

; 3684 : 		return RCLASS_GROUND;

	mov	eax, 1
$LN7@GetRClass:

; 3685 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRClass@UnitClass@@QAEHXZ ENDP			; UnitClass::GetRClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uc$ = -4						; size = 4
?GetUnitRange@UnitClass@@QAEHXZ PROC			; UnitClass::GetUnitRange
; _this$ = ecx

; 3666 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3667 : 	UnitClassDataType*	uc;
; 3668 : 
; 3669 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 3670 : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN1@GetUnitRan

; 3671 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetUnitRan
$LN1@GetUnitRan:

; 3672 : 	return uc->MaxRange;

	mov	eax, DWORD PTR _uc$[ebp]
	movsx	eax, WORD PTR [eax+258]
$LN2@GetUnitRan:

; 3673 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitRange@UnitClass@@QAEHXZ ENDP			; UnitClass::GetUnitRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_end$ = -12						; size = 4
_this$ = -8						; size = 4
_uc$ = -4						; size = 4
?GetUnitEndurance@UnitClass@@QAEHXZ PROC		; UnitClass::GetUnitEndurance
; _this$ = ecx

; 3654 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3655 : 	int		end;
; 3656 : 	UnitClassDataType*	uc;
; 3657 : 
; 3658 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 3659 : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN1@GetUnitEnd

; 3660 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetUnitEnd
$LN1@GetUnitEnd:

; 3661 : 	end = (uc->Fuel/(uc->Rate+1))/100;

	mov	eax, DWORD PTR _uc$[ebp]
	movsx	ecx, WORD PTR [eax+264]
	add	ecx, 1
	mov	edx, DWORD PTR _uc$[ebp]
	mov	eax, DWORD PTR [edx+260]
	cdq
	idiv	ecx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _end$[ebp], eax

; 3662 : 	return end;

	mov	eax, DWORD PTR _end$[ebp]
$LN2@GetUnitEnd:

; 3663 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitEndurance@UnitClass@@QAEHXZ ENDP		; UnitClass::GetUnitEndurance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatSpeed@UnitClass@@QBEHXZ PROC			; UnitClass::GetCombatSpeed
; _this$ = ecx

; 3642 : int UnitClass::GetCombatSpeed() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3643 : 	//TJL 11/22/03 Remove 0.85F
; 3644 : 	//return FloatToInt32(0.85F * class_data->MovementSpeed);
; 3645 : 	return FloatToInt32(class_data->MovementSpeed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movsx	edx, WORD PTR [ecx+256]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 3646 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatSpeed@UnitClass@@QBEHXZ ENDP			; UnitClass::GetCombatSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCruiseSpeed@UnitClass@@QBEHXZ PROC			; UnitClass::GetCruiseSpeed
; _this$ = ecx

; 3635 : int UnitClass::GetCruiseSpeed() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3636 : 	//TJL 11/22/03 Remove 0.65F
; 3637 : 	//return FloatToInt32(0.65F * class_data->MovementSpeed);
; 3638 : 	return FloatToInt32(class_data->MovementSpeed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movsx	edx, WORD PTR [ecx+256]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4

; 3639 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCruiseSpeed@UnitClass@@QBEHXZ ENDP			; UnitClass::GetCruiseSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxSpeed@UnitClass@@QBEHXZ PROC			; UnitClass::GetMaxSpeed
; _this$ = ecx

; 3649 : int UnitClass::GetMaxSpeed() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3650 : 	return class_data->MovementSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	movsx	eax, WORD PTR [ecx+256]

; 3651 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxSpeed@UnitClass@@QBEHXZ ENDP			; UnitClass::GetMaxSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_uc$ = -12						; size = 4
_mv$ = -8						; size = 4
_this$ = -4						; size = 4
_slot$ = 8						; size = 4
?GetFullstrengthVehicles@UnitClass@@QAEHH@Z PROC	; UnitClass::GetFullstrengthVehicles
; _this$ = ecx

; 4057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4058 : 	if (!Real())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@GetFullstr

; 4059 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@GetFullstr
$LN2@GetFullstr:

; 4060 : 
; 4061 : 	int mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	edx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$[ebp], edx

; 4062 : 	if (slot >= mv)

	mov	eax, DWORD PTR _slot$[ebp]
	cmp	eax, DWORD PTR _mv$[ebp]
	jl	SHORT $LN1@GetFullstr

; 4063 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@GetFullstr
$LN1@GetFullstr:

; 4064 : 
; 4065 : 	UnitClassDataType*		uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 4066 : 	return uc->NumElements[slot];

	mov	ecx, DWORD PTR _slot$[ebp]
	mov	edx, DWORD PTR _uc$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
$LN3@GetFullstr:

; 4067 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetFullstrengthVehicles@UnitClass@@QAEHH@Z ENDP	; UnitClass::GetFullstrengthVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_uc$1 = -24						; size = 4
_mv$2 = -20						; size = 4
_e$ = -16						; size = 4
_this$ = -12						; size = 4
_t$ = -8						; size = 2
_i$ = -4						; size = 2
?GetFullstrengthVehicles@UnitClass@@QAEHXZ PROC		; UnitClass::GetFullstrengthVehicles
; _this$ = ecx

; 4022 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4023 : 	short	i=0,t=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _t$[ebp], cx

; 4024 : 	Unit	e;
; 4025 : 
; 4026 : 	// KCK Hackish: We just assume all flights are fullstrength at 4 for score calculations
; 4027 : 	if (IsFlight()){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN9@GetFullstr

; 4028 : 		return 4;

	mov	eax, 4
	jmp	$LN10@GetFullstr
$LN9@GetFullstr:

; 4029 : 	}
; 4030 : 
; 4031 : 	if (Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN8@GetFullstr

; 4032 : 	{
; 4033 : 		e = GetUnitElement(i);

	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+888]
	call	edx
	mov	DWORD PTR _e$[ebp], eax
$LN7@GetFullstr:

; 4034 : 		while (e)

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN6@GetFullstr

; 4035 : 		{
; 4036 : 			t += e->GetFullstrengthVehicles();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	movsx	ecx, WORD PTR _t$[ebp]
	add	ecx, eax
	mov	WORD PTR _t$[ebp], cx

; 4037 : 			i++;

	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx

; 4038 : 			e = GetUnitElement(i);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+888]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 4039 : 		}

	jmp	SHORT $LN7@GetFullstr
$LN6@GetFullstr:

; 4040 : 	}
; 4041 : 	else

	jmp	$LN5@GetFullstr
$LN8@GetFullstr:

; 4042 : 	{
; 4043 : 		UnitClassDataType*		uc;
; 4044 : 		uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$1[ebp], eax

; 4045 : 
; 4046 : 		if (TeamInfo[GetTeam ()])

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN5@GetFullstr

; 4047 : 		{
; 4048 : 			int mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	ecx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$2[ebp], ecx

; 4049 : 			for (i=0; i<mv; i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN3@GetFullstr
$LN2@GetFullstr:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@GetFullstr:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mv$2[ebp]
	jge	SHORT $LN5@GetFullstr

; 4050 : 				t += uc->NumElements[i];

	movsx	edx, WORD PTR _i$[ebp]
	movsx	eax, WORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _uc$1[ebp]
	add	eax, DWORD PTR [ecx+edx*4+4]
	mov	WORD PTR _t$[ebp], ax
	jmp	SHORT $LN2@GetFullstr
$LN5@GetFullstr:

; 4051 : 		}
; 4052 : 	}
; 4053 : 	return t;

	movsx	eax, WORD PTR _t$[ebp]
$LN10@GetFullstr:

; 4054 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFullstrengthVehicles@UnitClass@@QAEHXZ ENDP		; UnitClass::GetFullstrengthVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_mv$1 = -20						; size = 4
_e$ = -16						; size = 4
_this$ = -12						; size = 4
_t$ = -8						; size = 2
_i$ = -4						; size = 2
?GetTotalVehicles@UnitClass@@QAEHXZ PROC		; UnitClass::GetTotalVehicles
; _this$ = ecx

; 3996 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3997 : 	short	i=0,t=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _t$[ebp], cx

; 3998 : 	Unit	e;
; 3999 : 
; 4000 : 	if (Father()){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+504]
	call	edx
	test	eax, eax
	je	SHORT $LN8@GetTotalVe

; 4001 : 		e = GetUnitElement(i);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+888]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN7@GetTotalVe:

; 4002 : 		while (e){

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN6@GetTotalVe

; 4003 : 			t += e->GetTotalVehicles();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	movsx	ecx, WORD PTR _t$[ebp]
	add	ecx, eax
	mov	WORD PTR _t$[ebp], cx

; 4004 : 			i++;

	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx

; 4005 : 			e = GetUnitElement(i);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+888]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 4006 : 		}

	jmp	SHORT $LN7@GetTotalVe
$LN6@GetTotalVe:

; 4007 : 	}
; 4008 : 	else {

	jmp	SHORT $LN5@GetTotalVe
$LN8@GetTotalVe:

; 4009 : 		if (TeamInfo[GetTeam()]){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN5@GetTotalVe

; 4010 : 			int mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	ecx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$1[ebp], ecx

; 4011 : 			for (i=0; i<mv; i++){

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN3@GetTotalVe
$LN2@GetTotalVe:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@GetTotalVe:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mv$1[ebp]
	jge	SHORT $LN5@GetTotalVe

; 4012 : 				t += GetNumVehicles (i);

	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	movsx	ecx, WORD PTR _t$[ebp]
	add	ecx, eax
	mov	WORD PTR _t$[ebp], cx

; 4013 : 			}

	jmp	SHORT $LN2@GetTotalVe
$LN5@GetTotalVe:

; 4014 : 		}
; 4015 : 	}
; 4016 : 	return t;

	movsx	eax, WORD PTR _t$[ebp]

; 4017 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalVehicles@UnitClass@@QAEHXZ ENDP		; UnitClass::GetTotalVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uc$ = -4						; size = 4
_vg$ = 8						; size = 4
?GetVehicleID@UnitClass@@QAEFH@Z PROC			; UnitClass::GetVehicleID
; _this$ = ecx

; 4069 : VehicleID UnitClass::GetVehicleID(int vg){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4070 : 	UnitClassDataType*		uc;
; 4071 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 4072 : 	if (!uc){ return 0; }

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN1@GetVehicle
	xor	eax, eax
	jmp	SHORT $LN2@GetVehicle
$LN1@GetVehicle:

; 4073 : 	return uc->VehicleType[vg];

	mov	eax, DWORD PTR _vg$[ebp]
	mov	ecx, DWORD PTR _uc$[ebp]
	mov	ax, WORD PTR [ecx+eax*2+68]
$LN2@GetVehicle:

; 4074 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetVehicleID@UnitClass@@QAEFH@Z ENDP			; UnitClass::GetVehicleID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitNameID@UnitClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitNameID@UnitClass@@QAEHXZ PROC			; UnitClass::GetUnitNameID, COMDAT
; _this$ = ecx

; 381  : 	int GetUnitNameID (void)						{ return name_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+226]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitNameID@UnitClass@@QAEHXZ ENDP			; UnitClass::GetUnitNameID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_tid$ = -8						; size = 4
_this$ = -4						; size = 4
_T$ = 8							; size = 1
?SetUnitSPType@UnitClass@@QAEHD@Z PROC			; UnitClass::SetUnitSPType
; _this$ = ecx

; 2850 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2851 : 	int		tid;
; 2852 : 
; 2853 : 	tid = GetClassID(GetDomain(),CLASS_UNIT,GetType(),GetSType(),T,0,0,0);

	push	0
	push	0
	push	0
	movzx	eax, BYTE PTR _T$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	push	edx
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	push	eax
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tid$[ebp], eax

; 2854 : 	if (!tid)

	cmp	DWORD PTR _tid$[ebp], 0
	jne	SHORT $LN1@SetUnitSPT

; 2855 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@SetUnitSPT
$LN1@SetUnitSPT:

; 2856 : 	SetEntityType(tid + VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _tid$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEntityType@VuEntity@@QAEXG@Z	; VuEntity::SetEntityType

; 2857 : 	class_data = (UnitClassDataType*) Falcon4ClassTable[tid].dataPtr;

	mov	edx, DWORD PTR _tid$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+edx+77]
	mov	DWORD PTR [eax+236], edx

; 2858 : 	BuildElements();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildElements@UnitClass@@QAEXXZ	; UnitClass::BuildElements

; 2859 : 	return tid;

	mov	eax, DWORD PTR _tid$[ebp]
$LN2@SetUnitSPT:

; 2860 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSPType@UnitClass@@QAEHD@Z ENDP			; UnitClass::SetUnitSPType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_sp$ = -16						; size = 4
_tid$ = -12						; size = 4
_this$ = -8						; size = 4
tv130 = -1						; size = 1
_T$ = 8							; size = 1
?SetUnitSType@UnitClass@@QAEHD@Z PROC			; UnitClass::SetUnitSType
; _this$ = ecx

; 2837 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2838 : 	int		tid,sp=1;

	mov	DWORD PTR _sp$[ebp], 1

; 2839 : 
; 2840 : 	tid = GetClassID(GetDomain(),CLASS_UNIT,GetType(),T,GetSPType(),0,0,0);

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	eax, al
	push	eax
	movzx	ecx, BYTE PTR _T$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	push	edx
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	push	eax
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tid$[ebp], eax
$LN2@SetUnitSTy:

; 2841 : 	while (!tid && sp < 10)

	cmp	DWORD PTR _tid$[ebp], 0
	jne	SHORT $LN1@SetUnitSTy
	cmp	DWORD PTR _sp$[ebp], 10			; 0000000aH
	jge	SHORT $LN1@SetUnitSTy

; 2842 : 		tid = GetClassID(GetDomain(),CLASS_UNIT,GetType(),T,sp++,0,0,0);

	mov	cl, BYTE PTR _sp$[ebp]
	mov	BYTE PTR tv130[ebp], cl
	push	0
	push	0
	push	0
	movzx	edx, BYTE PTR tv130[ebp]
	push	edx
	movzx	eax, BYTE PTR _T$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	push	ecx
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	push	edx
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tid$[ebp], eax
	mov	eax, DWORD PTR _sp$[ebp]
	add	eax, 1
	mov	DWORD PTR _sp$[ebp], eax
	jmp	SHORT $LN2@SetUnitSTy
$LN1@SetUnitSTy:

; 2843 : 	SetEntityType(tid + VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _tid$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEntityType@VuEntity@@QAEXG@Z	; VuEntity::SetEntityType

; 2844 : 	class_data = (UnitClassDataType*) Falcon4ClassTable[tid].dataPtr;

	mov	edx, DWORD PTR _tid$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+edx+77]
	mov	DWORD PTR [eax+236], edx

; 2845 : 	BuildElements();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildElements@UnitClass@@QAEXXZ	; UnitClass::BuildElements

; 2846 : 	return tid;

	mov	eax, DWORD PTR _tid$[ebp]

; 2847 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitSType@UnitClass@@QAEHD@Z ENDP			; UnitClass::SetUnitSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -52						; size = 8
$T3 = -44						; size = 8
$T4 = -36						; size = 4
_target$ = -32						; size = 4
tv95 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_msg$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 8
_po$ = 16						; size = 8
_so$ = 24						; size = 8
_ao$ = 32						; size = 8
_orders$ = 40						; size = 4
?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z PROC		; UnitClass::AssignUnit
; _this$ = ecx

; 3780 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3781 : 	VuTargetEntity* target = (VuTargetEntity*) vuDatabase->Find(OwnerId());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$[ebp], eax

; 3782 : 	FalconUnitAssignmentMessage*	msg = new FalconUnitAssignmentMessage(Id(), target);

	push	74					; 0000004aH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN3@AssignUnit
	push	1
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconUnitAssignmentMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconUnitAssignmentMessage::FalconUnitAssignmentMessage
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN4@AssignUnit
$LN3@AssignUnit:
	mov	DWORD PTR tv95[ebp], 0
$LN4@AssignUnit:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _msg$[ebp], edx

; 3783 : 
; 3784 : 	msg->dataBlock.poid = po;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR _po$[ebp]
	mov	DWORD PTR [eax+50], ecx
	mov	edx, DWORD PTR _po$[ebp+4]
	mov	DWORD PTR [eax+54], edx

; 3785 : 	msg->dataBlock.soid = so;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR _so$[ebp]
	mov	DWORD PTR [eax+58], ecx
	mov	edx, DWORD PTR _so$[ebp+4]
	mov	DWORD PTR [eax+62], edx

; 3786 : 	msg->dataBlock.roid = ao;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR _ao$[ebp]
	mov	DWORD PTR [eax+66], ecx
	mov	edx, DWORD PTR _ao$[ebp+4]
	mov	DWORD PTR [eax+70], edx

; 3787 : 	msg->dataBlock.orders = orders;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	cx, WORD PTR _orders$[ebp]
	mov	WORD PTR [eax+48], cx

; 3788 : 	FalconSendMessage(msg,TRUE);

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 3789 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignUnit@UnitClass@@QAEXVVU_ID@@000H@Z ENDP		; UnitClass::AssignUnit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTactic@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTactic@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitTactic, COMDAT
; _this$ = ecx

; 375  : 	int GetUnitTactic() const						{ return tactic; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+222]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTactic@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitMoved@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitMoved@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitMoved, COMDAT
; _this$ = ecx

; 374  : 	int GetUnitMoved() const						{ return moved; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+220]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitMoved@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTransportID@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetTransportID
; _this$ = ecx

; 3759 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3760 : 	if (!Cargo())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	SHORT $LN2@GetTranspo

; 3761 : 		return FalconNullId;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@GetTranspo
$LN2@GetTranspo:

; 3762 : 	if (!IsBattalion() && !IsSquadron())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetTranspo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetTranspo

; 3763 : 		return FalconNullId;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@GetTranspo
$LN1@GetTranspo:

; 3764 : 	return cargo_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	eax, DWORD PTR [ecx+208]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@GetTranspo:

; 3765 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTransportID@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetTransportID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetCargoID@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetCargoID
; _this$ = ecx

; 3750 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3751 : 	if (!Cargo())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	SHORT $LN2@GetCargoID

; 3752 : 		return FalconNullId;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@GetCargoID
$LN2@GetCargoID:

; 3753 : 	if (!IsFlight() && !IsTaskForce())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetCargoID
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetCargoID

; 3754 : 		return FalconNullId;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@GetCargoID
$LN1@GetCargoID:

; 3755 : 	return cargo_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	eax, DWORD PTR [ecx+208]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@GetCargoID:

; 3756 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCargoID@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetCargoID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTransport@UnitClass@@QAEPAVCampBaseClass@@XZ PROC	; UnitClass::GetTransport
; _this$ = ecx

; 3741 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3742 : 	if (!Cargo())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	SHORT $LN2@GetTranspo

; 3743 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@GetTranspo
$LN2@GetTranspo:

; 3744 : 	if (!IsBattalion() && !IsSquadron())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetTranspo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetTranspo

; 3745 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@GetTranspo
$LN1@GetTranspo:

; 3746 : 	return (CampEntity) vuDatabase->Find(cargo_id);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	push	edx
	mov	eax, DWORD PTR [ecx+204]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
$LN3@GetTranspo:

; 3747 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTransport@UnitClass@@QAEPAVCampBaseClass@@XZ ENDP	; UnitClass::GetTransport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCargo@UnitClass@@QAEPAVCampBaseClass@@XZ PROC	; UnitClass::GetCargo
; _this$ = ecx

; 3732 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3733 : 	if (!Cargo())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	SHORT $LN2@GetCargo

; 3734 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@GetCargo
$LN2@GetCargo:

; 3735 : 	if (!IsFlight() && !IsTaskForce())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetCargo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetCargo

; 3736 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@GetCargo
$LN1@GetCargo:

; 3737 : 	return (CampEntity) vuDatabase->Find(cargo_id);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	push	edx
	mov	eax, DWORD PTR [ecx+204]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
$LN3@GetCargo:

; 3738 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCargo@UnitClass@@QAEPAVCampBaseClass@@XZ ENDP	; UnitClass::GetCargo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_target$ = -4						; size = 4
?GetCampTarget@UnitClass@@QAEPAVCampBaseClass@@XZ PROC	; UnitClass::GetCampTarget
; _this$ = ecx

; 3719 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3720 : 	FalconEntity	*target;
; 3721 : 
; 3722 : 	target = GetTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _target$[ebp], eax

; 3723 : 	if (!target)

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN3@GetCampTar

; 3724 : 		return NULL;;

	xor	eax, eax
	jmp	SHORT $LN4@GetCampTar
$LN3@GetCampTar:

; 3725 : 	if (target->IsSim())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN2@GetCampTar

; 3726 : 		return ((SimBaseClass*)target)->GetCampaignObject();

	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	jmp	SHORT $LN4@GetCampTar

; 3727 : 	else

	jmp	SHORT $LN4@GetCampTar
$LN2@GetCampTar:

; 3728 : 		return (CampBaseClass*)target;

	mov	eax, DWORD PTR _target$[ebp]
$LN4@GetCampTar:

; 3729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampTarget@UnitClass@@QAEPAVCampBaseClass@@XZ ENDP	; UnitClass::GetCampTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_cTarget$1 = -16					; size = 4
_comp$2 = -12						; size = 4
_target$ = -8						; size = 4
_theObj$3 = -4						; size = 4
?GetSimTarget@UnitClass@@QAEPAVSimBaseClass@@XZ PROC	; UnitClass::GetSimTarget
; _this$ = ecx

; 3688 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3689 : 	FalconEntity	*target;
; 3690 : 
; 3691 : 	target = GetTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _target$[ebp], eax

; 3692 : 	if (!target)

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN8@GetSimTarg

; 3693 : 		return NULL;;

	xor	eax, eax
	jmp	$LN9@GetSimTarg
$LN8@GetSimTarg:

; 3694 : 	if (target->IsSim())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN7@GetSimTarg

; 3695 : 		return (SimBaseClass*) target;

	mov	eax, DWORD PTR _target$[ebp]
	jmp	$LN9@GetSimTarg
	jmp	$LN6@GetSimTarg
$LN7@GetSimTarg:

; 3696 : 	else if (target->IsCampaign())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?IsCampaign@FalconEntity@@QAEHXZ	; FalconEntity::IsCampaign
	test	eax, eax
	je	$LN6@GetSimTarg

; 3697 : 	{
; 3698 : 		// Get random component
; 3699 : 		CampBaseClass	*cTarget = (CampBaseClass*)target;

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR _cTarget$1[ebp], eax

; 3700 : 		SimBaseClass	*theObj;
; 3701 : 		int				comp = 0;

	mov	DWORD PTR _comp$2[ebp], 0

; 3702 : 
; 3703 : 		if (cTarget->IsUnit())

	mov	ecx, DWORD PTR _cTarget$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _cTarget$1[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN4@GetSimTarg

; 3704 : 			comp = rand()%((Unit)cTarget)->GetTotalVehicles();

	call	_rand
	mov	esi, eax
	mov	ecx, DWORD PTR _cTarget$1[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	DWORD PTR _comp$2[ebp], edx
$LN4@GetSimTarg:

; 3705 : 
; 3706 : 		theObj = (SimBaseClass*) ((CampEntity)target)->GetComponentEntity(comp);

	mov	edx, DWORD PTR _comp$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _theObj$3[ebp], eax
$LN3@GetSimTarg:

; 3707 : 		while (theObj)

	cmp	DWORD PTR _theObj$3[ebp], 0
	je	SHORT $LN6@GetSimTarg

; 3708 : 		{
; 3709 : 			if (!theObj->IsDead() && !theObj->IsExploding() && theObj->IsAwake())

	mov	eax, DWORD PTR _theObj$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theObj$3[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetSimTarg
	mov	ecx, DWORD PTR _theObj$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theObj$3[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@GetSimTarg
	mov	ecx, DWORD PTR _theObj$3[ebp]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN1@GetSimTarg

; 3710 : 				return theObj;

	mov	eax, DWORD PTR _theObj$3[ebp]
	jmp	SHORT $LN9@GetSimTarg
$LN1@GetSimTarg:

; 3711 : 			comp++;

	mov	ecx, DWORD PTR _comp$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _comp$2[ebp], ecx

; 3712 : 			theObj =  (SimBaseClass*) ((CampEntity)target)->GetComponentEntity(comp);

	mov	edx, DWORD PTR _comp$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _target$[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _theObj$3[ebp], eax

; 3713 : 		}

	jmp	SHORT $LN3@GetSimTarg
$LN6@GetSimTarg:

; 3714 : 	}
; 3715 : 	return NULL;

	xor	eax, eax
$LN9@GetSimTarg:

; 3716 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSimTarget@UnitClass@@QAEPAVSimBaseClass@@XZ ENDP	; UnitClass::GetSimTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetTargetID, COMDAT
; _this$ = ecx

; 367  : 	VU_ID GetTargetID (void)						{ return target_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	edx, DWORD PTR [eax+216]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ PROC	; UnitClass::GetTarget, COMDAT
; _this$ = ecx

; 366  : 	FalconEntity* GetTarget (void)					{ return (FalconEntity*) vuDatabase->Find(target_id); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR [eax+212]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNumVehicles@UnitClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vg$ = 8						; size = 4
?GetNumVehicles@UnitClass@@QAEHH@Z PROC			; UnitClass::GetNumVehicles, COMDAT
; _this$ = ecx

; 365  : 	int GetNumVehicles (int vg)						{ return (int)((roster >> (vg*2)) & 0x03); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	sar	eax, cl
	and	eax, 3
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumVehicles@UnitClass@@QAEHH@Z ENDP			; UnitClass::GetNumVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
?GetUnitDestination@UnitClass@@QAEXPAF0@Z PROC		; UnitClass::GetUnitDestination
; _this$ = ecx

; 3768 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3769 : 	if ((dest_x==0 || dest_y==0) && !Parent()){

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+200]
	test	ecx, ecx
	je	SHORT $LN2@GetUnitDes
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+202]
	test	eax, eax
	jne	SHORT $LN3@GetUnitDes
$LN2@GetUnitDes:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	jne	SHORT $LN3@GetUnitDes

; 3770 : 		GetUnitParent()->GetUnitDestination (X, Y);

	mov	ecx, DWORD PTR _Y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _X$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	ecx, eax
	call	?GetUnitDestination@UnitClass@@QAEXPAF0@Z ; UnitClass::GetUnitDestination

; 3771 : 	}
; 3772 : 	else {

	jmp	SHORT $LN4@GetUnitDes
$LN3@GetUnitDes:

; 3773 : 		*X = dest_x-1;

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+200]
	sub	edx, 1
	mov	eax, DWORD PTR _X$[ebp]
	mov	WORD PTR [eax], dx

; 3774 : 		*Y = dest_y-1;

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+202]
	sub	edx, 1
	mov	eax, DWORD PTR _Y$[ebp]
	mov	WORD PTR [eax], dx
$LN4@GetUnitDes:

; 3775 : 	}
; 3776 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitDestination@UnitClass@@QAEXPAF0@Z ENDP		; UnitClass::GetUnitDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitMoved@UnitClass@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m$ = 8							; size = 1
?SetUnitMoved@UnitClass@@QAEXE@Z PROC			; UnitClass::SetUnitMoved, COMDAT
; _this$ = ecx

; 360  : 	void SetUnitMoved (uchar m)						{ moved = m; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _m$[ebp]
	mov	BYTE PTR [eax+220], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitMoved@UnitClass@@QAEXE@Z ENDP			; UnitClass::SetUnitMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_this$ = -12						; size = 4
$T3 = -8						; size = 4
tv73 = -4						; size = 4
_e$ = 8							; size = 4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z PROC	; UnitClass::SetTarget, COMDAT
; _this$ = ecx

; 359  : 	void SetTarget (FalconEntity *e)				{ target_id = (e)? e->Id() : FalconNullId; }

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN3@SetTarget
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@SetTarget
$LN3@SetTarget:
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR $T2[ebp+4], edx
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN4@SetTarget:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], eax
	mov	DWORD PTR [edx+216], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ENDP	; UnitClass::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetNumVehicles@UnitClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vg$ = 8						; size = 4
_n$ = 12						; size = 4
?SetNumVehicles@UnitClass@@QAEXHH@Z PROC		; UnitClass::SetNumVehicles, COMDAT
; _this$ = ecx

; 358  : 	void SetNumVehicles(int vg, int n)				{ SetRoster((roster & ~(3<<(vg*2))) | ((n & 0x03) << (vg*2))); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	mov	eax, 3
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _n$[ebp]
	and	edx, 3
	mov	ecx, DWORD PTR _vg$[ebp]
	shl	ecx, 1
	shl	edx, cl
	or	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoster@UnitClass@@QAEXJ@Z		; UnitClass::SetRoster
	mov	esp, ebp
	pop	ebp
	ret	8
?SetNumVehicles@UnitClass@@QAEXHH@Z ENDP		; UnitClass::SetNumVehicles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitDestination@UnitClass@@QAEXFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?SetUnitDestination@UnitClass@@QAEXFF@Z PROC		; UnitClass::SetUnitDestination, COMDAT
; _this$ = ecx

; 356  : 	void SetUnitDestination (GridIndex x, GridIndex y)	{ 	dest_x = (GridIndex)(x+1); dest_y = (GridIndex)(y+1); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR _x$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+200], ax
	movsx	edx, WORD PTR _y$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+202], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitDestination@UnitClass@@QAEXFF@Z ENDP		; UnitClass::SetUnitDestination
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_vc$ = -12						; size = 4
_wc$ = -8						; size = 4
_this$ = -4						; size = 4
_hp$ = 8						; size = 4
_slot$ = 12						; size = 4
?GetUnitWeaponCount@UnitClass@@UAEHHH@Z PROC		; UnitClass::GetUnitWeaponCount
; _this$ = ecx

; 4599 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4600 : 	ShiAssert(slot >= 0 && slot < VEHICLE_GROUPS_PER_UNIT);
; 4601 : 	ShiAssert(hp >=0 && hp < HARDPOINT_MAX);
; 4602 : 	ShiAssert(class_data != NULL);
; 4603 : 	VehicleClassDataType*	vc;
; 4604 : 	int						wc;
; 4605 : 
; 4606 : 	vc = GetVehicleClassData(class_data->VehicleType[slot]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _slot$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4607 : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN4@GetUnitWea

; 4608 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN5@GetUnitWea
$LN4@GetUnitWea:

; 4609 : 
; 4610 : 	wc = vc->Weapons[hp];

	mov	ecx, DWORD PTR _vc$[ebp]
	add	ecx, DWORD PTR _hp$[ebp]
	movzx	edx, BYTE PTR [ecx+130]
	mov	DWORD PTR _wc$[ebp], edx

; 4611 : 
; 4612 : 	// Use supply % to determine # of shots
; 4613 : 	if (wc > 2)						

	cmp	DWORD PTR _wc$[ebp], 2
	jle	SHORT $LN3@GetUnitWea

; 4614 : 	{
; 4615 : 		// if (# of shots > 2)		- supply % of shots
; 4616 : 		wc = (wc * GetUnitSupply()) / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+776]
	call	eax
	imul	eax, DWORD PTR _wc$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _wc$[ebp], eax
	jmp	SHORT $LN2@GetUnitWea
$LN3@GetUnitWea:

; 4617 : 	}
; 4618 : 	else if (rand() % 100 > GetUnitSupply())		

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+776]
	call	edx
	cmp	esi, eax
	jle	SHORT $LN2@GetUnitWea

; 4619 : 	{
; 4620 : 		// otherwise				- supply % of vehs have shots
; 4621 : 		wc = 0;

	mov	DWORD PTR _wc$[ebp], 0
$LN2@GetUnitWea:

; 4622 : 	}
; 4623 : 
; 4624 : 	return wc;

	mov	eax, DWORD PTR _wc$[ebp]
$LN5@GetUnitWea:

; 4625 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitWeaponCount@UnitClass@@UAEHHH@Z ENDP		; UnitClass::GetUnitWeaponCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vc$ = -4						; size = 4
_hp$ = 8						; size = 4
_slot$ = 12						; size = 4
?GetUnitWeaponId@UnitClass@@UAEHHH@Z PROC		; UnitClass::GetUnitWeaponId
; _this$ = ecx

; 4584 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4585 : 	ShiAssert(slot >= 0 && slot < VEHICLE_GROUPS_PER_UNIT);
; 4586 : 	ShiAssert(hp >=0 && hp < HARDPOINT_MAX);
; 4587 : 	ShiAssert(class_data != NULL);
; 4588 : 
; 4589 : 	VehicleClassDataType*	vc;
; 4590 : 
; 4591 : 	vc = GetVehicleClassData(class_data->VehicleType[slot]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _slot$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4592 : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN1@GetUnitWea

; 4593 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetUnitWea
$LN1@GetUnitWea:

; 4594 : 
; 4595 : 	return vc->Weapon[hp];

	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
$LN2@GetUnitWea:

; 4596 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitWeaponId@UnitClass@@UAEHHH@Z ENDP		; UnitClass::GetUnitWeaponId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_maxAlt$1 = -100					; size = 4
_rangeSqr$2 = -96					; size = 4
tv321 = -92						; size = 4
tv339 = -88						; size = 4
tv317 = -84						; size = 4
tv313 = -80						; size = 4
tv337 = -76						; size = 4
tv309 = -72						; size = 4
tv305 = -68						; size = 4
tv335 = -64						; size = 4
tv301 = -60						; size = 4
_vc$ = -56						; size = 4
_rng$ = -52						; size = 4
_diffZ$3 = -48						; size = 4
_minRange$4 = -44					; size = 4
_diffY$5 = -40						; size = 4
_diffX$6 = -36						; size = 4
_wpnDefinition$7 = -32					; size = 4
_br$ = -28						; size = 4
_minAlt$8 = -24						; size = 4
_auxData$9 = -20					; size = 4
_classInfoPtr$10 = -16					; size = 4
_i$ = -12						; size = 4
_wid$ = -8						; size = 4
_this$ = -4						; size = 4
_slot$ = 8						; size = 4
_mt$ = 12						; size = 4
_target$ = 16						; size = 4
?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z PROC ; UnitClass::GetVehicleRange
; _this$ = ecx

; 4525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 4526 : 	ShiAssert(slot >= 0 && slot < VEHICLE_GROUPS_PER_UNIT);
; 4527 : 	ShiAssert(class_data != NULL);
; 4528 : 	int						i,wid,rng,br=0;

	mov	DWORD PTR _br$[ebp], 0

; 4529 : 	VehicleClassDataType*	vc;
; 4530 : 
; 4531 : 	vc = GetVehicleClassData(class_data->VehicleType[slot]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _slot$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4532 : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN15@GetVehicle

; 4533 : 		return 0;

	xor	eax, eax
	jmp	$LN16@GetVehicle
$LN15@GetVehicle:

; 4534 : 
; 4535 : 	for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@GetVehicle
$LN13@GetVehicle:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN14@GetVehicle:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN12@GetVehicle

; 4536 : 	{
; 4537 : 		wid = GetUnitWeaponId(i,slot);

	mov	edx, DWORD PTR _slot$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+584]
	call	eax
	mov	DWORD PTR _wid$[ebp], eax

; 4538 : 		if (wid && GetUnitWeaponCount(i,slot))

	cmp	DWORD PTR _wid$[ebp], 0
	je	$LN1@GetVehicle
	mov	ecx, DWORD PTR _slot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	call	eax
	test	eax, eax
	je	$LN1@GetVehicle

; 4539 : 		{
; 4540 : 			// 2002-03-08 ADDED BY S.G. If we're a ground thingy, we're shooting at an air thingy and this weapon is a ... STYPE_MISSILE_SURF_AIR, we might be restricted to a min/max engagement range/altitude if we asked for it
; 4541 : 			if (g_bLimit2DRadarFight && target && OnGround() && (mt == LowAir || mt == Air)) {

	movzx	ecx, BYTE PTR ?g_bLimit2DRadarFight@@3_NA ; g_bLimit2DRadarFight
	test	ecx, ecx
	je	$LN3@GetVehicle
	cmp	DWORD PTR _target$[ebp], 0
	je	$LN3@GetVehicle
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	$LN3@GetVehicle
	cmp	DWORD PTR _mt$[ebp], 4
	je	SHORT $LN9@GetVehicle
	cmp	DWORD PTR _mt$[ebp], 5
	jne	$LN3@GetVehicle
$LN9@GetVehicle:

; 4542 : 				VU_BYTE *classInfoPtr = Falcon4ClassTable[WeaponDataTable[wid].Index].vuClassData.classInfo_;

	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	edx, WORD PTR [ecx+eax]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _classInfoPtr$10[ebp], ecx

; 4543 : 				if (classInfoPtr[VU_DOMAIN] == DOMAIN_AIR && classInfoPtr[VU_CLASS] == CLASS_VEHICLE && classInfoPtr[VU_TYPE] == TYPE_MISSILE && classInfoPtr[VU_STYPE] == STYPE_MISSILE_SURF_AIR) {

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _classInfoPtr$10[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 2
	jne	$LN3@GetVehicle
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _classInfoPtr$10[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 7
	jne	$LN3@GetVehicle
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classInfoPtr$10[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 6
	jne	$LN3@GetVehicle
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _classInfoPtr$10[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 5
	jne	$LN3@GetVehicle

; 4544 : 					MissileAuxData *auxData = NULL;

	mov	DWORD PTR _auxData$9[ebp], 0

; 4545 : 					SimWeaponDataType* wpnDefinition = &SimWeaponDataTable[Falcon4ClassTable[WeaponDataTable[wid].Index].vehicleDataIndex];

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movsx	eax, WORD PTR [edx+ecx+74]
	imul	eax, 52					; 00000034H
	add	eax, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	DWORD PTR _wpnDefinition$7[ebp], eax

; 4546 : 					if (wpnDefinition->dataIdx < numMissileDatasets)

	mov	ecx, DWORD PTR _wpnDefinition$7[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	edx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	jge	SHORT $LN7@GetVehicle

; 4547 : 						auxData = missileDataset[wpnDefinition->dataIdx].auxData;

	mov	eax, DWORD PTR _wpnDefinition$7[ebp]
	mov	ecx, DWORD PTR [eax+48]
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR ?missileDataset@@3PAVMissileDataSetClass@@A ; missileDataset
	mov	eax, DWORD PTR [edx+ecx+96]
	mov	DWORD PTR _auxData$9[ebp], eax
$LN7@GetVehicle:

; 4548 : 					if (auxData) {

	cmp	DWORD PTR _auxData$9[ebp], 0
	je	$LN3@GetVehicle

; 4549 : 						float minAlt = auxData->MinEngagementAlt;

	mov	ecx, DWORD PTR _auxData$9[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR _minAlt$8[ebp], xmm0

; 4550 : 						float minRange = auxData->MinEngagementRange;

	mov	edx, DWORD PTR _auxData$9[ebp]
	movss	xmm0, DWORD PTR [edx+24]
	movss	DWORD PTR _minRange$4[ebp], xmm0

; 4551 : 						float maxAlt = (float)WeaponDataTable[wid].MaxAlt * 1000.0f;

	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	edx, BYTE PTR [ecx+eax+58]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _maxAlt$1[ebp], xmm0

; 4552 : 						float diffX, diffY, diffZ, rangeSqr;
; 4553 : 
; 4554 : 						// If we haven't entered the MinEngagementAlt yet, use the one in the Falcon4.WCD file
; 4555 : 						if (minAlt < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _minAlt$8[ebp]
	jbe	SHORT $LN5@GetVehicle

; 4556 : 							minAlt = (float)(WeaponDataTable[wid].Name[18]) * 32.0F;

	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	ecx, 1
	imul	ecx, 18					; 00000012H
	movsx	edx, BYTE PTR [eax+ecx+12]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR _minAlt$8[ebp], xmm0
$LN5@GetVehicle:

; 4557 : 
; 4558 : 						diffX = XPos() - target->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv301[ebp]
	movss	xmm0, DWORD PTR tv301[ebp]
	mov	ecx, DWORD PTR _target$[ebp]
	movss	DWORD PTR tv335[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv305[ebp]
	movss	xmm0, DWORD PTR tv335[ebp]
	subss	xmm0, DWORD PTR tv305[ebp]
	movss	DWORD PTR _diffX$6[ebp], xmm0

; 4559 : 						diffY = YPos() - target->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv309[ebp]
	movss	xmm0, DWORD PTR tv309[ebp]
	mov	ecx, DWORD PTR _target$[ebp]
	movss	DWORD PTR tv337[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv313[ebp]
	movss	xmm0, DWORD PTR tv337[ebp]
	subss	xmm0, DWORD PTR tv313[ebp]
	movss	DWORD PTR _diffY$5[ebp], xmm0

; 4560 : 						diffZ = ZPos() - target->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv317[ebp]
	movss	xmm0, DWORD PTR tv317[ebp]
	mov	ecx, DWORD PTR _target$[ebp]
	movss	DWORD PTR tv339[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv321[ebp]
	movss	xmm0, DWORD PTR tv339[ebp]
	subss	xmm0, DWORD PTR tv321[ebp]
	movss	DWORD PTR _diffZ$3[ebp], xmm0

; 4561 : 
; 4562 : 						// If our range is less than the min range, don't consider this weapon (used range squared to save a FPU costly sqrt)
; 4563 : 						rangeSqr = diffX * diffX + diffY * diffY;

	movss	xmm0, DWORD PTR _diffX$6[ebp]
	mulss	xmm0, DWORD PTR _diffX$6[ebp]
	movss	xmm1, DWORD PTR _diffY$5[ebp]
	mulss	xmm1, DWORD PTR _diffY$5[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rangeSqr$2[ebp], xmm0

; 4564 : 						if (rangeSqr < minRange * minRange)

	movss	xmm0, DWORD PTR _minRange$4[ebp]
	mulss	xmm0, DWORD PTR _minRange$4[ebp]
	comiss	xmm0, DWORD PTR _rangeSqr$2[ebp]
	jbe	SHORT $LN4@GetVehicle

; 4565 : 							continue;

	jmp	$LN13@GetVehicle
$LN4@GetVehicle:

; 4566 : 
; 4567 : 						// If less than min altitude or more than max altitude (in this case diffZ is POSITIVE if we're below the target), don't consider this weapon
; 4568 : 						if (diffZ < minAlt || diffZ > maxAlt)

	movss	xmm0, DWORD PTR _minAlt$8[ebp]
	comiss	xmm0, DWORD PTR _diffZ$3[ebp]
	ja	SHORT $LN2@GetVehicle
	movss	xmm0, DWORD PTR _diffZ$3[ebp]
	comiss	xmm0, DWORD PTR _maxAlt$1[ebp]
	jbe	SHORT $LN3@GetVehicle
$LN2@GetVehicle:

; 4569 : 							continue;

	jmp	$LN13@GetVehicle
$LN3@GetVehicle:

; 4570 : 					}
; 4571 : 				}
; 4572 : 			}
; 4573 : 			// END OF ADDED SECTION 2002-03-08
; 4574 : 
; 4575 : 			rng = ::GetWeaponRange(wid,mt);

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wid$[ebp]
	push	ecx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	mov	DWORD PTR _rng$[ebp], eax

; 4576 : 			if (rng > br)

	mov	edx, DWORD PTR _rng$[ebp]
	cmp	edx, DWORD PTR _br$[ebp]
	jle	SHORT $LN1@GetVehicle

; 4577 : 				br = rng;

	mov	eax, DWORD PTR _rng$[ebp]
	mov	DWORD PTR _br$[ebp], eax
$LN1@GetVehicle:

; 4578 : 		}
; 4579 : 	}

	jmp	$LN13@GetVehicle
$LN12@GetVehicle:

; 4580 : 	return br;

	mov	eax, DWORD PTR _br$[ebp]
$LN16@GetVehicle:

; 4581 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetVehicleRange@UnitClass@@UAEHHHPAVFalconEntity@@@Z ENDP ; UnitClass::GetVehicleRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_vc$ = -24						; size = 4
_bs$ = -20						; size = 4
_str$ = -16						; size = 4
_wid$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_slot$ = 8						; size = 4
_mt$ = 12						; size = 4
_range$ = 16						; size = 4
?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z PROC ; UnitClass::GetVehicleCombatStrength
; _this$ = ecx

; 4499 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4500 : 	int						i,str=0,bs=0,wid;

	mov	DWORD PTR _str$[ebp], 0
	mov	DWORD PTR _bs$[ebp], 0

; 4501 : 	VehicleClassDataType*	vc;
; 4502 : 	ShiAssert(slot >= 0 && slot < VEHICLE_GROUPS_PER_UNIT);
; 4503 : 	ShiAssert(class_data != NULL);
; 4504 : 
; 4505 : 	vc = GetVehicleClassData(class_data->VehicleType[slot]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _slot$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4506 : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN7@GetVehicle

; 4507 : 		return 0;

	xor	eax, eax
	jmp	$LN8@GetVehicle
$LN7@GetVehicle:

; 4508 : 
; 4509 : 	for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@GetVehicle
$LN5@GetVehicle:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@GetVehicle:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN4@GetVehicle

; 4510 : 	{
; 4511 : 		wid = GetUnitWeaponId(i,slot);

	mov	edx, DWORD PTR _slot$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+584]
	call	eax
	mov	DWORD PTR _wid$[ebp], eax

; 4512 : 		if (wid && GetUnitWeaponCount(i,slot))

	cmp	DWORD PTR _wid$[ebp], 0
	je	SHORT $LN3@GetVehicle
	mov	ecx, DWORD PTR _slot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	call	eax
	test	eax, eax
	je	SHORT $LN3@GetVehicle

; 4513 : 		{
; 4514 : 			if (::GetWeaponRange(wid,mt) >= range)

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wid$[ebp]
	push	edx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	cmp	eax, DWORD PTR _range$[ebp]
	jl	SHORT $LN2@GetVehicle

; 4515 : 				str = GetWeaponScore(wid,mt,range);

	mov	eax, DWORD PTR _range$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wid$[ebp]
	push	edx
	call	?GetWeaponScore@@YAHHHH@Z		; GetWeaponScore
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _str$[ebp], eax
$LN2@GetVehicle:

; 4516 : 			if (str > bs)

	mov	eax, DWORD PTR _str$[ebp]
	cmp	eax, DWORD PTR _bs$[ebp]
	jle	SHORT $LN3@GetVehicle

; 4517 : 				bs = str;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	DWORD PTR _bs$[ebp], ecx
$LN3@GetVehicle:

; 4518 : 		}
; 4519 : 	}

	jmp	$LN5@GetVehicle
$LN4@GetVehicle:

; 4520 : 	return bs;

	mov	eax, DWORD PTR _bs$[ebp]
$LN8@GetVehicle:

; 4521 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetVehicleCombatStrength@UnitClass@@UAEHHW4MoveType@@H@Z ENDP ; UnitClass::GetVehicleCombatStrength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_vc$ = -24						; size = 4
_hc$ = -20						; size = 4
_wid$ = -16						; size = 4
_bc$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_slot$ = 8						; size = 4
_mt$ = 12						; size = 4
_range$ = 16						; size = 4
_hitflags$ = 20						; size = 4
?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z PROC ; UnitClass::GetVehicleHitChance
; _this$ = ecx

; 4470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4471 : 	VehicleClassDataType*	vc;
; 4472 : 	int						i,bc=0,hc=0,wid;

	mov	DWORD PTR _bc$[ebp], 0
	mov	DWORD PTR _hc$[ebp], 0

; 4473 : 
; 4474 : 	ShiAssert(slot >= 0 && slot < VEHICLE_GROUPS_PER_UNIT);
; 4475 : 	ShiAssert(class_data != NULL);
; 4476 : 	vc = GetVehicleClassData(class_data->VehicleType[slot]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _slot$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4477 : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN8@GetVehicle

; 4478 : 		return 0;

	xor	eax, eax
	jmp	$LN9@GetVehicle
$LN8@GetVehicle:

; 4479 : 
; 4480 : 	for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GetVehicle
$LN6@GetVehicle:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@GetVehicle:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN5@GetVehicle

; 4481 : 	{
; 4482 : 		wid = GetUnitWeaponId(i,slot);

	mov	edx, DWORD PTR _slot$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+584]
	call	eax
	mov	DWORD PTR _wid$[ebp], eax

; 4483 : 		if (wid && GetUnitWeaponCount(i,slot))

	cmp	DWORD PTR _wid$[ebp], 0
	je	SHORT $LN4@GetVehicle
	mov	ecx, DWORD PTR _slot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	call	eax
	test	eax, eax
	je	SHORT $LN4@GetVehicle

; 4484 : 		{
; 4485 : 			if (::GetWeaponRange(wid,mt) >= range)

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wid$[ebp]
	push	edx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	cmp	eax, DWORD PTR _range$[ebp]
	jl	SHORT $LN3@GetVehicle

; 4486 : 				hc = GetWeaponHitChance(wid,mt);

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wid$[ebp]
	push	ecx
	call	?GetWeaponHitChance@@YAHHH@Z		; GetWeaponHitChance
	add	esp, 8
	mov	DWORD PTR _hc$[ebp], eax
$LN3@GetVehicle:

; 4487 : 			if (hc > bc)

	mov	edx, DWORD PTR _hc$[ebp]
	cmp	edx, DWORD PTR _bc$[ebp]
	jle	SHORT $LN4@GetVehicle

; 4488 : 				bc = hc;

	mov	eax, DWORD PTR _hc$[ebp]
	mov	DWORD PTR _bc$[ebp], eax
$LN4@GetVehicle:

; 4489 : 		}
; 4490 : 	}

	jmp	$LN6@GetVehicle
$LN5@GetVehicle:

; 4491 : 	if (!bc)

	cmp	DWORD PTR _bc$[ebp], 0
	jne	SHORT $LN1@GetVehicle

; 4492 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN9@GetVehicle
$LN1@GetVehicle:

; 4493 : 	// Return weapon hit chance plus inherent hit chance
; 4494 : 	return bc + vc->HitChance[mt];

	mov	ecx, DWORD PTR _vc$[ebp]
	add	ecx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+66]
	add	eax, DWORD PTR _bc$[ebp]
$LN9@GetVehicle:

; 4495 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetVehicleHitChance@UnitClass@@UAEHHW4MoveType@@HH@Z ENDP ; UnitClass::GetVehicleHitChance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_ws$ = -36						; size = 4
_this$ = -32						; size = 4
_bw$ = -28						; size = 4
_bhp$ = -24						; size = 4
_str$ = -20						; size = 4
_bs$ = -16						; size = 4
_w$ = -12						; size = 4
_vc$ = -8						; size = 4
_i$ = -4						; size = 4
_slot$ = 8						; size = 4
_dam$ = 12						; size = 4
_mt$ = 16						; size = 4
_range$ = 20						; size = 4
_hp$ = 24						; size = 4
?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z PROC ; UnitClass::GetBestVehicleWeapon
; _this$ = ecx

; 4434 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 4435 : 	int			i,str,bs,w,ws,bw,bhp=-1;

	mov	DWORD PTR _bhp$[ebp], -1

; 4436 : 	VehicleClassDataType*	vc;
; 4437 : 
; 4438 : 	ShiAssert(slot >= 0 && slot < VEHICLE_GROUPS_PER_UNIT);
; 4439 : 	ShiAssert(class_data != NULL);
; 4440 : 	vc = GetVehicleClassData(class_data->VehicleType[slot]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _slot$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4441 : 
; 4442 : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN6@GetBestVeh

; 4443 : 		return 0;

	xor	eax, eax
	jmp	$LN7@GetBestVeh
$LN6@GetBestVeh:

; 4444 : 
; 4445 : 	ShiAssert(vc);
; 4446 : 
; 4447 : 	bw = bs = 0;

	mov	DWORD PTR _bs$[ebp], 0
	mov	ecx, DWORD PTR _bs$[ebp]
	mov	DWORD PTR _bw$[ebp], ecx

; 4448 : 	for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@GetBestVeh
$LN4@GetBestVeh:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@GetBestVeh:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@GetBestVeh

; 4449 : 	{
; 4450 : 		w = vc->Weapon[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+98]
	mov	DWORD PTR _w$[ebp], edx

; 4451 : 		ws = vc->Weapons[i];

	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+130]
	mov	DWORD PTR _ws$[ebp], ecx

; 4452 : 		ShiAssert (ws < 255)
; 4453 : 				if (w && ws)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN2@GetBestVeh
	cmp	DWORD PTR _ws$[ebp], 0
	je	SHORT $LN2@GetBestVeh

; 4454 : 				{
; 4455 : 					str = GetWeaponScore (w, dam, mt, range);

	mov	edx, DWORD PTR _range$[ebp]
	push	edx
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	?GetWeaponScore@@YAHHPAEHH@Z		; GetWeaponScore
	add	esp, 16					; 00000010H
	mov	DWORD PTR _str$[ebp], eax

; 4456 : 					if (str > bs)

	mov	eax, DWORD PTR _str$[ebp]
	cmp	eax, DWORD PTR _bs$[ebp]
	jle	SHORT $LN2@GetBestVeh

; 4457 : 					{
; 4458 : 						bw = w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _bw$[ebp], ecx

; 4459 : 						bs = str;

	mov	edx, DWORD PTR _str$[ebp]
	mov	DWORD PTR _bs$[ebp], edx

; 4460 : 						bhp = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bhp$[ebp], eax
$LN2@GetBestVeh:

; 4461 : 					}
; 4462 : 				}
; 4463 : 	}

	jmp	SHORT $LN4@GetBestVeh
$LN3@GetBestVeh:

; 4464 : 	*hp = bhp;

	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR _bhp$[ebp]
	mov	DWORD PTR [ecx], edx

; 4465 : 	return bw;

	mov	eax, DWORD PTR _bw$[ebp]
$LN7@GetBestVeh:

; 4466 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetBestVehicleWeapon@UnitClass@@UAEHHPAEW4MoveType@@HPAH@Z ENDP ; UnitClass::GetBestVehicleWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetRealPosition@UnitClass@@UAEXPAM00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetRealPosition@UnitClass@@UAEXPAM00@Z PROC		; UnitClass::GetRealPosition, COMDAT
; _this$ = ecx

; 347  : 	virtual void GetRealPosition (float*, float*, float*) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetRealPosition@UnitClass@@UAEXPAM00@Z ENDP		; UnitClass::GetRealPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SimSetOrientation@UnitClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSetOrientation@UnitClass@@UAEXMMM@Z PROC		; UnitClass::SimSetOrientation, COMDAT
; _this$ = ecx

; 346  : 	virtual void SimSetOrientation (float, float, float) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SimSetOrientation@UnitClass@@UAEXMMM@Z ENDP		; UnitClass::SimSetOrientation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SimSetLocation@UnitClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SimSetLocation@UnitClass@@UAEXMMM@Z PROC		; UnitClass::SimSetLocation, COMDAT
; _this$ = ecx

; 344  : 	virtual void SimSetLocation (float x, float y, float z)	{ SetPosition(x,y,z); MakeCampBaseDirty (DIRTY_POSITION, DDP[182].priority); MakeCampBaseDirty (DIRTY_ALTITUDE, DDP[183].priority); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
	mov	eax, 4
	imul	eax, 182				; 000000b6H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty
	mov	eax, 4
	imul	eax, 183				; 000000b7H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SimSetLocation@UnitClass@@UAEXMMM@Z ENDP		; UnitClass::SimSetLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SetUnitAltitude@UnitClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_alt$ = 8						; size = 4
?SetUnitAltitude@UnitClass@@QAEXH@Z PROC		; UnitClass::SetUnitAltitude, COMDAT
; _this$ = ecx

; 341  : 	void SetUnitAltitude (int alt)					{ SetPosition(XPos(),YPos(),-1.0F * (float)alt); MakeCampBaseDirty (DIRTY_ALTITUDE, DDP[181].priority); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cvtsi2ss xmm0, DWORD PTR _alt$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
	mov	eax, 4
	imul	eax, 181				; 000000b5H
	mov	ecx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeCampBaseDirty@CampBaseClass@@QAEXW4Dirty_Campaign_Base@@W4Dirtyness@@@Z ; CampBaseClass::MakeCampBaseDirty
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitAltitude@UnitClass@@QAEXH@Z ENDP		; UnitClass::SetUnitAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitClassName@UnitClass@@QAEPADXZ PROC		; UnitClass::GetUnitClassName
; _this$ = ecx

; 3988 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3989 : 	if (class_data)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+236], 0
	je	SHORT $LN2@GetUnitCla

; 3990 : 		return class_data->Name;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+236]
	add	eax, 230				; 000000e6H
	jmp	SHORT $LN3@GetUnitCla

; 3991 : 	else

	jmp	SHORT $LN3@GetUnitCla
$LN2@GetUnitCla:

; 3992 : 		return "Nothing";

	mov	eax, OFFSET ??_C@_07MMBOBMNN@Nothing?$AA@
$LN3@GetUnitCla:

; 3993 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitClassName@UnitClass@@QAEPADXZ ENDP		; UnitClass::GetUnitClassName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ PROC ; UnitClass::GetUnitClassData
; _this$ = ecx

; 3983 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3984 : 	return class_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+236]

; 3985 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ENDP ; UnitClass::GetUnitClassData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Inactive@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Inactive@UnitClass@@QBEHXZ PROC			; UnitClass::Inactive, COMDAT
; _this$ = ecx

; 323  : 	int Inactive () const								{ return (int)unit_flags & U_INACTIVE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 131072				; 00020000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Inactive@UnitClass@@QBEHXZ ENDP			; UnitClass::Inactive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Broken@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Broken@UnitClass@@QBEHXZ PROC				; UnitClass::Broken, COMDAT
; _this$ = ecx

; 320  : 	int Broken () const								{ return (int)unit_flags & U_BROKEN; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32768				; 00008000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Broken@UnitClass@@QBEHXZ ENDP				; UnitClass::Broken
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Cargo@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cargo@UnitClass@@QBEHXZ PROC				; UnitClass::Cargo, COMDAT
; _this$ = ecx

; 318  : 	int Cargo () const								{ return (int)unit_flags & U_CARGO; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 8192				; 00002000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Cargo@UnitClass@@QBEHXZ ENDP				; UnitClass::Cargo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Moving@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Moving@UnitClass@@QBEHXZ PROC				; UnitClass::Moving, COMDAT
; _this$ = ecx

; 316  : 	int Moving() const								{ return (int)unit_flags & U_MOVING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1024				; 00000400H
	mov	esp, ebp
	pop	ebp
	ret	0
?Moving@UnitClass@@QBEHXZ ENDP				; UnitClass::Moving
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Parent@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Parent@UnitClass@@QBEHXZ PROC				; UnitClass::Parent, COMDAT
; _this$ = ecx

; 312  : 	int Parent() const								{ return (int)unit_flags & U_PARENT; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32					; 00000020H
	mov	esp, ebp
	pop	ebp
	ret	0
?Parent@UnitClass@@QBEHXZ ENDP				; UnitClass::Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IsDead@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@UnitClass@@UBEHXZ PROC				; UnitClass::IsDead, COMDAT
; _this$ = ecx

; 307  : 	virtual int IsDead() const						{ return (int)unit_flags & U_DEAD; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@UnitClass@@UBEHXZ ENDP				; UnitClass::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?SetNoAbort@UnitClass@@QAEXH@Z PROC			; UnitClass::SetNoAbort
; _this$ = ecx

; 2823 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2824 : 	unit_flags |= U_NO_ABORT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 67108864				; 04000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2825 : 	if (!i){

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN1@SetNoAbort

; 2826 : 		unit_flags ^= U_NO_ABORT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 67108864				; 04000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN1@SetNoAbort:

; 2827 : 	}
; 2828 : 	//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[74].priority);
; 2829 : 	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 2830 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetNoAbort@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetNoAbort
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?SetIAKill@UnitClass@@QAEXH@Z PROC			; UnitClass::SetIAKill
; _this$ = ecx

; 2815 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2816 : 	unit_flags |= U_IA_KILL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 33554432				; 02000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2817 : 	if (!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN2@SetIAKill

; 2818 : 		unit_flags ^= U_IA_KILL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 33554432				; 02000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetIAKill:

; 2819 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2820 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetIAKill@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetIAKill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
?SetLocked@UnitClass@@QAEXH@Z PROC			; UnitClass::SetLocked
; _this$ = ecx

; 2793 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2794 : 	if (l)

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $LN4@SetLocked

; 2795 : 	{
; 2796 : 		if (!(unit_flags & U_LOCKED))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 16777216				; 01000000H
	jne	SHORT $LN3@SetLocked

; 2797 : 		{
; 2798 : 			unit_flags |= U_LOCKED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2799 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[72].priority);
; 2800 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetLocked:

; 2801 : 		}
; 2802 : 	}
; 2803 : 	else

	jmp	SHORT $LN5@SetLocked
$LN4@SetLocked:

; 2804 : 	{
; 2805 : 		if (unit_flags & U_LOCKED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN5@SetLocked

; 2806 : 		{
; 2807 : 			unit_flags &= ~U_LOCKED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -16777217				; feffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2808 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[73].priority);
; 2809 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetLocked:

; 2810 : 		}
; 2811 : 	}
; 2812 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLocked@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetLocked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_d$ = 8							; size = 4
?SetFired@UnitClass@@QAEXH@Z PROC			; UnitClass::SetFired
; _this$ = ecx

; 2771 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2772 : 	if (d)

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $LN4@SetFired

; 2773 : 	{
; 2774 : 		if (!(unit_flags & U_FIRED))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 8388608				; 00800000H
	jne	SHORT $LN3@SetFired

; 2775 : 		{
; 2776 : 			unit_flags |= U_FIRED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 8388608				; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2777 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[70].priority);
; 2778 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetFired:

; 2779 : 		}
; 2780 : 	}
; 2781 : 	else

	jmp	SHORT $LN5@SetFired
$LN4@SetFired:

; 2782 : 	{
; 2783 : 		if (unit_flags & U_FIRED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 8388608				; 00800000H
	je	SHORT $LN5@SetFired

; 2784 : 		{
; 2785 : 			unit_flags &= ~U_FIRED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -8388609				; ff7fffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2786 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[71].priority);
; 2787 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetFired:

; 2788 : 		}
; 2789 : 	}
; 2790 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFired@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetFired
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_d$ = 8							; size = 4
?SetDiverted@UnitClass@@QAEXH@Z PROC			; UnitClass::SetDiverted
; _this$ = ecx

; 2749 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2750 : 	if (d)

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $LN4@SetDiverte

; 2751 : 	{
; 2752 : 		if (!(unit_flags & U_DIVERTED))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 4194304				; 00400000H
	jne	SHORT $LN3@SetDiverte

; 2753 : 		{
; 2754 : 			unit_flags |= U_DIVERTED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2755 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[68].priority);
; 2756 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetDiverte:

; 2757 : 		}
; 2758 : 	}
; 2759 : 	else

	jmp	SHORT $LN5@SetDiverte
$LN4@SetDiverte:

; 2760 : 	{
; 2761 : 		if (unit_flags & U_DIVERTED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 4194304				; 00400000H
	je	SHORT $LN5@SetDiverte

; 2762 : 		{
; 2763 : 			unit_flags &= ~U_DIVERTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2764 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[69].priority);
; 2765 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetDiverte:

; 2766 : 		}
; 2767 : 	}
; 2768 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDiverted@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetDiverted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetPilots@UnitClass@@QAEXH@Z PROC			; UnitClass::SetPilots
; _this$ = ecx

; 2727 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2728 : 	if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetPilots

; 2729 : 	{
; 2730 : 		if (!(unit_flags & U_HAS_PILOTS))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 2097152				; 00200000H
	jne	SHORT $LN3@SetPilots

; 2731 : 		{
; 2732 : 			unit_flags |= U_HAS_PILOTS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 2097152				; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2733 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[66].priority);
; 2734 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetPilots:

; 2735 : 		}
; 2736 : 	}
; 2737 : 	else

	jmp	SHORT $LN5@SetPilots
$LN4@SetPilots:

; 2738 : 	{
; 2739 : 		if (unit_flags & U_HAS_PILOTS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 2097152				; 00200000H
	je	SHORT $LN5@SetPilots

; 2740 : 		{
; 2741 : 			unit_flags &= ~U_HAS_PILOTS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -2097153				; ffdfffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2742 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[67].priority);
; 2743 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetPilots:

; 2744 : 		}
; 2745 : 	}
; 2746 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPilots@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetPilots
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetFinal@UnitClass@@QAEXH@Z PROC			; UnitClass::SetFinal
; _this$ = ecx

; 2711 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2712 : 	if (p && !(unit_flags & U_FINAL))

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@SetFinal
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 1048576				; 00100000H
	jne	SHORT $LN3@SetFinal

; 2713 : 	{
; 2714 : 		unit_flags |= U_FINAL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 1048576				; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2715 : 		//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[64].priority);
; 2716 : 		MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_NOW);

	push	65536					; 00010000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
	jmp	SHORT $LN4@SetFinal
$LN3@SetFinal:

; 2717 : 	}
; 2718 : 	else if (!p && (unit_flags & U_FINAL))

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN4@SetFinal
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 1048576				; 00100000H
	je	SHORT $LN4@SetFinal

; 2719 : 	{
; 2720 : 		unit_flags ^= U_FINAL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	xor	edx, 1048576				; 00100000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2721 : 		//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[65].priority);
; 2722 : 		MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_NOW);

	push	65536					; 00010000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN4@SetFinal:

; 2723 : 	}
; 2724 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFinal@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetFinal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetTempDest@UnitClass@@QAEXH@Z PROC			; UnitClass::SetTempDest
; _this$ = ecx

; 2703 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2704 : 	unit_flags |= U_TEMP_DEST;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 16777216				; 01000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2705 : 	if (!t)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@SetTempDes

; 2706 : 		unit_flags ^= U_TEMP_DEST;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 16777216				; 01000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetTempDes:

; 2707 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2708 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTempDest@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetTempDest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?SetSupported@UnitClass@@QAEXH@Z PROC			; UnitClass::SetSupported
; _this$ = ecx

; 2695 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2696 : 	unit_flags |= U_SUPPORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2697 : 	if (!s)

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN2@SetSupport

; 2698 : 		unit_flags ^= U_SUPPORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetSupport:

; 2699 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2700 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSupported@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetSupported
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetDetached@UnitClass@@QAEXH@Z PROC			; UnitClass::SetDetached
; _this$ = ecx

; 2673 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2674 : 	if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetDetache

; 2675 : 	{
; 2676 : 		if (!(unit_flags & U_DETACHED))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 4194304				; 00400000H
	jne	SHORT $LN3@SetDetache

; 2677 : 		{
; 2678 : 			unit_flags |= U_DETACHED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2679 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[62].priority);
; 2680 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetDetache:

; 2681 : 		}
; 2682 : 	}
; 2683 : 	else

	jmp	SHORT $LN5@SetDetache
$LN4@SetDetache:

; 2684 : 	{
; 2685 : 		if (unit_flags & U_DETACHED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 4194304				; 00400000H
	je	SHORT $LN5@SetDetache

; 2686 : 		{
; 2687 : 			unit_flags &= ~U_DETACHED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2688 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[63].priority);
; 2689 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetDetache:

; 2690 : 		}
; 2691 : 	}
; 2692 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDetached@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetDetached
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetRetreating@UnitClass@@QAEXH@Z PROC			; UnitClass::SetRetreating
; _this$ = ecx

; 2657 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2658 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetRetreat

; 2659 : 		if (!(unit_flags & U_RETREATING)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 2097152				; 00200000H
	jne	SHORT $LN3@SetRetreat

; 2660 : 			unit_flags |= U_RETREATING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 2097152				; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2661 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetRetreat:

; 2662 : 		}
; 2663 : 	}
; 2664 : 	else{

	jmp	SHORT $LN5@SetRetreat
$LN4@SetRetreat:

; 2665 : 		if (unit_flags & U_RETREATING){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 2097152				; 00200000H
	je	SHORT $LN5@SetRetreat

; 2666 : 			unit_flags &= ~U_RETREATING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -2097153				; ffdfffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2667 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetRetreat:

; 2668 : 		}
; 2669 : 	}
; 2670 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRetreating@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetRetreating
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetTargeted@UnitClass@@QAEXH@Z PROC			; UnitClass::SetTargeted
; _this$ = ecx

; 2649 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2650 : 	unit_flags |= U_TARGETED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 1048576				; 00100000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2651 : 	if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@SetTargete

; 2652 : 		unit_flags ^= U_TARGETED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 1048576				; 00100000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetTargete:

; 2653 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2654 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTargeted@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetTargeted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?SetFragment@UnitClass@@QAEXH@Z PROC			; UnitClass::SetFragment
; _this$ = ecx

; 2631 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2632 : 	if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN4@SetFragmen

; 2633 : 	{
; 2634 : 		if (!(unit_flags & U_FRAGMENTED)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 262144				; 00040000H
	jne	SHORT $LN3@SetFragmen

; 2635 : 			unit_flags |= U_FRAGMENTED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2636 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetFragmen:

; 2637 : 		}
; 2638 : 	}
; 2639 : 	else

	jmp	SHORT $LN5@SetFragmen
$LN4@SetFragmen:

; 2640 : 	{
; 2641 : 		if (unit_flags & U_FRAGMENTED){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 262144				; 00040000H
	je	SHORT $LN5@SetFragmen

; 2642 : 			unit_flags &= ~U_FRAGMENTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -262145				; fffbffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2643 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetFragmen:

; 2644 : 		}
; 2645 : 	}
; 2646 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFragment@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetFragment
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?SetInactive@UnitClass@@QAEXH@Z PROC			; UnitClass::SetInactive
; _this$ = ecx

; 2594 : void UnitClass::SetInactive(int f){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2595 : 	if (f){

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN5@SetInactiv

; 2596 : 		if (!(unit_flags & U_INACTIVE)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 131072				; 00020000H
	jne	SHORT $LN4@SetInactiv

; 2597 : 			// inactivate: list handling will be done when its detected scanning the list
; 2598 : 
; 2599 : 			/*AllUnitList->Remove(this);
; 2600 : 			AllParentList->Remove(this);
; 2601 : 			AllRealList->Remove(this);
; 2602 : 			RealUnitProxList->Remove(this);
; 2603 : 
; 2604 : 			InactiveList->Insert(this);*/
; 2605 : 
; 2606 : 			unit_flags |= U_INACTIVE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2607 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN4@SetInactiv:

; 2608 : 		}
; 2609 : 	}
; 2610 : 	else {

	jmp	$LN6@SetInactiv
$LN5@SetInactiv:

; 2611 : 		if (unit_flags & U_INACTIVE){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 131072				; 00020000H
	je	$LN6@SetInactiv

; 2612 : 			// activate: have to find a place for list handlings here
; 2613 : 
; 2614 : 			ClearDeaggregationData();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	call	eax

; 2615 : 			unit_flags &= ~U_INACTIVE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2616 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 2617 : 
; 2618 : 			InactiveList->Remove(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?InactiveList@@3PAVVuLinkedList@@A ; InactiveList
	call	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Remove

; 2619 : 			
; 2620 : 			AllUnitList->Insert(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	call	?Insert@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Insert

; 2621 : 			AllParentList->Insert(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AllParentList@@3PAVVuLinkedList@@A ; AllParentList
	call	?Insert@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Insert

; 2622 : 			if (Real()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	je	SHORT $LN6@SetInactiv

; 2623 : 				AllRealList->Insert(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AllRealList@@3PAVVuLinkedList@@A ; AllRealList
	call	?Insert@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Insert

; 2624 : 				RealUnitProxList->Insert(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	call	?Insert@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Insert
$LN6@SetInactiv:

; 2625 : 			}
; 2626 : 		}
; 2627 : 	}
; 2628 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetInactive@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetInactive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetLosses@UnitClass@@QAEXH@Z PROC			; UnitClass::SetLosses
; _this$ = ecx

; 2587 : void UnitClass::SetLosses (int p){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 	unit_flags |= U_LOSSES;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2589 : 	if (!p)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@SetLosses

; 2590 : 		unit_flags ^= U_LOSSES;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetLosses:

; 2591 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2592 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLosses@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetLosses
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetAborted@UnitClass@@QAEXH@Z PROC			; UnitClass::SetAborted
; _this$ = ecx

; 2571 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2572 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetAborted

; 2573 : 		if (!(unit_flags & U_BROKEN)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 32768				; 00008000H
	jne	SHORT $LN3@SetAborted

; 2574 : 			unit_flags |= U_BROKEN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2575 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetAborted:

; 2576 : 		}
; 2577 : 	}
; 2578 : 	else

	jmp	SHORT $LN5@SetAborted
$LN4@SetAborted:

; 2579 : 	{
; 2580 : 		if (unit_flags & U_BROKEN){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 32768				; 00008000H
	je	SHORT $LN5@SetAborted

; 2581 : 			unit_flags ^= U_BROKEN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	xor	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2582 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetAborted:

; 2583 : 		}
; 2584 : 	}
; 2585 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetAborted@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetAborted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -68						; size = 8
$T3 = -60						; size = 8
$T4 = -52						; size = 8
$T5 = -44						; size = 8
$T6 = -36						; size = 4
tv144 = -32						; size = 4
$T7 = -28						; size = 4
tv133 = -24						; size = 4
_newEvent$8 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
?SetBroken@UnitClass@@QAEXH@Z PROC			; UnitClass::SetBroken
; _this$ = ecx

; 2508 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetBroken@UnitClass@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2509 : 	// If we just broke, send a CampUI 'withdrawing/aborted' message to everyone here
; 2510 : 	if (!(unit_flags & U_BROKEN) && p && Real() && !IsDead())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 32768				; 00008000H
	jne	$LN16@SetBroken
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN16@SetBroken
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+508]
	call	edx
	test	eax, eax
	je	$LN16@SetBroken
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	$LN16@SetBroken

; 2511 : 	{
; 2512 : 		FalconCampEventMessage	*newEvent = new FalconCampEventMessage(Id(), FalconLocalGame);

	push	100					; 00000064H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN21@SetBroken
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@SetBroken
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN20@SetBroken
$LN19@SetBroken:
	mov	DWORD PTR tv133[ebp], 0
$LN20@SetBroken:
	push	1
	mov	edx, DWORD PTR tv133[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconCampEventMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconCampEventMessage::FalconCampEventMessage
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN22@SetBroken
$LN21@SetBroken:
	mov	DWORD PTR tv144[ebp], 0
$LN22@SetBroken:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _newEvent$8[ebp], ecx

; 2513 : 
; 2514 : 		newEvent->dataBlock.team = GetTeam();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	BYTE PTR [ecx+53], al

; 2515 : 		newEvent->dataBlock.eventType = FalconCampEventMessage::unitWithdrawing;

	mov	edx, DWORD PTR _newEvent$8[ebp]
	mov	DWORD PTR [edx+48], 5

; 2516 : 		GetLocation(&newEvent->dataBlock.data.xLoc,&newEvent->dataBlock.data.yLoc);

	mov	eax, DWORD PTR _newEvent$8[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	add	ecx, 58					; 0000003aH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2517 : 		newEvent->dataBlock.data.owners[0] = GetOwner();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	dx, al
	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [ecx+eax+80], dx

; 2518 : 		if (GetDomain() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 2
	jne	SHORT $LN15@SetBroken

; 2519 : 		{
; 2520 : 			newEvent->dataBlock.data.formatId = 1812;

	mov	eax, 1812				; 00000714H
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [ecx+56], ax

; 2521 : 			newEvent->dataBlock.data.textIds[0] = -1 * GetVehicleID(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	edx, ax
	imul	edx, -1
	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [ecx+eax+84], dx
	jmp	$LN14@SetBroken
$LN15@SetBroken:

; 2522 : 		}
; 2523 : 		else if (GetDomain() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 4
	jne	SHORT $LN13@SetBroken

; 2524 : 		{
; 2525 : 			newEvent->dataBlock.data.formatId = 1811;

	mov	eax, 1811				; 00000713H
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [ecx+56], ax

; 2526 : 		}
; 2527 : 		else

	jmp	$LN14@SetBroken
$LN13@SetBroken:

; 2528 : 		{
; 2529 : 			newEvent->dataBlock.data.vuIds[0] = Id();

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, 8
	imul	eax, 0
	mov	esi, DWORD PTR _newEvent$8[ebp]
	mov	DWORD PTR [esi+eax+64], ecx
	mov	DWORD PTR [esi+eax+68], edx

; 2530 : 			if (GetType() == TYPE_BATTALION)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 1
	jne	$LN11@SetBroken

; 2531 : 			{
; 2532 : 				if (GetUnitCurrentRole() == GRO_ATTACK)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+672]
	call	edx
	cmp	eax, 1
	jne	SHORT $LN10@SetBroken

; 2533 : 				{
; 2534 : 					newEvent->dataBlock.data.formatId = 1813;

	mov	eax, 1813				; 00000715H
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [ecx+56], ax

; 2535 : 				}
; 2536 : 				else

	jmp	SHORT $LN9@SetBroken
$LN10@SetBroken:

; 2537 : 				{
; 2538 : 					newEvent->dataBlock.data.formatId = 1810;

	mov	edx, 1810				; 00000712H
	mov	eax, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [eax+56], dx
$LN9@SetBroken:

; 2539 : 				}
; 2540 : 				if (GetUnitParentID() != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+948]
	call	edx
	mov	ecx, eax
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@SetBroken

; 2541 : 				{
; 2542 : 					newEvent->dataBlock.data.vuIds[0] = GetUnitParentID();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+948]
	call	edx
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, 8
	imul	eax, 0
	mov	esi, DWORD PTR _newEvent$8[ebp]
	mov	DWORD PTR [esi+eax+64], ecx
	mov	DWORD PTR [esi+eax+68], edx
$LN8@SetBroken:

; 2543 : 				}
; 2544 : 			}
; 2545 : 			else

	jmp	SHORT $LN14@SetBroken
$LN11@SetBroken:

; 2546 : 			{
; 2547 : 				if (GetUnitCurrentRole() == GRO_ATTACK)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN6@SetBroken

; 2548 : 					newEvent->dataBlock.data.formatId = 1815;

	mov	ecx, 1815				; 00000717H
	mov	edx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [edx+56], cx

; 2549 : 				else

	jmp	SHORT $LN14@SetBroken
$LN6@SetBroken:

; 2550 : 					newEvent->dataBlock.data.formatId = 1814;

	mov	eax, 1814				; 00000716H
	mov	ecx, DWORD PTR _newEvent$8[ebp]
	mov	WORD PTR [ecx+56], ax
$LN14@SetBroken:

; 2551 : 			}
; 2552 : 		}
; 2553 : 		SendCampUIMessage(newEvent);

	mov	edx, DWORD PTR _newEvent$8[ebp]
	push	edx
	call	?SendCampUIMessage@@YAXPAVFalconCampEventMessage@@@Z ; SendCampUIMessage
	add	esp, 4
$LN16@SetBroken:

; 2554 : 	}
; 2555 : 	// Now set the flag
; 2556 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetBroken

; 2557 : 		if (!(unit_flags & U_BROKEN)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 32768				; 00008000H
	jne	SHORT $LN3@SetBroken

; 2558 : 			unit_flags |= U_BROKEN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2559 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetBroken:

; 2560 : 		}
; 2561 : 	}
; 2562 : 	else {

	jmp	SHORT $LN17@SetBroken
$LN4@SetBroken:

; 2563 : 		if (unit_flags & U_BROKEN){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 32768				; 00008000H
	je	SHORT $LN17@SetBroken

; 2564 : 			unit_flags ^= U_BROKEN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	xor	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2565 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN17@SetBroken:

; 2566 : 		}
; 2567 : 	}
; 2568 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetBroken@UnitClass@@QAEXH@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetBroken@UnitClass@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetBroken@UnitClass@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBroken@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetBroken
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetCombat@UnitClass@@QAEXH@Z PROC			; UnitClass::SetCombat
; _this$ = ecx

; 2492 : void UnitClass::SetCombat (int p){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2493 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetCombat

; 2494 : 		if (!(unit_flags & U_COMBAT)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 16384				; 00004000H
	jne	SHORT $LN3@SetCombat

; 2495 : 			unit_flags |= U_COMBAT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 16384				; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2496 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetCombat:

; 2497 : 		}
; 2498 : 	}
; 2499 : 	else {

	jmp	SHORT $LN5@SetCombat
$LN4@SetCombat:

; 2500 : 		if (unit_flags & U_COMBAT){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 16384				; 00004000H
	je	SHORT $LN5@SetCombat

; 2501 : 			unit_flags &= ~U_COMBAT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -16385				; ffffbfffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2502 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetCombat:

; 2503 : 		}
; 2504 : 	}
; 2505 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCombat@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetCombat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c$ = 8							; size = 4
?SetCargo@UnitClass@@QAEXH@Z PROC			; UnitClass::SetCargo
; _this$ = ecx

; 2477 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2478 : 	if (c) {

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN4@SetCargo

; 2479 : 		if (!(unit_flags & U_CARGO)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 8192				; 00002000H
	jne	SHORT $LN3@SetCargo

; 2480 : 			unit_flags |= U_CARGO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2481 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetCargo:

; 2482 : 		}
; 2483 : 	}
; 2484 : 	else {

	jmp	SHORT $LN5@SetCargo
$LN4@SetCargo:

; 2485 : 		if (unit_flags & U_CARGO){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 8192				; 00002000H
	je	SHORT $LN5@SetCargo

; 2486 : 			unit_flags ^= U_CARGO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	xor	edx, 8192				; 00002000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2487 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetCargo:

; 2488 : 		}
; 2489 : 	}
; 2490 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCargo@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetCargo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
?SetHasECM@UnitClass@@QAEXH@Z PROC			; UnitClass::SetHasECM
; _this$ = ecx

; 2461 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2462 : 	if (e){

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN4@SetHasECM

; 2463 : 		if (!(unit_flags & U_HASECM)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN3@SetHasECM

; 2464 : 			unit_flags |= U_HASECM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2465 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetHasECM:

; 2466 : 		}
; 2467 : 	}
; 2468 : 	else {

	jmp	SHORT $LN5@SetHasECM
$LN4@SetHasECM:

; 2469 : 		if (unit_flags & U_HASECM) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 4096				; 00001000H
	je	SHORT $LN5@SetHasECM

; 2470 : 			unit_flags &= ~U_HASECM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -4097				; ffffefffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2471 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetHasECM:

; 2472 : 		}
; 2473 : 	}
; 2474 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHasECM@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetHasECM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 4
?SetRefused@UnitClass@@QAEXH@Z PROC			; UnitClass::SetRefused
; _this$ = ecx

; 2453 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2454 : 	unit_flags |= U_REFUSED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2455 : 	if (!r)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $LN2@SetRefused

; 2456 : 		unit_flags ^= U_REFUSED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetRefused:

; 2457 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2458 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRefused@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetRefused
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetMoving@UnitClass@@QAEXH@Z PROC			; UnitClass::SetMoving
; _this$ = ecx

; 2437 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2438 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetMoving

; 2439 : 		if (!(unit_flags & U_MOVING)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 1024				; 00000400H
	jne	SHORT $LN3@SetMoving

; 2440 : 			unit_flags |= U_MOVING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2441 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetMoving:

; 2442 : 		}
; 2443 : 	}
; 2444 : 	else{

	jmp	SHORT $LN5@SetMoving
$LN4@SetMoving:

; 2445 : 		if (unit_flags & U_MOVING){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 1024				; 00000400H
	je	SHORT $LN5@SetMoving

; 2446 : 			unit_flags &= ~U_MOVING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -1025				; fffffbffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2447 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetMoving:

; 2448 : 		}
; 2449 : 	}
; 2450 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoving@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetMoving
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c$ = 8							; size = 4
?SetCommando@UnitClass@@QAEXH@Z PROC			; UnitClass::SetCommando
; _this$ = ecx

; 2428 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2429 : 	unit_flags |= U_COMMANDO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2430 : 	if (!c){

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN2@SetCommand

; 2431 : 		unit_flags ^= U_COMMANDO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetCommand:

; 2432 : 	}
; 2433 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2434 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCommando@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetCommando
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetScripted@UnitClass@@QAEXH@Z PROC			; UnitClass::SetScripted
; _this$ = ecx

; 2419 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2420 : 	unit_flags |= U_SCRIPTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2421 : 	if (!p){

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@SetScripte

; 2422 : 		unit_flags ^= U_SCRIPTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	xor	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN2@SetScripte:

; 2423 : 	}
; 2424 : 	//	MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);
; 2425 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetScripted@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetScripted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetEngaged@UnitClass@@QAEXH@Z PROC			; UnitClass::SetEngaged
; _this$ = ecx

; 2403 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2404 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetEngaged

; 2405 : 		if (!(unit_flags & U_ENGAGED)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN3@SetEngaged

; 2406 : 			unit_flags |= U_ENGAGED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2407 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetEngaged:

; 2408 : 		}
; 2409 : 	}
; 2410 : 	else {

	jmp	SHORT $LN5@SetEngaged
$LN4@SetEngaged:

; 2411 : 		if ((unit_flags & U_ENGAGED)){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 64					; 00000040H
	je	SHORT $LN5@SetEngaged

; 2412 : 			unit_flags &= ~U_ENGAGED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2413 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetEngaged:

; 2414 : 		}
; 2415 : 	}
; 2416 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetEngaged@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetEngaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetParent@UnitClass@@QAEXH@Z PROC			; UnitClass::SetParent
; _this$ = ecx

; 2387 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2388 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetParent

; 2389 : 		if (!(unit_flags & U_PARENT)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 32					; 00000020H
	jne	SHORT $LN3@SetParent

; 2390 : 			unit_flags |= U_PARENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2391 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetParent:

; 2392 : 		}
; 2393 : 	}
; 2394 : 	else {

	jmp	SHORT $LN5@SetParent
$LN4@SetParent:

; 2395 : 		if (unit_flags & U_PARENT){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 32					; 00000020H
	je	SHORT $LN5@SetParent

; 2396 : 			unit_flags &= ~U_PARENT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2397 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetParent:

; 2398 : 		}
; 2399 : 	}
; 2400 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetParent@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetDontPlan@UnitClass@@QAEXH@Z PROC			; UnitClass::SetDontPlan
; _this$ = ecx

; 2369 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2370 : 	if (p){

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@SetDontPla

; 2371 : 		if (!(unit_flags & U_NO_PLANNING)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN3@SetDontPla

; 2372 : 			unit_flags |= U_NO_PLANNING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2373 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[38].priority);
; 2374 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetDontPla:

; 2375 : 		}
; 2376 : 	}
; 2377 : 	else {

	jmp	SHORT $LN5@SetDontPla
$LN4@SetDontPla:

; 2378 : 		if (unit_flags & U_NO_PLANNING){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 16					; 00000010H
	je	SHORT $LN5@SetDontPla

; 2379 : 			unit_flags &= ~U_NO_PLANNING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2380 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[39].priority);
; 2381 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN5@SetDontPla:

; 2382 : 		}
; 2383 : 	}
; 2384 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDontPlan@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetDontPlan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetOrdered@UnitClass@@QAEXH@Z PROC			; UnitClass::SetOrdered
; _this$ = ecx

; 2361 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2362 : 	if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN2@SetOrdered

; 2363 : 		unit_flags |= U_ORDERED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2364 : 	else

	jmp	SHORT $LN3@SetOrdered
$LN2@SetOrdered:

; 2365 : 		unit_flags &= ~U_ORDERED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN3@SetOrdered:

; 2366 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetOrdered@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetOrdered
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetAssigned@UnitClass@@QAEXH@Z PROC			; UnitClass::SetAssigned
; _this$ = ecx

; 2353 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2354 : 	if (p)

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN2@SetAssigne

; 2355 : 		unit_flags |= U_ASSIGNED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx

; 2356 : 	else

	jmp	SHORT $LN3@SetAssigne
$LN2@SetAssigne:

; 2357 : 		unit_flags &= ~U_ASSIGNED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], ecx
$LN3@SetAssigne:

; 2358 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetAssigned@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetAssigned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 8
$T3 = -52						; size = 8
$T4 = -44						; size = 8
$T5 = -36						; size = 4
tv154 = -32						; size = 4
$T6 = -28						; size = 4
tv143 = -24						; size = 4
_newEvent$7 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_d$ = 8							; size = 4
?SetDead@UnitClass@@QAEXH@Z PROC			; UnitClass::SetDead
; _this$ = ecx

; 2310 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetDead@UnitClass@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2311 : 	// Start the death timeout clock
; 2312 : 	SetLastCheck(TheCampaign.CurrentTime);

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck

; 2313 : 	// If we just died, send a CampUI 'destroyed' message to everyone here
; 2314 : 	if (!(unit_flags & U_DEAD) && d && (IsBattalion() || IsTaskForce()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, 1
	jne	$LN8@SetDead
	cmp	DWORD PTR _d$[ebp], 0
	je	$LN8@SetDead
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN7@SetDead
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	$LN8@SetDead
$LN7@SetDead:

; 2315 : 	{
; 2316 : 		FalconCampEventMessage	*newEvent = new FalconCampEventMessage(Id(),FalconLocalGame);

	push	100					; 00000064H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN13@SetDead
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@SetDead
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN12@SetDead
$LN11@SetDead:
	mov	DWORD PTR tv143[ebp], 0
$LN12@SetDead:
	push	1
	mov	edx, DWORD PTR tv143[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0FalconCampEventMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconCampEventMessage::FalconCampEventMessage
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $LN14@SetDead
$LN13@SetDead:
	mov	DWORD PTR tv154[ebp], 0
$LN14@SetDead:
	mov	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _newEvent$7[ebp], ecx

; 2317 : 
; 2318 : 		newEvent->dataBlock.team = GetEnemyTeam(GetTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	mov	ecx, DWORD PTR _newEvent$7[ebp]
	mov	BYTE PTR [ecx+53], al

; 2319 : 		newEvent->dataBlock.eventType = FalconCampEventMessage::unitDestroyed;

	mov	edx, DWORD PTR _newEvent$7[ebp]
	mov	DWORD PTR [edx+48], 6

; 2320 : 		GetLocation(&newEvent->dataBlock.data.xLoc,&newEvent->dataBlock.data.yLoc);

	mov	eax, DWORD PTR _newEvent$7[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _newEvent$7[ebp]
	add	ecx, 58					; 0000003aH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2321 : 		newEvent->dataBlock.data.owners[0] = GetOwner();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	dx, al
	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _newEvent$7[ebp]
	mov	WORD PTR [ecx+eax+80], dx

; 2322 : 		if (IsBattalion())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	je	SHORT $LN6@SetDead

; 2323 : 		{
; 2324 : 			newEvent->dataBlock.data.formatId = 1820;

	mov	eax, 1820				; 0000071cH
	mov	ecx, DWORD PTR _newEvent$7[ebp]
	mov	WORD PTR [ecx+56], ax

; 2325 : 			newEvent->dataBlock.data.vuIds[0] = Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, 8
	imul	eax, 0
	mov	esi, DWORD PTR _newEvent$7[ebp]
	mov	DWORD PTR [esi+eax+64], ecx
	mov	DWORD PTR [esi+eax+68], edx

; 2326 : 			SendCampUIMessage(newEvent);

	mov	ecx, DWORD PTR _newEvent$7[ebp]
	push	ecx
	call	?SendCampUIMessage@@YAXPAVFalconCampEventMessage@@@Z ; SendCampUIMessage
	add	esp, 4

; 2327 : 		}
; 2328 : 		else

	jmp	SHORT $LN8@SetDead
$LN6@SetDead:

; 2329 : 		{
; 2330 : 			newEvent->dataBlock.data.formatId = 1822;

	mov	edx, 1822				; 0000071eH
	mov	eax, DWORD PTR _newEvent$7[ebp]
	mov	WORD PTR [eax+56], dx

; 2331 : 			newEvent->dataBlock.data.vuIds[0] = Id();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, 8
	imul	ecx, 0
	mov	esi, DWORD PTR _newEvent$7[ebp]
	mov	DWORD PTR [esi+ecx+64], edx
	mov	DWORD PTR [esi+ecx+68], eax

; 2332 : 			SendCampUIMessage(newEvent);

	mov	edx, DWORD PTR _newEvent$7[ebp]
	push	edx
	call	?SendCampUIMessage@@YAXPAVFalconCampEventMessage@@@Z ; SendCampUIMessage
	add	esp, 4
$LN8@SetDead:

; 2333 : 		}
; 2334 : 	}
; 2335 : 	// Set the flags
; 2336 : 	if (d) {

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $LN4@SetDead

; 2337 : 		if (!(unit_flags & U_DEAD)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	and	ecx, 1
	jne	SHORT $LN3@SetDead

; 2338 : 			unit_flags |= U_DEAD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	or	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], eax

; 2339 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[36].priority);
; 2340 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN3@SetDead:

; 2341 : 		}
; 2342 : 	}
; 2343 : 	else {

	jmp	SHORT $LN9@SetDead
$LN4@SetDead:

; 2344 : 		if (unit_flags & U_DEAD){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	and	eax, 1
	je	SHORT $LN9@SetDead

; 2345 : 			unit_flags &= ~U_DEAD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], edx

; 2346 : 			//MakeUnitDirty (DIRTY_UNIT_FLAGS, DDP[37].priority);
; 2347 : 			MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_SOON);

	push	4096					; 00001000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN9@SetDead:

; 2348 : 		}
; 2349 : 	}
; 2350 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetDead@UnitClass@@QAEXH@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetDead@UnitClass@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetDead@UnitClass@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetDead@UnitClass@@QAEXH@Z ENDP			; UnitClass::SetDead
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?IsUnit@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnit@UnitClass@@UAEHXZ PROC				; UnitClass::IsUnit, COMDAT
; _this$ = ecx

; 274  : 	virtual int IsUnit (void)										{ return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnit@UnitClass@@UAEHXZ ENDP				; UnitClass::IsUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_vehs$ = -12						; size = 4
_morale$ = -8						; size = 4
_this$ = -4						; size = 4
_shot$ = 8						; size = 4
_lost$ = 12						; size = 4
?MoraleCheck@UnitClass@@QAEHHH@Z PROC			; UnitClass::MoraleCheck
; _this$ = ecx

; 955  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 956  : 	int			morale,vehs;
; 957  : 
; 958  : 	if (IsDead() || !shot)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@MoraleChec
	cmp	DWORD PTR _shot$[ebp], 0
	jne	SHORT $LN9@MoraleChec
$LN8@MoraleChec:

; 959  : 	{
; 960  : 		return 0;

	xor	eax, eax
	jmp	$LN10@MoraleChec
$LN9@MoraleChec:

; 961  : 	}
; 962  : 
; 963  : 	vehs = GetTotalVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _vehs$[ebp], eax

; 964  : 	if (!vehs)

	cmp	DWORD PTR _vehs$[ebp], 0
	jne	SHORT $LN7@MoraleChec

; 965  : 	{
; 966  : 		return 0;

	xor	eax, eax
	jmp	$LN10@MoraleChec
$LN7@MoraleChec:

; 967  : 	}
; 968  : 
; 969  : 	morale = GetUnitMorale();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+780]
	call	eax
	mov	DWORD PTR _morale$[ebp], eax

; 970  : 	if (morale > 0)					// If we're tracking morale

	cmp	DWORD PTR _morale$[ebp], 0
	jle	SHORT $LN6@MoraleChec

; 971  : 	{
; 972  : 		// Subtract morale equal to our losses (% of current forces)
; 973  : 		morale -= (200 * lost / (lost+vehs)) + (shot+9)/10;

	mov	eax, DWORD PTR _lost$[ebp]
	imul	eax, 200				; 000000c8H
	mov	ecx, DWORD PTR _lost$[ebp]
	add	ecx, DWORD PTR _vehs$[ebp]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _shot$[ebp]
	add	eax, 9
	cdq
	mov	esi, 10					; 0000000aH
	idiv	esi
	add	ecx, eax
	mov	edx, DWORD PTR _morale$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _morale$[ebp], edx

; 974  : 		if (morale < 1)

	cmp	DWORD PTR _morale$[ebp], 1
	jge	SHORT $LN5@MoraleChec

; 975  : 		{
; 976  : 			morale = 1;

	mov	DWORD PTR _morale$[ebp], 1
$LN5@MoraleChec:

; 977  : 		}
; 978  : 
; 979  : 		if (IsBattalion())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN4@MoraleChec

; 980  : 		{
; 981  : 			SetUnitMorale(morale);

	mov	ecx, DWORD PTR _morale$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+752]
	call	edx
$LN4@MoraleChec:

; 982  : 		}
; 983  : 	}
; 984  : 	else

	jmp	SHORT $LN3@MoraleChec
$LN6@MoraleChec:

; 985  : 	{
; 986  : 		// Otherwise come up with a decent % chance
; 987  : 		morale = (100*(vehs+losses)) / (shot+lost*2+losses*2);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+221]
	add	eax, DWORD PTR _vehs$[ebp]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _lost$[ebp]
	mov	edx, DWORD PTR _shot$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [edx+221]
	lea	ecx, DWORD PTR [ecx+edx*2]
	cdq
	idiv	ecx
	mov	DWORD PTR _morale$[ebp], eax
$LN3@MoraleChec:

; 988  : 	}
; 989  : 	// Check for a break in morale
; 990  : 	if ((morale < 65) && (morale < (rand()%65)))

	cmp	DWORD PTR _morale$[ebp], 65		; 00000041H
	jge	SHORT $LN2@MoraleChec
	call	_rand
	cdq
	mov	ecx, 65					; 00000041H
	idiv	ecx
	cmp	DWORD PTR _morale$[ebp], edx
	jge	SHORT $LN2@MoraleChec

; 991  : 	{
; 992  : 		if (lost)

	cmp	DWORD PTR _lost$[ebp], 0
	je	SHORT $LN1@MoraleChec

; 993  : 		{
; 994  : 			SetLosses(1);				// Flag unit as taking losses

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLosses@UnitClass@@QAEXH@Z		; UnitClass::SetLosses
$LN1@MoraleChec:

; 995  : 		}
; 996  : 
; 997  : 		SetBroken(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBroken@UnitClass@@QAEXH@Z		; UnitClass::SetBroken

; 998  : #ifdef KEV_DEBUG
; 999  : 		//		MonoPrint("Unit %d broken! %d%% chance.\n",GetCampID(),100-morale);
; 1000 : #endif
; 1001 : 		// Trigger a tactics check
; 1002 : 		ChooseTactic();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+496]
	call	edx

; 1003 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN10@MoraleChec
$LN2@MoraleChec:

; 1004 : 	}
; 1005 : 	return 1;

	mov	eax, 1
$LN10@MoraleChec:

; 1006 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?MoraleCheck@UnitClass@@QAEHHH@Z ENDP			; UnitClass::MoraleCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_nomove$ = -28						; size = 4
_t$ = -24						; size = 4
_this$ = -20						; size = 4
_x$ = -16						; size = 2
_y$ = -12						; size = 2
_X$ = -8						; size = 2
_Y$ = -4						; size = 2
_h$ = 8							; size = 1
?ChangeUnitLocation@UnitClass@@QAEHE@Z PROC		; UnitClass::ChangeUnitLocation
; _this$ = ecx

; 2086 : int UnitClass::ChangeUnitLocation(CampaignHeading h){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2087 : 	// counts number of time this function is called every second
; 2088 : 	//static unsigned int count = 0;
; 2089 : 	//static DWORD lastZero;
; 2090 : 	//++count;
; 2091 : 	//DWORD thisTime = GetTickCount();
; 2092 : 	//if (thisTime - lastZero > 1000){
; 2093 : 	//	MonoPrint("change unit location: %d\n", count);
; 2094 : 	//	count = 0;
; 2095 : 	//	lastZero = thisTime;
; 2096 : 	//}
; 2097 : 
; 2098 : 	GridIndex x,y,X,Y;
; 2099 : 	int nomove = 0;

	mov	DWORD PTR _nomove$[ebp], 0

; 2100 : 	CampaignTime t;
; 2101 : 
; 2102 : 	if (h < 0 || h > 8){

	movzx	eax, BYTE PTR _h$[ebp]
	test	eax, eax
	jl	SHORT $LN15@ChangeUnit
	movzx	ecx, BYTE PTR _h$[ebp]
	cmp	ecx, 8
	jle	SHORT $LN16@ChangeUnit
$LN15@ChangeUnit:

; 2103 : 		SetUnitLastMove(Camp_GetCurrentTime());

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+592]
	call	edx

; 2104 : 		return 0;

	xor	eax, eax
	jmp	$LN17@ChangeUnit
$LN16@ChangeUnit:

; 2105 : 	}
; 2106 : 	if (!IsAggregate()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN14@ChangeUnit

; 2107 : 		return 0;

	xor	eax, eax
	jmp	$LN17@ChangeUnit
$LN14@ChangeUnit:

; 2108 : 	}
; 2109 : 	if (!Real()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	jne	SHORT $LN13@ChangeUnit

; 2110 : 		return 0;

	xor	eax, eax
	jmp	$LN17@ChangeUnit
$LN13@ChangeUnit:

; 2111 : 	}
; 2112 : 	t = TimeToMove(this,h);

	movzx	ecx, BYTE PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?TimeToMove@@YAKPAVUnitClass@@E@Z	; TimeToMove
	add	esp, 8
	mov	DWORD PTR _t$[ebp], eax

; 2113 : 
; 2114 : 	if (GetMoveTime() >= t){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+644]
	call	eax
	cmp	eax, DWORD PTR _t$[ebp]
	jb	$LN12@ChangeUnit

; 2115 : 		if (t < 1){

	cmp	DWORD PTR _t$[ebp], 1
	jae	SHORT $LN11@ChangeUnit

; 2116 : 			return 0;

	xor	eax, eax
	jmp	$LN17@ChangeUnit
$LN11@ChangeUnit:

; 2117 : 		}
; 2118 : 
; 2119 : 		IncrementTime(t);

	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+736]
	call	edx

; 2120 : 		GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2121 : 		X = (GridIndex)x+dx[h];

	movsx	edx, WORD PTR _x$[ebp]
	movzx	eax, BYTE PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dx@@3PAFA[eax*2]
	add	edx, ecx
	mov	WORD PTR _X$[ebp], dx

; 2122 : 		Y = (GridIndex)y+dy[h];

	movsx	edx, WORD PTR _y$[ebp]
	movzx	eax, BYTE PTR _h$[ebp]
	movsx	ecx, WORD PTR ?dy@@3PAFA[eax*2]
	add	edx, ecx
	mov	WORD PTR _Y$[ebp], dx

; 2123 : 
; 2124 : 		if ((X < 0) || (X >= Map_Max_X) || (Y < 0) || (Y >= Map_Max_Y)){

	movsx	edx, WORD PTR _X$[ebp]
	test	edx, edx
	jl	SHORT $LN9@ChangeUnit
	movsx	eax, WORD PTR _X$[ebp]
	movsx	ecx, WORD PTR ?Map_Max_X@@3FA		; Map_Max_X
	cmp	eax, ecx
	jge	SHORT $LN9@ChangeUnit
	movsx	edx, WORD PTR _Y$[ebp]
	test	edx, edx
	jl	SHORT $LN9@ChangeUnit
	movsx	eax, WORD PTR _Y$[ebp]
	movsx	ecx, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	cmp	eax, ecx
	jl	SHORT $LN10@ChangeUnit
$LN9@ChangeUnit:

; 2125 : 			// KCK Hack: Teleport units off map back onto map
; 2126 : 			if (X < 0){

	movsx	edx, WORD PTR _X$[ebp]
	test	edx, edx
	jge	SHORT $LN8@ChangeUnit

; 2127 : 				X = 0;

	xor	eax, eax
	mov	WORD PTR _X$[ebp], ax
$LN8@ChangeUnit:

; 2128 : 			}
; 2129 : 			if (Y < 0){

	movsx	ecx, WORD PTR _Y$[ebp]
	test	ecx, ecx
	jge	SHORT $LN7@ChangeUnit

; 2130 : 				Y = 0;

	xor	edx, edx
	mov	WORD PTR _Y$[ebp], dx
$LN7@ChangeUnit:

; 2131 : 			}
; 2132 : 			if (X >= Map_Max_X){

	movsx	eax, WORD PTR _X$[ebp]
	movsx	ecx, WORD PTR ?Map_Max_X@@3FA		; Map_Max_X
	cmp	eax, ecx
	jl	SHORT $LN6@ChangeUnit

; 2133 : 				X = (GridIndex)(Map_Max_X - 1);

	movsx	edx, WORD PTR ?Map_Max_X@@3FA		; Map_Max_X
	sub	edx, 1
	mov	WORD PTR _X$[ebp], dx
$LN6@ChangeUnit:

; 2134 : 			}
; 2135 : 			if (Y >= Map_Max_Y){

	movsx	eax, WORD PTR _Y$[ebp]
	movsx	ecx, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	cmp	eax, ecx
	jl	SHORT $LN10@ChangeUnit

; 2136 : 				Y = (GridIndex)(Map_Max_Y - 1);

	movsx	edx, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	sub	edx, 1
	mov	WORD PTR _Y$[ebp], dx
$LN10@ChangeUnit:

; 2137 : 			}
; 2138 : 		}
; 2139 : 		// Be optimistic- actually move the unit (if it's aggregated)
; 2140 : 		// Only move it if its going to be on the map however.
; 2141 : 		SetLocation(X,Y);

	movzx	eax, WORD PTR _Y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _X$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocation@CampBaseClass@@QAEXFF@Z	; CampBaseClass::SetLocation

; 2142 : 		SetUnitMoved(GetUnitMoved()+1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitMoved@UnitClass@@QBEHXZ		; UnitClass::GetUnitMoved
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitMoved@UnitClass@@QAEXE@Z	; UnitClass::SetUnitMoved

; 2143 : 
; 2144 : 		// Detect things
; 2145 : 		if (DetectOnMove() < 0){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+520]
	call	edx
	test	eax, eax
	jge	SHORT $LN4@ChangeUnit

; 2146 : 			nomove = 1;

	mov	DWORD PTR _nomove$[ebp], 1
$LN4@ChangeUnit:

; 2147 : 		}
; 2148 : 
; 2149 : 		// If we couldn't move, put ourselves back where we started
; 2150 : 		if (h == Here || nomove){

	movzx	eax, BYTE PTR _h$[ebp]
	cmp	eax, 8
	je	SHORT $LN2@ChangeUnit
	cmp	DWORD PTR _nomove$[ebp], 0
	je	SHORT $LN3@ChangeUnit
$LN2@ChangeUnit:

; 2151 : 			SetLocation(x,y);

	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocation@CampBaseClass@@QAEXFF@Z	; CampBaseClass::SetLocation

; 2152 : 			return -1;

	or	eax, -1
	jmp	SHORT $LN17@ChangeUnit
$LN3@ChangeUnit:

; 2153 : 		}
; 2154 : 
; 2155 : 		// If we get here, it's because we've moved..
; 2156 : #ifdef CAMPTOOL
; 2157 : 		else if (DisplayOk(this) && displayCampaign){
; 2158 : 			RedrawCell(NULL,x,y);
; 2159 : 			RedrawUnit(this);
; 2160 : 		}		
; 2161 : #endif
; 2162 : 		if (IsBattalion()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN1@ChangeUnit

; 2163 : 			ClearDeaggregationData();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	call	eax
$LN1@ChangeUnit:

; 2164 : 		}
; 2165 : 
; 2166 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN17@ChangeUnit
$LN12@ChangeUnit:

; 2167 : 	}
; 2168 : 	return 0;

	xor	eax, eax
$LN17@ChangeUnit:

; 2169 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeUnitLocation@UnitClass@@QAEHE@Z ENDP		; UnitClass::ChangeUnitLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -44						; size = 8
$T3 = -36						; size = 4
_this$ = -32						; size = 4
tv130 = -28						; size = 4
$T4 = -24						; size = 4
tv87 = -20						; size = 4
_um$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 8
_msg$ = 16						; size = 2
_d1$ = 20						; size = 2
_d2$ = 24						; size = 2
_d3$ = 28						; size = 2
?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z PROC ; UnitClass::BroadcastUnitMessage
; _this$ = ecx

; 543  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 544  : 	FalconUnitMessage* um = new FalconUnitMessage(Id(), FalconLocalGame);

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN5@BroadcastU
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@BroadcastU
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN4@BroadcastU
$LN3@BroadcastU:
	mov	DWORD PTR tv87[ebp], 0
$LN4@BroadcastU:
	push	1
	mov	ecx, DWORD PTR tv87[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0FalconUnitMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconUnitMessage::FalconUnitMessage
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN6@BroadcastU
$LN5@BroadcastU:
	mov	DWORD PTR tv130[ebp], 0
$LN6@BroadcastU:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _um$[ebp], ecx

; 545  : 	um->dataBlock.from = id;

	mov	edx, DWORD PTR _um$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR [edx+48], eax
	mov	ecx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [edx+52], ecx

; 546  : 	um->dataBlock.message = msg;

	mov	edx, DWORD PTR _um$[ebp]
	mov	ax, WORD PTR _msg$[ebp]
	mov	WORD PTR [edx+56], ax

; 547  : 	um->dataBlock.data1 = d1;

	mov	ecx, DWORD PTR _um$[ebp]
	mov	dx, WORD PTR _d1$[ebp]
	mov	WORD PTR [ecx+58], dx

; 548  : 	um->dataBlock.data2 = d2;

	mov	eax, DWORD PTR _um$[ebp]
	mov	cx, WORD PTR _d2$[ebp]
	mov	WORD PTR [eax+60], cx

; 549  : 	um->dataBlock.data3 = d3;

	mov	edx, DWORD PTR _um$[ebp]
	mov	ax, WORD PTR _d3$[ebp]
	mov	WORD PTR [edx+62], ax

; 550  : 	FalconSendMessage(um,TRUE);

	push	1
	mov	ecx, DWORD PTR _um$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 551  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ENDP ; UnitClass::BroadcastUnitMessage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -52						; size = 8
$T3 = -44						; size = 8
$T4 = -36						; size = 4
_target$ = -32						; size = 4
tv95 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_um$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 8
_msg$ = 16						; size = 2
_d1$ = 20						; size = 2
_d2$ = 24						; size = 2
_d3$ = 28						; size = 2
?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z PROC	; UnitClass::SendUnitMessage
; _this$ = ecx

; 531  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 532  : 	VuTargetEntity* target = (VuTargetEntity*) vuDatabase->Find(OwnerId());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$[ebp], eax

; 533  : 	FalconUnitMessage* um = new FalconUnitMessage(Id(), target);

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN3@SendUnitMe
	push	1
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconUnitMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconUnitMessage::FalconUnitMessage
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN4@SendUnitMe
$LN3@SendUnitMe:
	mov	DWORD PTR tv95[ebp], 0
$LN4@SendUnitMe:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _um$[ebp], edx

; 534  : 	um->dataBlock.from = id;

	mov	eax, DWORD PTR _um$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	edx, DWORD PTR _id$[ebp+4]
	mov	DWORD PTR [eax+52], edx

; 535  : 	um->dataBlock.message = msg;

	mov	eax, DWORD PTR _um$[ebp]
	mov	cx, WORD PTR _msg$[ebp]
	mov	WORD PTR [eax+56], cx

; 536  : 	um->dataBlock.data1 = d1;

	mov	edx, DWORD PTR _um$[ebp]
	mov	ax, WORD PTR _d1$[ebp]
	mov	WORD PTR [edx+58], ax

; 537  : 	um->dataBlock.data2 = d2;

	mov	ecx, DWORD PTR _um$[ebp]
	mov	dx, WORD PTR _d2$[ebp]
	mov	WORD PTR [ecx+60], dx

; 538  : 	um->dataBlock.data3 = d3;

	mov	eax, DWORD PTR _um$[ebp]
	mov	cx, WORD PTR _d3$[ebp]
	mov	WORD PTR [eax+62], cx

; 539  : 	FalconSendMessage(um,TRUE);

	push	1
	mov	edx, DWORD PTR _um$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 540  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ENDP	; UnitClass::SendUnitMessage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z PROC ; UnitClass::GetVehicleDeagData, COMDAT
; _this$ = ecx

; 266  : 	virtual int GetVehicleDeagData(SimInitDataClass*, int)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?GetVehicleDeagData@UnitClass@@UAEHPAVSimInitDataClass@@H@Z ENDP ; UnitClass::GetVehicleDeagData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?SupplyUnit@UnitClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?SupplyUnit@UnitClass@@UAEXHH@Z PROC			; UnitClass::SupplyUnit, COMDAT
; _this$ = ecx

; 265  : 	virtual void SupplyUnit (int, int)								{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?SupplyUnit@UnitClass@@UAEXHH@Z ENDP			; UnitClass::SupplyUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitFuelNeed@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitFuelNeed@UnitClass@@UAEHH@Z PROC		; UnitClass::GetUnitFuelNeed, COMDAT
; _this$ = ecx

; 264  : 	virtual int GetUnitFuelNeed (int)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitFuelNeed@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetUnitFuelNeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSupplyNeed@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetUnitSupplyNeed@UnitClass@@UAEHH@Z PROC		; UnitClass::GetUnitSupplyNeed, COMDAT
; _this$ = ecx

; 263  : 	virtual int GetUnitSupplyNeed (int)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitSupplyNeed@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetUnitSupplyNeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CombatTime@UnitClass@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatTime@UnitClass@@UAEKXZ PROC			; UnitClass::CombatTime, COMDAT
; _this$ = ecx

; 262  : 	virtual CampaignTime CombatTime (void)							{ return CampaignDay; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 86400000				; 05265c00H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatTime@UnitClass@@UAEKXZ ENDP			; UnitClass::CombatTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateTime@UnitClass@@QBEKXZ PROC			; UnitClass::UpdateTime
; _this$ = ecx

; 5446 : CampaignTime UnitClass::UpdateTime() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5447 : 	return update_interval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+188]

; 5448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTime@UnitClass@@QBEKXZ ENDP			; UnitClass::UpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ChooseTarget@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ChooseTarget@UnitClass@@UAEHXZ PROC			; UnitClass::ChooseTarget, COMDAT
; _this$ = ecx

; 253  : 	virtual int ChooseTarget (void)									{ return -1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	mov	esp, ebp
	pop	ebp
	ret	0
?ChooseTarget@UnitClass@@UAEHXZ ENDP			; UnitClass::ChooseTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DetectOnMove@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DetectOnMove@UnitClass@@UAEHXZ PROC			; UnitClass::DetectOnMove, COMDAT
; _this$ = ecx

; 252  : 	virtual int DetectOnMove (void)									{ return -1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectOnMove@UnitClass@@UAEHXZ ENDP			; UnitClass::DetectOnMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitSpeed@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSpeed@UnitClass@@UBEHXZ PROC			; UnitClass::GetUnitSpeed, COMDAT
; _this$ = ecx

; 251  : 	virtual int GetUnitSpeed() const								{ return GetMaxSpeed(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMaxSpeed@UnitClass@@QBEHXZ		; UnitClass::GetMaxSpeed
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSpeed@UnitClass@@UBEHXZ ENDP			; UnitClass::GetUnitSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?AdjustForSupply@UnitClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AdjustForSupply@UnitClass@@UAEMXZ PROC			; UnitClass::AdjustForSupply, COMDAT
; _this$ = ecx

; 250  : 	virtual float AdjustForSupply(void)								{ return 1.0F; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld1
	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustForSupply@UnitClass@@UAEMXZ ENDP			; UnitClass::AdjustForSupply
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Real@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Real@UnitClass@@UAEHXZ PROC				; UnitClass::Real, COMDAT
; _this$ = ecx

; 249  : 	virtual int Real (void)											{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Real@UnitClass@@UAEHXZ ENDP				; UnitClass::Real
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Father@UnitClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Father@UnitClass@@UBEHXZ PROC				; UnitClass::Father, COMDAT
; _this$ = ecx

; 248  : 	virtual int Father() const										{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Father@UnitClass@@UBEHXZ ENDP				; UnitClass::Father
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CheckTactic@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?CheckTactic@UnitClass@@UAEHH@Z PROC			; UnitClass::CheckTactic, COMDAT
; _this$ = ecx

; 247  : 	virtual int CheckTactic (int)									{ return 1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckTactic@UnitClass@@UAEHH@Z ENDP			; UnitClass::CheckTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ChooseTactic@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ChooseTactic@UnitClass@@UAEHXZ PROC			; UnitClass::ChooseTactic, COMDAT
; _this$ = ecx

; 246  : 	virtual int ChooseTactic (void)									{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ChooseTactic@UnitClass@@UAEHXZ ENDP			; UnitClass::ChooseTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?DoCombat@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoCombat@UnitClass@@UAEHXZ PROC			; UnitClass::DoCombat, COMDAT
; _this$ = ecx

; 245  : 	virtual int DoCombat (void)										{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?DoCombat@UnitClass@@UAEHXZ ENDP			; UnitClass::DoCombat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?MoveUnit@UnitClass@@UAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?MoveUnit@UnitClass@@UAEHK@Z PROC			; UnitClass::MoveUnit, COMDAT
; _this$ = ecx

; 244  : 	virtual int MoveUnit (CampaignTime)								{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?MoveUnit@UnitClass@@UAEHK@Z ENDP			; UnitClass::MoveUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z PROC	; UnitClass::Reaction, COMDAT
; _this$ = ecx

; 243  : 	virtual int Reaction (CampEntity, int, float)					{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Reaction@UnitClass@@UAEHPAVCampBaseClass@@HM@Z ENDP	; UnitClass::Reaction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ClearDeaggregationData@UnitClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDeaggregationData@UnitClass@@UAEXXZ PROC		; UnitClass::ClearDeaggregationData, COMDAT
; _this$ = ecx

; 242  : 	virtual void ClearDeaggregationData (void)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDeaggregationData@UnitClass@@UAEXXZ ENDP		; UnitClass::ClearDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?ShouldDeaggregate@UnitClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShouldDeaggregate@UnitClass@@UAEHXZ PROC		; UnitClass::ShouldDeaggregate, COMDAT
; _this$ = ecx

; 241  : 	virtual int	ShouldDeaggregate(void)								{return TRUE;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldDeaggregate@UnitClass@@UAEHXZ ENDP		; UnitClass::ShouldDeaggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ PROC ; UnitClass::GetUnitDeaggregationData, COMDAT
; _this$ = ecx

; 240  : 	virtual UnitDeaggregationData* GetUnitDeaggregationData (void)	{ return NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitDeaggregationData@UnitClass@@UAEPAVUnitDeaggregationData@@XZ ENDP ; UnitClass::GetUnitDeaggregationData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z PROC ; UnitClass::GetDeaggregationPoint, COMDAT
; _this$ = ecx

; 239  : 	virtual int GetDeaggregationPoint (int, CampEntity*)			{ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	8
?GetDeaggregationPoint@UnitClass@@UAEHHPAPAVCampBaseClass@@@Z ENDP ; UnitClass::GetDeaggregationPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?CanShootWeapon@UnitClass@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?CanShootWeapon@UnitClass@@UAEHH@Z PROC			; UnitClass::CanShootWeapon, COMDAT
; _this$ = ecx

; 238  : 	virtual int CanShootWeapon (int)								{ return TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?CanShootWeapon@UnitClass@@UAEHH@Z ENDP			; UnitClass::CanShootWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_unitData$ = -4						; size = 4
?GetRadarType@UnitClass@@UAEHXZ PROC			; UnitClass::GetRadarType
; _this$ = ecx

; 3575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3576 : 	UnitClassDataType* unitData = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _unitData$[ebp], eax

; 3577 : 	if (unitData && unitData->RadarVehicle < 255) // Naval unit CTD

	cmp	DWORD PTR _unitData$[ebp], 0
	je	SHORT $LN2@GetRadarTy
	mov	eax, DWORD PTR _unitData$[ebp]
	movzx	ecx, BYTE PTR [eax+328]
	cmp	ecx, 255				; 000000ffH
	jge	SHORT $LN2@GetRadarTy

; 3578 : 	{
; 3579 : 		return ((VehicleClassDataType *)Falcon4ClassTable[unitData->VehicleType[unitData->RadarVehicle]].dataPtr)->RadarType;

	mov	edx, DWORD PTR _unitData$[ebp]
	movzx	eax, BYTE PTR [edx+328]
	mov	ecx, DWORD PTR _unitData$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+68]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	movsx	eax, WORD PTR [ecx+56]
	jmp	SHORT $LN3@GetRadarTy

; 3580 : 	} else {

	jmp	SHORT $LN3@GetRadarTy
$LN2@GetRadarTy:

; 3581 : 		return RDR_NO_RADAR;

	xor	eax, eax
$LN3@GetRadarTy:

; 3582 : 	}
; 3583 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarType@UnitClass@@UAEHXZ ENDP			; UnitClass::GetRadarType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_o$1 = -16						; size = 4
_this$ = -12						; size = 4
_x$2 = -8						; size = 2
_y$3 = -4						; size = 2
_anum$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 4
?GetArcAngle@UnitClass@@UAEXHPAM0@Z PROC		; UnitClass::GetArcAngle
; _this$ = ecx

; 3525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3526 : 	if (!IsBattalion())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@GetArcAngl

; 3527 : 	{
; 3528 : 		*a1 = 0.0F;

	mov	ecx, DWORD PTR _a1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0

; 3529 : 		*a2 = 2.0F*PI;

	mov	edx, DWORD PTR _a2$[ebp]
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [edx], xmm0

; 3530 : 		return;

	jmp	SHORT $LN5@GetArcAngl
$LN4@GetArcAngl:

; 3531 : 	}
; 3532 : 	// Only stationary air defense units even have any radar capibility
; 3533 : 	//if (!Moving() && GetUnitNormalRole() == GRO_AIRDEFENSE)
; 3534 : 	if ((!Moving()|| g_bFireOntheMove) && GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN2@GetArcAngl
	movzx	eax, BYTE PTR ?g_bFireOntheMove@@3_NA	; g_bFireOntheMove
	test	eax, eax
	je	SHORT $LN1@GetArcAngl
$LN2@GetArcAngl:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN1@GetArcAngl

; 3535 : 	{
; 3536 : 		Objective		o = NULL;

	mov	DWORD PTR _o$1[ebp], 0

; 3537 : 		GridIndex		x,y;
; 3538 : 		GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 3539 : 		o = FindNearestObjective (x, y, NULL, 1);

	push	1
	push	0
	movzx	eax, WORD PTR _y$3[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$2[ebp]
	push	ecx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$1[ebp], eax

; 3540 : 		if (o)

	cmp	DWORD PTR _o$1[ebp], 0
	je	SHORT $LN1@GetArcAngl

; 3541 : 			o->GetArcAngle(anum,a1,a2);

	mov	edx, DWORD PTR _a2$[ebp]
	push	edx
	mov	eax, DWORD PTR _a1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _anum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$1[ebp]
	mov	edx, DWORD PTR [eax+444]
	call	edx
$LN1@GetArcAngl:
$LN5@GetArcAngl:

; 3542 : 	}
; 3543 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetArcAngle@UnitClass@@UAEXHPAM0@Z ENDP		; UnitClass::GetArcAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_o$1 = -16						; size = 4
_this$ = -12						; size = 4
_x$2 = -8						; size = 2
_y$3 = -4						; size = 2
_anum$ = 8						; size = 4
?GetArcRange@UnitClass@@UAEMH@Z PROC			; UnitClass::GetArcRange
; _this$ = ecx

; 3507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3508 : 	if (!IsBattalion())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@GetArcRang

; 3509 : 		return 0.0F;

	fldz
	jmp	SHORT $LN5@GetArcRang
$LN4@GetArcRang:

; 3510 : 	// Only stationary air defense units even have any radar capibility
; 3511 : 	//if (!Moving() && GetUnitNormalRole() == GRO_AIRDEFENSE)
; 3512 : 	if ((!Moving()|| g_bFireOntheMove) && GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN2@GetArcRang
	movzx	ecx, BYTE PTR ?g_bFireOntheMove@@3_NA	; g_bFireOntheMove
	test	ecx, ecx
	je	SHORT $LN1@GetArcRang
$LN2@GetArcRang:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN1@GetArcRang

; 3513 : 	{
; 3514 : 		Objective		o = NULL;

	mov	DWORD PTR _o$1[ebp], 0

; 3515 : 		GridIndex		x,y;
; 3516 : 		GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 3517 : 		o = FindNearestObjective (x, y, NULL, 1);

	push	1
	push	0
	movzx	edx, WORD PTR _y$3[ebp]
	push	edx
	movzx	eax, WORD PTR _x$2[ebp]
	push	eax
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$1[ebp], eax

; 3518 : 		if (o)

	cmp	DWORD PTR _o$1[ebp], 0
	je	SHORT $LN1@GetArcRang

; 3519 : 			return o->GetArcRange(anum);

	mov	ecx, DWORD PTR _anum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$1[ebp]
	mov	edx, DWORD PTR [eax+440]
	call	edx
	jmp	SHORT $LN5@GetArcRang
$LN1@GetArcRang:

; 3520 : 	}
; 3521 : 	return 0.0F;

	fldz
$LN5@GetArcRang:

; 3522 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetArcRange@UnitClass@@UAEMH@Z ENDP			; UnitClass::GetArcRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_o$1 = -16						; size = 4
_this$ = -12						; size = 4
_x$2 = -8						; size = 2
_y$3 = -4						; size = 2
_anum$ = 8						; size = 4
?GetArcRatio@UnitClass@@UAEMH@Z PROC			; UnitClass::GetArcRatio
; _this$ = ecx

; 3489 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3490 : 	if (!IsBattalion())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@GetArcRati

; 3491 : 		return 0.0F;

	fldz
	jmp	SHORT $LN5@GetArcRati
$LN4@GetArcRati:

; 3492 : 	// Only stationary air defense units even have any radar capibility
; 3493 : 	//if (!Moving() && GetUnitNormalRole() == GRO_AIRDEFENSE)
; 3494 : 	if ((!Moving()|| g_bFireOntheMove) && GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN2@GetArcRati
	movzx	ecx, BYTE PTR ?g_bFireOntheMove@@3_NA	; g_bFireOntheMove
	test	ecx, ecx
	je	SHORT $LN1@GetArcRati
$LN2@GetArcRati:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN1@GetArcRati

; 3495 : 	{
; 3496 : 		Objective		o = NULL;

	mov	DWORD PTR _o$1[ebp], 0

; 3497 : 		GridIndex		x,y;
; 3498 : 		GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 3499 : 		o = FindNearestObjective (x, y, NULL, 1);

	push	1
	push	0
	movzx	edx, WORD PTR _y$3[ebp]
	push	edx
	movzx	eax, WORD PTR _x$2[ebp]
	push	eax
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$1[ebp], eax

; 3500 : 		if (o)

	cmp	DWORD PTR _o$1[ebp], 0
	je	SHORT $LN1@GetArcRati

; 3501 : 			return o->GetArcRatio(anum);

	mov	ecx, DWORD PTR _anum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _o$1[ebp]
	mov	edx, DWORD PTR [eax+436]
	call	edx
	jmp	SHORT $LN5@GetArcRati
$LN1@GetArcRati:

; 3502 : 	}
; 3503 : 	return 0.0F;

	fldz
$LN5@GetArcRati:

; 3504 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetArcRatio@UnitClass@@UAEMH@Z ENDP			; UnitClass::GetArcRatio
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_o$1 = -16						; size = 4
_this$ = -12						; size = 4
_x$2 = -8						; size = 2
_y$3 = -4						; size = 2
?GetNumberOfArcs@UnitClass@@UAEHXZ PROC			; UnitClass::GetNumberOfArcs
; _this$ = ecx

; 3471 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3472 : 	if (!IsBattalion())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@GetNumberO

; 3473 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN5@GetNumberO
$LN4@GetNumberO:

; 3474 : 	// Only stationary air defense units even have any radar capibility
; 3475 : 	//if (!Moving() && GetUnitNormalRole() == GRO_AIRDEFENSE)
; 3476 : 	if ((!Moving()|| g_bFireOntheMove) && GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN2@GetNumberO
	movzx	ecx, BYTE PTR ?g_bFireOntheMove@@3_NA	; g_bFireOntheMove
	test	ecx, ecx
	je	SHORT $LN3@GetNumberO
$LN2@GetNumberO:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN3@GetNumberO

; 3477 : 	{
; 3478 : 		Objective		o = NULL;

	mov	DWORD PTR _o$1[ebp], 0

; 3479 : 		GridIndex		x,y;
; 3480 : 		GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 3481 : 		o = FindNearestObjective (x, y, NULL, 1);

	push	1
	push	0
	movzx	edx, WORD PTR _y$3[ebp]
	push	edx
	movzx	eax, WORD PTR _x$2[ebp]
	push	eax
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$1[ebp], eax

; 3482 : 		if (o)

	cmp	DWORD PTR _o$1[ebp], 0
	je	SHORT $LN3@GetNumberO

; 3483 : 			return o->GetNumberOfArcs();

	mov	ecx, DWORD PTR _o$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$1[ebp]
	mov	eax, DWORD PTR [edx+432]
	call	eax
	jmp	SHORT $LN5@GetNumberO
$LN3@GetNumberO:

; 3484 : 	}
; 3485 : 	return 0;

	xor	eax, eax
$LN5@GetNumberO:

; 3486 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfArcs@UnitClass@@UAEHXZ ENDP			; UnitClass::GetNumberOfArcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv129 = -20						; size = 4
_this$ = -16						; size = 4
_unitData$ = -12					; size = 4
_iIrSign$1 = -8						; size = 4
_pIrSign$ = -4						; size = 4
?GetIRFactor@UnitClass@@UAEMXZ PROC			; UnitClass::GetIRFactor
; _this$ = ecx

; 3552 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3553 : 	// TODO:  THIS NEED TO RETURN IR DATA
; 3554 : 	UnitClassDataType* unitData = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _unitData$[ebp], eax

; 3555 : 
; 3556 : 	ShiAssert (unitData->VehicleType[0]);
; 3557 : 	// 2000-11-17 MODIFIED BY S.G. SINCE WE HAVE AN IR DATA NOW, WHY NOT USE IT :-)
; 3558 : 	//   return ((VehicleClassDataType *)Falcon4ClassTable[unitData->VehicleType[0]].dataPtr)->RCSfactor;
; 3559 : 
; 3560 : 	// The IR signature is stored as a byte at offset 0x9E of the falcon4.vcd structure.
; 3561 : 	// This byte, as well as 0x9D and 0x9F are used for padding originally.
; 3562 : 	// The value range will be 0 to 2 with increments of 0.0078125
; 3563 : 	unsigned char *pIrSign = (unsigned char *)((VehicleClassDataType *)Falcon4ClassTable[unitData->VehicleType[0]].dataPtr);

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _unitData$[ebp]
	movsx	edx, WORD PTR [ecx+eax+68]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	mov	DWORD PTR _pIrSign$[ebp], ecx

; 3564 : 	if (pIrSign)

	cmp	DWORD PTR _pIrSign$[ebp], 0
	je	SHORT $LN1@GetIRFacto

; 3565 : 	{
; 3566 : 		int iIrSign = (unsigned)pIrSign[0x9E];

	mov	edx, 1
	imul	edx, 158				; 0000009eH
	mov	eax, DWORD PTR _pIrSign$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _iIrSign$1[ebp], ecx

; 3567 : 		if (iIrSign)

	cmp	DWORD PTR _iIrSign$1[ebp], 0
	je	SHORT $LN1@GetIRFacto

; 3568 : 			return (float)iIrSign / 128.0f;

	cvtsi2ss xmm0, DWORD PTR _iIrSign$1[ebp]
	divss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR tv129[ebp], xmm0
	fld	DWORD PTR tv129[ebp]
	jmp	SHORT $LN3@GetIRFacto
$LN1@GetIRFacto:

; 3569 : 	}
; 3570 : 
; 3571 : 	return ((VehicleClassDataType *)Falcon4ClassTable[unitData->VehicleType[0]].dataPtr)->RCSfactor;

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _unitData$[ebp]
	movsx	ecx, WORD PTR [eax+edx+68]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	fld	DWORD PTR [eax+28]
$LN3@GetIRFacto:

; 3572 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetIRFactor@UnitClass@@UAEMXZ ENDP			; UnitClass::GetIRFactor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_unitData$ = -8						; size = 4
_this$ = -4						; size = 4
?GetRCSFactor@UnitClass@@UAEMXZ PROC			; UnitClass::GetRCSFactor
; _this$ = ecx

; 3546 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3547 : 	UnitClassDataType* unitData = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _unitData$[ebp], eax

; 3548 : 	return ((VehicleClassDataType *)Falcon4ClassTable[unitData->VehicleType[0]].dataPtr)->RCSfactor;

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _unitData$[ebp]
	movsx	edx, WORD PTR [ecx+eax+68]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	fld	DWORD PTR [ecx+28]

; 3549 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRCSFactor@UnitClass@@UAEMXZ ENDP			; UnitClass::GetRCSFactor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv140 = -16						; size = 4
tv133 = -12						; size = 4
_this$ = -8						; size = 4
_vehicle$1 = -4						; size = 4
_component$ = 8						; size = 4
?GetComponentAltitude@UnitClass@@UAEHH@Z PROC		; UnitClass::GetComponentAltitude
; _this$ = ecx

; 3607 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3608 : 	if (component < 255)

	cmp	DWORD PTR _component$[ebp], 255		; 000000ffH
	jge	SHORT $LN1@GetCompone

; 3609 : 	{
; 3610 : 		SimVehicleClass		*vehicle = (SimVehicleClass*) GetComponentNumber(component);

	mov	eax, DWORD PTR _component$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _vehicle$1[ebp], eax

; 3611 : 		if (vehicle)

	cmp	DWORD PTR _vehicle$1[ebp], 0
	je	SHORT $LN1@GetCompone

; 3612 : 			return FloatToInt32(vehicle->ZPos() * -1.0F);

	mov	ecx, DWORD PTR _vehicle$1[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv133[ebp]
	movss	xmm0, DWORD PTR tv133[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	jmp	SHORT $LN3@GetCompone
$LN1@GetCompone:

; 3613 : 	}
; 3614 : 	return FloatToInt32(ZPos() * -1.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv140[ebp]
	movss	xmm0, DWORD PTR tv140[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
$LN3@GetCompone:

; 3615 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetComponentAltitude@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetComponentAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_vehicle$1 = -24					; size = 4
_this$ = -20						; size = 4
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_component$ = 16					; size = 4
?GetComponentLocation@UnitClass@@UAEXPAF0H@Z PROC	; UnitClass::GetComponentLocation
; _this$ = ecx

; 3586 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3587 : 	::vector v;
; 3588 : 
; 3589 : 	v.z = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _v$[ebp+8], xmm0

; 3590 : 	if (component < 255 && GetComponents())

	cmp	DWORD PTR _component$[ebp], 255		; 000000ffH
	jge	SHORT $LN1@GetCompone
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	SHORT $LN1@GetCompone

; 3591 : 	{
; 3592 : 		SimVehicleClass		*vehicle = (SimVehicleClass*) GetComponentNumber(component);

	mov	eax, DWORD PTR _component$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _vehicle$1[ebp], eax

; 3593 : 		if (vehicle)

	cmp	DWORD PTR _vehicle$1[ebp], 0
	je	SHORT $LN1@GetCompone

; 3594 : 		{
; 3595 : 			v.x = vehicle->XPos();

	mov	ecx, DWORD PTR _vehicle$1[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _v$[ebp]

; 3596 : 			v.y = vehicle->YPos();

	mov	ecx, DWORD PTR _vehicle$1[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _v$[ebp+4]

; 3597 : 			ConvertSimToGrid(&v,x,y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH

; 3598 : 			return;

	jmp	SHORT $LN3@GetCompone
$LN1@GetCompone:

; 3599 : 		}
; 3600 : 	}
; 3601 : 	v.x = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _v$[ebp]

; 3602 : 	v.y = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _v$[ebp+4]

; 3603 : 	ConvertSimToGrid(&v,x,y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH
$LN3@GetCompone:

; 3604 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetComponentLocation@UnitClass@@UAEXPAF0H@Z ENDP	; UnitClass::GetComponentLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_tl$1 = -140						; size = 4
tv614 = -136						; size = 4
tv818 = -132						; size = 4
tv642 = -128						; size = 4
_uc$2 = -124						; size = 4
_z$3 = -120						; size = 4
tv790 = -116						; size = 4
tv630 = -112						; size = 4
tv830 = -108						; size = 4
_vc$4 = -104						; size = 4
tv786 = -100						; size = 4
_ez$5 = -96						; size = 4
tv682 = -92						; size = 4
tv828 = -88						; size = 4
tv674 = -84						; size = 4
tv626 = -80						; size = 4
_azLimit$6 = -76					; size = 4
tv668 = -72						; size = 4
tv826 = -68						; size = 4
_az$7 = -64						; size = 4
_x$8 = -60						; size = 2
_mt$ = -56						; size = 4
_el$9 = -52						; size = 4
_y$10 = -48						; size = 2
_vdr$11 = -44						; size = 4
_o$12 = -40						; size = 4
_vdr$13 = -36						; size = 4
_jammerRange$14 = -32					; size = 4
_yd$15 = -28						; size = 4
_jammerRange$16 = -24					; size = 4
_ds$ = -20						; size = 4
_ecmFlight$17 = -16					; size = 4
_ecmFlight$18 = -12					; size = 4
_mrs$ = -8						; size = 4
_this$ = -4						; size = 4
_ent$ = 8						; size = 4
?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z PROC	; UnitClass::CanDetect
; _this$ = ecx

; 3261 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	DWORD PTR _this$[ebp], ecx

; 3262 : 	float			ds,mrs;
; 3263 : 	MoveType		mt;
; 3264 : 
; 3265 : 	mt = ent->GetMovementType();

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _mt$[ebp], eax

; 3266 : 	ds = DistSqu(XPos(),YPos(),ent->XPos(),ent->YPos());

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?DistSqu@@YAMMMMM@Z			; DistSqu
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _ds$[ebp]

; 3267 : 	mrs = (float)(GetDetectionRange(mt) * KM_TO_FT);

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+416]
	call	edx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _mrs$[ebp], xmm0

; 3268 : 	mrs *= mrs;

	movss	xmm0, DWORD PTR _mrs$[ebp]
	mulss	xmm0, DWORD PTR _mrs$[ebp]
	movss	DWORD PTR _mrs$[ebp], xmm0

; 3269 : 	if (ds > mrs)

	movss	xmm0, DWORD PTR _ds$[ebp]
	comiss	xmm0, DWORD PTR _mrs$[ebp]
	jbe	SHORT $LN38@CanDetect

; 3270 : 		return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN38@CanDetect:

; 3271 : 
; 3272 : #ifdef DEBUG
; 3273 : 	if (ent->IsAirplane())
; 3274 : 		int i = 0;
; 3275 : 	if (IsAirplane())
; 3276 : 		int i = 0;
; 3277 : #endif
; 3278 : 	// Additional Detection requirements against aircraft
; 3279 : 	if (ent->IsFlight())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN1@CanDetect

; 3280 : 	{
; 3281 : 		/* 2001-04-05 REMOVED BY S.G. TOO MANY CHANGES TO KEEP TRACK...
; 3282 : 		// First see if our eyes will do the job
; 3283 : 		float vdr = (float) GetVisualDetectionRange(mt);
; 3284 : 		vdr *= vdr;
; 3285 : 		if (ds < vdr)
; 3286 : 		return DETECTED_VISUAL;
; 3287 : 
; 3288 : 		// If we don't have a radar and the sucker isn't spotted yet, just bail out.
; 3289 : 		if (!IsEmitting() && !((Flight)ent)->GetSpotted(GetTeam()))
; 3290 : 		return 0;
; 3291 : 
; 3292 : 		// If we're a batallion, try to use radar coverage masks
; 3293 : 		if (IsBattalion())
; 3294 : 		{
; 3295 : 		GridIndex		x,y;
; 3296 : 		Objective		o = NULL;
; 3297 : 		if (Moving())
; 3298 : 		return 0;
; 3299 : 		else
; 3300 : 		{
; 3301 : 		// Try to use nearby objective's radar mask data
; 3302 : 		GetLocation(&x,&y);
; 3303 : 		o = FindNearestObjective (x, y, NULL, 1);
; 3304 : 		if (o && o->HasRadarRanges())
; 3305 : 		{
; 3306 : 		mrs = o->GetSiteRange(ent);
; 3307 : 		mrs *= mrs;
; 3308 : 		if (ds > mrs)
; 3309 : 		return 0;
; 3310 : 		}
; 3311 : 		}
; 3312 : 		}
; 3313 : 		 */
; 3314 : 		// 2001-03-15 ADDED BY S.G. SEE COMMENT WITHIN. BASICALLY, I NEED TO DO MORE TEST IF BOTH ARE FLIGHTS
; 3315 : 		// 2001-03-22 REMOVED BY S.G. DON'T CHECK IF SPOTTED. THIS IS DONE IN DetectVs NOW. THAT WAY, SPOTTING CAN BE LOST
; 3316 : 		if (IsFlight()) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN36@CanDetect

; 3317 : 			// Using the graphic's altitude map, adjust the altitude
; 3318 : 			float ez = ent->ZPos() + TheMap.GetMEA(ent->XPos(), ent->YPos());

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv614[ebp]
	movss	xmm0, DWORD PTR tv614[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR tv826[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	fstp	DWORD PTR tv626[ebp]
	movss	xmm0, DWORD PTR tv826[ebp]
	addss	xmm0, DWORD PTR tv626[ebp]
	movss	DWORD PTR _ez$5[ebp], xmm0

; 3319 : 			float z =  ZPos() + TheMap.GetMEA(XPos(), YPos());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv630[ebp]
	movss	xmm0, DWORD PTR tv630[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv828[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	fstp	DWORD PTR tv642[ebp]
	movss	xmm0, DWORD PTR tv828[ebp]
	addss	xmm0, DWORD PTR tv642[ebp]
	movss	DWORD PTR _z$3[ebp], xmm0

; 3320 : 
; 3321 : 			// First, if the enemy is hugging the ground, we cannot see it (don't forget that's only if the enemy is't spotted)
; 3322 : 			if (ez > -500.0f && z < -2000.0f)

	movss	xmm0, DWORD PTR _ez$5[ebp]
	comiss	xmm0, DWORD PTR __real@c3fa0000
	jbe	SHORT $LN35@CanDetect
	movss	xmm0, DWORD PTR __real@c4fa0000
	comiss	xmm0, DWORD PTR _z$3[ebp]
	jbe	SHORT $LN35@CanDetect

; 3323 : 				return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN35@CanDetect:

; 3324 : 
; 3325 : 			// Since both are flights, now deal with spherical coverage instead of cylindrical
; 3326 : 			float az = TargetAz((FalconEntity *)this, (FalconEntity *)ent);

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?TargetAz@@YAMPAVFalconEntity@@0@Z	; TargetAz
	add	esp, 8
	fstp	DWORD PTR _az$7[ebp]

; 3327 : 			float el = TargetEl((FalconEntity *)this, (FalconEntity *)ent);

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?TargetEl@@YAMPAVFalconEntity@@0@Z	; TargetEl
	add	esp, 8
	fstp	DWORD PTR _el$9[ebp]

; 3328 : 
; 3329 : 			VehicleClassDataType* vc = GetVehicleClassData(class_data->VehicleType[0]); // That's ok, we are a flight and flight are made of the same airplane, so same radar for all of them

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	mov	ecx, 2
	imul	ecx, 0
	movsx	edx, WORD PTR [eax+ecx+68]
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$4[ebp], eax

; 3330 : 			float azLimit = RadarDataTable[vc->RadarType].ScanHalfAngle;

	mov	eax, DWORD PTR _vc$4[ebp]
	movsx	ecx, WORD PTR [eax+56]
	imul	ecx, 58					; 0000003aH
	mov	edx, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	movss	xmm0, DWORD PTR [edx+ecx+24]
	movss	DWORD PTR _azLimit$6[ebp], xmm0

; 3331 : 
; 3332 : 			// If we are not emitting, or if the enemy is outside our radar cone (generic, 60w 60h) and the enemy isn't spotted yet, limit to visual detection only...
; 3333 : 			if (!IsEmitting() || (fabs(az) > azLimit || fabs(el) > 60.0f * DTR)) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	je	SHORT $LN32@CanDetect
	push	ecx
	movss	xmm0, DWORD PTR _az$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv668[ebp]
	movss	xmm0, DWORD PTR tv668[ebp]
	comiss	xmm0, DWORD PTR _azLimit$6[ebp]
	ja	SHORT $LN32@CanDetect
	push	ecx
	movss	xmm0, DWORD PTR _el$9[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv674[ebp]
	movss	xmm0, DWORD PTR tv674[ebp]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	$LN29@CanDetect
$LN32@CanDetect:

; 3334 : 				// We have to go visual. We'll use a generic -30, +90 elevation and -175 to +175 azimuth coverage. If outside, not seen.
; 3335 : 				if (el < -30.0f * DTR || el > 90.0f * DTR || fabs(az) > 175.0f * DTR)

	movss	xmm0, DWORD PTR __real@bf060a91
	comiss	xmm0, DWORD PTR _el$9[ebp]
	ja	SHORT $LN30@CanDetect
	movss	xmm0, DWORD PTR _el$9[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fd9
	ja	SHORT $LN30@CanDetect
	push	ecx
	movss	xmm0, DWORD PTR _az$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv682[ebp]
	movss	xmm0, DWORD PTR tv682[ebp]
	comiss	xmm0, DWORD PTR __real@40437a13
	jbe	SHORT $LN31@CanDetect
$LN30@CanDetect:

; 3336 : 					return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN31@CanDetect:

; 3337 : 
; 3338 : 				// Now that we know the enemy is in our field of view (but not in our RADAR FOV) see if it's close enough to see with our eyes
; 3339 : 				float vdr = (float) GetVisualDetectionRange(mt) * KM_TO_FT;

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	call	?GetVisualDetectionRange@@YAHH@Z	; GetVisualDetectionRange
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _vdr$13[ebp], xmm0

; 3340 : 				vdr *= vdr;

	movss	xmm0, DWORD PTR _vdr$13[ebp]
	mulss	xmm0, DWORD PTR _vdr$13[ebp]
	movss	DWORD PTR _vdr$13[ebp], xmm0

; 3341 : 				if (ds > vdr)

	movss	xmm0, DWORD PTR _ds$[ebp]
	comiss	xmm0, DWORD PTR _vdr$13[ebp]
	jbe	SHORT $LN29@CanDetect

; 3342 : 					return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN29@CanDetect:

; 3343 : 			}
; 3344 : 			// 2001-05-01 ADDED BY S.G. AWACS ARE AFFECTED BY SOJ AS MUCH AS GROUND RADAR...
; 3345 : 			// If we get here, our flight can see the other flight. Now check if we are an AWAC and if so, are jammed by SOJ?
; 3346 : 			if (GetSType() == STYPE_UNIT_AWACS) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	cmp	edx, 5
	jne	$LN21@CanDetect

; 3347 : 				Flight	ecmFlight = ((FlightClass *)ent)->GetECMFlight();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetECMFlight@FlightClass@@QAEPAV1@XZ	; FlightClass::GetECMFlight
	mov	DWORD PTR _ecmFlight$18[ebp], eax

; 3348 : 				if (((FlightClass *)ent)->HasAreaJamming())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+280]
	call	eax
	test	eax, eax
	je	SHORT $LN27@CanDetect

; 3349 : 					ecmFlight = (FlightClass *)ent;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR _ecmFlight$18[ebp], ecx
	jmp	SHORT $LN24@CanDetect
$LN27@CanDetect:

; 3350 : 				else if (ecmFlight) {

	cmp	DWORD PTR _ecmFlight$18[ebp], 0
	je	SHORT $LN24@CanDetect

; 3351 : 					if (!ecmFlight->IsAreaJamming())

	mov	edx, DWORD PTR _ecmFlight$18[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ecmFlight$18[ebp]
	mov	edx, DWORD PTR [eax+272]
	call	edx
	test	eax, eax
	jne	SHORT $LN24@CanDetect

; 3352 : 						ecmFlight = NULL;

	mov	DWORD PTR _ecmFlight$18[ebp], 0
$LN24@CanDetect:

; 3353 : 				}
; 3354 : 
; 3355 : 				if (ecmFlight) {

	cmp	DWORD PTR _ecmFlight$18[ebp], 0
	je	$LN21@CanDetect

; 3356 : 					// Now, here's what we need to do:
; 3357 : 					// 1. For now jamming power has 360 degrees coverage
; 3358 : 					// 2. The radar range will be reduced by the ratio of its normal range and the jammer's range to the radar to the power of two
; 3359 : 					// 3. The jammer is dropping the radar gain, effectively dropping its detection distance
; 3360 : 					// 4. If the flight is outside this new range, it's not detected.
; 3361 : 
; 3362 : 					// Get the range of the SOJ to the radar
; 3363 : 					float jammerRange = DistSqu(ecmFlight->XPos(),ecmFlight->YPos(),XPos(),YPos());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ecmFlight$18[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ecmFlight$18[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?DistSqu@@YAMMMMM@Z			; DistSqu
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _jammerRange$16[ebp]

; 3364 : 
; 3365 : 					// If the SOJ is within the radar normal range, 'adjust' it. If this is now less that ds (our range to the radar), return 0.
; 3366 : 					// SOJ can jamm even if outside the detection range of the radar
; 3367 : 					if (jammerRange < mrs * 2.25f) {

	movss	xmm0, DWORD PTR _mrs$[ebp]
	mulss	xmm0, DWORD PTR __real@40100000
	comiss	xmm0, DWORD PTR _jammerRange$16[ebp]
	jbe	SHORT $LN21@CanDetect

; 3368 : 						jammerRange = jammerRange / (mrs * 2.25f); // No need to check for zero because jammerRange has to be LESS than mrs to go in

	movss	xmm0, DWORD PTR _mrs$[ebp]
	mulss	xmm0, DWORD PTR __real@40100000
	movss	xmm1, DWORD PTR _jammerRange$16[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _jammerRange$16[ebp], xmm1

; 3369 : 						mrs *= jammerRange * jammerRange;

	movss	xmm0, DWORD PTR _jammerRange$16[ebp]
	mulss	xmm0, DWORD PTR _jammerRange$16[ebp]
	mulss	xmm0, DWORD PTR _mrs$[ebp]
	movss	DWORD PTR _mrs$[ebp], xmm0

; 3370 : 						if (ds > mrs)

	movss	xmm0, DWORD PTR _ds$[ebp]
	comiss	xmm0, DWORD PTR _mrs$[ebp]
	jbe	SHORT $LN21@CanDetect

; 3371 : 							// We are being jammed. AWAC don't see well outside their plane so don't try visual detection...
; 3372 : 							return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN21@CanDetect:

; 3373 : 					}
; 3374 : 				}
; 3375 : 			}
; 3376 : 
; 3377 : 		}
; 3378 : 		else {

	jmp	$LN6@CanDetect
$LN36@CanDetect:

; 3379 : 			// Now see if our eyes will do the job (original code was also missing * KM_TO_FT)
; 3380 : 			float vdr = (float) GetVisualDetectionRange(mt) * KM_TO_FT;

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	call	?GetVisualDetectionRange@@YAHH@Z	; GetVisualDetectionRange
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _vdr$11[ebp], xmm0

; 3381 : 			vdr *= vdr;

	movss	xmm0, DWORD PTR _vdr$11[ebp]
	mulss	xmm0, DWORD PTR _vdr$11[ebp]
	movss	DWORD PTR _vdr$11[ebp], xmm0

; 3382 : 			if (ds < vdr)

	movss	xmm0, DWORD PTR _vdr$11[ebp]
	comiss	xmm0, DWORD PTR _ds$[ebp]
	jbe	SHORT $LN19@CanDetect

; 3383 : 				return DETECTED_VISUAL;

	mov	eax, 1
	jmp	$LN39@CanDetect
$LN19@CanDetect:

; 3384 : 
; 3385 : 			// We're not a flight so do battalion tests...
; 3386 : 
; 3387 : 			// First test is are we emitting (then we can use radar coverage)
; 3388 : 			if (IsEmitting()) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	je	$LN6@CanDetect

; 3389 : 				// Here's the deal, we're not a flight but we are unit so we must be a battalion, but just check to be sure...
; 3390 : 				// If we're a batallion, try to use radar coverage masks
; 3391 : 				if (IsBattalion()) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	$LN6@CanDetect

; 3392 : 					GridIndex		x,y;
; 3393 : 					Objective		o = NULL;

	mov	DWORD PTR _o$12[ebp], 0

; 3394 : 					if (Moving())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN16@CanDetect

; 3395 : 						return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect

; 3396 : 					else {

	jmp	SHORT $LN13@CanDetect
$LN16@CanDetect:

; 3397 : 						// Try to use nearby objective's radar mask data
; 3398 : 						GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$8[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 3399 : 						o = FindNearestObjective (x, y, NULL, 1);

	push	1
	push	0
	movzx	eax, WORD PTR _y$10[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$8[ebp]
	push	ecx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$12[ebp], eax

; 3400 : 						if (o && o->HasRadarRanges()) {

	cmp	DWORD PTR _o$12[ebp], 0
	je	SHORT $LN13@CanDetect
	mov	ecx, DWORD PTR _o$12[ebp]
	call	?HasRadarRanges@ObjectiveClass@@QAEHXZ	; ObjectiveClass::HasRadarRanges
	test	eax, eax
	je	SHORT $LN13@CanDetect

; 3401 : 							mrs = o->GetSiteRange(ent);

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$12[ebp]
	call	?GetSiteRange@ObjectiveClass@@QAEMPAVFalconEntity@@@Z ; ObjectiveClass::GetSiteRange
	fstp	DWORD PTR _mrs$[ebp]

; 3402 : 							mrs *= mrs;

	movss	xmm0, DWORD PTR _mrs$[ebp]
	mulss	xmm0, DWORD PTR _mrs$[ebp]
	movss	DWORD PTR _mrs$[ebp], xmm0

; 3403 : 							if (ds > mrs)

	movss	xmm0, DWORD PTR _ds$[ebp]
	comiss	xmm0, DWORD PTR _mrs$[ebp]
	jbe	SHORT $LN13@CanDetect

; 3404 : 								return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN13@CanDetect:

; 3405 : 						}
; 3406 : 					}
; 3407 : 
; 3408 : 					// Get our attached stand off jammer flight, if any
; 3409 : 					// Make sure this SOJ is on station. If ent IS the SOJ, then it emits along the flightpaths as well
; 3410 : 					// This allows the SOJ flight to be protected as it reaches its station waypoints.
; 3411 : 
; 3412 : 					Flight	ecmFlight = ((FlightClass *)ent)->GetECMFlight();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetECMFlight@FlightClass@@QAEPAV1@XZ	; FlightClass::GetECMFlight
	mov	DWORD PTR _ecmFlight$17[ebp], eax

; 3413 : 					if (((FlightClass *)ent)->HasAreaJamming())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+280]
	call	eax
	test	eax, eax
	je	SHORT $LN12@CanDetect

; 3414 : 						ecmFlight = (FlightClass *)ent;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR _ecmFlight$17[ebp], ecx
	jmp	SHORT $LN9@CanDetect
$LN12@CanDetect:

; 3415 : 					else if (ecmFlight) {

	cmp	DWORD PTR _ecmFlight$17[ebp], 0
	je	SHORT $LN9@CanDetect

; 3416 : 						if (!ecmFlight->IsAreaJamming())

	mov	edx, DWORD PTR _ecmFlight$17[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ecmFlight$17[ebp]
	mov	edx, DWORD PTR [eax+272]
	call	edx
	test	eax, eax
	jne	SHORT $LN9@CanDetect

; 3417 : 							ecmFlight = NULL;

	mov	DWORD PTR _ecmFlight$17[ebp], 0
$LN9@CanDetect:

; 3418 : 					}
; 3419 : 
; 3420 : 					if (ecmFlight) {

	cmp	DWORD PTR _ecmFlight$17[ebp], 0
	je	$LN6@CanDetect

; 3421 : 						// Now, here's what we need to do:
; 3422 : 						// 1. For now jamming power has 360 degrees coverage
; 3423 : 						// 2. The radar range will be reduced by the ratio of its normal range and the jammer's range to the radar to the power of two
; 3424 : 						// 3. The jammer is dropping the radar gain, effectively dropping its detection distance
; 3425 : 						// 4. If the flight is outside this new range, it's not detected.
; 3426 : 
; 3427 : 						// Get the range of the SOJ to the radar
; 3428 : 						float jammerRange = DistSqu(ecmFlight->XPos(),ecmFlight->YPos(),XPos(),YPos());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ecmFlight$17[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ecmFlight$17[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?DistSqu@@YAMMMMM@Z			; DistSqu
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _jammerRange$14[ebp]

; 3429 : 
; 3430 : 						// If the SOJ is within the radar normal range, 'adjust' it. If this is now less that ds (our range to the radar), return 0.
; 3431 : 						// SOJ can jamm even if outside the detection range of the radar
; 3432 : 						if (jammerRange < mrs * 2.25f) {

	movss	xmm0, DWORD PTR _mrs$[ebp]
	mulss	xmm0, DWORD PTR __real@40100000
	comiss	xmm0, DWORD PTR _jammerRange$14[ebp]
	jbe	SHORT $LN6@CanDetect

; 3433 : 							jammerRange = jammerRange / (mrs * 2.25f); // No need to check for zero because jammerRange has to be LESS than mrs to go in

	movss	xmm0, DWORD PTR _mrs$[ebp]
	mulss	xmm0, DWORD PTR __real@40100000
	movss	xmm1, DWORD PTR _jammerRange$14[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _jammerRange$14[ebp], xmm1

; 3434 : 							mrs *= jammerRange * jammerRange;

	movss	xmm0, DWORD PTR _jammerRange$14[ebp]
	mulss	xmm0, DWORD PTR _jammerRange$14[ebp]
	mulss	xmm0, DWORD PTR _mrs$[ebp]
	movss	DWORD PTR _mrs$[ebp], xmm0

; 3435 : 							if (ds > mrs)

	movss	xmm0, DWORD PTR _ds$[ebp]
	comiss	xmm0, DWORD PTR _mrs$[ebp]
	jbe	SHORT $LN6@CanDetect

; 3436 : 								return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN6@CanDetect:

; 3437 : 						}
; 3438 : 					}
; 3439 : 				}
; 3440 : 			}
; 3441 : 		}
; 3442 : 
; 3443 : 		// See if enemy flight is beaming us, and go vis only if so
; 3444 : 		float yd = (float)fabs(ent->Yaw() - Yaw());

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv786[ebp]
	movss	xmm0, DWORD PTR tv786[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv830[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv790[ebp]
	movss	xmm0, DWORD PTR tv830[ebp]
	subss	xmm0, DWORD PTR tv790[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR _yd$15[ebp]

; 3445 : 		if (yd > 180*DTR) yd -= PI;

	movss	xmm0, DWORD PTR _yd$15[ebp]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN5@CanDetect
	movss	xmm0, DWORD PTR _yd$15[ebp]
	subss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR _yd$15[ebp], xmm0
$LN5@CanDetect:

; 3446 : 		// 2001-04-02 MODIFIED BY S.G. BEAMING ANGLE TOO WIDE
; 3447 : 		//		if (yd > 60*DTR && yd < 120*DTR)
; 3448 : 		if (yd > 80*DTR && yd < 100*DTR)

	movss	xmm0, DWORD PTR _yd$15[ebp]
	comiss	xmm0, DWORD PTR __real@3fb2b8c1
	jbe	SHORT $LN4@CanDetect
	movss	xmm0, DWORD PTR __real@3fdf66f1
	comiss	xmm0, DWORD PTR _yd$15[ebp]
	jbe	SHORT $LN4@CanDetect

; 3449 : 			return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN4@CanDetect:

; 3450 : 
; 3451 : 		// Stealth aircraft act as if they're flying at double their range
; 3452 : 		UnitClassDataType	*uc = ((Flight)ent)->GetUnitClassData();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$2[ebp], eax

; 3453 : 		// 2001-04-29 MODIFIED BY S.G. IF IT'S A STEALTH AND IT GOT HERE, IT WASN'T DETECTED VISUALLY SO ABORT RIGHT NOW
; 3454 : 		//		if (uc->Flags & VEH_STEALTH && ds*4.0F > mrs)
; 3455 : 		if (uc->Flags & VEH_STEALTH)

	mov	eax, DWORD PTR _uc$2[ebp]
	movzx	ecx, WORD PTR [eax+228]
	and	ecx, 32					; 00000020H
	je	SHORT $LN3@CanDetect

; 3456 : 			return 0;

	xor	eax, eax
	jmp	$LN39@CanDetect
$LN3@CanDetect:

; 3457 : 
; 3458 : 		// If we're an aircraft, we can't see below MEA very well with radar
; 3459 : 		if (IsFlight())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN1@CanDetect

; 3460 : 		{
; 3461 : 			float tl = TheMap.GetMEA(ent->XPos(),ent->YPos());

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	fstp	DWORD PTR _tl$1[ebp]

; 3462 : 			if ((-1*ent->ZPos() < tl) && (ds*16.0f > mrs))

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv818[ebp]
	movss	xmm0, DWORD PTR tv818[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR _tl$1[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@CanDetect
	movss	xmm0, DWORD PTR _ds$[ebp]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR _mrs$[ebp]
	jbe	SHORT $LN1@CanDetect

; 3463 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN39@CanDetect
$LN1@CanDetect:

; 3464 : 		}
; 3465 : 	}
; 3466 : 	return DETECTED_RADAR;

	mov	eax, 2
$LN39@CanDetect:

; 3467 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CanDetect@UnitClass@@UAEHPAVFalconEntity@@@Z ENDP	; UnitClass::CanDetect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
?GetElectronicDetectionRange@UnitClass@@UAEHH@Z PROC	; UnitClass::GetElectronicDetectionRange
; _this$ = ecx

; 3101 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3102 : 	// 2002-02-25 MODIFIED BY S.G. ABOVE 250 HAS A NEW MEANING SO USE THE UNIT ELECTRONIC DETECTION RANGE INSTEAD... WAS IN RP5, FORGOT TO ADD IT TO F4UT!
; 3103 : 	//	return class_data->Detection[mt];
; 3104 : 	if (class_data->Detection[mt] > 250)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+309]
	cmp	eax, 250				; 000000faH
	jle	SHORT $LN1@GetElectro

; 3105 : 	{
; 3106 : 		return 250 + (class_data->Detection[mt] - 250) * 50;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [edx+eax+309]
	sub	eax, 250				; 000000faH
	imul	eax, 50					; 00000032H
	add	eax, 250				; 000000faH
	jmp	SHORT $LN2@GetElectro
$LN1@GetElectro:

; 3107 : 	}
; 3108 : 
; 3109 : 	return class_data->Detection[mt];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [edx+eax+309]
$LN2@GetElectro:

; 3110 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetElectronicDetectionRange@UnitClass@@UAEHH@Z ENDP	; UnitClass::GetElectronicDetectionRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_uc$ = -12						; size = 4
_dr$ = -8						; size = 4
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
?GetDetectionRange@UnitClass@@UAEHH@Z PROC		; UnitClass::GetDetectionRange
; _this$ = ecx

; 3083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3084 : 	int					dr;
; 3085 : 	UnitClassDataType*	uc;
; 3086 : 
; 3087 : 	if (!Real())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@GetDetecti

; 3088 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@GetDetecti
$LN2@GetDetecti:

; 3089 : 
; 3090 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 3091 : 	ShiAssert(uc);
; 3092 : 	// 2001-04-21 MODIFIED BY S.G. ABOVE 250 HAS A NEW MEANING SO USE THE UNIT ELECTRONIC DETECTION RANGE INSTEAD...
; 3093 : 	//	dr = uc->Detection[mt];
; 3094 : 	dr = GetElectronicDetectionRange(mt);

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+420]
	call	edx
	mov	DWORD PTR _dr$[ebp], eax

; 3095 : 	if (dr < VisualDetectionRange[mt])

	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _dr$[ebp]
	cmp	ecx, DWORD PTR ?VisualDetectionRange@@3PAHA[eax*4]
	jge	SHORT $LN1@GetDetecti

; 3096 : 		dr = GetVisualDetectionRange(mt);

	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	call	?GetVisualDetectionRange@@YAHH@Z	; GetVisualDetectionRange
	add	esp, 4
	mov	DWORD PTR _dr$[ebp], eax
$LN1@GetDetecti:

; 3097 : 	return dr;

	mov	eax, DWORD PTR _dr$[ebp]
$LN3@GetDetecti:

; 3098 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDetectionRange@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetDetectionRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
?GetAproxWeaponRange@UnitClass@@UAEHH@Z PROC		; UnitClass::GetAproxWeaponRange
; _this$ = ecx

; 3078 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3079 : 	return class_data->Range[mt];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+301]

; 3080 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAproxWeaponRange@UnitClass@@UAEHH@Z ENDP		; UnitClass::GetAproxWeaponRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_rng$ = -16						; size = 4
_this$ = -12						; size = 4
_mr$ = -8						; size = 4
_i$ = -4						; size = 4
_mt$ = 8						; size = 4
_target$ = 12						; size = 4
?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z PROC ; UnitClass::GetWeaponRange
; _this$ = ecx

; 3063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3064 : 	int		i,rng,mr;
; 3065 : 
; 3066 : 	mr = 0;

	mov	DWORD PTR _mr$[ebp], 0

; 3067 : 	for (i=0; i<VEHICLE_GROUPS_PER_UNIT; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GetWeaponR
$LN3@GetWeaponR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GetWeaponR:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN2@GetWeaponR

; 3068 : 	{
; 3069 : 		rng = GetVehicleRange(i, mt, target); // 2002-03-08 MODIFIED BY S.G. Added target which is passed to GetVehicleRamge

	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+580]
	call	eax
	mov	DWORD PTR _rng$[ebp], eax

; 3070 : 		if (rng > mr)

	mov	ecx, DWORD PTR _rng$[ebp]
	cmp	ecx, DWORD PTR _mr$[ebp]
	jle	SHORT $LN1@GetWeaponR

; 3071 : 			mr = rng;

	mov	edx, DWORD PTR _rng$[ebp]
	mov	DWORD PTR _mr$[ebp], edx
$LN1@GetWeaponR:

; 3072 : 	}

	jmp	SHORT $LN3@GetWeaponR
$LN2@GetWeaponR:

; 3073 : 	return mr;

	mov	eax, DWORD PTR _mr$[ebp]

; 3074 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetWeaponRange@UnitClass@@UAEHHPAVFalconEntity@@@Z ENDP ; UnitClass::GetWeaponRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_uc$ = -16						; size = 4
_str$ = -12						; size = 4
_T$ = -8						; size = 4
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
_range$ = 12						; size = 4
?GetAproxCombatStrength@UnitClass@@UAEHHH@Z PROC	; UnitClass::GetAproxCombatStrength
; _this$ = ecx

; 3039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3040 : 	Unit	T;
; 3041 : 	int		str=0;

	mov	DWORD PTR _str$[ebp], 0

; 3042 : 	UnitClassDataType*	uc;
; 3043 : 
; 3044 : 	if (Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN4@GetAproxCo

; 3045 : 	{
; 3046 : 		T = GetFirstUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _T$[ebp], eax
$LN3@GetAproxCo:

; 3047 : 		while(T != NULL)

	cmp	DWORD PTR _T$[ebp], 0
	je	SHORT $LN2@GetAproxCo

; 3048 : 		{
; 3049 : 			str += T->GetAproxCombatStrength(mt, range);

	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _T$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _T$[ebp]
	mov	eax, DWORD PTR [edx+404]
	call	eax
	add	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _str$[ebp], eax

; 3050 : 			T = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _T$[ebp], eax

; 3051 : 		}

	jmp	SHORT $LN3@GetAproxCo
$LN2@GetAproxCo:

; 3052 : 		return str;

	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN5@GetAproxCo
$LN4@GetAproxCo:

; 3053 : 	}
; 3054 : 
; 3055 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 3056 : 	if (uc && Real() && uc->Range[mt] >= range)

	cmp	DWORD PTR _uc$[ebp], 0
	je	SHORT $LN1@GetAproxCo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	call	eax
	test	eax, eax
	je	SHORT $LN1@GetAproxCo
	mov	ecx, DWORD PTR _uc$[ebp]
	add	ecx, DWORD PTR _mt$[ebp]
	movzx	edx, BYTE PTR [ecx+301]
	cmp	edx, DWORD PTR _range$[ebp]
	jl	SHORT $LN1@GetAproxCo

; 3057 : 		return uc->Strength[mt];

	mov	eax, DWORD PTR _uc$[ebp]
	add	eax, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [eax+293]
	jmp	SHORT $LN5@GetAproxCo
$LN1@GetAproxCo:

; 3058 : 	return 0;

	xor	eax, eax
$LN5@GetAproxCo:

; 3059 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetAproxCombatStrength@UnitClass@@UAEHHH@Z ENDP	; UnitClass::GetAproxCombatStrength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv256 = -48						; size = 4
tv268 = -44						; size = 4
tv248 = -40						; size = 4
tv266 = -36						; size = 4
tv239 = -32						; size = 4
tv264 = -28						; size = 4
tv230 = -24						; size = 4
tv262 = -20						; size = 4
_T$ = -16						; size = 4
_i$ = -12						; size = 4
_str$ = -8						; size = 4
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
_range$ = 12						; size = 4
?GetCombatStrength@UnitClass@@UAEHHH@Z PROC		; UnitClass::GetCombatStrength
; _this$ = ecx

; 3009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3010 : 	Unit	T;
; 3011 : 	int		str=0,i;

	mov	DWORD PTR _str$[ebp], 0

; 3012 : 
; 3013 : 	if (Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN12@GetCombatS

; 3014 : 	{
; 3015 : 		T = GetFirstUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _T$[ebp], eax
$LN11@GetCombatS:

; 3016 : 		while(T != NULL)

	cmp	DWORD PTR _T$[ebp], 0
	je	SHORT $LN10@GetCombatS

; 3017 : 		{
; 3018 : 			str += T->GetCombatStrength(mt, range);

	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _T$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _T$[ebp]
	mov	eax, DWORD PTR [edx+400]
	call	eax
	add	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _str$[ebp], eax

; 3019 : 			T = GetNextUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _T$[ebp], eax

; 3020 : 		}

	jmp	SHORT $LN11@GetCombatS
$LN10@GetCombatS:

; 3021 : 		return str;

	mov	eax, DWORD PTR _str$[ebp]
	jmp	$LN13@GetCombatS
$LN12@GetCombatS:

; 3022 : 	}
; 3023 : 
; 3024 : 	for (i=0; i<VEHICLE_GROUPS_PER_UNIT; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@GetCombatS
$LN8@GetCombatS:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN9@GetCombatS:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN7@GetCombatS

; 3025 : 		str += GetNumVehicles(i) * GetVehicleCombatStrength(i,(MoveType)mt,range);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	esi, eax
	mov	eax, DWORD PTR _range$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+576]
	call	eax
	imul	esi, eax
	add	esi, DWORD PTR _str$[ebp]
	mov	DWORD PTR _str$[ebp], esi
	jmp	SHORT $LN8@GetCombatS
$LN7@GetCombatS:

; 3026 : 	if (GetRClass() == RCLASS_AIR)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	test	eax, eax
	jne	SHORT $LN6@GetCombatS

; 3027 : 		str = FloatToInt32(str * AirExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv262[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	push	ecx
	call	?AirExperienceAdjustment@@YAME@Z	; AirExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv230[ebp]
	movss	xmm0, DWORD PTR tv262[ebp]
	mulss	xmm0, DWORD PTR tv230[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _str$[ebp], eax
	jmp	$LN1@GetCombatS
$LN6@GetCombatS:

; 3028 : 	else if (GetRClass() == RCLASS_NAVAL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	cmp	eax, 3
	jne	SHORT $LN4@GetCombatS

; 3029 : 		str = FloatToInt32(str * NavalExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv264[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	push	edx
	call	?NavalExperienceAdjustment@@YAME@Z	; NavalExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv239[ebp]
	movss	xmm0, DWORD PTR tv264[ebp]
	mulss	xmm0, DWORD PTR tv239[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _str$[ebp], eax
	jmp	$LN1@GetCombatS
$LN4@GetCombatS:

; 3030 : 	else if (GetRClass() == RCLASS_AIRDEFENSE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	cmp	eax, 2
	jne	SHORT $LN2@GetCombatS

; 3031 : 		str = FloatToInt32(str * AirDefenseExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv266[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	eax, al
	push	eax
	call	?AirDefenseExperienceAdjustment@@YAME@Z	; AirDefenseExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv248[ebp]
	movss	xmm0, DWORD PTR tv266[ebp]
	mulss	xmm0, DWORD PTR tv248[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _str$[ebp], eax

; 3032 : 	else

	jmp	SHORT $LN1@GetCombatS
$LN2@GetCombatS:

; 3033 : 		str = FloatToInt32(str * GroundExperienceAdjustment(GetOwner()));

	cvtsi2ss xmm0, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv268[ebp], xmm0
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ecx, al
	push	ecx
	call	?GroundExperienceAdjustment@@YAME@Z	; GroundExperienceAdjustment
	add	esp, 4
	fstp	DWORD PTR tv256[ebp]
	movss	xmm0, DWORD PTR tv268[ebp]
	mulss	xmm0, DWORD PTR tv256[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _str$[ebp], eax
$LN1@GetCombatS:

; 3034 : 	return str;

	mov	eax, DWORD PTR _str$[ebp]
$LN13@GetCombatS:

; 3035 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?GetCombatStrength@UnitClass@@UAEHHH@Z ENDP		; UnitClass::GetCombatStrength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uc$ = -4						; size = 4
_mt$ = 8						; size = 4
_range$ = 12						; size = 4
?GetAproxHitChance@UnitClass@@UAEHHH@Z PROC		; UnitClass::GetAproxHitChance
; _this$ = ecx

; 2995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2996 : 	UnitClassDataType*	uc;
; 2997 : 
; 2998 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 2999 : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN2@GetAproxHi

; 3000 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@GetAproxHi
$LN2@GetAproxHi:

; 3001 : 	if (range < uc->Range[mt])

	mov	eax, DWORD PTR _uc$[ebp]
	add	eax, DWORD PTR _mt$[ebp]
	movzx	ecx, BYTE PTR [eax+301]
	cmp	DWORD PTR _range$[ebp], ecx
	jge	SHORT $LN1@GetAproxHi

; 3002 : 		return FloatToInt32(uc->HitChance[mt] * (1.25F - ((float)range/(uc->Range[mt]+1))));

	mov	edx, DWORD PTR _uc$[ebp]
	add	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [edx+285]
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR _uc$[ebp]
	add	ecx, DWORD PTR _mt$[ebp]
	movzx	edx, BYTE PTR [ecx+301]
	add	edx, 1
	cvtsi2ss xmm2, edx
	divss	xmm1, xmm2
	movss	xmm2, DWORD PTR __real@3fa00000
	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	jmp	SHORT $LN3@GetAproxHi
$LN1@GetAproxHi:

; 3003 : 
; 3004 : 	return 0;

	xor	eax, eax
$LN3@GetAproxHi:

; 3005 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetAproxHitChance@UnitClass@@UAEHHH@Z ENDP		; UnitClass::GetAproxHitChance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_bhc$ = -24						; size = 4
_mv$ = -20						; size = 4
_i$ = -16						; size = 4
_T$ = -12						; size = 4
_hc$ = -8						; size = 4
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
_range$ = 12						; size = 4
?GetHitChance@UnitClass@@UAEHHH@Z PROC			; UnitClass::GetHitChance
; _this$ = ecx

; 2972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2973 : 	Unit		T;
; 2974 : 	int		bhc=0,hc=0,i,mv;

	mov	DWORD PTR _bhc$[ebp], 0
	mov	DWORD PTR _hc$[ebp], 0

; 2975 : 
; 2976 : 	if (Father())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+504]
	call	eax
	test	eax, eax
	je	SHORT $LN6@GetHitChan

; 2977 : 	{
; 2978 : 		T = GetFirstUnitElement();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _T$[ebp], eax
$LN5@GetHitChan:

; 2979 : 		while(T != NULL)

	cmp	DWORD PTR _T$[ebp], 0
	je	SHORT $LN4@GetHitChan

; 2980 : 		{
; 2981 : 			hc += (100-hc) * T->GetHitChance(mt, range) / 100;

	mov	esi, 100				; 00000064H
	sub	esi, DWORD PTR _hc$[ebp]
	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _T$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _T$[ebp]
	mov	eax, DWORD PTR [edx+392]
	call	eax
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _hc$[ebp]
	mov	DWORD PTR _hc$[ebp], eax

; 2982 : 			T = GetNextUnitElement();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+960]
	call	edx
	mov	DWORD PTR _T$[ebp], eax

; 2983 : 		}

	jmp	SHORT $LN5@GetHitChan
$LN4@GetHitChan:

; 2984 : 		return hc;

	mov	eax, DWORD PTR _hc$[ebp]
	jmp	$LN7@GetHitChan
$LN6@GetHitChan:

; 2985 : 	}
; 2986 : 
; 2987 : 	mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	edx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$[ebp], edx

; 2988 : 	for (i=0; i<mv; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@GetHitChan
$LN2@GetHitChan:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@GetHitChan:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mv$[ebp]
	jge	SHORT $LN1@GetHitChan

; 2989 : 		hc += (100-hc) * GetVehicleHitChance(i,(MoveType)mt,range,0) / 100;

	mov	esi, 100				; 00000064H
	sub	esi, DWORD PTR _hc$[ebp]
	push	0
	mov	edx, DWORD PTR _range$[ebp]
	push	edx
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+572]
	call	edx
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _hc$[ebp]
	mov	DWORD PTR _hc$[ebp], eax
	jmp	SHORT $LN2@GetHitChan
$LN1@GetHitChan:

; 2990 : 	return bhc;

	mov	eax, DWORD PTR _bhc$[ebp]
$LN7@GetHitChan:

; 2991 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?GetHitChance@UnitClass@@UAEHHH@Z ENDP			; UnitClass::GetHitChance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_d$1 = -12						; size = 4
_p$2 = -8						; size = 4
_this$ = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_object$ = 16						; size = 4
?GetDivisionName@UnitClass@@UAEPADPADHH@Z PROC		; UnitClass::GetDivisionName
; _this$ = ecx

; 2945 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2946 : 	if (GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	jne	$LN9@GetDivisio

; 2947 : 	{
; 2948 : 		if (Parent() && GetUnitDivision() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	SHORT $LN8@GetDivisio
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@GetDivisio

; 2949 : 			GetName(buffer,size,object);

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	jmp	$LN7@GetDivisio
$LN8@GetDivisio:

; 2950 : 		else if (GetUnitDivision() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@GetDivisio

; 2951 : 		{
; 2952 : 			Unit	p = GetUnitParent();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _p$2[ebp], eax

; 2953 : 			if (p)

	cmp	DWORD PTR _p$2[ebp], 0
	je	SHORT $LN5@GetDivisio

; 2954 : 				p->GetDivisionName(buffer,size,object);

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _p$2[ebp]
	mov	eax, DWORD PTR [edx+388]
	call	eax
$LN5@GetDivisio:

; 2955 : 		}
; 2956 : 		else

	jmp	SHORT $LN7@GetDivisio
$LN6@GetDivisio:

; 2957 : 		{
; 2958 : 			Division	d = GetDivisionByUnit(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?GetDivisionByUnit@@YAPAVDivisionClass@@PAVUnitClass@@@Z ; GetDivisionByUnit
	add	esp, 4
	mov	DWORD PTR _d$1[ebp], eax

; 2959 : 			if (d)

	cmp	DWORD PTR _d$1[ebp], 0
	je	SHORT $LN3@GetDivisio

; 2960 : 				d->GetName(buffer,size,object);

	mov	edx, DWORD PTR _object$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _d$1[ebp]
	call	?GetName@DivisionClass@@QAEPADPADHH@Z	; DivisionClass::GetName

; 2961 : 			else

	jmp	SHORT $LN7@GetDivisio
$LN3@GetDivisio:

; 2962 : 				::GetDivisionName(GetUnitDivision(),buffer,size,object);

	mov	edx, DWORD PTR _object$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+904]
	call	edx
	push	eax
	call	?GetDivisionName@@YAPADHPADHH@Z		; GetDivisionName
	add	esp, 16					; 00000010H
$LN7@GetDivisio:

; 2963 : 		}
; 2964 : 	}
; 2965 : 	else

	jmp	SHORT $LN1@GetDivisio
$LN9@GetDivisio:

; 2966 : 		buffer = GetName(buffer,size,object);

	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	DWORD PTR _buffer$[ebp], eax
$LN1@GetDivisio:

; 2967 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 2968 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetDivisionName@UnitClass@@UAEPADPADHH@Z ENDP		; UnitClass::GetDivisionName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_d$1 = -176						; size = 4
_p$2 = -172						; size = 4
_this$ = -168						; size = 4
_temp1$ = -164						; size = 80
_temp2$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_object$ = 16						; size = 4
?GetFullName@UnitClass@@UAEPADPADHH@Z PROC		; UnitClass::GetFullName
; _this$ = ecx

; 2904 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2905 : 	_TCHAR	temp1[80],temp2[80];
; 2906 : 
; 2907 : 	if (GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	jne	$LN10@GetFullNam

; 2908 : 	{
; 2909 : 		if (Parent() && GetUnitDivision() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	SHORT $LN9@GetFullNam
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	test	eax, eax
	jne	SHORT $LN9@GetFullNam

; 2910 : 		{
; 2911 : 			ReadIndexedString(167, temp2, 63);

	push	63					; 0000003fH
	lea	ecx, DWORD PTR _temp2$[ebp]
	push	ecx
	push	167					; 000000a7H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 2912 : 			_sntprintf(buffer,size,"%s %s",GetName(temp1,size,object),temp2);

	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp1$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	push	eax
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 20					; 00000014H
	jmp	$LN8@GetFullNam
$LN9@GetFullNam:

; 2913 : 		}
; 2914 : 		else if (Parent())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	$LN7@GetFullNam

; 2915 : 		{
; 2916 : 			Division	d = GetDivisionByUnit(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?GetDivisionByUnit@@YAPAVDivisionClass@@PAVUnitClass@@@Z ; GetDivisionByUnit
	add	esp, 4
	mov	DWORD PTR _d$1[ebp], eax

; 2917 : 			if (d)

	cmp	DWORD PTR _d$1[ebp], 0
	je	SHORT $LN6@GetFullNam

; 2918 : 				_sntprintf(buffer,size,gUnitNameFormat,GetName(temp1,size,object),d->GetName(temp2,63,object));

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	push	63					; 0000003fH
	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _d$1[ebp]
	call	?GetName@DivisionClass@@QAEPADPADHH@Z	; DivisionClass::GetName
	push	eax
	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp1$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	push	eax
	push	OFFSET ?gUnitNameFormat@@3PADA		; gUnitNameFormat
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 20					; 00000014H

; 2919 : 			else

	jmp	SHORT $LN5@GetFullNam
$LN6@GetFullNam:

; 2920 : 				_sntprintf(buffer,size,gUnitNameFormat,GetName(temp1,size,object),::GetDivisionName(GetUnitDivision(),temp2,79,object));

	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	push	79					; 0000004fH
	lea	ecx, DWORD PTR _temp2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+904]
	call	edx
	push	eax
	call	?GetDivisionName@@YAPADHPADHH@Z		; GetDivisionName
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp1$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	push	eax
	push	OFFSET ?gUnitNameFormat@@3PADA		; gUnitNameFormat
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 20					; 00000014H
$LN5@GetFullNam:

; 2921 : 		}
; 2922 : 		else

	jmp	$LN8@GetFullNam
$LN7@GetFullNam:

; 2923 : 		{
; 2924 : 			Unit	p;
; 2925 : 			p = GetUnitParent();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _p$2[ebp], eax

; 2926 : 			if (!p)

	cmp	DWORD PTR _p$2[ebp], 0
	jne	SHORT $LN3@GetFullNam

; 2927 : 			{
; 2928 : 				ReadIndexedString(167, temp2, 63);

	push	63					; 0000003fH
	lea	ecx, DWORD PTR _temp2$[ebp]
	push	ecx
	push	167					; 000000a7H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 2929 : 				_sntprintf(buffer,size,"%s %s",GetName(temp1,size,object),temp2);

	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp1$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	push	eax
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 20					; 00000014H

; 2930 : 			}
; 2931 : 			else

	jmp	SHORT $LN8@GetFullNam
$LN3@GetFullNam:

; 2932 : 				_sntprintf(buffer,size,gUnitNameFormat,GetName(temp1,size,object),p->GetFullName(temp2,size,object));

	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$2[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _p$2[ebp]
	mov	eax, DWORD PTR [edx+384]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	lea	eax, DWORD PTR _temp1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	push	eax
	push	OFFSET ?gUnitNameFormat@@3PADA		; gUnitNameFormat
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__snprintf
	add	esp, 20					; 00000014H
$LN8@GetFullNam:

; 2933 : 		}
; 2934 : 	}
; 2935 : 	else

	jmp	SHORT $LN1@GetFullNam
$LN10@GetFullNam:

; 2936 : 		buffer = GetName(buffer,size,object);

	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	DWORD PTR _buffer$[ebp], eax
$LN1@GetFullNam:

; 2937 : 
; 2938 : 	// _sntprintf should do this for us, but for some reason it sometimes doesn't
; 2939 : 	buffer[size-1] = 0;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _size$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 2940 : 
; 2941 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]

; 2942 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetFullName@UnitClass@@UAEPADPADHH@Z ENDP		; UnitClass::GetFullName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_name_id$ = -136					; size = 4
$T1 = -132						; size = 4
_this$ = -128						; size = 4
_junk$2 = -124						; size = 30
_temp3$ = -92						; size = 30
_temp2$ = -60						; size = 30
_format$ = -28						; size = 10
_temp1$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetName@UnitClass@@UAEPADPADHH@Z PROC			; UnitClass::GetName
; _this$ = ecx

; 2864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2865 : 	int		name_id;
; 2866 : 	_TCHAR	temp1[10],temp2[30],temp3[30],format[10];
; 2867 : 
; 2868 : 	name_id = GetUnitNameID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	mov	DWORD PTR _name_id$[ebp], eax

; 2869 : 	GetNumberName(name_id,temp1);

	lea	eax, DWORD PTR _temp1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name_id$[ebp]
	push	ecx
	call	?GetNumberName@@YAPADHPAD@Z		; GetNumberName
	add	esp, 8

; 2870 : 	_tcscpy(format,"%s %s %s");

	push	OFFSET ??_C@_08EPEHIMMI@?$CFs?5?$CFs?5?$CFs?$AA@
	lea	edx, DWORD PTR _format$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 2871 : 	_tcsnccpy(temp2,class_data->Name,29);

	push	29					; 0000001dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	add	ecx, 230				; 000000e6H
	push	ecx
	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	call	__tcsnccpy
	add	esp, 12					; 0000000cH

; 2872 : 	temp2[29] = 0;

	mov	eax, 1
	imul	eax, 29					; 0000001dH
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 30			; 0000001eH
	jae	SHORT $LN10@GetName
	jmp	SHORT $LN11@GetName
$LN10@GetName:
	call	___report_rangecheckfailure
$LN11@GetName:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _temp2$[ebp+ecx], 0

; 2873 : 
; 2874 : 	if (gLangIDNum == F4LANG_GERMAN)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 3		; gLangIDNum
	jne	SHORT $LN7@GetName

; 2875 : 	{
; 2876 : 		// Replace space with hyphen, if necessary
; 2877 : 		if (temp2[_tcslen(temp2)-1] == '-')

	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	movsx	eax, BYTE PTR _temp2$[ebp+eax-1]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN6@GetName

; 2878 : 			_tcscpy(format,"%s %s%s");

	push	OFFSET ??_C@_07LLFIICBM@?$CFs?5?$CFs?$CFs?$AA@
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN6@GetName:

; 2879 : 	}

	jmp	SHORT $LN5@GetName
$LN7@GetName:

; 2880 : 	else if (gLangIDNum == F4LANG_FRENCH)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 4		; gLangIDNum
	jne	SHORT $LN5@GetName

; 2881 : 	{
; 2882 : 		if (name_id == 1 && IsBattalion())

	cmp	DWORD PTR _name_id$[ebp], 1
	jne	SHORT $LN5@GetName
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	je	SHORT $LN5@GetName

; 2883 : 		{
; 2884 : 			_TCHAR	junk[30];
; 2885 : 
; 2886 : 			ReadIndexedString(19, junk, 5);

	push	5
	lea	eax, DWORD PTR _junk$2[ebp]
	push	eax
	push	19					; 00000013H
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 2887 : 			_tcscpy(temp1,"1");

	push	OFFSET ??_C@_01HIHLOKLC@1?$AA@
	lea	ecx, DWORD PTR _temp1$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2888 : 			_tcscat(temp1,junk);

	lea	edx, DWORD PTR _junk$2[ebp]
	push	edx
	lea	eax, DWORD PTR _temp1$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN5@GetName:

; 2889 : 		}
; 2890 : 	}
; 2891 : 
; 2892 : 	GetSizeName(GetDomain(),GetType(),temp3);

	lea	ecx, DWORD PTR _temp3$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	push	eax
	call	?GetSizeName@@YAPADHHPAD@Z		; GetSizeName
	add	esp, 12					; 0000000cH

; 2893 : 
; 2894 : 	ShiAssert(((int) (_tcslen(temp1)+_tcslen(temp2)+_tcslen(temp3)+3)) < size);
; 2895 : 
; 2896 : 	if (gLangIDNum >= F4LANG_SPANISH)

	cmp	DWORD PTR ?gLangIDNum@@3HA, 5		; gLangIDNum
	jl	SHORT $LN2@GetName

; 2897 : 		_sntprintf(buffer,size,format,temp1,temp3,temp2);

	lea	ecx, DWORD PTR _temp2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp3$[ebp]
	push	edx
	lea	eax, DWORD PTR _temp1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__snprintf
	add	esp, 24					; 00000018H

; 2898 : 	else

	jmp	SHORT $LN1@GetName
$LN2@GetName:

; 2899 : 		_sntprintf(buffer,size,format,temp1,temp2,temp3);

	lea	ecx, DWORD PTR _temp3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp2$[ebp]
	push	edx
	lea	eax, DWORD PTR _temp1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__snprintf
	add	esp, 24					; 00000018H
$LN1@GetName:

; 2900 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
$LN9@GetName:

; 2901 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetName@UnitClass@@UAEPADPADHH@Z ENDP			; UnitClass::GetName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uc$ = -4						; size = 4
?GetDamageModifiers@UnitClass@@UAEPAEXZ PROC		; UnitClass::GetDamageModifiers
; _this$ = ecx

; 4077 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4078 : 	UnitClassDataType*	uc;
; 4079 : 
; 4080 : 	uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 4081 : 	if (!uc)

	cmp	DWORD PTR _uc$[ebp], 0
	jne	SHORT $LN1@GetDamageM

; 4082 : 		return DefaultDamageMods;

	mov	eax, OFFSET ?DefaultDamageMods@@3PAEA	; DefaultDamageMods
	jmp	SHORT $LN2@GetDamageM
$LN1@GetDamageM:

; 4083 : 	return uc->DamageMod;

	mov	eax, DWORD PTR _uc$[ebp]
	add	eax, 317				; 0000013dH
$LN2@GetDamageM:

; 4084 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDamageModifiers@UnitClass@@UAEPAEXZ ENDP		; UnitClass::GetDamageModifiers
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_mv$ = -48						; size = 4
_shot$ = -44						; size = 4
_vc$ = -40						; size = 4
_max_salvos$ = -36					; size = 4
_gotit$ = -32						; size = 4
_total$ = -28						; size = 4
_bw$ = -24						; size = 4
_sup$ = -20						; size = 4
_cw$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_dam$ = 8						; size = 4
_m$ = 12						; size = 4
_w$ = 16						; size = 4
_wc$ = 20						; size = 4
_dist$ = 24						; size = 4
?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z PROC ; UnitClass::CollectWeapons
; _this$ = ecx

; 4087 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4088 : 	int			cw=0,bw,i,j,gotit,shot,total=0,sup,max_salvos=255;

	mov	DWORD PTR _cw$[ebp], 0
	mov	DWORD PTR _total$[ebp], 0
	mov	DWORD PTR _max_salvos$[ebp], 255	; 000000ffH

; 4089 : 	VehicleClassDataType*	vc;
; 4090 : 
; 4091 : 	// Quick check if we're totally out of supply
; 4092 : 	sup = GetUnitSupply();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+776]
	call	eax
	mov	DWORD PTR _sup$[ebp], eax

; 4093 : 	if (!sup)

	cmp	DWORD PTR _sup$[ebp], 0
	jne	SHORT $LN25@CollectWea

; 4094 : 		return 0;

	xor	eax, eax
	jmp	$LN26@CollectWea
$LN25@CollectWea:

; 4095 : 
; 4096 : 	// KCK HACK: Ground units only take one salvo at a flight per weapon type (guided weapons only)
; 4097 : 	if (MOVE_AIR(m) && !IsFlight())

	cmp	DWORD PTR _m$[ebp], 5
	je	SHORT $LN23@CollectWea
	cmp	DWORD PTR _m$[ebp], 4
	jne	SHORT $LN24@CollectWea
$LN23@CollectWea:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	jne	SHORT $LN24@CollectWea

; 4098 : 		max_salvos = 1;

	mov	DWORD PTR _max_salvos$[ebp], 1
$LN24@CollectWea:

; 4099 : 
; 4100 : 	if (GetTeam() < 0 || F4IsBadCodePtr((FARPROC) TeamInfo[GetTeam()]) || GetRClass() < 0 || F4IsBadReadPtr(&(TeamInfo[GetTeam()]->max_vehicle[GetRClass()]), sizeof(uchar))) // JB 010305 CTD

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jl	SHORT $LN21@CollectWea
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	push	ecx
	call	?F4IsBadCodePtr@@YA_NPAX@Z		; F4IsBadCodePtr
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@CollectWea
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	test	eax, eax
	jl	SHORT $LN21@CollectWea
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	lea	edx, DWORD PTR [esi+eax+872]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@CollectWea
$LN21@CollectWea:

; 4101 : 		return 0; // JB 010305 CTD

	xor	eax, eax
	jmp	$LN26@CollectWea
$LN22@CollectWea:

; 4102 : 
; 4103 : 	int mv = TeamInfo[GetTeam()]->max_vehicle[GetRClass()];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	esi, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRClass@UnitClass@@QAEHXZ		; UnitClass::GetRClass
	movzx	edx, BYTE PTR [esi+eax+872]
	mov	DWORD PTR _mv$[ebp], edx

; 4104 : 	for (i=0; i<mv && class_data->VehicleType[i] && cw<MAX_TYPES_PER_CAMP_FIRE_MESSAGE && wc[0]<max_salvos; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@CollectWea
$LN19@CollectWea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@CollectWea:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mv$[ebp]
	jge	$LN18@CollectWea
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2+68]
	test	edx, edx
	je	$LN18@CollectWea
	cmp	DWORD PTR _cw$[ebp], 8
	jge	$LN18@CollectWea
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _wc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, DWORD PTR _max_salvos$[ebp]
	jge	$LN18@CollectWea

; 4105 : 	{
; 4106 : 		bw = GetBestVehicleWeapon(i,dam,m,dist,&j);

	lea	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dist$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	mov	eax, DWORD PTR _dam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+568]
	call	edx
	mov	DWORD PTR _bw$[ebp], eax

; 4107 : 		if (bw > 0 && CanShootWeapon(bw))

	cmp	DWORD PTR _bw$[ebp], 0
	jle	$LN17@CollectWea
	mov	eax, DWORD PTR _bw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+464]
	call	eax
	test	eax, eax
	je	$LN17@CollectWea

; 4108 : 		{
; 4109 : 			for (j=0,gotit=0; j<cw && !gotit; j++)

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _gotit$[ebp], 0
	jmp	SHORT $LN16@CollectWea
$LN15@CollectWea:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN16@CollectWea:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _cw$[ebp]
	jge	SHORT $LN14@CollectWea
	cmp	DWORD PTR _gotit$[ebp], 0
	jne	SHORT $LN14@CollectWea

; 4110 : 			{
; 4111 : 				if (w[j] == bw)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, DWORD PTR _bw$[ebp]
	jne	SHORT $LN13@CollectWea

; 4112 : 				{
; 4113 : 					wc[j] += GetNumVehicles(i) * GetWeaponFireRate(w[j]);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	push	eax
	call	?GetWeaponFireRate@@YAHH@Z		; GetWeaponFireRate
	add	esp, 4
	imul	esi, eax
	mov	ecx, DWORD PTR _wc$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	edx, esi
	mov	eax, DWORD PTR _wc$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], dl

; 4114 : 					gotit = 1;

	mov	DWORD PTR _gotit$[ebp], 1
$LN13@CollectWea:

; 4115 : 				}
; 4116 : 			}

	jmp	SHORT $LN15@CollectWea
$LN14@CollectWea:

; 4117 : 			if (!gotit)

	cmp	DWORD PTR _gotit$[ebp], 0
	jne	$LN17@CollectWea

; 4118 : 			{
; 4119 : 				w[cw] = bw;

	mov	ecx, DWORD PTR _cw$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	mov	ax, WORD PTR _bw$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 4120 : 				wc[cw] = GetNumVehicles(i) * GetWeaponFireRate(w[cw]);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	ebx, eax
	mov	edx, DWORD PTR _cw$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	push	ecx
	call	?GetWeaponFireRate@@YAHH@Z		; GetWeaponFireRate
	add	esp, 4
	imul	ebx, eax
	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, DWORD PTR _cw$[ebp]
	mov	BYTE PTR [edx], bl

; 4121 : 				if (wc[cw] > max_salvos && (WeaponDataTable[w[cw]].GuidanceFlags & WEAP_GUIDED_MASK))

	mov	eax, DWORD PTR _wc$[ebp]
	add	eax, DWORD PTR _cw$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _max_salvos$[ebp]
	jle	SHORT $LN11@CollectWea
	mov	edx, DWORD PTR _cw$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	and	eax, 31					; 0000001fH
	je	SHORT $LN11@CollectWea

; 4122 : 					wc[cw] = GetWeaponFireRate(w[cw]);

	mov	ecx, DWORD PTR _cw$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	push	eax
	call	?GetWeaponFireRate@@YAHH@Z		; GetWeaponFireRate
	add	esp, 4
	mov	ecx, DWORD PTR _wc$[ebp]
	add	ecx, DWORD PTR _cw$[ebp]
	mov	BYTE PTR [ecx], al
$LN11@CollectWea:

; 4123 : 				cw++;

	mov	edx, DWORD PTR _cw$[ebp]
	add	edx, 1
	mov	DWORD PTR _cw$[ebp], edx
$LN17@CollectWea:

; 4124 : 			}
; 4125 : 		}
; 4126 : 		// Total this vehicle's ammunition for supply purposes
; 4127 : 		vc = GetVehicleClassData(class_data->VehicleType[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 4128 : 		for (j=0; j<HARDPOINT_MAX && vc; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@CollectWea
$LN9@CollectWea:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@CollectWea:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jge	SHORT $LN8@CollectWea
	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN8@CollectWea

; 4129 : 		{
; 4130 : 			if (vc->Weapons[j] < 255)

	mov	edx, DWORD PTR _vc$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR [edx+130]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN7@CollectWea

; 4131 : 				total += vc->Weapons[j];

	mov	ecx, DWORD PTR _vc$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR [ecx+130]
	add	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR _total$[ebp], edx
$LN7@CollectWea:

; 4132 : 		}

	jmp	SHORT $LN9@CollectWea
$LN8@CollectWea:

; 4133 : 	}

	jmp	$LN19@CollectWea
$LN18@CollectWea:

; 4134 : 	if (!total)

	cmp	DWORD PTR _total$[ebp], 0
	jne	SHORT $LN6@CollectWea

; 4135 : 		return 0;

	xor	eax, eax
	jmp	$LN26@CollectWea
$LN6@CollectWea:

; 4136 : 
; 4137 : 	// Now do supply
; 4138 : 	for (i=0,shot=0; i<cw; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _shot$[ebp], 0
	jmp	SHORT $LN5@CollectWea
$LN4@CollectWea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@CollectWea:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cw$[ebp]
	jge	SHORT $LN3@CollectWea

; 4139 : 	{
; 4140 : 		wc[i] = (wc[i]*sup)/100;		// Adjust for supply

	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	imul	eax, DWORD PTR _sup$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], al

; 4141 : 		if (wc[i] < 1)

	mov	eax, DWORD PTR _wc$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jge	SHORT $LN2@CollectWea

; 4142 : 			wc[i] = 1;

	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 1
$LN2@CollectWea:

; 4143 : 		shot += wc[i];

	mov	eax, DWORD PTR _wc$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _shot$[ebp]
	mov	DWORD PTR _shot$[ebp], ecx

; 4144 : 	}

	jmp	SHORT $LN4@CollectWea
$LN3@CollectWea:

; 4145 : 	//	sup = GetUnitSupply() - ((GetUnitSupply() * shot*2) / total) - 2;		// The '*2' for shots makes up for non-popular weapons not getting shot
; 4146 : 	sup = GetUnitSupply() - ((GetUnitSupply() * shot) / total);		// The '*2' for shots makes up for non-popular weapons not getting shot

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+776]
	call	edx
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+776]
	call	eax
	imul	eax, DWORD PTR _shot$[ebp]
	cdq
	idiv	DWORD PTR _total$[ebp]
	sub	esi, eax
	mov	DWORD PTR _sup$[ebp], esi

; 4147 : 	if (sup < 0)

	jns	SHORT $LN1@CollectWea

; 4148 : 		sup = 0;

	mov	DWORD PTR _sup$[ebp], 0
$LN1@CollectWea:

; 4149 : 	SetUnitSupply(sup);

	mov	ecx, DWORD PTR _sup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+748]
	call	edx

; 4150 : 	return cw;

	mov	eax, DWORD PTR _cw$[ebp]
$LN26@CollectWea:

; 4151 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?CollectWeapons@UnitClass@@UAEHPAEW4MoveType@@QAFQAEH@Z ENDP ; UnitClass::CollectWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -44						; size = 8
_n$ = -36						; size = 4
_islocal$ = -32						; size = 4
_pilot$ = -28						; size = 4
_i$ = -24						; size = 4
_lost$ = -20						; size = 4
_addhulk$ = -16						; size = 4
_v$ = -12						; size = 4
_this$ = -8						; size = 4
_addcrater$ = -1					; size = 1
_data$ = 8						; size = 4
_shooter$ = 12						; size = 4
_dtm$ = 16						; size = 4
?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z PROC ; UnitClass::DecodeDamageData
; _this$ = ecx

; 877  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 	int		lost,i,n,v,pilot=255,islocal = IsLocal(),addhulk=0;

	mov	DWORD PTR _pilot$[ebp], 255		; 000000ffH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	mov	DWORD PTR _islocal$[ebp], eax
	mov	DWORD PTR _addhulk$[ebp], 0

; 879  : 	uchar	addcrater;
; 880  : 
; 881  : 	// This 'decode' is called for both local and remote entities.
; 882  : 	// However, Local entities have already suffered the losses, so 
; 883  : 	// Only need to do the kill evaluation
; 884  : 	lost = *data;		data++;

	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _lost$[ebp], edx
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax

; 885  : 	for (i=0; i<lost; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@DecodeDama
$LN16@DecodeDama:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN17@DecodeDama:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _lost$[ebp]
	jge	$LN15@DecodeDama

; 886  : 	{
; 887  : 		v = *data;		data++;

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 1
	mov	DWORD PTR _data$[ebp], edx

; 888  : 		if (!islocal)

	cmp	DWORD PTR _islocal$[ebp], 0
	jne	SHORT $LN14@DecodeDama

; 889  : 		{
; 890  : 			// Score the kill
; 891  : 			n = GetNumVehicles(v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	DWORD PTR _n$[ebp], eax

; 892  : 			if (n)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN14@DecodeDama

; 893  : 			{
; 894  : 				SetNumVehicles(v,n-1);

	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles

; 895  : 				losses++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+221]
	add	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+221], cl
$LN14@DecodeDama:

; 896  : 			}
; 897  : 		}
; 898  : 		if (!addhulk && IsBattalion())

	cmp	DWORD PTR _addhulk$[ebp], 0
	jne	SHORT $LN12@DecodeDama
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN12@DecodeDama

; 899  : 			addhulk = Falcon4ClassTable[GetVehicleID(v)].visType[VIS_DESTROYED];

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	edx, ax
	imul	edx, 81					; 00000051H
	add	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, 2
	imul	eax, 3
	movsx	ecx, WORD PTR [edx+eax+60]
	mov	DWORD PTR _addhulk$[ebp], ecx
$LN12@DecodeDama:

; 900  : 		// Extra data for flights
; 901  : 		if (IsFlight())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN11@DecodeDama

; 902  : 		{
; 903  : 			pilot = *data;			

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _pilot$[ebp], ecx

; 904  : 			data++;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 1
	mov	DWORD PTR _data$[ebp], edx

; 905  : 			((Flight)this)->plane_stats[pilot] = *data;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _pilot$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+416], dl

; 906  : 			data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax

; 907  : 			//((Flight)this)->MakeFlightDirty (DIRTY_PLANE_STATS, DDP[33].priority);
; 908  : 			((Flight)this)->MakeFlightDirty (DIRTY_PLANE_STATS, SEND_RELIABLE);

	push	1048576					; 00100000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeFlightDirty@FlightClass@@QAEXW4Dirty_Flight@@W4Dirtyness@@@Z ; FlightClass::MakeFlightDirty
$LN11@DecodeDama:

; 909  : 		}
; 910  : 
; 911  : 		// Check for radar being down
; 912  : 		if (class_data->RadarVehicle == v && IsEmitting())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	movzx	eax, BYTE PTR [edx+328]
	cmp	eax, DWORD PTR _v$[ebp]
	jne	SHORT $LN10@DecodeDama
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	je	SHORT $LN10@DecodeDama

; 913  : 			SetEmitting(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEmitting@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetEmitting
$LN10@DecodeDama:

; 914  : 
; 915  : 		// Generate a death message if we or the shooter is a member of the package 
; 916  : 		if (dtm)

	cmp	DWORD PTR _dtm$[ebp], 0
	je	SHORT $LN9@DecodeDama

; 917  : 		{
; 918  : 			dtm->dataBlock.dPilotID = pilot;

	mov	ecx, DWORD PTR _dtm$[ebp]
	mov	dl, BYTE PTR _pilot$[ebp]
	mov	BYTE PTR [ecx+66], dl

; 919  : 			dtm->dataBlock.dIndex = GetVehicleID(v) + VU_LAST_ENTITY_TYPE;

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _dtm$[ebp]
	mov	WORD PTR [edx+67], cx

; 920  : 			// Update squadron and pilot statistics
; 921  : 			EvaluateKill(dtm,NULL,shooter,NULL,this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _shooter$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _dtm$[ebp]
	push	edx
	call	?EvaluateKill@@YAXPAVFalconDeathMessage@@PAVSimBaseClass@@PAVCampBaseClass@@12@Z ; EvaluateKill
	add	esp, 20					; 00000014H
	jmp	SHORT $LN8@DecodeDama
$LN9@DecodeDama:

; 922  : 		}
; 923  : 		else if (shooter->IsFlight())

	mov	eax, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN8@DecodeDama

; 924  : 			EvaluateKill(dtm,NULL,shooter,NULL,this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _shooter$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _dtm$[ebp]
	push	eax
	call	?EvaluateKill@@YAXPAVFalconDeathMessage@@PAVSimBaseClass@@PAVCampBaseClass@@12@Z ; EvaluateKill
	add	esp, 20					; 00000014H
$LN8@DecodeDama:

; 925  : 	}

	jmp	$LN16@DecodeDama
$LN15@DecodeDama:

; 926  : 	SetUnitMorale(*data);	data++;

	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+752]
	call	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 1
	mov	DWORD PTR _data$[ebp], ecx

; 927  : 
; 928  : 	// Add any necessary craters/hulks
; 929  : 	addcrater = *data;		data++;

	mov	edx, DWORD PTR _data$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _addcrater$[ebp], al
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 1
	mov	DWORD PTR _data$[ebp], ecx

; 930  : 	ShiAssert(addcrater < 10);
; 931  : 	if (addhulk)

	cmp	DWORD PTR _addhulk$[ebp], 0
	je	SHORT $LN6@DecodeDama

; 932  : 		AddHulk(this, addhulk);

	mov	edx, DWORD PTR _addhulk$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AddHulk@@YAXPAVFalconEntity@@H@Z	; AddHulk
	add	esp, 8
$LN6@DecodeDama:

; 933  : 	if (addcrater)

	movzx	ecx, BYTE PTR _addcrater$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@DecodeDama

; 934  : 		AddMissCraters (this, addcrater);

	movzx	edx, BYTE PTR _addcrater$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AddMissCraters@@YAXPAVFalconEntity@@H@Z ; AddMissCraters
	add	esp, 8
$LN5@DecodeDama:

; 935  : 
; 936  : 	// Record the final state, to keep remote entities consitant
; 937  : 	if (!islocal)

	cmp	DWORD PTR _islocal$[ebp], 0
	jne	SHORT $LN4@DecodeDama

; 938  : 		memcpy(&roster,data,sizeof(fourbyte));			data += sizeof(fourbyte);

	push	4
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@DecodeDama:
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 4
	mov	DWORD PTR _data$[ebp], eax

; 939  : 
; 940  : 	// Special case shit to do..
; 941  : 	if (lost && IsFlight())

	cmp	DWORD PTR _lost$[ebp], 0
	je	SHORT $LN3@DecodeDama
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN3@DecodeDama

; 942  : 		UpdateSquadronStatus((Flight)this, FALSE, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UpdateSquadronStatus@@YAXPAVFlightClass@@HH@Z ; UpdateSquadronStatus
	add	esp, 12					; 0000000cH
	jmp	$LN2@DecodeDama
$LN3@DecodeDama:

; 943  : 	else if (lost && islocal && GetDomain() == DOMAIN_SEA && GetType() == TYPE_TASKFORCE && GetSType() == STYPE_UNIT_CARRIER && !GetNumVehicles(0))

	cmp	DWORD PTR _lost$[ebp], 0
	je	$LN2@DecodeDama
	cmp	DWORD PTR _islocal$[ebp], 0
	je	$LN2@DecodeDama
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	cmp	edx, 4
	jne	SHORT $LN2@DecodeDama
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@DecodeDama
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 3
	jne	SHORT $LN2@DecodeDama
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	jne	SHORT $LN2@DecodeDama

; 944  : 	{
; 945  : 		// A carrier is missing
; 946  : 		// Probably be cool to send a special news event here...
; 947  : 		TeamInfo[GetTeam()]->atm->SendATMMessage(Id(), GetTeam(), FalconAirTaskingMessage::atmZapAirbase, 0, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	0
	push	6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+876]
	call	?SendATMMessage@AirTaskingManagerClass@@QAEXVVU_ID@@EFFFPAXH@Z ; AirTaskingManagerClass::SendATMMessage
$LN2@DecodeDama:

; 948  : 	}
; 949  : 
; 950  : 	return lost;

	mov	eax, DWORD PTR _lost$[ebp]

; 951  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DecodeDamageData@UnitClass@@UAEHPAEPAV1@PAVFalconDeathMessage@@@Z ENDP ; UnitClass::DecodeDamageData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_n$ = -56						; size = 4
_uc$ = -52						; size = 4
_lost$ = -48						; size = 4
_hp$ = -44						; size = 4
_vehs$ = -40						; size = 4
_count$ = -36						; size = 4
_actually_lost$ = -32					; size = 4
_cov$ = -28						; size = 4
_pilot$ = -24						; size = 4
_v$ = -20						; size = 4
_vc$ = -16						; size = 4
_this$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
_d$ = 8							; size = 4
_str$ = 12						; size = 4
_where$ = 16						; size = 4
_flags$ = 20						; size = 2
?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z PROC ; UnitClass::ApplyDamage
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	int	v,vehs,n,hp,count=0,lost=0;

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _lost$[ebp], 0

; 765  : 	VehicleClassDataType	*vc;
; 766  : 	GridIndex				x,y;
; 767  : 	int						cov,pilot,actually_lost=0;

	mov	DWORD PTR _actually_lost$[ebp], 0

; 768  : 	UnitClassDataType*		uc = GetUnitClassData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax

; 769  : 
; 770  : 	// Determine ground cover for land units
; 771  : 	if (GetDomain() == DOMAIN_LAND){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	jne	SHORT $LN25@ApplyDamag

; 772  : 		GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 773  : 		cov = GetGroundCover(GetCell(x,y))/2;

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	call	?GetCell@@YAPAEFF@Z			; GetCell
	add	esp, 8
	push	eax
	call	?GetGroundCover@@YA?AW4CoverType@@PAE@Z	; GetGroundCover
	add	esp, 4
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _cov$[ebp], eax

; 774  : 		if (Moving()){ cov /= 2; }

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Moving@UnitClass@@QBEHXZ		; UnitClass::Moving
	test	eax, eax
	je	SHORT $LN24@ApplyDamag
	mov	eax, DWORD PTR _cov$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _cov$[ebp], eax
$LN24@ApplyDamag:

; 775  : 		if (cov < 1){ cov = 1; }

	cmp	DWORD PTR _cov$[ebp], 1
	jge	SHORT $LN23@ApplyDamag
	mov	DWORD PTR _cov$[ebp], 1
$LN23@ApplyDamag:

; 776  : 	}

	jmp	SHORT $LN22@ApplyDamag
$LN25@ApplyDamag:

; 777  : 	else { cov = 1; }

	mov	DWORD PTR _cov$[ebp], 1
$LN22@ApplyDamag:

; 778  : 
; 779  : 	// Make sure we hit something if our target is gone
; 780  : 	if (where != 255 && !GetNumVehicles(where)){

	cmp	DWORD PTR _where$[ebp], 255		; 000000ffH
	je	SHORT $LN21@ApplyDamag
	mov	edx, DWORD PTR _where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	jne	SHORT $LN21@ApplyDamag

; 781  : 		where = 255;

	mov	DWORD PTR _where$[ebp], 255		; 000000ffH
$LN21@ApplyDamag:

; 782  : 	}
; 783  : 
; 784  : 	// Start the pounding
; 785  : 	vehs = GetTotalVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _vehs$[ebp], eax
$LN20@ApplyDamag:

; 786  : 	while (*str > 0 && vehs && count < MAX_DAMAGE_TRIES){

	mov	eax, DWORD PTR _str$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	$LN19@ApplyDamag
	cmp	DWORD PTR _vehs$[ebp], 0
	je	$LN19@ApplyDamag
	movsx	ecx, WORD PTR ?MAX_DAMAGE_TRIES@@3FA	; MAX_DAMAGE_TRIES
	cmp	DWORD PTR _count$[ebp], ecx
	jge	$LN19@ApplyDamag

; 787  : 		// Small units can avoid damage simply by not finding a vehicle
; 788  : 		if (where != 255){

	cmp	DWORD PTR _where$[ebp], 255		; 000000ffH
	je	SHORT $LN18@ApplyDamag

; 789  : 			v = where;

	mov	edx, DWORD PTR _where$[ebp]
	mov	DWORD PTR _v$[ebp], edx

; 790  : 		}
; 791  : 		else{

	jmp	SHORT $LN17@ApplyDamag
$LN18@ApplyDamag:

; 792  : 			v = rand()%VEHICLE_GROUPS_PER_UNIT;

	call	_rand
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN28@ApplyDamag
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN28@ApplyDamag:
	mov	DWORD PTR _v$[ebp], eax
$LN17@ApplyDamag:

; 793  : 		}
; 794  : 		n = GetNumVehicles(v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	DWORD PTR _n$[ebp], eax

; 795  : 		if (n > 0 && uc->VehicleType[v])

	cmp	DWORD PTR _n$[ebp], 0
	jle	$LN16@ApplyDamag
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _uc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+68]
	test	eax, eax
	je	$LN16@ApplyDamag

; 796  : 		{
; 797  : 			vc = GetVehicleClassData(uc->VehicleType[v]);

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _uc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+68]
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 798  : 			if (vc->DamageMod[d])

	mov	ecx, DWORD PTR _vc$[ebp]
	add	ecx, DWORD PTR _d$[ebp]
	movzx	edx, BYTE PTR [ecx+146]
	test	edx, edx
	je	$LN16@ApplyDamag

; 799  : 			{
; 800  : 				// Normalize hitpoints by damage type
; 801  : 				hp = vc->HitPoints * 100 / vc->DamageMod[d];

	mov	eax, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [eax+2]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _vc$[ebp]
	add	ecx, DWORD PTR _d$[ebp]
	movzx	ecx, BYTE PTR [ecx+146]
	cdq
	idiv	ecx
	mov	DWORD PTR _hp$[ebp], eax

; 802  : 				// Check if high explosive damage will do more
; 803  : 				if ((flags & WEAP_AREA) && vc->DamageMod[HighExplosiveDam] > vc->DamageMod[d])

	movsx	edx, WORD PTR _flags$[ebp]
	and	edx, 8
	je	SHORT $LN14@ApplyDamag
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+146]
	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	movzx	ecx, BYTE PTR [eax+146]
	cmp	edx, ecx
	jle	SHORT $LN14@ApplyDamag

; 804  : 					hp = vc->HitPoints * 100 / vc->DamageMod[HighExplosiveDam];

	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+2]
	imul	eax, 100				; 00000064H
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _vc$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx+146]
	cdq
	idiv	ecx
	mov	DWORD PTR _hp$[ebp], eax
$LN14@ApplyDamag:

; 805  : 				if (*str > hp || rand()%hp < *str)

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _hp$[ebp]
	jg	SHORT $LN12@ApplyDamag
	call	_rand
	cdq
	idiv	DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR _str$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN13@ApplyDamag
$LN12@ApplyDamag:

; 806  : 				{
; 807  : 					lost++;

	mov	edx, DWORD PTR _lost$[ebp]
	add	edx, 1
	mov	DWORD PTR _lost$[ebp], edx

; 808  : 					actually_lost++;

	mov	eax, DWORD PTR _actually_lost$[ebp]
	add	eax, 1
	mov	DWORD PTR _actually_lost$[ebp], eax

; 809  : 					vehs--;

	mov	ecx, DWORD PTR _vehs$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _vehs$[ebp], ecx

; 810  : 					SetNumVehicles(v,n-1);

	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles

; 811  : 					*gDamageStatusPtr = (uchar)v;									

	mov	ecx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	mov	dl, BYTE PTR _v$[ebp]
	mov	BYTE PTR [ecx], dl

; 812  : 					gDamageStatusPtr++;

	mov	eax, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	add	eax, 1
	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, eax	; gDamageStatusPtr

; 813  : 					gDamageStatusBuffer[0]++;

	mov	ecx, 1
	imul	ecx, 0
	mov	dl, BYTE PTR ?gDamageStatusBuffer@@3PAEA[ecx]
	add	dl, 1
	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR ?gDamageStatusBuffer@@3PAEA[eax], dl

; 814  : 					where = 255;

	mov	DWORD PTR _where$[ebp], 255		; 000000ffH

; 815  : 					if (!(flags & WEAP_AREA))		// Not area effect weapon, only get one kill per shot

	movsx	ecx, WORD PTR _flags$[ebp]
	and	ecx, 8
	jne	SHORT $LN11@ApplyDamag

; 816  : 						*str = 0;

	mov	edx, DWORD PTR _str$[ebp]
	mov	DWORD PTR [edx], 0
$LN11@ApplyDamag:

; 817  : 					// Flight related stuff to do:
; 818  : 					if (IsFlight())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN10@ApplyDamag

; 819  : 					{
; 820  : 						// Pick a pilot to kill
; 821  : 						pilot = ((Flight)this)->PickRandomPilot(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PickRandomPilot@FlightClass@@QAEHH@Z	; FlightClass::PickRandomPilot
	mov	DWORD PTR _pilot$[ebp], eax

; 822  : 						// COMMENTED OUT BY S.G. DON'T RTB WHEN KILLED!
; 823  : 						//   I'M ALSO FORCING A KIA INSTEAD OF MIA. STATISTIC CHANGES MIGHT BE REQUIRED
; 824  : 						// JB 010228 Commented back in -- attrition rates way too high!
; 825  : 						// JB 010710 Make configurable
; 826  : 						if (!g_bRealisticAttrition && rand()%2)

	movzx	ecx, BYTE PTR ?g_bRealisticAttrition@@3_NA ; g_bRealisticAttrition
	test	ecx, ecx
	jne	SHORT $LN9@ApplyDamag
	call	_rand
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN29@ApplyDamag
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN29@ApplyDamag:
	test	eax, eax
	je	SHORT $LN9@ApplyDamag

; 827  : 						{
; 828  : 							((Flight)this)->plane_stats[pilot] = AIRCRAFT_RTB;		// Aborted and returned to base

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _pilot$[ebp]
	mov	BYTE PTR [edx+416], 3

; 829  : 							actually_lost--;

	mov	eax, DWORD PTR _actually_lost$[ebp]
	sub	eax, 1
	mov	DWORD PTR _actually_lost$[ebp], eax
	jmp	SHORT $LN8@ApplyDamag
$LN9@ApplyDamag:

; 830  : #ifdef KEEP_STATISTICS
; 831  : 							AA_Saves++;
; 832  : #endif 
; 833  : 						}
; 834  : 						else if (!g_bRealisticAttrition && rand()%3)

	movzx	ecx, BYTE PTR ?g_bRealisticAttrition@@3_NA ; g_bRealisticAttrition
	test	ecx, ecx
	jne	SHORT $LN7@ApplyDamag
	call	_rand
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	je	SHORT $LN7@ApplyDamag

; 835  : 							((Flight)this)->plane_stats[pilot] = AIRCRAFT_MISSING;	// Missing

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _pilot$[ebp]
	mov	BYTE PTR [edx+416], 1

; 836  : 						else

	jmp	SHORT $LN8@ApplyDamag
$LN7@ApplyDamag:

; 837  : 							((Flight)this)->plane_stats[pilot] = AIRCRAFT_DEAD;		// Killed

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _pilot$[ebp]
	mov	BYTE PTR [eax+416], 2
$LN8@ApplyDamag:

; 838  : 
; 839  : 						//((Flight)this)->MakeFlightDirty (DIRTY_PLANE_STATS, DDP[32].priority);
; 840  : 						((Flight)this)->MakeFlightDirty (DIRTY_PLANE_STATS, SEND_RELIABLE);

	push	1048576					; 00100000H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeFlightDirty@FlightClass@@QAEXW4Dirty_Flight@@W4Dirtyness@@@Z ; FlightClass::MakeFlightDirty

; 841  : 
; 842  : 						*gDamageStatusPtr = (uchar)pilot;							gDamageStatusPtr++;

	mov	ecx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	mov	dl, BYTE PTR _pilot$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	add	eax, 1
	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, eax	; gDamageStatusPtr

; 843  : 						*gDamageStatusPtr = ((Flight)this)->plane_stats[pilot];		gDamageStatusPtr++;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _pilot$[ebp]
	mov	edx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	mov	al, BYTE PTR [ecx+416]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	add	ecx, 1
	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, ecx	; gDamageStatusPtr

; 844  : 					}
; 845  : 					else

	jmp	SHORT $LN13@ApplyDamag
$LN10@ApplyDamag:

; 846  : 						pilot = 255;

	mov	DWORD PTR _pilot$[ebp], 255		; 000000ffH
$LN13@ApplyDamag:

; 847  : 				}
; 848  : 				if (flags & WEAP_AREA)				// Area effect - halve strength and have another go.

	movsx	edx, WORD PTR _flags$[ebp]
	and	edx, 8
	je	SHORT $LN16@ApplyDamag

; 849  : 				{								// Note: we halve the strength wether or not we killed the target
; 850  : 					*str /= 2;	

	mov	eax, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _str$[ebp]
	mov	DWORD PTR [ecx], eax

; 851  : 					if (*str < MINIMUM_STRENGTH)

	movsx	edx, WORD PTR ?MINIMUM_STRENGTH@@3FA	; MINIMUM_STRENGTH
	mov	eax, DWORD PTR _str$[ebp]
	cmp	DWORD PTR [eax], edx
	jge	SHORT $LN16@ApplyDamag

; 852  : 						count = MAX_DAMAGE_TRIES;	// Stop causing damage eventually, for efficiency

	movsx	ecx, WORD PTR ?MAX_DAMAGE_TRIES@@3FA	; MAX_DAMAGE_TRIES
	mov	DWORD PTR _count$[ebp], ecx
$LN16@ApplyDamag:

; 853  : 				}
; 854  : 			}
; 855  : 		}
; 856  : 		count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 857  : 	}

	jmp	$LN20@ApplyDamag
$LN19@ApplyDamag:

; 858  : 
; 859  : 	// Check for death
; 860  : 	if (!vehs && !IsDead())

	cmp	DWORD PTR _vehs$[ebp], 0
	jne	SHORT $LN2@ApplyDamag
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@ApplyDamag

; 861  : 	{
; 862  : #ifdef KEV_DEBUG
; 863  : 		//		MonoPrint("Unit %d destroyed!\n",GetCampID());
; 864  : #endif
; 865  : 		if (IsBattalion())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN1@ApplyDamag

; 866  : 			TransferInitiative (GetTeam(), GetEnemyTeam(GetTeam()), 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetEnemyTeam@@YAEE@Z			; GetEnemyTeam
	add	esp, 4
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?TransferInitiative@@YAXEEH@Z		; TransferInitiative
	add	esp, 12					; 0000000cH
$LN1@ApplyDamag:

; 867  : 		KillUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit
$LN2@ApplyDamag:

; 868  : 	}
; 869  : 
; 870  : 	losses += lost;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+221]
	add	eax, DWORD PTR _lost$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+221], al

; 871  : 	return actually_lost;

	mov	eax, DWORD PTR _actually_lost$[ebp]

; 872  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ApplyDamage@UnitClass@@UAEHW4DamageDataType@@PAHHF@Z ENDP ; UnitClass::ApplyDamage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T1 = -128						; size = 8
$T2 = -120						; size = 8
$T3 = -112						; size = 4
_flags$ = -108						; size = 4
_strength$ = -104					; size = 4
_bonus$ = -100						; size = 4
_range$ = -96						; size = 4
_d$4 = -92						; size = 4
_c$5 = -88						; size = 4
_s$6 = -84						; size = 4
_e$7 = -80						; size = 4
_dt$ = -76						; size = 4
tv447 = -72						; size = 4
$T8 = -68						; size = 4
_r$9 = -64						; size = 4
_ct$10 = -60						; size = 4
_totalShots$ = -56					; size = 4
_shot$ = -52						; size = 4
_str$ = -48						; size = 4
_currentLosses$ = -44					; size = 4
_mt$ = -40						; size = 4
_i$ = -36						; size = 4
_shooter$ = -32						; size = 4
_hc$ = -28						; size = 4
_this$ = -24						; size = 4
_sx$ = -20						; size = 2
_sy$ = -16						; size = 2
_tx$ = -12						; size = 2
_ty$ = -8						; size = 2
_addcrater$ = -1					; size = 1
_cwfm$ = 8						; size = 4
_bonusToHit$ = 12					; size = 1
?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z PROC ; UnitClass::ApplyDamage
; _this$ = ecx

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	MoveType		mt;
; 561  : 	Int32			i,hc,range,shot,currentLosses=0;

	mov	DWORD PTR _currentLosses$[ebp], 0

; 562  : 	int				str=0,strength,flags,totalShots=0;

	mov	DWORD PTR _str$[ebp], 0
	mov	DWORD PTR _totalShots$[ebp], 0

; 563  : 	float			bonus;
; 564  : 	DamType			dt;
; 565  : 	GridIndex		sx,sy,tx,ty;
; 566  : 	Unit			shooter = (Unit)vuDatabase->Find(cwfm->dataBlock.shooterID);

	mov	eax, DWORD PTR _cwfm$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _shooter$[ebp], eax

; 567  : 	uchar			addcrater=0;

	mov	BYTE PTR _addcrater$[ebp], 0

; 568  : 
; 569  : 	if (!IsLocal())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN26@ApplyDamag

; 570  : 		return 0;

	xor	eax, eax
	jmp	$LN27@ApplyDamag
$LN26@ApplyDamag:

; 571  : 
; 572  : 	// 2001-08-06 ADDED BY S.G. FIXING A POSSIBLE CTD. shooter SHOULD NOT BE NULL BUT IT WAS ONCE. NO TIME TO FIX SO HACKING IT.
; 573  : 	if (!shooter)

	cmp	DWORD PTR _shooter$[ebp], 0
	jne	SHORT $LN25@ApplyDamag

; 574  : 		return 0;

	xor	eax, eax
	jmp	$LN27@ApplyDamag
$LN25@ApplyDamag:

; 575  : 
; 576  : 	// Since this person is shooting at us, check if they're a higher concern than our current target.
; 577  : 	// If so, set our target to them and choose a new tactic.
; 578  : 	// 2001-07-31 MODIFIED BY S.G. SO GROUND UNIT ARE NOT CAUSING A REACTION.
; 579  : 	//	if (IsFlight() && shooter->Id() != GetTargetID())
; 580  : 	if (IsFlight() && !shooter->OnGround() && shooter->Id() != GetTargetID())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN22@ApplyDamag
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN22@ApplyDamag
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetID@UnitClass@@QAE?AVVU_ID@@XZ	; UnitClass::GetTargetID
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _shooter$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@ApplyDamag

; 581  : 	{
; 582  : 		float			d;
; 583  : 		int				c,s,e,r=0;

	mov	DWORD PTR _r$9[ebp], 0

; 584  : 		CampEntity		ct = GetCampTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCampTarget@UnitClass@@QAEPAVCampBaseClass@@XZ ; UnitClass::GetCampTarget
	mov	DWORD PTR _ct$10[ebp], eax

; 585  : 		if (ct)

	cmp	DWORD PTR _ct$10[ebp], 0
	je	SHORT $LN23@ApplyDamag

; 586  : 			r = ((Flight)this)->DetectVs(ct, &d, &c, &s, &e);

	lea	ecx, DWORD PTR _e$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$6[ebp]
	push	edx
	lea	eax, DWORD PTR _c$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _d$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _ct$10[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetectVs@FlightClass@@QAEHPAVCampBaseClass@@PAMPAH22@Z ; FlightClass::DetectVs
	mov	DWORD PTR _r$9[ebp], eax
$LN23@ApplyDamag:

; 587  : 		if (((Flight)this)->DetectVs(shooter, &d, &c, &s, &e) > r)

	lea	eax, DWORD PTR _e$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _c$5[ebp]
	push	edx
	lea	eax, DWORD PTR _d$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _shooter$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetectVs@FlightClass@@QAEHPAVCampBaseClass@@PAMPAH22@Z ; FlightClass::DetectVs
	cmp	eax, DWORD PTR _r$9[ebp]
	jle	SHORT $LN22@ApplyDamag

; 588  : 		{
; 589  : 			// MonoPrint("Unit %d auto-engaging shooter %d.\n",GetCampID(),shooter->GetCampID());
; 590  : 			SetTarget(shooter);

	mov	edx, DWORD PTR _shooter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@UnitClass@@QAEXPAVFalconEntity@@@Z ; UnitClass::SetTarget

; 591  : 			SetEngaged(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 592  : 			ChooseTactic();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+496]
	call	eax
$LN22@ApplyDamag:

; 593  : 		}
; 594  : 	}
; 595  : 
; 596  : 	// Bonus for player performance
; 597  : 	bonus = CombatBonus(shooter->GetTeam(), FalconNullId);

	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	mov	eax, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?CombatBonus@@YAMEVVU_ID@@@Z		; CombatBonus
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _bonus$[ebp]

; 598  : 
; 599  : 	ShiAssert (IsAggregate());
; 600  : 
; 601  : 	gDamageStatusPtr = gDamageStatusBuffer + 1;

	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, OFFSET ?gDamageStatusBuffer@@3PAEA+1 ; gDamageStatusPtr

; 602  : 	gDamageStatusBuffer[0] = 0;

	mov	edx, 1
	imul	edx, 0
	mov	DWORD PTR $T8[ebp], edx
	cmp	DWORD PTR $T8[ebp], 256			; 00000100H
	jae	SHORT $LN29@ApplyDamag
	jmp	SHORT $LN30@ApplyDamag
$LN29@ApplyDamag:
	call	___report_rangecheckfailure
$LN30@ApplyDamag:
	mov	eax, DWORD PTR $T8[ebp]
	mov	BYTE PTR ?gDamageStatusBuffer@@3PAEA[eax], 0

; 603  : 	shooter->GetLocation(&sx,&sy);

	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _shooter$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 604  : 	GetLocation(&tx,&ty);

	lea	eax, DWORD PTR _ty$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 605  : 	range = FloatToInt32(Distance(sx,sy,tx,ty));

	movzx	edx, WORD PTR _ty$[ebp]
	push	edx
	movzx	eax, WORD PTR _tx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _sy$[ebp]
	push	ecx
	movzx	edx, WORD PTR _sx$[ebp]
	push	edx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _range$[ebp], eax

; 606  : 	mt = GetMovementType();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	mov	DWORD PTR _mt$[ebp], eax

; 607  : 	SetEngaged(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngaged@UnitClass@@QAEXH@Z		; UnitClass::SetEngaged

; 608  : 
; 609  : 	for (i=0; i<MAX_TYPES_PER_CAMP_FIRE_MESSAGE && cwfm->dataBlock.weapon[i] && cwfm->dataBlock.shots[i]; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@ApplyDamag
$LN20@ApplyDamag:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN21@ApplyDamag:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN19@ApplyDamag
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cwfm$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+64]
	test	ecx, ecx
	je	$LN19@ApplyDamag
	mov	edx, DWORD PTR _cwfm$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx+80]
	test	eax, eax
	je	$LN19@ApplyDamag

; 610  : 	{
; 611  : 		hc = GetWeaponHitChance(cwfm->dataBlock.weapon[i], mt, range) + bonusToHit;

	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cwfm$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+64]
	push	edx
	call	?GetWeaponHitChance@@YAHHHH@Z		; GetWeaponHitChance
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR _bonusToHit$[ebp]
	add	eax, ecx
	mov	DWORD PTR _hc$[ebp], eax

; 612  : 
; 613  : 		// Flight's get bonuses to hit based on vehicle type (ground vehicles should too -
; 614  : 		// but at this point, we don't really know which vehicle shot which weapon)
; 615  : 
; 616  : 		// A.S.
; 617  : 		if (!CampBugFixes)

	cmp	DWORD PTR ?CampBugFixes@@3HA, 0		; CampBugFixes
	jne	SHORT $LN18@ApplyDamag

; 618  : 		{
; 619  : 			if (shooter->IsFlight())

	mov	edx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN17@ApplyDamag

; 620  : 				hc += GetVehicleClassData(shooter->GetVehicleID(0))->HitChance[mt];

	push	0
	mov	ecx, DWORD PTR _shooter$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	push	eax
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	ecx, DWORD PTR _mt$[ebp]
	movzx	edx, BYTE PTR [eax+ecx+66]
	add	edx, DWORD PTR _hc$[ebp]
	mov	DWORD PTR _hc$[ebp], edx
$LN17@ApplyDamag:

; 621  : 			//	If target is a flight, it get's it's air to air manueverability as a defensive bonus
; 622  : 			if (IsFlight() && hc > 5)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN16@ApplyDamag
	cmp	DWORD PTR _hc$[ebp], 5
	jle	SHORT $LN16@ApplyDamag

; 623  : 				hc -= GetVehicleClassData(GetVehicleID(0))->HitChance[mt];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [eax+edx+66]
	mov	ecx, DWORD PTR _hc$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _hc$[ebp], ecx
$LN16@ApplyDamag:

; 624  : 		}
; 625  : 
; 626  : 		else

	jmp	$LN13@ApplyDamag
$LN18@ApplyDamag:

; 627  : 		{
; 628  : 			// A.S. 2001-12-09, begin
; 629  : 			if (shooter->IsFlight() &&  IsFlight() ) // Flights get only bonus for air targets as ground targets get no defensive bonus!

	mov	edx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN14@ApplyDamag
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN14@ApplyDamag

; 630  : 				hc += GetVehicleClassData(shooter->GetVehicleID(0))->HitChance[mt]; 

	push	0
	mov	ecx, DWORD PTR _shooter$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [eax+edx+66]
	add	eax, DWORD PTR _hc$[ebp]
	mov	DWORD PTR _hc$[ebp], eax
$LN14@ApplyDamag:

; 631  : 
; 632  : 			if (IsFlight() && hc > 5  &&  shooter->IsFlight())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN13@ApplyDamag
	cmp	DWORD PTR _hc$[ebp], 5
	jle	SHORT $LN13@ApplyDamag
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN13@ApplyDamag

; 633  : 				hc -= GetVehicleClassData(GetVehicleID(0))->HitChance[mt];	// no defensive bonus for flights, if shooter is on ground

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [eax+edx+66]
	mov	ecx, DWORD PTR _hc$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _hc$[ebp], ecx
$LN13@ApplyDamag:

; 634  : 		}
; 635  : 		// this makes AAA and SAMs more dangerous in 2D
; 636  : 		if ( shooter->IsFlight() && (WeaponDataTable[cwfm->dataBlock.weapon[i]].Flags & WEAP_ONETENTH))  

	mov	edx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN12@ApplyDamag
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cwfm$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+64]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN12@ApplyDamag

; 637  : 			hc = FloatToInt32(hc / 3.0F);								// reduction for aircraft guns, which are heavily over-modeled

	cvtsi2ss xmm0, DWORD PTR _hc$[ebp]
	divss	xmm0, DWORD PTR __real@40400000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _hc$[ebp], eax
$LN12@ApplyDamag:

; 638  : 		// end added section
; 639  : 
; 640  : 
; 641  : 		// HARMs will snap to current radar vehicle, if we're emitting
; 642  : 		if ((WeaponDataTable[cwfm->dataBlock.weapon[i]].GuidanceFlags & WEAP_ANTIRADATION))// && IsEmitting()) Leonr Change for HARMS

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cwfm$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+64]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	and	eax, 1
	je	SHORT $LN11@ApplyDamag

; 643  : 		{
; 644  : 			cwfm->dataBlock.dPilotId = class_data->RadarVehicle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _cwfm$[ebp]
	mov	cl, BYTE PTR [edx+328]
	mov	BYTE PTR [eax+89], cl

; 645  : 			hc += 90;		// KCK: Hackish - add a bonus if they kept their radar on.

	mov	edx, DWORD PTR _hc$[ebp]
	add	edx, 90					; 0000005aH
	mov	DWORD PTR _hc$[ebp], edx
$LN11@ApplyDamag:

; 646  : 		}
; 647  : 
; 648  : 		hc = FloatToInt32(bonus * hc);

	cvtsi2ss xmm0, DWORD PTR _hc$[ebp]
	mulss	xmm0, DWORD PTR _bonus$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _hc$[ebp], eax

; 649  : 
; 650  : 		// COMMENTED OUT BY S.G. NO MORE STUPID HACK
; 651  : 		// Commented back in by JB 010224 -- Caused high attrition rates
; 652  : 
; 653  : 		if (shooter->IsFlight())

	mov	eax, DWORD PTR _shooter$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _shooter$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN8@ApplyDamag

; 654  : 		{
; 655  : 			if (IsFlight())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN9@ApplyDamag

; 656  : 				hc = FloatToInt32(hc / HitChanceAir);	// default 3.5F -> Falcon4.AII

	cvtsi2ss xmm0, DWORD PTR _hc$[ebp]
	divss	xmm0, DWORD PTR ?HitChanceAir@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _hc$[ebp], eax

; 657  : 			else

	jmp	SHORT $LN8@ApplyDamag
$LN9@ApplyDamag:

; 658  : 				hc = FloatToInt32(hc / HitChanceGround);	// default 1.5F

	cvtsi2ss xmm0, DWORD PTR _hc$[ebp]
	divss	xmm0, DWORD PTR ?HitChanceGround@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _hc$[ebp], eax
$LN8@ApplyDamag:

; 659  : 		}	
; 660  : 		// END HACK
; 661  : 
; 662  : 		if (hc < 1)

	cmp	DWORD PTR _hc$[ebp], 1
	jge	SHORT $LN7@ApplyDamag

; 663  : 			hc = 1;		// Minimum chance to hit of 1%

	mov	DWORD PTR _hc$[ebp], 1
$LN7@ApplyDamag:

; 664  : 
; 665  : 		// Tally the losses
; 666  : 		strength = GetWeaponStrength(cwfm->dataBlock.weapon[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cwfm$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+64]
	push	eax
	call	?GetWeaponStrength@@YAHH@Z		; GetWeaponStrength
	add	esp, 4
	mov	DWORD PTR _strength$[ebp], eax

; 667  : 		str = 0;

	mov	DWORD PTR _str$[ebp], 0

; 668  : 		dt = (DamType)GetWeaponDamageType(cwfm->dataBlock.weapon[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cwfm$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+64]
	push	eax
	call	?GetWeaponDamageType@@YAHH@Z		; GetWeaponDamageType
	add	esp, 4
	mov	DWORD PTR _dt$[ebp], eax

; 669  : 		// 2002-03-22 MN minimum of 95% hitchance for nukes
; 670  : 		if (dt == NuclearDam)

	cmp	DWORD PTR _dt$[ebp], 9
	jne	SHORT $LN6@ApplyDamag

; 671  : 			hc = max (95,hc);

	cmp	DWORD PTR _hc$[ebp], 95			; 0000005fH
	jge	SHORT $LN31@ApplyDamag
	mov	DWORD PTR tv447[ebp], 95		; 0000005fH
	jmp	SHORT $LN32@ApplyDamag
$LN31@ApplyDamag:
	mov	ecx, DWORD PTR _hc$[ebp]
	mov	DWORD PTR tv447[ebp], ecx
$LN32@ApplyDamag:
	mov	edx, DWORD PTR tv447[ebp]
	mov	DWORD PTR _hc$[ebp], edx
$LN6@ApplyDamag:

; 672  : 		flags = GetWeaponFlags(cwfm->dataBlock.weapon[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cwfm$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+64]
	push	edx
	call	?GetWeaponFlags@@YAHH@Z			; GetWeaponFlags
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 673  : 		shot = 0;

	mov	DWORD PTR _shot$[ebp], 0
$LN5@ApplyDamag:

; 674  : 		while (cwfm->dataBlock.shots[i] - shot>0)

	mov	eax, DWORD PTR _cwfm$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	sub	ecx, DWORD PTR _shot$[ebp]
	test	ecx, ecx
	jle	$LN4@ApplyDamag

; 675  : 		{
; 676  : 			totalShots ++;

	mov	edx, DWORD PTR _totalShots$[ebp]
	add	edx, 1
	mov	DWORD PTR _totalShots$[ebp], edx

; 677  : 			if (rand()%100 < hc)

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, DWORD PTR _hc$[ebp]
	jge	SHORT $LN3@ApplyDamag

; 678  : 			{
; 679  : 				str += strength;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, DWORD PTR _strength$[ebp]
	mov	DWORD PTR _str$[ebp], edx

; 680  : 				currentLosses += ApplyDamage(dt, &str, cwfm->dataBlock.dPilotId, flags);

	movzx	eax, WORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cwfm$[ebp]
	movzx	edx, BYTE PTR [ecx+89]
	push	edx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+364]
	call	edx
	add	eax, DWORD PTR _currentLosses$[ebp]
	mov	DWORD PTR _currentLosses$[ebp], eax
	jmp	SHORT $LN1@ApplyDamag
$LN3@ApplyDamag:

; 681  : 			}
; 682  : 			else if (addcrater < 2 && GetDomain() == DOMAIN_LAND)

	movzx	eax, BYTE PTR _addcrater$[ebp]
	cmp	eax, 2
	jge	SHORT $LN1@ApplyDamag
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 3
	jne	SHORT $LN1@ApplyDamag

; 683  : 			{
; 684  : 				// Add a few craters for kicks
; 685  : 				addcrater++;

	mov	dl, BYTE PTR _addcrater$[ebp]
	add	dl, 1
	mov	BYTE PTR _addcrater$[ebp], dl
$LN1@ApplyDamag:

; 686  : 			}
; 687  : 			shot += 1 + (rand()%(currentLosses+1));		// Random stray shots - let's be nice

	call	_rand
	mov	ecx, DWORD PTR _currentLosses$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _shot$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	DWORD PTR _shot$[ebp], ecx

; 688  : 		}

	jmp	$LN5@ApplyDamag
$LN4@ApplyDamag:

; 689  : 	}

	jmp	$LN20@ApplyDamag
$LN19@ApplyDamag:

; 690  : 
; 691  : 	// Check morale
; 692  : 	MoraleCheck(totalShots, currentLosses);

	mov	edx, DWORD PTR _currentLosses$[ebp]
	push	edx
	mov	eax, DWORD PTR _totalShots$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoraleCheck@UnitClass@@QAEHHH@Z	; UnitClass::MoraleCheck

; 693  : 	*gDamageStatusPtr = (uchar)GetUnitMorale();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+780]
	call	eax
	mov	ecx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	mov	BYTE PTR [ecx], al

; 694  : 	gDamageStatusPtr++;

	mov	edx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	add	edx, 1
	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, edx	; gDamageStatusPtr

; 695  : 
; 696  : #ifdef DEBUG
; 697  : 	//		if (shooter->IsFlight())
; 698  : 	//			MonoPrint("%d (%d,%d) took %d losses from %d (%d,%d). range = %d\n",GetCampID(),tx,ty,currentLosses,shooter->GetCampID(),sx,sy,range);
; 699  : #endif
; 700  : 
; 701  : #ifdef KEEP_STATISTICS
; 702  : 	if (IsFlight())
; 703  : 	{
; 704  : 		if (shooter->IsFlight())
; 705  : 		{
; 706  : 			AA_Kills += currentLosses;
; 707  : 			AA_Shots += totalShots;
; 708  : 		}
; 709  : 		else if (shooter->IsBattalion())
; 710  : 		{
; 711  : 			GA_Kills += currentLosses;
; 712  : 			GA_Shots += totalShots;
; 713  : 		}
; 714  : 		else
; 715  : 		{
; 716  : 			NA_Kills += currentLosses;
; 717  : 			NA_Shots += totalShots;
; 718  : 		}
; 719  : 	}
; 720  : 	else if (IsBattalion())
; 721  : 	{
; 722  : 		if (shooter->IsFlight())
; 723  : 		{
; 724  : 			AG_Kills += currentLosses;
; 725  : 			AG_Shots += totalShots;
; 726  : 		}
; 727  : 		else if (shooter->IsBattalion() && shooter->GetUnitNormalRole() == GRO_FIRESUPPORT)
; 728  : 		{
; 729  : 			ART_Kills += currentLosses;
; 730  : 			ART_Shots += totalShots;
; 731  : 		}
; 732  : 		else
; 733  : 		{
; 734  : 			GG_Kills += currentLosses;
; 735  : 			GG_Shots += totalShots;
; 736  : 		}
; 737  : 	}
; 738  : 	//FILE *deb;    // A.S. debug
; 739  : 	//deb = fopen("c:\\temp\\stat.txt", "w");
; 740  : 	//fprintf(deb, "GG_Kills = %d  GA_Kills = %d  ART_Kills = %d  AA_Kills = %d  AG_Kills = %d  Time = %d\n", GG_Kills, GA_Kills, ART_Kills, AA_Kills, AG_Kills, TheCampaign.CurrentTime/(3600*1000));   
; 741  : 	//fclose(deb);
; 742  : 	// end debug
; 743  : #endif
; 744  : 
; 745  : 	// Record # of craters to add
; 746  : 	*gDamageStatusPtr = addcrater;								gDamageStatusPtr++;

	mov	eax, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	mov	cl, BYTE PTR _addcrater$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	add	edx, 1
	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, edx	; gDamageStatusPtr

; 747  : 
; 748  : 	// Record the final state, to keep remote entities consitant
; 749  : 	memcpy(gDamageStatusPtr,&roster,sizeof(fourbyte));			gDamageStatusPtr += sizeof(fourbyte);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	mov	ecx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	add	edx, 4
	mov	DWORD PTR ?gDamageStatusPtr@@3PAEA, edx	; gDamageStatusPtr

; 750  : 
; 751  : 	cwfm->dataBlock.size = gDamageStatusPtr - gDamageStatusBuffer;

	mov	eax, DWORD PTR ?gDamageStatusPtr@@3PAEA	; gDamageStatusPtr
	sub	eax, OFFSET ?gDamageStatusBuffer@@3PAEA
	mov	ecx, DWORD PTR _cwfm$[ebp]
	mov	WORD PTR [ecx+90], ax

; 752  : 	cwfm->dataBlock.data = new uchar[cwfm->dataBlock.size];

	mov	edx, DWORD PTR _cwfm$[ebp]
	movzx	eax, WORD PTR [edx+90]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR _cwfm$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+92], edx

; 753  : 	memcpy (cwfm->dataBlock.data,gDamageStatusBuffer,cwfm->dataBlock.size);

	mov	eax, DWORD PTR _cwfm$[ebp]
	movzx	ecx, WORD PTR [eax+90]
	push	ecx
	push	OFFSET ?gDamageStatusBuffer@@3PAEA
	mov	edx, DWORD PTR _cwfm$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 754  : 
; 755  : 	// Send the weapon fire message (with target's post-damage status)
; 756  : 	FalconSendMessage(cwfm,FALSE);

	push	0
	mov	ecx, DWORD PTR _cwfm$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 757  : 
; 758  : 	return currentLosses;

	mov	eax, DWORD PTR _currentLosses$[ebp]
$LN27@ApplyDamag:

; 759  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ApplyDamage@UnitClass@@UAEHPAVFalconCampWeaponsFire@@E@Z ENDP ; UnitClass::ApplyDamage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetPlayerStatus@UnitClass@@UAEHXZ PROC		; UnitClass::ResetPlayerStatus
; _this$ = ecx

; 2081 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2082 : 	return GameManager.CheckPlayerStatus(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, OFFSET ?GameManager@@3VGameManagerClass@@A ; GameManager
	call	?CheckPlayerStatus@GameManagerClass@@QAEHPAVFalconEntity@@@Z ; GameManagerClass::CheckPlayerStatus

; 2083 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetPlayerStatus@UnitClass@@UAEHXZ ENDP		; UnitClass::ResetPlayerStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$2 = -64						; size = 12
$T3 = -52						; size = 8
$T4 = -44						; size = 8
$T5 = -36						; size = 8
_vuid$ = -28						; size = 8
_vehicle$6 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_size$ = 12						; size = 4
?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z PROC	; UnitClass::TransferOwnershipFromData
; _this$ = ecx

; 2039 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2040 : 	if (IsAggregate() || IsLocal() || !data)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN8@TransferOw
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@TransferOw
	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN9@TransferOw
$LN8@TransferOw:

; 2041 : 		return;

	jmp	$LN10@TransferOw
$LN9@TransferOw:

; 2042 : 
; 2043 : #ifndef NDEBUG
; 2044 : 	MonoPrint ("Transfering ownership of remote Unit #%d!\n",GetCampID());
; 2045 : #endif
; 2046 : 
; 2047 : 	VU_ID					vuid;

	lea	ecx, DWORD PTR _vuid$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 2048 : 
; 2049 : 	SetDeagOwner (*(VU_ID*) data);						data += sizeof(VU_ID);

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDeagOwner@CampBaseClass@@QAEXVVU_ID@@@Z ; CampBaseClass::SetDeagOwner
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	mov	DWORD PTR _data$[ebp], ecx

; 2050 : 	//	memcpy(&deag_owner, data, sizeof(VU_ID));			data += sizeof(VU_ID);
; 2051 : 	memcpy(&roster, data, sizeof(fourbyte));			data += sizeof(fourbyte);

	push	4
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 4
	mov	DWORD PTR _data$[ebp], ecx

; 2052 : 
; 2053 : 	// Change ownership locally
; 2054 : 	if (GetComponents ())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	SHORT $LN7@TransferOw

; 2055 : 	{
; 2056 : 		VuEntity*		vehicle;
; 2057 : 		VuListIterator	myit(GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2058 : 		vehicle = myit.GetFirst();

	lea	ecx, DWORD PTR _myit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _vehicle$6[ebp], eax
$LN6@TransferOw:

; 2059 : 		while (vehicle)

	cmp	DWORD PTR _vehicle$6[ebp], 0
	je	SHORT $LN5@TransferOw

; 2060 : 		{
; 2061 : 			((SimBaseClass*)vehicle)->ChangeOwner(GetDeagOwner());

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ; CampBaseClass::GetDeagOwner
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _vehicle$6[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _vehicle$6[ebp]
	mov	eax, DWORD PTR [edx+328]
	call	eax

; 2062 : 			vehicle = myit.GetNext();

	lea	ecx, DWORD PTR _myit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _vehicle$6[ebp], eax

; 2063 : 		}

	jmp	SHORT $LN6@TransferOw
$LN5@TransferOw:

; 2064 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN7@TransferOw:

; 2065 : 
; 2066 : 	// Update our local wake status
; 2067 : 	if (IsAwake() && !FalconLocalSession->InSessionBubble(this,REAGREGATION_RATIO)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN4@TransferOw
	push	ecx
	movss	xmm0, DWORD PTR ?REAGREGATION_RATIO@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z ; FalconSessionEntity::InSessionBubble
	test	eax, eax
	jne	SHORT $LN4@TransferOw

; 2068 : 		Sleep();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+108]
	call	edx

; 2069 : 	}
; 2070 : 	else if (

	jmp	SHORT $LN2@TransferOw
$LN4@TransferOw:

; 2071 : 		!IsAwake() && (
; 2072 : 			GetDeagOwner() == FalconLocalSession->Id() || FalconLocalSession->InSessionBubble(this,1.0F)>0
; 2073 : 		)
; 2074 : 	){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN2@TransferOw
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ; CampBaseClass::GetDeagOwner
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@TransferOw
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z ; FalconSessionEntity::InSessionBubble
	test	eax, eax
	jle	SHORT $LN2@TransferOw
$LN1@TransferOw:

; 2075 : 		Wake();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax
$LN2@TransferOw:
$LN10@TransferOw:

; 2076 : 	}
; 2077 : 	return;
; 2078 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z$0:
	lea	ecx, DWORD PTR _myit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TransferOwnershipFromData@UnitClass@@UAEXPAEJ@Z ENDP	; UnitClass::TransferOwnershipFromData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$2 = -48						; size = 12
tv189 = -36						; size = 4
$T3 = -32						; size = 4
_next$4 = -28						; size = 4
$T5 = -24						; size = 4
_vehicle$6 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_size$ = 12						; size = 4
?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z PROC		; UnitClass::ReaggregateFromData
; _this$ = ecx

; 2006 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2007 : 	if (IsLocal() || IsAggregate())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Reaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN7@Reaggregat
$LN6@Reaggregat:

; 2008 : 		return;

	jmp	$LN8@Reaggregat
$LN7@Reaggregat:

; 2009 : 
; 2010 : 	if (IsAwake())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN5@Reaggregat

; 2011 : 		Sleep();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN5@Reaggregat:

; 2012 : 
; 2013 : 	SetAggregate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAggregate@CampBaseClass@@QAEX_N@Z	; CampBaseClass::SetAggregate

; 2014 : 
; 2015 : 	if (GetComponents()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	$LN4@Reaggregat

; 2016 : 		CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2017 : 		{
; 2018 : 			// destroy iterator before the components
; 2019 : 			VuListIterator	myit(GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2020 : 			for (VuEntity *next, *vehicle = myit.GetFirst(); vehicle != NULL; vehicle = next){

	lea	ecx, DWORD PTR _myit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _vehicle$6[ebp], eax
	jmp	SHORT $LN3@Reaggregat
$LN2@Reaggregat:
	mov	ecx, DWORD PTR _next$4[ebp]
	mov	DWORD PTR _vehicle$6[ebp], ecx
$LN3@Reaggregat:
	cmp	DWORD PTR _vehicle$6[ebp], 0
	je	SHORT $LN1@Reaggregat

; 2021 : 				next = myit.GetNext();

	lea	ecx, DWORD PTR _myit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _next$4[ebp], eax

; 2022 : 				((SimBaseClass*)vehicle)->SetRemoveFlag();

	mov	ecx, DWORD PTR _vehicle$6[ebp]
	call	?SetRemoveFlag@SimBaseClass@@QAEXXZ	; SimBaseClass::SetRemoveFlag

; 2023 : 			}

	jmp	SHORT $LN2@Reaggregat
$LN1@Reaggregat:

; 2024 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 2025 : 		GetComponents()->Unregister();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	ecx, eax
	call	?Unregister@VuCollection@@QAEXXZ	; VuCollection::Unregister

; 2026 : 		delete GetComponents();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	DWORD PTR $T3[ebp], eax
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN10@Reaggregat
	push	1
	mov	eax, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN11@Reaggregat
$LN10@Reaggregat:
	mov	DWORD PTR tv189[ebp], 0
$LN11@Reaggregat:

; 2027 : 		SetComponents (NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetComponents@CampBaseClass@@QAEXPAVTailInsertList@@@Z ; CampBaseClass::SetComponents

; 2028 : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection
$LN4@Reaggregat:

; 2029 : 	}
; 2030 : #if USE_VU_COLL_FOR_CAMPAIGN
; 2031 : 	deaggregatedEntities->Remove(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	call	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Remove
$LN8@Reaggregat:

; 2032 : #else
; 2033 : 	deaggregatedMap->remove(this->Id());
; 2034 : #endif
; 2035 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z$0:
	lea	ecx, DWORD PTR _myit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReaggregateFromData@UnitClass@@UAEXPAEJ@Z ENDP		; UnitClass::ReaggregateFromData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -356						; size = 8
$T3 = -348						; size = 8
$T4 = -340						; size = 8
$T5 = -332						; size = 8
_z$ = -324						; size = 4
$T6 = -320						; size = 4
_creating_session$ = -316				; size = 4
$T7 = -312						; size = 4
_vc$ = -308						; size = 4
$T8 = -304						; size = 4
$T9 = -300						; size = 4
_fuel$ = -296						; size = 4
tv133 = -292						; size = 4
tv251 = -288						; size = 4
$T10 = -284						; size = 4
$T11 = -280						; size = 4
_newObject$ = -276					; size = 4
$T12 = -272						; size = 4
_motiontype$ = -268					; size = 4
tv397 = -264						; size = 4
tv207 = -260						; size = 4
_vuid$ = -256						; size = 8
_owning_session$ = -248					; size = 4
_lw$ = -244						; size = 4
_vehs$13 = -240						; size = 4
$T14 = -236						; size = 4
_classID$ = -232					; size = 4
_loadlist$ = -228					; size = 4
_inslot$ = -224						; size = 4
_w$ = -220						; size = 4
_i$ = -216						; size = 4
_vg$15 = -212						; size = 4
_wps$ = -208						; size = 2
_slot$16 = -201						; size = 1
_v$17 = -200						; size = 2
_value$ = -196						; size = 2
_rem$ = -192						; size = 4
_this$ = -188						; size = 4
_simdata$ = -184					; size = 168
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_size$ = 12						; size = 4
?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z PROC		; UnitClass::DeaggregateFromData
; _this$ = ecx

; 1825 : void UnitClass::DeaggregateFromData(VU_BYTE* data, long size) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1826 : 	if (IsLocal() || !IsAggregate()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN27@Deaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN28@Deaggregat
$LN27@Deaggregat:

; 1827 : 		return;

	jmp	$LN29@Deaggregat
$LN28@Deaggregat:

; 1828 : 	}
; 1829 : 
; 1830 : 	int						i,classID,inslot,motiontype;
; 1831 : 	SimInitDataClass		simdata;

	lea	ecx, DWORD PTR _simdata$[ebp]
	call	??0SimInitDataClass@@QAE@XZ

; 1832 : 	SimBaseClass*			newObject;
; 1833 : 	FalconSessionEntity*	owning_session;
; 1834 : 	FalconSessionEntity*	creating_session;
; 1835 : 	VU_ID					vuid;

	lea	ecx, DWORD PTR _vuid$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 1836 : 	ushort					value,wps;
; 1837 : 	VehicleClassDataType*	vc;
; 1838 : 	float					z;
; 1839 : 	WayPoint				w,lw = NULL;

	mov	DWORD PTR _lw$[ebp], 0

; 1840 : 	long					fuel;
; 1841 : 	LoadoutStruct*			loadlist = NULL;

	mov	DWORD PTR _loadlist$[ebp], 0

; 1842 : 
; 1843 : 	memset(&simdata, 0, sizeof(simdata));

	push	168					; 000000a8H
	push	0
	lea	ecx, DWORD PTR _simdata$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1844 : 
; 1845 : 	SetComponents(new TailInsertList());

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN31@Deaggregat
	push	OFFSET ?FalconNothingFilter@@3VFalconNothingFilterType@@A ; FalconNothingFilter
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0TailInsertList@@QAE@PAVVuFilter@@@Z	; TailInsertList::TailInsertList
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN32@Deaggregat
$LN31@Deaggregat:
	mov	DWORD PTR tv133[ebp], 0
$LN32@Deaggregat:
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetComponents@CampBaseClass@@QAEXPAVTailInsertList@@@Z ; CampBaseClass::SetComponents

; 1846 : 	GetComponents()->Register();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	ecx, eax
	call	?Register@VuCollection@@QAEXXZ		; VuCollection::Register

; 1847 : 
; 1848 : 	DisposeWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints

; 1849 : 	long *rem = &size;

	lea	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _rem$[ebp], ecx

; 1850 : 
; 1851 : 	vuid.num_ = VU_SESSION_ENTITY_ID;

	mov	DWORD PTR _vuid$[ebp], 3

; 1852 : 	memcpychk(&vuid.creator_, &data, sizeof(VU_SESSION_ID), rem);	

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vuid$[ebp+4]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1853 : 	owning_session = (FalconSessionEntity*) vuDatabase->Find(vuid);

	mov	edx, DWORD PTR _vuid$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _vuid$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _owning_session$[ebp], eax

; 1854 : 	memcpychk(&vuid.creator_, &data, sizeof(VU_SESSION_ID), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	lea	eax, DWORD PTR _vuid$[ebp+4]
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1855 : 	creating_session = (FalconSessionEntity*) vuDatabase->Find(vuid);

	mov	ecx, DWORD PTR _vuid$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _vuid$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _creating_session$[ebp], eax

; 1856 : 	memcpychk(&unit_flags, &data, sizeof(fourbyte), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 196				; 000000c4H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1857 : 	memcpychk(&roster, &data, sizeof(fourbyte), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1858 : 	memcpychk(&z, &data, sizeof(float), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1859 : 	memcpychk(&value, &data, sizeof(ushort), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1860 : 	simdata.currentWaypoint = (Int32) value;

	movzx	eax, WORD PTR _value$[ebp]
	mov	DWORD PTR _simdata$[ebp+148], eax

; 1861 : 	current_wp = (ushort) value + 1;

	movzx	ecx, WORD PTR _value$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+224], cx

; 1862 : 	memcpychk(&wps, &data, sizeof(ushort), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wps$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1863 : 	simdata.numWaypoints = wps;

	movzx	eax, WORD PTR _wps$[ebp]
	mov	DWORD PTR _simdata$[ebp+144], eax
$LN26@Deaggregat:

; 1864 : 
; 1865 : 	while (wps)	{

	movzx	ecx, WORD PTR _wps$[ebp]
	test	ecx, ecx
	je	$LN25@Deaggregat

; 1866 : 		w = new WayPointClass(&data, rem);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN33@Deaggregat
	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0WayPointClass@@QAE@PAPAEPAJ@Z	; WayPointClass::WayPointClass
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN34@Deaggregat
$LN33@Deaggregat:
	mov	DWORD PTR tv207[ebp], 0
$LN34@Deaggregat:
	mov	ecx, DWORD PTR tv207[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR _w$[ebp], edx

; 1867 : 		if (!wp_list){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+244], 0
	jne	SHORT $LN24@Deaggregat

; 1868 : 			wp_list = w;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [ecx+244], edx
	jmp	SHORT $LN21@Deaggregat
$LN24@Deaggregat:

; 1869 : 		}
; 1870 : 		else if (lw){

	cmp	DWORD PTR _lw$[ebp], 0
	je	SHORT $LN22@Deaggregat

; 1871 : 			lw->InsertWP(w);

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lw$[ebp]
	call	?InsertWP@WayPointClass@@QAEXPAV1@@Z	; WayPointClass::InsertWP

; 1872 : 		}
; 1873 : 		else {

	jmp	SHORT $LN21@Deaggregat
$LN22@Deaggregat:

; 1874 : 			delete w;

	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@Deaggregat:

; 1875 : 		}
; 1876 : 		lw = w;

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _lw$[ebp], eax

; 1877 : 		wps--;

	mov	cx, WORD PTR _wps$[ebp]
	sub	cx, 1
	mov	WORD PTR _wps$[ebp], cx

; 1878 : 	}

	jmp	$LN26@Deaggregat
$LN25@Deaggregat:

; 1879 : 
; 1880 : 	simdata.waypointList = NULL;

	mov	DWORD PTR _simdata$[ebp+160], 0

; 1881 : 	simdata.vehicleInUnit = -1;

	or	edx, -1
	mov	WORD PTR _simdata$[ebp+42], dx

; 1882 : 	// sfr: @todo reorganize this, passing this stuff to FlightClass DeaggregateFromData
; 1883 : 	if (IsFlight())	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN20@Deaggregat

; 1884 : 		// Copy in flight's loadout data
; 1885 : 		memcpychk(&fuel, &data, sizeof(long), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	lea	eax, DWORD PTR _fuel$[ebp]
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1886 : 		// This is fuel burnt
; 1887 : 		SetBurntFuel(fuel);

	mov	ecx, DWORD PTR _fuel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+600]
	call	edx

; 1888 : 		memcpychk(&value, &data, sizeof(uchar), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1889 : 		ShiAssert (value > 0);
; 1890 : 		loadlist = new LoadoutStruct[value];

	movzx	eax, WORD PTR _value$[ebp]
	mov	DWORD PTR $T12[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T12[ebp]
	mov	edx, 48					; 00000030H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN35@Deaggregat
	push	OFFSET ??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR $T14[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T14[ebp]
	mov	DWORD PTR tv251[ebp], edx
	jmp	SHORT $LN36@Deaggregat
$LN35@Deaggregat:
	mov	DWORD PTR tv251[ebp], 0
$LN36@Deaggregat:
	mov	eax, DWORD PTR tv251[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _loadlist$[ebp], ecx

; 1891 : 		//loadlist = (LoadoutStruct *)MemAllocPtr(LoadoutStruct::pool, sizeof(LoadoutStruct)*(value), FALSE );
; 1892 : 		for (ushort v=0; v<value; v++)	{

	xor	edx, edx
	mov	WORD PTR _v$17[ebp], dx
	jmp	SHORT $LN19@Deaggregat
$LN18@Deaggregat:
	mov	ax, WORD PTR _v$17[ebp]
	add	ax, 1
	mov	WORD PTR _v$17[ebp], ax
$LN19@Deaggregat:
	movzx	ecx, WORD PTR _v$17[ebp]
	movzx	edx, WORD PTR _value$[ebp]
	cmp	ecx, edx
	jge	$LN17@Deaggregat

; 1893 : 			for (i=0; i<HARDPOINT_MAX; i++)	{

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Deaggregat
$LN15@Deaggregat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@Deaggregat:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN14@Deaggregat

; 1894 : 				memcpychk(&loadlist[v].WeaponID[i], &data, sizeof (short), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	movzx	eax, WORD PTR _v$17[ebp]
	imul	eax, 48					; 00000030H
	add	eax, DWORD PTR _loadlist$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*2]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1895 : 				memcpychk(&loadlist[v].WeaponCount[i], &data, sizeof (uchar), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _v$17[ebp]
	imul	edx, 48					; 00000030H
	add	edx, DWORD PTR _loadlist$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [edx+eax+32]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1896 : 			}

	jmp	SHORT $LN15@Deaggregat
$LN14@Deaggregat:

; 1897 : 		}

	jmp	$LN18@Deaggregat
$LN17@Deaggregat:

; 1898 : 		SetLoadout(loadlist, value);

	movzx	edx, WORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadlist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+636]
	call	eax

; 1899 : 		simdata.callsignIdx = ((Flight)this)->callsign_id;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+425]
	mov	DWORD PTR _simdata$[ebp+152], edx

; 1900 : 		simdata.callsignNum = ((Flight)this)->callsign_num;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+426]
	mov	DWORD PTR _simdata$[ebp+156], ecx

; 1901 : 	}
; 1902 : 	else {

	jmp	SHORT $LN13@Deaggregat
$LN20@Deaggregat:

; 1903 : 		simdata.callsignIdx = 0;

	mov	DWORD PTR _simdata$[ebp+152], 0

; 1904 : 		simdata.callsignNum = 0;

	mov	DWORD PTR _simdata$[ebp+156], 0
$LN13@Deaggregat:

; 1905 : 	}
; 1906 : 
; 1907 : 	// Set the owner of the newly created deaggregated entities
; 1908 : 	SetDeagOwner (owning_session->Id());

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _owning_session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDeagOwner@CampBaseClass@@QAEXVVU_ID@@@Z ; CampBaseClass::SetDeagOwner

; 1909 : 
; 1910 : 	simdata.forcedId.creator_ = creating_session->Id().creator_;

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _creating_session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _simdata$[ebp+20], ecx

; 1911 : 
; 1912 : 	SetAggregate(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAggregate@CampBaseClass@@QAEX_N@Z	; CampBaseClass::SetAggregate

; 1913 : 
; 1914 : 	simdata.displayPriority = 0;

	mov	BYTE PTR _simdata$[ebp+164], 0

; 1915 : 	simdata.side = GetOwner();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	edx, al
	mov	DWORD PTR _simdata$[ebp+52], edx

; 1916 : 	simdata.campBase = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _simdata$[ebp+12], eax

; 1917 : 	simdata.createType = SimInitDataClass::CampaignVehicle;

	mov	DWORD PTR _simdata$[ebp], 7

; 1918 : 	simdata.createFlags = SIDC_SILENT_INSERT | SIDC_FORCE_ID;

	mov	DWORD PTR _simdata$[ebp+4], 5

; 1919 : 	simdata.ptIndex = 0;

	mov	DWORD PTR _simdata$[ebp+84], 0

; 1920 : 	if (owning_session != FalconLocalSession) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _owning_session$[ebp], eax
	je	SHORT $LN12@Deaggregat

; 1921 : 		simdata.createFlags |= SIDC_REMOTE_OWNER;

	mov	ecx, DWORD PTR _simdata$[ebp+4]
	or	ecx, 2
	mov	DWORD PTR _simdata$[ebp+4], ecx

; 1922 : 		simdata.owner = owning_session;

	mov	edx, DWORD PTR _owning_session$[ebp]
	mov	DWORD PTR _simdata$[ebp+8], edx
$LN12@Deaggregat:

; 1923 : 	}
; 1924 : 	
; 1925 : 	for (unsigned int vg=0; vg<VEHICLE_GROUPS_PER_UNIT; vg++) {

	mov	DWORD PTR _vg$15[ebp], 0
	jmp	SHORT $LN11@Deaggregat
$LN10@Deaggregat:
	mov	eax, DWORD PTR _vg$15[ebp]
	add	eax, 1
	mov	DWORD PTR _vg$15[ebp], eax
$LN11@Deaggregat:
	cmp	DWORD PTR _vg$15[ebp], 16		; 00000010H
	jae	$LN9@Deaggregat

; 1926 : 		int vehs = GetNumVehicles(vg);

	mov	ecx, DWORD PTR _vg$15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	DWORD PTR _vehs$13[ebp], eax

; 1927 : 		classID = GetVehicleID(vg);

	mov	edx, DWORD PTR _vg$15[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	mov	DWORD PTR _classID$[ebp], eax

; 1928 : 		inslot = 0;

	mov	DWORD PTR _inslot$[ebp], 0
$LN8@Deaggregat:

; 1929 : 		while (vehs && classID) {

	cmp	DWORD PTR _vehs$13[ebp], 0
	je	$LN7@Deaggregat
	cmp	DWORD PTR _classID$[ebp], 0
	je	$LN7@Deaggregat

; 1930 : 			// Adjust to the correctly textured object (Dogfight only)
; 1931 : 			if (FalconLocalGame->GetGameType() == game_Dogfight) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@Deaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv397[ebp], eax
	jmp	SHORT $LN38@Deaggregat
$LN37@Deaggregat:
	mov	DWORD PTR tv397[ebp], 0
$LN38@Deaggregat:
	mov	ecx, DWORD PTR tv397[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN6@Deaggregat

; 1932 : 				classID = SimDogfight.AdjustClassId(GetVehicleID(vg),GetTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _vg$15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	edx, ax
	push	edx
	mov	ecx, OFFSET ?SimDogfight@@3VDogfightClass@@A ; SimDogfight
	call	?AdjustClassId@DogfightClass@@QAEHHH@Z	; DogfightClass::AdjustClassId
	mov	DWORD PTR _classID$[ebp], eax
$LN6@Deaggregat:

; 1933 : 			}
; 1934 : 			uchar slot;
; 1935 : 			memcpychk(&slot, &data, sizeof(uchar), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _slot$16[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1936 : 			simdata.campSlot = slot;

	movzx	eax, BYTE PTR _slot$16[ebp]
	mov	DWORD PTR _simdata$[ebp+32], eax

; 1937 : 			simdata.inSlot = inslot;

	mov	ecx, DWORD PTR _inslot$[ebp]
	mov	DWORD PTR _simdata$[ebp+36], ecx

; 1938 : 			if (slot*3 + inslot >= 48){ 

	movzx	edx, BYTE PTR _slot$16[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _inslot$[ebp]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN5@Deaggregat

; 1939 : 				printf("battalion heir will exceed\n"); 

	push	OFFSET ??_C@_0BM@JKDKHHG@battalion?5heir?5will?5exceed?6?$AA@
	call	_printf
	add	esp, 4
$LN5@Deaggregat:

; 1940 : 			}
; 1941 : 
; 1942 : 			// Set the position initially to the unit's real position
; 1943 : 			simdata.x = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _simdata$[ebp+56]

; 1944 : 			simdata.y = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _simdata$[ebp+60]

; 1945 : 			simdata.z = ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _simdata$[ebp+64]

; 1946 : 
; 1947 : 			// Now query for any offsets
; 1948 : 			motiontype = GetVehicleDeagData(&simdata,TRUE);

	push	1
	lea	eax, DWORD PTR _simdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+548]
	call	eax
	mov	DWORD PTR _motiontype$[ebp], eax

; 1949 : 
; 1950 : 			if (motiontype < 0)	{

	cmp	DWORD PTR _motiontype$[ebp], 0
	jge	SHORT $LN4@Deaggregat

; 1951 : 				// Technically, if we get here the flight should have been canceled, so just do it.
; 1952 : 				CancelFlight((Flight)this);						

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?CancelFlight@@YAXPAVFlightClass@@@Z	; CancelFlight
	add	esp, 4

; 1953 : 				return;

	jmp	$LN29@Deaggregat
$LN4@Deaggregat:

; 1954 : 			}
; 1955 : 
; 1956 : 			// Now decode positions and heading
; 1957 : 			memcpychk(&simdata.forcedId.num_,&data,sizeof(VU_ID_NUMBER), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _simdata$[ebp+16]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1958 : 			memcpychk(&simdata.x, &data, sizeof(float), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _simdata$[ebp+56]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1959 : 			memcpychk(&simdata.y,& data, sizeof(float), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _simdata$[ebp+60]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1960 : 			memcpychk(&simdata.heading, &data, sizeof(float), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _simdata$[ebp+68]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1961 : 			memcpychk(&simdata.ptIndex, &data, sizeof(short), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _simdata$[ebp+84]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 1962 : 
; 1963 : 			vc = GetVehicleClassData(classID);

	mov	edx, DWORD PTR _classID$[ebp]
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 1964 : 			simdata.status = VIS_NORMAL;

	mov	DWORD PTR _simdata$[ebp+48], 0

; 1965 : 			simdata.descriptionIndex = classID + VU_LAST_ENTITY_TYPE;

	mov	eax, DWORD PTR _classID$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _simdata$[ebp+28], eax

; 1966 : 			simdata.flags = vc->Flags;

	mov	ecx, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _simdata$[ebp+76], edx

; 1967 : 
; 1968 : 			// This actually adds the bugger
; 1969 : 			newObject = AddObjectToSim (&simdata, motiontype);

	mov	eax, DWORD PTR _motiontype$[ebp]
	push	eax
	lea	ecx, DWORD PTR _simdata$[ebp]
	push	ecx
	call	?AddObjectToSim@@YAPAVSimBaseClass@@PAVSimInitDataClass@@H@Z ; AddObjectToSim
	add	esp, 8
	mov	DWORD PTR _newObject$[ebp], eax

; 1970 : 			if (newObject){

	cmp	DWORD PTR _newObject$[ebp], 0
	je	SHORT $LN3@Deaggregat

; 1971 : 				GetComponents()->ForcedInsert(newObject);

	mov	edx, DWORD PTR _newObject$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	ecx, eax
	call	?ForcedInsert@TailInsertList@@QAEHPAVVuEntity@@@Z ; TailInsertList::ForcedInsert
$LN3@Deaggregat:

; 1972 : 			}
; 1973 : 
; 1974 : 			vehs--;

	mov	eax, DWORD PTR _vehs$13[ebp]
	sub	eax, 1
	mov	DWORD PTR _vehs$13[ebp], eax

; 1975 : 			inslot++;

	mov	ecx, DWORD PTR _inslot$[ebp]
	add	ecx, 1
	mov	DWORD PTR _inslot$[ebp], ecx

; 1976 : 		}

	jmp	$LN8@Deaggregat
$LN7@Deaggregat:

; 1977 : 	}

	jmp	$LN10@Deaggregat
$LN9@Deaggregat:

; 1978 : 
; 1979 : 	// Update our local wake status
; 1980 : #if NEW_WAKE
; 1981 : 	if (this->OwnerId() == vuLocalSessionEntity->Id()){

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Deaggregat

; 1982 : 		Wake();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx

; 1983 : 	}
; 1984 : 	else {

	jmp	SHORT $LN1@Deaggregat
$LN2@Deaggregat:

; 1985 : 		Sleep();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN1@Deaggregat:

; 1986 : 	}
; 1987 : #else
; 1988 : 	if ((owning_session == FalconLocalSession) || (FalconLocalSession->InSessionBubble(this,1.0F)>0)){
; 1989 : 		Wake();
; 1990 : 	}
; 1991 : 	else{
; 1992 : 		SetAwake(0);
; 1993 : 	}
; 1994 : #endif
; 1995 : 
; 1996 : 	//adds the unit to deaggregated list
; 1997 : #if USE_VU_COLL_FOR_CAMPAIGN
; 1998 : 	deaggregatedEntities->ForcedInsert(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	call	?ForcedInsert@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::ForcedInsert
$LN29@Deaggregat:

; 1999 : #else
; 2000 : 	deaggregatedMap->insert(CampBaseBin(this));
; 2001 : #endif
; 2002 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z$0:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z$1:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z$2:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-348]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeaggregateFromData@UnitClass@@UAEXPAEJ@Z ENDP		; UnitClass::DeaggregateFromData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemoveFromSimLists@UnitClass@@UAEXXZ PROC		; UnitClass::RemoveFromSimLists
; _this$ = ecx

; 1809 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1810 : 	// remove drawable from drawing
; 1811 : 	if (  draw_pointer )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+240], 0
	je	SHORT $LN2@RemoveFrom

; 1812 : 	{
; 1813 : 		OTWDriver.RemoveObject( draw_pointer, TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 1814 : 		draw_pointer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+240], 0
$LN2@RemoveFrom:

; 1815 : 	}
; 1816 : 
; 1817 : 	if (!InSimLists())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSimLists@CampBaseClass@@QAEHXZ	; CampBaseClass::InSimLists
	test	eax, eax
	jne	SHORT $LN1@RemoveFrom

; 1818 : 		return;

	jmp	SHORT $LN3@RemoveFrom
$LN1@RemoveFrom:

; 1819 : 
; 1820 : 	SetInSimLists(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetInSimLists@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetInSimLists

; 1821 : 	SimDriver.RemoveFromCampUnitList(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RemoveFromCampUnitList@SimulationDriver@@QAEXPAVVuEntity@@@Z ; SimulationDriver::RemoveFromCampUnitList
$LN3@RemoveFrom:

; 1822 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveFromSimLists@UnitClass@@UAEXXZ ENDP		; UnitClass::RemoveFromSimLists
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
tv431 = -216						; size = 4
$T2 = -212						; size = 4
tv421 = -208						; size = 4
tv532 = -204						; size = 4
tv426 = -200						; size = 4
tv530 = -196						; size = 4
_vc$3 = -192						; size = 4
tv436 = -188						; size = 4
$T4 = -184						; size = 4
tv528 = -180						; size = 4
tv201 = -176						; size = 4
_distsqu$ = -172					; size = 4
$T5 = -168						; size = 4
tv189 = -164						; size = 4
$T6 = -160						; size = 4
_drawdist$ = -156					; size = 4
_this$ = -152						; size = 4
_pos$7 = -148						; size = 12
_label$8 = -136						; size = 80
_part1$9 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_cameraX$ = 8						; size = 4
_cameraY$ = 12						; size = 4
?InsertInSimLists@UnitClass@@UAEXMM@Z PROC		; UnitClass::InsertInSimLists
; _this$ = ecx

; 1728 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InsertInSimLists@UnitClass@@UAEXMM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1729 : 	float	distsqu = (cameraX-XPos())*(cameraX-XPos()) + (cameraY-YPos())*(cameraY-YPos());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv421[ebp]
	movss	xmm0, DWORD PTR _cameraX$[ebp]
	subss	xmm0, DWORD PTR tv421[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv528[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv426[ebp]
	movss	xmm0, DWORD PTR _cameraX$[ebp]
	subss	xmm0, DWORD PTR tv426[ebp]
	movss	xmm1, DWORD PTR tv528[ebp]
	mulss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv530[ebp], xmm1
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv431[ebp]
	movss	xmm0, DWORD PTR _cameraY$[ebp]
	subss	xmm0, DWORD PTR tv431[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv532[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv436[ebp]
	movss	xmm0, DWORD PTR _cameraY$[ebp]
	subss	xmm0, DWORD PTR tv436[ebp]
	movss	xmm1, DWORD PTR tv532[ebp]
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv530[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _distsqu$[ebp], xmm0

; 1730 : 	float	drawdist = EntityType()->bubbleRange_ * VISUAL_CAMPAIGN_UNIT_MULTIPLIER;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	movss	xmm0, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _drawdist$[ebp], xmm0

; 1731 : 
; 1732 : 	// This case is for the destructor's sleep call.
; 1733 : 	// Basically, we're going away, so don't put us in any lists.
; 1734 : 	if (VuState() > VU_MEM_ACTIVE || Inactive()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	jg	SHORT $LN17@InsertInSi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Inactive@UnitClass@@QBEHXZ		; UnitClass::Inactive
	test	eax, eax
	je	SHORT $LN18@InsertInSi
$LN17@InsertInSi:

; 1735 : 		return;

	jmp	$LN19@InsertInSi
$LN18@InsertInSi:

; 1736 : 	}
; 1737 : 
; 1738 : #ifdef CAMPAIGN_LABELS
; 1739 : 	if (PlayerOptions.NameTagsOn())

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?NameTagsOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::NameTagsOn
	test	eax, eax
	je	$LN16@InsertInSi

; 1740 : 	{
; 1741 : 		//		char tmpStr[40];
; 1742 : 
; 1743 : 		if (draw_pointer == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+240], 0
	jne	$LN15@InsertInSi

; 1744 : 		{
; 1745 : 			if (distsqu < drawdist*drawdist)

	movss	xmm0, DWORD PTR _drawdist$[ebp]
	mulss	xmm0, DWORD PTR _drawdist$[ebp]
	comiss	xmm0, DWORD PTR _distsqu$[ebp]
	jbe	$LN14@InsertInSi

; 1746 : 			{
; 1747 : 				Tpoint pos;
; 1748 : 
; 1749 : 				// get id of representative vehicle and its class data
; 1750 : 				VehicleClassDataType*	vc;
; 1751 : 				vc = GetVehicleClassData(GetVehicleID(0));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$3[ebp], eax

; 1752 : 				GetRealPosition(&pos.x,&pos.y,&pos.z);

	lea	edx, DWORD PTR _pos$7[ebp+8]
	push	edx
	lea	eax, DWORD PTR _pos$7[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pos$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+564]
	call	edx

; 1753 : 				if ( IsBattalion() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	$LN13@InsertInSi

; 1754 : 					draw_pointer = new DrawablePoint( 0xff666666, TRUE, &pos, 1.0f );

	push	100					; 00000064H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN21@InsertInSi
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos$7[ebp]
	push	ecx
	push	1
	push	-10066330				; ff666666H
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0DrawablePoint@@QAE@KHPBUTpoint@@M@Z	; DrawablePoint::DrawablePoint
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN22@InsertInSi
$LN21@InsertInSi:
	mov	DWORD PTR tv189[ebp], 0
$LN22@InsertInSi:
	mov	edx, DWORD PTR tv189[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+240], ecx

; 1755 : 				else

	jmp	SHORT $LN12@InsertInSi
$LN13@InsertInSi:

; 1756 : 					draw_pointer = new DrawablePoint( 0xff666666, FALSE, &pos, 1.0f );

	push	100					; 00000064H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN23@InsertInSi
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos$7[ebp]
	push	edx
	push	0
	push	-10066330				; ff666666H
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0DrawablePoint@@QAE@KHPBUTpoint@@M@Z	; DrawablePoint::DrawablePoint
	mov	DWORD PTR tv201[ebp], eax
	jmp	SHORT $LN24@InsertInSi
$LN23@InsertInSi:
	mov	DWORD PTR tv201[ebp], 0
$LN24@InsertInSi:
	mov	eax, DWORD PTR tv201[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+240], edx
$LN12@InsertInSi:

; 1757 : 
; 1758 : 				ShiAssert (TeamInfo[GetTeam()]);
; 1759 : 				if (TeamInfo[GetTeam()])

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	$LN6@InsertInSi

; 1760 : 				{
; 1761 : 					if (IsFlight())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN10@InsertInSi

; 1762 : 						draw_pointer->SetLabel(vc->Name, TeamSimColorList[TeamInfo[GetTeam()]->GetColor()]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetColor@TeamClass@@QAEHXZ		; TeamClass::GetColor
	mov	edx, DWORD PTR ?TeamSimColorList@@3PAJA[eax*4]
	push	edx
	mov	eax, DWORD PTR _vc$3[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+240]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1763 : 					else

	jmp	$LN6@InsertInSi
$LN10@InsertInSi:

; 1764 : 					{
; 1765 : 						if (gLangIDNum <= F4LANG_GERMAN || !IsBattalion())

	cmp	DWORD PTR ?gLangIDNum@@3HA, 3		; gLangIDNum
	jle	SHORT $LN7@InsertInSi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@InsertInSi
$LN7@InsertInSi:

; 1766 : 							draw_pointer->SetLabel(GetUnitClassName(), TeamSimColorList[TeamInfo[GetTeam()]->GetColor()]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetColor@TeamClass@@QAEHXZ		; TeamClass::GetColor
	mov	edx, DWORD PTR ?TeamSimColorList@@3PAJA[eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassName@UnitClass@@QAEPADXZ	; UnitClass::GetUnitClassName
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+240]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1767 : 						else

	jmp	$LN6@InsertInSi
$LN8@InsertInSi:

; 1768 : 						{
; 1769 : 							_TCHAR	part1[40],label[80];
; 1770 : 							GetSizeName(GetDomain(),GetType(),part1);

	lea	eax, DWORD PTR _part1$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	push	edx
	call	?GetSizeName@@YAPADHHPAD@Z		; GetSizeName
	add	esp, 12					; 0000000cH

; 1771 : 							_stprintf(label,"%s %s",part1,GetUnitClassName());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitClassName@UnitClass@@QAEPADXZ	; UnitClass::GetUnitClassName
	push	eax
	lea	eax, DWORD PTR _part1$9[ebp]
	push	eax
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
	lea	ecx, DWORD PTR _label$8[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1772 : 							draw_pointer->SetLabel(label, TeamSimColorList[TeamInfo[GetTeam()]->GetColor()]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetColor@TeamClass@@QAEHXZ		; TeamClass::GetColor
	mov	ecx, DWORD PTR ?TeamSimColorList@@3PAJA[eax*4]
	push	ecx
	lea	edx, DWORD PTR _label$8[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+240]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN6@InsertInSi:

; 1773 : 						}
; 1774 : 					}
; 1775 : 				}			
; 1776 : 				// put it in display
; 1777 : 				OTWDriver.InsertObject( draw_pointer );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN14@InsertInSi:

; 1778 : 			}
; 1779 : 		}
; 1780 : 		else

	jmp	SHORT $LN4@InsertInSi
$LN15@InsertInSi:

; 1781 : 		{
; 1782 : 			// drawpointer not null, check distance and remove drawpointer if too far
; 1783 : 			if ( distsqu > drawdist * drawdist )

	movss	xmm0, DWORD PTR _drawdist$[ebp]
	mulss	xmm0, DWORD PTR _drawdist$[ebp]
	movss	xmm1, DWORD PTR _distsqu$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@InsertInSi

; 1784 : 			{
; 1785 : 				OTWDriver.RemoveObject( draw_pointer, TRUE );

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 1786 : 				draw_pointer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], 0
$LN4@InsertInSi:

; 1787 : 			}
; 1788 : 		}

	jmp	SHORT $LN2@InsertInSi
$LN16@InsertInSi:

; 1789 : 	}
; 1790 : 	else if (draw_pointer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+240], 0
	je	SHORT $LN2@InsertInSi

; 1791 : 	{
; 1792 : 		OTWDriver.RemoveObject( draw_pointer, TRUE );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 1793 : 		draw_pointer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+240], 0
$LN2@InsertInSi:

; 1794 : 	}
; 1795 : #endif
; 1796 : 
; 1797 : 	//	SetChecked(1);
; 1798 : 
; 1799 : 	ShiAssert (Real());
; 1800 : 
; 1801 : 	if (InSimLists())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSimLists@CampBaseClass@@QAEHXZ	; CampBaseClass::InSimLists
	test	eax, eax
	je	SHORT $LN1@InsertInSi

; 1802 : 		return;

	jmp	SHORT $LN19@InsertInSi
$LN1@InsertInSi:

; 1803 : 
; 1804 : 	SetInSimLists(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetInSimLists@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetInSimLists

; 1805 : 	SimDriver.AddToCampUnitList(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AddToCampUnitList@SimulationDriver@@QAEXPAVVuEntity@@@Z ; SimulationDriver::AddToCampUnitList
$LN19@InsertInSi:

; 1806 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InsertInSimLists@UnitClass@@UAEXMM@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InsertInSimLists@UnitClass@@UAEXMM@Z$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InsertInSimLists@UnitClass@@UAEXMM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InsertInSimLists@UnitClass@@UAEXMM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InsertInSimLists@UnitClass@@UAEXMM@Z ENDP		; UnitClass::InsertInSimLists
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Sleep@UnitClass@@UAEHXZ PROC				; UnitClass::Sleep
; _this$ = ecx

; 1715 : int UnitClass::Sleep (void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1716 : 	SetAwake(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAwake@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetAwake

; 1717 : 
; 1718 : 	//	OTWDriver.LockObject ();
; 1719 : 	if (GetComponents ()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	SHORT $LN1@Sleep

; 1720 : 		SimDriver.SleepCampaignFlight(GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SleepCampaignFlight@SimulationDriver@@QAEXPAVTailInsertList@@@Z ; SimulationDriver::SleepCampaignFlight
$LN1@Sleep:

; 1721 : 	}
; 1722 : 	return 1;

	mov	eax, 1

; 1723 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Sleep@UnitClass@@UAEHXZ ENDP				; UnitClass::Sleep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Wake@UnitClass@@UAEHXZ PROC				; UnitClass::Wake
; _this$ = ecx

; 1699 : int UnitClass::Wake (void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1700 : 	// sfr: in MP, we need to run entities even if we are not inside game
; 1701 : #if !NEW_WAKE
; 1702 : 	if (!OTWDriver.IsActive()){ return 0; }
; 1703 : #endif
; 1704 : 
; 1705 : 	if (GetComponents()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	SHORT $LN2@Wake

; 1706 : 		SimDriver.WakeCampaignBase(TRUE, this, GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?WakeCampaignBase@SimulationDriver@@QAEXHPAVCampBaseClass@@PAVTailInsertList@@@Z ; SimulationDriver::WakeCampaignBase

; 1707 : 		SetAwake(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAwake@CampBaseClass@@QAEXH@Z	; CampBaseClass::SetAwake

; 1708 : 	}
; 1709 : 	else {

	jmp	SHORT $LN1@Wake
$LN2@Wake:

; 1710 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@Wake
$LN1@Wake:

; 1711 : 	}
; 1712 : 	return 1;

	mov	eax, 1
$LN3@Wake:

; 1713 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Wake@UnitClass@@UAEHXZ ENDP				; UnitClass::Wake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -72						; size = 8
$T3 = -64						; size = 8
_vuid$4 = -56						; size = 8
$T5 = -48						; size = 4
$T6 = -44						; size = 4
_vehleft$ = -40						; size = 4
tv234 = -36						; size = 4
$T7 = -32						; size = 4
tv223 = -28						; size = 4
_msg$8 = -24						; size = 4
_dataptr$9 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_session$ = 8						; size = 4
?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z PROC ; UnitClass::TransferOwnership
; _this$ = ecx

; 1661 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1662 : 	if (IsAggregate() || !IsLocal()){ return 0; }

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN6@TransferOw
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@TransferOw
$LN6@TransferOw:
	xor	eax, eax
	jmp	$LN8@TransferOw
$LN7@TransferOw:

; 1663 : 
; 1664 : 	// Record the current state here, and determine what we have remaining and Change ownership locally
; 1665 : 	int vehleft = RecordCurrentState(session, FALSE);

	push	0
	mov	ecx, DWORD PTR _session$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+328]
	call	edx
	mov	DWORD PTR _vehleft$[ebp], eax

; 1666 : 
; 1667 : 	// Set the new owner of the deaggregated entities
; 1668 : 	SetDeagOwner (session->Id());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDeagOwner@CampBaseClass@@QAEXVVU_ID@@@Z ; CampBaseClass::SetDeagOwner

; 1669 : 
; 1670 : 	// Kill off unit or send owenership transfer message
; 1671 : 	if (vehleft){

	cmp	DWORD PTR _vehleft$[ebp], 0
	je	$LN5@TransferOw

; 1672 : 		// Update our local wake status
; 1673 : 		if (IsAwake() && !FalconLocalSession->InSessionBubble(this,REAGREGATION_RATIO)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN4@TransferOw
	push	ecx
	movss	xmm0, DWORD PTR ?REAGREGATION_RATIO@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z ; FalconSessionEntity::InSessionBubble
	test	eax, eax
	jne	SHORT $LN4@TransferOw

; 1674 : 			Sleep();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax

; 1675 : 		}
; 1676 : 		else if (

	jmp	SHORT $LN2@TransferOw
$LN4@TransferOw:

; 1677 : 			!IsAwake() && (
; 1678 : 				session == FalconLocalSession || FalconLocalSession->InSessionBubble(this,1.0F)>0
; 1679 : 			)
; 1680 : 		){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN2@TransferOw
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _session$[ebp], eax
	je	SHORT $LN1@TransferOw
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?InSessionBubble@FalconSessionEntity@@QAEHPAVFalconEntity@@M@Z ; FalconSessionEntity::InSessionBubble
	test	eax, eax
	jle	SHORT $LN2@TransferOw
$LN1@TransferOw:

; 1681 : 			Wake();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx
$LN2@TransferOw:

; 1682 : 		}
; 1683 : 
; 1684 : 		// Send the transfer owenership message
; 1685 : 		FalconCampDataMessage *msg = new FalconCampDataMessage(Id(), FalconLocalGame);

	push	58					; 0000003aH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN12@TransferOw
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@TransferOw
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv223[ebp], eax
	jmp	SHORT $LN11@TransferOw
$LN10@TransferOw:
	mov	DWORD PTR tv223[ebp], 0
$LN11@TransferOw:
	push	1
	mov	ecx, DWORD PTR tv223[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconCampDataMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconCampDataMessage::FalconCampDataMessage
	mov	DWORD PTR tv234[ebp], eax
	jmp	SHORT $LN13@TransferOw
$LN12@TransferOw:
	mov	DWORD PTR tv234[ebp], 0
$LN13@TransferOw:
	mov	eax, DWORD PTR tv234[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _msg$8[ebp], ecx

; 1686 : 		msg->dataBlock.type = FalconCampDataMessage::campDeaggregateStatusChangeData;

	mov	edx, DWORD PTR _msg$8[ebp]
	mov	DWORD PTR [edx+48], 0

; 1687 : 		msg->dataBlock.size = sizeof(VU_ID) + sizeof(fourbyte);

	mov	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _msg$8[ebp]
	mov	WORD PTR [ecx+52], ax

; 1688 : 		msg->dataBlock.data = new uchar[msg->dataBlock.size];

	mov	edx, DWORD PTR _msg$8[ebp]
	movzx	eax, WORD PTR [edx+52]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR _msg$8[ebp]
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+54], edx

; 1689 : 		uchar	*dataptr = msg->dataBlock.data;

	mov	eax, DWORD PTR _msg$8[ebp]
	mov	ecx, DWORD PTR [eax+54]
	mov	DWORD PTR _dataptr$9[ebp], ecx

; 1690 : 		VU_ID	vuid = session->Id();

	lea	edx, DWORD PTR _vuid$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id

; 1691 : 		memcpy(dataptr, &vuid, sizeof(VU_ID));				dataptr += sizeof(VU_ID);

	push	8
	lea	eax, DWORD PTR _vuid$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataptr$9[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _dataptr$9[ebp]
	add	edx, 8
	mov	DWORD PTR _dataptr$9[ebp], edx

; 1692 : 		memcpy(dataptr, &roster, sizeof(fourbyte));			dataptr += sizeof(fourbyte);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	mov	ecx, DWORD PTR _dataptr$9[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _dataptr$9[ebp]
	add	edx, 4
	mov	DWORD PTR _dataptr$9[ebp], edx

; 1693 : 		FalconSendMessage(msg,TRUE);

	push	1
	mov	eax, DWORD PTR _msg$8[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN5@TransferOw:

; 1694 : 	}
; 1695 : 
; 1696 : 	return 1;

	mov	eax, 1
$LN8@TransferOw:

; 1697 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TransferOwnership@UnitClass@@UAEHPAVFalconSessionEntity@@@Z ENDP ; UnitClass::TransferOwnership
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_myit$2 = -96						; size = 12
$T3 = -84						; size = 8
$T4 = -76						; size = 8
$T5 = -68						; size = 4
tv242 = -64						; size = 4
$T6 = -60						; size = 4
_next$7 = -56						; size = 4
$T8 = -52						; size = 4
tv286 = -48						; size = 4
$T9 = -44						; size = 4
tv275 = -40						; size = 4
tv157 = -36						; size = 4
$T10 = -32						; size = 4
$T11 = -28						; size = 4
_vehicle$12 = -24					; size = 4
_msg$13 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_session$ = 8						; size = 4
?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z PROC ; UnitClass::Reaggregate
; _this$ = ecx

; 1598 : int UnitClass::Reaggregate (FalconSessionEntity* session){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1599 : 	if (IsAggregate() || !IsLocal())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN8@Reaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@Reaggregat
$LN8@Reaggregat:

; 1600 : 		return 0;

	xor	eax, eax
	jmp	$LN10@Reaggregat
$LN9@Reaggregat:

; 1601 : 
; 1602 : 	if (session && session->GetPlayerEntity() && (session->GetPlayerFlight() == this)){

	cmp	DWORD PTR _session$[ebp], 0
	je	SHORT $LN7@Reaggregat
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
	test	eax, eax
	je	SHORT $LN7@Reaggregat
	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerFlight@FalconSessionEntity@@QBEPAVFlightClass@@XZ ; FalconSessionEntity::GetPlayerFlight
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN7@Reaggregat

; 1603 : 		// A player is in this unit, so don't reaggregate
; 1604 : 		return 0;

	xor	eax, eax
	jmp	$LN10@Reaggregat
$LN7@Reaggregat:

; 1605 : 	}
; 1606 : 
; 1607 : 	// Record the current state here, and determine what we have remaining
; 1608 : 	RecordCurrentState(NULL, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	call	eax

; 1609 : 
; 1610 : 	// We need to do some special case stuff:
; 1611 : 	if (IsBattalion() && !IsDead()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN6@Reaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@Reaggregat

; 1612 : 		((Battalion)this)->deag_data = new UnitDeaggregationData;

	push	580					; 00000244H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN12@Reaggregat
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0UnitDeaggregationData@@QAE@XZ	; UnitDeaggregationData::UnitDeaggregationData
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN13@Reaggregat
$LN12@Reaggregat:
	mov	DWORD PTR tv157[ebp], 0
$LN13@Reaggregat:
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR [edx+360], eax

; 1613 : 		((Battalion)this)->deag_data->StoreDeaggregationData(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+360]
	call	?StoreDeaggregationData@UnitDeaggregationData@@QAEXPAVUnitClass@@@Z ; UnitDeaggregationData::StoreDeaggregationData
$LN6@Reaggregat:

; 1614 : 	}
; 1615 : 
; 1616 : 	if (IsAwake()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN5@Reaggregat

; 1617 : 		Sleep();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN5@Reaggregat:

; 1618 : 	}
; 1619 : 
; 1620 : 	SetAggregate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAggregate@CampBaseClass@@QAEX_N@Z	; CampBaseClass::SetAggregate

; 1621 : 
; 1622 : 	// chill the sim vehicles
; 1623 : 	if (GetComponents())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	$LN4@Reaggregat

; 1624 : 	{
; 1625 : 		CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 1626 : 		{
; 1627 : 			VuEntity *vehicle, *next;
; 1628 : 			VuListIterator	myit(GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1629 : 			vehicle = myit.GetFirst();

	lea	ecx, DWORD PTR _myit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _vehicle$12[ebp], eax
$LN3@Reaggregat:

; 1630 : 			while (vehicle){

	cmp	DWORD PTR _vehicle$12[ebp], 0
	je	SHORT $LN2@Reaggregat

; 1631 : 				next = myit.GetNext();

	lea	ecx, DWORD PTR _myit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _next$7[ebp], eax

; 1632 : 				((SimBaseClass*)vehicle)->SetRemoveFlag();

	mov	ecx, DWORD PTR _vehicle$12[ebp]
	call	?SetRemoveFlag@SimBaseClass@@QAEXXZ	; SimBaseClass::SetRemoveFlag

; 1633 : 				vehicle = next;

	mov	ecx, DWORD PTR _next$7[ebp]
	mov	DWORD PTR _vehicle$12[ebp], ecx

; 1634 : 			}

	jmp	SHORT $LN3@Reaggregat
$LN2@Reaggregat:

; 1635 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1636 : 		GetComponents()->Unregister();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	ecx, eax
	call	?Unregister@VuCollection@@QAEXXZ	; VuCollection::Unregister

; 1637 : 		delete GetComponents();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	DWORD PTR $T6[ebp], eax
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T11[ebp], edx
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN14@Reaggregat
	push	1
	mov	eax, DWORD PTR $T11[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T11[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR tv242[ebp], eax
	jmp	SHORT $LN15@Reaggregat
$LN14@Reaggregat:
	mov	DWORD PTR tv242[ebp], 0
$LN15@Reaggregat:

; 1638 : 		SetComponents (NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetComponents@CampBaseClass@@QAEXPAVTailInsertList@@@Z ; CampBaseClass::SetComponents

; 1639 : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection
$LN4@Reaggregat:

; 1640 : 	}
; 1641 : 
; 1642 : 	if (TheCampaign.IsOnline()){

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?IsOnline@CampaignClass@@QAEHXZ		; CampaignClass::IsOnline
	test	eax, eax
	je	$LN1@Reaggregat

; 1643 : 		// Send Reaggregation data to everyone in the group
; 1644 : 		FalconSimCampMessage *msg = new FalconSimCampMessage(Id(), FalconLocalGame);

	push	66					; 00000042H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN18@Reaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@Reaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN17@Reaggregat
$LN16@Reaggregat:
	mov	DWORD PTR tv275[ebp], 0
$LN17@Reaggregat:
	push	1
	mov	edx, DWORD PTR tv275[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconSimCampMessage::FalconSimCampMessage
	mov	DWORD PTR tv286[ebp], eax
	jmp	SHORT $LN19@Reaggregat
$LN18@Reaggregat:
	mov	DWORD PTR tv286[ebp], 0
$LN19@Reaggregat:
	mov	eax, DWORD PTR tv286[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _msg$13[ebp], ecx

; 1645 : 		msg->dataBlock.message = FalconSimCampMessage::simcampReaggregateFromData;

	mov	edx, DWORD PTR _msg$13[ebp]
	mov	DWORD PTR [edx+56], 3

; 1646 : 		msg->dataBlock.from = GetDeagOwner();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ; CampBaseClass::GetDeagOwner
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$13[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 1647 : 		msg->dataBlock.size = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _msg$13[ebp]
	mov	WORD PTR [edx+60], cx

; 1648 : 		msg->dataBlock.data = NULL;

	mov	eax, DWORD PTR _msg$13[ebp]
	mov	DWORD PTR [eax+62], 0

; 1649 : 		FalconSendMessage(msg,TRUE);

	push	1
	mov	ecx, DWORD PTR _msg$13[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN1@Reaggregat:

; 1650 : 	}
; 1651 : 
; 1652 : #if USE_VU_COLL_FOR_CAMPAIGN
; 1653 : 	deaggregatedEntities->Remove(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	call	?Remove@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::Remove

; 1654 : #else
; 1655 : 	deaggregatedMap->remove(this->Id());
; 1656 : #endif
; 1657 : 	return 1;

	mov	eax, 1
$LN10@Reaggregat:

; 1658 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$0:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$1:
	lea	ecx, DWORD PTR _myit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$2:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Reaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z ENDP ; UnitClass::Reaggregate
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -324						; size = 8
$T3 = -316						; size = 8
$T4 = -308						; size = 8
$T5 = -300						; size = 8
$T6 = -292						; size = 4
_vc$ = -288						; size = 4
_y$ = -284						; size = 4
_airbase$7 = -280					; size = 4
_x$ = -276						; size = 4
_nextTOTime$8 = -272					; size = 4
$T9 = -268						; size = 4
_z$ = -264						; size = 4
tv489 = -260						; size = 4
tv245 = -256						; size = 4
_newObject$ = -252					; size = 4
_ent$10 = -248						; size = 4
_motiontype$ = -244					; size = 4
_brain$11 = -240					; size = 4
tv395 = -236						; size = 4
tv364 = -232						; size = 4
_airbase$12 = -228					; size = 4
_vehs$ = -224						; size = 4
_inslot$ = -220						; size = 4
_w$13 = -216						; size = 4
_base$ = -212						; size = 4
_rwIndex$ = -208					; size = 4
_dfClassID$14 = -204					; size = 2
_brain$15 = -200					; size = 4
_v$ = -196						; size = 4
_classID$ = -192					; size = 2
_this$ = -188						; size = 4
_simdata$ = -184					; size = 168
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_session$ = 8						; size = 4
?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z PROC ; UnitClass::Deaggregate
; _this$ = ecx

; 1399 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1400 : 	if (!IsLocal() || !IsAggregate() || IsDead()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN30@Deaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN30@Deaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+552]
	call	eax
	test	eax, eax
	je	SHORT $LN31@Deaggregat
$LN30@Deaggregat:

; 1401 : 		return 0;

	xor	eax, eax
	jmp	$LN32@Deaggregat
$LN31@Deaggregat:

; 1402 : 	}
; 1403 : 
; 1404 : 	SimInitDataClass		simdata;

	lea	ecx, DWORD PTR _simdata$[ebp]
	call	??0SimInitDataClass@@QAE@XZ

; 1405 : 	int						v,vehs,motiontype,inslot,rwIndex;
; 1406 : 	VehicleID				classID;
; 1407 : 	VehicleClassDataType	*vc;
; 1408 : 	float					x,y,z;
; 1409 : 	VuEntity				*newObject;
; 1410 : 
; 1411 : 	memset(&simdata, 0, sizeof(simdata));

	push	168					; 000000a8H
	push	0
	lea	ecx, DWORD PTR _simdata$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1412 : 
; 1413 : 	simdata.rwIndex = rwIndex = 0;

	mov	DWORD PTR _rwIndex$[ebp], 0
	mov	edx, DWORD PTR _rwIndex$[ebp]
	mov	DWORD PTR _simdata$[ebp+88], edx

; 1414 : 
; 1415 : 	CampBaseClass *base = GetUnitAirbase();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+704]
	call	eax
	mov	DWORD PTR _base$[ebp], eax

; 1416 : 	if (base != NULL && GetCurrentWaypoint() == 1){

	cmp	DWORD PTR _base$[ebp], 0
	je	$LN27@Deaggregat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentWaypoint@UnitClass@@QAEGXZ	; UnitClass::GetCurrentWaypoint
	movzx	ecx, ax
	cmp	ecx, 1
	jne	$LN27@Deaggregat

; 1417 : 		// for airbases, add to runway lists
; 1418 : 		ATCBrain *brain = NULL;

	mov	DWORD PTR _brain$15[ebp], 0

; 1419 : 		if (base->IsObjective()){

	mov	edx, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	je	$LN27@Deaggregat

; 1420 : 			// pt data works only for airbases
; 1421 : 			ObjectiveClass *airbase = static_cast<ObjectiveClass*>(base);

	mov	eax, DWORD PTR _base$[ebp]
	mov	DWORD PTR _airbase$7[ebp], eax

; 1422 : 			brain = airbase->brain;

	mov	ecx, DWORD PTR _airbase$7[ebp]
	mov	edx, DWORD PTR [ecx+240]
	mov	DWORD PTR _brain$15[ebp], edx

; 1423 : 			if (brain){

	cmp	DWORD PTR _brain$15[ebp], 0
	je	SHORT $LN27@Deaggregat

; 1424 : 				rwIndex = brain->FindBestTakeoffRunway(TRUE);

	push	1
	mov	ecx, DWORD PTR _brain$15[ebp]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _rwIndex$[ebp], eax

; 1425 : 				simdata.rwIndex = rwIndex;

	mov	eax, DWORD PTR _rwIndex$[ebp]
	mov	DWORD PTR _simdata$[ebp+88], eax

; 1426 : 				ulong nextTOTime = brain->FindFlightTakeoffTime(
; 1427 : 					static_cast<FlightClass*>(const_cast<UnitClass*>(this)), GetQueue(rwIndex)
; 1428 : 				);

	mov	ecx, DWORD PTR _rwIndex$[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _brain$15[ebp]
	call	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z ; ATCBrain::FindFlightTakeoffTime
	mov	DWORD PTR _nextTOTime$8[ebp], eax

; 1429 : 				brain->AddTraffic(this->Id(), noATC, rwIndex, nextTOTime);

	mov	eax, DWORD PTR _nextTOTime$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _rwIndex$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _brain$15[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
$LN27@Deaggregat:

; 1430 : 			}
; 1431 : 		}
; 1432 : 	}
; 1433 : 
; 1434 : 	//delete spi;
; 1435 : 	//spi = new ScopeProfiler("UDEAG2", 6000);
; 1436 : 
; 1437 : 	// Check for possible problems
; 1438 : 	if (IsFlight())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN20@Deaggregat

; 1439 : 	{
; 1440 : 		CampEntity				ent = NULL;

	mov	DWORD PTR _ent$10[ebp], 0

; 1441 : 		simdata.ptIndex = GetDeaggregationPoint(0, &ent);

	lea	ecx, DWORD PTR _ent$10[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+468]
	call	edx
	mov	DWORD PTR _simdata$[ebp+84], eax

; 1442 : 		ObjectiveClass *airbase = static_cast<ObjectiveClass*>(ent);

	mov	eax, DWORD PTR _ent$10[ebp]
	mov	DWORD PTR _airbase$12[ebp], eax

; 1443 : 		ATCBrain *brain = NULL;

	mov	DWORD PTR _brain$11[ebp], 0

; 1444 : 		if (airbase)

	cmp	DWORD PTR _airbase$12[ebp], 0
	je	SHORT $LN25@Deaggregat

; 1445 : 			brain = airbase->brain;

	mov	ecx, DWORD PTR _airbase$12[ebp]
	mov	edx, DWORD PTR [ecx+240]
	mov	DWORD PTR _brain$11[ebp], edx
$LN25@Deaggregat:

; 1446 : 		if (brain)

	cmp	DWORD PTR _brain$11[ebp], 0
	je	SHORT $LN24@Deaggregat

; 1447 : 			simdata.rwIndex = airbase->brain->FindBestTakeoffRunway(false);

	push	0
	mov	eax, DWORD PTR _airbase$12[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _simdata$[ebp+88], eax

; 1448 : 		else

	jmp	SHORT $LN23@Deaggregat
$LN24@Deaggregat:

; 1449 : 			simdata.rwIndex = 0;

	mov	DWORD PTR _simdata$[ebp+88], 0
$LN23@Deaggregat:

; 1450 : 		if (simdata.ptIndex == DPT_ERROR_NOT_READY)

	cmp	DWORD PTR _simdata$[ebp+84], -1
	jne	SHORT $LN22@Deaggregat

; 1451 : 		{
; 1452 : 			return 0;

	xor	eax, eax
	jmp	$LN32@Deaggregat
	jmp	SHORT $LN20@Deaggregat
$LN22@Deaggregat:

; 1453 : 		}
; 1454 : 		else if (simdata.ptIndex == DPT_ERROR_CANT_PLACE){

	cmp	DWORD PTR _simdata$[ebp+84], -2		; fffffffeH
	jne	SHORT $LN20@Deaggregat

; 1455 : 			//				ShiAssert(0);
; 1456 : 			// Technically, if we get here the flight should have been canceled, so just do it.
; 1457 : 			CancelFlight((Flight)this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?CancelFlight@@YAXPAVFlightClass@@@Z	; CancelFlight
	add	esp, 4

; 1458 : 			return 0;

	xor	eax, eax
	jmp	$LN32@Deaggregat
$LN20@Deaggregat:

; 1459 : 		}
; 1460 : 	}
; 1461 : 
; 1462 : 	if (!session){

	cmp	DWORD PTR _session$[ebp], 0
	jne	SHORT $LN19@Deaggregat

; 1463 : 		session = FalconLocalSession;

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	DWORD PTR _session$[ebp], eax
$LN19@Deaggregat:

; 1464 : 	}
; 1465 : 
; 1466 : 	// Set the owner of the newly created deaggregated entities
; 1467 : 	SetDeagOwner (session->Id());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDeagOwner@CampBaseClass@@QAEXVVU_ID@@@Z ; CampBaseClass::SetDeagOwner

; 1468 : 	GetRealPosition(&x,&y,&z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+564]
	call	eax

; 1469 : 
; 1470 : 	SetComponents (new TailInsertList());

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN34@Deaggregat
	push	OFFSET ?FalconNothingFilter@@3VFalconNothingFilterType@@A ; FalconNothingFilter
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0TailInsertList@@QAE@PAVVuFilter@@@Z	; TailInsertList::TailInsertList
	mov	DWORD PTR tv245[ebp], eax
	jmp	SHORT $LN35@Deaggregat
$LN34@Deaggregat:
	mov	DWORD PTR tv245[ebp], 0
$LN35@Deaggregat:
	mov	ecx, DWORD PTR tv245[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetComponents@CampBaseClass@@QAEXPAVTailInsertList@@@Z ; CampBaseClass::SetComponents

; 1471 : 	GetComponents()->Register();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	ecx, eax
	call	?Register@VuCollection@@QAEXXZ		; VuCollection::Register

; 1472 : 
; 1473 : 	// Fill the reusable simdata class.
; 1474 : 	simdata.side = GetOwner();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	eax, al
	mov	DWORD PTR _simdata$[ebp+52], eax

; 1475 : 	simdata.displayPriority = 0;

	mov	BYTE PTR _simdata$[ebp+164], 0

; 1476 : 	simdata.campBase = this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _simdata$[ebp+12], ecx

; 1477 : 	simdata.vehicleInUnit = -1;

	or	edx, -1
	mov	WORD PTR _simdata$[ebp+42], dx

; 1478 : 	if (IsFlight()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN18@Deaggregat

; 1479 : 		WayPoint			w;
; 1480 : 		simdata.callsignIdx = ((Flight)this)->callsign_id;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+425]
	mov	DWORD PTR _simdata$[ebp+152], edx

; 1481 : 		simdata.callsignNum = ((Flight)this)->callsign_num;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+426]
	mov	DWORD PTR _simdata$[ebp+156], ecx

; 1482 : 		// Setup waypoint data
; 1483 : 		simdata.numWaypoints = 0;

	mov	DWORD PTR _simdata$[ebp+144], 0

; 1484 : 		w = GetFirstUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$13[ebp], eax
$LN17@Deaggregat:

; 1485 : 		while (w)

	cmp	DWORD PTR _w$13[ebp], 0
	je	SHORT $LN16@Deaggregat

; 1486 : 		{
; 1487 : 			simdata.numWaypoints++;

	mov	edx, DWORD PTR _simdata$[ebp+144]
	add	edx, 1
	mov	DWORD PTR _simdata$[ebp+144], edx

; 1488 : 			w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$13[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$13[ebp], eax

; 1489 : 		}

	jmp	SHORT $LN17@Deaggregat
$LN16@Deaggregat:

; 1490 : 		simdata.currentWaypoint = current_wp-1;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+224]
	sub	ecx, 1
	mov	DWORD PTR _simdata$[ebp+148], ecx

; 1491 : 	}
; 1492 : 	else {

	jmp	SHORT $LN15@Deaggregat
$LN18@Deaggregat:

; 1493 : 		simdata.callsignIdx = 0;

	mov	DWORD PTR _simdata$[ebp+152], 0

; 1494 : 		simdata.callsignNum = 0;

	mov	DWORD PTR _simdata$[ebp+156], 0

; 1495 : 		simdata.waypointList = NULL;

	mov	DWORD PTR _simdata$[ebp+160], 0

; 1496 : 		simdata.currentWaypoint = -1;

	mov	DWORD PTR _simdata$[ebp+148], -1

; 1497 : 		simdata.numWaypoints = 0;

	mov	DWORD PTR _simdata$[ebp+144], 0
$LN15@Deaggregat:

; 1498 : 	}
; 1499 : 	simdata.createType = SimInitDataClass::CampaignVehicle;

	mov	DWORD PTR _simdata$[ebp], 7

; 1500 : 	simdata.createFlags = SIDC_SILENT_INSERT;

	mov	DWORD PTR _simdata$[ebp+4], 1

; 1501 : 	if (session != FalconLocalSession)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	DWORD PTR _session$[ebp], eax
	je	SHORT $LN14@Deaggregat

; 1502 : 	{
; 1503 : 		simdata.createFlags |= SIDC_REMOTE_OWNER;

	mov	edx, DWORD PTR _simdata$[ebp+4]
	or	edx, 2
	mov	DWORD PTR _simdata$[ebp+4], edx

; 1504 : 		simdata.owner = session;

	mov	eax, DWORD PTR _session$[ebp]
	mov	DWORD PTR _simdata$[ebp+8], eax
$LN14@Deaggregat:

; 1505 : 	}
; 1506 : 
; 1507 : 	// VP_changes for tracing DB 
; 1508 : 	/*	FILE* deb = fopen("c:\\traceA10\\dbrain.txt", "a");
; 1509 : 		fprintf(deb, "UnitClass Deaggregate nV=%d Id=%d\n", VEHICLE_GROUPS_PER_UNIT, simdata.callsignIdx );   
; 1510 : 		fclose(deb);
; 1511 : 		*/
; 1512 : 	// Now add all the vehicles
; 1513 : 	for (v=0; v<VEHICLE_GROUPS_PER_UNIT; v++)

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN13@Deaggregat
$LN12@Deaggregat:
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 1
	mov	DWORD PTR _v$[ebp], ecx
$LN13@Deaggregat:
	cmp	DWORD PTR _v$[ebp], 16			; 00000010H
	jge	$LN11@Deaggregat

; 1514 : 	{
; 1515 : 		vehs = GetNumVehicles(v);

	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	mov	DWORD PTR _vehs$[ebp], eax

; 1516 : 		classID = GetVehicleID(v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	mov	WORD PTR _classID$[ebp], ax

; 1517 : 		inslot = 0;

	mov	DWORD PTR _inslot$[ebp], 0
$LN10@Deaggregat:

; 1518 : 		while (vehs && classID)

	cmp	DWORD PTR _vehs$[ebp], 0
	je	$LN9@Deaggregat
	movsx	ecx, WORD PTR _classID$[ebp]
	test	ecx, ecx
	je	$LN9@Deaggregat

; 1519 : 		{
; 1520 : 			vc = GetVehicleClassData(classID);

	movsx	edx, WORD PTR _classID$[ebp]
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 1521 : 
; 1522 : 			// Adjust to the correctly textured object (Dogfight only)
; 1523 : 			if (FalconLocalGame->GetGameType() == game_Dogfight){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN36@Deaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv364[ebp], eax
	jmp	SHORT $LN37@Deaggregat
$LN36@Deaggregat:
	mov	DWORD PTR tv364[ebp], 0
$LN37@Deaggregat:
	mov	ecx, DWORD PTR tv364[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN7@Deaggregat

; 1524 : 				// sfr: added fallback code to DF here
; 1525 : 				// so if we do not find the DF variant, use the common one
; 1526 : 				VehicleID dfClassID = SimDogfight.AdjustClassId(GetVehicleID(v),GetTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	push	eax
	mov	ecx, OFFSET ?SimDogfight@@3VDogfightClass@@A ; SimDogfight
	call	?AdjustClassId@DogfightClass@@QAEHHH@Z	; DogfightClass::AdjustClassId
	mov	WORD PTR _dfClassID$14[ebp], ax

; 1527 : 				if (dfClassID != 0){

	movsx	ecx, WORD PTR _dfClassID$14[ebp]
	test	ecx, ecx
	je	SHORT $LN7@Deaggregat

; 1528 : 					classID = dfClassID;

	mov	dx, WORD PTR _dfClassID$14[ebp]
	mov	WORD PTR _classID$[ebp], dx
$LN7@Deaggregat:

; 1529 : 				}
; 1530 : 			}
; 1531 : 			simdata.campSlot = v;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR _simdata$[ebp+32], eax

; 1532 : 			simdata.inSlot = inslot;

	mov	ecx, DWORD PTR _inslot$[ebp]
	mov	DWORD PTR _simdata$[ebp+36], ecx

; 1533 : 			simdata.status = VIS_NORMAL;

	mov	DWORD PTR _simdata$[ebp+48], 0

; 1534 : 			simdata.descriptionIndex = classID + VU_LAST_ENTITY_TYPE;

	movsx	edx, WORD PTR _classID$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _simdata$[ebp+28], edx

; 1535 : 			simdata.flags = vc->Flags;

	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _simdata$[ebp+76], ecx

; 1536 : 
; 1537 : 			// Set the position initially to the unit's real position
; 1538 : 			simdata.x = x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _simdata$[ebp+56], xmm0

; 1539 : 			simdata.y = y;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _simdata$[ebp+60], xmm0

; 1540 : 			simdata.z = _isnan(z) ? -14000.0f : z;

	cvtss2sd xmm0, DWORD PTR _z$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	__isnan
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@Deaggregat
	movss	xmm0, DWORD PTR __real@c65ac000
	movss	DWORD PTR tv395[ebp], xmm0
	jmp	SHORT $LN39@Deaggregat
$LN38@Deaggregat:
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR tv395[ebp], xmm0
$LN39@Deaggregat:
	movss	xmm0, DWORD PTR tv395[ebp]
	movss	DWORD PTR _simdata$[ebp+64], xmm0

; 1541 : 
; 1542 : 			// Now query for any offsets
; 1543 : 			motiontype = GetVehicleDeagData(&simdata, FALSE);

	push	0
	lea	edx, DWORD PTR _simdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+548]
	call	eax
	mov	DWORD PTR _motiontype$[ebp], eax

; 1544 : 			if (motiontype < 0){

	cmp	DWORD PTR _motiontype$[ebp], 0
	jge	SHORT $LN6@Deaggregat

; 1545 : 				// Technically, if we get here the flight should have been canceled, so just do it.
; 1546 : 				CancelFlight((Flight)this);	

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?CancelFlight@@YAXPAVFlightClass@@@Z	; CancelFlight
	add	esp, 4

; 1547 : 				return 0;

	xor	eax, eax
	jmp	$LN32@Deaggregat
$LN6@Deaggregat:

; 1548 : 			}
; 1549 : 
; 1550 : 			// This actually adds the bugger
; 1551 : 			newObject = AddObjectToSim(&simdata, motiontype);

	mov	edx, DWORD PTR _motiontype$[ebp]
	push	edx
	lea	eax, DWORD PTR _simdata$[ebp]
	push	eax
	call	?AddObjectToSim@@YAPAVSimBaseClass@@PAVSimInitDataClass@@H@Z ; AddObjectToSim
	add	esp, 8
	mov	DWORD PTR _newObject$[ebp], eax

; 1552 : 
; 1553 : 			if (newObject){

	cmp	DWORD PTR _newObject$[ebp], 0
	je	SHORT $LN5@Deaggregat

; 1554 : 				GetComponents()->ForcedInsert(newObject);

	mov	ecx, DWORD PTR _newObject$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	mov	ecx, eax
	call	?ForcedInsert@TailInsertList@@QAEHPAVVuEntity@@@Z ; TailInsertList::ForcedInsert
$LN5@Deaggregat:

; 1555 : 			}
; 1556 : 
; 1557 : 			vehs--;

	mov	edx, DWORD PTR _vehs$[ebp]
	sub	edx, 1
	mov	DWORD PTR _vehs$[ebp], edx

; 1558 : 			inslot++;

	mov	eax, DWORD PTR _inslot$[ebp]
	add	eax, 1
	mov	DWORD PTR _inslot$[ebp], eax

; 1559 : 		}

	jmp	$LN10@Deaggregat
$LN9@Deaggregat:

; 1560 : 	}

	jmp	$LN12@Deaggregat
$LN11@Deaggregat:

; 1561 : 
; 1562 : 	SetAggregate(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAggregate@CampBaseClass@@QAEX_N@Z	; CampBaseClass::SetAggregate

; 1563 : 
; 1564 : 	if (TheCampaign.IsOnline()){

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?IsOnline@CampaignClass@@QAEHXZ		; CampaignClass::IsOnline
	test	eax, eax
	je	SHORT $LN4@Deaggregat

; 1565 : 		SendDeaggregateData(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN40@Deaggregat
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv489[ebp], eax
	jmp	SHORT $LN41@Deaggregat
$LN40@Deaggregat:
	mov	DWORD PTR tv489[ebp], 0
$LN41@Deaggregat:
	mov	edx, DWORD PTR tv489[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+324]
	call	eax
$LN4@Deaggregat:

; 1566 : 	}
; 1567 : 
; 1568 : 	// Update our wake status
; 1569 : #if NEW_WAKE
; 1570 : 	if (this->OwnerId() == vuLocalSessionEntity->Id()){

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Deaggregat

; 1571 : 		Wake();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 1572 : 	}
; 1573 : 	else {

	jmp	SHORT $LN2@Deaggregat
$LN3@Deaggregat:

; 1574 : 		Sleep();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN2@Deaggregat:

; 1575 : 	}
; 1576 : #else
; 1577 : 	if ((session == FalconLocalSession) || FalconLocalSession->InSessionBubble(this,1.0F)>0){
; 1578 : 		Wake();
; 1579 : 	}
; 1580 : 	else{
; 1581 : 		SetAwake(0);
; 1582 : 	}
; 1583 : #endif
; 1584 : 
; 1585 : 	// Special case stuff for battalions
; 1586 : 	if (IsBattalion()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN1@Deaggregat

; 1587 : 		ClearDeaggregationData();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	call	eax
$LN1@Deaggregat:

; 1588 : 	}
; 1589 : 
; 1590 : #if USE_VU_COLL_FOR_CAMPAIGN
; 1591 : 	deaggregatedEntities->ForcedInsert(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?deaggregatedEntities@@3PAVVuHashTable@@A ; deaggregatedEntities
	call	?ForcedInsert@VuCollection@@QAEHPAVVuEntity@@@Z ; VuCollection::ForcedInsert

; 1592 : #else
; 1593 : 	deaggregatedMap->insert(CampBaseBin(this));
; 1594 : #endif
; 1595 : 	return 1;

	mov	eax, 1
$LN32@Deaggregat:

; 1596 : }	

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-316]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Deaggregate@UnitClass@@UAEHPAVFalconSessionEntity@@@Z ENDP ; UnitClass::Deaggregate
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -168						; size = 8
$T3 = -160						; size = 8
_myit$4 = -152						; size = 12
_vid$5 = -140						; size = 4
$T6 = -136						; size = 4
$T7 = -132						; size = 4
$T8 = -128						; size = 4
$T9 = -124						; size = 4
tv356 = -120						; size = 4
_newLoad$10 = -116					; size = 4
tv78 = -112						; size = 4
tv481 = -108						; size = 4
tv310 = -104						; size = 4
$T11 = -100						; size = 4
_fuelUsed$ = -96					; size = 4
_vehicle_class_data$ = -92				; size = 4
_num$12 = -88						; size = 4
_maxFuelUsed$ = -84					; size = 4
_have$ = -80						; size = 4
_hasECM$ = -76						; size = 4
$T13 = -72						; size = 4
_loadData$ = -68					; size = 16
_total$ = -52						; size = 4
_vehleft$ = -48						; size = 4
_lastPilot$ = -44					; size = 4
_SMS$14 = -40						; size = 4
_pilotSlot$ = -36					; size = 4
_fl$ = -32						; size = 4
_v$ = -28						; size = 4
_vehicle$15 = -24					; size = 4
_this$ = -20						; size = 4
_hp$16 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_session$ = 8						; size = 4
_byReag$ = 12						; size = 4
?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z PROC ; UnitClass::RecordCurrentState
; _this$ = ecx

; 1140 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1141 : 	VehicleClassDataType *vehicle_class_data;
; 1142 : 
; 1143 : 	int				v,have=0,total=0,vehleft=0,lastPilot=-1,pilotSlot=0;

	mov	DWORD PTR _have$[ebp], 0
	mov	DWORD PTR _total$[ebp], 0
	mov	DWORD PTR _vehleft$[ebp], 0
	mov	DWORD PTR _lastPilot$[ebp], -1
	mov	DWORD PTR _pilotSlot$[ebp], 0

; 1144 : 	long			fuelUsed,maxFuelUsed=-64000;

	mov	DWORD PTR _maxFuelUsed$[ebp], -64000	; ffff0600H

; 1145 : 	Flight			fl = NULL;

	mov	DWORD PTR _fl$[ebp], 0

; 1146 : 	LoadoutStruct	*loadData[PILOTS_PER_FLIGHT] = { 0 };

	mov	DWORD PTR _loadData$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _loadData$[ebp+4], eax
	mov	DWORD PTR _loadData$[ebp+8], eax
	mov	DWORD PTR _loadData$[ebp+12], eax

; 1147 : 
; 1148 : 	int 		hasECM;
; 1149 : 
; 1150 : 	vehicle_class_data = GetVehicleClassData(class_data->VehicleType[0]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, 2
	imul	eax, 0
	movsx	ecx, WORD PTR [edx+eax+68]
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vehicle_class_data$[ebp], eax

; 1151 : 
; 1152 : 	if (vehicle_class_data)

	cmp	DWORD PTR _vehicle_class_data$[ebp], 0
	je	SHORT $LN50@RecordCurr

; 1153 : 	{
; 1154 : 		hasECM = vehicle_class_data->Flags & VEH_HAS_JAMMER ? TRUE : FALSE;

	mov	edx, DWORD PTR _vehicle_class_data$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 65536				; 00010000H
	je	SHORT $LN53@RecordCurr
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN54@RecordCurr
$LN53@RecordCurr:
	mov	DWORD PTR tv78[ebp], 0
$LN54@RecordCurr:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _hasECM$[ebp], ecx

; 1155 : 	}
; 1156 : 	else

	jmp	SHORT $LN49@RecordCurr
$LN50@RecordCurr:

; 1157 : 	{
; 1158 : 		hasECM = FALSE;

	mov	DWORD PTR _hasECM$[ebp], 0
$LN49@RecordCurr:

; 1159 : 	}
; 1160 : 
; 1161 : 	SetRoster(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoster@UnitClass@@QAEXJ@Z		; UnitClass::SetRoster

; 1162 : 
; 1163 : 	// Check if it's died in the meantime
; 1164 : 	if (IsDead())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+552]
	call	edx
	test	eax, eax
	je	SHORT $LN48@RecordCurr

; 1165 : 		return 0;

	xor	eax, eax
	jmp	$LN51@RecordCurr
$LN48@RecordCurr:

; 1166 : 
; 1167 : 	// Assume unaccounted for pilots are MIA, if this is a flight
; 1168 : 	if (IsFlight())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN44@RecordCurr

; 1169 : 	{
; 1170 : 		fl = (Flight)this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _fl$[ebp], ecx

; 1171 : 		for (v=0; v<PILOTS_PER_FLIGHT; v++)

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN46@RecordCurr
$LN45@RecordCurr:
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 1
	mov	DWORD PTR _v$[ebp], edx
$LN46@RecordCurr:
	cmp	DWORD PTR _v$[ebp], 4
	jge	SHORT $LN44@RecordCurr

; 1172 : 		{
; 1173 : 			if (fl->plane_stats[v] == AIRCRAFT_AVAILABLE)

	mov	eax, DWORD PTR _fl$[ebp]
	add	eax, DWORD PTR _v$[ebp]
	movzx	ecx, BYTE PTR [eax+416]
	cmp	ecx, 4
	jne	SHORT $LN43@RecordCurr

; 1174 : 			{
; 1175 : 				fl->plane_stats[v] = AIRCRAFT_DEAD;

	mov	edx, DWORD PTR _fl$[ebp]
	add	edx, DWORD PTR _v$[ebp]
	mov	BYTE PTR [edx+416], 2

; 1176 : 				//fl->MakeFlightDirty (DIRTY_PLANE_STATS, DDP[34].priority);
; 1177 : 				fl->MakeFlightDirty (DIRTY_PLANE_STATS, SEND_RELIABLE);

	push	1048576					; 00100000H
	push	8
	mov	ecx, DWORD PTR _fl$[ebp]
	call	?MakeFlightDirty@FlightClass@@QAEXW4Dirty_Flight@@W4Dirtyness@@@Z ; FlightClass::MakeFlightDirty
$LN43@RecordCurr:

; 1178 : 			}
; 1179 : 		}

	jmp	SHORT $LN45@RecordCurr
$LN44@RecordCurr:

; 1180 : 	}
; 1181 : 
; 1182 : 	// Record current state of components
; 1183 : 	if (GetComponents())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	$LN42@RecordCurr

; 1184 : 	{
; 1185 : 		SimVehicleClass		*vehicle;
; 1186 : 		int					num,hp,vid;
; 1187 : 		SMSBaseClass		*SMS;
; 1188 : 
; 1189 : 		// Now plop the vehicles back in
; 1190 : 		VuListIterator		myit(GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _myit$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1191 : 		vehicle = (SimVehicleClass*) myit.GetFirst();

	lea	ecx, DWORD PTR _myit$4[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _vehicle$15[ebp], eax
$LN64@RecordCurr:

; 1192 : 		while (vehicle)

	cmp	DWORD PTR _vehicle$15[ebp], 0
	je	$LN40@RecordCurr

; 1193 : 		{
; 1194 : 			if(F4IsBadReadPtr(vehicle,sizeof(SimVehicleClass)))

	push	744					; 000002e8H
	mov	eax, DWORD PTR _vehicle$15[ebp]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN39@RecordCurr

; 1195 : 			{
; 1196 : 				vehicle = (SimVehicleClass*) myit.GetNext();

	lea	ecx, DWORD PTR _myit$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _vehicle$15[ebp], eax

; 1197 : 				continue;

	jmp	SHORT $LN64@RecordCurr
$LN39@RecordCurr:

; 1198 : 			}
; 1199 : 			if (session)

	cmp	DWORD PTR _session$[ebp], 0
	je	SHORT $LN36@RecordCurr

; 1200 : 			{
; 1201 : 				// FRB - CTD's here
; 1202 : 				if(!F4IsBadReadPtr(session,sizeof(FalconSessionEntity)))

	push	660					; 00000294H
	mov	edx, DWORD PTR _session$[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@RecordCurr

; 1203 : 				{
; 1204 : 					if (!vehicle->IsSetFalcFlag(FEC_HASPLAYERS))

	push	4
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	SHORT $LN36@RecordCurr

; 1205 : 					{
; 1206 : 						// if it has players - then they are responsible for changing owner - not the campaign entity.
; 1207 : 						vehicle->ChangeOwner(session->Id());

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _session$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	eax, DWORD PTR [edx+328]
	call	eax
$LN36@RecordCurr:

; 1208 : 					}
; 1209 : 				}
; 1210 : 			}
; 1211 : 
; 1212 : 			v = vehicle->GetSlot();

	mov	ecx, DWORD PTR _vehicle$15[ebp]
	call	?GetSlot@SimBaseClass@@QAEHXZ		; SimBaseClass::GetSlot
	mov	DWORD PTR _v$[ebp], eax

; 1213 : 			vid = GetVehicleID(v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	edx, ax
	mov	DWORD PTR _vid$5[ebp], edx

; 1214 : 			ShiAssert(GetNumVehicles(v)<3);
; 1215 : 			// KCK: When we're reaggregating a unit, there are some cases where we want to
; 1216 : 			// make sure a half dead or pilotless vehicle is recorded as being dead.
; 1217 : 			//
; 1218 : 			// Check if this vehicle is dead according to the sim, and simply ignore it, if so.
; 1219 : 			// (This will cause it not be added back into the campaign data)
; 1220 : 			if (byReag && vehicle->IsDead() && !vehicle->IsSetFalcFlag(FEC_REGENERATING))

	cmp	DWORD PTR _byReag$[ebp], 0
	je	SHORT $LN35@RecordCurr
	mov	eax, DWORD PTR _vehicle$15[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	je	SHORT $LN35@RecordCurr
	push	8
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	SHORT $LN35@RecordCurr
	jmp	$LN11@RecordCurr
$LN35@RecordCurr:

; 1221 : 			{
; 1222 : 				// Do nothing
; 1223 : 			}
; 1224 : 			// Check if this vehicle is essentially out of action for the Campaign's purpose (even if it is
; 1225 : 			// technically alive in the sim). Theoretically, we could register this fact with the mission evaluator.
; 1226 : 			// (This will also cause it not be added back into the campaign data)
; 1227 : 			else if (byReag && (!vehicle->HasPilot() || vehicle->pctStrength < MIN_DEAD_PCT) && !vehicle->IsSetFalcFlag(FEC_REGENERATING))

	cmp	DWORD PTR _byReag$[ebp], 0
	je	SHORT $LN33@RecordCurr
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	eax, DWORD PTR [edx+472]
	call	eax
	test	eax, eax
	je	SHORT $LN32@RecordCurr
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	movss	xmm0, DWORD PTR ?MIN_DEAD_PCT@@3MA
	comiss	xmm0, DWORD PTR [ecx+292]
	jbe	SHORT $LN33@RecordCurr
$LN32@RecordCurr:
	push	8
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	SHORT $LN33@RecordCurr

; 1228 : 			{
; 1229 : 				// I once tried simulating a death message here, but it was painfull and error prone.
; 1230 : 				// What will happen without this, is if a unit reaggregates while something is 'mostly
; 1231 : 				// dead' it will be removed from the unit, but the fact it died (or the kill credit)
; 1232 : 				// will not be recorded in the mission evaluator. 
; 1233 : 				// Maybe this is ok, or some day I could work out how to fake this death message.
; 1234 : 				/*				FalconDeathMessage	*dtm = new FalconDeathMessage (Id(), FalconLocalGame);
; 1235 : 								dtm->dataBlock.dEntityID		= dtm->dataBlock.fEntityID		= vehicle->Id();
; 1236 : 								dtm->dataBlock.dCampID			= dtm->dataBlock.fCampID		= GetCampID();
; 1237 : 								dtm->dataBlock.dSide			= dtm->dataBlock.fSide			= GetOwner();
; 1238 : 								dtm->dataBlock.dPilotID			= dtm->dataBlock.fPilotID		= vehicle->pilotSlot;
; 1239 : 								dtm->dataBlock.dIndex			= dtm->dataBlock.fIndex			= vehicle->Type();
; 1240 : 								dtm->dataBlock.fWeaponID		= ????;
; 1241 : 								dtm->dataBlock.fWeaponUID		= FalconNullId;
; 1242 : 								dtm->dataBlock.damageType		= FalconDamageType::OtherDamage;
; 1243 : 								dtm->dataBlock.deathPctStrength	= 0;
; 1244 : 
; 1245 : 								FalconEntity *lastToHit = (FalconEntity*)vuDatabase->Find( vehicle->LastShooter() );
; 1246 : 								if (lastToHit && !lastToHit->IsEject() )
; 1247 : 								{
; 1248 : 								if (lastToHit->IsSim())
; 1249 : 								{
; 1250 : 								dtm->dataBlock.fPilotID	= ((SimVehicleClass*)lastToHit)->pilotSlot;
; 1251 : 								dtm->dataBlock.fCampID	= ((SimVehicleClass*)lastToHit)->GetCampaignObject()->GetCampID();
; 1252 : 								dtm->dataBlock.fSide	= ((SimVehicleClass*)lastToHit)->GetCampaignObject()->GetOwner();
; 1253 : 								}
; 1254 : 								else
; 1255 : 								{
; 1256 : 								dtm->dataBlock.fPilotID	= 0;
; 1257 : 								dtm->dataBlock.fCampID	= ((CampBaseClass*)lastToHit)->GetCampID();
; 1258 : 								dtm->dataBlock.fSide	= ((CampBaseClass*)lastToHit)->GetOwner();
; 1259 : 								}
; 1260 : 								dtm->dataBlock.fEntityID	= lastToHit->Id();
; 1261 : 								dtm->dataBlock.fIndex		= lastToHit->Type();
; 1262 : 								}
; 1263 : 								FalconSendMessage (dtm, TRUE);
; 1264 : 				 */
; 1265 : 			}
; 1266 : 			else

	jmp	$LN11@RecordCurr
$LN33@RecordCurr:

; 1267 : 			{
; 1268 : 				// Put the thing back into the campaign unit
; 1269 : 				SetNumVehicles(v, GetNumVehicles(v)+1);

	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	add	eax, 1
	push	eax
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumVehicles@UnitClass@@QAEXHH@Z	; UnitClass::SetNumVehicles

; 1270 : 				vehleft++;

	mov	ecx, DWORD PTR _vehleft$[ebp]
	add	ecx, 1
	mov	DWORD PTR _vehleft$[ebp], ecx

; 1271 : 				pilotSlot = 0;

	mov	DWORD PTR _pilotSlot$[ebp], 0

; 1272 : 				if (fl && vehicle->vehicleInUnit < PILOTS_PER_FLIGHT)

	cmp	DWORD PTR _fl$[ebp], 0
	je	SHORT $LN29@RecordCurr
	mov	edx, DWORD PTR _vehicle$15[ebp]
	movzx	eax, BYTE PTR [edx+664]
	cmp	eax, 4
	jge	SHORT $LN29@RecordCurr

; 1273 : 				{
; 1274 : 					pilotSlot = fl->GetAdjustedPlayerSlot(vehicle->pilotSlot);

	mov	ecx, DWORD PTR _vehicle$15[ebp]
	movzx	edx, BYTE PTR [ecx+665]
	push	edx
	mov	ecx, DWORD PTR _fl$[ebp]
	call	?GetAdjustedPlayerSlot@FlightClass@@QAEHH@Z ; FlightClass::GetAdjustedPlayerSlot
	mov	DWORD PTR _pilotSlot$[ebp], eax

; 1275 : 					//ShiAssert (pilotSlot == vehicle->vehicleInUnit);
; 1276 : 					fl->plane_stats[pilotSlot] = AIRCRAFT_AVAILABLE;

	mov	eax, DWORD PTR _fl$[ebp]
	add	eax, DWORD PTR _pilotSlot$[ebp]
	mov	BYTE PTR [eax+416], 4

; 1277 : 					//fl->MakeFlightDirty (DIRTY_PLANE_STATS, DDP[35].priority);
; 1278 : 					fl->MakeFlightDirty (DIRTY_PLANE_STATS, SEND_RELIABLE);

	push	1048576					; 00100000H
	push	8
	mov	ecx, DWORD PTR _fl$[ebp]
	call	?MakeFlightDirty@FlightClass@@QAEXW4Dirty_Flight@@W4Dirtyness@@@Z ; FlightClass::MakeFlightDirty

; 1279 : 					if (pilotSlot > lastPilot){

	mov	ecx, DWORD PTR _pilotSlot$[ebp]
	cmp	ecx, DWORD PTR _lastPilot$[ebp]
	jle	SHORT $LN29@RecordCurr

; 1280 : 						lastPilot = pilotSlot;

	mov	edx, DWORD PTR _pilotSlot$[ebp]
	mov	DWORD PTR _lastPilot$[ebp], edx
$LN29@RecordCurr:

; 1281 : 					}
; 1282 : 				}
; 1283 : 				// Reaggregate our weapons
; 1284 : 				SMS = vehicle->GetSMS();

	mov	eax, DWORD PTR _vehicle$15[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	eax, DWORD PTR [edx+464]
	call	eax
	mov	DWORD PTR _SMS$14[ebp], eax

; 1285 : 				if (SMS)

	cmp	DWORD PTR _SMS$14[ebp], 0
	je	$LN11@RecordCurr

; 1286 : 				{
; 1287 : 					if (fl)

	cmp	DWORD PTR _fl$[ebp], 0
	je	$LN27@RecordCurr

; 1288 : 					{
; 1289 : 						// Flights will get an all new loadout structure
; 1290 : 						if (!loadData[pilotSlot])

	mov	ecx, DWORD PTR _pilotSlot$[ebp]
	cmp	DWORD PTR _loadData$[ebp+ecx*4], 0
	jne	SHORT $LN26@RecordCurr

; 1291 : 							loadData[pilotSlot] = new LoadoutStruct;

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN55@RecordCurr
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct
	mov	DWORD PTR tv310[ebp], eax
	jmp	SHORT $LN56@RecordCurr
$LN55@RecordCurr:
	mov	DWORD PTR tv310[ebp], 0
$LN56@RecordCurr:
	mov	edx, DWORD PTR tv310[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _pilotSlot$[ebp]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _loadData$[ebp+eax*4], ecx
$LN26@RecordCurr:

; 1292 : 						for (hp=0; hp<HARDPOINT_MAX; hp++)

	mov	DWORD PTR _hp$16[ebp], 0
	jmp	SHORT $LN25@RecordCurr
$LN24@RecordCurr:
	mov	edx, DWORD PTR _hp$16[ebp]
	add	edx, 1
	mov	DWORD PTR _hp$16[ebp], edx
$LN25@RecordCurr:
	cmp	DWORD PTR _hp$16[ebp], 16		; 00000010H
	jge	$LN23@RecordCurr

; 1293 : 						{
; 1294 : 							if (hp < SMS->NumHardpoints())

	mov	ecx, DWORD PTR _SMS$14[ebp]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _hp$16[ebp], eax
	jge	$LN22@RecordCurr

; 1295 : 							{
; 1296 : 								// This is as a result of Leon's Rocket hack
; 1297 : 								if (SMS->hardPoint[hp]->weaponId == gRocketId)

	mov	eax, DWORD PTR _SMS$14[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	movsx	edx, WORD PTR ?gRocketId@@3FA		; gRocketId
	cmp	ecx, edx
	jne	SHORT $LN21@RecordCurr

; 1298 : 								{
; 1299 : 									loadData[pilotSlot]->WeaponID[hp] = (short) SMS->hardPoint[hp]->GetRackId();

	mov	eax, DWORD PTR _SMS$14[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _SMS$14[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _hp$16[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+132]
	call	edx
	mov	ecx, DWORD PTR _pilotSlot$[ebp]
	mov	edx, DWORD PTR _loadData$[ebp+ecx*4]
	mov	ecx, DWORD PTR _hp$16[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 1300 : 									loadData[pilotSlot]->WeaponCount[hp] = min(1,SMS->hardPoint[hp]->weaponCount);

	mov	edx, DWORD PTR _SMS$14[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hp$16[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [edx+10]
	cmp	eax, 1
	jle	SHORT $LN57@RecordCurr
	mov	DWORD PTR tv356[ebp], 1
	jmp	SHORT $LN58@RecordCurr
$LN57@RecordCurr:
	mov	ecx, DWORD PTR _SMS$14[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$16[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	mov	DWORD PTR tv356[ebp], edx
$LN58@RecordCurr:
	mov	eax, DWORD PTR _pilotSlot$[ebp]
	mov	ecx, DWORD PTR _loadData$[ebp+eax*4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	al, BYTE PTR tv356[ebp]
	mov	BYTE PTR [ecx+edx+32], al

; 1301 : 								}
; 1302 : 								else

	jmp	SHORT $LN18@RecordCurr
$LN21@RecordCurr:

; 1303 : 								{
; 1304 : 									loadData[pilotSlot]->WeaponID[hp] = (short) SMS->hardPoint[hp]->weaponId;

	mov	ecx, DWORD PTR _SMS$14[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$16[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _pilotSlot$[ebp]
	mov	eax, DWORD PTR _loadData$[ebp+edx*4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	cx, WORD PTR [ecx+8]
	mov	WORD PTR [eax+edx*2], cx

; 1305 : 									if (WeaponDataTable[loadData[pilotSlot]->WeaponID[hp]].Flags & WEAP_ONETENTH)

	mov	edx, DWORD PTR _pilotSlot$[ebp]
	mov	eax, DWORD PTR _loadData$[ebp+edx*4]
	mov	ecx, DWORD PTR _hp$16[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN19@RecordCurr

; 1306 : 										//Cobra 12/08/04 This is called when returning from sim
; 1307 : 										//Causes gun rounds to be removed!!! Removed "/10"
; 1308 : 										loadData[pilotSlot]->WeaponCount[hp] = (uchar) (SMS->hardPoint[hp]->weaponCount/*/10*/);

	mov	edx, DWORD PTR _SMS$14[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hp$16[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _pilotSlot$[ebp]
	mov	ecx, DWORD PTR _loadData$[ebp+eax*4]
	mov	eax, DWORD PTR _hp$16[ebp]
	mov	dl, BYTE PTR [edx+10]
	mov	BYTE PTR [ecx+eax+32], dl

; 1309 : 									else

	jmp	SHORT $LN18@RecordCurr
$LN19@RecordCurr:

; 1310 : 										loadData[pilotSlot]->WeaponCount[hp] = (uchar) SMS->hardPoint[hp]->weaponCount;

	mov	eax, DWORD PTR _SMS$14[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _pilotSlot$[ebp]
	mov	edx, DWORD PTR _loadData$[ebp+ecx*4]
	mov	ecx, DWORD PTR _hp$16[ebp]
	mov	al, BYTE PTR [eax+10]
	mov	BYTE PTR [edx+ecx+32], al
$LN18@RecordCurr:

; 1311 : 								}
; 1312 : 
; 1313 : 								// check for ECM pod
; 1314 : 								if (WeaponDataTable[SMS->hardPoint[hp]->weaponId].Flags & WEAP_ECM)

	mov	ecx, DWORD PTR _SMS$14[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$16[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+8]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 4
	je	SHORT $LN17@RecordCurr

; 1315 : 								{
; 1316 : 									hasECM = TRUE;

	mov	DWORD PTR _hasECM$[ebp], 1
$LN17@RecordCurr:

; 1317 : 								}
; 1318 : 							}
; 1319 : 							else

	jmp	SHORT $LN16@RecordCurr
$LN22@RecordCurr:

; 1320 : 							{
; 1321 : 								loadData[pilotSlot]->WeaponID[hp] = 0;

	mov	edx, DWORD PTR _pilotSlot$[ebp]
	mov	eax, DWORD PTR _loadData$[ebp+edx*4]
	xor	ecx, ecx
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 1322 : 								loadData[pilotSlot]->WeaponCount[hp] = 0;

	mov	eax, DWORD PTR _pilotSlot$[ebp]
	mov	ecx, DWORD PTR _loadData$[ebp+eax*4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	BYTE PTR [ecx+edx+32], 0
$LN16@RecordCurr:

; 1323 : 							}
; 1324 : 							ShiAssert (loadData[pilotSlot]->WeaponID[hp] < NumWeaponTypes);
; 1325 : 						}

	jmp	$LN24@RecordCurr
$LN23@RecordCurr:

; 1326 : 						// Calculate fuel used
; 1327 : 						fuelUsed = fl->CalculateFuelAvailable(pilotSlot) - vehicle->GetTotalFuel();

	mov	eax, DWORD PTR _pilotSlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fl$[ebp]
	call	?CalculateFuelAvailable@FlightClass@@QAEJH@Z ; FlightClass::CalculateFuelAvailable
	mov	esi, eax
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _vehicle$15[ebp]
	mov	eax, DWORD PTR [edx+468]
	call	eax
	sub	esi, eax
	mov	DWORD PTR _fuelUsed$[ebp], esi

; 1328 : 						if (fuelUsed > maxFuelUsed)

	mov	ecx, DWORD PTR _fuelUsed$[ebp]
	cmp	ecx, DWORD PTR _maxFuelUsed$[ebp]
	jle	SHORT $LN15@RecordCurr

; 1329 : 							maxFuelUsed = fuelUsed;

	mov	edx, DWORD PTR _fuelUsed$[ebp]
	mov	DWORD PTR _maxFuelUsed$[ebp], edx
$LN15@RecordCurr:

; 1330 : 					}
; 1331 : 					else

	jmp	$LN11@RecordCurr
$LN27@RecordCurr:

; 1332 : 					{
; 1333 : 						// Average the weapons for all non-ac vehicles
; 1334 : 						for (hp=0; hp<SMS->NumHardpoints(); hp++)

	mov	DWORD PTR _hp$16[ebp], 0
	jmp	SHORT $LN13@RecordCurr
$LN12@RecordCurr:
	mov	eax, DWORD PTR _hp$16[ebp]
	add	eax, 1
	mov	DWORD PTR _hp$16[ebp], eax
$LN13@RecordCurr:
	mov	ecx, DWORD PTR _SMS$14[ebp]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _hp$16[ebp], eax
	jge	SHORT $LN11@RecordCurr

; 1335 : 						{
; 1336 : 							num = SMS->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _SMS$14[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$16[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	mov	DWORD PTR _num$12[ebp], edx

; 1337 : 							if (WeaponDataTable[SMS->hardPoint[hp]->weaponId].Flags & WEAP_ONETENTH)

	mov	eax, DWORD PTR _SMS$14[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$16[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	movsx	ecx, WORD PTR [eax+8]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+10]
	and	eax, 32768				; 00008000H
	je	SHORT $LN10@RecordCurr

; 1338 : 								num /= 10;

	mov	eax, DWORD PTR _num$12[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _num$12[ebp], eax
$LN10@RecordCurr:

; 1339 : 							have += num;

	mov	edx, DWORD PTR _have$[ebp]
	add	edx, DWORD PTR _num$12[ebp]
	mov	DWORD PTR _have$[ebp], edx

; 1340 : 							total += ((VehicleClassDataType*)Falcon4ClassTable[vid].dataPtr)->Weapons[hp];

	mov	eax, DWORD PTR _vid$5[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	mov	eax, DWORD PTR _hp$16[ebp]
	movzx	ecx, BYTE PTR [edx+eax+130]
	add	ecx, DWORD PTR _total$[ebp]
	mov	DWORD PTR _total$[ebp], ecx

; 1341 : 						}

	jmp	$LN12@RecordCurr
$LN11@RecordCurr:

; 1342 : 					}
; 1343 : 				}
; 1344 : 			}
; 1345 : 			vehicle = (SimVehicleClass*) myit.GetNext();

	lea	ecx, DWORD PTR _myit$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _vehicle$15[ebp], eax

; 1346 : 		}

	jmp	$LN64@RecordCurr
$LN40@RecordCurr:

; 1347 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN42@RecordCurr:

; 1348 : 
; 1349 : 	if (!vehleft)

	cmp	DWORD PTR _vehleft$[ebp], 0
	jne	SHORT $LN9@RecordCurr

; 1350 : 	{
; 1351 : 		KillUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit

; 1352 : 		return vehleft;

	mov	eax, DWORD PTR _vehleft$[ebp]
	jmp	$LN51@RecordCurr
$LN9@RecordCurr:

; 1353 : 	}
; 1354 : 
; 1355 : 	// Do special stuff by unit domain
; 1356 : 	if (fl)

	cmp	DWORD PTR _fl$[ebp], 0
	je	$LN8@RecordCurr

; 1357 : 	{
; 1358 : 		// Copy in new loadout data
; 1359 : 		LoadoutStruct	*newLoad;
; 1360 : 		ShiAssert (lastPilot > -1);
; 1361 : 		newLoad = new LoadoutStruct[lastPilot+1];

	mov	edx, DWORD PTR _lastPilot$[ebp]
	add	edx, 1
	mov	DWORD PTR $T11[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T11[ebp]
	mov	edx, 48					; 00000030H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN59@RecordCurr
	push	OFFSET ??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR $T13[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR tv481[ebp], edx
	jmp	SHORT $LN60@RecordCurr
$LN59@RecordCurr:
	mov	DWORD PTR tv481[ebp], 0
$LN60@RecordCurr:
	mov	eax, DWORD PTR tv481[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _newLoad$10[ebp], ecx

; 1362 : 		//newLoad = (LoadoutStruct *)MemAllocPtr(LoadoutStruct::pool, sizeof(LoadoutStruct)*(lastPilot+1), FALSE );
; 1363 : 		for (v=0; v<lastPilot+1; v++)

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN7@RecordCurr
$LN6@RecordCurr:
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 1
	mov	DWORD PTR _v$[ebp], edx
$LN7@RecordCurr:
	mov	eax, DWORD PTR _lastPilot$[ebp]
	add	eax, 1
	cmp	DWORD PTR _v$[ebp], eax
	jge	SHORT $LN5@RecordCurr

; 1364 : 		{
; 1365 : 			if (loadData[v])

	mov	ecx, DWORD PTR _v$[ebp]
	cmp	DWORD PTR _loadData$[ebp+ecx*4], 0
	je	SHORT $LN4@RecordCurr

; 1366 : 			{
; 1367 : 				memcpy(&newLoad[v],loadData[v],sizeof(LoadoutStruct));

	push	48					; 00000030H
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _loadData$[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, DWORD PTR _newLoad$10[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1368 : 				delete loadData[v];

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _loadData$[ebp+edx*4]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1369 : 				loadData[v] = NULL;

	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR _loadData$[ebp+edx*4], 0
$LN4@RecordCurr:

; 1370 : 			}
; 1371 : 			ShiAssert (newLoad[v].WeaponID[0] < NumWeaponTypes);
; 1372 : 		}

	jmp	SHORT $LN6@RecordCurr
$LN5@RecordCurr:

; 1373 : 		fl->SetLoadout(newLoad,lastPilot+1);

	mov	eax, DWORD PTR _lastPilot$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _newLoad$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _fl$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR [eax+636]
	call	edx

; 1374 : 		fl->UseFuel(maxFuelUsed);

	mov	eax, DWORD PTR _maxFuelUsed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _fl$[ebp]
	mov	eax, DWORD PTR [edx+740]
	call	eax

; 1375 : 		UpdateSquadronStatus(fl, FALSE, FALSE);

	push	0
	push	0
	mov	ecx, DWORD PTR _fl$[ebp]
	push	ecx
	call	?UpdateSquadronStatus@@YAXPAVFlightClass@@HH@Z ; UpdateSquadronStatus
	add	esp, 12					; 0000000cH

; 1376 : 
; 1377 : 		// Set ECM flag
; 1378 : 		SetHasECM(hasECM);

	mov	edx, DWORD PTR _hasECM$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHasECM@UnitClass@@QAEXH@Z		; UnitClass::SetHasECM

; 1379 : 	}
; 1380 : 	else

	jmp	SHORT $LN2@RecordCurr
$LN8@RecordCurr:

; 1381 : 	{
; 1382 : 		// Calclulate new supply level
; 1383 : 		if (total)

	cmp	DWORD PTR _total$[ebp], 0
	je	SHORT $LN2@RecordCurr

; 1384 : 			SetUnitSupply(100 * have / total);

	mov	eax, DWORD PTR _have$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _total$[ebp]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+748]
	call	eax
$LN2@RecordCurr:

; 1385 : 	}
; 1386 : 
; 1387 : 	// Check for carrier death
; 1388 : 	if (IsTaskForce() && GetSType() == STYPE_UNIT_CARRIER && !GetNumVehicles(0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN1@RecordCurr
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 3
	jne	SHORT $LN1@RecordCurr
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	test	eax, eax
	jne	SHORT $LN1@RecordCurr

; 1389 : 	{
; 1390 : 		// Probably be cool to send a special news event here...
; 1391 : 		TeamInfo[GetTeam()]->atm->SendATMMessage(Id(), GetTeam(), FalconAirTaskingMessage::atmZapAirbase, 0, 0, NULL, 0);

	push	0
	push	0
	push	0
	push	0
	push	6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR [edx+876]
	call	?SendATMMessage@AirTaskingManagerClass@@QAEXVVU_ID@@EFFFPAXH@Z ; AirTaskingManagerClass::SendATMMessage
$LN1@RecordCurr:

; 1392 : 	}
; 1393 : 
; 1394 : 	return vehleft;

	mov	eax, DWORD PTR _vehleft$[ebp]
$LN51@RecordCurr:

; 1395 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z$0:
	lea	ecx, DWORD PTR _myit$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z$1:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z$2:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RecordCurrentState@UnitClass@@UAEHPAVFalconSessionEntity@@H@Z ENDP ; UnitClass::RecordCurrentState
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_vuid$ = -168						; size = 8
$T2 = -160						; size = 8
$T3 = -152						; size = 8
$T4 = -144						; size = 8
$T5 = -136						; size = 8
$T6 = -128						; size = 8
_tc$ = -120						; size = 4
_myit$7 = -116						; size = 12
_fuel$ = -104						; size = 4
_onesize$ = -100					; size = 4
$T8 = -96						; size = 4
_z$ = -92						; size = 4
$T9 = -88						; size = 4
tv163 = -84						; size = 4
$T10 = -80						; size = 4
_tr$ = -76						; size = 4
_addr$ = -72						; size = 4
_i$ = -68						; size = 4
_num$ = -64						; size = 4
_pos$ = -60						; size = 4
_msg$ = -56						; size = 4
_wv$ = -52						; size = 2
_wps$ = -48						; size = 2
_slot$11 = -41						; size = 1
_value$ = -40						; size = 2
_w$ = -36						; size = 4
_v$ = -32						; size = 4
_totalsize$ = -28					; size = 4
_vehicle$ = -24						; size = 4
_this$ = -20						; size = 4
_ddptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 4
?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z PROC ; UnitClass::SendDeaggregateData
; _this$ = ecx

; 1008 : void UnitClass::SendDeaggregateData(VuTargetEntity *target){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1009 : 	if (IsAggregate()){	return; }

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN23@SendDeaggr
	jmp	$LN24@SendDeaggr
$LN23@SendDeaggr:

; 1010 : 
; 1011 : 	uchar					*ddptr;
; 1012 : 	short wv;
; 1013 : 	ushort					value,wps;
; 1014 : 	FalconSimCampMessage	*msg;
; 1015 : 	SimVehicleClass			*vehicle = NULL;

	mov	DWORD PTR _vehicle$[ebp], 0

; 1016 : 	VU_ID_NUMBER			num;
; 1017 : 	VU_SESSION_ID			addr;

	lea	ecx, DWORD PTR _addr$[ebp]
	call	??0VU_SESSION_ID@@QAE@XZ		; VU_SESSION_ID::VU_SESSION_ID

; 1018 : 	int						totalsize,onesize,i,tc=0,tr=0,v/*,classID*/;

	mov	DWORD PTR _tc$[ebp], 0
	mov	DWORD PTR _tr$[ebp], 0

; 1019 : 	WayPoint				w;
; 1020 : 	VU_ID					vuid;

	lea	ecx, DWORD PTR _vuid$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 1021 : 	long					fuel;
; 1022 : 	float					pos,z;
; 1023 : 	//VehicleClassDataType	*vc;
; 1024 : 
; 1025 : 	// Calculate unit data size
; 1026 : 	wps = 0;

	xor	eax, eax
	mov	WORD PTR _wps$[ebp], ax

; 1027 : 	totalsize = 0;

	mov	DWORD PTR _totalsize$[ebp], 0

; 1028 : 
; 1029 : 	w = GetFirstUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax
$LN22@SendDeaggr:

; 1030 : 	while (w){

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN21@SendDeaggr

; 1031 : 		totalsize += w->SaveSize();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?SaveSize@WayPointClass@@QAEHXZ		; WayPointClass::SaveSize
	add	eax, DWORD PTR _totalsize$[ebp]
	mov	DWORD PTR _totalsize$[ebp], eax

; 1032 : 		wps++;

	mov	cx, WORD PTR _wps$[ebp]
	add	cx, 1
	mov	WORD PTR _wps$[ebp], cx

; 1033 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1034 : 	}

	jmp	SHORT $LN22@SendDeaggr
$LN21@SendDeaggr:

; 1035 : 	totalsize += 
; 1036 : 		sizeof(VU_SESSION_ID) + sizeof(VU_SESSION_ID) + sizeof(fourbyte) + 
; 1037 : 		sizeof(fourbyte) + sizeof(float) + sizeof(ushort) + sizeof(ushort)
; 1038 : 	;

	mov	edx, DWORD PTR _totalsize$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR _totalsize$[ebp], edx

; 1039 : 
; 1040 : 	if (IsFlight()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN20@SendDeaggr

; 1041 : 		totalsize += sizeof(long) + sizeof(uchar) + 
; 1042 : 			GetNumberOfLoadouts() * sizeof(short) * HARDPOINT_MAX + 
; 1043 : 			GetNumberOfLoadouts() * sizeof(uchar) * HARDPOINT_MAX
; 1044 : 		;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
	mov	esi, eax
	shl	esi, 1
	shl	esi, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
	shl	eax, 4
	add	eax, DWORD PTR _totalsize$[ebp]
	lea	ecx, DWORD PTR [eax+esi+5]
	mov	DWORD PTR _totalsize$[ebp], ecx
$LN20@SendDeaggr:

; 1045 : 	}
; 1046 : 
; 1047 : 	// Calculate per vehicle data size
; 1048 : 	onesize =  sizeof(uchar) + sizeof(VU_ID_NUMBER) + sizeof(float) + sizeof(float) + sizeof(float) + sizeof(short);

	mov	DWORD PTR _onesize$[ebp], 19		; 00000013H

; 1049 : 	for (v=0; v<VEHICLE_GROUPS_PER_UNIT; v++){

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN19@SendDeaggr
$LN18@SendDeaggr:
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 1
	mov	DWORD PTR _v$[ebp], edx
$LN19@SendDeaggr:
	cmp	DWORD PTR _v$[ebp], 16			; 00000010H
	jge	SHORT $LN17@SendDeaggr

; 1050 : 		tr += GetNumVehicles(v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumVehicles@UnitClass@@QAEHH@Z	; UnitClass::GetNumVehicles
	add	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR _tr$[ebp], eax

; 1051 : 	}

	jmp	SHORT $LN18@SendDeaggr
$LN17@SendDeaggr:

; 1052 : 	/* sfr: not necessary
; 1053 : 	VuListIterator myit(GetComponents());
; 1054 : 	vehicle = (SimVehicleClass*) myit.GetFirst();
; 1055 : 	while (vehicle){
; 1056 : 		tc++;
; 1057 : 		vehicle = (SimVehicleClass*) myit.GetNext();
; 1058 : 	}*/	
; 1059 : 	totalsize += tr*onesize;

	mov	ecx, DWORD PTR _tr$[ebp]
	imul	ecx, DWORD PTR _onesize$[ebp]
	add	ecx, DWORD PTR _totalsize$[ebp]
	mov	DWORD PTR _totalsize$[ebp], ecx

; 1060 : 
; 1061 : 	msg = new FalconSimCampMessage(Id(), target);

	push	66					; 00000042H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN26@SendDeaggr
	push	1
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0FalconSimCampMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconSimCampMessage::FalconSimCampMessage
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN27@SendDeaggr
$LN26@SendDeaggr:
	mov	DWORD PTR tv163[ebp], 0
$LN27@SendDeaggr:
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR _msg$[ebp], ecx

; 1062 : 	msg->dataBlock.message = FalconSimCampMessage::simcampDeaggregateFromData;

	mov	edx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [edx+56], 4

; 1063 : 	msg->dataBlock.from = GetDeagOwner();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ; CampBaseClass::GetDeagOwner
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 1064 : 	msg->dataBlock.size = totalsize;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	dx, WORD PTR _totalsize$[ebp]
	mov	WORD PTR [ecx+60], dx

; 1065 : 	msg->dataBlock.data = new uchar[totalsize];

	mov	eax, DWORD PTR _totalsize$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [ecx+62], edx

; 1066 : 	ddptr = msg->dataBlock.data;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+62]
	mov	DWORD PTR _ddptr$[ebp], ecx

; 1067 : 	// pass some status stuff along, so we're on the same page.
; 1068 : 	addr = GetDeagOwner().creator_;

	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ; CampBaseClass::GetDeagOwner
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _addr$[ebp], eax

; 1069 : 	memcpy(ddptr, &addr, sizeof(VU_SESSION_ID));				ddptr += sizeof(VU_SESSION_ID);

	push	4
	lea	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ddptr$[ebp], eax

; 1070 : 	addr = FalconLocalSession->Id().creator_;

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _addr$[ebp], edx

; 1071 : 	memcpy(ddptr, &addr, sizeof(VU_SESSION_ID));				ddptr += sizeof(VU_SESSION_ID);

	push	4
	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ddptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ddptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ddptr$[ebp], edx

; 1072 : 	memcpy(ddptr, &unit_flags, sizeof(fourbyte));				ddptr += sizeof(fourbyte);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	mov	ecx, DWORD PTR _ddptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ddptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ddptr$[ebp], edx

; 1073 : 	memcpy(ddptr, &roster, sizeof(fourbyte));					ddptr += sizeof(fourbyte);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	mov	ecx, DWORD PTR _ddptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ddptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ddptr$[ebp], edx

; 1074 : 	z = ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _z$[ebp]

; 1075 : 	memcpy(ddptr, &z, sizeof(float));							ddptr += sizeof(float);

	push	4
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ddptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ddptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ddptr$[ebp], edx

; 1076 : 	value = (ushort) current_wp-1;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+224]
	sub	ecx, 1
	mov	WORD PTR _value$[ebp], cx

; 1077 : 	memcpy(ddptr, &value, sizeof(ushort));						ddptr += sizeof(ushort);

	push	2
	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _ddptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ddptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ddptr$[ebp], ecx

; 1078 : 	memcpy(ddptr, &wps, sizeof(ushort));						ddptr += sizeof(ushort);

	push	2
	lea	edx, DWORD PTR _wps$[ebp]
	push	edx
	mov	eax, DWORD PTR _ddptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ddptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ddptr$[ebp], ecx

; 1079 : 	w = GetFirstUnitWP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax
$LN16@SendDeaggr:

; 1080 : 	while (w){

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN15@SendDeaggr

; 1081 : 		w->Save(&ddptr);

	lea	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?Save@WayPointClass@@QAEHPAPAE@Z	; WayPointClass::Save

; 1082 : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 1083 : 	}

	jmp	SHORT $LN16@SendDeaggr
$LN15@SendDeaggr:

; 1084 : 	// Send the loadout array for anything which has it (probably only flights)
; 1085 : 	if (IsFlight()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN11@SendDeaggr

; 1086 : 		fuel = GetBurntFuel();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	call	eax
	mov	DWORD PTR _fuel$[ebp], eax

; 1087 : 		memcpy(ddptr, &fuel, sizeof(long));						ddptr += sizeof(long);

	push	4
	lea	ecx, DWORD PTR _fuel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ddptr$[ebp], eax

; 1088 : 		value = (uchar) GetNumberOfLoadouts();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
	movzx	cx, al
	mov	WORD PTR _value$[ebp], cx

; 1089 : 		memcpy(ddptr, &value, sizeof(uchar));					ddptr += sizeof(uchar);

	push	1
	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _ddptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ddptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ddptr$[ebp], ecx

; 1090 : 		for (v=0; v<value; v++){

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN13@SendDeaggr
$LN12@SendDeaggr:
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 1
	mov	DWORD PTR _v$[ebp], edx
$LN13@SendDeaggr:
	movzx	eax, WORD PTR _value$[ebp]
	cmp	DWORD PTR _v$[ebp], eax
	jge	$LN11@SendDeaggr

; 1091 : 			for (i=0; i<HARDPOINT_MAX; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SendDeaggr
$LN9@SendDeaggr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@SendDeaggr:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN8@SendDeaggr

; 1092 : 				wv = (short) GetUnitWeaponId(i,v);

	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+584]
	call	eax
	mov	WORD PTR _wv$[ebp], ax

; 1093 : 				memcpy(ddptr, &wv, sizeof(short));				ddptr += sizeof(short);

	push	2
	lea	ecx, DWORD PTR _wv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ddptr$[ebp], eax

; 1094 : 				wv = (uchar) GetUnitWeaponCount(i,v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+588]
	call	eax
	movzx	cx, al
	mov	WORD PTR _wv$[ebp], cx

; 1095 : 				memcpy(ddptr, &wv, sizeof(uchar));				ddptr += sizeof(uchar);

	push	1
	lea	edx, DWORD PTR _wv$[ebp]
	push	edx
	mov	eax, DWORD PTR _ddptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ddptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ddptr$[ebp], ecx

; 1096 : 			}

	jmp	$LN9@SendDeaggr
$LN8@SendDeaggr:

; 1097 : 		}

	jmp	$LN12@SendDeaggr
$LN11@SendDeaggr:

; 1098 : 	}
; 1099 : 
; 1100 : 	{
; 1101 : 		VuListIterator myit(GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _myit$7[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1102 : 		for (

	lea	ecx, DWORD PTR _myit$7[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _vehicle$[ebp], eax

; 1103 : 			vehicle = static_cast<SimVehicleClass*>(myit.GetFirst());
; 1104 : 			vehicle != NULL;

	jmp	SHORT $LN7@SendDeaggr
$LN6@SendDeaggr:

; 1105 : 			vehicle = static_cast<SimVehicleClass*>(myit.GetNext())
; 1106 : 		){

	lea	ecx, DWORD PTR _myit$7[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _vehicle$[ebp], eax
$LN7@SendDeaggr:
	cmp	DWORD PTR _vehicle$[ebp], 0
	je	$LN5@SendDeaggr

; 1107 : 			//sfr: not needed
; 1108 : 			//classID = vehicle->Type() - VU_LAST_ENTITY_TYPE;
; 1109 : 			//vc = GetVehicleClassData(classID);
; 1110 : 			uchar slot = (uchar)vehicle->GetSlot();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?GetSlot@SimBaseClass@@QAEHXZ		; SimBaseClass::GetSlot
	mov	BYTE PTR _slot$11[ebp], al

; 1111 : 			memcpy(ddptr, &slot, sizeof(uchar));						ddptr += sizeof(uchar);

	push	1
	lea	edx, DWORD PTR _slot$11[ebp]
	push	edx
	mov	eax, DWORD PTR _ddptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ddptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ddptr$[ebp], ecx

; 1112 : 			num = vehicle->Id().num_;

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _num$[ebp], eax

; 1113 : 			memcpy(ddptr, &num, sizeof(VU_ID_NUMBER));					ddptr += sizeof(VU_ID_NUMBER);

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ddptr$[ebp], eax

; 1114 : 			pos = vehicle->XPos();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _pos$[ebp]

; 1115 : 			memcpy(ddptr, &pos, sizeof(float));							ddptr += sizeof(float);

	push	4
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ddptr$[ebp], eax

; 1116 : 			pos = vehicle->YPos();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _pos$[ebp]

; 1117 : 			memcpy(ddptr, &pos, sizeof(float));							ddptr += sizeof(float);

	push	4
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ddptr$[ebp], eax

; 1118 : 			pos = vehicle->Yaw();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _pos$[ebp]

; 1119 : 			memcpy(ddptr, &pos, sizeof(float));							ddptr += sizeof(float);

	push	4
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ddptr$[ebp], eax

; 1120 : 			if (vehicle->IsAirplane()){

	mov	ecx, DWORD PTR _vehicle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _vehicle$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	SHORT $LN4@SendDeaggr

; 1121 : 				if (((AircraftClass*)vehicle)->DBrain()){

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	test	eax, eax
	je	SHORT $LN3@SendDeaggr

; 1122 : 					num = ((AircraftClass*)vehicle)->DBrain()->GetTaxiPoint();

	mov	ecx, DWORD PTR _vehicle$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?GetTaxiPoint@DigitalBrain@@QAEHXZ	; DigitalBrain::GetTaxiPoint
	mov	DWORD PTR _num$[ebp], eax

; 1123 : 				}
; 1124 : 				else{

	jmp	SHORT $LN2@SendDeaggr
$LN3@SendDeaggr:

; 1125 : 					num = 0;

	mov	DWORD PTR _num$[ebp], 0
$LN2@SendDeaggr:

; 1126 : 				}
; 1127 : 			}
; 1128 : 			else{

	jmp	SHORT $LN1@SendDeaggr
$LN4@SendDeaggr:

; 1129 : 				num = 0;

	mov	DWORD PTR _num$[ebp], 0
$LN1@SendDeaggr:

; 1130 : 			}
; 1131 : 			memcpy(ddptr, &num, sizeof(short));							ddptr += sizeof(short);

	push	2
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ddptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ddptr$[ebp], eax

; 1132 : 		}	

	jmp	$LN6@SendDeaggr
$LN5@SendDeaggr:

; 1133 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$7[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1134 : 
; 1135 : 	// Send Deaggregation data to everyone in the group
; 1136 : 	FalconSendMessage(msg, TRUE);

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN24@SendDeaggr:

; 1137 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z$0:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z$1:
	lea	ecx, DWORD PTR _myit$7[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendDeaggregateData@UnitClass@@UAEXPAVVuTargetEntity@@@Z ENDP ; UnitClass::SendDeaggregateData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_tmp_ent$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@UnitClass@@UAEHPAVVuFullUpdateEvent@@@Z PROC	; UnitClass::Handle
; _this$ = ecx

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 	// copy data from temp entity to current entity
; 504  : 	UnitClass* tmp_ent = (UnitClass*)(event->expandedData_.get());

	mov	ecx, DWORD PTR _event$[ebp]
	add	ecx, 48					; 00000030H
	call	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ; VuBin<VuEntity>::get
	mov	DWORD PTR _tmp_ent$[ebp], eax

; 505  : 
; 506  : 	DisposeWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints

; 507  : 
; 508  : 	memcpy(&last_check, &tmp_ent->last_check, sizeof(CampaignTime));

	push	4
	mov	eax, DWORD PTR _tmp_ent$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 509  : 	memcpy(&roster, &tmp_ent->roster, sizeof(fourbyte));		

	push	4
	mov	edx, DWORD PTR _tmp_ent$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 510  : 	memcpy(&unit_flags, &tmp_ent->unit_flags, sizeof(fourbyte));		

	push	4
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	add	ecx, 196				; 000000c4H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 196				; 000000c4H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 511  : 	memcpy(&dest_x, &tmp_ent->dest_x, sizeof(GridIndex));		

	push	2
	mov	eax, DWORD PTR _tmp_ent$[ebp]
	add	eax, 200				; 000000c8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 512  : 	memcpy(&dest_y, &tmp_ent->dest_y, sizeof(GridIndex));		

	push	2
	mov	edx, DWORD PTR _tmp_ent$[ebp]
	add	edx, 202				; 000000caH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 202				; 000000caH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 513  : 	memcpy(&target_id, &tmp_ent->target_id, sizeof(VU_ID));

	push	8
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	add	ecx, 212				; 000000d4H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 212				; 000000d4H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 514  : 	memcpy(&cargo_id, &tmp_ent->cargo_id, sizeof(VU_ID));

	push	8
	mov	eax, DWORD PTR _tmp_ent$[ebp]
	add	eax, 204				; 000000ccH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 515  : 	memcpy(&moved, &tmp_ent->moved, sizeof(uchar));			

	push	1
	mov	edx, DWORD PTR _tmp_ent$[ebp]
	add	edx, 220				; 000000dcH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 220				; 000000dcH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 516  : 	memcpy(&losses, &tmp_ent->losses, sizeof(uchar));		

	push	1
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	add	ecx, 221				; 000000ddH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 221				; 000000ddH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 517  : 	memcpy(&tactic, &tmp_ent->tactic, sizeof(uchar));		

	push	1
	mov	eax, DWORD PTR _tmp_ent$[ebp]
	add	eax, 222				; 000000deH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 222				; 000000deH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 518  : 	memcpy(&current_wp, &tmp_ent->current_wp, sizeof(ushort));

	push	2
	mov	edx, DWORD PTR _tmp_ent$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 519  : 	memcpy(&name_id, &tmp_ent->name_id, sizeof(short));		

	push	2
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	add	ecx, 226				; 000000e2H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 226				; 000000e2H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 520  : 	memcpy(&reinforcement, &tmp_ent->reinforcement, sizeof(short));	

	push	2
	mov	eax, DWORD PTR _tmp_ent$[ebp]
	add	eax, 228				; 000000e4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 228				; 000000e4H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 521  : 
; 522  : 	wp_list = tmp_ent->wp_list;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmp_ent$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR [edx+244], ecx

; 523  : 	tmp_ent->wp_list = NULL;

	mov	edx, DWORD PTR _tmp_ent$[ebp]
	mov	DWORD PTR [edx+244], 0

; 524  : 
; 525  : 	SetPosition(tmp_ent->XPos(),tmp_ent->YPos(),tmp_ent->ZPos());

	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _tmp_ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 526  : 
; 527  : 	return CampBaseClass::Handle(event);

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@CampBaseClass@@UAEHPAVVuFullUpdateEvent@@@Z ; CampBaseClass::Handle

; 528  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@UnitClass@@UAEHPAVVuFullUpdateEvent@@@Z ENDP	; UnitClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_stream$ = 8						; size = 4
?Save@UnitClass@@UAEHPAPAE@Z PROC			; UnitClass::Save
; _this$ = ecx

; 454  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 455  : 	CampBaseClass::Save(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Save@CampBaseClass@@UAEHPAPAE@Z	; CampBaseClass::Save

; 456  : 
; 457  : 	if (save_log)

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN3@Save

; 458  : 	{
; 459  : 		fprintf (save_log, "%08x UnitClass ", *stream - start_save_stream);

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR ?start_save_stream@@3HA	; start_save_stream
	push	edx
	push	OFFSET ??_C@_0BA@NIOPHDFC@?$CF08x?5UnitClass?5?$AA@
	mov	eax, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 460  : 		fflush (save_log);

	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fflush
	add	esp, 4
$LN3@Save:

; 461  : 	}
; 462  : 
; 463  : 	if (!IsAggregate())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate

; 464  : 	{
; 465  : 		// KCK TODO: We need to send the deaggregated data as well!
; 466  : 	}
; 467  : 
; 468  : 	memcpy(*stream, &last_check, sizeof(CampaignTime));		*stream += sizeof(CampaignTime);

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 184				; 000000b8H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 469  : 	memcpy(*stream, &roster, sizeof(fourbyte));				*stream += sizeof(fourbyte);

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 470  : 	memcpy(*stream, &unit_flags, sizeof(fourbyte));			*stream += sizeof(fourbyte);

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 196				; 000000c4H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 471  : 	memcpy(*stream, &dest_x, sizeof(GridIndex));			*stream += sizeof(GridIndex);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 472  : 	memcpy(*stream, &dest_y, sizeof(GridIndex));			*stream += sizeof(GridIndex);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 202				; 000000caH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 473  : #ifdef CAMPTOOL
; 474  : 	if (gRenameIds)
; 475  : 		target_id.num_ = RenameTable[target_id.num_];
; 476  : #endif
; 477  : 	memcpy(*stream, &target_id,	sizeof(VU_ID));				*stream += sizeof(VU_ID);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 212				; 000000d4H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 478  : #ifdef CAMPTOOL
; 479  : 	if (gRenameIds)
; 480  : 		cargo_id.num_ = RenameTable[cargo_id.num_];
; 481  : #endif
; 482  : 	memcpy(*stream, &cargo_id,	sizeof(VU_ID));				*stream += sizeof(VU_ID);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 204				; 000000ccH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 483  : 	memcpy(*stream, &moved, sizeof(uchar));					*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 220				; 000000dcH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 484  : 	memcpy(*stream, &losses, sizeof(uchar));				*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 221				; 000000ddH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 485  : 	memcpy(*stream, &tactic, sizeof(uchar));				*stream += sizeof(uchar);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 222				; 000000deH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 486  : 	memcpy(*stream, &current_wp, sizeof(ushort));			*stream += sizeof(ushort);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 487  : 	memcpy(*stream, &name_id, sizeof(short));				*stream += sizeof(short);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 226				; 000000e2H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 488  : 	memcpy(*stream, &reinforcement, sizeof(short));			*stream += sizeof(short);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 228				; 000000e4H
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 489  : 
; 490  : 	if (save_log)

	cmp	DWORD PTR ?save_log@@3PAU_iobuf@@A, 0	; save_log
	je	SHORT $LN1@Save

; 491  : 	{
; 492  : 		fprintf (save_log, "%08x Waypoints ", *stream - start_save_stream);

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR ?start_save_stream@@3HA	; start_save_stream
	push	eax
	push	OFFSET ??_C@_0BA@BOFFLAKG@?$CF08x?5Waypoints?5?$AA@
	mov	ecx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 493  : 		fflush (save_log);

	mov	edx, DWORD PTR ?save_log@@3PAU_iobuf@@A	; save_log
	push	edx
	call	_fflush
	add	esp, 4
$LN1@Save:

; 494  : 	}
; 495  : 
; 496  : 	EncodeWaypoints(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncodeWaypoints@UnitClass@@QAEHPAPAE@Z	; UnitClass::EncodeWaypoints

; 497  : 
; 498  : 	return SaveSize();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 499  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Save@UnitClass@@UAEHPAPAE@Z ENDP			; UnitClass::Save
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_w$ = -12						; size = 4
_size$ = -8						; size = 4
_wps$ = -1						; size = 1
?SaveSize@UnitClass@@UAEHXZ PROC			; UnitClass::SaveSize
; _this$ = ecx

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 	uchar		wps=0;

	mov	BYTE PTR _wps$[ebp], 0

; 420  : 	int			size=0;

	mov	DWORD PTR _size$[ebp], 0

; 421  : 	WayPoint	w;
; 422  : 
; 423  : 	// Count waypoints
; 424  : 	//	CampEnterCriticalSection();
; 425  : 	w = wp_list;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR _w$[ebp], ecx
$LN2@SaveSize:

; 426  : 	while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN1@SaveSize

; 427  : 	{
; 428  : 		wps++;

	mov	dl, BYTE PTR _wps$[ebp]
	add	dl, 1
	mov	BYTE PTR _wps$[ebp], dl

; 429  : 		size += w->SaveSize();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?SaveSize@WayPointClass@@QAEHXZ		; WayPointClass::SaveSize
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 430  : 		w = w->GetNextWP();

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _w$[ebp], eax

; 431  : 	}

	jmp	SHORT $LN2@SaveSize
$LN1@SaveSize:

; 432  : 	//	CampLeaveCriticalSection();
; 433  : 
; 434  : 	// return size
; 435  : 	size += CampBaseClass::SaveSize()
; 436  : 			+ sizeof(CampaignTime)
; 437  : 			+ sizeof(fourbyte)
; 438  : 			+ sizeof(fourbyte)
; 439  : 			+ sizeof(GridIndex)
; 440  : 			+ sizeof(GridIndex)
; 441  : 			+ sizeof(VU_ID)
; 442  : 			+ sizeof(VU_ID)
; 443  : 			+ sizeof(uchar)
; 444  : 			+ sizeof(uchar)
; 445  : 			+ sizeof(uchar)
; 446  : 			+ sizeof(ushort)
; 447  : 			+ sizeof(short)
; 448  : 			+ sizeof(short)
; 449  : 			+ sizeof(ushort);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveSize@CampBaseClass@@UAEHXZ		; CampBaseClass::SaveSize
	mov	ecx, DWORD PTR _size$[ebp]
	lea	edx, DWORD PTR [ecx+eax+43]
	mov	DWORD PTR _size$[ebp], edx

; 450  : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 451  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveSize@UnitClass@@UAEHXZ ENDP			; UnitClass::SaveSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_c$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1UnitClass@@UAE@XZ PROC				; UnitClass::~UnitClass
; _this$ = ecx

; 397  : UnitClass::~UnitClass(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1UnitClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7UnitClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 398  : 	ShiAssert( !draw_pointer );
; 399  : 
; 400  : 	if (wp_list)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+244], 0
	je	SHORT $LN2@UnitClass

; 401  : 		DisposeWayPoints();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisposeWayPoints@UnitClass@@QAEXXZ	; UnitClass::DisposeWayPoints
$LN2@UnitClass:

; 402  : 	wp_list = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+244], 0

; 403  : 
; 404  : 	// Kill any cargo we were carrying
; 405  : 	Unit	c;
; 406  : 	c = (Unit) GetCargo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCargo@UnitClass@@QAEPAVCampBaseClass@@XZ ; UnitClass::GetCargo
	mov	DWORD PTR _c$[ebp], eax

; 407  : 	if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN3@UnitClass

; 408  : 		c->KillUnit();

	mov	ecx, DWORD PTR _c$[ebp]
	call	?KillUnit@UnitClass@@QAEXXZ		; UnitClass::KillUnit
$LN3@UnitClass:

; 409  : 
; 410  : 
; 411  : #ifdef DEBUG_COUNT
; 412  : 	gUnitCount--;
; 413  : 	myunitlist.DelObj(Id().num_);
; 414  : #endif
; 415  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CampBaseClass@@UAE@XZ		; CampBaseClass::~CampBaseClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1UnitClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CampBaseClass@@UAE@XZ		; CampBaseClass::~CampBaseClass
__ehhandler$??1UnitClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1UnitClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1UnitClass@@UAE@XZ ENDP				; UnitClass::~UnitClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
??0UnitClass@@QAE@PAPAEPAJ@Z PROC			; UnitClass::UnitClass
; _this$ = ecx

; 286  : UnitClass::UnitClass(VU_BYTE **stream, long *rem) : CampBaseClass (stream, rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0UnitClass@@QAE@PAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CampBaseClass@@QAE@PAPAEPAJ@Z	; CampBaseClass::CampBaseClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7UnitClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 287  : #if HOTSPOT_FIX
; 288  : 	update_interval = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 289  : #endif
; 290  : 
; 291  : 	if (load_log) {

	cmp	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
	je	SHORT $LN6@UnitClass

; 292  : 		fprintf (load_log, "%08x UnitClass ", *stream - start_load_stream);

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR ?start_load_stream@@3HA	; start_load_stream
	push	edx
	push	OFFSET ??_C@_0BA@NIOPHDFC@?$CF08x?5UnitClass?5?$AA@
	mov	eax, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 293  : 		fflush (load_log);

	mov	ecx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	ecx
	call	_fflush
	add	esp, 4
$LN6@UnitClass:

; 294  : 	}
; 295  : 
; 296  : //#ifdef CAMPTOOL
; 297  : //	if (gRenameIds)
; 298  : //	{
; 299  : //		VU_ID		new_id = FalconNullId;
; 300  : //
; 301  : //		if (IsFlight() || IsPackage())
; 302  : //		{
; 303  : //			// Rename this ID
; 304  : //			for (
; 305  : //				new_id.num_ = FIRST_LOW_VOLATILE_VU_ID_NUMBER_1; 
; 306  : //				new_id.num_ < LAST_LOW_VOLATILE_VU_ID_NUMBER_2; 
; 307  : //				new_id.num_++
; 308  : //			){
; 309  : //				if (!vuDatabase->Find(new_id))
; 310  : //				{
; 311  : //					RenameTable[share_.id_.num_] = new_id.num_;
; 312  : //					share_.id_ = new_id;
; 313  : //					break;
; 314  : //				}
; 315  : //			}
; 316  : //		}
; 317  : //		else
; 318  : //		{
; 319  : //			// Rename this ID
; 320  : //			for (new_id.num_ = FIRST_NON_VOLATILE_VU_ID_NUMBER; new_id.num_ < LAST_NON_VOLATILE_VU_ID_NUMBER; new_id.num_++)
; 321  : //			{
; 322  : //				if (!vuDatabase->Find(new_id))
; 323  : //				{
; 324  : //					RenameTable[share_.id_.num_] = new_id.num_;
; 325  : //					share_.id_ = new_id;
; 326  : //					break;
; 327  : //				}
; 328  : //			}
; 329  : //		}
; 330  : //	}
; 331  : //#endif
; 332  : 
; 333  : 	memcpychk(&last_check, stream, sizeof(CampaignTime), rem);	

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 334  : 	memcpychk(&roster, stream, sizeof(fourbyte), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 335  : 	memcpychk(&unit_flags, stream, sizeof(fourbyte), rem);		

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196				; 000000c4H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 336  : 	memcpychk(&dest_x, stream, sizeof(GridIndex), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 337  : 	memcpychk(&dest_y, stream, sizeof(GridIndex), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 202				; 000000caH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 338  : 	memcpychk(&target_id, stream, sizeof(VU_ID), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 339  : #ifdef DEBUG
; 340  : 	// VU_ID_NUMBERs moved to 32 bits
; 341  : 	target_id.num_ &= 0xffff;
; 342  : #endif
; 343  : 	if (gCampDataVersion > 1)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 1	; gCampDataVersion
	jle	SHORT $LN5@UnitClass

; 344  : 	{
; 345  : 		memcpychk(&cargo_id, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 346  : #ifdef DEBUG
; 347  : 		// VU_ID_NUMBERs moved to 32 bits
; 348  : 		cargo_id.num_ &= 0xffff;
; 349  : #endif
; 350  : 	}
; 351  : 	else

	jmp	SHORT $LN4@UnitClass
$LN5@UnitClass:

; 352  : 	{
; 353  : 		cargo_id = FalconNullId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [edx+204], eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [edx+208], ecx

; 354  : 		SetCargo(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCargo@UnitClass@@QAEXH@Z		; UnitClass::SetCargo

; 355  : 		SetRefused(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRefused@UnitClass@@QAEXH@Z		; UnitClass::SetRefused
$LN4@UnitClass:

; 356  : 	}
; 357  : 
; 358  : 	memcpychk(&moved, stream, sizeof(uchar), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 220				; 000000dcH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 359  : 	memcpychk(&losses, stream, sizeof(uchar), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 221				; 000000ddH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 360  : 	memcpychk(&tactic, stream, sizeof(uchar), rem);			

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 222				; 000000deH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 361  : 	if (gCampDataVersion >= 71)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 71	; gCampDataVersion, 00000047H
	jl	SHORT $LN3@UnitClass

; 362  : 	{
; 363  : 		memcpychk(&current_wp, stream, sizeof(ushort), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 364  : 	}
; 365  : 	else

	jmp	SHORT $LN2@UnitClass
$LN3@UnitClass:

; 366  : 	{
; 367  : 		current_wp = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+224], dx

; 368  : 		memcpychk(&current_wp, stream, sizeof(uchar), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN2@UnitClass:

; 369  : 	}
; 370  : 	memcpychk(&name_id, stream, sizeof(short), rem);	

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 226				; 000000e2H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 371  : 	memcpychk(&reinforcement, stream, sizeof(short), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 228				; 000000e4H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 372  : 
; 373  : 	odds = 50;

	mov	ecx, 50					; 00000032H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+230], cx

; 374  : 	draw_pointer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+240], 0

; 375  : 
; 376  : 	if (load_log){

	cmp	DWORD PTR ?load_log@@3PAU_iobuf@@A, 0	; load_log
	je	SHORT $LN1@UnitClass

; 377  : 		fprintf (load_log, "%08x Waypoints ", stream - start_load_stream);

	mov	ecx, DWORD PTR ?start_load_stream@@3HA	; start_load_stream
	shl	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	sub	edx, ecx
	push	edx
	push	OFFSET ??_C@_0BA@BOFFLAKG@?$CF08x?5Waypoints?5?$AA@
	mov	eax, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 378  : 		fflush (load_log);

	mov	ecx, DWORD PTR ?load_log@@3PAU_iobuf@@A	; load_log
	push	ecx
	call	_fflush
	add	esp, 4
$LN1@UnitClass:

; 379  : 	}
; 380  : 
; 381  : 	wp_list = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+244], 0

; 382  : 	DecodeWaypoints(stream, rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z ; UnitClass::DecodeWaypoints

; 383  : 
; 384  : 	class_data = (UnitClassDataType*) Falcon4ClassTable[share_.entityType_-VU_LAST_ENTITY_TYPE].dataPtr;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+4]
	sub	eax, 100				; 00000064H
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+eax+77]
	mov	DWORD PTR [ecx+236], eax

; 385  : 	dirty_unit = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+232], 0

; 386  : 
; 387  : #ifdef DEBUG_COUNT
; 388  : 	gUnitCount++;
; 389  : 	myunitlist.AddObj(Id().num_, this);
; 390  : #endif
; 391  : 	// JPO SOJ
; 392  : 	sojSource = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+248], 0

; 393  : 	sojOctant = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+252], 0

; 394  : 	sojRangeSq = 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+256], xmm0

; 395  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0UnitClass@@QAE@PAPAEPAJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CampBaseClass@@UAE@XZ		; CampBaseClass::~CampBaseClass
__ehhandler$??0UnitClass@@QAE@PAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0UnitClass@@QAE@PAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0UnitClass@@QAE@PAPAEPAJ@Z ENDP			; UnitClass::UnitClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 2
_id$ = 12						; size = 4
??0UnitClass@@QAE@GK@Z PROC				; UnitClass::UnitClass
; _this$ = ecx

; 252  : UnitClass::UnitClass (ushort type, VU_ID_NUMBER id) : CampBaseClass (type, id){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0UnitClass@@QAE@GK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	movzx	ecx, WORD PTR _type$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CampBaseClass@@QAE@GK@Z		; CampBaseClass::CampBaseClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7UnitClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 253  : 	last_check = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 0

; 254  : #if HOTSPOT_FIX
; 255  : 	update_interval = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+188], 0

; 256  : #endif
; 257  : 	roster = 0;     

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+192], 0

; 258  : 	unit_flags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], 0

; 259  : 	dest_x = dest_y = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+202], cx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+200], ax

; 260  : 	target_id = FalconNullId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [edx+212], eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [edx+216], ecx

; 261  : 	cargo_id = FalconNullId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [edx+204], eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [edx+208], ecx

; 262  : 	moved = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+220], 0

; 263  : 	losses = 0;		

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+221], 0

; 264  : 	tactic = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+222], 0

; 265  : 	current_wp = 0;	

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+224], dx

; 266  : 	name_id = GetCampId ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCampId@CampBaseClass@@QBEFXZ	; CampBaseClass::GetCampId
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+226], ax

; 267  : 	reinforcement = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+228], dx

; 268  : 	odds = 50;

	mov	ecx, 50					; 00000032H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+230], cx

; 269  : 	wp_list = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+244], 0

; 270  : 	draw_pointer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], 0

; 271  : 	class_data = (UnitClassDataType*) Falcon4ClassTable[type-VU_LAST_ENTITY_TYPE].dataPtr;

	movzx	edx, WORD PTR _type$[ebp]
	sub	edx, 100				; 00000064H
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+edx+77]
	mov	DWORD PTR [eax+236], edx

; 272  : 	dirty_unit = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+232], 0

; 273  : 
; 274  : 	SetUnitAltitude(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitAltitude@UnitClass@@QAEXH@Z	; UnitClass::SetUnitAltitude

; 275  : #ifdef DEBUG_COUNT
; 276  : 	gUnitCount++;
; 277  : 	myunitlist.AddObj(Id().num_, this);
; 278  : #endif
; 279  : 
; 280  : 	// JB SOJ
; 281  : 	sojSource = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+248], 0

; 282  : 	sojOctant = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+252], 0

; 283  : 	sojRangeSq = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+256], xmm0

; 284  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0UnitClass@@QAE@GK@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CampBaseClass@@UAE@XZ		; CampBaseClass::~CampBaseClass
__ehhandler$??0UnitClass@@QAE@GK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0UnitClass@@QAE@GK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0UnitClass@@QAE@GK@Z ENDP				; UnitClass::UnitClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bits$ = -8						; size = 2
_refresh_required$ = -1					; size = 1
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
?ReadDirty@UnitClass@@QAEXPAPAEPAJ@Z PROC		; UnitClass::ReadDirty
; _this$ = ecx

; 5907 : void UnitClass::ReadDirty (VU_BYTE **stream, long *rem){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 5908 : 
; 5909 : 	bool refresh_required;
; 5910 : 	unsigned short bits;
; 5911 : 
; 5912 : 	refresh_required = false;

	mov	BYTE PTR _refresh_required$[ebp], 0

; 5913 : 
; 5914 : 	memcpychk(&bits, stream, sizeof(unsigned short), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bits$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5915 : 
; 5916 : 	// MonoPrint ("Recv UC %08x", bits);
; 5917 : 
; 5918 : 	if (bits & DIRTY_WAYPOINT) {

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 1
	je	SHORT $LN11@ReadDirty

; 5919 : 		memcpychk(&current_wp, stream, sizeof(ushort), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN11@ReadDirty:

; 5920 : #ifdef DEBUG
; 5921 : 		if (!current_wp)
; 5922 : 			ShiAssert(!IsFlight());
; 5923 : #endif
; 5924 : 	}
; 5925 : 
; 5926 : 	if (bits & DIRTY_ROSTER) {

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 4
	je	SHORT $LN10@ReadDirty

; 5927 : 		memcpychk(&roster, stream, sizeof(fourbyte), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5928 : 		refresh_required = true;

	mov	BYTE PTR _refresh_required$[ebp], 1
$LN10@ReadDirty:

; 5929 : 	}
; 5930 : 
; 5931 : 	if (bits & DIRTY_UNIT_FLAGS) {

	movzx	edx, WORD PTR _bits$[ebp]
	and	edx, 8
	je	SHORT $LN9@ReadDirty

; 5932 : 		memcpychk(&unit_flags, stream, sizeof(fourbyte), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 196				; 000000c4H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN9@ReadDirty:

; 5933 : 	}
; 5934 : 
; 5935 : 	if (bits & DIRTY_DESTINATION) {

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN8@ReadDirty

; 5936 : 
; 5937 : 		memcpychk(&dest_x, stream, sizeof(GridIndex), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 200				; 000000c8H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 5938 : 		memcpychk(&dest_y, stream, sizeof(GridIndex), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 202				; 000000caH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN8@ReadDirty:

; 5939 : 	}
; 5940 : 
; 5941 : 	if (bits & DIRTY_CARGO_ID) {

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN7@ReadDirty

; 5942 : 		memcpychk(&cargo_id, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN7@ReadDirty:

; 5943 : 	}
; 5944 : 
; 5945 : 	if (bits & DIRTY_TARGET_ID)	{

	movzx	edx, WORD PTR _bits$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN6@ReadDirty

; 5946 : 		memcpychk(&target_id, stream, sizeof(VU_ID), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 212				; 000000d4H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN6@ReadDirty:

; 5947 : 	}
; 5948 : 
; 5949 : 	if (bits & DIRTY_MOVED)	{

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN5@ReadDirty

; 5950 : 		memcpychk(&moved, stream, sizeof(uchar), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 220				; 000000dcH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN5@ReadDirty:

; 5951 : 	}
; 5952 : 
; 5953 : 	if (bits & DIRTY_TACTIC) {

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN4@ReadDirty

; 5954 : 		memcpychk(&tactic, stream, sizeof(uchar), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 222				; 000000deH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN4@ReadDirty:

; 5955 : 	}
; 5956 : 
; 5957 : 	if (bits & DIRTY_REINFORCEMENT) {

	movzx	edx, WORD PTR _bits$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN3@ReadDirty

; 5958 : 		memcpychk(&reinforcement, stream, sizeof(short), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 228				; 000000e4H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN3@ReadDirty:

; 5959 : 	}
; 5960 : 
; 5961 : 	if (bits & DIRTY_WP_LIST)	{

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 8192				; 00002000H
	je	SHORT $LN2@ReadDirty

; 5962 : 		DecodeWaypoints(stream, rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecodeWaypoints@UnitClass@@QAEXPAPAEPAJ@Z ; UnitClass::DecodeWaypoints

; 5963 : 		//sfr: refresh UI
; 5964 : 		refresh_required = true;

	mov	BYTE PTR _refresh_required$[ebp], 1
$LN2@ReadDirty:

; 5965 : 	}
; 5966 : 
; 5967 : 	if (refresh_required){

	movzx	eax, BYTE PTR _refresh_required$[ebp]
	test	eax, eax
	je	SHORT $LN12@ReadDirty

; 5968 : 		UI_Refresh ();

	call	?UI_Refresh@@YAXXZ			; UI_Refresh
$LN12@ReadDirty:

; 5969 : 	}
; 5970 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ReadDirty@UnitClass@@QAEXPAPAEPAJ@Z ENDP		; UnitClass::ReadDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_start$ = -12						; size = 4
_this$ = -8						; size = 4
_ptr$ = -4						; size = 4
_stream$ = 8						; size = 4
?WriteDirty@UnitClass@@QAEXPAPAE@Z PROC			; UnitClass::WriteDirty
; _this$ = ecx

; 5810 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 5811 : 	unsigned char
; 5812 : 			*start,
; 5813 : 			*ptr;
; 5814 : 
; 5815 : 	start = *stream;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], ecx

; 5816 : 	ptr = *stream;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ptr$[ebp], eax

; 5817 : 
; 5818 : 	//	MonoPrint ("Send UC %08x\n", dirty_unit); 
; 5819 : 
; 5820 : 	// Encode it up
; 5821 : 	*(ushort*) ptr = dirty_unit;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+232]
	mov	WORD PTR [ecx], ax

; 5822 : 	ptr += sizeof (ushort);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx

; 5823 : 
; 5824 : 	if (dirty_unit & DIRTY_WAYPOINT)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 1
	je	SHORT $LN10@WriteDirty

; 5825 : 	{
; 5826 : 		*(ushort*)ptr = current_wp;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+224]
	mov	WORD PTR [ecx], ax

; 5827 : 		ptr += sizeof (ushort);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx
$LN10@WriteDirty:

; 5828 : #ifdef DEBUG
; 5829 : 		if (!current_wp)
; 5830 : 			ShiAssert(!IsFlight());
; 5831 : #endif
; 5832 : 	}
; 5833 : 
; 5834 : 	/*	if (dirty_unit & DIRTY_LAST_CHECK)
; 5835 : 		{
; 5836 : 	 *(CampaignTime*)ptr = last_check;
; 5837 : 	 ptr += sizeof (CampaignTime);
; 5838 : 	 }
; 5839 : 	 */
; 5840 : 	if (dirty_unit & DIRTY_ROSTER)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 4
	je	SHORT $LN9@WriteDirty

; 5841 : 	{
; 5842 : 		*(fourbyte*)ptr = roster;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+192]
	mov	DWORD PTR [ecx], eax

; 5843 : 		ptr += sizeof (fourbyte);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptr$[ebp], ecx
$LN9@WriteDirty:

; 5844 : 	}
; 5845 : 
; 5846 : 	if (dirty_unit & DIRTY_UNIT_FLAGS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 8
	je	SHORT $LN8@WriteDirty

; 5847 : 	{
; 5848 : 		*(fourbyte*)ptr = unit_flags;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [ecx], eax

; 5849 : 		ptr += sizeof (fourbyte);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptr$[ebp], ecx
$LN8@WriteDirty:

; 5850 : 	}
; 5851 : 
; 5852 : 	if (dirty_unit & DIRTY_DESTINATION)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 16					; 00000010H
	je	SHORT $LN7@WriteDirty

; 5853 : 	{
; 5854 : 		*(GridIndex*)ptr = dest_x;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+200]
	mov	WORD PTR [ecx], ax

; 5855 : 		ptr += sizeof (GridIndex);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx

; 5856 : 
; 5857 : 		*(GridIndex*)ptr = dest_y;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+202]
	mov	WORD PTR [edx], cx

; 5858 : 		ptr += sizeof (GridIndex);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx
$LN7@WriteDirty:

; 5859 : 	}
; 5860 : 
; 5861 : 	if (dirty_unit & DIRTY_CARGO_ID)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	and	ecx, 32					; 00000020H
	je	SHORT $LN6@WriteDirty

; 5862 : 	{
; 5863 : 		*(VU_ID*)ptr = cargo_id;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	ecx, DWORD PTR [edx+208]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 5864 : 		ptr += sizeof (VU_ID);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 8
	mov	DWORD PTR _ptr$[ebp], eax
$LN6@WriteDirty:

; 5865 : 	}
; 5866 : 
; 5867 : 	if (dirty_unit & DIRTY_TARGET_ID)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	and	edx, 64					; 00000040H
	je	SHORT $LN5@WriteDirty

; 5868 : 	{
; 5869 : 		*(VU_ID*)ptr = target_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	edx, DWORD PTR [eax+216]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 5870 : 		ptr += sizeof (VU_ID);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptr$[ebp], ecx
$LN5@WriteDirty:

; 5871 : 	}
; 5872 : 
; 5873 : 	if (dirty_unit & DIRTY_MOVED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 128				; 00000080H
	je	SHORT $LN4@WriteDirty

; 5874 : 	{
; 5875 : 		*(uchar*)ptr = moved;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+220]
	mov	BYTE PTR [ecx], al

; 5876 : 		ptr += sizeof (uchar);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
$LN4@WriteDirty:

; 5877 : 	}
; 5878 : 
; 5879 : 	if (dirty_unit & DIRTY_TACTIC)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 512				; 00000200H
	je	SHORT $LN3@WriteDirty

; 5880 : 	{
; 5881 : 		*(uchar*)ptr = tactic;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+222]
	mov	BYTE PTR [ecx], al

; 5882 : 		ptr += sizeof (uchar);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
$LN3@WriteDirty:

; 5883 : 	}
; 5884 : 
; 5885 : 	if (dirty_unit & DIRTY_REINFORCEMENT)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 2048				; 00000800H
	je	SHORT $LN2@WriteDirty

; 5886 : 	{
; 5887 : 		*(short*)ptr = reinforcement;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+228]
	mov	WORD PTR [ecx], ax

; 5888 : 		ptr += sizeof (short);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx
$LN2@WriteDirty:

; 5889 : 	}
; 5890 : 
; 5891 : 	if (dirty_unit & DIRTY_WP_LIST)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	and	eax, 8192				; 00002000H
	je	SHORT $LN1@WriteDirty

; 5892 : 	{
; 5893 : 		EncodeWaypoints(&ptr);

	lea	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncodeWaypoints@UnitClass@@QAEHPAPAE@Z	; UnitClass::EncodeWaypoints
$LN1@WriteDirty:

; 5894 : 	}
; 5895 : 
; 5896 : 	dirty_unit = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+232], 0

; 5897 : 
; 5898 : 	*stream = ptr;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 5899 : 
; 5900 : 	// MonoPrint ("(%d)\n", *stream - start);
; 5901 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WriteDirty@UnitClass@@QAEXPAPAE@Z ENDP			; UnitClass::WriteDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
_score$ = 12						; size = 4
?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z PROC ; UnitClass::MakeUnitDirty
; _this$ = ecx

; 5792 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5793 : 	if ((!IsLocal()) || (VuState() != VU_MEM_ACTIVE)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@MakeUnitDi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	je	SHORT $LN3@MakeUnitDi
$LN2@MakeUnitDi:

; 5794 : 		return;

	jmp	SHORT $LN4@MakeUnitDi
$LN3@MakeUnitDi:

; 5795 : 	}
; 5796 : 
; 5797 : 	if (!IsAggregate() && (score != SEND_RELIABLEANDOOB)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	jne	SHORT $LN1@MakeUnitDi
	cmp	DWORD PTR _score$[ebp], 268435456	; 10000000H
	je	SHORT $LN1@MakeUnitDi

; 5798 : 		// increase score for deagged units
; 5799 : 		score = static_cast<Dirtyness>(score << 4);

	mov	ecx, DWORD PTR _score$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _score$[ebp], ecx
$LN1@MakeUnitDi:

; 5800 : 	}
; 5801 : 	dirty_unit |= bits ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+232]
	or	eax, DWORD PTR _bits$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+232], eax

; 5802 : 	MakeDirty (DIRTY_UNIT, score);

	mov	edx, DWORD PTR _score$[ebp]
	push	edx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z ; FalconEntity::MakeDirty
$LN4@MakeUnitDi:

; 5803 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ENDP ; UnitClass::MakeUnitDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
$T2 = -1088						; size = 8
$T3 = -1080						; size = 8
_ptr$4 = -1072						; size = 4
_target$5 = -1068					; size = 4
$T6 = -1064						; size = 4
$T7 = -1060						; size = 4
tv151 = -1056						; size = 4
$T8 = -1052						; size = 4
_this$ = -1048						; size = 4
_msg$9 = -1044						; size = 4
_tmp$10 = -1040						; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?MakeWaypointsDirty@UnitClass@@QAEXXZ PROC		; UnitClass::MakeWaypointsDirty
; _this$ = ecx

; 5578 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakeWaypointsDirty@UnitClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1076				; 00000434H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5579 : 	// KCK: This is not a great way of doing this.
; 5580 : 	// Basically, it works fine for flights (which don't change waypoints often-
; 5581 : 	// in fact, only on player tweaking). However, it would be fatal to do this
; 5582 : 	// for Battalions (bandwidth wise). The bitch is, in Force-on-Force TE, we 
; 5583 : 	// need to. We can either do a TE check here (kinda scary) or set up a new
; 5584 : 	// message for ordering battalions, which is what I'm going to do.
; 5585 : 	if (IsFlight())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN4@MakeWaypoi

; 5586 : 	{
; 5587 : 		if (IsLocal()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@MakeWaypoi

; 5588 : 			//MakeUnitDirty (DIRTY_WP_LIST, DDP[89].priority);
; 5589 : 			MakeUnitDirty (DIRTY_WP_LIST, SEND_NOW);

	push	65536					; 00010000H
	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5590 : 		}
; 5591 : 		else {

	jmp	$LN4@MakeWaypoi
$LN2@MakeWaypoi:

; 5592 : 			// Need to send data to the host
; 5593 : 			VuSessionEntity				*target = (VuSessionEntity*) vuDatabase->Find(OwnerId());

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _target$5[ebp], eax

; 5594 : 			FalconFlightPlanMessage		*msg = new FalconFlightPlanMessage(Id(), target);

	push	57					; 00000039H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN6@MakeWaypoi
	push	1
	mov	eax, DWORD PTR _target$5[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0FalconFlightPlanMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconFlightPlanMessage::FalconFlightPlanMessage
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN7@MakeWaypoi
$LN6@MakeWaypoi:
	mov	DWORD PTR tv151[ebp], 0
$LN7@MakeWaypoi:
	mov	ecx, DWORD PTR tv151[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _msg$9[ebp], edx

; 5595 : 			uchar						tmp[1024],*ptr;
; 5596 : 
; 5597 : 			ptr = tmp;

	lea	eax, DWORD PTR _tmp$10[ebp]
	mov	DWORD PTR _ptr$4[ebp], eax

; 5598 : 			msg->dataBlock.size = EncodeWaypoints(&ptr);

	lea	ecx, DWORD PTR _ptr$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncodeWaypoints@UnitClass@@QAEHPAPAE@Z	; UnitClass::EncodeWaypoints
	mov	edx, DWORD PTR _msg$9[ebp]
	mov	DWORD PTR [edx+49], eax

; 5599 : 			msg->dataBlock.type = FalconFlightPlanMessage::waypointData;

	mov	eax, DWORD PTR _msg$9[ebp]
	mov	BYTE PTR [eax+48], 0

; 5600 : 			msg->dataBlock.data = new uchar[msg->dataBlock.size];

	mov	ecx, DWORD PTR _msg$9[ebp]
	mov	edx, DWORD PTR [ecx+49]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	eax, DWORD PTR _msg$9[ebp]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [eax+53], ecx

; 5601 : 			ShiAssert(msg->dataBlock.size < 1024);
; 5602 : 			memcpy(msg->dataBlock.data, tmp, msg->dataBlock.size);

	mov	edx, DWORD PTR _msg$9[ebp]
	mov	eax, DWORD PTR [edx+49]
	push	eax
	lea	ecx, DWORD PTR _tmp$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$9[ebp]
	mov	eax, DWORD PTR [edx+53]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5603 : 			FalconSendMessage(msg, TRUE);

	push	1
	mov	ecx, DWORD PTR _msg$9[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN4@MakeWaypoi:

; 5604 : 		}
; 5605 : 	}
; 5606 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MakeWaypointsDirty@UnitClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?MakeWaypointsDirty@UnitClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1080]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakeWaypointsDirty@UnitClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakeWaypointsDirty@UnitClass@@QAEXXZ ENDP		; UnitClass::MakeWaypointsDirty
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_o$ = 8							; size = 2
?SetOdds@UnitClass@@QAEXF@Z PROC			; UnitClass::SetOdds
; _this$ = ecx

; 5569 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5570 : 	odds = o;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _o$[ebp]
	mov	WORD PTR [eax+230], cx

; 5571 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetOdds@UnitClass@@QAEXF@Z ENDP			; UnitClass::SetOdds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 2
?SetReinforcement@UnitClass@@QAEXF@Z PROC		; UnitClass::SetReinforcement
; _this$ = ecx

; 5559 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5560 : 	reinforcement = r;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _r$[ebp]
	mov	WORD PTR [eax+228], cx

; 5561 : 	MakeUnitDirty (DIRTY_REINFORCEMENT, SEND_EVENTUALLY);

	push	1
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5562 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetReinforcement@UnitClass@@QAEXF@Z ENDP		; UnitClass::SetReinforcement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nid$ = 8						; size = 2
?SetNameId@UnitClass@@QAEXF@Z PROC			; UnitClass::SetNameId
; _this$ = ecx

; 5550 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5551 : 	name_id = nid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _nid$[ebp]
	mov	WORD PTR [eax+226], cx

; 5552 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetNameId@UnitClass@@QAEXF@Z ENDP			; UnitClass::SetNameId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cw$ = 8						; size = 2
?SetCurrentWaypoint@UnitClass@@QAEXG@Z PROC		; UnitClass::SetCurrentWaypoint
; _this$ = ecx

; 5404 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5405 : #ifdef DEBUG
; 5406 : 	WayPoint	tw = wp_list;
; 5407 : 	int       i=cw;
; 5408 : 	while (i && tw)
; 5409 : 	{
; 5410 : 		tw = tw->GetNextWP();
; 5411 : 		i--;
; 5412 : 	}
; 5413 : 	ShiAssert(i==0);
; 5414 : 	if (!cw)
; 5415 : 		ShiAssert(!IsFlight());
; 5416 : #endif
; 5417 : 	current_wp = cw;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _cw$[ebp]
	mov	WORD PTR [eax+224], cx

; 5418 : 	//MakeUnitDirty (DIRTY_WAYPOINT, DDP[79].priority);
; 5419 : 	MakeUnitDirty (DIRTY_WAYPOINT, SEND_NOW);

	push	65536					; 00010000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5420 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCurrentWaypoint@UnitClass@@QAEXG@Z ENDP		; UnitClass::SetCurrentWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 1
?SetTactic@UnitClass@@QAEXE@Z PROC			; UnitClass::SetTactic
; _this$ = ecx

; 5540 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5541 : 	tactic = t;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+222], cl

; 5542 : 	MakeUnitDirty (DIRTY_TACTIC, SEND_EVENTUALLY);

	push	1
	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5543 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTactic@UnitClass@@QAEXE@Z ENDP			; UnitClass::SetTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 1
?SetLosses@UnitClass@@QAEXE@Z PROC			; UnitClass::SetLosses
; _this$ = ecx

; 5531 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5532 : 	losses = l;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _l$[ebp]
	mov	BYTE PTR [eax+221], cl

; 5533 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLosses@UnitClass@@QAEXE@Z ENDP			; UnitClass::SetLosses
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m$ = 8							; size = 1
?SetMoved@UnitClass@@QAEXE@Z PROC			; UnitClass::SetMoved
; _this$ = ecx

; 5521 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5522 : 	moved = m;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _m$[ebp]
	mov	BYTE PTR [eax+220], cl

; 5523 : 	MakeUnitDirty (DIRTY_MOVED, SEND_EVENTUALLY);

	push	1
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5524 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoved@UnitClass@@QAEXE@Z ENDP			; UnitClass::SetMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_tid$ = 8						; size = 8
?SetTargetId@UnitClass@@QAEXVVU_ID@@@Z PROC		; UnitClass::SetTargetId
; _this$ = ecx

; 5511 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5512 : 	target_id = tid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tid$[ebp]
	mov	DWORD PTR [eax+212], ecx
	mov	edx, DWORD PTR _tid$[ebp+4]
	mov	DWORD PTR [eax+216], edx

; 5513 : 	MakeUnitDirty (DIRTY_TARGET_ID, SEND_EVENTUALLY);

	push	1
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5514 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTargetId@UnitClass@@QAEXVVU_ID@@@Z ENDP		; UnitClass::SetTargetId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cid$ = 8						; size = 8
?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z PROC		; UnitClass::SetCargoId
; _this$ = ecx

; 5501 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5502 : 	cargo_id = cid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cid$[ebp]
	mov	DWORD PTR [eax+204], ecx
	mov	edx, DWORD PTR _cid$[ebp+4]
	mov	DWORD PTR [eax+208], edx

; 5503 : 	MakeUnitDirty (DIRTY_CARGO_ID, SEND_EVENTUALLY);

	push	1
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5504 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetCargoId@UnitClass@@QAEXVVU_ID@@@Z ENDP		; UnitClass::SetCargoId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_y$ = 8							; size = 2
?SetDestY@UnitClass@@QAEXF@Z PROC			; UnitClass::SetDestY
; _this$ = ecx

; 5491 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5492 : 	dest_y = y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _y$[ebp]
	mov	WORD PTR [eax+202], cx

; 5493 : 	MakeUnitDirty (DIRTY_DESTINATION, SEND_EVENTUALLY);

	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5494 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDestY@UnitClass@@QAEXF@Z ENDP			; UnitClass::SetDestY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetDestX@UnitClass@@QAEXF@Z PROC			; UnitClass::SetDestX
; _this$ = ecx

; 5481 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5482 : 	dest_x = x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+200], cx

; 5483 : 	MakeUnitDirty (DIRTY_DESTINATION, SEND_EVENTUALLY);

	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5484 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDestX@UnitClass@@QAEXF@Z ENDP			; UnitClass::SetDestX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
?SetUnitFlags@UnitClass@@QAEXJ@Z PROC			; UnitClass::SetUnitFlags
; _this$ = ecx

; 5468 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5469 : 	if (unit_flags != f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	cmp	ecx, DWORD PTR _f$[ebp]
	je	SHORT $LN2@SetUnitFla

; 5470 : 	{
; 5471 : 		unit_flags = f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR [edx+196], eax

; 5472 : 		MakeUnitDirty (DIRTY_UNIT_FLAGS, SEND_EVENTUALLY);

	push	1
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty
$LN2@SetUnitFla:

; 5473 : 	}
; 5474 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitFlags@UnitClass@@QAEXJ@Z ENDP			; UnitClass::SetUnitFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 4
?SetRoster@UnitClass@@QAEXJ@Z PROC			; UnitClass::SetRoster
; _this$ = ecx

; 5458 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5459 : 	roster = r;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+192], ecx

; 5460 : 	MakeUnitDirty (DIRTY_ROSTER, SEND_EVENTUALLY);

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeUnitDirty@UnitClass@@QAEXW4Dirty_Unit@@W4Dirtyness@@@Z ; UnitClass::MakeUnitDirty

; 5461 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRoster@UnitClass@@QAEXJ@Z ENDP			; UnitClass::SetRoster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\unit.cpp
_TEXT	SEGMENT
_randFactor$ = -16					; size = 4
_tenSecs$ = -12						; size = 4
_this$ = -8						; size = 4
_max$ = -4						; size = 4
_t$ = 8							; size = 4
?SetLastCheck@UnitClass@@QAEXK@Z PROC			; UnitClass::SetLastCheck
; _this$ = ecx

; 5426 : void UnitClass::SetLastCheck(CampaignTime t){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 5427 : 	last_check = t;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 5428 : #if HOTSPOT_FIX
; 5429 : 	CampaignTime max = MaxUpdateTime();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+528]
	call	edx
	mov	DWORD PTR _max$[ebp], eax

; 5430 : 	int randFactor;
; 5431 : 	CampaignTime tenSecs = 10*CampaignSeconds;

	mov	DWORD PTR _tenSecs$[ebp], 10000		; 00002710H

; 5432 : 	if (max <= tenSecs){

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, DWORD PTR _tenSecs$[ebp]
	ja	SHORT $LN2@SetLastChe

; 5433 : 		// somwhere between -max/2 and max/2
; 5434 : 		randFactor = (rand() % max) - (max / 2);

	call	_rand
	xor	edx, edx
	div	DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR _max$[ebp]
	shr	ecx, 1
	sub	edx, ecx
	mov	DWORD PTR _randFactor$[ebp], edx

; 5435 : 	}
; 5436 : 	else {

	jmp	SHORT $LN1@SetLastChe
$LN2@SetLastChe:

; 5437 : 		// somewhere between max - 5 and max + 5 
; 5438 : 		randFactor = (rand() % tenSecs) - (tenSecs / 2);

	call	_rand
	xor	edx, edx
	div	DWORD PTR _tenSecs$[ebp]
	mov	eax, DWORD PTR _tenSecs$[ebp]
	shr	eax, 1
	sub	edx, eax
	mov	DWORD PTR _randFactor$[ebp], edx
$LN1@SetLastChe:

; 5439 : 	}
; 5440 : 	update_interval = max + randFactor;

	mov	ecx, DWORD PTR _max$[ebp]
	add	ecx, DWORD PTR _randFactor$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], ecx

; 5441 : #endif
; 5442 : 	//	MakeUnitDirty (DIRTY_LAST_CHECK, SEND_WHENEVER);
; 5443 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLastCheck@UnitClass@@QAEXK@Z ENDP			; UnitClass::SetLastCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetNameId@UnitClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNameId@UnitClass@@QAEFXZ PROC			; UnitClass::GetNameId, COMDAT
; _this$ = ecx

; 157  : 	short GetNameId (void)				{ return name_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+226]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNameId@UnitClass@@QAEFXZ ENDP			; UnitClass::GetNameId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetCurrentWaypoint@UnitClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentWaypoint@UnitClass@@QAEGXZ PROC		; UnitClass::GetCurrentWaypoint, COMDAT
; _this$ = ecx

; 156  : 	ushort GetCurrentWaypoint (void)	{ return current_wp; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+224]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentWaypoint@UnitClass@@QAEGXZ ENDP		; UnitClass::GetCurrentWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTactic@UnitClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTactic@UnitClass@@QAEEXZ PROC			; UnitClass::GetTactic, COMDAT
; _this$ = ecx

; 155  : 	uchar GetTactic (void)				{ return tactic; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+222]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTactic@UnitClass@@QAEEXZ ENDP			; UnitClass::GetTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLosses@UnitClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLosses@UnitClass@@QAEEXZ PROC			; UnitClass::GetLosses, COMDAT
; _this$ = ecx

; 154  : 	uchar GetLosses (void)				{ return losses; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+221]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLosses@UnitClass@@QAEEXZ ENDP			; UnitClass::GetLosses
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetMoved@UnitClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMoved@UnitClass@@QAEEXZ PROC			; UnitClass::GetMoved, COMDAT
; _this$ = ecx

; 153  : 	uchar GetMoved (void)				{ return moved; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+220]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoved@UnitClass@@QAEEXZ ENDP			; UnitClass::GetMoved
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTargetId@UnitClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTargetId@UnitClass@@QAE?AVVU_ID@@XZ PROC		; UnitClass::GetTargetId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID GetTargetId (void)			{ return target_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	edx, DWORD PTR [eax+216]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTargetId@UnitClass@@QAE?AVVU_ID@@XZ ENDP		; UnitClass::GetTargetId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetDestY@UnitClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDestY@UnitClass@@QAEFXZ PROC			; UnitClass::GetDestY, COMDAT
; _this$ = ecx

; 150  : 	GridIndex GetDestY (void)			{ return dest_y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+202]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDestY@UnitClass@@QAEFXZ ENDP			; UnitClass::GetDestY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetDestX@UnitClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDestX@UnitClass@@QAEFXZ PROC			; UnitClass::GetDestX, COMDAT
; _this$ = ecx

; 149  : 	GridIndex GetDestX (void)			{ return dest_x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+200]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDestX@UnitClass@@QAEFXZ ENDP			; UnitClass::GetDestX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitFlags@UnitClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitFlags@UnitClass@@QAEJXZ PROC			; UnitClass::GetUnitFlags, COMDAT
; _this$ = ecx

; 148  : 	fourbyte GetUnitFlags (void)		{ return unit_flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitFlags@UnitClass@@QAEJXZ ENDP			; UnitClass::GetUnitFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetRoster@UnitClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoster@UnitClass@@QAEJXZ PROC			; UnitClass::GetRoster, COMDAT
; _this$ = ecx

; 147  : 	fourbyte GetRoster (void)			{ return roster; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRoster@UnitClass@@QAEJXZ ENDP			; UnitClass::GetRoster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetLastCheck@UnitClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastCheck@UnitClass@@QAEKXZ PROC			; UnitClass::GetLastCheck, COMDAT
; _this$ = ecx

; 146  : 	CampaignTime GetLastCheck (void)	{ return last_check; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastCheck@UnitClass@@QAEKXZ ENDP			; UnitClass::GetLastCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\cmpclass.h
;	COMDAT ?IsOnline@CampaignClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOnline@CampaignClass@@QAEHXZ PROC			; CampaignClass::IsOnline, COMDAT
; _this$ = ecx

; 181  : 	int IsOnline (void)										{ return Flags & CAMP_ONLINE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	and	eax, 512				; 00000200H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsOnline@CampaignClass@@QAEHXZ ENDP			; CampaignClass::IsOnline
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\loadout.h
;	COMDAT ??0LoadoutStruct@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0LoadoutStruct@@QAE@XZ PROC				; LoadoutStruct::LoadoutStruct, COMDAT
; _this$ = ecx

; 32   : 		LoadoutStruct(void)		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 		{ 
; 34   : 			memset(WeaponID,	0,	(sizeof(short) * HARDPOINT_MAX)); 

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 35   : 			memset(WeaponCount,	0,	(sizeof(uchar) * HARDPOINT_MAX)); 

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0LoadoutStruct@@QAE@XZ ENDP				; LoadoutStruct::LoadoutStruct
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0SimInitDataClass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SimInitDataClass@@QAE@XZ PROC			; SimInitDataClass::SimInitDataClass, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SimInitDataClass@@QAE@XZ ENDP			; SimInitDataClass::SimInitDataClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?SetSpottedTime@CampBaseClass@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetSpottedTime@CampBaseClass@@QAEXK@Z PROC		; CampBaseClass::SetSpottedTime, COMDAT
; _this$ = ecx

; 299  : 	void SetSpottedTime (CampaignTime t)		{	spotTime = t; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+144], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpottedTime@CampBaseClass@@QAEXK@Z ENDP		; CampBaseClass::SetSpottedTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSPType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSPType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSPType, COMDAT
; _this$ = ecx

; 291  : 	uchar GetSPType (void) const						{	return (EntityType())->classInfo_[VU_SPTYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 2
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSPType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSPType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_e$ = 8							; size = 4
?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z PROC	; CampBaseClass::HasEntity, COMDAT
; _this$ = ecx

; 281  : 	virtual int HasEntity(VuEntity *e) const    {   

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		return ((components && (components->Find(e) != NULL)) || (this == e)); 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+160], 0
	je	SHORT $LN3@HasEntity
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?Find@VuCollection@@QBE_NPAVVuEntity@@@Z ; VuCollection::Find
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@HasEntity
$LN3@HasEntity:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	je	SHORT $LN4@HasEntity
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN5@HasEntity
$LN4@HasEntity:
	mov	DWORD PTR tv81[ebp], 1
$LN5@HasEntity:
	mov	eax, DWORD PTR tv81[ebp]

; 283  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?HasEntity@CampBaseClass@@UBEHPAVVuEntity@@@Z ENDP	; CampBaseClass::HasEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?InSimLists@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InSimLists@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::InSimLists, COMDAT
; _this$ = ecx

; 275  : 	int InSimLists (void)						{	return local_flags & CBC_IN_SIM_LIST; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
?InSimLists@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::InSimLists
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAwake@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 273  : 	int IsAwake (void)							{	return local_flags & CBC_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsEmitting@CampBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@CampBaseClass@@UAEHXZ PROC			; CampBaseClass::IsEmitting, COMDAT
; _this$ = ecx

; 269  : 	virtual int IsEmitting (void)				{	return base_flags & CBC_EMITTING; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+150]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@CampBaseClass@@UAEHXZ ENDP			; CampBaseClass::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsCampBase@CampBaseClass@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCampBase@CampBaseClass@@UAE_NXZ PROC			; CampBaseClass::IsCampBase, COMDAT
; _this$ = ecx

; 268  : 	virtual bool IsCampBase() { return true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampBase@CampBaseClass@@UAE_NXZ ENDP			; CampBaseClass::IsCampBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetMissilesFlying@CampBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMissilesFlying@CampBaseClass@@UAEHXZ PROC		; CampBaseClass::GetMissilesFlying, COMDAT
; _this$ = ecx

; 249  : 	virtual int GetMissilesFlying (void)				{ return 0; } // MLR 10/3/2004 - finishing what //me123 started

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMissilesFlying@CampBaseClass@@UAEHXZ ENDP		; CampBaseClass::GetMissilesFlying
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?StepRadar@CampBaseClass@@UAEHHHM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
_d$ = 12						; size = 4
_range$ = 16						; size = 4
?StepRadar@CampBaseClass@@UAEHHHM@Z PROC		; CampBaseClass::StepRadar, COMDAT
; _this$ = ecx

; 240  : 	virtual int StepRadar (int t,int d, float range)								{	return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StepRadar@CampBaseClass@@UAEHHHM@Z ENDP		; CampBaseClass::StepRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCountry@CampBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCountry@CampBaseClass@@UAEEXZ PROC			; CampBaseClass::GetCountry, COMDAT
; _this$ = ecx

; 239  : 	virtual uchar GetCountry (void)								{	return owner; }		// New FalcEnt friendly form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCountry@CampBaseClass@@UAEEXZ ENDP			; CampBaseClass::GetCountry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetTeam@CampBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeam@CampBaseClass@@UAEEXZ PROC			; CampBaseClass::GetTeam, COMDAT
; _this$ = ecx

; 238  : 	virtual uchar GetTeam (void)								{	return ::GetTeam(owner); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+154]
	push	ecx
	call	?GetTeam@@YAEE@Z			; GetTeam
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeam@CampBaseClass@@UAEEXZ ENDP			; CampBaseClass::GetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCampID@CampBaseClass@@UAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampID@CampBaseClass@@UAEFXZ PROC			; CampBaseClass::GetCampID, COMDAT
; _this$ = ecx

; 237  : 	virtual short GetCampID (void)								{	return camp_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampID@CampBaseClass@@UAEFXZ ENDP			; CampBaseClass::GetCampID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?OnGround@CampBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnGround@CampBaseClass@@UAEHXZ PROC			; CampBaseClass::OnGround, COMDAT
; _this$ = ecx

; 236  : 	virtual int OnGround (void)									{	return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGround@CampBaseClass@@UAEHXZ ENDP			; CampBaseClass::OnGround
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ PROC	; CampBaseClass::GetDeagOwner, COMDAT
; _this$ = ecx

; 142  : 	VU_ID GetDeagOwner() const					{	return deag_owner; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDeagOwner@CampBaseClass@@QBE?AVVU_ID@@XZ ENDP	; CampBaseClass::GetDeagOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ PROC ; CampBaseClass::GetComponents, COMDAT
; _this$ = ecx

; 141  : 	TailInsertList *GetComponents() const		{	return components; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ENDP ; CampBaseClass::GetComponents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCampId@CampBaseClass@@QBEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampId@CampBaseClass@@QBEFXZ PROC			; CampBaseClass::GetCampId, COMDAT
; _this$ = ecx

; 139  : 	short GetCampId() const						{	return camp_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampId@CampBaseClass@@QBEFXZ ENDP			; CampBaseClass::GetCampId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetBaseFlags@CampBaseClass@@QBEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBaseFlags@CampBaseClass@@QBEFXZ PROC		; CampBaseClass::GetBaseFlags, COMDAT
; _this$ = ecx

; 138  : 	short GetBaseFlags() const 					{	return base_flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+150]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseFlags@CampBaseClass@@QBEFXZ ENDP		; CampBaseClass::GetBaseFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSpotted@CampBaseClass@@QBEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpotted@CampBaseClass@@QBEFXZ PROC			; CampBaseClass::GetSpotted, COMDAT
; _this$ = ecx

; 137  : 	short GetSpotted() const 					{	return spotted; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpotted@CampBaseClass@@QBEFXZ ENDP			; CampBaseClass::GetSpotted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSpotTime@CampBaseClass@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpotTime@CampBaseClass@@QBEKXZ PROC			; CampBaseClass::GetSpotTime, COMDAT
; _this$ = ecx

; 136  : 	CampaignTime GetSpotTime() const			{	return spotTime; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpotTime@CampBaseClass@@QBEKXZ ENDP			; CampBaseClass::GetSpotTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ?memcpychk@@YAXPAXPAPAEIPAJ@Z
_TEXT	SEGMENT
$T2 = -152						; size = 12
_s$3 = -140						; size = 24
_err$4 = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_rem$ = 20						; size = 4
?memcpychk@@YAXPAXPAPAEIPAJ@Z PROC			; memcpychk, COMDAT

; 25   : inline void memcpychk(void *dst, VU_BYTE **src, size_t size, long *rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 26   : 	if ((size_t)*rem < size){

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN1@memcpychk

; 27   : 		char err[100];
; 28   : 		sprintf(err, "Trying to write %lu bytes to %ld buffer", static_cast<unsigned long>(size), *rem);

	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
	lea	edx, DWORD PTR _err$4[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 29   : 		std::string s(err);

	lea	eax, DWORD PTR _err$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 30   : 		throw InvalidBufferException(s);

	lea	ecx, DWORD PTR _s$3[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
	push	OFFSET __TI4?AVInvalidBufferException@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 31   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@memcpychk:

; 32   : 	memcpy(dst, *src, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 33   : 	*rem -= size;

	mov	ecx, DWORD PTR _rem$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [eax], edx

; 34   : 	*src += size;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax], edx
$LN3@memcpychk:

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0:
	lea	ecx, DWORD PTR _s$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?memcpychk@@YAXPAXPAPAEIPAJ@Z ENDP			; memcpychk
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidBufferException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidBufferException@@UAEPAXI@Z PROC		; InvalidBufferException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidBufferException@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidBufferException@@UAEPAXI@Z ENDP		; InvalidBufferException::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0InvalidBufferException@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV0@@Z PROC		; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV0@@Z ENDP		; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1InvalidBufferException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InvalidBufferException@@UAE@XZ PROC			; InvalidBufferException::~InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1InvalidBufferException@@UAE@XZ ENDP			; InvalidBufferException::~InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx

; 19   : 	InvalidBufferException(const std::string &msg) : out_of_range(msg){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPLocation@WayPointClass@@QBEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetWPLocation@WayPointClass@@QBEXPAF0@Z PROC		; WayPointClass::GetWPLocation, COMDAT
; _this$ = ecx

; 205  : 	void GetWPLocation (GridIndex* x, GridIndex* y) const { *x = GridX; *y = GridY; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetWPLocation@WayPointClass@@QBEXPAF0@Z ENDP		; WayPointClass::GetWPLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPArrivalTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPArrivalTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPArrivalTime, COMDAT
; _this$ = ecx

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPArrivalTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPArrivalTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPTargetID@WayPointClass@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetWPTargetID@WayPointClass@@QAE?AVVU_ID@@XZ PROC	; WayPointClass::GetWPTargetID, COMDAT
; _this$ = ecx

; 167  : 	VU_ID GetWPTargetID (void)						{ return TargetID; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetWPTargetID@WayPointClass@@QAE?AVVU_ID@@XZ ENDP	; WayPointClass::GetWPTargetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetSEARCHtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSEARCHtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetSEARCHtimer, COMDAT
; _this$ = ecx

; 198  : 	virtual VU_TIME GetSEARCHtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSEARCHtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetAQUIREtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAQUIREtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetAQUIREtimer, COMDAT
; _this$ = ecx

; 197  : 	virtual VU_TIME GetAQUIREtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAQUIREtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetStepSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetStepSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetStepSearchMode, COMDAT
; _this$ = ecx

; 196  : 	virtual void SetStepSearchMode(uchar)					{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStepSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetStepSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSEARCHtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetSEARCHtimer, COMDAT
; _this$ = ecx

; 194  : 	virtual void SetSEARCHtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetAQUIREtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetAQUIREtimer, COMDAT
; _this$ = ecx

; 193  : 	virtual void SetAQUIREtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetAltitude@FalconEntity@@QBEHXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?GetAltitude@FalconEntity@@QBEHXZ PROC			; FalconEntity::GetAltitude, COMDAT
; _this$ = ecx

; 169  : 	int GetAltitude() const						{ return FloatToInt32(ZPos() * -1.0F); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv76[ebp]
	movss	xmm0, DWORD PTR tv76[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAltitude@FalconEntity@@QBEHXZ ENDP			; FalconEntity::GetAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::HasAreaJamming, COMDAT
; _this$ = ecx

; 162  : 	virtual int HasAreaJamming (void)			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::HasAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::HasSPJamming, COMDAT
; _this$ = ecx

; 161  : 	virtual int HasSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::HasSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsAreaJamming, COMDAT
; _this$ = ecx

; 160  : 	virtual int IsAreaJamming (void)            { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSPJamming, COMDAT
; _this$ = ecx

; 159  : 	virtual int IsSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTaskForce@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTaskForce@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTaskForce, COMDAT
; _this$ = ecx

; 158  : 	virtual int IsTaskForce (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTaskForce@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTaskForce
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTeam@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeam@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTeam, COMDAT
; _this$ = ecx

; 157  : 	virtual int IsTeam (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeam@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPackage@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPackage@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsPackage, COMDAT
; _this$ = ecx

; 156  : 	virtual int IsPackage (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPackage@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSquadron@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSquadron@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSquadron, COMDAT
; _this$ = ecx

; 155  : 	virtual int IsSquadron (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSquadron@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsFlight@FalconEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlight@FalconEntity@@UBEHXZ PROC			; FalconEntity::IsFlight, COMDAT
; _this$ = ecx

; 154  : 	virtual int IsFlight() const				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlight@FalconEntity@@UBEHXZ ENDP			; FalconEntity::IsFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBrigade@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrigade@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBrigade, COMDAT
; _this$ = ecx

; 153  : 	virtual int IsBrigade (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrigade@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBrigade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBattalion@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBattalion@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBattalion, COMDAT
; _this$ = ecx

; 152  : 	virtual int IsBattalion (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBattalion@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBattalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsObjective@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjective@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsObjective, COMDAT
; _this$ = ecx

; 151  : 	virtual int IsObjective (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsObjective@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ PROC	; FalconEntity::GetMovementType, COMDAT
; _this$ = ecx

; 149  : 	virtual MoveType GetMovementType (void)		{ return NoMove; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ ENDP	; FalconEntity::GetMovementType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsDead@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsDead, COMDAT
; _this$ = ecx

; 144  : 	virtual int IsDead (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsExploding@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExploding@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsExploding, COMDAT
; _this$ = ecx

; 143  : 	virtual int IsExploding (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExploding@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsExploding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsWeapon@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWeapon@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsWeapon, COMDAT
; _this$ = ecx

; 142  : 	virtual int IsWeapon (void)   				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWeapon@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsShip@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShip@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsShip, COMDAT
; _this$ = ecx

; 141  : 	virtual int IsShip (void) 			        { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShip@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGroundVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGroundVehicle@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsGroundVehicle, COMDAT
; _this$ = ecx

; 140  : 	virtual int IsGroundVehicle (void) 			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGroundVehicle@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsGroundVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAirplane@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirplane@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsAirplane, COMDAT
; _this$ = ecx

; 139  : 	virtual int IsAirplane (void)	   			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirplane@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsAirplane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEject@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEject@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEject, COMDAT
; _this$ = ecx

; 138  : 	virtual int IsEject (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEject@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsHelicopter@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHelicopter@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsHelicopter, COMDAT
; _this$ = ecx

; 137  : 	virtual int IsHelicopter (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHelicopter@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsHelicopter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsStatic@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStatic@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsStatic, COMDAT
; _this$ = ecx

; 136  : 	virtual int IsStatic (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStatic@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsStatic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsVehicle@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsVehicle, COMDAT
; _this$ = ecx

; 135  : 	virtual int IsVehicle (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVehicle@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMover@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMover@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMover, COMDAT
; _this$ = ecx

; 134  : 	virtual int IsMover (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGun@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGun@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsGun, COMDAT
; _this$ = ecx

; 133  : 	virtual int IsGun (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGun@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBomb@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBomb@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBomb, COMDAT
; _this$ = ecx

; 132  : 	virtual int IsBomb (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBomb@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsLauncher@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsLauncher, COMDAT
; _this$ = ecx

; 131  : 	virtual int IsLauncher (void)               { return FALSE; } // MLR 3/4/2004 - rocket pods

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMissile@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMissile@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMissile, COMDAT
; _this$ = ecx

; 130  : 	virtual int IsMissile (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMissile@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?CombatClass@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatClass@FalconEntity@@UAEHXZ PROC			; FalconEntity::CombatClass, COMDAT
; _this$ = ecx

; 127  : 	virtual int CombatClass (void)				{ return 999; } // 2002-02-25 ADDED BY S.G. No combat class for non flight or non aircraft class

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 999				; 000003e7H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatClass@FalconEntity@@UAEHXZ ENDP			; FalconEntity::CombatClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetSearchMode, COMDAT
; _this$ = ecx

; 126  : 	virtual void SetSearchMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?ReturnToSearch@FalconEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReturnToSearch@FalconEntity@@UAEXXZ PROC		; FalconEntity::ReturnToSearch, COMDAT
; _this$ = ecx

; 124  : 	virtual void ReturnToSearch (void)			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReturnToSearch@FalconEntity@@UAEXXZ ENDP		; FalconEntity::ReturnToSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetRadarMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetRadarMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetRadarMode, COMDAT
; _this$ = ecx

; 123  : 	virtual void SetRadarMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRadarMode@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@FalconEntity@@UAEHXZ PROC			; FalconEntity::GetRadarMode, COMDAT
; _this$ = ecx

; 121  : 	virtual int GetRadarMode (void)				{ return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@FalconEntity@@UAEHXZ ENDP			; FalconEntity::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampaign@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsCampaign@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsCampaign, COMDAT
; _this$ = ecx

; 101  : 		{return (falconType & FalconCampaignEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 1
	je	SHORT $LN3@IsCampaign
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsCampaign
$LN3@IsCampaign:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsCampaign:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampaign@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSimBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSimBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsSimBase, COMDAT
; _this$ = ecx

; 98   : 	virtual bool IsSimBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSimBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsSimBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ PROC	; VuBin<VuEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ENDP	; VuBin<VuEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@PBD@Z		; std::logic_error::logic_error
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 146  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1717 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1718 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1719 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 38   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@

; 39   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ PROC		; VuEntity::VuState, COMDAT
; _this$ = ecx

; 153  : 	VU_MEM VuState() const    { return vuState_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ ENDP		; VuEntity::VuState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::OwnerId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID OwnerId() const     { return share_.ownerId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::OwnerId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sc$ = 8						; size = 4
?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z PROC	; VuEntity::SetSendCreate, COMDAT
; _this$ = ecx

; 148  : 	void SetSendCreate(VU_SEND_TYPE sc) { share_.flags_.breakdown_.sendCreate_ = sc; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _sc$[ebp]
	and	eax, 3
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -193				; ffffff3fH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ENDP	; VuEntity::SetSendCreate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??BVU_ID@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVU_ID@@QBEKXZ PROC					; VU_ID::operator unsigned long, COMDAT
; _this$ = ecx

; 162  : 	operator VU_KEY() const { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??BVU_SESSION_ID@@QBEKXZ		; VU_SESSION_ID::operator unsigned long
	movzx	eax, ax
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx]
	or	eax, edx

; 164  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVU_ID@@QBEKXZ ENDP					; VU_ID::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??9VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator!=, COMDAT
; _this$ = ecx

; 111  : 	bool operator != (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 1
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 1
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??BVU_SESSION_ID@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVU_SESSION_ID@@QBEKXZ PROC				; VU_SESSION_ID::operator unsigned long, COMDAT
; _this$ = ecx

; 79   : 	operator unsigned long() const { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		return (unsigned long) value_; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVU_SESSION_ID@@QBEKXZ ENDP				; VU_SESSION_ID::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_SESSION_ID@@QAE@XZ PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 52   : 	VU_SESSION_ID() : value_(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_SESSION_ID@@QAE@XZ ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tchar.h
;	COMDAT __tcsnccpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsnccpy PROC						; COMDAT

; 1809 : {

	push	ebp
	mov	ebp, esp

; 1810 : #pragma warning(push)
; 1811 : #pragma warning(disable:4996)
; 1812 :     return (char *)_mbsncpy((unsigned char *)_Dst,(const unsigned char *)_Source, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Source$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dst$[ebp]
	push	edx
	call	__mbsncpy
	add	esp, 12					; 0000000cH

; 1813 : #pragma warning(pop)
; 1814 : }

	pop	ebp
	ret	0
__tcsnccpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
